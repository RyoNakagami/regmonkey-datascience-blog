---
title: "å¾®åˆ†æ–¹ç¨‹å¼ã‚’ç”¨ã„ãŸToy models"
author: "Ryo Nakagami"
date: "2025-01-30"
categories: [å¾®åˆ†æ–¹ç¨‹å¼]
listing_category: math-general
comments:
  utterances:
       repo: RyoNakagami/regmonkey-datascience-blog
       label: discussion
       issue-term: title
abstract: First order linear differential equationã‚’ç”¨ã„ãŸãƒ¢ãƒ‡ãƒªãƒ³ã‚°ä¾‹ã‚’ç´¹ä»‹
---

## ãƒãƒ«ã‚µã‚¹ãƒ¢ãƒ‡ãƒ«

<div class="blog-custom-border">
::: {#exr- .custom_problem }
: ãƒãƒ«ã‚µã‚¹ã®äººå£è«–
<br>

æ™‚åˆ» $t$ ã«ãŠã‘ã‚‹ã¨ã‚ã‚‹å›½ã®äººå£ãŒ $N(t) > 0$ ã§è¡¨ã•ã‚Œã‚‹ã¨ã™ã‚‹ï¼ãƒãƒ«ã‚µã‚¹ã¯æ™‚åˆ» $t$ ã‹ã‚‰ $t+\Delta t$ ã®äººå£å¢—åˆ† $\Delta N = N(t+\Delta) - N(t)$ ã¯

$$
\Delta N = k N(t)\Delta t \qquad (k: \text{constant})
$$

ã®ã‚ˆã†ã« $N, \Delta t$ ã«æ¯”ä¾‹ã™ã‚‹ã¨ã—ãŸï¼ã“ã“ã‹ã‚‰ä»¥ä¸‹ã®ã‚ˆã†ã«å¼å¤‰å½¢ã‚’è¡Œã„

$$
\frac{\Delta N}{\Delta t} = k N(t)
$$

$\Delta t\to 0$ ã¨ã—ã¦æ¬¡ã®ã‚ˆã†ãªå¾®åˆ†æ–¹ç¨‹å¼ã‚’å¾—ãŸã¨ã—ã¾ã™

$$
\frac{dN(t)}{dt} = kN(t) \label{eq-de-01}
$$


$(t, N(t))$ ãŒ $(0, 1.00 \times 10^8), (1, 1.25 \times 10^8)$ ã¨ä¸ãˆã‚‰ã‚Œã¦ã„ã‚‹ã¨ãï¼Œ$t = 2$ ã®äººå£ $N(2)$ ã‚’æ¨å®šã›ã‚ˆï¼

:::

</div>

<!--::: {.callout-note collapse="true" icon=false}-->
::: {.callout-note collapse="false" icon=false}
## Solution

å¾®åˆ†æ–¹ç¨‹å¼ \eqref{eq-de-01} ã‚’ä»¥ä¸‹ã®ã‚ˆã†ã«å¤‰å½¢ã—ç©åˆ†ã™ã‚‹ã¨

$$
\begin{align}
&\frac{dN(t)}{dt} = kN(t) \\
&\Rightarrow \int \frac{1}{N(t)}\frac{dN(t)}{dt} dt= \int k dt \\
&\Rightarrow \log \vert N(t) \vert = kt + C\\[5pt]
&\Rightarrow \log N(t) = kt + C
\end{align}
$$

å¾“ã£ã¦ï¼Œ

$$
N(t) = \exp(C + kt) = \tilde C\exp(kt)
$$

$t = 0$ ã®ã¨ãã® $N(0) = N_0$ ã¨ã™ã‚‹ã¨ï¼Œ$\tilde C = N_0$ ã§ãªã‘ã‚Œã°ãªã‚‰ãªã„ã®ã§

$$
N(t) = N_0\exp(kt) \label{eq-malthus-solution}
$$

$(t, N(t))$ ãŒ $(0, 1.00 \times 10^8), (1, 1.25 \times 10^8)$ ã¨ä¸ãˆã‚‰ã‚Œã¦ã„ã‚‹ã®ã§ï¼Œ

$$
N_0 = 1.00 \times 10^8
$$

æ¬¡ã«

$$
\begin{align}
&N(1) = 1.00 \times 10^8 \exp(k)\\[5pt]
&\Rightarrow \exp(k) = 1.25
\end{align}
$$

å¾“ã£ã¦ï¼Œ

$$
N(2) = (1.25)^2 \times 10^8 \approx 1.56 \times 10^8
$$

:::

<strong > &#9654;&nbsp; Python Simulation</strong>

`scipy.integrate`ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã®`odeint`ã‚’ç”¨ã„ã‚Œã°å¾®åˆ†æ–¹ç¨‹å¼ã‚’è§£ãã“ã¨ãŒã§ãã¾ã™ï¼

::: {#fig-plot .center}
```{python}
#| code-fold: show
import numpy as np
from scipy.integrate import odeint
import matplotlib.pyplot as plt

# malthusian growth func
def malthusian_model(y, t, k=np.log(1.25)):
    dydt = k * y
    return dydt

# init
N_0 = 1.0

# data point
data = (0, 1), (1, 1.25)

# time
t = np.linspace(0, 5, 21)

# solve
n = odeint(malthusian_model, N_0, t)

# plot
plt.plot(t, n)
plt.scatter(*zip(*data), color='red', label='observed data points')
plt.legend()
plt.xlabel("t")
plt.ylabel("$N(t)$")
plt.title("Malthusian gwrowth simulation")
plt.show()
```
:::

@fig-plot ã‚’ã¿ã‚‹ã¨ $N(t)$ ã¯æŒ‡æ•°é–¢æ•°çš„ã«å¢—åŠ ã—ã¦ã„ã‚‹ã“ã¨ãŒèª­ã¿å–ã‚Œã¾ã™ï¼ã“ã‚Œã¯ $k$ ã®ç¬¦å·ã«ä¾å­˜ã—ã¦ã„ã¾ã™ï¼

- $k > 0$: æŒ‡æ•°é–¢æ•°çš„å¢—åŠ 
- $k = 0$: å¤‰åŒ–ãªã—
- $k < 0$: æŒ‡æ•°é–¢æ•°çš„æ¸›è¡°

ã¨ãªã‚Šã¾ã™ï¼å›³ç¤ºã™ã‚‹ã¨ä»¥ä¸‹ã®ã‚ˆã†ã«ãªã‚Šã¾ã™

::: {#fig-simulation .center}

```{python}
# | code-fold: true

import statsmodels.api as sm

# params
k_args = (-0.2, 0, 0.2)

# solve
for k in k_args:
    n = odeint(malthusian_model, N_0, t, args=(k,))
    plt.plot(t, n, label=f"k={k}")

plt.legend()
plt.xlabel("t")
plt.ylabel("$N(t)$")
plt.title("Malthusian growth simulation with different $k$")
plt.show()
```

:::

::: {.nte- .callout-tip icon="false"}
# ğŸµ ãƒãƒ«ã‚µã‚¹ãƒ¢ãƒ‡ãƒ«ã®é™ç•Œ

ãƒãƒ«ã‚µã‚¹ãƒ¢ãƒ‡ãƒ«ã¯ï¼Œ$k > 0$ ã®ã¨ãäººå£ãŒæŒ‡æ•°é–¢æ•°çš„ã«å¢—åŠ ã™ã‚‹ã¨äºˆæ¸¬ã—ã¦ã„ã¾ã™ï¼å®Ÿéš›ã«ã¯ï¼Œé£Ÿæ–™ã‚„çŸ³æ²¹ã¨ã„ã£ãŸè³‡æºã¯æœ‰é™ã§ã‚ã‚‹ã®ã§äººå£å¢—åŠ ã‚’æŠ‘åˆ¶ã™ã‚‹è¦å› ãŒã‚ã‚‹ãŸã‚ï¼Œç¾å®Ÿã§ãƒãƒ«ã‚µã‚¹ãƒ¢ãƒ‡ãƒ«çš„å¢—åŠ ã‚’ã™ã‚‹ã“ã¨ã¯åˆ°åº•èµ·ã“ã‚Šãˆã¾ã›ã‚“ï¼

:::


### Estimation & Prediction

- $N(t)$ ã¯ 4æœŸé–“ã”ã¨ã«è¦³æ¸¬ã•ã‚Œã‚‹(=è¦³æ¸¬ã•ã‚Œã‚‹tã¯$(0, 1, 2, 4)$) 
- è¦³æ¸¬ã•ã‚Œã‚‹ $N(t)$ ã«ã¯ãƒã‚¤ã‚ºãŒä¹—ã£ã¦ã—ã¾ã£ã¦ã„ã‚‹: $\epsilon_t \sim N(0, 0.1)$

ã¨ã„ã†çŠ¶æ³ã®ã®ã‚‚ã¨ï¼Œ$(N_0, k)$ ã‚’æ¨å®šã—ï¼Œ$t>4$ ã®ç¯„å›²ã®äººå£ã«ã¤ã„ã¦äºˆæ¸¬ã™ã‚‹ã“ã¨ã¯ã§ãã‚‹ã®ã‹ï¼Ÿã¨ã„ã†å•é¡Œã‚’è€ƒãˆã¦ã¿ã¾ã™ï¼

\eqref{eq-malthus-solution} ã«ã¤ã„ã¦å¯¾æ•°ã‚’å–ã‚‹ã¨

$$
\log N(t) = \log(N_0) + kt
$$

ã¨ãªã‚Šã¾ã™ï¼ã¤ã¾ã‚Šï¼Œå¯¾æ•°å¤‰æ›ã—ãŸå¤‰æ•°ã«ã¤ã„ã¦ã®ç·šå½¢ãƒ¢ãƒ‡ãƒ«ã¨ã—ã¦æ¨å®šé‡ã‚’è€ƒãˆã‚‹ã“ã¨ãŒã§ãã¾ã™ï¼è¦³æ¸¬ãƒã‚¤ã‚º $\epsilon_t$ ã‚’è¸ã¾ãˆã‚‹ã¨ï¼Œè¦³æ¸¬ã•ã‚Œã‚‹äººå£ã‚’ $\tilde N(t)$ ã¨ã™ã‚‹ã¨

$$
\begin{align}
&\tilde N(t) = N_0\exp(kt) + \epsilon_t\\
&\Rightarrow\log \tilde N(t) = \log (N_0\exp(kt) + \epsilon_t)
\end{align}
$$

ã¨ãªã£ã¦ã—ã¾ã„ã¾ã™ãŒï¼Œè¿‘ä¼¼å¼ã¨ã—ã¦

$$
\log\tilde N(t) = \alpha + \beta t + e_i
$$

ã§æ¨å®šã™ã‚‹ã¨ã—ã¾ã™ï¼$\epsilon_i$ãŒhomogeneousã¨ã—ã¦ã‚‚$e_i$ãŒhomogeneousã¨ã¯é™ã‚‰ãªã„ã®ã§heteroskedasticity residual erroã‚’æƒ³å®šã—ã¦æ¨å®šã—ã¾ã™ï¼

::: {#fig-estimation .center}
```{python}
# | code-fold: show

import statsmodels.api as sm

np.random.seed(42)

# observation step
STEP = 4

# DGP
actual_n = n.flatten()
observed_n = actual_n[::STEP][:-1] + +np.random.normal(0, 0.1, len(actual_n[::STEP][:-1]))
observed_t = t[::STEP][:-1]
X = sm.add_constant(observed_t)

# fit
model = sm.OLS(np.log(observed_n), X).fit(cov_type="HC0")
estimated_n_0, estimated_k = model.params

# simulation
simulated_n = odeint(malthusian_model, np.exp(estimated_n_0), t, args=(estimated_k,))

# plot
plt.plot(t, simulated_n, label="simulated")
plt.scatter(observed_t, observed_n, color="gray", alpha=0.8, marker='x', label="actual data points")
plt.scatter(t, actual_n, color="red", alpha=0.8, label="actual data points")
plt.legend()
plt.xlabel("t")
plt.ylabel("$N(t)$")
plt.title("Malthusian growth prediction")
plt.axvspan(4.25, t[-1], color='gray', alpha=0.3)
plt.text(4.65, 2.0, "Prediction\nPeriod", ha='center', va='center', fontsize=11, color='black')
plt.show()
```
:::

## ãƒ´ã‚§ã‚¢ãƒ•ãƒ«ã‚¹ãƒˆã®äººå£è«–

äººå£éå¯†ã®è¦å› ã‚’è€ƒæ…®ã«å…¥ã‚Œã¦ãƒãƒ«ã‚µã‚¹ãƒ¢ãƒ‡ãƒ«ã‚’ä¿®æ­£ã—ãŸã®ãŒãƒ´ã‚§ã‚¢ãƒ•ãƒ«ã‚¹ãƒˆãƒ¢ãƒ‡ãƒ«ã§ã™ï¼

<strong > &#9654;&nbsp; ä»®å®šã®è¨­å®š</strong>

- äººå£ã®ä¸Šé™ $N_\infty$ ãŒå­˜åœ¨ã™ã‚‹
- ç¾åœ¨ã®äººå£ã‚’ $N(t)$ ã¨ã—ãŸã¨ãï¼Œäººå£å¢—åŠ  $\Delta N(t)$ ã¯ $N(t)$ ã¨ $\displaystyle 1 - \frac{N(t)}{N_\infty}$ ã¨æ™‚é–“åŒºé–“ $\Delta$ ã«æ¯”ä¾‹ã™ã‚‹

<strong > &#9654;&nbsp; å•é¡Œã®å®šå¼åŒ–</strong>

æ¯”ä¾‹å®šæ•°ã‚’ $k$ ã¨ã—ãŸã¨ã

$$
\Delta N(t) = kN(t)\left(1 - \frac{N(t)}{N_\infty}\right)\Delta t
$$

$\Delta t\to 0$ ã¨æ¥µé™ã‚’ã¨ã‚‹ã¨

$$
\frac{dN(t)}{dt} = kN(t)\left(1 - \frac{N(t)}{N_\infty}\right)\label{eq-logistic-model}
$$

äººå£å¤‰åŒ–ã¯ä¸Šè¨˜ã®ã‚ˆã†ãªä¸€éšä¸Šå¾®åˆ†æ–¹ç¨‹å¼ã§è¡¨ã›ã‚‹ã¨ã„ã†å½¢ã§å®šå¼åŒ–ã§ãã¾ã—ãŸï¼

<strong > &#9654;&nbsp; ãƒ¢ãƒ‡ãƒ«ã‚’è§£ã</strong>

\eqref{eq-logistic-model} ã‚’å¤‰å½¢ã™ã‚‹ã¨

$$
\frac{N_\infty}{N_\infty - N(t)}\frac{dN(t)}{N(t)dt} = k
$$

ä¸¡è¾ºã‚’ $t$ ã«ã¤ã„ã¦ç©åˆ†ã™ã‚‹ã¨

$$
\begin{align}
& \int\frac{N_\infty}{N_\infty - N(t)}\frac{dN(t)}{N(t)dt} dt= \int k dt\\
&\Rightarrow \int\left(\frac{1}{N(t)}+\frac{1}{N_\infty - N(t)}\right)dN(t) = \int k dt\\
&\Rightarrow \log N(t) - \log(N_\infty - N(t)) = kt + C\\
&\Rightarrow \log \frac{N(t)}{N_\infty - N(t)} = kt + C
\end{align}
$$

ã“ã®ã¨ãï¼Œ$N(0) = N_0$ ã¨åˆæœŸæ¡ä»¶ãŒä¸ãˆã‚‰ã‚ŒãŸã¨ã™ã‚‹ã¨

$$
\exp(C) = \frac{N_0}{N_\infty - N_0}
$$

ã‚ˆã£ã¦ï¼Œ

$$
\frac{N(t)}{N_\infty - N(t)} = \frac{N_0}{N_\infty - N_0}\exp(kt)
$$

ã“ã‚Œã‚’ $N(t)$ ã«ã¤ã„ã¦ã¨ãã¨ï¼Œ

$$
N(t) = \frac{N_\infty}{1 + [(N_\infty/N_0 - 1)]\exp(-kt)}
$$

ã¾ãŸã¯

$$
\frac{1}{N(t)} = \frac{1}{N_\infty} + \left(\frac{1}{N_0} - \frac{1}{N_\infty}\right)\exp(-kt)
$$

<strong > &#9654;&nbsp; è§£é‡ˆ</strong>

$t\to\infty$ ã®ã¨ãï¼Œ$\lim_{t\to\infty}\exp(-kt) = 0$ ã‚ˆã‚Š

$$
\lim_{t\to\infty}N(t) = N_\infty
$$

ã¨ãªã‚‹ã“ã¨ãŒã‚ã‹ã‚Šã¾ã™ï¼åˆæœŸå€¤ã«å¿œã˜ã¦ $N_\infty$ ã¸åˆ°é”ã™ã‚‹çµŒè·¯ã¯ç•°ãªã‚Šã¾ã™ï¼ä»®ã« $N_\infty = 12, k=0.2$ ã¨ã—ã¦ï¼ŒåˆæœŸå€¤ãŒ $(1, 3, 6, 9, 12, 15)$ ã¨ç•°ãªã‚‹æ°´æº–ã§ä¸ãˆã‚‰ã‚ŒãŸã¨ã—ã¾ã™ï¼

```{python}
from scipy.integrate import solve_ivp


# Define logistic growth model
def logistic_growth(t, N, k=0.2, M=12):
    dydt = k * N * (1 - N / M)
    return dydt

# Set up the grid for the direction field
t_vals = np.linspace(0, 30, 20)  # Time values
P_vals = np.linspace(0, 16, 20)  # Population values
T, P = np.meshgrid(t_vals, P_vals)

# Compute direction field (dP/dt values)
dP_dt = logistic_growth(None, P)

# Normalize arrows for visualization
norm = np.sqrt(1**2 + dP_dt**2)
U = 1 / norm  # Time step is 1 (arbitrary)
V = dP_dt / norm  # Scale arrows properly

# Plot the direction field
plt.figure(figsize=(8, 5))
plt.quiver(T, P, U, V, color="gray", alpha=0.7) # [T, P]: arrow location, [U, V]: arrow direction

# Solve the ODE for different initial conditions
initial_conditions = [1, 3, 6, 9, 12, 15,]
t_span = (0, 30)
t_eval = np.linspace(0, 30, 100)

for P0 in initial_conditions:
    sol = solve_ivp(logistic_growth, t_span, [P0], t_eval=t_eval)
    if sol.success:
        plt.plot(sol.t, sol.y[0], linewidth=2, label=f"P(0)={P0}")
    else:
        raise ValueError("computation failed")

# Labels and title
plt.xlabel("t")
plt.ylabel("P(t)")
plt.title("Logistic Growth Model")
plt.legend()
plt.grid()

# Show the plot
plt.show()
```

- $0< N_0 < N_\infty$: ã¯ã˜ã‚ã®å¢—åŠ ã¯æŒ‡æ•°é–¢æ•°çš„ã ãŒï¼Œã‚ã‚‹ç¨‹åº¦ã®æ°´æº–ã‹ã‚‰å¢—åŠ ã®åº¦åˆã„ã¯æ¸›è¡°ã—ã¦ã„ã
- $N_0 = N_\infty$: å¤‰åŒ–ãªã—
- $N_0 > N_\infty$: $N_\infty$ã«è¿‘ã¥ãæ–¹å‘ã§æ¸›å°‘ã—ã¦ã„ãï¼æ¸›è¡°ã®åº¦åˆã„ã¯æ¸›è¡°ã—ã¦ã„ã
- $N_0 = 0$: ã“ã‚Œã‚‚ä¸€ã¤ã®å‡è¡¡ã ãŒï¼Œã¡ã‚‡ã£ã¨ã—ãŸã‚·ãƒ§ãƒƒã‚¯ãŒã‚ã‚‹ã ã‘ã§ $N_\infty$ ã‚’ç›®æŒ‡ã™Pathã«ä¹—ã£ã¦ã—ã¾ã†(= **unstable equilibrium**)

<strong > &#9654;&nbsp; Validation</strong>

ãƒ´ã‚§ã‚¢ãƒ•ãƒ«ã‚¹ãƒˆãƒ¢ãƒ‡ãƒ«ãŒäººå£å‹•æ…‹ã‚’è¡¨ã—ãŸè‰¯ã„ãƒ¢ãƒ‡ãƒ«ãªã®ã‹ï¼Œ1820-1930ã®ã‚¢ãƒ¡ãƒªã‚«ã®äººå£ãƒ‡ãƒ¼ã‚¿ã‚’ç”¨ã„ã¦æ¤œè¨¼ã—ã¦ã¿ã¾ã™ï¼

```{python}
import pandas as pd

# Historical population data (year, population in millions)
data = {
    "year": [1820, 1830, 1840, 1850, 1860, 1870, 1880, 1890, 1900, 1910, 1920, 1930, 2000],
    "us_population_million": [9.6, 12.9, 17.1, 23.2, 31.4, 38.6, 50.2, 62.9, 76.0, 92.0, 106.5, 123.2, 282.2]
}

# Create DataFrame
df = pd.DataFrame(data)

# Display table
df
```

ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼ã‚’ $N_0 = 3.9, k = 0.3134, N_\infty = 197$ ã¨é¸ã¶ã¨

::: {#fig-us-population-plot .center}

```{python}
t_index = np.linspace(0, (df.shape[0] + 10), 100)
sol = solve_ivp(logistic_growth, [0, t_index[-1]], [3.9], t_eval=t_index, args=(0.3134, 197))
plt.plot(1790 + sol.t*10, sol.y[0], linewidth=2, label=f"prediction")
plt.scatter(
    df.year,
    df.us_population_million,
    color="gray",
    alpha=0.8,
    marker="x",
    label="actual data points",
)
plt.xlabel('year')
plt.ylabel('population(million)')
plt.legend()
plt.show()
```

Model prediction vs actual USA population

:::

ã“ã®ã‚ˆã†ã«, 1800-1930å¹´ã®ã‚¢ãƒ¡ãƒªã‚«äººå£å‹•æ…‹ã‚’ä¸Šæ‰‹ãèª¬æ˜ã™ã‚‹ãƒ¢ãƒ‡ãƒ«ã¨ãªã£ã¦ã„ã‚‹ã“ã¨ãŒã‚ã‹ã‚Šã¾ã™ï¼ä¸€æ–¹ï¼Œãƒ¢ãƒ‡ãƒ«ã®ä¸Šé™ã¯ $197\times 10^6$ ã§ã‚ã‚‹ãŒï¼Œ2000å¹´ã®äººå£ã¯
$282.2\times 10^6$ ã¨ãªã£ã¦ãŠã‚Šï¼Œé•·æœŸã«ãŠã‘ã‚‹äººå£å‹•æ…‹ã‚’èª¬æ˜ã§ãã‚‹ã‚‚ã®ã«ã¯ãªã£ã¦ã„ãªã„ã“ã¨ã‚‚èª­ã¿å–ã‚Œã¾ã™ï¼

$N_\infty$ ã®ä»®å®šãŒé–“é•ã£ã¦ã„ãŸã¨è§£é‡ˆã™ã‚‹ã“ã¨ãŒä¸€ã¤è€ƒãˆã‚‰ã‚Œã¾ã™ãŒï¼Œäººå£å¤‰åŒ–ã‚’æ”¯é…ã™ã‚‹æ³•å‰‡ã¯æŠ€è¡“å¤‰åŒ–ã‚„æ”¿æ²»ã¨ã„ã£ãŸè¦å› ã«å½±éŸ¿ã‚’å—ã‘ã‚‹ãŸã‚ï¼Œå¸¸ã«åŒã˜æ”¯é…æ³•å‰‡ã«åŸºã¥ã„ã¦ã„ã‚‹ã¨ä»®å®šã™ã‚‹ã“ã¨ãŒé–“é•ã£ã¦ã„ã‚‹ã¨ã‚‚è§£é‡ˆã™ã‚‹ã“ã¨ãŒå‡ºæ¥ã¾ã™ï¼
