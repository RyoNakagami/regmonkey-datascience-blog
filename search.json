[
  {
    "objectID": "dictionary/dict.html",
    "href": "dictionary/dict.html",
    "title": "Dictionary",
    "section": "",
    "text": "genre\n      comment\n    \n  \n\n\n    \n        \n        \n        \n        \n        \n        \n        \n        \n    \n    \n   \n    \n      \n  \n        \n    \n    \n  \n        \n    \n    \n  \n        \n    \n      \n  \n        \n            \n                \n                \n            \n            \n                \n                \n            \n            \n                \n                \n            \n            \n                \n                \n            \n            \n                \n                \n            \n        \n    \n\n\nLoading ITables v2.2.5 from the internet...\n(need help?)"
  },
  {
    "objectID": "posts/2025-02-13-complex-plane/index.html",
    "href": "posts/2025-02-13-complex-plane/index.html",
    "title": "複素平面と複素数による回転",
    "section": "",
    "text": "Def: 複素数と 0 \n複素数 \\(z = a + bi = 0\\) のとき，\\(a = b = 0\\) である．\n\nこの定義より，複素数 \\(z\\) の絶対値 \\(\\vert z \\vert = 0\\) であるならば，\n\\[\n\\begin{align}\n\\vert z \\vert = 0 \\Leftrightarrow (a^2 + b^2) = 0 \\Leftrightarrow a = b = 0 \\Leftrightarrow z = 0\n\\end{align}\n\\]\nであることがわかります．\n\nDef: 共役複素数 \n複素数 \\(z = a + bi\\) に対して，\\(a - bi\\) を \\(z\\) の共役複素数と呼び，\\(\\overline z\\) と表す．\n\n足すと 5 になり，掛けると 7 になる２つの数を考えてみたいと思います．それぞれの数を \\(\\alpha, \\beta\\) とすると解と係数の関係より\n\\[\nx^2 - 5x + 7 =0\n\\]\nという二次方程式の解を求めることで求まります．これをといてみると\n\\[\n\\alpha, \\beta = \\frac{5 \\pm \\sqrt{25 - 28}}{2} = \\frac{5 \\pm \\sqrt{3}i}{2}\n\\]\nという複素解がでてきます．また，共役複素数の定義より\n\\[\n\\overline \\alpha = \\beta\n\\]\nであることがわかります．また，もともとの問題が２つの和が \\(5\\), 積が \\(7\\) を満たす数を求める問題であったとことから\n\\[\n\\begin{gather}\n\\alpha + \\overline\\alpha = 5\\\\\n\\alpha \\overline\\alpha = 7\n\\end{gather}\n\\]\nとなりますが，このように共役複素数は積と和が実数になるという特徴が有ります．\n\n\nTheorem 1 \n複素数 \\(z = a + bi\\) について，\n\\[\nz\\overline z = a^2 + b^2\n\\]\nが成り立つ．\n\n\n\n\n\n\n\n\n\nProof\n\n\n\n\n\n\\[\n\\begin{align}\n(a + bi)(a - bi)\n    &= a^2 - (bi)^2\\\\\n    &= a^2 - b^2i^2\\\\\n    &= a^2 + b^2\n\\end{align}\n\\]\n\n\n\n複素数 \\(z = a + bi\\) について，\\(z\\overline{z} = 1\\) となるような複素数 \\(\\overline{z}\\) を（乗法）逆元と呼ぶとき，\n\\[\n\\frac{z\\overline{z}}{a^2 + b^2} = 1\n\\]\nとなることから，\\(\\displaystyle \\frac{\\overline{z}}{\\vert z \\vert^2} = \\frac{\\overline{z}}{z\\overline{z}} = \\frac{a - bi}{a^2 + b^2}\\) が逆源となることがわかります．\n\n\nTheorem 2 : 共役複素数 \n２つの複素数 \\(z, w\\) に対して，\n\\[\n\\begin{gather}\n\\overline{z + w} = \\overline{z} + \\overline{w} \\label{#eq-complex-1}\\\\\n\\overline{z w} = \\overline{z}\\,\\overline{w} \\label{#eq-complex-2}\n\\end{gather}\n\\]\nが成り立つ．\n\n\n\n\n\n\n\n\n\nProof\n\n\n\n\n\n以下では，\\(z = a + bi, w = c + di\\) とします．\n ▶  \\(\\eqref{#eq-complex-1}\\) の証明\n\\[\n\\begin{align}\n\\overline{z + w}\n    &= \\overline{(a + c) + (b+d)i}\\\\\n    &= (a + c) - (b+d)i\\\\\n    &= (a - bi) + (c - di)\\\\\n    &= \\overline{z} + \\overline{w}\n\\end{align}\n\\]\n ▶  \\(\\eqref{#eq-complex-2}\\) の証明\n\\[\n\\begin{align}\n&zw = (ac - bd) + (ad + bc)i\\\\\n\\Rightarrow & \\overline{zw} = (ac - bd) - (ad + bc)i\n\\end{align}\n\\]\n次に\n\\[\n\\begin{align}\n\\overline{z}\\,\\overline{w}\n    &=  (ac - bd) + (ad + bc)i\n\\end{align}\n\\]\nしたがって，\\(\\eqref{#eq-complex-2}\\) が成り立つ．"
  },
  {
    "objectID": "posts/2025-02-13-complex-plane/index.html#複素数の性質",
    "href": "posts/2025-02-13-complex-plane/index.html#複素数の性質",
    "title": "複素平面と複素数による回転",
    "section": "",
    "text": "Def: 複素数と 0 \n複素数 \\(z = a + bi = 0\\) のとき，\\(a = b = 0\\) である．\n\nこの定義より，複素数 \\(z\\) の絶対値 \\(\\vert z \\vert = 0\\) であるならば，\n\\[\n\\begin{align}\n\\vert z \\vert = 0 \\Leftrightarrow (a^2 + b^2) = 0 \\Leftrightarrow a = b = 0 \\Leftrightarrow z = 0\n\\end{align}\n\\]\nであることがわかります．\n\nDef: 共役複素数 \n複素数 \\(z = a + bi\\) に対して，\\(a - bi\\) を \\(z\\) の共役複素数と呼び，\\(\\overline z\\) と表す．\n\n足すと 5 になり，掛けると 7 になる２つの数を考えてみたいと思います．それぞれの数を \\(\\alpha, \\beta\\) とすると解と係数の関係より\n\\[\nx^2 - 5x + 7 =0\n\\]\nという二次方程式の解を求めることで求まります．これをといてみると\n\\[\n\\alpha, \\beta = \\frac{5 \\pm \\sqrt{25 - 28}}{2} = \\frac{5 \\pm \\sqrt{3}i}{2}\n\\]\nという複素解がでてきます．また，共役複素数の定義より\n\\[\n\\overline \\alpha = \\beta\n\\]\nであることがわかります．また，もともとの問題が２つの和が \\(5\\), 積が \\(7\\) を満たす数を求める問題であったとことから\n\\[\n\\begin{gather}\n\\alpha + \\overline\\alpha = 5\\\\\n\\alpha \\overline\\alpha = 7\n\\end{gather}\n\\]\nとなりますが，このように共役複素数は積と和が実数になるという特徴が有ります．\n\n\nTheorem 1 \n複素数 \\(z = a + bi\\) について，\n\\[\nz\\overline z = a^2 + b^2\n\\]\nが成り立つ．\n\n\n\n\n\n\n\n\n\nProof\n\n\n\n\n\n\\[\n\\begin{align}\n(a + bi)(a - bi)\n    &= a^2 - (bi)^2\\\\\n    &= a^2 - b^2i^2\\\\\n    &= a^2 + b^2\n\\end{align}\n\\]\n\n\n\n複素数 \\(z = a + bi\\) について，\\(z\\overline{z} = 1\\) となるような複素数 \\(\\overline{z}\\) を（乗法）逆元と呼ぶとき，\n\\[\n\\frac{z\\overline{z}}{a^2 + b^2} = 1\n\\]\nとなることから，\\(\\displaystyle \\frac{\\overline{z}}{\\vert z \\vert^2} = \\frac{\\overline{z}}{z\\overline{z}} = \\frac{a - bi}{a^2 + b^2}\\) が逆源となることがわかります．\n\n\nTheorem 2 : 共役複素数 \n２つの複素数 \\(z, w\\) に対して，\n\\[\n\\begin{gather}\n\\overline{z + w} = \\overline{z} + \\overline{w} \\label{#eq-complex-1}\\\\\n\\overline{z w} = \\overline{z}\\,\\overline{w} \\label{#eq-complex-2}\n\\end{gather}\n\\]\nが成り立つ．\n\n\n\n\n\n\n\n\n\nProof\n\n\n\n\n\n以下では，\\(z = a + bi, w = c + di\\) とします．\n ▶  \\(\\eqref{#eq-complex-1}\\) の証明\n\\[\n\\begin{align}\n\\overline{z + w}\n    &= \\overline{(a + c) + (b+d)i}\\\\\n    &= (a + c) - (b+d)i\\\\\n    &= (a - bi) + (c - di)\\\\\n    &= \\overline{z} + \\overline{w}\n\\end{align}\n\\]\n ▶  \\(\\eqref{#eq-complex-2}\\) の証明\n\\[\n\\begin{align}\n&zw = (ac - bd) + (ad + bc)i\\\\\n\\Rightarrow & \\overline{zw} = (ac - bd) - (ad + bc)i\n\\end{align}\n\\]\n次に\n\\[\n\\begin{align}\n\\overline{z}\\,\\overline{w}\n    &=  (ac - bd) + (ad + bc)i\n\\end{align}\n\\]\nしたがって，\\(\\eqref{#eq-complex-2}\\) が成り立つ．"
  },
  {
    "objectID": "posts/2025-02-13-complex-plane/index.html#複素平面",
    "href": "posts/2025-02-13-complex-plane/index.html#複素平面",
    "title": "複素平面と複素数による回転",
    "section": "複素平面",
    "text": "複素平面\n複素数 \\(z = a + bi\\) は実部と虚部に着目すると２つの実数の組 \\((a, b)\\) と1:1対応していることがわかります．一方，２つの実数の組 \\((a, b)\\) を与えるということは 実数平面空間の１点と対応することと同じなので，平面上の点全体と複素数の全体は１対１に対応するということがわかります．\nこの対応によって，平面が複素数全体であると考えたものを複素平面またはガウス平面と呼びます．複素平面においては，\\(x\\) 軸を実軸，\\(y\\) 軸を虚軸といいます．\n\n極形式の導入\n複素平面において，複素数 \\(z = a + bi\\) の位置ベクトル \\(\\overrightarrow{OZ}\\) について\n\n\\(r\\): \\(||\\overrightarrow{OZ}||\\)\n\\(\\theta\\) : ベクトル \\(\\overrightarrow{OZ}\\) が実軸となす角\n\nと極座標に対応させて考えると，\\(r = |z|\\) となりますし，また偏角についても\n\\[\n\\theta = \\operatorname{arg} z\n\\]\nと表します．ここから複素数について次のような表し方を得ます\n\\[\nz = r(\\cos\\theta + i\\sin\\theta)\n\\]\nこれを \\(z\\) の極形式といいます．\n\n📘 REMARKS \n複素数 \\(z = a + bi\\) について，複素平面上では\n\n\\(-z = -a - bi\\): 原点に関する対称移動\n\\(\\overline{z} = a - bi\\): 実軸に関する対称移動\n\\(-\\overline{z} = -a + bi\\): 虚軸に関する対称移動\n\n\nCode\nimport matplotlib.pyplot as plt\n\n# 複素数の定義（例として z = 2 + 1i）\na, b = 2, 1\nz = complex(a, b)\n\n# 各変換\nminus_z = -z                # -z\nconj_z = z.conjugate()      # z̄\nminus_conj_z = -conj_z      # -z̄\n\n# 複素数の点とラベル\npoints = {\n    \"z\": z,\n    \"-z\": minus_z,\n    \"z̄\": conj_z,\n    \"-z̄\": minus_conj_z\n}\n\n# プロット\nfig, ax = plt.subplots(figsize=(6,6))\nax.set_facecolor(\"#EFF5F5\")\n\nfor label, point in points.items():\n    ax.plot(point.real, point.imag, 'o', c=\"#4477AA\")\n    ax.text(point.real + 0.1, point.imag + 0.1, label, fontsize=12)\n\ndef draw_arrow(from_point, to_point, color):\n    ax.annotate(\"\",\n                xy=(to_point.real, to_point.imag),\n                xytext=(from_point.real, from_point.imag),\n                arrowprops=dict(arrowstyle=\"-&gt;\", color=color, lw=1.2))\n\ndraw_arrow(0, z, \"#4477AA\")\ndraw_arrow(complex(0, z.imag), z, \"#4477AA\")\ndraw_arrow(complex(0, z.imag), minus_conj_z, \"gray\")\ndraw_arrow(0, minus_z, \"gray\")      # z → -z\ndraw_arrow(complex(z.real, 0), conj_z, \"gray\")\ndraw_arrow(complex(z.real, 0), z, \"#4477AA\")\n\n\n# 軸設定\nax.set_xlim(-2.5, 2.5)\nax.set_ylim(-2.5, 2.5)\nax.axhline(0, color='gray', linewidth=0.5)\nax.axvline(0, color='gray', linewidth=0.5)\nax.set_xlabel('Re')\nax.set_ylabel('Im')\n\nax.set_title('Symmetries of complex numbers')\nax.grid(True, which=\"both\", linestyle=\"--\", linewidth=0.5)\nax.set_aspect(\"equal\", adjustable=\"box\")  # Make axes equal scale\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 1\n\n\n\n\n\n\n複素数の積と回転\n２つの複素数 \\(z, w\\) の積を考えます．\n\\[\n\\begin{align}\n\\vert z \\vert = r_1, \\quad & \\operatorname{arg}z = \\theta_1\\\\\n\\vert w \\vert = r_2, \\quad & \\operatorname{arg}w = \\theta_2\n\\end{align}\n\\]\nとおくと，加法定理を用いて以下のように展開できます\n\\[\n\\begin{align}\nzw\n    &= r_1(\\cos\\theta_1 + i \\sin\\theta_1)r_2(\\cos\\theta_2 + i \\sin\\theta_2)\\\\\n    &= r_1r_2\\{(\\cos\\theta_1\\cos\\theta_2 - \\sin\\theta_1\\sin\\theta_1) + i(\\cos\\theta_1\\sin\\theta_2 + \\cos\\theta_2\\sin\\theta_1)\\}\\\\\n    &= r_1r_2(\\cos(\\theta_1 + \\theta_2) + i\\sin(\\theta_1 + \\theta_2))\n\\end{align}\n\\]\nここから以下のことがわかります\n\\[\n\\begin{gather}\n\\vert zw \\vert  = \\vert z\\vert\\, \\vert w \\vert\\\\\n\\operatorname{arg} zw \\equiv \\operatorname{arg} z + \\operatorname{arg} w \\quad(\\operatorname{mod} 2\\pi)\n\\end{gather}\n\\]\n積 \\(zw\\) の位置ベクトルは，\\(z\\) の位置ベクトルを \\(\\vert w \\vert\\) 倍に拡大し，原点 \\(O\\) のまわりに角 \\(\\operatorname{arg} w\\) だけ回転させたものであると解釈できます．\n\nCode\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# --- Define your complex numbers here ---\nz = 1 + 1j\nw = complex(1, np.sqrt(3))\n# ----------------------------------------\n\n## Calculate the product\nproduct = z * w\n\n# Points and labels for scattering (Origin + z, w, product)\nnums_to_label = {\"z\": z, \"w\": w, \"z*w\": product}\npoints = list(nums_to_label.values())\nreal_parts = [p.real for p in points]\nimag_parts = [p.imag for p in points]\nscatter_labels = [f\"{name} = {num:.2f}\" for name, num in nums_to_label.items()]\n\n\n# Create the plot\nfig, ax = plt.subplots(figsize=(6, 6))\nax.set_facecolor(\"#EFF5F5\")\n# Scatter plot for the points\ncolors = [\"#4477AA\", \"gray\", \"#2E45B8\"]  # Origin, z, w, product\nmarkers = [\"o\", \"o\", \"o\"]\nfor i in range(len(points)):\n    ax.scatter(\n        real_parts[i],\n        imag_parts[i],\n        color=colors[i],\n        marker=markers[i],\n        s=50,\n        label=scatter_labels[i],\n    )\n    # Add arrows from origin\n    ax.annotate(\n        \"\",\n        xy=(real_parts[i], imag_parts[i]),\n        xytext=(0, 0),\n        arrowprops=dict(arrowstyle=\"-&gt;\", color=colors[i]),\n    )\n\n# Add argument text annotations\ntext_offset = 0.15  # Small offset for text position, adjust as needed\nfor name, num in nums_to_label.items():\n    # Calculate argument in degrees\n    arg_rad = np.angle(num)\n    arg_deg = np.degrees(arg_rad)\n\n    # Create text label\n    text_label = f\"arg({name}) = {arg_deg:.1f}°\"  # Format to 1 decimal place\n\n    # Position the text slightly offset from the point\n    # You might need to fine-tune text_x, text_y for better placement\n    text_x = num.real + text_offset * np.cos(\n        arg_rad + np.pi / 8\n    )  # Offset slightly outwards\n    text_y = num.imag + text_offset * np.sin(arg_rad + np.pi / 8)\n\n    ax.text(\n        text_x,\n        text_y,\n        text_label,\n        fontsize=9,\n        color=colors[list(nums_to_label.keys()).index(name)],\n    )  # Use point's color\n\n\n# --- Plot Styling ---\n# Set plot limits to ensure all points and text are visible\nmax_abs_val = max(abs(p) for p in points[1:]) if len(points) &gt; 1 else 1\npadding = max_abs_val * 0.4  # Add padding based on magnitude\nax.set_xlim(min(real_parts) - padding, max(real_parts) + padding)\nax.set_ylim(min(imag_parts) - padding, max(imag_parts) + padding)\n\n# Determine symmetric limits centered at 0\nlim = max(abs(l) for l in ax.get_xlim() + ax.get_ylim())\nax.set_xlim(-2, lim)\nax.set_ylim(-1, lim)\n\n\n# Add grid, labels, and title\nax.grid(True, which=\"both\", linestyle=\"--\", linewidth=0.5)\nax.axhline(y=0, color=\"k\", linewidth=0.8)\nax.axvline(x=0, color=\"k\", linewidth=0.8)\nax.set_xlabel(\"Real Axis\")\nax.set_ylabel(\"Imaginary Axis\")\nax.set_title(\"Complex Numbers z, w, z*w, and their Arguments\")\nax.set_aspect(\"equal\", adjustable=\"box\")  # Make axes equal scale\nax.legend()\n\n# Show the plot\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 2\n\n\n\n ▶  加法定理を用いずに回転を理解する\nここでは加法定理を用いずに大きさが1の複素数 \\(\\cos\\theta + i\\sin\\theta\\) を掛ける操作が複素平面上の \\(\\theta\\) 回転を表すことを確認します．\n\\[\n\\begin{gather}\nz = a + ib\\\\\nw = \\cos\\theta + i\\sin\\theta\n\\end{gather}\n\\]\nの２つの複素数の積は\n\\[\n\\begin{align}\nzw\n    &= (a + ib)(\\cos\\theta + i\\sin\\theta)\\\\\n    &= (a\\cos\\theta - b\\sin\\theta) + i(a\\sin\\theta + b\\cos\\theta )\n\\end{align}\n\\]\n以下の図では \\(z = a + ib\\) として\n\n複素数 \\(z\\) と対応する点２次元実数空間に表した点を \\(P =(a, b)\\)\n\\(P\\) を \\(\\theta\\) 回転させた点を \\(Q\\)\n\\(P\\) を \\(90^\\prime\\) 回転させた点を \\(R  = (-b, a)\\)\n\\(\\overrightarrow{OQ}\\) を \\(\\overrightarrow{OP}\\) に正射影したベクトルを \\(\\overrightarrow{OP^\\prime}\\)\n\nとしています．ベクトルの正射影の考え方より\n\\[\n\\begin{align}\n\\overrightarrow{OP^\\prime} = \\vert OQ \\vert \\cos\\theta \\frac{\\overrightarrow{OP}}{\\vert OP\\vert} = \\cos\\theta \\overrightarrow{OP}\\\\\n\\overrightarrow{P^\\prime Q} = \\vert OQ \\vert \\sin\\theta \\frac{\\overrightarrow{OR}}{\\vert OR\\vert} = \\sin\\theta \\overrightarrow{OR}\n\\end{align}\n\\]\n従って，\n\\[\n\\begin{align}\n\\overrightarrow{OQ}\n    &= \\overrightarrow{OP^\\prime} + \\overrightarrow{P^\\prime Q}\\\\\n    &= \\cos\\theta \\overrightarrow{OP} + \\sin\\theta \\overrightarrow{OR}\n\\end{align}\n\\]\nここで，成分を考えると\n\\[\n\\overrightarrow{OQ} = (a\\cos\\theta - b\\sin\\theta, a\\sin\\theta + b\\cos\\theta)\n\\]\nこれは複素数 \\((a\\cos\\theta - b\\sin\\theta) + i(a\\sin\\theta + b\\cos\\theta )\\) に対応しているので，複素数の積 \\(zw\\) は \\(z\\) を \\(\\operatorname{arg} w\\) だけ回転させた複素平面の点に対応することがわかりました．\n\nCode\nimport matplotlib.patches as patches\nimport cmath\n\nfig, ax = plt.subplots(figsize=(6, 6))\nax.set_facecolor(\"#EFF5F5\")\n\n# Circle parameters\nr = 2  # radius\ntheta = np.linspace(0, 2 * np.pi, 500)\ncircle = r * np.exp(1j * theta)\nax.plot(circle.real, circle.imag, label=f\"|z| = {r}\", color=\"gray\")\n\n## define points\nOP = complex(np.sqrt(3), 1)\nOR = OP * 1j\nO = complex(0, 0)\nOQ = complex(np.cos(np.pi / 3), np.sin(np.pi / 3)) * OP\nOP_2 = np.cos(np.pi / 3) * OP\n\n\n## plots\npoints = [OP, OR, OQ]\nscatter_labels = [\"P\", \"R\", \"Q\"]\n\nax.text(\n    0,\n    -0.15,\n    \"O\",\n    fontsize=10,\n    color=\"black\",\n)\n\n# 直交する2本の線を描画\nfor i in range(len(points)):\n    point = points[i]\n    ax.plot([0, point.real], [0, point.imag], \"k\", linewidth=2)  # OP\n    ax.text(\n        point.real,\n        point.imag + 0.05,\n        scatter_labels[i],\n        fontsize=10,\n        color=\"black\",\n    )\n\n## ad P'Q\nax.plot([OP_2.real, OQ.real], [OP_2.imag, OQ.imag], color=\"gray\", linestyle=\"dotted\")\nax.text(\n    OP_2.real + 0.05,\n    OP_2.imag * 0.8,\n    r\"$P^\\prime$\",\n    fontsize=10,\n    color=\"black\",\n)\n\n\n# 直角記号（小さな四角）を原点付近に描画\n# 直角記号（原点から少しオフセット）\ntheta = cmath.phase(OP)  # 60 degrees\northogonal_theta = theta + np.pi / 2  # 90° 直交\noffset = 0.0\n# 直角マークの位置を作成（60°方向に少し移動 → 90°方向に正方形を描く）\nbase_x = offset * np.cos(theta)\nbase_y = offset * np.sin(theta)\nrect_dx = 0.2 * np.cos(orthogonal_theta)\nrect_dy = 0.2 * np.sin(orthogonal_theta)\n\n# 小さな直角マーク（平行四辺形を回転して表現）\nright_angle = patches.Polygon(\n    [\n        (base_x, base_y),\n        (base_x + rect_dx, base_y + rect_dy),\n        (\n            base_x + rect_dx + 0.2 * np.cos(theta),\n            base_y + rect_dy + 0.2 * np.sin(theta),\n        ),\n        (base_x + 0.2 * np.cos(theta), base_y + 0.2 * np.sin(theta)),\n    ],\n    closed=True,\n    edgecolor=\"black\",\n    facecolor=\"none\",\n)\n\nax.add_patch(right_angle)\narc = patches.Arc(\n    (0, 0),\n    0.8,\n    0.8,\n    angle=np.degrees(cmath.phase(OP)),  # start\n    theta1=0,\n    theta2=np.degrees(cmath.phase(OQ)) - np.degrees(cmath.phase(OP)),\n    color=\"black\",\n)\n\n## add angle theta\ntheta_r = 0.5\nax.text(\n    theta_r * np.cos(np.mean([cmath.phase(OQ), cmath.phase(OP)])),\n    theta_r * np.sin(np.mean([cmath.phase(OQ), cmath.phase(OP)])),\n    r\"$\\theta$\",\n    color=\"black\",\n    fontsize=10,\n)\n\nax.add_patch(arc)\n\n# 軸設定\nax.set_xlim(-2.5, 2.5)\nax.set_ylim(-2.5, 2.5)\nax.set_aspect(\"equal\")\nax.grid(True)\n\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 3\n\n\n\n ▶  複素数の割り算\n２つの複素数 \\(z, w\\) を上と同様に考えます． \\(\\vert w \\vert \\neq 0\\) であるとき，\n\\[\n\\begin{align}\n\\frac{1}{w}\n    &= \\frac{1}{r_2(\\cos \\theta_2 + i\\sin\\theta_2)}\\\\\n    &= \\frac{1}{r_2}(\\cos \\theta_2 - i\\sin\\theta_2)\\\\\n    &= \\frac{1}{r_2}(\\cos (-\\theta_2) + i\\sin(-\\theta_2))\\\\\n\\end{align}\n\\]\nであるので\n\\[\n\\begin{align}\n\\frac{z}{w}\n    &= \\frac{r_1}{r_2}\\{(\\cos\\theta_1\\cos(-\\theta_2) - \\sin\\theta_1\\sin(-\\theta_2)) + i(\\cos\\theta_1\\sin(-\\theta_2 )+ \\sin\\theta_1\\cos(-\\theta_2))\\}\\\\\n    &= \\frac{r_1}{r_2}\\{(\\cos\\theta_1\\cos\\theta_2 + \\sin\\theta_1\\sin\\theta_2) + i(-\\cos\\theta_1\\sin\\theta_2 +  \\sin\\theta_1\\cos\\theta_2)\\}\\\\\n    &= \\frac{r_1}{r_2}(\\cos(\\theta_1 - \\theta_2) + i (\\sin\\theta_1 - \\theta_2))\n\\end{align}\n\\]\nしたがって，\n\\[\n\\begin{gather}\n\\bigg\\vert \\frac{z}{w} \\bigg\\vert  = \\frac{\\vert z\\vert}{\\vert w \\vert}\\\\\n\\operatorname{arg}  \\frac{z}{w}  \\equiv \\operatorname{arg} z - \\operatorname{arg} w \\quad(\\operatorname{mod} 2\\pi)\n\\end{gather}\n\\]\n\n\nTheorem 3 : ド・モアブルの公式 \n正の整数 \\(n\\) に対して，\n\\[\n(\\cos\\theta + i\\sin\\theta)^n = \\cos n\\theta + i\\sin n \\theta\n\\]\nが成り立つ．\n\n\n\n\n\n\n\n\n\nProof\n\n\n\n\n\n数学的帰納法を用いて示す．\\(n = 1\\) のとき成立するのは明らか．\\(n = k\\) のとき，ド・モアブルの公式が成立すると仮定すると\n\\[\n\\begin{align}\n(\\cos\\theta + i\\sin\\theta)^{k+1}\n    &= (\\cos\\theta + i\\sin\\theta)^{k} \\cdot (\\cos\\theta + i\\sin\\theta)\\\\\n    &= (\\cos k\\theta + i\\sin k\\theta)(\\cos\\theta + i\\sin\\theta)\\\\\n    &= (\\cos k\\theta \\cos \\theta - \\sin k\\theta\\sin \\theta) + i(\\cos k\\theta \\sin\\theta + \\sin k\\theta \\cos\\theta)\\\\\n    &= \\cos(k\\theta + \\theta) + i\\sin(k\\theta + \\theta)\\\\\n    &= \\cos(k+1)\\theta + i\\sin(k+1) \\theta\n\\end{align}\n\\]\n従って，\\(k+1\\) のときもド・モアブルの公式が成立することがわかる．\n\n\n\n ▶  1の \\(n\\) 乗根を複素数の範囲で求める\n\\(n\\) 乗すると \\(a\\) になる数を \\(a\\) の \\(n\\) 乗根といいます．ここで1の6乗根を求めてみたいと思います．\n\\(z^6 =1\\) より \\(\\vert z \\vert = 1\\). つまり，\n\\[\nz = \\cos\\theta + i \\sin\\theta\n\\]\nと表すことができます．ド・モアブルの公式より\n\\[\nz^6 = \\cos6\\theta + i \\sin6\\theta = 1\n\\]\nつまり，\n\\[\n\\begin{gather}\n6\\theta \\equiv 0 \\, \\operatorname{mod} 2\\pi\n\\end{gather}\n\\]\n\\(\\displaystyle \\zeta = \\cos\\frac{2\\pi}{6} + i \\sin \\frac{2\\pi}{6}\\) とおくと，\n\\[\n(1, \\zeta, \\zeta^2, \\zeta^3, \\zeta^4, \\zeta^5)\n\\]\nが解となります．これをplotすると以下のよう単位円周を６等分した点になることがわかります．\n\nCode\nzeta = complex(np.cos(2 * np.pi / 6), np.sin(2 * np.pi / 6))\npoints = [zeta ** i for i in range(6)]\nscatter_labels = [1] + [fr'$\\zeta^{i}$' for i in range(1, 6)]\n\n# Create the plot\nfig, ax = plt.subplots(figsize=(6, 6))\nax.set_facecolor(\"#EFF5F5\")\nfor i in range(len(points)):\n    ax.scatter(\n        points[i].real,\n        points[i].imag,\n        s=50,\n        color=\"#4477AA\",\n    )\n\n    ax.text(\n        points[i].real,\n        points[i].imag+0.05,\n        scatter_labels[i],\n        fontsize=9,\n        color='black',\n    )\n\n\n# Circle parameters\nr = 1  # radius\ntheta = np.linspace(0, 2 * np.pi, 500)\ncircle = r * np.exp(1j * theta) \nax.plot(circle.real, circle.imag, label=f'|z| = {r}', color='gray')\n\n# Add grids\nax.grid(True, which=\"both\", linestyle=\"--\", linewidth=0.5)\nax.axhline(y=0, color=\"k\", linewidth=0.8)\nax.axvline(x=0, color=\"k\", linewidth=0.8)\nax.set_xlabel(\"Real Axis\")\nax.set_ylabel(\"Imaginary Axis\")\nax.set_title(\"6th Roots of Unity on the Complex Plane\")\nax.set_aspect(\"equal\", adjustable=\"box\")  # Make axes equal scale\nax.legend()\n\n# Show the plot\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 4\n\n\n\n ▶  大きさが1の複素数とLie群\n大きさが1の複素数の集合は，複素平面で考えると大きさが1の円周になります．この集合を\n\\[\nS = \\{z \\in \\mathbb C | \\vert z\\vert = 1\\}\n\\]\nと表すことができますが，オイラーの公式を用いると\n\\[\nS = \\{\\exp(i\\theta) \\in \\mathbb C | 0 \\leq \\theta &lt; 2\\pi\\}\n\\]\nと表すことができます．このとき，\\(S\\) の元は積の演算で閉じていることがわかります．つまり，\n\\[\n\\exp(i\\theta_1), \\exp(i\\theta_2) \\in S \\Rightarrow \\exp(i\\theta_1)\\exp(i\\theta_2) \\in S\n\\]\nこの積の演算に関して \\(S\\) は以下が成立するので群となります\n\n結合法則: \\((\\exp(i\\theta_1)\\exp(i\\theta_2))\\exp(i\\theta_3) = \\exp(i\\theta_1)(\\exp(i\\theta_2)\\exp(i\\theta_3)) = \\exp(i(\\theta_1 + \\theta_2 + \\theta_3))\\)\n単位元の存在: \\(\\exp(i\\cdot 0) = 1\\)\n逆元の存在: \\(\\exp(i\\theta)\\) に対して，\\(\\exp(-i\\theta)\\) が逆元として定義できる\n\nこのように，大きさが1である複素数の集合を考えることで，図形的な側面だけでなく，演算が定義された代数的な側面を持つ数学的な対象を考えることができます．\n\n\n\n\n\n\n\n📘 Key Takeaways\n\n\n\n\n\n ▶  複素ベクトル空間\n１次元複素ベクトル空間 \\(\\mathbb{C}\\) について，複素数 \\(z = a + bi, (a, b \\in \\mathbb R)\\) に対して\n\n\\((a, b)\\) を対応させる写像 \\(\\mathbb C\\to \\mathbb R^2\\) は全単射\n任意の \\(w, z \\in \\mathbb C\\) に対して，\\(w + z\\) の実部と虚部の組は \\(\\mathbb R^2\\) に含まれるので，和を保つ\nスカラーとして \\(\\lambda \\in \\mathbb R\\) を考えると，スカラー倍も保つ\n\n以上より，\\(\\mathbb{C}\\) は２次元実ベクトル空間 \\(\\mathbb R^2\\) と同一視できます．同様に \\(n\\)次元複素ベクトル空間 \\(\\mathbb C^n\\)は \\(2n\\)次元実ベクトル空間 \\(\\mathbb R^{2n}\\) とみなすことができます．\n ▶  複素ベクトル空間と実ベクトル空間の違い\n\nベクトル空間として，実数上で考えるのと複素数上で考えるのでは多くの場合大差はない\n一方，固有値や固有ベクトル，内積を考える場合には違いが生じる"
  },
  {
    "objectID": "posts/2025-01-08-bigquery-preprocess-01/index.html",
    "href": "posts/2025-01-08-bigquery-preprocess-01/index.html",
    "title": "BigQuery: TIME型カラムを指定したレベルで丸めて集計する",
    "section": "",
    "text": "▶  スーパーの来店時刻データ\n\n\n\nmember_id\nusage_date\nusage_time\n\n\n\n\n\n123456\n2024-02-01\n08:09:00\n\n\n\n223456\n2024-02-01\n08:10:00\n\n\n\n223456\n2024-02-11\n08:10:00\n\n\n\n123456\n2024-02-01\n20:09:00\n\n\n\n323456\n2024-02-01\n20:09:00\n\n\n\n\nという形でとあるスーパーの来店時刻データregmonkey-sample-data.restaurant_kawasaki.customer_recordが与えられているとします． このとき，以下の3つの処理を実施して，曜日×時間帯別平均来店者数の集計を行いたいとします．\n ▶  処理1: 24時間オーバーのデータへ変換\n\n00:01:00 → 24:00:00\n01:01:59 → 25:00:00\n\nのように夜中02:59:59までは26:59:59へ変換するという処理\n ▶  処理2: TIME型データを丸める\n\n08:09:00 → 08:00:00\n08:20:00 → 08:15:00\n\nのようにTIME型データを15分刻みに丸める処理\n ▶  処理3: DATE型データをISO day of weekへ変換\n\n月曜日を1, 日曜日を7とするISO day of weekに変換する\n祝日は8をアサインする\n\n2024-02-11, 2024-02-23は8がアサインされる"
  },
  {
    "objectID": "posts/2025-01-08-bigquery-preprocess-01/index.html#what-i-want-to-do",
    "href": "posts/2025-01-08-bigquery-preprocess-01/index.html#what-i-want-to-do",
    "title": "BigQuery: TIME型カラムを指定したレベルで丸めて集計する",
    "section": "",
    "text": "▶  スーパーの来店時刻データ\n\n\n\nmember_id\nusage_date\nusage_time\n\n\n\n\n\n123456\n2024-02-01\n08:09:00\n\n\n\n223456\n2024-02-01\n08:10:00\n\n\n\n223456\n2024-02-11\n08:10:00\n\n\n\n123456\n2024-02-01\n20:09:00\n\n\n\n323456\n2024-02-01\n20:09:00\n\n\n\n\nという形でとあるスーパーの来店時刻データregmonkey-sample-data.restaurant_kawasaki.customer_recordが与えられているとします． このとき，以下の3つの処理を実施して，曜日×時間帯別平均来店者数の集計を行いたいとします．\n ▶  処理1: 24時間オーバーのデータへ変換\n\n00:01:00 → 24:00:00\n01:01:59 → 25:00:00\n\nのように夜中02:59:59までは26:59:59へ変換するという処理\n ▶  処理2: TIME型データを丸める\n\n08:09:00 → 08:00:00\n08:20:00 → 08:15:00\n\nのようにTIME型データを15分刻みに丸める処理\n ▶  処理3: DATE型データをISO day of weekへ変換\n\n月曜日を1, 日曜日を7とするISO day of weekに変換する\n祝日は8をアサインする\n\n2024-02-11, 2024-02-23は8がアサインされる"
  },
  {
    "objectID": "posts/2025-01-08-bigquery-preprocess-01/index.html#query-example",
    "href": "posts/2025-01-08-bigquery-preprocess-01/index.html#query-example",
    "title": "BigQuery: TIME型カラムを指定したレベルで丸めて集計する",
    "section": "Query Example",
    "text": "Query Example\n ▶  処理1: 24時間オーバーのデータへ変換\nTIME型のままでは23:59:59までしかカバーされないので，extended timeの表記を試みたい場合はSTRING型へ変換する必要があります．\nCREATE TEMP FUNCTION convert_extended_time(standard_time TIME)\nRETURNS STRING\nAS (\n  CASE \n    WHEN EXTRACT(HOUR FROM standard_time) &lt; 3 THEN\n      FORMAT(\"%02d:%02d:%02d\", EXTRACT(HOUR FROM standard_time) + 24, EXTRACT(MINUTE FROM standard_time), EXTRACT(SECOND FROM standard_time))\n    ELSE \n      FORMAT(\"%02d:%02d:%02d\", EXTRACT(HOUR FROM standard_time), EXTRACT(MINUTE FROM standard_time), EXTRACT(SECOND FROM standard_time))\n  END\n);\n ▶  処理2: TIME型データを丸める\nCREATE TEMP FUNCTION round_to_nearest_15_minute(usage_time TIME, round_level INT64)\nRETURNS TIME\nAS (\n  TIME_TRUNC(\n    TIME_SUB(usage_time, INTERVAL MOD(EXTRACT(MINUTE FROM usage_time), round_level) MINUTE),\n    MINUTE\n  )\n);\n ▶  処理3: DATE型データをISO day of weekへ変換\nBigQueryが提供する EXTRACT(DAYOFWEEK FROM &lt;date-column&gt;) は日曜日1から始まり土曜日7で終わる形式となっているので自分で以下のように関数をUDFを定義することが必要になります．\nCREATE TEMP FUNCTION convert_iso_dayofweek(usage_date DATE)\nRETURNS INT64\nAS (\n  MOD(EXTRACT(DAYOFWEEK FROM usage_date) + 5, 7) + 1\n);\n ▶  データ抽出クエリ\nWITH\n  daily_summary AS(\n    SELECT \n        usage_date,\n        round_to_nearest_15_minute(usage_time, 15) AS rounded_usage_time,\n        CASE\n          WHEN usage_date in (DATE('2024-02-11'), DATE('2024-02-23')) THEN 8\n          ELSE convert_iso_dayofweek(usage_date) \n        END AS dayofweek,\n        COUNT(1) AS customer_count\n    FROM \n        `regmonkey-sample-data.restaurant_kawasaki.customer_record`\n    GROUP BY\n        1, 2\n  )\nSELECT\n    dayofweek,\n    convert_extended_time(rounded_usage_time) AS rounded_usage_time,\n    AVG(customer_count) AS mean_customer_count\nFROM\n    daily_summary \nGROUP BY \n  1, 2\nORDER BY\n  1, 2;"
  },
  {
    "objectID": "posts/2025-03-05-addition-theorem/index.html",
    "href": "posts/2025-03-05-addition-theorem/index.html",
    "title": "三角関数の加法定理",
    "section": "",
    "text": "Theorem 1 : 加法定理 \n\\[\n\\begin{align}\n\\sin (\\alpha + \\beta) &= \\sin \\alpha \\cos \\beta + \\cos \\alpha \\sin \\beta\\\\\n\\cos (\\alpha + \\beta) &= \\cos \\alpha \\cos \\beta - \\sin \\alpha \\sin \\beta\n\\end{align}\n\\]\n\n\n「咲いたコスモス，コスモス咲いた」なり「しこってこすってこすってしこって」と語呂合わせで加法定理を覚えたりしますが，ここでは加法定理を図形的に考えてみたいと思います．\n\n\n\n\n\n\nFigure 1\n\n\n\nFigure 1 のように半径 \\(1\\) の単位円周上に \\(\\angle DOB = \\alpha + \\beta\\) となる点 \\(B\\) をとります． 同じく \\(\\angle AOD = \\alpha\\) となるように点をとると，\\(\\angle BOA = \\beta\\) となります．このとき，点 \\(B\\) の \\(y\\) 成分は \\(\\sin(\\alpha + \\beta)\\) となります．\n点 \\(B\\) から直線 \\(OA\\) 上に垂線を下ろし，その交点を \\(C\\) とすると \\(OB = 1\\) より\n\\[\n\\begin{align}\nBC & = \\sin\\beta\\\\\nOC &= \\cos\\beta\n\\end{align}\n\\]\nとなることがわかります．点 \\(C\\) から垂線を下ろし，\\(x\\) 軸との交点を \\(E\\), \\(B\\) から直線 \\(CE\\) との交点を \\(F\\) とすると\n\\[\n\\begin{align}\nCE &= \\sin \\alpha\\cos\\beta\\\\\nCF &= \\cos\\alpha\\sin\\beta\n\\end{align}\n\\]\nしたがって，\\(CE + CF = \\sin(\\alpha + \\beta)\\) となることから\n\\[\n\\sin (\\alpha + \\beta) = \\sin \\alpha \\cos \\beta + \\cos \\alpha \\sin \\beta\n\\]\nとなることが図形的にわかります．同様に\n\\[\n\\begin{align}\nOE &= \\cos\\alpha\\cos\\beta\\\\\nBF&= \\sin\\alpha\\sin\\beta\n\\end{align}\n\\]\nより\n\\[\n\\cos(\\alpha + \\beta) = OE - BF = \\cos\\alpha\\cos\\beta - \\sin\\alpha\\sin\\beta\n\\]\n ▶  ２角の差 \\(\\alpha - \\beta\\) の場合\n\\(\\sin(-\\beta) = -\\sin(\\beta)\\) および \\(\\cos(-\\beta) = \\cos\\beta\\) より\n\\[\n\\begin{align}\n\\sin (\\alpha - \\beta)\n    &= \\sin (\\alpha  + (-\\beta))\\\\\n    &= \\sin \\alpha \\cos (-\\beta) + \\cos \\alpha \\sin (-\\beta)\\\\\n    &= \\sin \\alpha \\cos \\beta - \\cos \\alpha \\sin \\beta\n\\end{align}\n\\]\n同様に\n\\[\n\\begin{align}\n\\cos (\\alpha - \\beta)\n    &= \\cos (\\alpha  + (-\\beta))\\\\\n    &= \\cos \\alpha \\cos (-\\beta) - \\sin \\alpha \\sin (-\\beta)\\\\\n    &= \\cos \\alpha \\cos \\beta + \\sin \\alpha \\sin \\beta\n\\end{align}\n\\]\n以上より\n\\[\n\\begin{align}\n\\sin (\\alpha \\pm \\beta) &= \\sin \\alpha \\cos \\beta \\pm \\cos \\alpha \\sin \\beta\\\\\n\\cos (\\alpha \\pm \\beta) &= \\cos \\alpha \\cos \\beta \\mp \\sin \\alpha \\sin \\beta\n\\end{align}\n\\]\n\n📘 REMARKS \n\\(\\sin \\theta\\) は奇関数，\\(\\cos \\theta\\) は偶関数であることに留意すると\n\\[\n\\begin{align}\n\\text{奇関数} \\times \\text{偶関数} &= \\text{奇関数}\\\\\n\\text{偶関数} \\times \\text{偶関数} &= \\text{偶関数}\\\\\n\\text{偶関数} + \\text{偶関数} &= \\text{偶関数}\\\\\n\\text{奇関数} + \\text{奇関数} &= \\text{奇関数}\n\\end{align}\n\\]\nであるので，加法定理のRHSとLHSがそれぞれ対応していることがわかります．\n\n\n\n\n\nTheorem 2 : オイラーの公式 \n\\[\n\\exp(i\\theta) = \\cos\\theta + i\\sin\\theta\n\\]\n\n\n\n\n\n\n\n\n\nオイラーの公式を用いた加法定理の導出\n\n\n\n\n\n\\[\n\\begin{align}\n\\exp(i(\\alpha + \\beta))\n    &= \\exp(i\\alpha)\\exp(i\\beta)\\\\\n    &= (\\cos\\alpha + i\\sin\\alpha)(\\cos\\beta + i\\sin\\beta)\\\\\n    &= \\cos\\alpha\\cos\\beta - \\sin\\alpha\\sin\\beta + i(\\sin\\alpha\\cos\\beta + \\cos\\alpha\\sin\\beta)\n\\end{align}\n\\]\n\\(\\exp(i(\\alpha + \\beta)) = \\cos(\\alpha + \\beta) + i\\sin(\\alpha + \\beta)\\) であることから実部と虚部の比較より\n\\[\n\\begin{align}\n\\sin (\\alpha + \\beta) &= \\sin \\alpha \\cos \\beta + \\cos \\alpha \\sin \\beta\\\\\n\\cos (\\alpha + \\beta) &= \\cos \\alpha \\cos \\beta - \\sin \\alpha \\sin \\beta\n\\end{align}\n\\]\n二角の差の場合は\n\\[\n\\exp(i(\\alpha - \\beta))= \\exp(i\\alpha)\\exp(-i\\beta)\n\\]\nから同様に示すことが出来ます．\n\n\n\n\n\n\n\n\n\n\n\n\n\nProof\n\n\n\n\n\n正弦と余弦の加法定理より\n\\[\n\\begin{align}\n\\tan(\\alpha \\pm \\beta)\n    &= \\frac{\\sin(\\alpha \\pm \\beta)}{\\cos(\\alpha \\pm \\beta)}\\\\\n    &= \\frac{\\sin \\alpha \\cos \\beta \\pm \\cos \\alpha \\sin \\beta}{\\cos \\alpha \\cos \\beta \\mp \\sin \\alpha \\sin \\beta}\n\\end{align}\n\\]\n分子と分母を \\(\\cos \\alpha \\cos \\beta\\) で割ると\n\\[\n\\begin{align}\n\\tan(\\alpha \\pm \\beta) = \\frac{\\tan \\alpha \\pm \\tan \\beta}{1 \\mp \\tan \\alpha \\tan \\beta}\n\\end{align}\n\\]\n\n\n\n\n\nExercise 1 \n\\(\\tan 1^\\circ\\) が無理数であることを示せ\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\\(\\tan 1^\\circ\\) がとある有理数 \\(a\\) であると仮定すると，加法定理より\n\\[\n\\tan 2^\\circ = \\frac{2a}{1 - a^2}\n\\]\nとなり，有理数の四則演算は有理数で閉じていることから \\(\\tan 2^\\circ\\) も有理数であることがわかる．同様に \\(4^\\circ, 8^\\circ, 16^\\circ, 32^\\circ\\) も有理数であることがわかる．\nここで，\n\\[\n\\tan 30^\\circ = \\frac{\\sqrt{3}}{3}\n\\]\nより \\(\\tan 30^\\circ\\) は無理数であることに着目する．一方，\\(\\tan 30^\\circ\\) は加法定理より\n\\[\n\\begin{align}\n\\tan 30^\\circ\n    &= \\tan (32^\\circ - 2^\\circ)\\\\\n    &= \\frac{\\tan 32^\\circ + \\tan 2^\\circ}{1 + \\tan 32^\\circ\\tan 2^\\circ}\n\\end{align}\n\\]\nこのとき，\\(\\tan 32^\\circ, \\tan 2^\\circ\\) はともに有理数であるので， \\(\\tan 30^\\circ\\) は無理数であることと矛盾． したがって，\\(\\tan 1^\\circ\\) は無理数である．"
  },
  {
    "objectID": "posts/2025-03-05-addition-theorem/index.html#加法定理",
    "href": "posts/2025-03-05-addition-theorem/index.html#加法定理",
    "title": "三角関数の加法定理",
    "section": "",
    "text": "Theorem 1 : 加法定理 \n\\[\n\\begin{align}\n\\sin (\\alpha + \\beta) &= \\sin \\alpha \\cos \\beta + \\cos \\alpha \\sin \\beta\\\\\n\\cos (\\alpha + \\beta) &= \\cos \\alpha \\cos \\beta - \\sin \\alpha \\sin \\beta\n\\end{align}\n\\]\n\n\n「咲いたコスモス，コスモス咲いた」なり「しこってこすってこすってしこって」と語呂合わせで加法定理を覚えたりしますが，ここでは加法定理を図形的に考えてみたいと思います．\n\n\n\n\n\n\nFigure 1\n\n\n\nFigure 1 のように半径 \\(1\\) の単位円周上に \\(\\angle DOB = \\alpha + \\beta\\) となる点 \\(B\\) をとります． 同じく \\(\\angle AOD = \\alpha\\) となるように点をとると，\\(\\angle BOA = \\beta\\) となります．このとき，点 \\(B\\) の \\(y\\) 成分は \\(\\sin(\\alpha + \\beta)\\) となります．\n点 \\(B\\) から直線 \\(OA\\) 上に垂線を下ろし，その交点を \\(C\\) とすると \\(OB = 1\\) より\n\\[\n\\begin{align}\nBC & = \\sin\\beta\\\\\nOC &= \\cos\\beta\n\\end{align}\n\\]\nとなることがわかります．点 \\(C\\) から垂線を下ろし，\\(x\\) 軸との交点を \\(E\\), \\(B\\) から直線 \\(CE\\) との交点を \\(F\\) とすると\n\\[\n\\begin{align}\nCE &= \\sin \\alpha\\cos\\beta\\\\\nCF &= \\cos\\alpha\\sin\\beta\n\\end{align}\n\\]\nしたがって，\\(CE + CF = \\sin(\\alpha + \\beta)\\) となることから\n\\[\n\\sin (\\alpha + \\beta) = \\sin \\alpha \\cos \\beta + \\cos \\alpha \\sin \\beta\n\\]\nとなることが図形的にわかります．同様に\n\\[\n\\begin{align}\nOE &= \\cos\\alpha\\cos\\beta\\\\\nBF&= \\sin\\alpha\\sin\\beta\n\\end{align}\n\\]\nより\n\\[\n\\cos(\\alpha + \\beta) = OE - BF = \\cos\\alpha\\cos\\beta - \\sin\\alpha\\sin\\beta\n\\]\n ▶  ２角の差 \\(\\alpha - \\beta\\) の場合\n\\(\\sin(-\\beta) = -\\sin(\\beta)\\) および \\(\\cos(-\\beta) = \\cos\\beta\\) より\n\\[\n\\begin{align}\n\\sin (\\alpha - \\beta)\n    &= \\sin (\\alpha  + (-\\beta))\\\\\n    &= \\sin \\alpha \\cos (-\\beta) + \\cos \\alpha \\sin (-\\beta)\\\\\n    &= \\sin \\alpha \\cos \\beta - \\cos \\alpha \\sin \\beta\n\\end{align}\n\\]\n同様に\n\\[\n\\begin{align}\n\\cos (\\alpha - \\beta)\n    &= \\cos (\\alpha  + (-\\beta))\\\\\n    &= \\cos \\alpha \\cos (-\\beta) - \\sin \\alpha \\sin (-\\beta)\\\\\n    &= \\cos \\alpha \\cos \\beta + \\sin \\alpha \\sin \\beta\n\\end{align}\n\\]\n以上より\n\\[\n\\begin{align}\n\\sin (\\alpha \\pm \\beta) &= \\sin \\alpha \\cos \\beta \\pm \\cos \\alpha \\sin \\beta\\\\\n\\cos (\\alpha \\pm \\beta) &= \\cos \\alpha \\cos \\beta \\mp \\sin \\alpha \\sin \\beta\n\\end{align}\n\\]\n\n📘 REMARKS \n\\(\\sin \\theta\\) は奇関数，\\(\\cos \\theta\\) は偶関数であることに留意すると\n\\[\n\\begin{align}\n\\text{奇関数} \\times \\text{偶関数} &= \\text{奇関数}\\\\\n\\text{偶関数} \\times \\text{偶関数} &= \\text{偶関数}\\\\\n\\text{偶関数} + \\text{偶関数} &= \\text{偶関数}\\\\\n\\text{奇関数} + \\text{奇関数} &= \\text{奇関数}\n\\end{align}\n\\]\nであるので，加法定理のRHSとLHSがそれぞれ対応していることがわかります．\n\n\n\n\n\nTheorem 2 : オイラーの公式 \n\\[\n\\exp(i\\theta) = \\cos\\theta + i\\sin\\theta\n\\]\n\n\n\n\n\n\n\n\n\nオイラーの公式を用いた加法定理の導出\n\n\n\n\n\n\\[\n\\begin{align}\n\\exp(i(\\alpha + \\beta))\n    &= \\exp(i\\alpha)\\exp(i\\beta)\\\\\n    &= (\\cos\\alpha + i\\sin\\alpha)(\\cos\\beta + i\\sin\\beta)\\\\\n    &= \\cos\\alpha\\cos\\beta - \\sin\\alpha\\sin\\beta + i(\\sin\\alpha\\cos\\beta + \\cos\\alpha\\sin\\beta)\n\\end{align}\n\\]\n\\(\\exp(i(\\alpha + \\beta)) = \\cos(\\alpha + \\beta) + i\\sin(\\alpha + \\beta)\\) であることから実部と虚部の比較より\n\\[\n\\begin{align}\n\\sin (\\alpha + \\beta) &= \\sin \\alpha \\cos \\beta + \\cos \\alpha \\sin \\beta\\\\\n\\cos (\\alpha + \\beta) &= \\cos \\alpha \\cos \\beta - \\sin \\alpha \\sin \\beta\n\\end{align}\n\\]\n二角の差の場合は\n\\[\n\\exp(i(\\alpha - \\beta))= \\exp(i\\alpha)\\exp(-i\\beta)\n\\]\nから同様に示すことが出来ます．\n\n\n\n\n\n\n\n\n\n\n\n\n\nProof\n\n\n\n\n\n正弦と余弦の加法定理より\n\\[\n\\begin{align}\n\\tan(\\alpha \\pm \\beta)\n    &= \\frac{\\sin(\\alpha \\pm \\beta)}{\\cos(\\alpha \\pm \\beta)}\\\\\n    &= \\frac{\\sin \\alpha \\cos \\beta \\pm \\cos \\alpha \\sin \\beta}{\\cos \\alpha \\cos \\beta \\mp \\sin \\alpha \\sin \\beta}\n\\end{align}\n\\]\n分子と分母を \\(\\cos \\alpha \\cos \\beta\\) で割ると\n\\[\n\\begin{align}\n\\tan(\\alpha \\pm \\beta) = \\frac{\\tan \\alpha \\pm \\tan \\beta}{1 \\mp \\tan \\alpha \\tan \\beta}\n\\end{align}\n\\]\n\n\n\n\n\nExercise 1 \n\\(\\tan 1^\\circ\\) が無理数であることを示せ\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\\(\\tan 1^\\circ\\) がとある有理数 \\(a\\) であると仮定すると，加法定理より\n\\[\n\\tan 2^\\circ = \\frac{2a}{1 - a^2}\n\\]\nとなり，有理数の四則演算は有理数で閉じていることから \\(\\tan 2^\\circ\\) も有理数であることがわかる．同様に \\(4^\\circ, 8^\\circ, 16^\\circ, 32^\\circ\\) も有理数であることがわかる．\nここで，\n\\[\n\\tan 30^\\circ = \\frac{\\sqrt{3}}{3}\n\\]\nより \\(\\tan 30^\\circ\\) は無理数であることに着目する．一方，\\(\\tan 30^\\circ\\) は加法定理より\n\\[\n\\begin{align}\n\\tan 30^\\circ\n    &= \\tan (32^\\circ - 2^\\circ)\\\\\n    &= \\frac{\\tan 32^\\circ + \\tan 2^\\circ}{1 + \\tan 32^\\circ\\tan 2^\\circ}\n\\end{align}\n\\]\nこのとき，\\(\\tan 32^\\circ, \\tan 2^\\circ\\) はともに有理数であるので， \\(\\tan 30^\\circ\\) は無理数であることと矛盾． したがって，\\(\\tan 1^\\circ\\) は無理数である．"
  },
  {
    "objectID": "posts/2025-03-05-addition-theorem/index.html#倍角の公式とサインカーブ",
    "href": "posts/2025-03-05-addition-theorem/index.html#倍角の公式とサインカーブ",
    "title": "三角関数の加法定理",
    "section": "倍角の公式とサインカーブ",
    "text": "倍角の公式とサインカーブ\n\n\nTheorem 3 : 倍角の公式 \n\\[\n\\begin{align}\n\\sin 2\\theta &= 2\\sin\\theta\\cos\\theta\\\\\n\\cos 2\\theta &= \\cos^2\\theta - \\sin^2\\theta\\\\\n             &= 1 - 2\\sin^2\\theta = 2\\cos^2\\theta - 1\\\\\n\\tan 2\\theta &= \\frac{2\\tan\\theta}{1 - \\tan^2\\theta}\n\\end{align}\n\\]\n\n\n\\(y = \\sin x\\) は振幅 \\(1\\) で周期 \\(2\\pi\\) の周期関数ですが，\n\\[\ny = \\alpha\\sin \\beta x \\quad \\alpha &gt; 0, \\beta &gt; 0\n\\]\nと変形すると，振幅 \\(\\alpha\\) で周期 \\(\\displaystyle \\frac{2\\pi}{\\beta}\\) の周期関数となります．\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport matplotlib.ticker as ticker\n\n# Define the x values\nx = np.linspace(-2 * np.pi, 2 * np.pi, 400)\n\n# Define the y values for both functions\ny1 = np.sin(x)\ny2 = np.sin(x / 2)\ny3 = 3 * np.sin(2 * x)\n\n# Create the plot\nplt.figure(figsize=(10, 6))\nplt.plot(x, y1, label=r\"$y = \\sin(x)$\", color=\"b\")\nplt.plot(x, y2, label=r\"$y = \\sin(x/2)$\", color=\"r\", linestyle=\"--\")\nplt.plot(x, y3, label=r\"$y = 3\\sin(2x)$\", color=\"gray\", linestyle=\"--\")\n\n# Add labels, title, and legend\nplt.xlabel(\"x\")\nplt.ylabel(\"y\")\nplt.title(\"Comparison of $y = \\sin(x)$ and $y = \\sin(x/2)$, $y = 3\\sin(2x)$\")\nplt.axhline(0, color=\"black\", linewidth=0.5)\nplt.axvline(0, color=\"black\", linewidth=0.5)\nplt.legend()\nplt.grid(True)\n\n# Set x-ticks to multiples of pi\nxticks = np.arange(-2 * np.pi, 2.5 * np.pi, np.pi / 2)\nxtick_labels = [\n    r\"$-2\\pi$\",\n    r\"$-\\frac{3\\pi}{2}$\",\n    r\"$-\\pi$\",\n    r\"$-\\frac{\\pi}{2}$\",\n    \"0\",\n    r\"$\\frac{\\pi}{2}$\",\n    r\"$\\pi$\",\n    r\"$\\frac{3\\pi}{2}$\",\n    r\"$2\\pi$\",\n]\nplt.xticks(xticks, xtick_labels)\n\n# Show the plot\nplt.show()\n\n\n\n\n\n\n\n\n\n次に，\\(y = \\sin x \\cos x\\) のグラフを考えてみます．加法定理より\n\\[\n\\begin{align}\n\\sin 2x\n    &= \\sin (x + x)\\\\\n    &= 2\\sin x\\cos x\n\\end{align}\n\\]\nであることから\n\\[\n\\sin x \\cos x = \\frac{1}{2}\\sin 2x\n\\]\nつまり，\\(y = \\sin x \\cos x\\) のグラフは振幅 \\(\\displaystyle \\frac{1}{2}\\)，周期 \\(\\pi\\) のサインカーブとなることがわかります．\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport matplotlib.ticker as ticker\n\n# Define the x values\nx = np.linspace(-2 * np.pi, 2 * np.pi, 400)\n\n# Define the y values for both functions\ny1 = np.sin(x) * np.cos(x)\ny2 = np.sin(2 * x) /2\n\n# Create the plot\nplt.figure(figsize=(10, 6))\nplt.plot(x, y1, label=r\"$y = \\sin(x)$\", color=\"b\")\nplt.plot(x, y2, label=r\"$y = \\frac{1}{2}\\sin(2x)$\", color=\"gray\", linestyle=\"--\")\n\n# Add labels, title, and legend\nplt.xlabel(\"x\")\nplt.ylabel(\"y\")\nplt.axhline(0, color=\"black\", linewidth=0.5)\nplt.axvline(0, color=\"black\", linewidth=0.5)\nplt.legend()\nplt.grid(True)\n\n# Set x-ticks to multiples of pi\nxticks = np.arange(-2 * np.pi, 2.5 * np.pi, np.pi / 2)\nxtick_labels = [\n    r\"$-2\\pi$\",\n    r\"$-\\frac{3\\pi}{2}$\",\n    r\"$-\\pi$\",\n    r\"$-\\frac{\\pi}{2}$\",\n    \"0\",\n    r\"$\\frac{\\pi}{2}$\",\n    r\"$\\pi$\",\n    r\"$\\frac{3\\pi}{2}$\",\n    r\"$2\\pi$\",\n]\nplt.xticks(xticks, xtick_labels)\n\n# Show the plot\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\nTheorem 4 : 半角の公式 \n\\[\n\\begin{align}\n\\sin^2 \\frac{\\theta}{2} &= \\frac{1 - \\cos\\theta}{2}\\\\\n\\cos^2 \\frac{\\theta}{2} &= \\frac{1 + \\cos\\theta}{2}\\\\\n\\tan^2 \\frac{\\theta}{2} &= \\frac{1 - \\cos\\theta}{1 + \\cos\\theta}\n\\end{align}\n\\]\n\n\n\nExample 1 \n\\(y = \\sin^2 x\\) について考えてみます．正弦関数は奇関数であるので，\\(\\sin^2 x\\) は偶関数になるはずです．半角の公式を用いると\n\\[\n\\sin^2 x = \\frac{1 - \\cos 2x}{2}\n\\]\nとなるので，振幅 \\(\\displaystyle\\frac{1}{2}\\), 周期 \\(\\pi\\) のコサインカーブを \\(\\displaystyle\\frac{1}{2}\\) 平行移動したものであることがわかります．\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport matplotlib.ticker as ticker\n\n# Define the x values\nx = np.linspace(-2 * np.pi, 2 * np.pi, 400)\n\n# Define the y values for both functions\ny1 = (1 - np.cos(2 * x))/2\ny2 = np.cos(2 * x)\n\n# Create the plot\nplt.figure(figsize=(8, 6))\nplt.plot(x, y1, label=r\"$y = \\sin^2(x)$\", color=\"b\")\nplt.plot(x, y2, label=r\"$y = \\cos(x)$\", color=\"gray\", linestyle=\"--\")\n\n# Add labels, title, and legend\nplt.xlabel(\"x\")\nplt.ylabel(\"y\")\nplt.axhline(0, color=\"black\", linewidth=0.5)\nplt.axvline(0, color=\"black\", linewidth=0.5)\nplt.legend( loc='lower right',)\nplt.grid(True)\n\n# Set x-ticks to multiples of pi\nxticks = np.arange(-2 * np.pi, 2.5 * np.pi, np.pi / 2)\nxtick_labels = [\n    r\"$-2\\pi$\",\n    r\"$-\\frac{3\\pi}{2}$\",\n    r\"$-\\pi$\",\n    r\"$-\\frac{\\pi}{2}$\",\n    \"0\",\n    r\"$\\frac{\\pi}{2}$\",\n    r\"$\\pi$\",\n    r\"$\\frac{3\\pi}{2}$\",\n    r\"$2\\pi$\",\n]\nplt.xticks(xticks, xtick_labels)\n\n\n# Show the plot\nplt.show()"
  },
  {
    "objectID": "posts/2025-03-05-addition-theorem/index.html#和積の公式",
    "href": "posts/2025-03-05-addition-theorem/index.html#和積の公式",
    "title": "三角関数の加法定理",
    "section": "和積の公式",
    "text": "和積の公式\n\n\nTheorem 5 : 正弦関数の和積の公式 \n\\[\n\\begin{align}\n\\sin \\alpha + \\sin\\beta &= 2 \\sin \\frac{\\alpha+\\beta}{2}\\cos \\frac{\\alpha-\\beta}{2}\\\\\n\\sin \\alpha - \\sin\\beta &= 2 \\cos \\frac{\\alpha+\\beta}{2}\\sin \\frac{\\alpha-\\beta}{2}\\\\\n\\cos \\alpha + \\cos\\beta &= 2 \\cos \\frac{\\alpha+\\beta}{2}\\cos \\frac{\\alpha-\\beta}{2}\\\\\n\\cos \\alpha - \\cos\\beta &= -2 \\sin \\frac{\\alpha+\\beta}{2}\\sin \\frac{\\alpha-\\beta}{2}\n\\end{align}\n\\]\n\n\n\n\n\n\n\n\n\nProof\n\n\n\n\n\n加法定理より\n\\[\n\\begin{align}\n\\sin (\\gamma + \\delta)\n    &= \\sin\\gamma \\cos\\delta + \\cos\\gamma \\sin\\delta\\\\\n\\sin (\\gamma - \\delta)\n    &= \\sin\\gamma \\cos\\delta - \\cos\\gamma \\sin\\delta\n\\end{align}\n\\]\nこれを整理すると\n\\[\n\\begin{align}\n\\sin (\\gamma + \\delta) + \\sin (\\gamma - \\delta) &= 2\\sin\\gamma \\cos\\delta\\\\\n\\sin (\\gamma + \\delta) - \\sin (\\gamma - \\delta) &= 2\\cos\\gamma \\sin\\delta\n\\end{align}\n\\]\nここで，\\(\\gamma + \\delta = \\alpha, \\gamma - \\delta = \\beta\\) とおくと\n\\[\n\\begin{gather}\n\\gamma = \\frac{ \\alpha + \\beta}{2}, \\quad \\delta = \\frac{\\alpha - \\beta}{2}\n\\end{gather}\n\\]\nとなるので\n\\[\n\\begin{align}\n\\sin \\alpha + \\sin\\beta &= 2 \\sin \\frac{\\alpha+\\beta}{2}\\cos \\frac{\\alpha-\\beta}{2}\\\\\n\\sin \\alpha - \\sin\\beta &= 2 \\cos \\frac{\\alpha+\\beta}{2}\\sin \\frac{\\alpha-\\beta}{2}\n\\end{align}\n\\]\n余弦関数も同様に\n\\[\n\\begin{align}\n\\cos (\\gamma + \\delta)\n    &= \\cos\\gamma \\cos\\delta - \\sin\\gamma \\sin\\delta\\\\\n\\cos (\\gamma - \\delta)\n    &= \\cos\\gamma \\cos\\delta + \\sin\\gamma \\sin\\delta\n\\end{align}\n\\]\nであるので\n\\[\n\\begin{align}\n\\cos (\\gamma + \\delta) + \\cos (\\gamma - \\delta) &= 2\\cos\\gamma \\cos\\delta\\\\\n\\cos (\\gamma + \\delta) - \\cos (\\gamma - \\delta) &= -2\\sin\\gamma \\sin\\delta\n\\end{align}\n\\]\nから導くことができます．\n\n\n\n\nExample 2 \n\\(x + y + z = \\pi\\) を満たす実数 \\(x, y, z\\) について\n\\[\n\\sin x + \\sin y + \\sin z = 4 \\cos\\frac{x}{2}\\cos\\frac{y}{2}\\cos\\frac{z}{2}\n\\]\nが成り立ちます．LHSを式変形すると\n\\[\n\\begin{align}\n\\sin x + \\sin y + \\sin z\n    &= \\sin x + \\sin y + \\sin (\\pi - (x + y))\\\\\n    &= \\sin x + \\sin y + \\sin (x + y)\\\\\n    &= 2\\sin\\frac{x+y}{2}\\cos\\frac{x-y}{2} + 2\\sin\\frac{x+y}{2}\\cos\\frac{x+y}{2}\\\\\n    &= 2\\sin\\frac{x+y}{2}\\left(\\cos\\frac{x-y}{2} + \\cos\\frac{x+y}{2}\\right)\\\\\n    &= 2\\sin\\frac{x+y}{2}\\times 2\\cos\\frac{\\frac{x-y}{2} + \\frac{x-y}{2}}{2}\\cos\\frac{\\frac{x-y}{2} - \\frac{x-y}{2}}{2}\\\\\n    &=4\\sin\\frac{x+y}{2}\\cos\\frac{x}{2}\\cos\\frac{-y}{2}\\\\\n    &=4\\sin\\frac{\\pi-z}{2}\\cos\\frac{x}{2}\\cos\\frac{y}{2}\\\\\n    &=4\\cos\\frac{z}{2}\\cos\\frac{x}{2}\\cos\\frac{y}{2}\n\\end{align}\n\\]"
  },
  {
    "objectID": "posts/2025-03-05-addition-theorem/index.html#references",
    "href": "posts/2025-03-05-addition-theorem/index.html#references",
    "title": "三角関数の加法定理",
    "section": "References",
    "text": "References\n\nRegmonkey Datascience Blog &gt; tangent 75°の図形的計算\nRegmonkey Datascience Blog &gt; 三角形の内接円"
  },
  {
    "objectID": "posts/2024-12-16-ssh-to-macos/index.html",
    "href": "posts/2024-12-16-ssh-to-macos/index.html",
    "title": "macOSへのssh接続",
    "section": "",
    "text": "同じprivate networkに属しているmacOS端末に対して公開鍵認証を用いてssh接続したい\n\n同じprovate networkに属している前提の端末へのsshになるので\nssh hoshinokirby@192.168.10.110\nのように自宅内のネットワークのみで有効なプライベートIPアドレス（クラスC 192.168.0.0 ~ 192.168.255.255）を指定してアクセスすることを想定しています．"
  },
  {
    "objectID": "posts/2024-12-16-ssh-to-macos/index.html#what-we-want-to-do",
    "href": "posts/2024-12-16-ssh-to-macos/index.html#what-we-want-to-do",
    "title": "macOSへのssh接続",
    "section": "",
    "text": "同じprivate networkに属しているmacOS端末に対して公開鍵認証を用いてssh接続したい\n\n同じprovate networkに属している前提の端末へのsshになるので\nssh hoshinokirby@192.168.10.110\nのように自宅内のネットワークのみで有効なプライベートIPアドレス（クラスC 192.168.0.0 ~ 192.168.255.255）を指定してアクセスすることを想定しています．"
  },
  {
    "objectID": "posts/2024-12-16-ssh-to-macos/index.html#how-to-set-up",
    "href": "posts/2024-12-16-ssh-to-macos/index.html#how-to-set-up",
    "title": "macOSへのssh接続",
    "section": "How to set up",
    "text": "How to set up\n ▶  Server側\nSSHサーバー側はopenssh-serverなりssh serverが動いている必要があります．\n\nSystem Preferences &gt; Sharingをクリック\nRemote Loginを有効化\n\n以上の2ステップで，macOS側のSSH serverをactive状態にすることができます．\n ▶  Client側\nパスワード認証の場合は\n\narpコマンドでアクセス先端末のプライベートIPアドレスを検索\nsshコマンドでアクセス\n\nで完了となりますが，今回は公開鍵認証手順を紹介します．公開鍵認証の場合は\n\nSSH Key Pair の作成\n公開鍵の登録(接続先のauthorized_keysファイル（~/.ssh/authorized_keys）に追加)\nsshコマンドでアクセスとなります\n\n\n\nSSH Key Pair の作成\n\nssh-keygen -t rsa -b 4096 -f ~/.ssh/pupupu_land\n\n\n-t rsa: key typeの指定\n-b 4096: key lengthの指定(長いほどsecurity強固になる)\n-f  ~/.ssh/pupupu_land: key pairの生成先とファイル名（今回はpupupu_land, pupupu_land.pubが生成される）\n\n\n\n公開鍵の登録\n\nssh-copy-id -i ~/.ssh/pupupu_land.pub username@&lt;target-ip&gt;\n\n\n-i ~/.ssh/pupupu_land.pub: コピーする公開鍵ファイルを指定\n\n公開鍵を登録するには，\n\n公開鍵のファイルをコピー\n接続先のauthorized_keysファイル（~/.ssh/authorized_keys）に追加\nauthorized_keysファイルがない場合は作成後に適切なパーミッションを設定\n\nが必要となりますが，ssh-copy-idコマンドですべて自動実行することができるというメリットがあります．\n ▶  ssh connection\n上記の設定後，sshコマンド実行することで，macOSへアクセスすることができます． 毎回プライベートIPアドレスを調べるのが億劫な場合，デバイスのMACアドレスがわかればarpコマンドで以下のように検索することもできます．\narp -a | grep &lt;MAC-address&gt; | awk -F'[()]' '{print $2}'"
  },
  {
    "objectID": "posts/2024-12-17-firefox-proxy-access/index.html",
    "href": "posts/2024-12-17-firefox-proxy-access/index.html",
    "title": "Firefoxを用いたsocks5 proxyブラウザアクセス設定",
    "section": "",
    "text": "アクセス元のglobal IPが制限されたサイト(例: 社内用gitlabサーバー)へアクセスする場合，\n\n許可されたglobal IPに属するプライベートIPネットワークに接続している端末からアクセス\n別端末から上記の端末へssh接続し，プロキシサーバー的に使用をする\n\nという2つの方法が考えられます．後者の方法をFirefoxを用いて設定する方法を紹介します．\n ▶  なぜFirefoxなのか？\n\nGoogle chromeでもproxy設定は可能ですが，OS側の設定を変更してしまう\nFirefoxはブラウザレベルでproxyの設定が可能"
  },
  {
    "objectID": "posts/2024-12-17-firefox-proxy-access/index.html#what-we-want-to-do",
    "href": "posts/2024-12-17-firefox-proxy-access/index.html#what-we-want-to-do",
    "title": "Firefoxを用いたsocks5 proxyブラウザアクセス設定",
    "section": "",
    "text": "アクセス元のglobal IPが制限されたサイト(例: 社内用gitlabサーバー)へアクセスする場合，\n\n許可されたglobal IPに属するプライベートIPネットワークに接続している端末からアクセス\n別端末から上記の端末へssh接続し，プロキシサーバー的に使用をする\n\nという2つの方法が考えられます．後者の方法をFirefoxを用いて設定する方法を紹介します．\n ▶  なぜFirefoxなのか？\n\nGoogle chromeでもproxy設定は可能ですが，OS側の設定を変更してしまう\nFirefoxはブラウザレベルでproxyの設定が可能"
  },
  {
    "objectID": "posts/2024-12-17-firefox-proxy-access/index.html#firefoxにおけるsocks5-proxy設定",
    "href": "posts/2024-12-17-firefox-proxy-access/index.html#firefoxにおけるsocks5-proxy設定",
    "title": "Firefoxを用いたsocks5 proxyブラウザアクセス設定",
    "section": "Firefoxにおけるsocks5 proxy設定",
    "text": "Firefoxにおけるsocks5 proxy設定\n\nFirefoxを開いて、右上のメニューボタン（三本線）をクリック\nメニューから「設定」を選択\nネットワーク設定を開く\n「手動でプロキシ設定をする」オプションを選択\n「SOCKS v5」を選択し，SOCKSホストを127.0.0.1，ポートを1080で設定\n変更を保存\n\n\n\n\nfirefox-proxy-setting\n\n\n\nHow to use\nLinux, Windows, MacOS問わず\nssh &lt;username&gt;@&lt;proxy-server&gt; -D 1080\nとまず，ssh接続を確立します．-D オプションはダイナミックポートフォワーディング (Dynamic Port Forwarding)の設定です． 上記を実行するとローカルの 1080番ポート にSOCKS5プロキシが立ち上がります．\nFirefoxで SOCKS5プロキシ 127.0.0.1:1080と設定すると，\n\n\n\n\n\nsequenceDiagram\n    participant Client as クライアント\n    participant LocalSOCKS as localhost:1080 (SOCKSプロキシ)\n    participant SSHTunnel as SSHトンネル\n    participant RemoteServer as リモートサーバー\n    participant ExternalServer as 外部サーバー\n\n    %% 1. クライアントがSOCKSプロキシに接続\n    Client-&gt;&gt;LocalSOCKS: データ送信 (接続要求, 宛先IP/ポート)\n\n    %% 2. SOCKSプロキシがSSHトンネル経由でリモートサーバーに転送\n    LocalSOCKS-&gt;&gt;SSHTunnel: データ転送 (暗号化)\n\n    %% 3. SSHトンネルがリモートサーバーに転送\n    SSHTunnel-&gt;&gt;RemoteServer: データ中継 (トンネル経由)\n\n    %% 4. リモートサーバーが外部サーバーに接続\n    RemoteServer-&gt;&gt;ExternalServer: 外部サーバー接続要求 (TCP/UDP)\n    ExternalServer--&gt;&gt;RemoteServer: 接続応答\n\n    %% 5. 応答をクライアントに返送\n    RemoteServer--&gt;&gt;SSHTunnel: 応答データ\n    SSHTunnel--&gt;&gt;LocalSOCKS: 暗号化データ戻し\n    LocalSOCKS--&gt;&gt;Client: レスポンス転送\n\n\n\n\n\n\n\nという順序で通信されるようになります．"
  },
  {
    "objectID": "posts/2024-12-17-firefox-proxy-access/index.html#appendix-プロキシサーバーの仕組み",
    "href": "posts/2024-12-17-firefox-proxy-access/index.html#appendix-プロキシサーバーの仕組み",
    "title": "Firefoxを用いたsocks5 proxyブラウザアクセス設定",
    "section": "Appendix: プロキシサーバーの仕組み",
    "text": "Appendix: プロキシサーバーの仕組み\nクライアントの依頼に応じて，外部のサーバーにサービスを要求し，その結果をクライアントに提供するサーバーをプロキシサーバーといいます． SOCKS5は，プロキシサーバーを利用してサーバーとクライアント間のパケットをルーティングするインターネットプロトコルのことを指します．\nSOCKS5プロキシサーバーのメリットとして，安全性，匿名性，利便性の3つがあります．\n ▶  安全性\n\nSOCKS5は，ユーザー名とパスワードによる認証機能をサポートしているため，外部の不正アクセスや認証されていないクライアントからの利用を防ぐことができる\nSSHトンネルと組み合わせることで，安全にSOCKS5プロキシサーバー経由の通信を暗号化することができる = リモートアクセス時のデータ転送が保護され，悪意のあるネットワーク環境でも安全に通信可能\nプロキシサーバーを中間地点として使用することで，DDoS攻撃などの直接的な大量トラフィック攻撃を遮断することが可能\n\n ▶  匿名性\n\nネットワーク全体のトラフィックがプロキシサーバー経由で処理されるため，外部から見えるIPアドレスが プロキシのIPになる = SOCKS5プロキシを介することで，クライアントのIPアドレス/端末名を隠すことができる\n一括でアクセス元をプロキシのIPに集約し，クライアントIPを隠蔽することでセキュリティとプライバシー保護が可能になるという活用方法がある\n\nSOCKS5プロキシは，クライアントから送信されたデータをそのまま中継しますが，データ送信時のヘッダ情報（IPアドレスなど）をカプセル化します． そのため，外部サーバーはデータの中身だけを認識し，送信元（クライアント）に関する情報は知ることができないという仕組みになっています．\n ▶  利便性\n\nSOCKS5はプロトコル非依存であり，TCPとUDPの両方の通信をサポートしている = FTP, SMTP, P2P, VoIP, DNSリクエスト, オンラインゲームなど多様なアプリケーションで利用可能\n\n\n\n\n\n\nsequenceDiagram\n    participant Client as クライアント\n    participant SOCKS5ProxyServer as SOCKS5プロキシサーバー\n    participant ExternalServer as 外部サーバー\n\n    %% 1. 接続要求とハンドシェイク\n    Client-&gt;&gt;SOCKS5ProxyServer: 接続要求 (Handshake: バージョン, 認証方式)\n    SOCKS5ProxyServer--&gt;&gt;Client: 認証方式応答 (成功/失敗)\n\n    %% 2. 外部サーバーへの接続要求\n    Client-&gt;&gt;SOCKS5ProxyServer: 外部サーバー接続要求 (宛先IP, ポート)\n    note right of Client: クライアントのIPアドレスは隠蔽される\n    SOCKS5ProxyServer-&gt;&gt;ExternalServer: 接続確立要求 (プロキシのIPを使用)\n\n    %% 3. 接続確立確認\n    ExternalServer--&gt;&gt;SOCKS5ProxyServer: 接続成功応答\n    SOCKS5ProxyServer--&gt;&gt;Client: 接続確立成功通知\n\n    %% 4. データ転送 (カプセル化)\n    Client-&gt;&gt;SOCKS5ProxyServer: データ送信 (カプセル化されたパケット)\n    note over SOCKS5ProxyServer: データをそのまま中継 (IPアドレス非公開)\n    SOCKS5ProxyServer-&gt;&gt;ExternalServer: データ転送 (TCP/UDP)\n    ExternalServer--&gt;&gt;SOCKS5ProxyServer: レスポンスデータ\n    SOCKS5ProxyServer--&gt;&gt;Client: レスポンス転送\n\n    %% 5. 通信終了\n    Client-&gt;&gt;SOCKS5ProxyServer: 通信終了リクエスト\n    SOCKS5ProxyServer-&gt;&gt;ExternalServer: 接続切断\n    SOCKS5ProxyServer--&gt;&gt;Client: 通信終了通知\n\n\n\n\n\n\n\nSOCKS5プロキシはキャッシュを行わない\nHTTPプロキシは一般的に，ウェブコンテンツ（画像、HTML、動画など）をキャッシュすることで，再アクセス時にデータ転送を高速化します． 一方，SOCKS5プロキシはキャッシュを行なわないという違いがあります．\n\nSOCKS5はデータ転送のトンネルを作る役割を果たすため，通信内容のデータを確認・保存することがない\nあくまで「データを中継する」プロトコルであり，内容に依存しないため，キャッシュ機能は持たない\n\nSOCKS5はキャッシュ機能を持たないことで，シンプルかつ高速な通信環境を提供してくれるものと理解していればOKだとおもいます． キャッシュはリアルタイム通信に不要ですし，また，キャッシュ管理の手間やストレージコストが不要というメリットもあります．"
  },
  {
    "objectID": "posts/2025-02-03-continuous-function/index.html",
    "href": "posts/2025-02-03-continuous-function/index.html",
    "title": "関数の連続性",
    "section": "",
    "text": "変数 \\(x\\) が限りなく \\(a\\) に近づくとき，\\(f(x)\\) も \\(f(a)\\) に近づくならば，\\(f(x)\\) は \\(x=a\\) において連続である，といいます．つまり，\n\\[\nx\\to a \\text{ ならば } f(x) \\to f(a)\n\\]\n\nDef: \\(\\epsilon\\)-\\(\\delta\\) 論法的連続性 \n任意の \\(\\epsilon &gt;0\\) に対して，ある \\(\\delta &gt; 0\\) が存在して，\n\\[\n\\vert x - a \\vert &lt; \\delta \\Rightarrow \\vert f(x) - f(a)\\vert &lt; \\epsilon\n\\]\nを満たすとき，\\(x=a\\) において \\(f(x)\\) は連続であるという．\n\n\nExample 1 \n\\(f(x) = \\sqrt{x}\\) について，\\(a &gt; 0\\) で連続であることを以下示します．\n\\[\n\\begin{align}\n\\vert \\sqrt{x} - \\sqrt{a} \\vert\n    &= \\left\\vert\\frac{(\\sqrt{x} - \\sqrt{a})(\\sqrt{x} + \\sqrt{a})}{\\sqrt{x}+\\sqrt{a}}\\right\\vert\\\\\n    &= \\left\\vert\\frac{x - a}{\\sqrt{x}+\\sqrt{a}}\\right\\vert\\\\\n    &\\leq \\left\\vert\\frac{x - a}{\\sqrt{a}}\\right\\vert\n\\end{align}\n\\]\nここで，\\(\\vert x - a\\vert &lt; \\delta(\\epsilon) = \\epsilon\\sqrt{a}\\) と定めると\n\\[\n\\vert x - a\\vert &lt; \\delta(\\epsilon) \\Rightarrow \\vert \\sqrt{x} - \\sqrt{a}\\vert &lt; \\epsilon\n\\]\n\n\n\nExample 2 : 三角関数の連続性 \n\\(x = a + h\\) とおくと，和積の公式を用いて\n\\[\n\\begin{align}\n\\vert \\sin(x) - \\sin(a) \\vert\n    &= 2\\left\\vert \\cos\\frac{x+a}{2}\\sin\\frac{x-a}{2} \\right\\vert\\\\\n    &= 2\\left\\vert \\cos\\left(a + \\frac{h}{2}\\right)\\sin\\frac{h}{2} \\right\\vert\\\\\n    &\\leq 2\\left\\vert\\frac{h}{2}\\right\\vert \\cdot 1\\\\\n    &=\\vert h \\vert\n\\end{align}\n\\]\n\\(\\cos x = \\sin\\left(x + \\frac{\\pi}{2}\\right)\\) であるので，\\(\\sin x\\) が連続であるならば, \\(\\cos x\\) も連続．\n\n\n\n\nTheorem 1  : 連続関数の定数倍\n\\(f(x)\\) は \\(x=a\\) で連続であるとします．このとき，定数 \\(c\\) を用いた \\(cf(x)\\) も \\(x=a\\) にて連続となります．\n\n\n\n\n\n\n\n\n\nProof\n\n\n\n\n\n仮定より\n\\[\n\\forall \\eta &gt; 0, \\exists \\delta(\\eta) &gt; 0, \\vert x - a\\vert &lt; \\delta(\\eta)\\Rightarrow\\vert f(x) - f(a)\\vert &lt; \\eta\n\\]\nこのとき，任意の \\(\\epsilon &gt; 0\\) に対して，\n\\[\n\\eta = \\frac{\\epsilon}{\\vert c \\vert} &gt;0\n\\]\nと対応させると，\n\\[\n\\forall \\epsilon &gt; 0, \\exists \\delta(\\epsilon) &gt; 0, \\vert x - a\\vert &lt; \\delta(\\epsilon)\\Rightarrow\\vert f(x) - f(a)\\vert &lt; \\frac{\\epsilon}{\\vert c \\vert }\n\\]\nつまり，\n\\[\n\\forall \\epsilon &gt; 0, \\exists \\delta(\\epsilon) &gt; 0, \\vert x - a\\vert &lt; \\delta(\\epsilon)\\Rightarrow \\vert c\\vert\\vert f(x) - f(a)\\vert &lt; \\epsilon\n\\]\nこれを変形すると\n\\[\n\\forall \\epsilon &gt; 0, \\exists \\delta(\\epsilon) &gt; 0, \\vert x - a\\vert &lt; \\delta(\\epsilon)\\Rightarrow \\vert cf(x) - cf(a)\\vert &lt; \\epsilon\n\\]\n\n\n\n\n\nTheorem 2 : 連続関数の和\n\n\\(f(x), g(x)\\) は \\(x=a\\) で連続であるとします．このとき，\\(f(x) + g(x)\\) も \\(x=a\\) にて連続となります．\n\n\n\n\n\n\n\n\n\nProof\n\n\n\n\n\n仮定より\n\\[\n\\begin{align}\n\\vert x - a \\vert &lt; \\delta&\\Rightarrow \\vert f(x) - f(a)\\vert &lt; \\epsilon/2\\\\\n\\vert x - a \\vert &lt; \\eta&\\Rightarrow \\vert g(x) - g(a)\\vert &lt; \\epsilon/2\n\\end{align}\n\\]\nここで，\\(M = \\min(\\delta, \\eta)\\) とすると，\n\\[\n\\begin{align}\n\\vert x - a \\vert &lt; M&\\Rightarrow \\vert f(x) - f(a)\\vert &lt; \\epsilon/2\\\\\n\\vert x - a \\vert &lt; M&\\Rightarrow \\vert g(x) - g(a)\\vert &lt; \\epsilon/2\n\\end{align}\n\\]\nまた\n\\[\n\\begin{align}\n\\vert(f(x) - g(x)) - (f(a) + g(a))\n    &= \\vert(f(x) - f(a)) + (g(x) + g(a))\\vert\\\\\n    &\\leq \\vert(f(x) - f(a))\\vert + \\vert (g(x) + g(a))\\vert\n\\end{align}\n\\]\n従って，\\(\\vert x - a \\vert &lt; M\\) であるならば\n\\[\n\\begin{align}\n\\vert (g(x) + f(x)) - (g(a) + f(a))\\vert \\leq \\vert(f(x) - f(a))\\vert + \\vert (g(x) + g(a))\\vert &lt; \\epsilon\n\\end{align}\n\\]\n\n\n\n\n\nTheorem 3  : 連続関数の線型結合\n\\(f(x), g(x)\\) は \\(x=a\\) で連続であるとします．このとき，定数 \\(c_1, c_2\\)に対して \\(c_1f(x) + c_2g(x)\\) も \\(x=a\\) にて連続となります．\n\n\n\n\n\n\n\n\n\nProof\n\n\n\n\n\n\\[\n\\begin{align}\n\\vert x - a \\vert &lt; \\delta&\\Rightarrow \\vert f(x) - f(a)\\vert &lt; \\frac{\\epsilon}{2\\vert c_1\\vert}\\\\\n\\vert x - a \\vert &lt; \\eta&\\Rightarrow \\vert g(x) - g(a)\\vert &lt; \\frac{\\epsilon}{2\\vert c_2\\vert}\n\\end{align}\n\\]\nとして，\\(M = \\min(\\delta, \\eta)\\) とすれば，上記と同様に連続性を示すことができます．\n\n\n\n\n\nTheorem 4  : 連続関数の積\n\\(f(x), g(x)\\) は \\(x=a\\) で連続であるとします．このとき，\\(f(x)g(x)\\) も \\(x=a\\) にて連続となります．\n\n\n\n\n\n\n\n\n\nProof\n\n\n\n\n\n\\[\n\\vert x - a \\vert &lt; \\delta(1) \\Rightarrow \\vert f(x) - f(a)\\vert &lt; 1\n\\]\nとすると，\n\\[\n\\vert x - a \\vert &lt; \\delta(1) \\Rightarrow \\vert f(x) \\vert &lt; 1 + \\vert f(a) \\vert\n\\]\n\\(\\delta, \\eta\\) を以下のように定め，\n\\[\n\\begin{align}\n\\vert x - a \\vert &lt; \\delta &\\Rightarrow \\vert f(x) - f(a)\\vert &lt; \\frac{\\epsilon}{2(1 + \\vert f(a) \\vert + \\vert g(a) \\vert)}\\\\\n\\vert x - a \\vert &lt; \\eta &\\Rightarrow \\vert g(x) - g(a)\\vert &lt; \\frac{\\epsilon}{2(1 + \\vert f(a) \\vert + \\vert g(a) \\vert)}\n\\end{align}\n\\]\n\\[\n\\delta(\\epsilon) = \\min (\\delta(1), \\delta, \\eta)\n\\]\nとすると，\n\\[\n\\begin{align}\n\\vert x - a \\vert &lt; \\delta(\\epsilon)\n    \\Rightarrow &\\vert f(x)g(x) - f(a)g(a)\\vert\\\\[5pt]\n    &= \\vert f(x)(g(x) - g(a)) + g(a)(f(x) - f(a))\\vert\\\\[5pt]\n    &\\leq \\vert f(x)\\vert \\vert(g(x) - g(a))\\vert + \\vert g(a)\\vert\\vert(f(x) - f(a))\\vert\\\\[5pt]\n    &&lt; (1 + \\vert f(a) \\vert)\\frac{\\epsilon}{2(1 + \\vert f(a) \\vert + \\vert g(a) \\vert)} + \\vert g(a)\\vert \\frac{\\epsilon}{2(1 + \\vert f(a) \\vert + \\vert g(a) \\vert)}\\\\\n    &= \\epsilon\n\\end{align}\n\\]\nよって，連続性が示された．\n\n\n\n\n\nTheorem 5  連続関数の逆数 \n\\(f(x)\\) は \\(x=a\\) で連続であるとします．このとき，\\(f(a)\\neq 0\\) であるならば \\(1/f(x)\\) も \\(x=a\\) にて連続となります．\n\n\n\n\n\n\n\n\n\nProof\n\n\n\n\n\n連続性の仮定より\n\\[\n\\vert x - a \\vert &lt; \\delta(\\vert f(a)/2\\vert) \\Rightarrow \\vert f(x) - f(a)\\vert &lt; \\frac{\\vert f(a)\\vert}{2}\n\\]\nとすると，\n\\[\n\\vert x - a \\vert &lt; \\delta(\\vert f(a)/2\\vert) \\Rightarrow \\frac{\\vert f(a)\\vert}{2} &lt; \\vert f(x)\\vert\n\\]\nこのとき，\n\\[\n\\begin{align}\n\\left\\vert \\frac{1}{f(x)} - \\frac{1}{f(a)} \\right\\vert\n    &= \\left\\vert \\frac{f(x) - f(a)}{f(x)f(a)} \\right\\vert\\\\\n    &&lt; \\left\\vert \\frac{f(x) - f(a)}{(f(a))^2 / 2} \\right\\vert\n\\end{align}\n\\]\n従って，\\(\\vert x - a \\vert &lt; \\eta \\Rightarrow \\vert f(x) - f(a)\\vert &lt; \\displaystyle\\frac{\\epsilon\\vert (f(a))^2\\vert}{2}\\) となるような \\(\\eta\\) を用いて，\n\\[\n\\delta(\\epsilon) = \\min(\\delta(\\vert f(a)/2\\vert), \\eta)\n\\]\nとすれば\n\\[\n\\vert x - a \\vert &lt; \\delta(\\epsilon) \\Rightarrow \\left\\vert \\frac{1}{f(x)} - \\frac{1}{f(a)} \\right\\vert &lt; \\epsilon\n\\]\n\n\n\n\n\n点 \\(a\\) における極限を考えるとき，\n\n\\(x\\) が増大しつつ \\(a\\) に（左側から）近づく, \\(\\lim_{x\\to a-0}\\)\n\\(x\\) が減少しつつ \\(a\\) に（右側から）近づく, \\(\\lim_{x\\to a+0}\\)\n\nそれぞれの場合を分けて取り扱うことがあります．\n\nExample 3 \n\\(f(x) = \\tan x\\) について，\\(x = \\pi/2\\) における極限を考えてみます．\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport sympy as sy\n\nx = sy.Symbol('x')\nf = sy.tan(x)\n\nx_vals = np.linspace(-np.pi/2+1e-6, np.pi, 400)\ny_vals = np.tan(x_vals)\n\nplt.figure(figsize=(8, 6))\nplt.plot(x_vals, y_vals, label=r'$f(x) = \\tan(x)$')\nplt.ylim(-10, 10)\nplt.xticks([-np.pi/2, 0, np.pi/2, np.pi], [r'$-\\frac{\\pi}{2}$', '0', r'$\\frac{\\pi}{2}$', r'$\\pi$'])\nplt.axvline(np.pi/2, color='r', linestyle='--', label=r'$x = \\frac{\\pi}{2}$')\nplt.axhline(0, color='black',linewidth=0.5)\nplt.axvline(0, color='black',linewidth=0.5)\nplt.title(r'Plot of $f(x) = \\tan(x)$ around $x = \\frac{\\pi}{2}$')\nplt.xlabel('x')\nplt.ylabel('f(x)')\nplt.legend()\nplt.grid(True)\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 1\n\n\n\n上記の図のように，\n\\[\n\\begin{align}\n\\lim_{x\\to \\pi/2+0} \\tan x &= -\\infty\\\\\n\\lim_{x\\to \\pi/2-0} \\tan x &= \\infty\n\\end{align}\n\\]\n実際に，sympy で確認してみると\n\n# DO NOT USE np.pi\nprint(f\"左極限: {sy.limit(sy.tan(x), x, sy.pi/2, '-')}\")\nprint(f\"右極限: {sy.limit(sy.tan(x), x, sy.pi/2, '+')}\")\n\n左極限: oo\n右極限: -oo\n\n\n\n\n ▶  右連続と左連続\n\\[\n\\begin{align}\nf(a) &= \\alpha\\\\[5pt]\n\\lim_{x\\to a-0} f(x) &= \\alpha\\\\\n\\lim_{x\\to a+0} f(x) &= \\beta \\neq \\alpha\n\\end{align}\n\\]\nのとき，\\(f(x)\\) は \\(x = a\\) において左連続といいます．\n\\(f(x)\\) が閉区間 \\([a, b]\\) において定義されているとき，\n\n\\(x=a\\) においては右連続\n\\(x=b\\) においては左連続\n\nであることを意味します．開区間 \\((a, b)\\) において定義されているとき，\\(f(a+0)\\) が確定ならば，それを \\(f(a)\\) として定義域を \\([a, b)\\) 区間に拡張すると \\(f(x)\\) は \\(x=a\\) において右連続になります．\n一方，\\((0, \\infty)\\) 区間で定義された関数 \\(\\displaystyle f(x) = \\frac{1}{x}\\) は開区間では連続ですが，\\(x = 0\\) のときは定義されません．このとき，\\(f(0) = 0\\) として定義域を \\([0, \\infty)\\) に拡張すると，\\(x=0\\) で連続な関数にはなりませんし，\\(f(0)\\) をどんな値にしたとしても，\\(x=0\\) の近傍において, \\(f(x)\\) はいくらでも大きくなってしまうので，連続な関数にはなりません．\n\n📘 REMARKS \n\n開区間 \\((a, b)\\) で定義された連続な関数が，開区間 \\([a, b]\\) の連続な関数に拡張できるとは限らない\n\n\n\nExample 4  : 右連続関数と累積分布関数 \n離散確率変数 \\(X\\sim\\operatorname{Bin}(5, 1/3)\\) を考えます．離散確率変数の累積分布関数 \\(F(x)\\) は\n\\[\nF(x) = \\operatorname{P}(X \\leq x) = \\sum_{y\\leq x}p(y) \\qquad p(y): \\text{確率関数}\n\\]\nと定義されるので，\\(F(x)\\) は右側連続となります．実際に\n\nCode\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom scipy.stats import binom\n\nn, p = 5, 1 / 3\nx = np.arange(0, 6)\ncdf = binom.cdf(x, n, p)\n\nfig, ax = plt.subplots(1, 1)\nax.hlines(cdf, x, x + 1, color=\"gray\")\nax.step(x, cdf, where=\"post\", color=\"gray\", linestyle=\"dotted\")\nax.plot(x, cdf, \"o\", color=\"gray\")\nax.scatter(x[:-1] + 1, cdf[:-1], marker=\"$\\u25EF$\", alpha=0.5, color=\"gray\")\nax.set_xlabel(\"x\")\nax.set_ylabel(\"F(x)\")\nax.set_title(\"CDF of Binomial Distribution (n=5, p=1/3)\")\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 2\n\n\n\nこのとき，確率関数は\n\\[\np(x) = F(x) - \\lim_{x_n\\to x-0}F(x_n)\n\\]\nとすることで計算することが出来ます．一方，\\(F(x) = \\operatorname{P}(X &lt; x)\\) と定義すると左連続となります．\n\n\n\n\n\n\\[\nf(x) = \\frac{\\sin x}{x}\n\\]\nを考えます．この関数は \\(x - 0\\) で定義されていないですが\n\\[\n\\begin{align}\nf(x) = \\left\\{\\begin{array}{c}\n\\frac{\\sin x}{x} & (x\\neq 0)\\\\\n1 & (x = 0)\n\\end{array}\\right.\n\\end{align}\n\\]\nと \\(x = 0\\) で連続かつ微分可能になるように拡張することが出来ます．この拡張された関数を特にsinc関数と呼びます．\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Define the sinc function\ndef sinc(x):\n    return np.sinc(x / np.pi)\n\ndef inverse_x(x):\n    return 1/x\n\n# Generate x values\nx_vals = np.linspace(-10*np.pi, 10*np.pi, 400)\ny_vals = sinc(x_vals)\n\n# Plot the sinc function\nplt.figure(figsize=(8, 6))\nplt.plot(x_vals, y_vals, label=r'$f(x) = \\frac{\\sin(x)}{x}$')\nplt.plot(x_vals, inverse_x(x_vals), label=r'$f(x) = \\frac{1}{x}$')\nplt.xticks(np.arange(-10*np.pi, 11*np.pi, np.pi), \n           [r'$-10\\pi$', r'$-9\\pi$', r'$-8\\pi$', r'$-7\\pi$', r'$-6\\pi$', r'$-5\\pi$', r'$-4\\pi$', r'$-3\\pi$', r'$-2\\pi$', r'$-\\pi$', '0', r'$\\pi$', r'$2\\pi$', r'$3\\pi$', r'$4\\pi$', r'$5\\pi$', r'$6\\pi$', r'$7\\pi$', r'$8\\pi$', r'$9\\pi$', r'$10\\pi$'])\nplt.axhline(0, color='black',linewidth=0.5)\nplt.axvline(0, color='black',linewidth=0.5)\nplt.title(r'Plot of $f(x) = \\frac{\\sin(x)}{x}$')\nplt.xlabel('x')\nplt.ylabel('f(x)')\nplt.ylim(-1.1, 1.1)\nplt.legend()\nplt.grid(True)\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 3\n\n\n\n ▶  \\(x = 0\\)における連続性の証明\n\n\n\n\n\n\n\nProof\n\n\n\n\n\n偶関数の性質\n\\[\n\\frac{\\sin x}{x} = \\frac{\\sin -x}{-x}\n\\]\nより \\(0 &lt; x \\to +0\\) の場合を考えます．xy座標上に \\(O = (0, 0)，A = (1, 0)，B = (\\cos x, \\sin x)，C = (1, \\tan x)\\) という点をとったとき，\n\\[\n\\text{三角形}OAB \\subset \\text{扇形}OAB \\subset \\text{三角形}OAC\n\\]\nつまり\n\\[\n\\text{三角形}OAB\\text{の面積} \\leq \\text{扇形}OAB\\text{の面積} \\leq  \\text{三角形}OAC\n\\]\n従って，\n\\[\n\\begin{align}\n\\frac{\\sin x}{2} \\leq \\frac{x}{2} &lt; \\frac{\\tan x}{2}\n\\end{align}\n\\]\n両辺 を \\(\\sin ⁡x\\) で割って逆数をとると\n\\[\n\\begin{align}\n\\cos x \\leq \\frac{x\\sin x}{x} &lt; 1\n\\end{align}\n\\]\nここで，\\(x\\to +0\\) とすると，\\(\\cos x \\to 1\\) となり，はさみうちの原理より\n\\[\n\\lim_{x\\to+0}\\frac{\\sin x}{x} = 1\n\\]\n\n\n\n ▶  \\(x = 0\\)における微分可能性の証明\n\n\n\n\n\n\n\nProof\n\n\n\n\n\n\\[\n\\begin{align}\n\\cos x \\leq \\frac{x\\sin x}{x} &lt; 1\n\\end{align}\n\\]\nが \\(-\\frac{\\pi}{2} \\leq x \\leq \\frac{\\pi}{2}\\) で成り立つので\n\\[\n0=\\lim_{x\\to0}\\frac{\\cos(x)-1}{x}\\le\\lim_{x\\to0}\\frac{\\frac{\\sin(x)}x-1}{x-0}\\le0\n\\]\n\\[\n\\begin{align}\n\\lim_{x\\to0}\\frac{1-\\cos(x)}x\n&=\\lim_{x\\to0}\\frac1x\\frac{\\sin^2(x)}{1+\\cos(x)}\\\\\n&=\\lim_{x\\to0}\\frac{\\sin(x)}x\\lim_{x\\to0}\\frac{\\sin(x)}{1+\\cos(x)}\\\\[6pt]\n&=1\\cdot0 = 0\n\\end{align}\n\\]\n従って，はさみうちの原理より \\(f^\\prime(0) = 0\\)"
  },
  {
    "objectID": "posts/2025-02-03-continuous-function/index.html#連続関数",
    "href": "posts/2025-02-03-continuous-function/index.html#連続関数",
    "title": "関数の連続性",
    "section": "",
    "text": "変数 \\(x\\) が限りなく \\(a\\) に近づくとき，\\(f(x)\\) も \\(f(a)\\) に近づくならば，\\(f(x)\\) は \\(x=a\\) において連続である，といいます．つまり，\n\\[\nx\\to a \\text{ ならば } f(x) \\to f(a)\n\\]\n\nDef: \\(\\epsilon\\)-\\(\\delta\\) 論法的連続性 \n任意の \\(\\epsilon &gt;0\\) に対して，ある \\(\\delta &gt; 0\\) が存在して，\n\\[\n\\vert x - a \\vert &lt; \\delta \\Rightarrow \\vert f(x) - f(a)\\vert &lt; \\epsilon\n\\]\nを満たすとき，\\(x=a\\) において \\(f(x)\\) は連続であるという．\n\n\nExample 1 \n\\(f(x) = \\sqrt{x}\\) について，\\(a &gt; 0\\) で連続であることを以下示します．\n\\[\n\\begin{align}\n\\vert \\sqrt{x} - \\sqrt{a} \\vert\n    &= \\left\\vert\\frac{(\\sqrt{x} - \\sqrt{a})(\\sqrt{x} + \\sqrt{a})}{\\sqrt{x}+\\sqrt{a}}\\right\\vert\\\\\n    &= \\left\\vert\\frac{x - a}{\\sqrt{x}+\\sqrt{a}}\\right\\vert\\\\\n    &\\leq \\left\\vert\\frac{x - a}{\\sqrt{a}}\\right\\vert\n\\end{align}\n\\]\nここで，\\(\\vert x - a\\vert &lt; \\delta(\\epsilon) = \\epsilon\\sqrt{a}\\) と定めると\n\\[\n\\vert x - a\\vert &lt; \\delta(\\epsilon) \\Rightarrow \\vert \\sqrt{x} - \\sqrt{a}\\vert &lt; \\epsilon\n\\]\n\n\n\nExample 2 : 三角関数の連続性 \n\\(x = a + h\\) とおくと，和積の公式を用いて\n\\[\n\\begin{align}\n\\vert \\sin(x) - \\sin(a) \\vert\n    &= 2\\left\\vert \\cos\\frac{x+a}{2}\\sin\\frac{x-a}{2} \\right\\vert\\\\\n    &= 2\\left\\vert \\cos\\left(a + \\frac{h}{2}\\right)\\sin\\frac{h}{2} \\right\\vert\\\\\n    &\\leq 2\\left\\vert\\frac{h}{2}\\right\\vert \\cdot 1\\\\\n    &=\\vert h \\vert\n\\end{align}\n\\]\n\\(\\cos x = \\sin\\left(x + \\frac{\\pi}{2}\\right)\\) であるので，\\(\\sin x\\) が連続であるならば, \\(\\cos x\\) も連続．\n\n\n\n\nTheorem 1  : 連続関数の定数倍\n\\(f(x)\\) は \\(x=a\\) で連続であるとします．このとき，定数 \\(c\\) を用いた \\(cf(x)\\) も \\(x=a\\) にて連続となります．\n\n\n\n\n\n\n\n\n\nProof\n\n\n\n\n\n仮定より\n\\[\n\\forall \\eta &gt; 0, \\exists \\delta(\\eta) &gt; 0, \\vert x - a\\vert &lt; \\delta(\\eta)\\Rightarrow\\vert f(x) - f(a)\\vert &lt; \\eta\n\\]\nこのとき，任意の \\(\\epsilon &gt; 0\\) に対して，\n\\[\n\\eta = \\frac{\\epsilon}{\\vert c \\vert} &gt;0\n\\]\nと対応させると，\n\\[\n\\forall \\epsilon &gt; 0, \\exists \\delta(\\epsilon) &gt; 0, \\vert x - a\\vert &lt; \\delta(\\epsilon)\\Rightarrow\\vert f(x) - f(a)\\vert &lt; \\frac{\\epsilon}{\\vert c \\vert }\n\\]\nつまり，\n\\[\n\\forall \\epsilon &gt; 0, \\exists \\delta(\\epsilon) &gt; 0, \\vert x - a\\vert &lt; \\delta(\\epsilon)\\Rightarrow \\vert c\\vert\\vert f(x) - f(a)\\vert &lt; \\epsilon\n\\]\nこれを変形すると\n\\[\n\\forall \\epsilon &gt; 0, \\exists \\delta(\\epsilon) &gt; 0, \\vert x - a\\vert &lt; \\delta(\\epsilon)\\Rightarrow \\vert cf(x) - cf(a)\\vert &lt; \\epsilon\n\\]\n\n\n\n\n\nTheorem 2 : 連続関数の和\n\n\\(f(x), g(x)\\) は \\(x=a\\) で連続であるとします．このとき，\\(f(x) + g(x)\\) も \\(x=a\\) にて連続となります．\n\n\n\n\n\n\n\n\n\nProof\n\n\n\n\n\n仮定より\n\\[\n\\begin{align}\n\\vert x - a \\vert &lt; \\delta&\\Rightarrow \\vert f(x) - f(a)\\vert &lt; \\epsilon/2\\\\\n\\vert x - a \\vert &lt; \\eta&\\Rightarrow \\vert g(x) - g(a)\\vert &lt; \\epsilon/2\n\\end{align}\n\\]\nここで，\\(M = \\min(\\delta, \\eta)\\) とすると，\n\\[\n\\begin{align}\n\\vert x - a \\vert &lt; M&\\Rightarrow \\vert f(x) - f(a)\\vert &lt; \\epsilon/2\\\\\n\\vert x - a \\vert &lt; M&\\Rightarrow \\vert g(x) - g(a)\\vert &lt; \\epsilon/2\n\\end{align}\n\\]\nまた\n\\[\n\\begin{align}\n\\vert(f(x) - g(x)) - (f(a) + g(a))\n    &= \\vert(f(x) - f(a)) + (g(x) + g(a))\\vert\\\\\n    &\\leq \\vert(f(x) - f(a))\\vert + \\vert (g(x) + g(a))\\vert\n\\end{align}\n\\]\n従って，\\(\\vert x - a \\vert &lt; M\\) であるならば\n\\[\n\\begin{align}\n\\vert (g(x) + f(x)) - (g(a) + f(a))\\vert \\leq \\vert(f(x) - f(a))\\vert + \\vert (g(x) + g(a))\\vert &lt; \\epsilon\n\\end{align}\n\\]\n\n\n\n\n\nTheorem 3  : 連続関数の線型結合\n\\(f(x), g(x)\\) は \\(x=a\\) で連続であるとします．このとき，定数 \\(c_1, c_2\\)に対して \\(c_1f(x) + c_2g(x)\\) も \\(x=a\\) にて連続となります．\n\n\n\n\n\n\n\n\n\nProof\n\n\n\n\n\n\\[\n\\begin{align}\n\\vert x - a \\vert &lt; \\delta&\\Rightarrow \\vert f(x) - f(a)\\vert &lt; \\frac{\\epsilon}{2\\vert c_1\\vert}\\\\\n\\vert x - a \\vert &lt; \\eta&\\Rightarrow \\vert g(x) - g(a)\\vert &lt; \\frac{\\epsilon}{2\\vert c_2\\vert}\n\\end{align}\n\\]\nとして，\\(M = \\min(\\delta, \\eta)\\) とすれば，上記と同様に連続性を示すことができます．\n\n\n\n\n\nTheorem 4  : 連続関数の積\n\\(f(x), g(x)\\) は \\(x=a\\) で連続であるとします．このとき，\\(f(x)g(x)\\) も \\(x=a\\) にて連続となります．\n\n\n\n\n\n\n\n\n\nProof\n\n\n\n\n\n\\[\n\\vert x - a \\vert &lt; \\delta(1) \\Rightarrow \\vert f(x) - f(a)\\vert &lt; 1\n\\]\nとすると，\n\\[\n\\vert x - a \\vert &lt; \\delta(1) \\Rightarrow \\vert f(x) \\vert &lt; 1 + \\vert f(a) \\vert\n\\]\n\\(\\delta, \\eta\\) を以下のように定め，\n\\[\n\\begin{align}\n\\vert x - a \\vert &lt; \\delta &\\Rightarrow \\vert f(x) - f(a)\\vert &lt; \\frac{\\epsilon}{2(1 + \\vert f(a) \\vert + \\vert g(a) \\vert)}\\\\\n\\vert x - a \\vert &lt; \\eta &\\Rightarrow \\vert g(x) - g(a)\\vert &lt; \\frac{\\epsilon}{2(1 + \\vert f(a) \\vert + \\vert g(a) \\vert)}\n\\end{align}\n\\]\n\\[\n\\delta(\\epsilon) = \\min (\\delta(1), \\delta, \\eta)\n\\]\nとすると，\n\\[\n\\begin{align}\n\\vert x - a \\vert &lt; \\delta(\\epsilon)\n    \\Rightarrow &\\vert f(x)g(x) - f(a)g(a)\\vert\\\\[5pt]\n    &= \\vert f(x)(g(x) - g(a)) + g(a)(f(x) - f(a))\\vert\\\\[5pt]\n    &\\leq \\vert f(x)\\vert \\vert(g(x) - g(a))\\vert + \\vert g(a)\\vert\\vert(f(x) - f(a))\\vert\\\\[5pt]\n    &&lt; (1 + \\vert f(a) \\vert)\\frac{\\epsilon}{2(1 + \\vert f(a) \\vert + \\vert g(a) \\vert)} + \\vert g(a)\\vert \\frac{\\epsilon}{2(1 + \\vert f(a) \\vert + \\vert g(a) \\vert)}\\\\\n    &= \\epsilon\n\\end{align}\n\\]\nよって，連続性が示された．\n\n\n\n\n\nTheorem 5  連続関数の逆数 \n\\(f(x)\\) は \\(x=a\\) で連続であるとします．このとき，\\(f(a)\\neq 0\\) であるならば \\(1/f(x)\\) も \\(x=a\\) にて連続となります．\n\n\n\n\n\n\n\n\n\nProof\n\n\n\n\n\n連続性の仮定より\n\\[\n\\vert x - a \\vert &lt; \\delta(\\vert f(a)/2\\vert) \\Rightarrow \\vert f(x) - f(a)\\vert &lt; \\frac{\\vert f(a)\\vert}{2}\n\\]\nとすると，\n\\[\n\\vert x - a \\vert &lt; \\delta(\\vert f(a)/2\\vert) \\Rightarrow \\frac{\\vert f(a)\\vert}{2} &lt; \\vert f(x)\\vert\n\\]\nこのとき，\n\\[\n\\begin{align}\n\\left\\vert \\frac{1}{f(x)} - \\frac{1}{f(a)} \\right\\vert\n    &= \\left\\vert \\frac{f(x) - f(a)}{f(x)f(a)} \\right\\vert\\\\\n    &&lt; \\left\\vert \\frac{f(x) - f(a)}{(f(a))^2 / 2} \\right\\vert\n\\end{align}\n\\]\n従って，\\(\\vert x - a \\vert &lt; \\eta \\Rightarrow \\vert f(x) - f(a)\\vert &lt; \\displaystyle\\frac{\\epsilon\\vert (f(a))^2\\vert}{2}\\) となるような \\(\\eta\\) を用いて，\n\\[\n\\delta(\\epsilon) = \\min(\\delta(\\vert f(a)/2\\vert), \\eta)\n\\]\nとすれば\n\\[\n\\vert x - a \\vert &lt; \\delta(\\epsilon) \\Rightarrow \\left\\vert \\frac{1}{f(x)} - \\frac{1}{f(a)} \\right\\vert &lt; \\epsilon\n\\]\n\n\n\n\n\n点 \\(a\\) における極限を考えるとき，\n\n\\(x\\) が増大しつつ \\(a\\) に（左側から）近づく, \\(\\lim_{x\\to a-0}\\)\n\\(x\\) が減少しつつ \\(a\\) に（右側から）近づく, \\(\\lim_{x\\to a+0}\\)\n\nそれぞれの場合を分けて取り扱うことがあります．\n\nExample 3 \n\\(f(x) = \\tan x\\) について，\\(x = \\pi/2\\) における極限を考えてみます．\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport sympy as sy\n\nx = sy.Symbol('x')\nf = sy.tan(x)\n\nx_vals = np.linspace(-np.pi/2+1e-6, np.pi, 400)\ny_vals = np.tan(x_vals)\n\nplt.figure(figsize=(8, 6))\nplt.plot(x_vals, y_vals, label=r'$f(x) = \\tan(x)$')\nplt.ylim(-10, 10)\nplt.xticks([-np.pi/2, 0, np.pi/2, np.pi], [r'$-\\frac{\\pi}{2}$', '0', r'$\\frac{\\pi}{2}$', r'$\\pi$'])\nplt.axvline(np.pi/2, color='r', linestyle='--', label=r'$x = \\frac{\\pi}{2}$')\nplt.axhline(0, color='black',linewidth=0.5)\nplt.axvline(0, color='black',linewidth=0.5)\nplt.title(r'Plot of $f(x) = \\tan(x)$ around $x = \\frac{\\pi}{2}$')\nplt.xlabel('x')\nplt.ylabel('f(x)')\nplt.legend()\nplt.grid(True)\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 1\n\n\n\n上記の図のように，\n\\[\n\\begin{align}\n\\lim_{x\\to \\pi/2+0} \\tan x &= -\\infty\\\\\n\\lim_{x\\to \\pi/2-0} \\tan x &= \\infty\n\\end{align}\n\\]\n実際に，sympy で確認してみると\n\n# DO NOT USE np.pi\nprint(f\"左極限: {sy.limit(sy.tan(x), x, sy.pi/2, '-')}\")\nprint(f\"右極限: {sy.limit(sy.tan(x), x, sy.pi/2, '+')}\")\n\n左極限: oo\n右極限: -oo\n\n\n\n\n ▶  右連続と左連続\n\\[\n\\begin{align}\nf(a) &= \\alpha\\\\[5pt]\n\\lim_{x\\to a-0} f(x) &= \\alpha\\\\\n\\lim_{x\\to a+0} f(x) &= \\beta \\neq \\alpha\n\\end{align}\n\\]\nのとき，\\(f(x)\\) は \\(x = a\\) において左連続といいます．\n\\(f(x)\\) が閉区間 \\([a, b]\\) において定義されているとき，\n\n\\(x=a\\) においては右連続\n\\(x=b\\) においては左連続\n\nであることを意味します．開区間 \\((a, b)\\) において定義されているとき，\\(f(a+0)\\) が確定ならば，それを \\(f(a)\\) として定義域を \\([a, b)\\) 区間に拡張すると \\(f(x)\\) は \\(x=a\\) において右連続になります．\n一方，\\((0, \\infty)\\) 区間で定義された関数 \\(\\displaystyle f(x) = \\frac{1}{x}\\) は開区間では連続ですが，\\(x = 0\\) のときは定義されません．このとき，\\(f(0) = 0\\) として定義域を \\([0, \\infty)\\) に拡張すると，\\(x=0\\) で連続な関数にはなりませんし，\\(f(0)\\) をどんな値にしたとしても，\\(x=0\\) の近傍において, \\(f(x)\\) はいくらでも大きくなってしまうので，連続な関数にはなりません．\n\n📘 REMARKS \n\n開区間 \\((a, b)\\) で定義された連続な関数が，開区間 \\([a, b]\\) の連続な関数に拡張できるとは限らない\n\n\n\nExample 4  : 右連続関数と累積分布関数 \n離散確率変数 \\(X\\sim\\operatorname{Bin}(5, 1/3)\\) を考えます．離散確率変数の累積分布関数 \\(F(x)\\) は\n\\[\nF(x) = \\operatorname{P}(X \\leq x) = \\sum_{y\\leq x}p(y) \\qquad p(y): \\text{確率関数}\n\\]\nと定義されるので，\\(F(x)\\) は右側連続となります．実際に\n\nCode\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom scipy.stats import binom\n\nn, p = 5, 1 / 3\nx = np.arange(0, 6)\ncdf = binom.cdf(x, n, p)\n\nfig, ax = plt.subplots(1, 1)\nax.hlines(cdf, x, x + 1, color=\"gray\")\nax.step(x, cdf, where=\"post\", color=\"gray\", linestyle=\"dotted\")\nax.plot(x, cdf, \"o\", color=\"gray\")\nax.scatter(x[:-1] + 1, cdf[:-1], marker=\"$\\u25EF$\", alpha=0.5, color=\"gray\")\nax.set_xlabel(\"x\")\nax.set_ylabel(\"F(x)\")\nax.set_title(\"CDF of Binomial Distribution (n=5, p=1/3)\")\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 2\n\n\n\nこのとき，確率関数は\n\\[\np(x) = F(x) - \\lim_{x_n\\to x-0}F(x_n)\n\\]\nとすることで計算することが出来ます．一方，\\(F(x) = \\operatorname{P}(X &lt; x)\\) と定義すると左連続となります．\n\n\n\n\n\n\\[\nf(x) = \\frac{\\sin x}{x}\n\\]\nを考えます．この関数は \\(x - 0\\) で定義されていないですが\n\\[\n\\begin{align}\nf(x) = \\left\\{\\begin{array}{c}\n\\frac{\\sin x}{x} & (x\\neq 0)\\\\\n1 & (x = 0)\n\\end{array}\\right.\n\\end{align}\n\\]\nと \\(x = 0\\) で連続かつ微分可能になるように拡張することが出来ます．この拡張された関数を特にsinc関数と呼びます．\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Define the sinc function\ndef sinc(x):\n    return np.sinc(x / np.pi)\n\ndef inverse_x(x):\n    return 1/x\n\n# Generate x values\nx_vals = np.linspace(-10*np.pi, 10*np.pi, 400)\ny_vals = sinc(x_vals)\n\n# Plot the sinc function\nplt.figure(figsize=(8, 6))\nplt.plot(x_vals, y_vals, label=r'$f(x) = \\frac{\\sin(x)}{x}$')\nplt.plot(x_vals, inverse_x(x_vals), label=r'$f(x) = \\frac{1}{x}$')\nplt.xticks(np.arange(-10*np.pi, 11*np.pi, np.pi), \n           [r'$-10\\pi$', r'$-9\\pi$', r'$-8\\pi$', r'$-7\\pi$', r'$-6\\pi$', r'$-5\\pi$', r'$-4\\pi$', r'$-3\\pi$', r'$-2\\pi$', r'$-\\pi$', '0', r'$\\pi$', r'$2\\pi$', r'$3\\pi$', r'$4\\pi$', r'$5\\pi$', r'$6\\pi$', r'$7\\pi$', r'$8\\pi$', r'$9\\pi$', r'$10\\pi$'])\nplt.axhline(0, color='black',linewidth=0.5)\nplt.axvline(0, color='black',linewidth=0.5)\nplt.title(r'Plot of $f(x) = \\frac{\\sin(x)}{x}$')\nplt.xlabel('x')\nplt.ylabel('f(x)')\nplt.ylim(-1.1, 1.1)\nplt.legend()\nplt.grid(True)\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 3\n\n\n\n ▶  \\(x = 0\\)における連続性の証明\n\n\n\n\n\n\n\nProof\n\n\n\n\n\n偶関数の性質\n\\[\n\\frac{\\sin x}{x} = \\frac{\\sin -x}{-x}\n\\]\nより \\(0 &lt; x \\to +0\\) の場合を考えます．xy座標上に \\(O = (0, 0)，A = (1, 0)，B = (\\cos x, \\sin x)，C = (1, \\tan x)\\) という点をとったとき，\n\\[\n\\text{三角形}OAB \\subset \\text{扇形}OAB \\subset \\text{三角形}OAC\n\\]\nつまり\n\\[\n\\text{三角形}OAB\\text{の面積} \\leq \\text{扇形}OAB\\text{の面積} \\leq  \\text{三角形}OAC\n\\]\n従って，\n\\[\n\\begin{align}\n\\frac{\\sin x}{2} \\leq \\frac{x}{2} &lt; \\frac{\\tan x}{2}\n\\end{align}\n\\]\n両辺 を \\(\\sin ⁡x\\) で割って逆数をとると\n\\[\n\\begin{align}\n\\cos x \\leq \\frac{x\\sin x}{x} &lt; 1\n\\end{align}\n\\]\nここで，\\(x\\to +0\\) とすると，\\(\\cos x \\to 1\\) となり，はさみうちの原理より\n\\[\n\\lim_{x\\to+0}\\frac{\\sin x}{x} = 1\n\\]\n\n\n\n ▶  \\(x = 0\\)における微分可能性の証明\n\n\n\n\n\n\n\nProof\n\n\n\n\n\n\\[\n\\begin{align}\n\\cos x \\leq \\frac{x\\sin x}{x} &lt; 1\n\\end{align}\n\\]\nが \\(-\\frac{\\pi}{2} \\leq x \\leq \\frac{\\pi}{2}\\) で成り立つので\n\\[\n0=\\lim_{x\\to0}\\frac{\\cos(x)-1}{x}\\le\\lim_{x\\to0}\\frac{\\frac{\\sin(x)}x-1}{x-0}\\le0\n\\]\n\\[\n\\begin{align}\n\\lim_{x\\to0}\\frac{1-\\cos(x)}x\n&=\\lim_{x\\to0}\\frac1x\\frac{\\sin^2(x)}{1+\\cos(x)}\\\\\n&=\\lim_{x\\to0}\\frac{\\sin(x)}x\\lim_{x\\to0}\\frac{\\sin(x)}{1+\\cos(x)}\\\\[6pt]\n&=1\\cdot0 = 0\n\\end{align}\n\\]\n従って，はさみうちの原理より \\(f^\\prime(0) = 0\\)"
  },
  {
    "objectID": "posts/2025-02-14-shogi-getting-started/index.html",
    "href": "posts/2025-02-14-shogi-getting-started/index.html",
    "title": "本日の詰将棋: Quiz 1~5",
    "section": "",
    "text": "Figure 1\n\n\n\n\n📘 KeyPoints \n\n初手に５二銀と捨てて，馬の利きを確保するのがポイント"
  },
  {
    "objectID": "posts/2025-02-14-shogi-getting-started/index.html#quiz-1-馬の利き",
    "href": "posts/2025-02-14-shogi-getting-started/index.html#quiz-1-馬の利き",
    "title": "本日の詰将棋: Quiz 1~5",
    "section": "",
    "text": "Figure 1\n\n\n\n\n📘 KeyPoints \n\n初手に５二銀と捨てて，馬の利きを確保するのがポイント"
  },
  {
    "objectID": "posts/2025-02-14-shogi-getting-started/index.html#quiz-2-角よりも銀",
    "href": "posts/2025-02-14-shogi-getting-started/index.html#quiz-2-角よりも銀",
    "title": "本日の詰将棋: Quiz 1~5",
    "section": "Quiz 2: 角よりも銀",
    "text": "Quiz 2: 角よりも銀"
  },
  {
    "objectID": "posts/2025-02-14-shogi-getting-started/index.html#quiz-3-金頭桂",
    "href": "posts/2025-02-14-shogi-getting-started/index.html#quiz-3-金頭桂",
    "title": "本日の詰将棋: Quiz 1~5",
    "section": "Quiz 3: 金頭桂",
    "text": "Quiz 3: 金頭桂\n\n\n\n\n\n\nFigure 2\n\n\n\n\n📘 KeyPoints \n\n竜を切ってからの金頭桂"
  },
  {
    "objectID": "posts/2025-02-14-shogi-getting-started/index.html#quiz-4",
    "href": "posts/2025-02-14-shogi-getting-started/index.html#quiz-4",
    "title": "本日の詰将棋: Quiz 1~5",
    "section": "Quiz 4",
    "text": "Quiz 4\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n派生：５三に歩が存在する場合\n相手玉の逃げ道が少なくなるので，一手早く積ませることが出来ます\n\n\n\n\n\n\nFigure 3"
  },
  {
    "objectID": "posts/2025-02-14-shogi-getting-started/index.html#quiz5-飛車を切る",
    "href": "posts/2025-02-14-shogi-getting-started/index.html#quiz5-飛車を切る",
    "title": "本日の詰将棋: Quiz 1~5",
    "section": "Quiz5: 飛車を切る",
    "text": "Quiz5: 飛車を切る\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n📘 KeyPoints \n\n馬の利きを通すためあえて竜を切る\n金２枚の代わりに斜めのコマ一つ（金一 & 角 or 銀一）の場合でも詰むことができる"
  },
  {
    "objectID": "posts/2025-02-19-make-lag-variable/index.html",
    "href": "posts/2025-02-19-make-lag-variable/index.html",
    "title": "Group毎に定義されたラグ変数の作成",
    "section": "",
    "text": "次のようなpandas.DataFrameを考えます\n\n\nCode\nimport pandas as pd\nimport polars as pl\n\ndf = pd.DataFrame(\n    {\n        \"entity_col\": [\"A\", \"A\", \"A\", \"A\", \"A\", \"A\", \"B\", \"B\", \"B\", \"C\"],\n        \"state\": [1, 0, 1, 1, 1, 0, 0, 0, 0, 1],\n        \"time_col\": pd.to_datetime([\n            \"2021-01-02\",\n            \"2021-01-03\",\n            \"2021-01-04\",\n            \"2021-01-01\",\n            \"2021-01-03\",\n            \"2021-01-04\",\n            \"2021-02-02\",\n            \"2021-02-03\",\n            \"2021-02-10\",\n            \"2021-01-02\",\n        ]),\n        \"temp\": [1, 2, 11, 13, 12, 14, 10, 9, 8, 0],\n    }\n)\n\ndf\n\n\n\n\n\n\n\n\n\nentity_col\nstate\ntime_col\ntemp\n\n\n\n\n0\nA\n1\n2021-01-02\n1\n\n\n1\nA\n0\n2021-01-03\n2\n\n\n2\nA\n1\n2021-01-04\n11\n\n\n3\nA\n1\n2021-01-01\n13\n\n\n4\nA\n1\n2021-01-03\n12\n\n\n5\nA\n0\n2021-01-04\n14\n\n\n6\nB\n0\n2021-02-02\n10\n\n\n7\nB\n0\n2021-02-03\n9\n\n\n8\nB\n0\n2021-02-10\n8\n\n\n9\nC\n1\n2021-01-02\n0\n\n\n\n\n\n\n\n\n📘 実施したい処理 \n\n(entity_col, state)でGroup Keysとして，各Group内部で time_col の順番に応じて tempカラムについてラグ変数を作成したい\nラグ変数の名前は Defaultでは f\"{target_column}_1lag, 指定があった場合はそれに倣うとする\n\n\n\n\n\nfrom typing import Optional\n\n\ndef generate_lag_variable_with_group_key(\n    df: pd.DataFrame | pl.DataFrame,\n    target_column: str,\n    sort_key: list[str],\n    group_key: list[str],\n    lag_size: int,\n    ascending: list[bool] | bool = True,\n    lagged_col_name: Optional[str] = None,\n) -&gt; pd.DataFrame | pl.DataFrame:\n    \"\"\"\n    Generate a lagged variable in a DataFrame with a specified group key.\n\n    This function creates a new column in the DataFrame that contains\n    the lagged values of an existing column, grouped by specified keys.\n    It supports both pandas and polars DataFrames.\n\n    Parameters:\n        df (pd.DataFrame | pl.DataFrame):\n            The input DataFrame, either pandas or polars.\n\n        col (str):\n            The name of the column to generate the lagged variable from.\n\n        sort_key (list[str]):\n            The list of columns to sort the DataFrame by before generating the lagged variable.\n\n        group_key (list[str]):\n            The list of columns to group the DataFrame by before generating the lagged variable.\n\n        lag_size (int):\n            The number of periods to lag the variable.\n\n        ascending (list[bool] | bool, optional):\n            The sort order for each column in sort_key. Defaults to True.\n\n        lagged_col_name (Optional[str], optional):\n            The name of the new lagged column. If None, defaults to \"{col}_{lag_size}lag\".\n\n    Returns:\n        pd.DataFrame | pl.DataFrame: The DataFrame with the new lagged variable column.\n\n    Raises:\n        TypeError: If the input DataFrame is neither pandas.DataFrame nor polars.DataFrame.\n    \"\"\"\n\n    # set up common variables\n    if lagged_col_name is None:\n        lagged_col_name = f\"{target_column}_{lag_size}lag\"\n\n    result_sort_key = group_key + sort_key\n\n    if isinstance(df, pd.DataFrame):\n        # Sort the dataframe by the specified sort key\n        df_sorted = df.sort_values(by=sort_key, ascending=ascending)\n\n        # Generate the lagged variable\n        df_sorted[lagged_col_name] = df_sorted.groupby(group_key)[target_column].shift(\n            lag_size\n        )\n\n        # Sort the dataframe by the group key and sort key\n        result_sort_key = group_key + sort_key\n        df_result = df_sorted.sort_values(by=result_sort_key).reset_index(drop=True)\n\n    elif isinstance(df, pl.DataFrame):\n        if isinstance(ascending, list):\n            order_reverse = [not x for x in ascending]\n        else:\n            order_reverse = not ascending\n\n        df_sorted = df.sort(sort_key, descending=order_reverse)\n        df_sorted = df_sorted.with_columns(\n            pl.col(target_column)\n            .shift(lag_size)\n            .over(group_key)\n            .alias(lagged_col_name)\n        )\n        df_result = df_sorted.sort(result_sort_key)\n\n    else:\n        raise TypeError(\n            f\"type(df) is {type(df)}: df should be pandas.DataFrame or polars.DataFrame\"\n        )\n\n    return df_result\n\n\n\n\n ▶  pandas.DataFrame\n\ngenerate_lag_variable_with_group_key(\n    df=df,\n    target_column=\"temp\",\n    sort_key=[\"time_col\"],\n    group_key=[\"entity_col\", \"state\"],\n    lag_size=1,\n    ascending= [True]\n)\n\n\n\n\n\n\n\n\nentity_col\nstate\ntime_col\ntemp\ntemp_1lag\n\n\n\n\n0\nA\n0\n2021-01-03\n2\nNaN\n\n\n1\nA\n0\n2021-01-04\n14\n2.0\n\n\n2\nA\n1\n2021-01-01\n13\nNaN\n\n\n3\nA\n1\n2021-01-02\n1\n13.0\n\n\n4\nA\n1\n2021-01-03\n12\n1.0\n\n\n5\nA\n1\n2021-01-04\n11\n12.0\n\n\n6\nB\n0\n2021-02-02\n10\nNaN\n\n\n7\nB\n0\n2021-02-03\n9\n10.0\n\n\n8\nB\n0\n2021-02-10\n8\n9.0\n\n\n9\nC\n1\n2021-01-02\n0\nNaN\n\n\n\n\n\n\n\n ▶  polars.DataFrame\n\ndf_polars = pl.DataFrame(df)\ngenerate_lag_variable_with_group_key(\n    df=df_polars,\n    target_column=\"temp\",\n    sort_key=[\"time_col\"],\n    group_key=[\"entity_col\", \"state\"],\n    lag_size=1,\n)\n\n\nshape: (10, 5)\n\n\n\nentity_col\nstate\ntime_col\ntemp\ntemp_1lag\n\n\nstr\ni64\ndatetime[ns]\ni64\ni64\n\n\n\n\n\"A\"\n0\n2021-01-03 00:00:00\n2\nnull\n\n\n\"A\"\n0\n2021-01-04 00:00:00\n14\n2\n\n\n\"A\"\n1\n2021-01-01 00:00:00\n13\nnull\n\n\n\"A\"\n1\n2021-01-02 00:00:00\n1\n13\n\n\n\"A\"\n1\n2021-01-03 00:00:00\n12\n1\n\n\n\"A\"\n1\n2021-01-04 00:00:00\n11\n12\n\n\n\"B\"\n0\n2021-02-02 00:00:00\n10\nnull\n\n\n\"B\"\n0\n2021-02-03 00:00:00\n9\n10\n\n\n\"B\"\n0\n2021-02-10 00:00:00\n8\n9\n\n\n\"C\"\n1\n2021-01-02 00:00:00\n0\nnull\n\n\n\n\n\n\n\n\n\n\n📘 テスト方針 \n\n異なるラグサイズ（lag size）の処理: ラグサイズの値を自由に指定できるか？\nカスタムラグカラム名の指定: ラグカラムに任意の名前を付けることができるか？。\nソート順の指定: 昇順（ascending=True）または降順（ascending=False）でソートできるか？\n不正な入力タイプのエラー処理: 入力値が不正な場合，適切なエラーメッセージを表示するか？\n\n\n ▶  Test Examples\n\nimport pytest\nimport pandas as pd\nimport polars as pl\nimport numpy as np\n\n# Import the function to be tested\n# from hogehoge import generate_lag_variable_with_group_key  # Replace with actual module name\n\n@pytest.fixture\ndef sample_pandas_df():\n    \"\"\"Fixture to provide a sample Pandas DataFrame\"\"\"\n    return pd.DataFrame({\n        \"entity\": [\"A\", \"A\", \"A\", \"B\", \"B\", \"B\"],\n        \"time\": [\"2023-01-01\", \"2023-01-02\", \"2023-01-03\",\n                 \"2023-01-01\", \"2023-01-02\", \"2023-01-03\"],\n        \"value\": [10, 20, 30, 100, 200, 300]\n    }).assign(time=lambda df: pd.to_datetime(df[\"time\"]))  # Ensure datetime type\n\n@pytest.fixture\ndef sample_polars_df():\n    \"\"\"Fixture to provide a sample Polars DataFrame\"\"\"\n    return pl.DataFrame({\n        \"entity\": [\"A\", \"A\", \"A\", \"B\", \"B\", \"B\"],\n        \"time\": [\"2023-01-01\", \"2023-01-02\", \"2023-01-03\",\n                 \"2023-01-01\", \"2023-01-02\", \"2023-01-03\"],\n        \"value\": [10, 20, 30, 100, 200, 300]\n    }).with_columns(pl.col(\"time\").str.to_date())  # Ensure datetime type\n\n@pytest.mark.parametrize(\"df_type\", [\"pandas\", \"polars\"])\ndef test_generate_lag_variable_basic(df_type, sample_pandas_df, sample_polars_df):\n    \"\"\"Test basic functionality with Pandas and Polars\"\"\"\n    df = sample_pandas_df if df_type == \"pandas\" else sample_polars_df\n    result = generate_lag_variable_with_group_key(\n        df=df,\n        target_column=\"value\",\n        sort_key=[\"time\"],\n        group_key=[\"entity\"],\n        lag_size=1\n    )\n\n    assert \"value_1lag\" in result.columns, \"Lagged column not found!\"\n    expected_values_pandas = [np.nan, 10.0, 20.0, np.nan, 100.0, 200.0]  # Expected shifted values\n    expected_values_polars = [None, 10, 20, None, 100, 200]  # Expected shifted values\n    if df_type == \"pandas\":\n        assert np.array_equal(result[\"value_1lag\"].to_list(), expected_values_pandas, equal_nan=True)\n    else:\n        assert result[\"value_1lag\"].to_list() == expected_values_polars \n\ndef test_generate_lag_variable_custom_column(sample_pandas_df):\n    \"\"\"Test if custom column name works correctly\"\"\"\n    result = generate_lag_variable_with_group_key(\n        df=sample_pandas_df,\n        target_column=\"value\",\n        sort_key=[\"time\"],\n        group_key=[\"entity\"],\n        lag_size=1,\n        lagged_col_name=\"custom_lag\"\n    )\n    assert \"custom_lag\" in result.columns, \"Custom lag column name not applied!\"\n\ndef test_generate_lag_variable_with_descending_order(sample_pandas_df):\n    \"\"\"Test sorting order with descending time\"\"\"\n    result = generate_lag_variable_with_group_key(\n        df=sample_pandas_df,\n        target_column=\"value\",\n        sort_key=[\"time\"],\n        group_key=[\"entity\"],\n        lag_size=1,\n        ascending=False  # Reverse sorting order\n    )\n    expected_values = [20.0, 30.0, np.nan, 200.0, 300.0, np.nan]  # Because order is reversed\n    assert np.array_equal(result[\"value_1lag\"].to_list(), expected_values, equal_nan=True)\n\ndef test_generate_lag_variable_invalid_input():\n    \"\"\"Test function raises TypeError for invalid input\"\"\"\n    with pytest.raises(TypeError):\n        generate_lag_variable_with_group_key(\n            df=\"not_a_dataframe\",  # Invalid type\n            target_column=\"value\",\n            sort_key=[\"time\"],\n            group_key=[\"entity\"],\n            lag_size=1\n        )\n\n\n注意点 ! \n\nnp.nan != np.nan であるため，np.nanを含むリストを比較する場合，== を直接使用しても正しく機能しません\nNaN は未定義値であるため，NaN は自身と等しくない"
  },
  {
    "objectID": "posts/2025-02-19-make-lag-variable/index.html#ラグ変数の作成",
    "href": "posts/2025-02-19-make-lag-variable/index.html#ラグ変数の作成",
    "title": "Group毎に定義されたラグ変数の作成",
    "section": "",
    "text": "次のようなpandas.DataFrameを考えます\n\n\nCode\nimport pandas as pd\nimport polars as pl\n\ndf = pd.DataFrame(\n    {\n        \"entity_col\": [\"A\", \"A\", \"A\", \"A\", \"A\", \"A\", \"B\", \"B\", \"B\", \"C\"],\n        \"state\": [1, 0, 1, 1, 1, 0, 0, 0, 0, 1],\n        \"time_col\": pd.to_datetime([\n            \"2021-01-02\",\n            \"2021-01-03\",\n            \"2021-01-04\",\n            \"2021-01-01\",\n            \"2021-01-03\",\n            \"2021-01-04\",\n            \"2021-02-02\",\n            \"2021-02-03\",\n            \"2021-02-10\",\n            \"2021-01-02\",\n        ]),\n        \"temp\": [1, 2, 11, 13, 12, 14, 10, 9, 8, 0],\n    }\n)\n\ndf\n\n\n\n\n\n\n\n\n\nentity_col\nstate\ntime_col\ntemp\n\n\n\n\n0\nA\n1\n2021-01-02\n1\n\n\n1\nA\n0\n2021-01-03\n2\n\n\n2\nA\n1\n2021-01-04\n11\n\n\n3\nA\n1\n2021-01-01\n13\n\n\n4\nA\n1\n2021-01-03\n12\n\n\n5\nA\n0\n2021-01-04\n14\n\n\n6\nB\n0\n2021-02-02\n10\n\n\n7\nB\n0\n2021-02-03\n9\n\n\n8\nB\n0\n2021-02-10\n8\n\n\n9\nC\n1\n2021-01-02\n0\n\n\n\n\n\n\n\n\n📘 実施したい処理 \n\n(entity_col, state)でGroup Keysとして，各Group内部で time_col の順番に応じて tempカラムについてラグ変数を作成したい\nラグ変数の名前は Defaultでは f\"{target_column}_1lag, 指定があった場合はそれに倣うとする\n\n\n\n\n\nfrom typing import Optional\n\n\ndef generate_lag_variable_with_group_key(\n    df: pd.DataFrame | pl.DataFrame,\n    target_column: str,\n    sort_key: list[str],\n    group_key: list[str],\n    lag_size: int,\n    ascending: list[bool] | bool = True,\n    lagged_col_name: Optional[str] = None,\n) -&gt; pd.DataFrame | pl.DataFrame:\n    \"\"\"\n    Generate a lagged variable in a DataFrame with a specified group key.\n\n    This function creates a new column in the DataFrame that contains\n    the lagged values of an existing column, grouped by specified keys.\n    It supports both pandas and polars DataFrames.\n\n    Parameters:\n        df (pd.DataFrame | pl.DataFrame):\n            The input DataFrame, either pandas or polars.\n\n        col (str):\n            The name of the column to generate the lagged variable from.\n\n        sort_key (list[str]):\n            The list of columns to sort the DataFrame by before generating the lagged variable.\n\n        group_key (list[str]):\n            The list of columns to group the DataFrame by before generating the lagged variable.\n\n        lag_size (int):\n            The number of periods to lag the variable.\n\n        ascending (list[bool] | bool, optional):\n            The sort order for each column in sort_key. Defaults to True.\n\n        lagged_col_name (Optional[str], optional):\n            The name of the new lagged column. If None, defaults to \"{col}_{lag_size}lag\".\n\n    Returns:\n        pd.DataFrame | pl.DataFrame: The DataFrame with the new lagged variable column.\n\n    Raises:\n        TypeError: If the input DataFrame is neither pandas.DataFrame nor polars.DataFrame.\n    \"\"\"\n\n    # set up common variables\n    if lagged_col_name is None:\n        lagged_col_name = f\"{target_column}_{lag_size}lag\"\n\n    result_sort_key = group_key + sort_key\n\n    if isinstance(df, pd.DataFrame):\n        # Sort the dataframe by the specified sort key\n        df_sorted = df.sort_values(by=sort_key, ascending=ascending)\n\n        # Generate the lagged variable\n        df_sorted[lagged_col_name] = df_sorted.groupby(group_key)[target_column].shift(\n            lag_size\n        )\n\n        # Sort the dataframe by the group key and sort key\n        result_sort_key = group_key + sort_key\n        df_result = df_sorted.sort_values(by=result_sort_key).reset_index(drop=True)\n\n    elif isinstance(df, pl.DataFrame):\n        if isinstance(ascending, list):\n            order_reverse = [not x for x in ascending]\n        else:\n            order_reverse = not ascending\n\n        df_sorted = df.sort(sort_key, descending=order_reverse)\n        df_sorted = df_sorted.with_columns(\n            pl.col(target_column)\n            .shift(lag_size)\n            .over(group_key)\n            .alias(lagged_col_name)\n        )\n        df_result = df_sorted.sort(result_sort_key)\n\n    else:\n        raise TypeError(\n            f\"type(df) is {type(df)}: df should be pandas.DataFrame or polars.DataFrame\"\n        )\n\n    return df_result\n\n\n\n\n ▶  pandas.DataFrame\n\ngenerate_lag_variable_with_group_key(\n    df=df,\n    target_column=\"temp\",\n    sort_key=[\"time_col\"],\n    group_key=[\"entity_col\", \"state\"],\n    lag_size=1,\n    ascending= [True]\n)\n\n\n\n\n\n\n\n\nentity_col\nstate\ntime_col\ntemp\ntemp_1lag\n\n\n\n\n0\nA\n0\n2021-01-03\n2\nNaN\n\n\n1\nA\n0\n2021-01-04\n14\n2.0\n\n\n2\nA\n1\n2021-01-01\n13\nNaN\n\n\n3\nA\n1\n2021-01-02\n1\n13.0\n\n\n4\nA\n1\n2021-01-03\n12\n1.0\n\n\n5\nA\n1\n2021-01-04\n11\n12.0\n\n\n6\nB\n0\n2021-02-02\n10\nNaN\n\n\n7\nB\n0\n2021-02-03\n9\n10.0\n\n\n8\nB\n0\n2021-02-10\n8\n9.0\n\n\n9\nC\n1\n2021-01-02\n0\nNaN\n\n\n\n\n\n\n\n ▶  polars.DataFrame\n\ndf_polars = pl.DataFrame(df)\ngenerate_lag_variable_with_group_key(\n    df=df_polars,\n    target_column=\"temp\",\n    sort_key=[\"time_col\"],\n    group_key=[\"entity_col\", \"state\"],\n    lag_size=1,\n)\n\n\nshape: (10, 5)\n\n\n\nentity_col\nstate\ntime_col\ntemp\ntemp_1lag\n\n\nstr\ni64\ndatetime[ns]\ni64\ni64\n\n\n\n\n\"A\"\n0\n2021-01-03 00:00:00\n2\nnull\n\n\n\"A\"\n0\n2021-01-04 00:00:00\n14\n2\n\n\n\"A\"\n1\n2021-01-01 00:00:00\n13\nnull\n\n\n\"A\"\n1\n2021-01-02 00:00:00\n1\n13\n\n\n\"A\"\n1\n2021-01-03 00:00:00\n12\n1\n\n\n\"A\"\n1\n2021-01-04 00:00:00\n11\n12\n\n\n\"B\"\n0\n2021-02-02 00:00:00\n10\nnull\n\n\n\"B\"\n0\n2021-02-03 00:00:00\n9\n10\n\n\n\"B\"\n0\n2021-02-10 00:00:00\n8\n9\n\n\n\"C\"\n1\n2021-01-02 00:00:00\n0\nnull\n\n\n\n\n\n\n\n\n\n\n📘 テスト方針 \n\n異なるラグサイズ（lag size）の処理: ラグサイズの値を自由に指定できるか？\nカスタムラグカラム名の指定: ラグカラムに任意の名前を付けることができるか？。\nソート順の指定: 昇順（ascending=True）または降順（ascending=False）でソートできるか？\n不正な入力タイプのエラー処理: 入力値が不正な場合，適切なエラーメッセージを表示するか？\n\n\n ▶  Test Examples\n\nimport pytest\nimport pandas as pd\nimport polars as pl\nimport numpy as np\n\n# Import the function to be tested\n# from hogehoge import generate_lag_variable_with_group_key  # Replace with actual module name\n\n@pytest.fixture\ndef sample_pandas_df():\n    \"\"\"Fixture to provide a sample Pandas DataFrame\"\"\"\n    return pd.DataFrame({\n        \"entity\": [\"A\", \"A\", \"A\", \"B\", \"B\", \"B\"],\n        \"time\": [\"2023-01-01\", \"2023-01-02\", \"2023-01-03\",\n                 \"2023-01-01\", \"2023-01-02\", \"2023-01-03\"],\n        \"value\": [10, 20, 30, 100, 200, 300]\n    }).assign(time=lambda df: pd.to_datetime(df[\"time\"]))  # Ensure datetime type\n\n@pytest.fixture\ndef sample_polars_df():\n    \"\"\"Fixture to provide a sample Polars DataFrame\"\"\"\n    return pl.DataFrame({\n        \"entity\": [\"A\", \"A\", \"A\", \"B\", \"B\", \"B\"],\n        \"time\": [\"2023-01-01\", \"2023-01-02\", \"2023-01-03\",\n                 \"2023-01-01\", \"2023-01-02\", \"2023-01-03\"],\n        \"value\": [10, 20, 30, 100, 200, 300]\n    }).with_columns(pl.col(\"time\").str.to_date())  # Ensure datetime type\n\n@pytest.mark.parametrize(\"df_type\", [\"pandas\", \"polars\"])\ndef test_generate_lag_variable_basic(df_type, sample_pandas_df, sample_polars_df):\n    \"\"\"Test basic functionality with Pandas and Polars\"\"\"\n    df = sample_pandas_df if df_type == \"pandas\" else sample_polars_df\n    result = generate_lag_variable_with_group_key(\n        df=df,\n        target_column=\"value\",\n        sort_key=[\"time\"],\n        group_key=[\"entity\"],\n        lag_size=1\n    )\n\n    assert \"value_1lag\" in result.columns, \"Lagged column not found!\"\n    expected_values_pandas = [np.nan, 10.0, 20.0, np.nan, 100.0, 200.0]  # Expected shifted values\n    expected_values_polars = [None, 10, 20, None, 100, 200]  # Expected shifted values\n    if df_type == \"pandas\":\n        assert np.array_equal(result[\"value_1lag\"].to_list(), expected_values_pandas, equal_nan=True)\n    else:\n        assert result[\"value_1lag\"].to_list() == expected_values_polars \n\ndef test_generate_lag_variable_custom_column(sample_pandas_df):\n    \"\"\"Test if custom column name works correctly\"\"\"\n    result = generate_lag_variable_with_group_key(\n        df=sample_pandas_df,\n        target_column=\"value\",\n        sort_key=[\"time\"],\n        group_key=[\"entity\"],\n        lag_size=1,\n        lagged_col_name=\"custom_lag\"\n    )\n    assert \"custom_lag\" in result.columns, \"Custom lag column name not applied!\"\n\ndef test_generate_lag_variable_with_descending_order(sample_pandas_df):\n    \"\"\"Test sorting order with descending time\"\"\"\n    result = generate_lag_variable_with_group_key(\n        df=sample_pandas_df,\n        target_column=\"value\",\n        sort_key=[\"time\"],\n        group_key=[\"entity\"],\n        lag_size=1,\n        ascending=False  # Reverse sorting order\n    )\n    expected_values = [20.0, 30.0, np.nan, 200.0, 300.0, np.nan]  # Because order is reversed\n    assert np.array_equal(result[\"value_1lag\"].to_list(), expected_values, equal_nan=True)\n\ndef test_generate_lag_variable_invalid_input():\n    \"\"\"Test function raises TypeError for invalid input\"\"\"\n    with pytest.raises(TypeError):\n        generate_lag_variable_with_group_key(\n            df=\"not_a_dataframe\",  # Invalid type\n            target_column=\"value\",\n            sort_key=[\"time\"],\n            group_key=[\"entity\"],\n            lag_size=1\n        )\n\n\n注意点 ! \n\nnp.nan != np.nan であるため，np.nanを含むリストを比較する場合，== を直接使用しても正しく機能しません\nNaN は未定義値であるため，NaN は自身と等しくない"
  },
  {
    "objectID": "posts/2025-01-30-differential-equations/index.html",
    "href": "posts/2025-01-30-differential-equations/index.html",
    "title": "微分方程式を用いたToy models",
    "section": "",
    "text": "Exercise 1 : マルサスの人口論 \n時刻 \\(t\\) におけるとある国の人口が \\(N(t) &gt; 0\\) で表されるとする．マルサスは時刻 \\(t\\) から \\(t+\\Delta t\\) の人口増分 \\(\\Delta N = N(t+\\Delta) - N(t)\\) は\n\\[\n\\Delta N = k N(t)\\Delta t \\qquad (k: \\text{constant})\n\\]\nのように \\(N, \\Delta t\\) に比例するとした．ここから以下のように式変形を行い\n\\[\n\\frac{\\Delta N}{\\Delta t} = k N(t)\n\\]\n\\(\\Delta t\\to 0\\) として次のような微分方程式を得たとします\n\\[\n\\frac{dN(t)}{dt} = kN(t) \\label{eq-de-01}\n\\]\n\\((t, N(t))\\) が \\((0, 1.00 \\times 10^8), (1, 1.25 \\times 10^8)\\) と与えられているとき，\\(t = 2\\) の人口 \\(N(2)\\) を推定せよ．\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n微分方程式 \\(\\eqref{eq-de-01}\\) を以下のように変形し積分すると\n\\[\n\\begin{align}\n&\\frac{dN(t)}{dt} = kN(t) \\\\\n&\\Rightarrow \\int \\frac{1}{N(t)}\\frac{dN(t)}{dt} dt= \\int k dt \\\\\n&\\Rightarrow \\log \\vert N(t) \\vert = kt + C\\\\[5pt]\n&\\Rightarrow \\log N(t) = kt + C\n\\end{align}\n\\]\n従って，\n\\[\nN(t) = \\exp(C + kt) = \\tilde C\\exp(kt)\n\\]\n\\(t = 0\\) のときの \\(N(0) = N_0\\) とすると，\\(\\tilde C = N_0\\) でなければならないので\n\\[\nN(t) = N_0\\exp(kt) \\label{eq-malthus-solution}\n\\]\n\\((t, N(t))\\) が \\((0, 1.00 \\times 10^8), (1, 1.25 \\times 10^8)\\) と与えられているので，\n\\[\nN_0 = 1.00 \\times 10^8\n\\]\n次に\n\\[\n\\begin{align}\n&N(1) = 1.00 \\times 10^8 \\exp(k)\\\\[5pt]\n&\\Rightarrow \\exp(k) = 1.25\n\\end{align}\n\\]\n従って，\n\\[\nN(2) = (1.25)^2 \\times 10^8 \\approx 1.56 \\times 10^8\n\\]\n\n\n\n ▶  Python Simulation\nscipy.integrateパッケージのodeintを用いれば微分方程式を解くことができます．\n\nCode\nimport numpy as np\nfrom scipy.integrate import odeint\nimport matplotlib.pyplot as plt\n\n# malthusian growth func\ndef malthusian_model(y, t, k=np.log(1.25)):\n    dydt = k * y\n    return dydt\n\n# init\nN_0 = 1.0\n\n# data point\ndata = (0, 1), (1, 1.25)\n\n# time\nt = np.linspace(0, 5, 21)\n\n# solve\nn = odeint(malthusian_model, N_0, t)\n\n# plot\nplt.plot(t, n)\nplt.scatter(*zip(*data), color='red', label='observed data points')\nplt.legend()\nplt.xlabel(\"t\")\nplt.ylabel(\"$N(t)$\")\nplt.title(\"Malthusian gwrowth simulation\")\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 1\n\n\n\nFigure 1 をみると \\(N(t)\\) は指数関数的に増加していることが読み取れます．これは \\(k\\) の符号に依存しています．\n\n\\(k &gt; 0\\): 指数関数的増加\n\\(k = 0\\): 変化なし\n\\(k &lt; 0\\): 指数関数的減衰\n\nとなります．図示すると以下のようになります\n\nCode\nimport statsmodels.api as sm\n\n# params\nk_args = (-0.2, 0, 0.2)\n\n# solve\nfor k in k_args:\n    n = odeint(malthusian_model, N_0, t, args=(k,))\n    plt.plot(t, n, label=f\"k={k}\")\n\nplt.legend()\nplt.xlabel(\"t\")\nplt.ylabel(\"$N(t)$\")\nplt.title(\"Malthusian growth simulation with different $k$\")\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 2\n\n\n\n\n\n\n\n\n\n🍵 マルサスモデルの限界\n\n\n\nマルサスモデルは，\\(k &gt; 0\\) のとき人口が指数関数的に増加すると予測しています．実際には，食料や石油といった資源は有限であるので人口増加を抑制する要因があるため，現実でマルサスモデル的増加をすることは到底起こりえません．\n\n\n\n\n\n\\(N(t)\\) は 4期間ごとに観測される(=観測されるtは\\((0, 1, 2, 4)\\))\n観測される \\(N(t)\\) にはノイズが乗ってしまっている: \\(\\epsilon_t \\sim N(0, 0.1)\\)\n\nという状況ののもと，\\((N_0, k)\\) を推定し，\\(t&gt;4\\) の範囲の人口について予測することはできるのか？という問題を考えてみます．\n\\(\\eqref{eq-malthus-solution}\\) について対数を取ると\n\\[\n\\log N(t) = \\log(N_0) + kt\n\\]\nとなります．つまり，対数変換した変数についての線形モデルとして推定量を考えることができます．観測ノイズ \\(\\epsilon_t\\) を踏まえると，観測される人口を \\(\\tilde N(t)\\) とすると\n\\[\n\\begin{align}\n&\\tilde N(t) = N_0\\exp(kt) + \\epsilon_t\\\\\n&\\Rightarrow\\log \\tilde N(t) = \\log (N_0\\exp(kt) + \\epsilon_t)\n\\end{align}\n\\]\nとなってしまいますが，近似式として\n\\[\n\\log\\tilde N(t) = \\alpha + \\beta t + e_i\n\\]\nで推定するとします．\\(\\epsilon_i\\)がhomogeneousとしても\\(e_i\\)がhomogeneousとは限らないのでheteroskedasticity residual erroを想定して推定します．\n\nCode\nimport statsmodels.api as sm\n\nnp.random.seed(42)\n\n# observation step\nSTEP = 4\n\n# DGP\nactual_n = n.flatten()\nobserved_n = actual_n[::STEP][:-1] + +np.random.normal(0, 0.1, len(actual_n[::STEP][:-1]))\nobserved_t = t[::STEP][:-1]\nX = sm.add_constant(observed_t)\n\n# fit\nmodel = sm.OLS(np.log(observed_n), X).fit(cov_type=\"HC0\")\nestimated_n_0, estimated_k = model.params\n\n# simulation\nsimulated_n = odeint(malthusian_model, np.exp(estimated_n_0), t, args=(estimated_k,))\n\n# plot\nplt.plot(t, simulated_n, label=\"simulated\")\nplt.scatter(observed_t, observed_n, color=\"gray\", alpha=0.8, marker='x', label=\"actual data points\")\nplt.scatter(t, actual_n, color=\"red\", alpha=0.8, label=\"actual data points\")\nplt.legend()\nplt.xlabel(\"t\")\nplt.ylabel(\"$N(t)$\")\nplt.title(\"Malthusian growth prediction\")\nplt.axvspan(4.25, t[-1], color='gray', alpha=0.3)\nplt.text(4.65, 2.0, \"Prediction\\nPeriod\", ha='center', va='center', fontsize=11, color='black')\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 3"
  },
  {
    "objectID": "posts/2025-01-30-differential-equations/index.html#マルサスモデル",
    "href": "posts/2025-01-30-differential-equations/index.html#マルサスモデル",
    "title": "微分方程式を用いたToy models",
    "section": "",
    "text": "Exercise 1 : マルサスの人口論 \n時刻 \\(t\\) におけるとある国の人口が \\(N(t) &gt; 0\\) で表されるとする．マルサスは時刻 \\(t\\) から \\(t+\\Delta t\\) の人口増分 \\(\\Delta N = N(t+\\Delta) - N(t)\\) は\n\\[\n\\Delta N = k N(t)\\Delta t \\qquad (k: \\text{constant})\n\\]\nのように \\(N, \\Delta t\\) に比例するとした．ここから以下のように式変形を行い\n\\[\n\\frac{\\Delta N}{\\Delta t} = k N(t)\n\\]\n\\(\\Delta t\\to 0\\) として次のような微分方程式を得たとします\n\\[\n\\frac{dN(t)}{dt} = kN(t) \\label{eq-de-01}\n\\]\n\\((t, N(t))\\) が \\((0, 1.00 \\times 10^8), (1, 1.25 \\times 10^8)\\) と与えられているとき，\\(t = 2\\) の人口 \\(N(2)\\) を推定せよ．\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n微分方程式 \\(\\eqref{eq-de-01}\\) を以下のように変形し積分すると\n\\[\n\\begin{align}\n&\\frac{dN(t)}{dt} = kN(t) \\\\\n&\\Rightarrow \\int \\frac{1}{N(t)}\\frac{dN(t)}{dt} dt= \\int k dt \\\\\n&\\Rightarrow \\log \\vert N(t) \\vert = kt + C\\\\[5pt]\n&\\Rightarrow \\log N(t) = kt + C\n\\end{align}\n\\]\n従って，\n\\[\nN(t) = \\exp(C + kt) = \\tilde C\\exp(kt)\n\\]\n\\(t = 0\\) のときの \\(N(0) = N_0\\) とすると，\\(\\tilde C = N_0\\) でなければならないので\n\\[\nN(t) = N_0\\exp(kt) \\label{eq-malthus-solution}\n\\]\n\\((t, N(t))\\) が \\((0, 1.00 \\times 10^8), (1, 1.25 \\times 10^8)\\) と与えられているので，\n\\[\nN_0 = 1.00 \\times 10^8\n\\]\n次に\n\\[\n\\begin{align}\n&N(1) = 1.00 \\times 10^8 \\exp(k)\\\\[5pt]\n&\\Rightarrow \\exp(k) = 1.25\n\\end{align}\n\\]\n従って，\n\\[\nN(2) = (1.25)^2 \\times 10^8 \\approx 1.56 \\times 10^8\n\\]\n\n\n\n ▶  Python Simulation\nscipy.integrateパッケージのodeintを用いれば微分方程式を解くことができます．\n\nCode\nimport numpy as np\nfrom scipy.integrate import odeint\nimport matplotlib.pyplot as plt\n\n# malthusian growth func\ndef malthusian_model(y, t, k=np.log(1.25)):\n    dydt = k * y\n    return dydt\n\n# init\nN_0 = 1.0\n\n# data point\ndata = (0, 1), (1, 1.25)\n\n# time\nt = np.linspace(0, 5, 21)\n\n# solve\nn = odeint(malthusian_model, N_0, t)\n\n# plot\nplt.plot(t, n)\nplt.scatter(*zip(*data), color='red', label='observed data points')\nplt.legend()\nplt.xlabel(\"t\")\nplt.ylabel(\"$N(t)$\")\nplt.title(\"Malthusian gwrowth simulation\")\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 1\n\n\n\nFigure 1 をみると \\(N(t)\\) は指数関数的に増加していることが読み取れます．これは \\(k\\) の符号に依存しています．\n\n\\(k &gt; 0\\): 指数関数的増加\n\\(k = 0\\): 変化なし\n\\(k &lt; 0\\): 指数関数的減衰\n\nとなります．図示すると以下のようになります\n\nCode\nimport statsmodels.api as sm\n\n# params\nk_args = (-0.2, 0, 0.2)\n\n# solve\nfor k in k_args:\n    n = odeint(malthusian_model, N_0, t, args=(k,))\n    plt.plot(t, n, label=f\"k={k}\")\n\nplt.legend()\nplt.xlabel(\"t\")\nplt.ylabel(\"$N(t)$\")\nplt.title(\"Malthusian growth simulation with different $k$\")\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 2\n\n\n\n\n\n\n\n\n\n🍵 マルサスモデルの限界\n\n\n\nマルサスモデルは，\\(k &gt; 0\\) のとき人口が指数関数的に増加すると予測しています．実際には，食料や石油といった資源は有限であるので人口増加を抑制する要因があるため，現実でマルサスモデル的増加をすることは到底起こりえません．\n\n\n\n\n\n\\(N(t)\\) は 4期間ごとに観測される(=観測されるtは\\((0, 1, 2, 4)\\))\n観測される \\(N(t)\\) にはノイズが乗ってしまっている: \\(\\epsilon_t \\sim N(0, 0.1)\\)\n\nという状況ののもと，\\((N_0, k)\\) を推定し，\\(t&gt;4\\) の範囲の人口について予測することはできるのか？という問題を考えてみます．\n\\(\\eqref{eq-malthus-solution}\\) について対数を取ると\n\\[\n\\log N(t) = \\log(N_0) + kt\n\\]\nとなります．つまり，対数変換した変数についての線形モデルとして推定量を考えることができます．観測ノイズ \\(\\epsilon_t\\) を踏まえると，観測される人口を \\(\\tilde N(t)\\) とすると\n\\[\n\\begin{align}\n&\\tilde N(t) = N_0\\exp(kt) + \\epsilon_t\\\\\n&\\Rightarrow\\log \\tilde N(t) = \\log (N_0\\exp(kt) + \\epsilon_t)\n\\end{align}\n\\]\nとなってしまいますが，近似式として\n\\[\n\\log\\tilde N(t) = \\alpha + \\beta t + e_i\n\\]\nで推定するとします．\\(\\epsilon_i\\)がhomogeneousとしても\\(e_i\\)がhomogeneousとは限らないのでheteroskedasticity residual erroを想定して推定します．\n\nCode\nimport statsmodels.api as sm\n\nnp.random.seed(42)\n\n# observation step\nSTEP = 4\n\n# DGP\nactual_n = n.flatten()\nobserved_n = actual_n[::STEP][:-1] + +np.random.normal(0, 0.1, len(actual_n[::STEP][:-1]))\nobserved_t = t[::STEP][:-1]\nX = sm.add_constant(observed_t)\n\n# fit\nmodel = sm.OLS(np.log(observed_n), X).fit(cov_type=\"HC0\")\nestimated_n_0, estimated_k = model.params\n\n# simulation\nsimulated_n = odeint(malthusian_model, np.exp(estimated_n_0), t, args=(estimated_k,))\n\n# plot\nplt.plot(t, simulated_n, label=\"simulated\")\nplt.scatter(observed_t, observed_n, color=\"gray\", alpha=0.8, marker='x', label=\"actual data points\")\nplt.scatter(t, actual_n, color=\"red\", alpha=0.8, label=\"actual data points\")\nplt.legend()\nplt.xlabel(\"t\")\nplt.ylabel(\"$N(t)$\")\nplt.title(\"Malthusian growth prediction\")\nplt.axvspan(4.25, t[-1], color='gray', alpha=0.3)\nplt.text(4.65, 2.0, \"Prediction\\nPeriod\", ha='center', va='center', fontsize=11, color='black')\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 3"
  },
  {
    "objectID": "posts/2025-01-30-differential-equations/index.html#ヴェアフルストの人口論",
    "href": "posts/2025-01-30-differential-equations/index.html#ヴェアフルストの人口論",
    "title": "微分方程式を用いたToy models",
    "section": "ヴェアフルストの人口論",
    "text": "ヴェアフルストの人口論\n人口過密の要因を考慮に入れてマルサスモデルを修正したのがヴェアフルストモデルです．\n ▶  仮定の設定\n\n人口の上限 \\(N_\\infty\\) が存在する\n現在の人口を \\(N(t)\\) としたとき，人口増加 \\(\\Delta N(t)\\) は \\(N(t)\\) と \\(\\displaystyle 1 - \\frac{N(t)}{N_\\infty}\\) と時間区間 \\(\\Delta\\) に比例する\n\n ▶  問題の定式化\n比例定数を \\(k\\) としたとき\n\\[\n\\Delta N(t) = kN(t)\\left(1 - \\frac{N(t)}{N_\\infty}\\right)\\Delta t\n\\]\n\\(\\Delta t\\to 0\\) と極限をとると\n\\[\n\\frac{dN(t)}{dt} = kN(t)\\left(1 - \\frac{N(t)}{N_\\infty}\\right)\\label{eq-logistic-model}\n\\]\n人口変化は上記のような一階上微分方程式で表せるという形で定式化できました．\n ▶  モデルを解く\n\\(\\eqref{eq-logistic-model}\\) を変形すると\n\\[\n\\frac{N_\\infty}{N_\\infty - N(t)}\\frac{dN(t)}{N(t)dt} = k\n\\]\n両辺を \\(t\\) について積分すると\n\\[\n\\begin{align}\n& \\int\\frac{N_\\infty}{N_\\infty - N(t)}\\frac{dN(t)}{N(t)dt} dt= \\int k dt\\\\\n&\\Rightarrow \\int\\left(\\frac{1}{N(t)}+\\frac{1}{N_\\infty - N(t)}\\right)dN(t) = \\int k dt\\\\\n&\\Rightarrow \\log N(t) - \\log(N_\\infty - N(t)) = kt + C\\\\\n&\\Rightarrow \\log \\frac{N(t)}{N_\\infty - N(t)} = kt + C\n\\end{align}\n\\]\nこのとき，\\(N(0) = N_0\\) と初期条件が与えられたとすると\n\\[\n\\exp(C) = \\frac{N_0}{N_\\infty - N_0}\n\\]\nよって，\n\\[\n\\frac{N(t)}{N_\\infty - N(t)} = \\frac{N_0}{N_\\infty - N_0}\\exp(kt)\n\\]\nこれを \\(N(t)\\) についてとくと，\n\\[\nN(t) = \\frac{N_\\infty}{1 + [(N_\\infty/N_0 - 1)]\\exp(-kt)}\n\\]\nまたは\n\\[\n\\frac{1}{N(t)} = \\frac{1}{N_\\infty} + \\left(\\frac{1}{N_0} - \\frac{1}{N_\\infty}\\right)\\exp(-kt)\n\\]\n ▶  解釈\n\\(t\\to\\infty\\) のとき，\\(\\lim_{t\\to\\infty}\\exp(-kt) = 0\\) より\n\\[\n\\lim_{t\\to\\infty}N(t) = N_\\infty\n\\]\nとなることがわかります．初期値に応じて \\(N_\\infty\\) へ到達する経路は異なります．仮に \\(N_\\infty = 12, k=0.2\\) として，初期値が \\((1, 3, 6, 9, 12, 15)\\) と異なる水準で与えられたとします．\n\n\nCode\nfrom scipy.integrate import solve_ivp\n\n\n# Define logistic growth model\ndef logistic_growth(t, N, k=0.2, M=12):\n    dydt = k * N * (1 - N / M)\n    return dydt\n\n# Set up the grid for the direction field\nt_vals = np.linspace(0, 30, 20)  # Time values\nP_vals = np.linspace(0, 16, 20)  # Population values\nT, P = np.meshgrid(t_vals, P_vals)\n\n# Compute direction field (dP/dt values)\ndP_dt = logistic_growth(None, P)\n\n# Normalize arrows for visualization\nnorm = np.sqrt(1**2 + dP_dt**2)\nU = 1 / norm  # Time step is 1 (arbitrary)\nV = dP_dt / norm  # Scale arrows properly\n\n# Plot the direction field\nplt.figure(figsize=(8, 5))\nplt.quiver(T, P, U, V, color=\"gray\", alpha=0.7) # [T, P]: arrow location, [U, V]: arrow direction\n\n# Solve the ODE for different initial conditions\ninitial_conditions = [1, 3, 6, 9, 12, 15,]\nt_span = (0, 30)\nt_eval = np.linspace(0, 30, 100)\n\nfor P0 in initial_conditions:\n    sol = solve_ivp(logistic_growth, t_span, [P0], t_eval=t_eval)\n    if sol.success:\n        plt.plot(sol.t, sol.y[0], linewidth=2, label=f\"P(0)={P0}\")\n    else:\n        raise ValueError(\"computation failed\")\n\n# Labels and title\nplt.xlabel(\"t\")\nplt.ylabel(\"P(t)\")\nplt.title(\"Logistic Growth Model\")\nplt.legend()\nplt.grid()\n\n# Show the plot\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\\(0&lt; N_0 &lt; N_\\infty\\): はじめの増加は指数関数的だが，ある程度の水準から増加の度合いは減衰していく\n\\(N_0 = N_\\infty\\): 変化なし\n\\(N_0 &gt; N_\\infty\\): \\(N_\\infty\\)に近づく方向で減少していく．減衰の度合いは減衰していく\n\\(N_0 = 0\\): これも一つの均衡だが，ちょっとしたショックがあるだけで \\(N_\\infty\\) を目指すPathに乗ってしまう(= unstable equilibrium)\n\n ▶  Validation\nヴェアフルストモデルが人口動態を表した良いモデルなのか，1820-1930のアメリカの人口データを用いて検証してみます．\n\n\nCode\nimport pandas as pd\n\n# Historical population data (year, population in millions)\ndata = {\n    \"year\": [1820, 1830, 1840, 1850, 1860, 1870, 1880, 1890, 1900, 1910, 1920, 1930, 2000],\n    \"us_population_million\": [9.6, 12.9, 17.1, 23.2, 31.4, 38.6, 50.2, 62.9, 76.0, 92.0, 106.5, 123.2, 282.2]\n}\n\n# Create DataFrame\ndf = pd.DataFrame(data)\n\n# Display table\ndf\n\n\n\n\n\n\n\n\n\nyear\nus_population_million\n\n\n\n\n0\n1820\n9.6\n\n\n1\n1830\n12.9\n\n\n2\n1840\n17.1\n\n\n3\n1850\n23.2\n\n\n4\n1860\n31.4\n\n\n5\n1870\n38.6\n\n\n6\n1880\n50.2\n\n\n7\n1890\n62.9\n\n\n8\n1900\n76.0\n\n\n9\n1910\n92.0\n\n\n10\n1920\n106.5\n\n\n11\n1930\n123.2\n\n\n12\n2000\n282.2\n\n\n\n\n\n\n\nパラメーターを \\(N_0 = 3.9, k = 0.3134, N_\\infty = 197\\) と選ぶと\n\nCode\nt_index = np.linspace(0, (df.shape[0] + 10), 100)\nsol = solve_ivp(logistic_growth, [0, t_index[-1]], [3.9], t_eval=t_index, args=(0.3134, 197))\nplt.plot(1790 + sol.t*10, sol.y[0], linewidth=2, label=f\"prediction\")\nplt.scatter(\n    df.year,\n    df.us_population_million,\n    color=\"gray\",\n    alpha=0.8,\n    marker=\"x\",\n    label=\"actual data points\",\n)\nplt.xlabel('year')\nplt.ylabel('population(million)')\nplt.legend()\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 4: Model prediction vs actual USA population\n\n\n\nこのように, 1800-1930年のアメリカ人口動態を上手く説明するモデルとなっていることがわかります．一方，モデルの上限は \\(197\\times 10^6\\) であるが，2000年の人口は \\(282.2\\times 10^6\\) となっており，長期における人口動態を説明できるものにはなっていないことも読み取れます．\n\\(N_\\infty\\) の仮定が間違っていたと解釈することが一つ考えられますが，人口変化を支配する法則は技術変化や政治といった要因に影響を受けるため，常に同じ支配法則に基づいていると仮定することが間違っているとも解釈することが出来ます．"
  },
  {
    "objectID": "posts/2025-01-28-mathmatical-modelling/index.html",
    "href": "posts/2025-01-28-mathmatical-modelling/index.html",
    "title": "数理モデルの作り方",
    "section": "",
    "text": "モデリングとは，現実の事象を説明するために実施するプロセスです．モデリングを通じて，これまで未知であった自然現象を解明したり，または解明を通じて将来の予測や，モデルに基づく意思決定を行ったりします．\nモデリングの流れとしては，\n\n単純化した仮定をたくさん立てる\n重要な変数が何であるのか明らかにする\n変数間の関係性について何かしらの仮定を考える\n\nこれらのステップを行いながら，現実の問題を数理モデルの問題に置き換えます．その後，適切な手法を用いて，モデルを解きます．解が出てきたならば，\n\nその解を現実の問題の文脈に翻訳し解釈\nモデルの解が現実のデータと一致しているかの妥当性検証\n\nを行いモデルを評価します．もしモデルの妥当性に疑念が認められたならば，仮定や変数の見直しなど定式化をやり直します．もしモデルが現実の事象に対して良い適合を示していたならば，意思決定目的関数に従ってモデル予測に基づく決定を行います．この一連の流れを表したのが (Figure 1) となります．\n\n\n\n\n\n\n\n\nflowchart BT\n    problem_setup[\"1: 解きたい現象の選択\"]\n    assumption[\"2: 仮説 & 仮定立案\"]\n    define_objective[\"3: 数理問題のモデル定式化\"]\n    solve[\"4: 数理問題を解く\"]\n    analysis[\"5: 解の意味を解釈する\"]\n    validation[\"6: モデル妥当性検証\"]\n    decision[\"7: モデルを用いた意思決定\"]\n    \n\n    subgraph problem-framing-phase[\"**phase 1: モデル定式化**\"]\n        direction TB\n        problem_setup --&gt; assumption\n        assumption --&gt; define_objective\n    end\n\n    subgraph analysis-phase[\"**phase 2: モデルを解く**\"]\n        direction LR\n        solve --&gt; analysis\n        analysis --&gt; validation\n    end\n\n    subgraph decision-phase[\"**phase 3: 意思決定**\"]\n        decision\n    end\n\n    analysis-phase --仮定/変数/モデル&lt;br&gt;の見直し--&gt; problem-framing-phase\n    problem-framing-phase ----&gt; analysis-phase\n    analysis-phase ----&gt; decision-phase\n\n\n\n\n\n\n\n\nFigure 1\n\n\n\n注意点として，なにを解きたいか？・知りたいか？がすでに決定されている状況からモデリングへというステップに入ります．なにを解くべきか？は意思決定問題の定式化や文脈に依存します．「解くべきもの・解く価値のあるもの」の議論を実施した上で，モデリングという過程に入ることを意識することが重要です．"
  },
  {
    "objectID": "posts/2025-01-28-mathmatical-modelling/index.html#モデリングのステップ",
    "href": "posts/2025-01-28-mathmatical-modelling/index.html#モデリングのステップ",
    "title": "数理モデルの作り方",
    "section": "",
    "text": "モデリングとは，現実の事象を説明するために実施するプロセスです．モデリングを通じて，これまで未知であった自然現象を解明したり，または解明を通じて将来の予測や，モデルに基づく意思決定を行ったりします．\nモデリングの流れとしては，\n\n単純化した仮定をたくさん立てる\n重要な変数が何であるのか明らかにする\n変数間の関係性について何かしらの仮定を考える\n\nこれらのステップを行いながら，現実の問題を数理モデルの問題に置き換えます．その後，適切な手法を用いて，モデルを解きます．解が出てきたならば，\n\nその解を現実の問題の文脈に翻訳し解釈\nモデルの解が現実のデータと一致しているかの妥当性検証\n\nを行いモデルを評価します．もしモデルの妥当性に疑念が認められたならば，仮定や変数の見直しなど定式化をやり直します．もしモデルが現実の事象に対して良い適合を示していたならば，意思決定目的関数に従ってモデル予測に基づく決定を行います．この一連の流れを表したのが (Figure 1) となります．\n\n\n\n\n\n\n\n\nflowchart BT\n    problem_setup[\"1: 解きたい現象の選択\"]\n    assumption[\"2: 仮説 & 仮定立案\"]\n    define_objective[\"3: 数理問題のモデル定式化\"]\n    solve[\"4: 数理問題を解く\"]\n    analysis[\"5: 解の意味を解釈する\"]\n    validation[\"6: モデル妥当性検証\"]\n    decision[\"7: モデルを用いた意思決定\"]\n    \n\n    subgraph problem-framing-phase[\"**phase 1: モデル定式化**\"]\n        direction TB\n        problem_setup --&gt; assumption\n        assumption --&gt; define_objective\n    end\n\n    subgraph analysis-phase[\"**phase 2: モデルを解く**\"]\n        direction LR\n        solve --&gt; analysis\n        analysis --&gt; validation\n    end\n\n    subgraph decision-phase[\"**phase 3: 意思決定**\"]\n        decision\n    end\n\n    analysis-phase --仮定/変数/モデル&lt;br&gt;の見直し--&gt; problem-framing-phase\n    problem-framing-phase ----&gt; analysis-phase\n    analysis-phase ----&gt; decision-phase\n\n\n\n\n\n\n\n\nFigure 1\n\n\n\n注意点として，なにを解きたいか？・知りたいか？がすでに決定されている状況からモデリングへというステップに入ります．なにを解くべきか？は意思決定問題の定式化や文脈に依存します．「解くべきもの・解く価値のあるもの」の議論を実施した上で，モデリングという過程に入ることを意識することが重要です．"
  },
  {
    "objectID": "posts/2025-02-05-surveying/index.html",
    "href": "posts/2025-02-05-surveying/index.html",
    "title": "測量法における測量の分類",
    "section": "",
    "text": "測量の分類は，一般的には，\n\n測量の手法\n測量の目的\n\nによって分類され，具体的には，多角測量，水準測量，地形測量，写真測量，地図測量，GISなどがあります．一方，測量法に基づく測量の分類という観点だと，測量法では，測量を\n\n基本測量\n公共測量\n基本測量及び公共測量以外の測量\n\nの三種類に分類しています．\n\n\n\n測量法第4条 \n「基本測量」とは，すべての測量の基礎となる測量で，国土地理院の行うものをいう\n\n基本測量とは以下２つの特徴があります\n\n国土地理院が実施する測量\nすべての測量の基礎となる測量\n\n ▶  基本測量事業内容\n\n\n\n\n\n\n\n測量内容\n説明\n\n\n\n\n基準点測量\n各種測量に地球上の正確な位置と高さを与える国家基準点体系（三角点，水準点等）の整備と維持管理事業\n\n\n地殻変動観測\n準点測量を継続的に行うことにより，地殻の動きをとらえる測量事業\n\n\n地理情報の整備や２万５千分の１地形図等基本図の作成\nデジタル形式の基本図「電子国土基本図」の整備など\n\n\n\n ▶  測量標の保全\n\n測量法第22条 \n何人も，国土地理院の長の承諾を得ないで，基本測量の測量標を移転し，汚損し，その他その効用を害する行為をしてはならない．\n\n\n\n\n\n測量法第5条 \n「公共測量」とは，基本測量以外の測量で次に掲げるものをいい，建物に関する測量その他の局地的測量又は小縮尺図の調製その他の高度の精度を必要としない測量で政令で定めるものを除く．\n\nその測量の実施に要する費用の全部又は一部を国又は公共団体が負担し，又は補助して行う測量\n基本測量又は公共測量の測量成果を使用して次の事業のために実施する測量で国土交通大臣が指定したもの\n\n行政庁の許可，認可その他の処分を受けて行われる事業\nその実施に要する費用の全部又は一部について国又は公共団体の負担又は補助，貸付けその他の助成を受けて行われる事業\n\n\n\n公共測量となる測量は以下の条件すべてを満たす測量だけとなります\n\n測量経費: 測量の費用を国・公共団体が負担・補助して実施する測量\n測量の精度: 高精度な測量に限る．国土地理院が測量計画機関から提出された計画書を審査し必要な精度が得られる方法で行われているか判断\n使用する測量: 基本測量・公共測量成果を２点以上使用する測量１点以下の場合でも規模大の測量\n\n公共測量は日本で実施される測量の大部分を占めています．（source: 国土地理院）\n\n\n\n\n\npie title 測量種類別の事業費の割合\n         \"公共測量\" : 89\n         \"民間の測量\" : 20\n         \"基本測量\": 1\n\n\n\n\n\n\n\n ▶  公共測量の表示等\n\n測量法第37条 \n公共測量を実施する者は，当該測量において設置する測量標に，公共測量の測量標であること及び測量計画機関の名称を表示しなければならない．\n\n公共測量を実施する者は，関係市町村長に対して当該測量を実施するために必要な情報の提供を求めることができる．\n測量計画機関は，公共測量において永久標識を設置したときは，遅滞なく，その種類及び所在地その他国土交通省令で定める事項を国土地理院の長に通知しなければならない．\n測量計画機関は，自ら実施した公共測量の永久標識を移転し，撤去し，又は廃棄したときは，遅滞なく，その種類及び旧所在地その他国土交通省令で定める事項を国土地理院の長に通知しなければならない．\n\n\n測量法第37条2にて，公共測量を実施するにあたって，地元の事情に最も精通していると考えられる関係市町村長に情報の提供を求めることができると規定されています．都道府県知事ではなく関係市町村長であるところに注意が必要です．\n\n\n\n\n測量法第6条 \nこの法律において「基本測量及び公共測量以外の測量」とは，基本測量又は公共測量の測量成果を使用して実施する基本測量及び公共測量以外の測量（建物に関する測量その他の局地的測量又は小縮尺図の調製その他の高度の精度を必要としない測量で政令で定めるものを除く．）をいう．"
  },
  {
    "objectID": "posts/2025-02-05-surveying/index.html#測量法における測量の分類",
    "href": "posts/2025-02-05-surveying/index.html#測量法における測量の分類",
    "title": "測量法における測量の分類",
    "section": "",
    "text": "測量の分類は，一般的には，\n\n測量の手法\n測量の目的\n\nによって分類され，具体的には，多角測量，水準測量，地形測量，写真測量，地図測量，GISなどがあります．一方，測量法に基づく測量の分類という観点だと，測量法では，測量を\n\n基本測量\n公共測量\n基本測量及び公共測量以外の測量\n\nの三種類に分類しています．\n\n\n\n測量法第4条 \n「基本測量」とは，すべての測量の基礎となる測量で，国土地理院の行うものをいう\n\n基本測量とは以下２つの特徴があります\n\n国土地理院が実施する測量\nすべての測量の基礎となる測量\n\n ▶  基本測量事業内容\n\n\n\n\n\n\n\n測量内容\n説明\n\n\n\n\n基準点測量\n各種測量に地球上の正確な位置と高さを与える国家基準点体系（三角点，水準点等）の整備と維持管理事業\n\n\n地殻変動観測\n準点測量を継続的に行うことにより，地殻の動きをとらえる測量事業\n\n\n地理情報の整備や２万５千分の１地形図等基本図の作成\nデジタル形式の基本図「電子国土基本図」の整備など\n\n\n\n ▶  測量標の保全\n\n測量法第22条 \n何人も，国土地理院の長の承諾を得ないで，基本測量の測量標を移転し，汚損し，その他その効用を害する行為をしてはならない．\n\n\n\n\n\n測量法第5条 \n「公共測量」とは，基本測量以外の測量で次に掲げるものをいい，建物に関する測量その他の局地的測量又は小縮尺図の調製その他の高度の精度を必要としない測量で政令で定めるものを除く．\n\nその測量の実施に要する費用の全部又は一部を国又は公共団体が負担し，又は補助して行う測量\n基本測量又は公共測量の測量成果を使用して次の事業のために実施する測量で国土交通大臣が指定したもの\n\n行政庁の許可，認可その他の処分を受けて行われる事業\nその実施に要する費用の全部又は一部について国又は公共団体の負担又は補助，貸付けその他の助成を受けて行われる事業\n\n\n\n公共測量となる測量は以下の条件すべてを満たす測量だけとなります\n\n測量経費: 測量の費用を国・公共団体が負担・補助して実施する測量\n測量の精度: 高精度な測量に限る．国土地理院が測量計画機関から提出された計画書を審査し必要な精度が得られる方法で行われているか判断\n使用する測量: 基本測量・公共測量成果を２点以上使用する測量１点以下の場合でも規模大の測量\n\n公共測量は日本で実施される測量の大部分を占めています．（source: 国土地理院）\n\n\n\n\n\npie title 測量種類別の事業費の割合\n         \"公共測量\" : 89\n         \"民間の測量\" : 20\n         \"基本測量\": 1\n\n\n\n\n\n\n\n ▶  公共測量の表示等\n\n測量法第37条 \n公共測量を実施する者は，当該測量において設置する測量標に，公共測量の測量標であること及び測量計画機関の名称を表示しなければならない．\n\n公共測量を実施する者は，関係市町村長に対して当該測量を実施するために必要な情報の提供を求めることができる．\n測量計画機関は，公共測量において永久標識を設置したときは，遅滞なく，その種類及び所在地その他国土交通省令で定める事項を国土地理院の長に通知しなければならない．\n測量計画機関は，自ら実施した公共測量の永久標識を移転し，撤去し，又は廃棄したときは，遅滞なく，その種類及び旧所在地その他国土交通省令で定める事項を国土地理院の長に通知しなければならない．\n\n\n測量法第37条2にて，公共測量を実施するにあたって，地元の事情に最も精通していると考えられる関係市町村長に情報の提供を求めることができると規定されています．都道府県知事ではなく関係市町村長であるところに注意が必要です．\n\n\n\n\n測量法第6条 \nこの法律において「基本測量及び公共測量以外の測量」とは，基本測量又は公共測量の測量成果を使用して実施する基本測量及び公共測量以外の測量（建物に関する測量その他の局地的測量又は小縮尺図の調製その他の高度の精度を必要としない測量で政令で定めるものを除く．）をいう．"
  },
  {
    "objectID": "posts/2025-02-05-surveying/index.html#測量法と測量の基準",
    "href": "posts/2025-02-05-surveying/index.html#測量法と測量の基準",
    "title": "測量法における測量の分類",
    "section": "測量法と測量の基準",
    "text": "測量法と測量の基準\n\n測量法第11条1項 \n位置は，地理学的経緯度及び平均海面からの高さで表示する． ただし，場合により，直角座標及び平均海面からの高さ，極座標及び平均海面からの高さ又は地心直交座標で表示することができる\n\n測量の基準に関して，位置の表示は原則「位置は，地理学的経緯度及び平均海面からの高さで表示する」ということになっています．\n\n世界測地系\n\n測量法第11条第2項 \n前項第一号の地理学的経緯度は，世界測地系に従つて測定しなければならない．\n\n世界測地系は，概念としてはただ一つのものですが，国ごとに採用する時期や構築に当たっての詳細な手法及び実現精度が異なります．代表例として以下の世界測地系があります：\n\n\n\n\n\n\n\n世界測地系\n特徴\n\n\n\n\nITRF系（国際地球基準座標系）\n地球の重心が原点，X軸をグリニッジ子午線と赤道との交点の方向，Y軸を東経90度の方向，Z軸を北極の方向にとった３次元直交座標(=Z軸は地球の自転軸と一致している)\n\n\nWGS系\nアメリカのGPSに用いられている．高精度・継続性よりむしろリアルタイム性が重要視される軍事，航法，海図，ナビゲーションの分野に適した世界測地系とされている．ITRF系とほぼ同一\n\n\nPZ系\nロシアの測位システムに用いられている\n\n\n\n日本では，ITRF系GRS80楕円体を採用しています．\n\n\n\n\n\n\n🌍: GRS80楕円体\n\n\n\n地球の形状は，自転による遠心力のため扁平な回転楕円体ですが，この楕円体の超半径と扁平率を与えたものを準拠楕円体と呼びます．準拠楕円体の１つであるGRS80楕円体では以下のように定められます\n\n長半径: 6,378,137m\n扁平率: 1/298.257222101\n\n\n\n\n回転楕円体\n\n\n\n\n\n\nジオイド\n\nDef: ジオイド \n平均海面を仮想的に陸地へ延長した面を「ジオイド」と呼ぶ．日本では，日本経緯度原点に最も近い東京湾の平均海面を通る水準面がジオイドと一致するものと考え, 高さの基準としている．ジオイドは重力方向に対して直交しています．\n\n\n\nGeoid\n\n\n\n水は重力の影響を受けて，高いところから低いところへ流れますが，地面が平坦なところでも，重力が小さいところから大きいところへ水が流れます． 地球内部の質量分布の不均一などによって，重力分布は一様ではないため，東京湾平均海面を基準としたジオイドはゆるやかな凹凸をしています．\n日本の土地の高さ（標高）は，東京湾の平均海面を基準（標高０ｍ）として測られています．水が高いこところから低いところへ流れることを表したジオイドを用いて標高が計算されているので．標高の高さと水の流れる方向は対応しているといえます．\n ▶  標高とジオイド高と楕円体高\n\n\n\nジオイド高さと標高と楕円体高\n\n\n\nジオイド高: 衛星測位の高さの基準である楕円体面から「ジオイド」までの高さ，国土地理院が発表している\n楕円体高: GPSや準天頂衛星システム等のGNSS測量で得られる高さで，楕円体面から地表面までの高さ\n\n\\[\n\\text{標高} = \\text{楕円体高} - \\text{ジオイド高}\n\\]"
  },
  {
    "objectID": "posts/2025-02-01-function-and-taylor-expansion/index.html",
    "href": "posts/2025-02-01-function-and-taylor-expansion/index.html",
    "title": "18世紀までの関数論とテイラー展開",
    "section": "",
    "text": "Def: 関数 \n\\(X \\subset \\mathbb R^n, Y\\subset \\mathbb R^n\\) とする．\\(X\\) から \\(Y\\) への関数（実関数）とは，\\(X\\) の任意の元 \\(x\\) に対して，\\(Y\\) の１つの元を対応させる規則をいう． このような \\(X\\) から \\(Y\\) への関数を\n\\[\nf: X\\to Y\n\\]\nを記述し，集合 \\(X\\) を関数 \\(f\\) の定義域(domain)，\\(Y\\) を値域(range) という．\n\n\\(y = x^2\\) としたとき，\\(y\\) は区間 \\((-\\infty, \\infty)\\) における \\(x\\) の関数と呼ばれます．関数の例としては以下，\n\nCode\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nx = np.linspace(-1, 1, 100)\n\nplt.plot(x, x**2)\nplt.gca().set_aspect('equal', adjustable='box')\nplt.show()\n\nplt.plot(x , np.sqrt(1 - x**2))\nplt.gca().set_aspect('equal', adjustable='box')\nplt.show()\n\n\n\n\n\n\n\n\\(y = x^2\\)\n\n\n\n\n\n\n\n\\(y = \\sqrt{1 - x^2}\\)\n\n\n\n\n\n ▶  古典的な関数\n歴史的に関数はまず，\n\n四則演算で表される代数式（\\(x^2 + 2x +1\\), \\(x + \\frac{1}{x}\\), \\(x + \\sqrt{4x^2 + 1}\\)）\n独立変数の代数式で表せない超越関数（\\(a^x, \\log x, \\sin x, \\arctan x\\)）\n\nに限られていました．これら関数は，各点周りでテイラー展開ができるという特徴があります．"
  },
  {
    "objectID": "posts/2025-02-01-function-and-taylor-expansion/index.html#関数",
    "href": "posts/2025-02-01-function-and-taylor-expansion/index.html#関数",
    "title": "18世紀までの関数論とテイラー展開",
    "section": "",
    "text": "Def: 関数 \n\\(X \\subset \\mathbb R^n, Y\\subset \\mathbb R^n\\) とする．\\(X\\) から \\(Y\\) への関数（実関数）とは，\\(X\\) の任意の元 \\(x\\) に対して，\\(Y\\) の１つの元を対応させる規則をいう． このような \\(X\\) から \\(Y\\) への関数を\n\\[\nf: X\\to Y\n\\]\nを記述し，集合 \\(X\\) を関数 \\(f\\) の定義域(domain)，\\(Y\\) を値域(range) という．\n\n\\(y = x^2\\) としたとき，\\(y\\) は区間 \\((-\\infty, \\infty)\\) における \\(x\\) の関数と呼ばれます．関数の例としては以下，\n\nCode\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nx = np.linspace(-1, 1, 100)\n\nplt.plot(x, x**2)\nplt.gca().set_aspect('equal', adjustable='box')\nplt.show()\n\nplt.plot(x , np.sqrt(1 - x**2))\nplt.gca().set_aspect('equal', adjustable='box')\nplt.show()\n\n\n\n\n\n\n\n\\(y = x^2\\)\n\n\n\n\n\n\n\n\\(y = \\sqrt{1 - x^2}\\)\n\n\n\n\n\n ▶  古典的な関数\n歴史的に関数はまず，\n\n四則演算で表される代数式（\\(x^2 + 2x +1\\), \\(x + \\frac{1}{x}\\), \\(x + \\sqrt{4x^2 + 1}\\)）\n独立変数の代数式で表せない超越関数（\\(a^x, \\log x, \\sin x, \\arctan x\\)）\n\nに限られていました．これら関数は，各点周りでテイラー展開ができるという特徴があります．"
  },
  {
    "objectID": "posts/2025-02-01-function-and-taylor-expansion/index.html#平均値の定理からtaylorの公式へ",
    "href": "posts/2025-02-01-function-and-taylor-expansion/index.html#平均値の定理からtaylorの公式へ",
    "title": "18世紀までの関数論とテイラー展開",
    "section": "平均値の定理からTaylorの公式へ",
    "text": "平均値の定理からTaylorの公式へ\n\n\nTheorem 1 : 平均値の定理 \n区間 \\([a, b]\\) において，\\(f(x), g(x)\\) は連続で, \\((a, b)\\) において微分可能とする．このとき，ある点 \\(\\xi \\in (a, b)\\) において，\n\\[\n\\frac{f(b) - f(a)}{g(b) - g(a)} = \\frac{f^\\prime(\\xi)}{g^\\prime(\\xi)}\\label{eq-mean-value}\n\\]\nただし，\\(g(a)\\neq g(b)\\)．\\(f^\\prime(x), g^\\prime(x)\\) は区間内で同時に \\(0\\) にならないと仮定する．\n\n\n\n\n\n\n\n\n\nProof\n\n\n\n\n\n\\(F(x) - \\mu f(x) - \\lambda g(x)\\) とおき，\\(F(a) = F(b) = k\\) となるように適当に \\(\\lambda:\\mu\\) を定める．\nこのとき，\n\\[\n\\begin{gather}\n\\mu f(a) - \\lambda g(a) = \\mu f(b) - \\lambda g(b)\\\\\n\\Rightarrow \\mu (f(b) - f(a)) = \\lambda (g(b) - g(a))\\\\\n\\Rightarrow \\mu (f(b) - f(a)) = \\lambda (g(b) - g(a))\\\\\n\\Rightarrow \\mu = g(b) - g(a), \\lambda = f(b) - f(a)\n\\end{gather}\n\\]\nとして，\n\\[\nF(x) = \\{g(b)-g(a)\\}f(x) - \\{f(b)-f(a)\\}g(x)\n\\]\nここで，\\(G(x) = F(x) - k\\) を考える．有界閉区間 \\([a, b]\\) において \\(f(x), g(x)\\) は連続であるので，有界閉区間 \\([a, b]\\) において \\(F(x)\\) および \\(G(x)\\) も連続関数である．関数の連続性より， とある \\(\\xi \\in [a, b]\\) で \\(G(x)\\) は最大値 \\(G(\\xi) = M &lt; \\infty\\) をとる．\n\\(M &gt; 0\\) のとき，\n\\(x = \\xi\\) において \\(\\Delta G \\leq 0\\). 故に\n\n\\(\\Delta x &gt; 0\\) とすれば \\(\\displaystyle\\frac{\\Delta G}{\\Delta x} \\leq 0\\), 従って，\\(G^\\prime(\\xi)\\leq 0\\)\n\\(\\Delta x &lt; 0\\) とすれば \\(\\displaystyle\\frac{\\Delta G}{\\Delta x} \\geq 0\\), 従って，\\(G^\\prime(\\xi)\\geq 0\\)\n\n従って，\\(G^\\prime(\\xi) = 0\\). \\(M = 0\\) のときは，同様に最小値 \\(G(\\xi) = M &gt; -\\infty\\) を考えると \\(G^\\prime(\\xi)\\geq 0\\) を得る．最小値と最大値が \\(0\\) の場合は \\(G(x)\\) が常に \\(0\\) であるので，\\(x \\in (a, b)\\) において \\(G^\\prime(x) = 0\\) は自明．\nこのとき，\\(F(x) - k = G(x)\\) より\n\\[\n\\begin{align}\nF^\\prime(\\xi) =  \\{g(b)-g(a)\\}f^\\prime(\\xi) - \\{f(b)-f(a)\\}g^\\prime(\\xi) = 0\n\\end{align}\n\\]\nよって，\n\\[\n\\frac{f(b) - f(a)}{g(b) - g(a)} = \\frac{f^\\prime(\\xi)}{g^\\prime(\\xi)}\n\\]\nが成立する．\n\n\n\n平均値の定理を幾何学的に考察してみます．独立変数 \\(t\\) について，曲線\n\\[\nx = f(t), y=g(t)\\qquad t \\in [a. b]\n\\]\nを考えます．このとき，\\(t=a, t=b\\) に対応する \\((x, y)\\) をそれぞれ \\(A, B\\) とすると，\\(\\eqref{eq-mean-value}\\) のLHSが弦ABの勾配に対応します． このとき，\\(x = f(t), y=g(t)\\) の曲線上のとある点 \\(P: t= \\xi\\) の接線が弦ABの勾配と平行になることを定理は示しています．\\(f^\\prime(x), g^\\prime(x)\\) は区間内で同時に \\(0\\) にならないと仮定は，曲線が各点において 確定の接線を有することを意味します．\n\nCode\ndef func_x(x):\n    return np.sin(x) + x\n\ndef func_y(x):\n    return x * np.log(x) ** 2\n\ndef tangent(x, x_0):\n    return func_y(x_0) + (x- func_x(x_0)) * (np.log(np.pi/2) ** 2.5)\n\n\nt = np.linspace(1e-18, np.pi/2, 1000)\nt2 = np.linspace(1.8, 2.6, 100)\nx, y = func_x(t), func_y(t)\nt_0 = 1.11\n\n# plot\nplt.plot(x, y, linewidth=2)\n\n# # add line\nplt.plot([0, func_x(np.pi/2)], [0, func_y(np.pi/2)], color=\"gray\")\nplt.text(-0.01, -0.03, \"A\")\nplt.text(2.55, 0.33, \"B\")\n\n# # add tangent\n# plt.text(x_0, sample_func(x_0)+1e-4, \"P: x = $\\exp(-2)$\")\nplt.scatter(func_x(t_0), func_y(t_0), color=\"gray\", linestyle=\"dotted\")\nplt.text(func_x(t_0), -0.02, \"P\")\nplt.plot(t2, tangent(t2, t_0))\n\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 1: \\(t\\in [0,\\pi/2]\\) 区間で定義された \\(x = \\sin(t) +t, y = \\begin{cases}t(\\log(t))^2  & (t\\in(0, \\pi/2))\\\\0 & t = 0\\end{cases}\\)\n\n\n\n\n\n\n\n\n\n🍵 Green Tea Break\n\n\n\n実数空間 \\(\\mathbb R\\) の部分集合 \\(I\\) で定義された関数 \\(f(x)\\) が区間 \\(I\\) の点 \\(a\\) において連続であるとは\n\\[\n\\lim_{x\\to a}f(x) = f(a)\n\\]\nが成り立つことをいいます．\n\\[\nf(t) = \\begin{cases}t(\\log(t))^2  & (t\\in(0, \\pi/2))\\\\0 & t = 0\\end{cases}\n\\]\nはロピタルの定理を用いると，\n\\[\n\\begin{align}\n\\lim_{t\\to 0} t(\\log(t))^2\n    &= \\lim_{t\\to 0} \\frac{(\\log(t))^2}{t^{-1}}\\\\\n    &= \\lim_{t\\to 0} \\frac{2(\\log(t))\\frac{1}{t}}{-t^{-2}}\\\\\n    &= \\lim_{t\\to 0} \\frac{2(\\log(t))}{-t^{-1}}\\\\\n    &= \\lim_{t\\to 0} \\frac{2t^{-1}}{t^{-2}}\\\\\n    &= \\lim_{t\\to 0} 2t = 0\n\\end{align}\n\\]\n以上のように連続性を示すことが出来ます．\n\n\n\nTaylorの公式\n\n\nTheorem 2 \nある区間において．\\(f(x)\\) は第 \\(n\\) 階まで微分可能とする．このときその区間において，\\(a\\) は定点，\\(x\\) を任意の点とするとき\n\\[\n\\begin{gather}\nf(x) = f(a) + \\frac{f^\\prime(a)}{1!}(x-a) + \\frac{f^{\\prime\\prime}(a)}{2!}(x-a)^2 + \\cdots + \\frac{f^{(n-1)}(a)}{(n-1)!}(x-a)^{n-1} + \\frac{f^{(n)}(\\xi)}{(n)!}(x-a)^{n}\\label{eq-taylor}\\\\\n\\text{s.t } \\quad \\xi = a + \\theta(x-a), \\qquad 0 &lt;\\theta&lt;1\n\\end{gather}\n\\]\n\n\n\\(\\frac{f^{(n)}(\\xi)}{(n)!}(x-a)^{n}\\) は \\(R_n\\) と表されることもあり，剰余項とよびます．\n\n\n\n\n\n\n\nProof\n\n\n\n\n\n\\[\nF(x) = f(x) - \\{f(a) + \\frac{f^\\prime(a)}{1!}(x-a) + \\frac{f^{\\prime\\prime}(a)}{2!}(x-a)^2 + \\cdots + \\frac{f^{(n-1)}(a)}{(n-1)!}(x-a)^{n-1}\\}\\label{eq-residual}\n\\]\nとおく．このとき，定義より\n\\[\nF(a) = F^{\\prime}(a) = F^{\\prime\\prime}(a) = \\cdots = F^{n-1}(a) = 0\n\\]\nここで，\n\\[\nG(x) = (x - a)^n\n\\]\nと定義すると第 \\(n\\) 階まで微分可能であり，また \\(G(a) = 0\\)．このとき，中間値の定理より\n\\[\n\\begin{align}\n\\frac{F(x) - F(a)}{G(x) - G(a)}\n    &= \\frac{F(x)}{G(x)}\\\\\n    &= \\frac{F(x)}{(x-a)^n}\\\\\n    &= \\frac{F^\\prime(x_1)}{n(x_1-a)^{n-1}} \\qquad x_1 \\in (a, x)\n\\end{align}\n\\]\n同様に\n\\[\n\\frac{F^\\prime(x_1)}{n(x_1-a)^{n-1}} = \\frac{F^{\\prime\\prime}(x_2)}{n(n-1)(x_2-a)^{n-2}} \\qquad x_2 \\in (a, x_1)\n\\]\n\\(f(x)\\) は第 \\(n\\) 階まで微分可能であるので，\\(F(x)\\) も第 \\(n\\) 階まで微分可能．従って，\n\\[\n\\frac{F(x)}{(x-1)^n} = \\frac{F^{n}(\\xi)}{n!} \\qquad \\exists\\xi \\in (a, x)\n\\]\nつまり\n\\[\nF(x) = \\frac{F^{n}(\\xi)}{n!}(x-a)^n\n\\]\nこれを \\(\\eqref{eq-residual}\\) に代入して整理すると \\(\\eqref{eq-taylor}\\) を得る．\n\n\n\n整式はそれ自身が有限個の項で完結したテイラー展開のしていますし，無限等比級数の公式\n\\[\n\\frac{1}{1 + r} = 1 - r + r^2 - r^3 + \\cdots = \\sum_{i=0}(-r)^i \\qquad (-1 &lt; r &lt; 1)\n\\]\nは \\(x = 1\\) 周りでの関数 \\(f(x) = 1/ x\\) のテイラー展開となっており，\\(x = 1 + r\\) とすると\n\\[\n\\begin{align}\n\\frac{1}{1+r}\n    &= 1 + \\frac{(-1)}{1!}r + \\frac{(-1)\\times(-2)}{2!}r^2 + \\frac{(-1)\\times(-2)\\times(-3)}{3!}r^3 + \\cdots\\\\\n    &= 1 - r + r^2 - r^3 + \\cdots\n\\end{align}\n\\]\nと確認することが出来ます．三角関数も\n\\[\n\\begin{align}\n\\cos x &= 1 - \\frac{1}{2}x^2 + \\frac{1}{24}x^4 - \\cdots\\\\\n\\sin x &= x - \\frac{1}{6}x^3 + \\frac{1}{120}x^5 - \\cdots\n\\end{align}\n\\]\nとテイラー展開することが出来ます．そのため，18世紀までの数学界では，関数は各点周りで冪級数にテイラー展開できるので，微分や積分もテイラー展開を応用して形式的な代数的計算で十分と考えられてました． 19世紀になると任意の関数 \\(f(x)\\) は\n\\[\nf(x) \\sim \\frac{a_0}{2} + \\sum_{n=1}^\\infty(a_n\\cos nx + b_n \\sin nx)\n\\]\nで表すことができるのではないか？という主張が登場し，関数，微分，積分の理論の見直しの必要性が認識されるようになりました．\n\nExample 1 : テイラー展開の例 \n次の関数の点 \\(a\\) のまわりのテイラー展開を剰余項を含めて \\(h^3\\) まで書き下すと以下のようになります\n\\[\n\\begin{align}\n\\log(a+h) &= \\log(a) + \\frac{h}{a} - \\frac{1}{2}\\frac{h^2}{a^2} + \\frac{1}{3}\\frac{h^3}{(a+\\theta h)^3}\\\\\n(a+h)^\\beta &= a^\\beta + \\beta a^{\\beta-1}h + \\frac{\\beta(\\beta-1)}{2!}a^{\\beta-2}h^2+ \\frac{\\beta(\\beta-1)(\\beta-2)}{3!}(a+\\theta h)^{\\beta-3}h^3\n\\end{align}\n\\]\nただし，\\(0 &lt; \\theta &lt; 1\\) とします．\n\n\n\nTaylor展開の応用: \\(e\\) が無理数であることの証明\n\\(f(x) = \\exp(x)\\) を マクローリン展開すると\n\\[\n\\exp(x) = 1 + \\frac{x}{1!} + \\frac{x^2}{2!} + \\frac{x^3}{3!} + \\cdots + \\frac{x^n}{n!} + R_{n+1}\n\\]\n\\(x = 1\\) としたとき，\n\\[\ne =  1 + \\frac{1}{1!} + \\frac{1}{2!} + \\frac{1}{3!} + \\cdots + \\frac{1}{n!} + R_{n+1}\n\\]\n剰余項 \\(R_{n+1}0\\) は\n\\[\nR_{n+1} = \\frac{\\exp(\\theta)}{(n+1)!} &gt; 0 \\quad \\exists\\theta \\in (0, 1)\n\\]\nつまり，\n\\[\nR_{n+1} = \\frac{\\exp(\\theta)}{(n+1)!} &lt; \\frac{3}{(n+1)!}\n\\]\nここで，\\(e\\) を有理数として \\(e = m/n\\) と既約分数で表せると仮定する．このとき，\\(n!e\\) は仮定より整数となるので\n\\[\n1 \\leq n!R_{n+1} = \\frac{\\exp(\\theta)}{n+1} &lt; \\frac{3}{n+1}\n\\]\n従って，\\(n+1 &lt;3\\) つまり \\(n &lt; 2\\)，従って，\\(n = 1\\) を得る．このとき，\\(m\\) は整数なので \\(e = m\\) となるが \\(2 &lt; e &lt; 3\\) より矛盾．従って，\\(e\\) は無理数となる．"
  },
  {
    "objectID": "posts/2025-01-29-set-and-topology-series/index.html",
    "href": "posts/2025-01-29-set-and-topology-series/index.html",
    "title": "フーリエ級数と積分理論再考",
    "section": "",
    "text": "フーリエが熱伝導方程式の解をどのように求めたのか？\nどのような流れで積分の定義の再考につながったのか？\n\nを紹介します．"
  },
  {
    "objectID": "posts/2025-01-29-set-and-topology-series/index.html#このノートのスコープ",
    "href": "posts/2025-01-29-set-and-topology-series/index.html#このノートのスコープ",
    "title": "フーリエ級数と積分理論再考",
    "section": "",
    "text": "フーリエが熱伝導方程式の解をどのように求めたのか？\nどのような流れで積分の定義の再考につながったのか？\n\nを紹介します．"
  },
  {
    "objectID": "posts/2025-01-29-set-and-topology-series/index.html#熱伝導方程式",
    "href": "posts/2025-01-29-set-and-topology-series/index.html#熱伝導方程式",
    "title": "フーリエ級数と積分理論再考",
    "section": "熱伝導方程式",
    "text": "熱伝導方程式\n物体内に温度勾配が存在すると，高温部から低温部へ熱伝導（Heat conduction）により熱エネルギーが伝わります．\n\n\n\n\n\n\nFigure 1: 長さ\\(\\pi\\)の密度が一様な棒\n\n\n\nFigure 1 のような細長い密度が一定の棒が与えられたとします．\n\n左端を 0 として，ある点の位置を左端からの距離 \\(x\\) で表す\nある点 \\(x\\) における時刻 \\(t\\) での温度を \\(T(x, t)\\) で表す\n単位断面積を単位時間に通過する熱エネルギーを \\(q(x, t)\\) とする(=熱流密度)\n\nフーリエの法則より，熱流密度 \\(q(x, t)\\) は温度勾配 \\(\\displaystyle{\\frac{\\partial T(x, t)}{\\partial x}}\\) に比例するので\n\\[\nq(x, t) = -\\lambda \\frac{\\partial T(x, t)}{\\partial x} \\label{eq-fourier-law}\n\\]\n\n\\(\\lambda  &gt; 0\\): 熱伝導率，RHSに符号マイナスがついているのは，高温から低音へ熱が流れることを表してる\n熱伝導率: 物質によって定まる物性値, 熱伝導率が大きいと熱エネルギーがよく伝わり，熱伝導率が小さいと熱エネルギーを伝えにくい\n\n\\(\\eqref{eq-fourier-law}\\) で表される熱の流入から，比熱 \\(c &gt; 0\\), 密度 \\(\\rho  &gt; 0\\) を用いると温度変化 \\(\\Delta T(x, t)\\) は熱の流入と流出２要素から以下のように表されます\n\\[\n\\begin{align}\n\\Delta T(x, t) &= \\frac{1}{c\\rho\\Delta x}(q(x, t) - q(x + \\Delta x, t))\\Delta t\\\\\n\\Rightarrow \\frac{\\Delta T(x, t)}{\\Delta t} &= \\frac{1}{c\\rho\\Delta x}(q(x, t) - q(x + \\Delta x, t))\n\\end{align}\n\\]\nここで，\\(\\Delta t\\to 0, \\Delta x\\to 0\\) とすると\n\\[\n\\frac{\\partial T(x, t)}{\\partial t} = -\\frac{1}{c\\rho}\\frac{\\partial q(x, t)}{\\partial x} \\label{eq-heat-balance}\n\\]\n\\(\\eqref{eq-fourier-law}\\), \\(\\eqref{eq-heat-balance}\\) より\n\\[\n\\begin{align}\n\\frac{\\partial T(x, t)}{\\partial t}\n    &= -\\frac{1}{c\\rho}\\frac{\\partial}{\\partial x}\\left(-\\lambda \\frac{\\partial T(x, t)}{\\partial x} \\right)\\\\\n    &= \\frac{\\lambda}{c\\rho}\\frac{\\partial^2 T(x, t)}{\\partial x^2} \\label{eq-hce}\n\\end{align}\n\\tag{1}\\]\nこれを熱伝導方程式と呼びます．\\(\\displaystyle\\frac{\\lambda}{c\\rho}\\) は温度伝導率（温度拡散率）と呼ばれます．\n\n\n\n\n\n\n🍵 Green Tea Break: 比熱\n\n\n\n\n比熱とは 1kg の物質の温度を 1K （＝1℃）上げるのに必要な熱量のこと\n「温まりやすさ」 「冷めにくさ」 を表す物理量と理解できる\n\n例えば，水1kgの場合，1K 上げるのに必要な熱量は4186J"
  },
  {
    "objectID": "posts/2025-01-29-set-and-topology-series/index.html#熱伝導方程式とフーリエ級数",
    "href": "posts/2025-01-29-set-and-topology-series/index.html#熱伝導方程式とフーリエ級数",
    "title": "フーリエ級数と積分理論再考",
    "section": "熱伝導方程式とフーリエ級数",
    "text": "熱伝導方程式とフーリエ級数\n\n方程式: 熱伝導方程式\n境界条件: 棒の両端の温度を 0 に保つ\n初期条件: 初期状態(\\(t=0\\))における位置 \\(x\\) の温度が \\(f(x)\\) で与えられている\n\nという設定の下，温度 \\(T\\) の時間変化を求める問題を考えます．\n ▶  境界条件\n\\[\nT(0, t) = T(\\pi, t) = 0 \\qquad (t\\geq 0) \\label{eq-boundary}\n\\]\n ▶  初期条件\n\\[\nT(x, 0) = f(x) \\qquad (0 \\leq x \\leq \\pi) \\label{eq-init}\n\\]\n\n ▶  重ね合わせの原理\n熱伝導方程式は次のような性質があります\n\n\\(T_1, T_2\\) が \\(\\eqref{eq-hce}\\), \\(\\eqref{eq-boundary}\\) を満たすとき，\\(T_1 + T_2\\) も\\(\\eqref{eq-hce}\\), \\(\\eqref{eq-boundary}\\) を満たす\n\\(T\\) が \\(\\eqref{eq-hce}\\), \\(\\eqref{eq-boundary}\\) を満たすとき，その任意の定数倍 \\(kT\\) も\\(\\eqref{eq-hce}\\), \\(\\eqref{eq-boundary}\\) を満たす\n\nこれを重ね合わせの原理と呼びます．\n\n温度 \\(T\\) の時間変化を求める問題を解くにあたって，フーリエは重ね合わせの原理を活用して\n\n\\(\\eqref{eq-hce}\\), \\(\\eqref{eq-boundary}\\) を満たす関数の条件のうち，なるべく簡単な形のものを求める\n得られた簡単な形の関数を足し合わせることで，初期条件 \\(\\eqref{eq-init}\\) を満たす関数を作る\n\nという二段構えで解くことを考えました．簡単な形の関数としてフーリエが考えたのは変数分離型の関数です．\n\n変数分離\n変数分離型関数とは，位置 \\(x\\) 飲みの関数 \\(v(x)\\) と時刻 \\(t\\) のみの関数 \\(w(t)\\) の積\n\\[\nT(x, t) = v(x)w(t)\n\\]\nの形で表させる関数のことです．変数分離型を仮定すると熱伝導方程式は常微分方程式を用いて以下のように表せます\n\\[\n\\begin{align}\n\\frac{c\\rho}{\\lambda}\\frac{w^\\prime(t)}{w(t)} = \\frac{v^{\\prime\\prime}(x)}{v(x)}\n\\end{align}\n\\]\nLHSは\\(t\\)のみの関数，RHSは\\(x\\)飲みの関数であるので，方程式が恒等的に成り立つためには，両辺は定数でなければなりません．定数を \\(k\\) と表すと\n\\[\n\\begin{align}\nw^\\prime(t) &= k Aw(t)\\\\\nv^{\\prime\\prime}(t) &= k v(x)\n\\end{align}\n\\]\nなお \\(A = \\displaystyle\\frac{\\lambda}{c\\rho}\\) としています．\n ▶  \\(w(t)\\) について解く\n\\[\n\\begin{align}\n\\frac{dw(t)}{w(t)} &= k A dt\\\\\n\\int \\frac{dw(t)}{w(t)}dt &= \\int k A dt \\label{eq-cond}\\\\\n\\log(\\vert w(t)\\vert) &= k A t + C \\qquad (C\\text{: constant})\\\\\nw(t) &= \\alpha \\exp(k At)\\qquad (\\alpha = \\exp(C))\n\\end{align}\n\\]\n従って，\n\\[\n\\begin{align}\nw(t) = \\left\\{\\begin{array}{c}\n\\alpha\\exp(kAt) & (k \\neq 0)\\\\\n\\alpha & (k = 0)\n\\end{array}\\right.\n\\end{align}\n\\]\n ▶  \\(v(x)\\) について解く\n2次線形微分方程式において，\\(p, q\\) が定数のとき\n\\[\ny^{\\prime\\prime} + py^{\\prime} + q = 0\n\\]\nの一般解は特定方程式 \\(a^2 + pa + q =0\\) の解によって以下のように定まります\ncase 1: ２つの実数解 \\(\\hat a_1, \\hat a_2\\) を持つ場合\n\\[\ny = A\\exp(\\hat a_1 x) + B\\exp(\\hat a_2 x)\n\\]\ncase 2: ２つの虚数解 \\(\\hat a \\pm \\hat b i\\) を持つ場合\n\\[\ny = \\exp(\\hat a x)(A\\cos(\\hat b x) + B \\sin(\\hat b x))\n\\]\ncase 3: 重解 \\(\\hat a\\) を持つ場合\n\\[\ny = (Ax + B)\\exp(\\hat a x)\n\\]\n以上より，\n\\[\n\\begin{align}\nv(x) = \\left\\{\\begin{array}{c}\n\\beta \\exp(\\sqrt{k}x) + \\gamma \\exp(-\\sqrt{k}x) & \\text{if } k &gt; 0\\\\\n\\beta x + \\gamma & \\text{if } k = 0 \\\\\n\\beta\\cos(\\sqrt{\\vert k\\vert}x) + \\gamma\\sin(\\sqrt{\\vert k\\vert}x) & \\text{if } k &lt;0\n\\end{array}\\right.\n\\end{align}\n\\]\n境界条件および初期条件を満たすように係数 \\(\\alpha, \\beta, \\gamma\\) を定めれば，解が求まることになります．\n\n\nフーリエ級数の登場\n ▶  \\(k &gt; 0\\) のケース\n\\(\\eqref{eq-cond}\\) より，時間の経過とともに温度が無限大に大きくなることはないので \\(k&gt; 0\\) はありえないことが直感的に分かりますが，\\(k&gt; 0\\) と仮定したとき 境界条件を満たす \\(\\alpha, \\beta, \\gamma\\) が存在しないことを確認します．\n\\[\n\\begin{align}\nw(t) &= \\alpha\\exp(kAt) \\\\\nv(x) &= \\beta \\exp(\\sqrt{k}x) + \\gamma \\exp(-\\sqrt{k}x)\n\\end{align}\n\\]\n境界条件より\n\\[\n\\begin{align}\nv(0) &= \\beta + \\gamma = 0\\\\\nv(\\pi) &= \\beta\\exp(\\sqrt{k}\\pi) + \\gamma\\exp(-\\sqrt{k}\\pi) = 0\n\\end{align}\n\\]\nここから\n\\[\n\\beta(\\exp(\\sqrt{k}\\pi) - \\exp(-\\sqrt{k}\\pi)) = 0\n\\]\n従って，\n\\[\n\\begin{align}\n&\\beta = \\gamma = 0\\\\\n\\Rightarrow& v(x) =  0\n\\end{align}\n\\]\nこれは \\(f(x) = 0 \\ \\ \\forall x \\in [0, \\pi]\\) 以外の場合は初期条件を満たすことがない．\n ▶  \\(k = 0\\) のケース\n\\[\n\\begin{align}\nw(t) &= \\alpha\\\\\nv(x) &= \\beta x + \\gamma\n\\end{align}\n\\]\n境界条件を満たすためには \\(\\beta = \\gamma = 0\\) が必要になるが，\\(f(x) = 0 \\ \\ \\forall x \\in [0, \\pi]\\) 以外の場合は初期条件を満たすことがない．\n ▶  \\(k &lt; 0\\) のケース\n\\[\n\\begin{align}\nw(t) &= \\alpha\\exp(kAt) \\\\\nv(x) &= \\beta\\cos(\\sqrt{\\vert k\\vert}x) + \\gamma\\sin(\\sqrt{\\vert k\\vert}x)\n\\end{align}\n\\]\n境界条件より\n\\[\n\\begin{align}\n\\beta &= 0\\\\\n\\gamma\\sin(\\sqrt{\\vert k\\vert}\\pi) &= 0\n\\end{align}\n\\]\n\\(\\gamma= 0\\) だと初期条件を満たすことができないので，\\(\\gamma \\neq 0\\). このとき，\\(\\sqrt{\\vert k\\vert} \\in \\mathbb Z\\) が解の必要条件となることが分かる． ここで，\\(k = -n^2\\) と書き直すと\n\\[\n\\begin{align}\nT(x, t) = \\alpha\\exp(-n^2At) \\cdot \\gamma\\sin(n\\pi) \\label{eq-sol-candidate}\n\\end{align}\n\\]\nが境界条件を満たす変数分離型の解となるとこが分かります．重ね合わせの原理より \\(\\eqref{eq-sol-candidate}\\) の定数倍も境界条件と熱伝導方程式を満たす関数となります．\n重ね合わせの原理より \\(1 \\leq n \\leq N\\) の範囲で\n\\[\n\\sum_{n=1}^N a_n \\alpha\\exp(-n^2At) \\cdot \\gamma\\sin(n\\pi)\n\\]\nも境界条件と熱伝導方程式を満たす関数となります．ここでフーリエは次のような主張をしました：\n\n\\[\n\\sum_{n=1}^\\infty a_n \\alpha\\exp(-n^2At) \\cdot \\gamma\\sin(n\\pi)\n\\]\nも境界条件と熱伝導方程式を満たす関数となりえる\n\nここから初期条件を満たす関数を求めたいので, \\(t=0\\) とすると\n\\[\nf(x) = \\sum_{n=1}^\\infty b_n \\sin(n\\pi)\n\\]\nが成り立つように \\(\\{b_n\\}_{n=1}^\\infty\\) を定めれば良いとなります．このとき，正弦関数の積の積分公式\n\\[\n\\begin{align}\n\\int^{\\pi}_0\\sin nx \\sin mx dx =\\begin{cases}\n\\displaystyle 0 & (m\\neq n)\\\\[4pt]\n\\displaystyle \\frac{\\pi}{2} & (m = n)\n\\end{cases}\n\\end{align}\n\\]\n従って，\n\\[\n\\begin{align}\n\\int^{\\pi}_0f(x)\\sin mx\\ dx\n& = \\int^\\pi_0 \\sum_{n=1}^\\infty b_n \\sin(n\\pi) \\sin(m\\pi) dx\\\\\n&= \\sum_{n=1}^\\infty \\int^\\pi_0b_n \\sin(n\\pi) \\sin(m\\pi) dx\\\\\n&= \\frac{\\pi}{2}b_m\n\\end{align}\n\\]\nとなり，\n\\[\nb_n = \\frac{2}{\\pi}\\int^{\\pi}_0f(x)\\sin nx \\ dx\n\\]\nこのように求めた級数関数が変数分離型を仮定したときの熱伝導方程式の解となりうるとフーリエは主張しました． これがフーリエ級数の誕生です.\n\n\nフーリエ級数の問題点と積分理論再考へ\nフーリエ級数が登場初期には以下のような批判にさらされました:\n\nフーリエ級数が収束する保証はどこにあるのか？\n\\(0\\)から\\(\\pi\\)までの特定の一個の\\(x\\)について\\(f(x)\\)の値を変更しても積分の値には影響しないので異なる関数が同じフーリエ級数で表現されてしまうのではないか？\n無限級数の項別積分(無限和と積分の順序交換)ができる保証はどこにあるのか？\n\n無限和と積分の順序交換の批判とは，仮に熱分布関数\\(T(x, t)\\)がフーリエ級数の形式で表せることができたとしても\n\\[\n\\begin{align*}\n&\\int^\\pi_{-\\pi}\\sum_{k=1}^\\infty (a_k \\cos kx + b_k \\sin kx)\\cos nx\\ dx \\\\\n&=\\sum_{k=1}^\\infty \\left(a_k \\int^\\pi_{-\\pi}\\cos kx \\cos nx\\ dx + b_k \\int^\\pi_{-\\pi}\\sin kx \\cos nx\\ dx\\right)\n\\end{align*}\n\\]\nができる保証がないというものです. これはフーリエ級数のそれ自体の問題というよりかは\n\nどんな関数が積分可能か？\nどのようなときに項別積分ができるのか？\n\nという積分の定義・理論の問題です．フーリエの時代では積分の理論が十分なものではなく，微分の逆として積分が捉えられており，上記の問題に答えることができませんでした． 以上が，熱の変化という自然科学現象の解明のため提案されたフーリエ級数が数学理論，特に積分理論の再整備の必要性を促した流れとなります．"
  },
  {
    "objectID": "posts/2025-01-29-set-and-topology-series/index.html#appendix-正弦関数の積の積分公式の証明",
    "href": "posts/2025-01-29-set-and-topology-series/index.html#appendix-正弦関数の積の積分公式の証明",
    "title": "フーリエ級数と積分理論再考",
    "section": "Appendix: 正弦関数の積の積分公式の証明",
    "text": "Appendix: 正弦関数の積の積分公式の証明\n\n\nExercise 1 \n\\(n,k\\)をそれぞれ自然数としたとき\n\\[\n\\begin{align}\n\\int^{\\pi}_0\\sin nx \\sin kx dx =\\begin{cases}\n\\displaystyle 0 & (k\\neq n)\\\\[4pt]\n\\displaystyle \\frac{\\pi}{2} & (k = n)\n\\end{cases}\n\\end{align}\n\\]\n\n\n\n\n\n\n\n\n\nProof\n\n\n\n\n\n積和の公式より\n\\[\n\\sin \\alpha\\sin \\beta=-\\frac{1}{2} \\left\\{\\cos(\\alpha+\\beta)-\\cos(\\alpha-\\beta)\\right\\}\n\\]\nこの積和の公式を用いると\n\\[\n\\begin{align}\n&\\int^{\\pi}_0\\sin nx \\sin kx\\ dx \\\\\n&= -\\frac{1}{2}\\int^{\\pi}_0 \\left\\{\\cos(n+k)x-\\cos(n-k)x\\right\\} dx \\\\\n&= -\\frac{1}{2}\\left\\{\\int^{\\pi}_0\\cos(n+k)x\\ dx- \\int^{\\pi}_0\\cos(n-k)x\\ dx\\right\\}\n\\end{align}\n\\]\nつぎに以下のケースを考えます\n\n\\(n=k\\)のとき\n\\(n\\neq k\\)のとき\n\n\n\\(n=k\\)のとき\n\n\\[\n-\\frac{1}{2}\\left\\{\\int^{\\pi}_0\\cos(n+k)x\\ dx- \\int^{\\pi}_0\\cos(n-k)x\\ dx\\right\\}\n\\]\nの第二項は\\(\\pi\\)となる一方, 第一項は\n\\[\n\\begin{align}\n\\int^{\\pi}_0\\cos(n+k)x dx &= -\\left[\\sin(n+k)x\\right]^{\\pi}_0\\\\\n&= 0\n\\end{align}\n\\]\n従って,\n\\[\n-\\frac{1}{2}\\left\\{\\int^{\\pi}_0\\cos(n+k)x\\ dx- \\int^{\\pi}_0\\cos(n-k)x\\ dx\\right\\} = \\frac{\\pi}{2}\n\\]\n\n\\(n\\neq k\\)のとき\n\n\\[\n\\begin{align}\n\\int^{\\pi}_0\\cos(n-k)x\\ dx &= -\\left[\\sin(n-k)x\\right]^{\\pi}_0 = 0\\\\[3pt]\n\\int^{\\pi}_0\\cos(n+k)x\\ dx &= -\\left[\\sin(n+k)x\\right]^{\\pi}_0 = 0\n\\end{align}\n\\]\nより\n\\[\n-\\frac{1}{2}\\left\\{\\int^{\\pi}_0\\cos(n+k)x\\ dx- \\int^{\\pi}_0\\cos(n-k)x\\ dx\\right\\} = 0\n\\]"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Regmonkey Datascience Blog",
    "section": "",
    "text": "徒然日記\n\n\n    \n      \n      \n    \n\n\n\n\n\nDate\n\n\nTitle\n\n\nCategories\n\n\nReading Time\n\n\n\n\n\n\n2025-03-05\n\n\n三角関数の加法定理\n\n\n三角関数\n\n\n7 min\n\n\n\n\n2025-03-03\n\n\nいろいろな三角不等式\n\n\n複素数, 幾何, ベクトル\n\n\n4 min\n\n\n\n\n2025-03-02\n\n\n敵の砲台の座標を探せ 1/N\n\n\n幾何\n\n\n9 min\n\n\n\n\n2025-03-01\n\n\nヘロンの公式の導出\n\n\n幾何\n\n\n2 min\n\n\n\n\n2025-02-28\n\n\nカバリエリの原理\n\n\n幾何\n\n\n14 min\n\n\n\n\n2025-02-27\n\n\ntangent 75°の図形的計算\n\n\n三角関数\n\n\n2 min\n\n\n\n\n2025-02-26\n\n\n余弦定理の考え方\n\n\n三角関数\n\n\n5 min\n\n\n\n\n2025-02-25\n\n\n正弦定理の考え方\n\n\n三角関数\n\n\n7 min\n\n\n\n\n2025-02-19\n\n\nGroup毎に定義されたラグ変数の作成\n\n\npython\n\n\n9 min\n\n\n\n\n2025-02-14\n\n\n本日の詰将棋: Quiz 1~5\n\n\n将棋\n\n\n1 min\n\n\n\n\n2025-02-13\n\n\n複素平面と複素数による回転\n\n\n複素数\n\n\n12 min\n\n\n\n\n2025-02-05\n\n\n測量法における測量の分類\n\n\n測量\n\n\n1 min\n\n\n\n\n2025-02-04\n\n\n単曲線と追加距離の計算\n\n\n三角関数, 測量\n\n\n4 min\n\n\n\n\n2025-02-03\n\n\n関数の連続性\n\n\n解析\n\n\n7 min\n\n\n\n\n2025-02-02\n\n\n有限個の多項式のテイラー展開\n\n\n解析\n\n\n4 min\n\n\n\n\n2025-02-01\n\n\n18世紀までの関数論とテイラー展開\n\n\n解析\n\n\n5 min\n\n\n\n\n2025-01-30\n\n\n微分方程式を用いたToy models\n\n\n微分方程式\n\n\n5 min\n\n\n\n\n2025-01-29\n\n\nフーリエ級数と積分理論再考\n\n\nフーリエ変換\n\n\n4 min\n\n\n\n\n2025-01-28\n\n\n数理モデルの作り方\n\n\n方法論\n\n\n1 min\n\n\n\n\n2025-01-27\n\n\n指数関数の微分\n\n\n解析\n\n\n2 min\n\n\n\n\n2025-01-08\n\n\nBigQuery: TIME型カラムを指定したレベルで丸めて集計する\n\n\nsql\n\n\n2 min\n\n\n\n\n2024-12-18\n\n\nSecure Shellの仕組み\n\n\nssh\n\n\n5 min\n\n\n\n\n2024-12-17\n\n\nFirefoxを用いたsocks5 proxyブラウザアクセス設定\n\n\nfirefox, network\n\n\n2 min\n\n\n\n\n2024-12-16\n\n\nmacOSへのssh接続\n\n\nssh\n\n\n1 min\n\n\n\n\n2024-12-11\n\n\nCloud StorageからExternal Tableの作成\n\n\nBigQuery\n\n\n2 min\n\n\n\n\n2024-12-07\n\n\nIPアドレス 0.0.0.0\n\n\nnetwork, quarto\n\n\n3 min\n\n\n\n\n\nNo matching items\n\n\n  \n\n\n\n\n    \n      \n      \n    \n\n\n\n\n\nDate\n\n\nTitle\n\n\nCategories\n\n\nReading Time\n\n\n\n\n\n\n2025-02-14\n\n\n本日の詰将棋: Quiz 1~5\n\n\n将棋\n\n\n1 min\n\n\n\n\n2025-02-05\n\n\n測量法における測量の分類\n\n\n測量\n\n\n1 min\n\n\n\n\n2025-02-04\n\n\n単曲線と追加距離の計算\n\n\n三角関数, 測量\n\n\n4 min\n\n\n\n\n\nNo matching items\n\n\n\n\nDatascience\n\nGeneral\n\n\n    \n      \n      \n    \n\n\n\n\n\nDate\n\n\nTitle\n\n\nCategories\n\n\nReading Time\n\n\n\n\n\n\n2025-03-02\n\n\n敵の砲台の座標を探せ 1/N\n\n\n幾何\n\n\n9 min\n\n\n\n\n\nNo matching items\n\n\n\n\n前処理\n\n\n    \n      \n      \n    \n\n\n\n\n\nDate\n\n\nTitle\n\n\nCategories\n\n\nReading Time\n\n\n\n\n\n\n2025-02-19\n\n\nGroup毎に定義されたラグ変数の作成\n\n\npython\n\n\n9 min\n\n\n\n\n\nNo matching items\n\n\n\n\n\n数学\n\nGeneral\n\n\n    \n      \n      \n    \n\n\n\n\n\nDate\n\n\nTitle\n\n\nCategories\n\n\nReading Time\n\n\n\n\n\n\n2025-03-05\n\n\n三角関数の加法定理\n\n\n三角関数\n\n\n7 min\n\n\n\n\n2025-03-03\n\n\nいろいろな三角不等式\n\n\n複素数, 幾何, ベクトル\n\n\n4 min\n\n\n\n\n2025-03-01\n\n\nヘロンの公式の導出\n\n\n幾何\n\n\n2 min\n\n\n\n\n2025-02-28\n\n\nカバリエリの原理\n\n\n幾何\n\n\n14 min\n\n\n\n\n2025-02-27\n\n\ntangent 75°の図形的計算\n\n\n三角関数\n\n\n2 min\n\n\n\n\n2025-02-26\n\n\n余弦定理の考え方\n\n\n三角関数\n\n\n5 min\n\n\n\n\n2025-02-25\n\n\n正弦定理の考え方\n\n\n三角関数\n\n\n7 min\n\n\n\n\n2025-02-02\n\n\n有限個の多項式のテイラー展開\n\n\n解析\n\n\n4 min\n\n\n\n\n2025-01-30\n\n\n微分方程式を用いたToy models\n\n\n微分方程式\n\n\n5 min\n\n\n\n\n2025-01-28\n\n\n数理モデルの作り方\n\n\n方法論\n\n\n1 min\n\n\n\n\n2025-01-27\n\n\n指数関数の微分\n\n\n解析\n\n\n2 min\n\n\n\n\n\nNo matching items\n\n\n  \n\n\n\n\n集合と位相 Series\n\n\n    \n      \n      \n    \n\n\n\n\n\nDate\n\n\nTitle\n\n\nCategories\n\n\nReading Time\n\n\n\n\n\n\n2025-02-03\n\n\n関数の連続性\n\n\n解析\n\n\n7 min\n\n\n\n\n2025-02-01\n\n\n18世紀までの関数論とテイラー展開\n\n\n解析\n\n\n5 min\n\n\n\n\n2025-01-29\n\n\nフーリエ級数と積分理論再考\n\n\nフーリエ変換\n\n\n4 min\n\n\n\n\n\nNo matching items\n\n\n\n\n複素解析 Series\n\n\n    \n      \n      \n    \n\n\n\n\n\nDate\n\n\nTitle\n\n\nCategories\n\n\nReading Time\n\n\n\n\n\n\n2025-02-13\n\n\n複素平面と複素数による回転\n\n\n複素数\n\n\n12 min\n\n\n\n\n\nNo matching items\n\n\n\n\n\n開発スキル\n\n\n    \n      \n      \n    \n\n\n\n\n\nDate\n\n\nTitle\n\n\nCategories\n\n\nReading Time\n\n\n\n\n\n\n2024-12-18\n\n\nSecure Shellの仕組み\n\n\nssh\n\n\n5 min\n\n\n\n\n2024-12-16\n\n\nmacOSへのssh接続\n\n\nssh\n\n\n1 min\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "某経済学研究科修士取得後，どこかのデータサイエンス（コンサル）会社に勤務してます． Arsenalが好きです．"
  },
  {
    "objectID": "posts/2025-02-02-taylor-expansion-and-polynomial/index.html",
    "href": "posts/2025-02-02-taylor-expansion-and-polynomial/index.html",
    "title": "有限個の多項式のテイラー展開",
    "section": "",
    "text": "\\(y = f(x)\\) の導関数を \\(f^\\prime(x)\\) とするとき，第二階の導関数を \\(f^{\\prime\\prime}(x)\\) と表記し，第 \\(n\\) 階の導関数を \\(f^{(n)}(x)\\) と表記します． 一点 \\(x\\) において\n\\[\n\\begin{gather}\nf^{\\prime\\prime}(x) = \\frac{d}{dx}\\left(\\frac{dy}{dx}\\right) = \\frac{d^2y}{dx^2}\\\\\nf^{(n)}(x) = \\frac{d^ny}{dx^n}\n\\end{gather}\n\\]\nとなります．\n ▶  記号の差異: \\(d^2y\\) vs \\(dx^2\\)\n\\(d^2y = d(dy)\\)，\\(dx^2 = (dx)^2\\) の意味で，この意味の差異を表現するため記号でも表記が異なっています．微分記号を用いて\n\\[\ndy = f^\\prime(x)dx\n\\]\nと書くとき，両辺の微分を取れば，\n\\[\n\\begin{align}\nd(dy) &= \\frac{d(f^{\\prime}(x))}{dx}(dx)^2 + f^\\prime(x)\\frac{d(dx)}{dx}dx\\\\\n      &= f^{\\prime\\prime}(x)(dx)^2 + f^\\prime(x)d(dx) \\label{eq-second-diff}\n\\end{align}\n\\]\n\\(x\\) が独立変数であるならば \\(dx\\) は \\(x\\) の水準関係なく自由に取れるので，\\(\\frac{d(dx)}{dx} = 0\\)．従って，\n\\[\nd^2y = f^{\\prime\\prime}(x)dx^2\n\\]\nとなります．もし，\\(x = \\varphi(t)\\) であるならば，\\(d^2x = \\varphi^{\\prime\\prime}(t)dt^2\\) となるので\n\\[\n\\frac{d}{dt^2}f(\\varphi(t)) = f^{\\prime\\prime}(\\varphi(t))(\\varphi^\\prime(t))^2 + f^\\prime(\\varphi(t))\\varphi^{\\prime\\prime}(t)\n\\]\n\n\n\n\nTheorem 1 : ライプニッツの公式(Leibniz rule) \n\\(u, v\\) が \\(x\\) の関数であるとき，\n\\[\n\\begin{align}\n\\frac{d^n(uv)}{dx^n}\n    &= u^{(n)}v + \\left(\\begin{array}{c}n\\\\1\\end{array}\\right)u^{(n-1)}v^{\\prime} + \\left(\\begin{array}{c}n\\\\2\\end{array}\\right)u^{(n-2)}v^{\\prime\\prime}+\\cdots+ \\left(\\begin{array}{c}n\\\\n-1\\end{array}\\right)u^{\\prime}v^{(n-1)} +uv^{(n)}\\\\\n    &= \\sum_{k=0}^n \\left(\\begin{array}{c}n\\\\ k\\end{array}\\right)u^{(n-k)}v^{(k)}\n\\end{align}\n\\]\n\n\n\n\n\n\n\n\n\nProof\n\n\n\n\n\n\\(n=1\\) のときは，積の微分公式より\n\\[\n\\frac{d(uv)}{dx^n} = \\frac{du}{dx}v + \\frac{dv}{dx}u\n\\]\n\\(n\\geq 2\\) については，帰納法を用いて示す．\\(n=t\\) のときライプニッツの公式が成立すると仮定する．\nこのとき，\n\\[\n\\begin{align}\n\\frac{d^{(t+1)}(uv)}{dx^{t+1}}\n    &= \\frac{d}{dt}\\left(\\frac{d^{(t)}(uv)}{dx^{t}}\\right)\\\\\n    &= \\frac{d}{dt}\\left(\\sum_{k=0}^t \\left(\\begin{array}{c}t\\\\ k\\end{array}\\right)u^{(t-k)}v^{(k)}\\right)\\\\\n    &= \\sum_{k=0}^t \\left(\\begin{array}{c}t\\\\ k\\end{array}\\right)[u^{(t-k+1)}v^{(k)} + u^{(t-k)}v^{(k+1)}]\\\\\n    &= \\sum_{k=0}^t \\left(\\begin{array}{c}t\\\\ k\\end{array}\\right)u^{(t-k+1)}v^{(k)} + \\sum_{k=0}^t \\left(\\begin{array}{c}t\\\\ k\\end{array}\\right)u^{(t-k)}v^{(k+1)}\\\\\n    &= \\left\\{u^{(t+1)}v + \\sum_{k=1}^t \\left(\\begin{array}{c}t\\\\ k\\end{array}\\right)u^{(t-k+1)}v^{(k)}\\right\\}+ \\left\\{uv^{(t+1)} + \\sum_{k=0}^{t-1} \\left(\\begin{array}{c}t\\\\ k\\end{array}\\right)u^{(t-k)}v^{(k+1)}\\right\\}\\\\\n    &= \\left\\{u^{(t+1)}v + \\sum_{k=1}^t \\left(\\begin{array}{c}t\\\\ k\\end{array}\\right)u^{(t-k+1)}v^{(k)}\\right\\}+ \\left\\{uv^{(t+1)} + \\sum_{j=1}^{t} \\left(\\begin{array}{c}t\\\\ j-1\\end{array}\\right)u^{(t-j+1)}v^{j}\\right\\}\\\\\n    &= u^{(t+1)}v + uv^{(t+1)} + \\sum_{k=1}^t \\left\\{\\left(\\begin{array}{c}t\\\\ k\\end{array}\\right) + \\left(\\begin{array}{c}t\\\\ k-1\\end{array}\\right)\\right\\}u^{(t-k+1)}v^{(k)}\\\\\n    &= u^{(t+1)}v + uv^{(t+1)} + \\sum_{k=1}^t \\left(\\begin{array}{c}t+1\\\\ k\\end{array}\\right)u^{(t+1-k)}v^{(k)}\\\\\n    &= \\sum_{k=0}^{t+1} \\left(\\begin{array}{c}t+1\\\\ k\\end{array}\\right)u^{(t+1-k)}v^{(k)}\n\\end{align}\n\\]\nとなり，\\(n = t + 1\\) の場合のライプニッツの公式の成立が確かめられた．\n\n\n\n\nExample 1 \n\\(y = x^2\\sin(x)\\) について \\(n\\) 階導関数を求めめたいとします．\n\\[\n(\\sin x)^{(k)} = \\sin\\left(x + \\frac{\\pi}{2}k\\right)\n\\]\nであるので\n\\(n=1\\) のときは\n\\[\ny^\\prime = x^2\\sin\\left(x + \\frac{\\pi}{2}\\right) + 2x\\sin(x)\n\\]\n\\(n\\geq 2\\) のときは，\\(x^2\\) が2回微分可能であることを考慮してライプニッツルールを利用すると\n\\[\n\\begin{align}\n\\frac{d^n}{dx^{n}}(x^2\\sin x)\n    &= x^2(\\sin(x))^{(n)} + 2nx(\\sin(x))^{(n-1)} + n(n-1)(\\sin(x))^{(n-2)}\\\\\n    &= x^2\\sin\\left(x + \\frac{\\pi}{2}n\\right) + 2nx\\sin\\left(x + \\frac{\\pi}{2}(n-1)\\right) + n(n-1)\\sin\\left(x + \\frac{\\pi}{2}(n-2)\\right)   \n\\end{align}\n\\]\n\n\n\nExample 2 \n\\[\n\\begin{align}\n(x\\sin x)^{(n)} = x\\sin\\left(x + \\frac{\\pi}{2}n\\right) + n \\sin\\left(x + \\frac{\\pi}{2}(n-1)\\right)\\\\\n(x\\cos x)^{(n)} = x\\cos\\left(x + \\frac{\\pi}{2}n\\right) + n \\cos\\left(x + \\frac{\\pi}{2}(n-1)\\right)\\\\\n(x^2\\exp(x))^{(n)} = x^2\\exp(x) + 2nx\\exp(x) + n(n-1)\\exp(x)\n\\end{align}\n\\]"
  },
  {
    "objectID": "posts/2025-02-02-taylor-expansion-and-polynomial/index.html#高階微分法とライプニッツの公式",
    "href": "posts/2025-02-02-taylor-expansion-and-polynomial/index.html#高階微分法とライプニッツの公式",
    "title": "有限個の多項式のテイラー展開",
    "section": "",
    "text": "\\(y = f(x)\\) の導関数を \\(f^\\prime(x)\\) とするとき，第二階の導関数を \\(f^{\\prime\\prime}(x)\\) と表記し，第 \\(n\\) 階の導関数を \\(f^{(n)}(x)\\) と表記します． 一点 \\(x\\) において\n\\[\n\\begin{gather}\nf^{\\prime\\prime}(x) = \\frac{d}{dx}\\left(\\frac{dy}{dx}\\right) = \\frac{d^2y}{dx^2}\\\\\nf^{(n)}(x) = \\frac{d^ny}{dx^n}\n\\end{gather}\n\\]\nとなります．\n ▶  記号の差異: \\(d^2y\\) vs \\(dx^2\\)\n\\(d^2y = d(dy)\\)，\\(dx^2 = (dx)^2\\) の意味で，この意味の差異を表現するため記号でも表記が異なっています．微分記号を用いて\n\\[\ndy = f^\\prime(x)dx\n\\]\nと書くとき，両辺の微分を取れば，\n\\[\n\\begin{align}\nd(dy) &= \\frac{d(f^{\\prime}(x))}{dx}(dx)^2 + f^\\prime(x)\\frac{d(dx)}{dx}dx\\\\\n      &= f^{\\prime\\prime}(x)(dx)^2 + f^\\prime(x)d(dx) \\label{eq-second-diff}\n\\end{align}\n\\]\n\\(x\\) が独立変数であるならば \\(dx\\) は \\(x\\) の水準関係なく自由に取れるので，\\(\\frac{d(dx)}{dx} = 0\\)．従って，\n\\[\nd^2y = f^{\\prime\\prime}(x)dx^2\n\\]\nとなります．もし，\\(x = \\varphi(t)\\) であるならば，\\(d^2x = \\varphi^{\\prime\\prime}(t)dt^2\\) となるので\n\\[\n\\frac{d}{dt^2}f(\\varphi(t)) = f^{\\prime\\prime}(\\varphi(t))(\\varphi^\\prime(t))^2 + f^\\prime(\\varphi(t))\\varphi^{\\prime\\prime}(t)\n\\]\n\n\n\n\nTheorem 1 : ライプニッツの公式(Leibniz rule) \n\\(u, v\\) が \\(x\\) の関数であるとき，\n\\[\n\\begin{align}\n\\frac{d^n(uv)}{dx^n}\n    &= u^{(n)}v + \\left(\\begin{array}{c}n\\\\1\\end{array}\\right)u^{(n-1)}v^{\\prime} + \\left(\\begin{array}{c}n\\\\2\\end{array}\\right)u^{(n-2)}v^{\\prime\\prime}+\\cdots+ \\left(\\begin{array}{c}n\\\\n-1\\end{array}\\right)u^{\\prime}v^{(n-1)} +uv^{(n)}\\\\\n    &= \\sum_{k=0}^n \\left(\\begin{array}{c}n\\\\ k\\end{array}\\right)u^{(n-k)}v^{(k)}\n\\end{align}\n\\]\n\n\n\n\n\n\n\n\n\nProof\n\n\n\n\n\n\\(n=1\\) のときは，積の微分公式より\n\\[\n\\frac{d(uv)}{dx^n} = \\frac{du}{dx}v + \\frac{dv}{dx}u\n\\]\n\\(n\\geq 2\\) については，帰納法を用いて示す．\\(n=t\\) のときライプニッツの公式が成立すると仮定する．\nこのとき，\n\\[\n\\begin{align}\n\\frac{d^{(t+1)}(uv)}{dx^{t+1}}\n    &= \\frac{d}{dt}\\left(\\frac{d^{(t)}(uv)}{dx^{t}}\\right)\\\\\n    &= \\frac{d}{dt}\\left(\\sum_{k=0}^t \\left(\\begin{array}{c}t\\\\ k\\end{array}\\right)u^{(t-k)}v^{(k)}\\right)\\\\\n    &= \\sum_{k=0}^t \\left(\\begin{array}{c}t\\\\ k\\end{array}\\right)[u^{(t-k+1)}v^{(k)} + u^{(t-k)}v^{(k+1)}]\\\\\n    &= \\sum_{k=0}^t \\left(\\begin{array}{c}t\\\\ k\\end{array}\\right)u^{(t-k+1)}v^{(k)} + \\sum_{k=0}^t \\left(\\begin{array}{c}t\\\\ k\\end{array}\\right)u^{(t-k)}v^{(k+1)}\\\\\n    &= \\left\\{u^{(t+1)}v + \\sum_{k=1}^t \\left(\\begin{array}{c}t\\\\ k\\end{array}\\right)u^{(t-k+1)}v^{(k)}\\right\\}+ \\left\\{uv^{(t+1)} + \\sum_{k=0}^{t-1} \\left(\\begin{array}{c}t\\\\ k\\end{array}\\right)u^{(t-k)}v^{(k+1)}\\right\\}\\\\\n    &= \\left\\{u^{(t+1)}v + \\sum_{k=1}^t \\left(\\begin{array}{c}t\\\\ k\\end{array}\\right)u^{(t-k+1)}v^{(k)}\\right\\}+ \\left\\{uv^{(t+1)} + \\sum_{j=1}^{t} \\left(\\begin{array}{c}t\\\\ j-1\\end{array}\\right)u^{(t-j+1)}v^{j}\\right\\}\\\\\n    &= u^{(t+1)}v + uv^{(t+1)} + \\sum_{k=1}^t \\left\\{\\left(\\begin{array}{c}t\\\\ k\\end{array}\\right) + \\left(\\begin{array}{c}t\\\\ k-1\\end{array}\\right)\\right\\}u^{(t-k+1)}v^{(k)}\\\\\n    &= u^{(t+1)}v + uv^{(t+1)} + \\sum_{k=1}^t \\left(\\begin{array}{c}t+1\\\\ k\\end{array}\\right)u^{(t+1-k)}v^{(k)}\\\\\n    &= \\sum_{k=0}^{t+1} \\left(\\begin{array}{c}t+1\\\\ k\\end{array}\\right)u^{(t+1-k)}v^{(k)}\n\\end{align}\n\\]\nとなり，\\(n = t + 1\\) の場合のライプニッツの公式の成立が確かめられた．\n\n\n\n\nExample 1 \n\\(y = x^2\\sin(x)\\) について \\(n\\) 階導関数を求めめたいとします．\n\\[\n(\\sin x)^{(k)} = \\sin\\left(x + \\frac{\\pi}{2}k\\right)\n\\]\nであるので\n\\(n=1\\) のときは\n\\[\ny^\\prime = x^2\\sin\\left(x + \\frac{\\pi}{2}\\right) + 2x\\sin(x)\n\\]\n\\(n\\geq 2\\) のときは，\\(x^2\\) が2回微分可能であることを考慮してライプニッツルールを利用すると\n\\[\n\\begin{align}\n\\frac{d^n}{dx^{n}}(x^2\\sin x)\n    &= x^2(\\sin(x))^{(n)} + 2nx(\\sin(x))^{(n-1)} + n(n-1)(\\sin(x))^{(n-2)}\\\\\n    &= x^2\\sin\\left(x + \\frac{\\pi}{2}n\\right) + 2nx\\sin\\left(x + \\frac{\\pi}{2}(n-1)\\right) + n(n-1)\\sin\\left(x + \\frac{\\pi}{2}(n-2)\\right)   \n\\end{align}\n\\]\n\n\n\nExample 2 \n\\[\n\\begin{align}\n(x\\sin x)^{(n)} = x\\sin\\left(x + \\frac{\\pi}{2}n\\right) + n \\sin\\left(x + \\frac{\\pi}{2}(n-1)\\right)\\\\\n(x\\cos x)^{(n)} = x\\cos\\left(x + \\frac{\\pi}{2}n\\right) + n \\cos\\left(x + \\frac{\\pi}{2}(n-1)\\right)\\\\\n(x^2\\exp(x))^{(n)} = x^2\\exp(x) + 2nx\\exp(x) + n(n-1)\\exp(x)\n\\end{align}\n\\]"
  },
  {
    "objectID": "posts/2025-02-02-taylor-expansion-and-polynomial/index.html#有限個の多項式のテイラー展開",
    "href": "posts/2025-02-02-taylor-expansion-and-polynomial/index.html#有限個の多項式のテイラー展開",
    "title": "有限個の多項式のテイラー展開",
    "section": "有限個の多項式のテイラー展開",
    "text": "有限個の多項式のテイラー展開\n\\(n\\) 次式の \\(f(x)\\) を考えます．このとき，定義域の任意の点 \\(a\\) を用いて，以下のように表すとします\n\\[\nf(x) = a_0 + a_1(x-a) + a_2(x-a)^2 + \\cdots + a_n(x-a)^n\n\\]\n\\(x = a\\) のとき，\\(f(a) = a_0\\)．両辺を \\(k\\) 回微分すると\n\\[\nf^{(k)}(x) = a_kk! + a_{k+1}\\frac{(k+1)!}{1!}(x-a) + a_{k+2}\\frac{(k+2)!}{2!}(x-a)^2 + \\cdots + a_{n}\\frac{n!}{(n-k)!}(x-a)^{n-k}\n\\]\nこのとき，\\(f^{(k)}(a) = a_kk!\\) であるので，\\(a_k = \\frac{f^{(k)}(a)}{k!}\\) を得る．従って，\\(n\\) 次式の \\(f(x)\\) は\n\\[\nf(x) = f(a) + \\frac{f^{\\prime}(a)}{1!}(x-a) + \\frac{f^{(2)}(a)}{2!}(x-a)^2 + \\cdots + \\frac{f^{(n)}(a)}{n!}(x-a)^n\\label{eq-poly}\n\\]\nと表すことが出来ます．\n\nExample 3 \n\\(f(x) = x^n\\) を\n\\[\nf(x) = a_0 + a_1(x-1) + a_2(x-1)^2 + \\cdots + a_n(x-1)^n\n\\]\nで表したいとします．このとき，\\(\\eqref{eq-poly}\\) より\n\\[\n\\begin{align}\nx^n\n    &= 1 + \\frac{n}{1!}(x-1)+ \\frac{n(n-1)}{2!}(x-1)^2 + \\cdots + \\frac{n!}{n!}(x-1)^n\\\\\n    &= \\sum_{k=0}^n \\left(\\begin{array}{c}n\\\\ k\\end{array}\\right)(x-1)^k\n\\end{align}\n\\]\nと表せます．これを更に式変形すると\n\\[\n\\begin{align}\n\\sum_{k=0}^n \\left(\\begin{array}{c}n\\\\ k\\end{array}\\right)(x-1)^k\n    &= \\sum_{k=0}^n \\left(\\begin{array}{c}n\\\\ k\\end{array}\\right)(x-1)^k 1^{n-k}\\\\\n    &= (x - 1 + 1)^n\\\\\n    &= x^n\n\\end{align}\n\\]\nよって \\(x^n\\) の \\(x = 1\\) まわりでのテイラー展開は \\((x - 1 + 1)^n\\) の二項展開と関係づけて理解することが出来ます．\n\n\n\n\nTheorem 2 \n\\(n\\) 次式の \\(f(x)\\) について，\\(x=a\\) が \\(k\\) 重解であるための必要十分条件は\n\\[\n\\begin{gather}\nf(a) = f^\\prime(a) = \\cdots = f^{(k-1)}(a) = 0\\\\\nf^{(k)}(a) \\neq 0\n\\end{gather}\n\\]\n\n\n\n\n\n\n\n\n\nProof\n\n\n\n\n\n\\(x=a\\) が \\(k\\) 重解であるということは，\\(f(x) = (x-a)^kg(x), g(a)\\neq 0\\) と同値であることに留意して以下示します．\n ▶  十分性\n\\(\\eqref{eq-poly}\\) より\n\\[\n\\begin{align}\nf(x)\n    &=\\frac{f^{(k)}(a)}{k!}(x-a)^k + \\frac{f^{(k+1)}(a)}{(k+1)!}(x-a)^{k+1} + \\cdots +\\frac{f^{(n)}(a)}{n!}(x-a)^n\\\\\n    &= (x-a)^k\\left\\{\\frac{f^{(k)}(a)}{k!} + \\frac{f^{(k+1)}(a)}{(k+1)!}(x-a)^{1} + \\cdots + \\frac{f^{(n)}(a)}{n!}(x-a)^{n-k}\\right\\}\\\\\n    &= (x-a)^kg(x)\n\\end{align}\n\\]\nこのとき，\\(f^{(k)}(a) \\neq 0\\) より \\(g(a)\\neq 0\\). 以上より，十分性は示せた．\n ▶  必要性\n\\(f(x) = (x-a)^kg(x), g(a)\\neq 0\\) のとき，\\(f(a) = 0\\) は自明． この式を \\(m\\) 回微分するとライプニッツルールより\n\\[\n\\begin{aligned}\nf^{(m)}(x) =& (x-a)^kg^{(m)}(x) + \\left(\\begin{array}{c}m\\\\ 1\\end{array}\\right)k(x-a)^{k-1}g^{(m-1)}(x) \\\\\n            &+ \\cdots + \\left(\\begin{array}{c}m\\\\ m\\end{array}\\right)k(k-1)\\cdots(k-m+1)(x-a)^{k-m}g(x)\n\\end{aligned}\n\\]\n\\(m &lt; k\\) であるならば，\\(f^{(m)}(a) = 0\\)，また \\(m = k\\) であるならば\n\\[\nf^{(k)}(a) = k!g(a) \\neq 0\n\\]\n従って，必要性も示された．\n\n\n\n\nExample 4 \n\\[\nf(x) = x^4 + ax^2 + bx + c = 0\n\\]\nが \\(x=1\\) を３重解に持つようにするようにパラメータを定めたいとします．\n\\[\n\\begin{align}\nf(1) &= 1 + a + b + c = 0\\\\\nf^\\prime(1) &= 4 + 2a + b = 0\\\\\nf^{\\prime\\prime}(1) &= 12 + 2a = 0\\\\\nf^{(3)}(1) &= 24 \\neq 0\\\\\n\\end{align}\n\\]\nこれを解くと，\\((a, b, c) = (-6, 8, -3)\\)．これを用いて整理すると\n\\[\nf(x) = (x-1)^3(x+3)\n\\]\nとなります．\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\n\ndef func_x(x, a, b, c):\n    return x**4 + a*x**2 + b*x + c\n\nx_domain = np.linspace(-4, 4, 100)\n\nplt.plot(x_domain, func_x(x_domain, *(-6, 8, -3)), label='$f(x) = x^4 - 6x^2 + 8x - 3$')\nplt.plot(x_domain, func_x(x_domain, *(-8, 12, -5)), label='$f(x) = (x-1)^2(x^2+2x-5)$')\nplt.xlabel('X')\nplt.ylabel('y')\nplt.axhline(0, color='gray', linestyle='--', linewidth=0.7)\nplt.legend()\nplt.xlim(-4, 4)\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 1"
  },
  {
    "objectID": "posts/2024-12-11-BQ-create-external-table/index.html",
    "href": "posts/2024-12-11-BQ-create-external-table/index.html",
    "title": "Cloud StorageからExternal Tableの作成",
    "section": "",
    "text": "Google Cloud StorageからBigQuery上にExternal tabaleを作成する\nPartition Fieldが定義されたExternal tabaleを作成するための条件を確認する"
  },
  {
    "objectID": "posts/2024-12-11-BQ-create-external-table/index.html#このノートのスコープ",
    "href": "posts/2024-12-11-BQ-create-external-table/index.html#このノートのスコープ",
    "title": "Cloud StorageからExternal Tableの作成",
    "section": "",
    "text": "Google Cloud StorageからBigQuery上にExternal tabaleを作成する\nPartition Fieldが定義されたExternal tabaleを作成するための条件を確認する"
  },
  {
    "objectID": "posts/2024-12-11-BQ-create-external-table/index.html#external-tableとは",
    "href": "posts/2024-12-11-BQ-create-external-table/index.html#external-tableとは",
    "title": "Cloud StorageからExternal Tableの作成",
    "section": "External Tableとは？",
    "text": "External Tableとは？\nBigQueryのExternal Table（外部テーブル）は，BigQuery内にデータをコピーまたはインポートすることなく， 外部データソースに直接アクセスしてクエリを実行できる機能です．\nBigQueryにおけるExternal Tableの利用形式として，permanent tableとtemporary tableの２つがあります．\n\npermanent table: BigQuery dataset内に作成され，外部データソースにリンクされるテーブル\ntemporary table: 外部データソースに対して一時的にクエリを実行する場合に利用されるテーブル\n\n一時的なテスト処理などでtemporary tableを用いることは有用ですが，分析者間でクエリやコードを共有して分析を進める場合はpermanent tableを持ちないと テーブルアクセスを共有できないので，このノートではpermanent tableを主に取り扱います．\n ▶  サポートされているデータストア\n\nBigLake\nCloud Storage\nBigtable\nGoogle Drive\nAmazon S3\nAzure Blob Storage\n\n以上のデータストアがBigQueryからアクセス可能な外部データソースとしてサポートされています\n ▶  Pricing\nBigQueryのPricingは\n\nCompute pricing: クエリの処理にかかる費用\nStorage pricing: データ保存費用\n\nの２つから構成されています．External Tableを用いると，後者の方はCloud Storage換算の費用となるため，一般的には ストレージコストを抑えることができます．ただし，External Tableにアクセスして分析するたびに\n\nQuery cost: クエリ計算処理時間に比例するコスト\nBytes cost: External tableからのデータ読み取りサイズに比例するコスト\n\nが発生します．\n\n📘 Tips \nExternal Tableを用いた分析が一時的なものであるならばExternal Tableを用いたほうが良いと思いますが， 頻繁にBigQueryからアクセスする場合は\n\nPartitioning/Clusteringを用いてアクセスサイズを抑える\nSELECT以下で*を使用せず，分析に用いるカラムを明示的に指定して，スキャンサイズを抑える\n\nという工夫，またはBigQuery native tableとしてデータを保持することを検討したほうが良いと思います．\n\n\nExternal Table use cases\nExternal Tableの特徴として，\n\nBigQuery native tableとしてデータは保持しない\nExternal Tableと紐づく外部ストアの最新データに対して，クエリ処理が走る\n\nがあります．そのため，PoCや営業段階での分析や頻繁にupdateされるデータに対してのオンライン分析といった場面で活用されるケースが多いです．\n\nExample: 営業段階でのアドホック分析 \n\nBtoC向けサービスを展開している企業Aに対して営業をしているとする\nNDAを結んだ後に，企業Aが保有しているデータのサンプルとして２年間分の連携してもらった\nこのデータを用いて簡易的な分析を行い，どのようなインサイトが導けそうか？を次の営業会議で企業Aに伝え説得したい\n\nという場面を考えます．\n ▶  Key Points\n\nわざわざテーブルスキーマを定義する時間はあまりない→早くEDAをやりたい\nサンプルデータなので，プロジェクト受注後に連携されるであろうデータセットよりも情報量が少ない→わざわざテーブルスキーマしても再利用可能性は低い\n\n ▶  External Tableのメリット\n\nテーブルスキーマをわざわざ定義しなくても，BigQueryを用いた大容量のデータに対しての分析が可能\n複数の分析者間でサンプルデータをCloud Storageベースで簡単に共有できる\nPythonなどの言語を用いた分析でも，予めBigQueryで前処理して小さいdatamartを作成し，それに対してEDAが実施できる"
  },
  {
    "objectID": "posts/2024-12-11-BQ-create-external-table/index.html#external-table作成",
    "href": "posts/2024-12-11-BQ-create-external-table/index.html#external-table作成",
    "title": "Cloud StorageからExternal Tableの作成",
    "section": "External Table作成",
    "text": "External Table作成\nここでは，EXTERNAL PARTITION TABLEの作成を目的に\n\ngoogle cloud storageへのupload\nEXTERNAL TABLEの作成\n\nの２段階の流れで説明します．\n ▶  Cloud Storageへのupload\n~/pupupuland_store_posというdirectory以下に，yyyymmdd形式の日付でpartitionされたPARQUET形式のデータがあるとします．\npupupuland_store_pos\n├── partition_dt=2023-09-23\n│   └── purchase_history_2023-09-23.parquet\n├── partition_dt=2023-09-24\n│   └── purchase_history_2023-09-24.parquet\n├── partition_dt=2023-09-25\n│   └── purchase_history_2023-09-25.parquet\n├── partition_dt=2023-09-26\n│   └── purchase_history_2023-09-26.parquet\n├── partition_dt=2023-09-27\n│   └── purchase_history_2023-09-27.parquet\n├── partition_dt=2023-09-28\n│   └── purchase_history_2023-09-28.parquet\n├── partition_dt=2023-09-29\n│   └── purchase_history_2023-09-29.parquet\n└── partition_dt=2023-09-30\n    └── purchase_history_2023-09-30.parquet\nこのディレクトリ構造を保持したまま，gs://project-make-dedede-great-again/というcloud storage bucketに格納したいとします．このとき\ngcloud storage cp -r ~/pupupuland_store_pos/ gs://project-make-dedede-great-again/\n以上で下準備は完了です．\n ▶  External Tableの作成\nGoogle Cloud project pupupuland-businessdata の dedede-holdings dataset以下に先程上げた pupupuland_store_pos tableを作成したいと思います．\nCREATE EXTERNAL TABLE `pupupuland-businessdata.dedede-holdings.pupupuland_store_pos`\nWITH PARTITION COLUMNS (\npartition_dt DATE, -- column order must match the external path\n)\nOPTIONS (\nuris = ['gs://project-make-dedede-great-again/pupupuland_store_pos/*'],\nformat = 'PARQUET',\nhive_partition_uri_prefix = 'gs://project-make-dedede-great-again/pupupuland_store_pos',\nrequire_hive_partition_filter = false);\nPARTITION COLUMNSのフィールドに partition_dtと入力していますが，これは外部ファイルのパスのパターンがgs://project-make-dedede-great-again/pupupuland_store_pos/partition_dt=yyyymmdd/data.parquet であることを前提にしています．そのため，upload時のdirectory構造を\n└── partition_dt=2023-09-30\n    └── purchase_history_20230930.parquet\nという形にしてcloud storageにuploadしたという背景があります．DATETYPEにDATEと指定していますが，/&lt;partition field&gt;=2018-10-18/という構造になっていないと失敗することに注意してください． 他にも INTEGER, STRING, TIMESTAMPが指定できます．TIMESTAMPの場合は，/&lt;partition field&gt;=2018-10-18 16:00:00+00/という構造であることが必要です．\nrequire_hive_partition_filter フィールドはクエリ時にpartition_dtによるWHERE句フィルタリングを強制するか否かの設定フィールドです． デフォルトではfalseとなっており，この場合はフィルタリングしなくてもクエリできることを意味します．"
  },
  {
    "objectID": "posts/2024-12-11-BQ-create-external-table/index.html#references",
    "href": "posts/2024-12-11-BQ-create-external-table/index.html#references",
    "title": "Cloud StorageからExternal Tableの作成",
    "section": "References",
    "text": "References\n\nIntroduction to external tables"
  },
  {
    "objectID": "posts/2025-02-26-law-of-cosines/index.html",
    "href": "posts/2025-02-26-law-of-cosines/index.html",
    "title": "余弦定理の考え方",
    "section": "",
    "text": "Exercise 1 \n\\(AC = 30, BC = 26, \\angle C = 70^\\circ\\) となるような \\(\\triangle ABC\\) が与えられたとします．このとき，長さ \\(AB\\) を求めよ\n\n\n\nCode\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport matplotlib.patches as patches\n\n# 辺の長さと角度\nAC = 30\nBC = 26\nangle_C = 70\n\n# 角度をラジアンに変換\nangle_C_rad = np.radians(angle_C)\n\n# 点Aの座標\nA = (0, 0)\n\nAB = np.sqrt(30**2 + 26**2 - 2 * 30 * 26 * np.cos(np.radians(70)))\n\n# 点Bの座標\nB = (AB, 0)\n\n# 点Cの座標\ncos_A = (30**2 + AB**2 - 26**2) / (2 * 30 * AB)\nsin_A = np.sqrt(1 - cos_A**2)\nC = (30 * cos_A, 30 * sin_A)\n\nslope = - (C[0] - B[0])/(C[1] - B[1])\nH = (24.6, 24.6 * slope)\n\n\n# 座標をリストに変換\nfig, ax = plt.subplots(figsize=(6, 6))\n\nax.plot([A[0], H[0]], [A[1], H[1]], \"k\")  # Black line with circle markers\nax.plot([A[0], B[0]], [A[1], B[1]], \"ko-\")  # Black line with circle markers\nax.plot([B[0], C[0]], [B[1], C[1]], \"ko-\")  # Black line with circle markers\nax.plot([C[0], A[0]], [C[1], A[1]], \"ko-\")  # Black line with circle markers\n\n# 点のラベル\nplt.text(H[0]-2, H[1], \"H\")\nplt.text(A[0]-2, A[1], \"A\")\nplt.text(B[0]+1, B[1], \"B\")\nplt.text(C[0]+1, C[1], \"C\")\n\n# 軸の範囲を設定\nplt.xlim(-5, 35)\nplt.ylim(-5, 35)\n\n# 軸のラベルを設定\nplt.xlabel(\"X\")\nplt.ylabel(\"Y\")\n\n# タイトルを設定\nplt.title(\"Triangle ABC\")\n\n# Add angles as arcs\narc_radius = 5  # Radius for the arcs\n\n# Angle at B\nangle_C_arc = patches.Arc(C, arc_radius*0.8, arc_radius*0.8, angle=250, theta1=np.degrees(320), theta2=np.degrees(70), color='blue')\nax.add_patch(angle_C_arc)\nax.text(C[0]-1, C[1] - arc_radius*.8, f\"{70}°\", fontsize=12, color='blue')\n# ax.text(C[0] + arc_radius/2, B[1] + 1, f\"{70}°\", fontsize=12, color='blue')\nax.text(5, 10, \"AC = 30\", fontsize=12, color='black', horizontalalignment='center')\nax.text(30, 10, \"BC = 26\", fontsize=12, color='black', horizontalalignment='center')\n\n# 図の表示\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 1\n\n\n\nこのとき，点 \\(A\\) から \\(BC\\) に対して垂線を下ろし，その交点を \\(H\\) とします．このとき\n\\[\n\\begin{align}\nCH &= AC * \\cos(C)\\\\\nBH &= BC - AC * \\cos(C)\\\\\nAH& = AC * \\sin(C)\n\\end{align}\n\\]\nピタゴラスの定理より\n\\[\nAB^2 = AH^2 + BH^2\n\\]\nなので\n\\[\n\\begin{align}\nAB^2 &= (BC - AC * \\cos(C))^2 + (AC * \\sin(C))^2\\\\\n     &= BC^2 + AC^2 - 2\\cdot BC\\cdot AC \\cos(C)\n\\end{align}\n\\]\n従って，\n\n\nCode\nprint(f\"AB = {AB:.2f}\")\n\n\nAB = 32.29\n\n\n ▶  ベクトルを用いた直感的理解\nベクトルの内積は \\(\\vec a \\cdot \\vec b = \\lvert a \\rvert \\lvert b \\rvert \\cos \\theta\\) で定義されることを利用すると，\n\\[\n\\begin{aligned}\nAB^2\n    &= \\left\\lvert \\overrightarrow{CA} - \\overrightarrow{CB} \\right\\rvert^2 \\\\\n    &= (\\overrightarrow{CA} - \\overrightarrow{CB}) \\cdot (\\overrightarrow{CA} - \\overrightarrow{CB}) \\\\\n    &= \\left\\lvert \\overrightarrow{CA} \\right\\rvert^2 + \\left\\lvert \\overrightarrow{CB} \\right\\rvert^2\n    - 2 \\overrightarrow{CA} \\cdot \\overrightarrow{CB} \\\\\n    &= \\left\\lvert \\overrightarrow{CA} \\right\\rvert^2 + \\left\\lvert \\overrightarrow{CB} \\right\\rvert^2\n    - 2 \\left\\lvert \\overrightarrow{CA} \\right\\rvert \\left\\lvert \\overrightarrow{CB} \\right\\rvert \\cos(\\angle ACB) \\\\\n    &= AC^2 + BC^2  - 2\\cdot AC\\cdot BC \\cos(C)\n\\end{aligned}\n\\]\n\n\n\n\nExercise 2 \n四角形PABQ が以下のように与えられている\n\n\\(AB = 10\\)\n\\(\\angle PAB = {75}^\\circ\\)\n\\(\\angle PBA = {50}^\\circ\\)\n\\(\\angle PAQ = {40}^\\circ\\)\n\\(\\angle QAB = {35}^\\circ\\)\n\\(\\angle PBQ = {70}^\\circ\\)\n\nこのとき，PQの距離を求めよ．\n\nCode\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport matplotlib.patches as patches\n\n# 辺の長さと角度\nAB = 10\nangle_PAB = np.radians(75)\nangle_PBA = np.radians(50)\nangle_QAB = np.radians(35)\nangle_AQB = np.radians(25)\nangle_QBA = np.radians(120)\nangle_APB = np.radians(55)\n\n\n# 点Aの座標\nA = (0, 0)\n\n# 点Bの座標\nB = (AB, 0)\n\n# 点Pの座標\nPA = AB / np.sin(angle_APB) * np.sin(angle_PBA)\nP = ((np.cos(angle_PAB)) * PA, (np.sin(angle_PAB)) * PA)\n\n# 点Qの座標\nQA = AB / np.sin(angle_AQB) * np.sin(angle_QBA)\nQ = ((np.cos(angle_QAB)) * QA, (np.sin(angle_QAB)) * QA)\n\n\n# 座標をリストに変換\nfig, ax = plt.subplots(figsize=(6, 6))\n\nax.plot([A[0], P[0]], [A[1], P[1]], \"k\")  # Black line with circle markers\nax.plot([A[0], B[0]], [A[1], B[1]], \"ko-\")  # Black line with circle markers\nax.plot([B[0], P[0]], [B[1], P[1]], \"ko-\")  # Black line with circle markers\nax.plot([Q[0], A[0]], [Q[1], A[1]], \"ko-\")  # Black line with circle markers\nax.plot([Q[0], B[0]], [Q[1], B[1]], \"ko-\")  # Black line with circle markers\nax.plot([Q[0], P[0]], [Q[1], P[1]], \"ko-\")  # Black line with circle markers\n\n# 点のラベル\nplt.text(A[0] - 1, A[1], \"A\")\nplt.text(B[0] + 1, B[1], \"B\")\nplt.text(P[0], P[1] + 1, \"P\")\nplt.text(Q[0] + 1, Q[1], \"Q\")\n\n# 軸の範囲を設定\nplt.xlim(-2, 20)\nplt.ylim(-2, 20)\n\n# 軸のラベルを設定\nplt.xlabel(\"X\")\nplt.ylabel(\"Y\")\n\n# タイトルを設定\nplt.title(\"How far is the distance between P and Q\")\n\n# Add angles as arcs\narc_radius = 5  # Radius for the arcs\n\n# Angle at B\nax.text(A[0] + 1, A[1] + 1.8, f\"{40}°\", fontsize=10, color=\"blue\")\nax.text(A[0] + 1, A[1] + 0.2, f\"{35}°\", fontsize=10, color=\"blue\")\nax.text(B[0] - 2, B[1] + 0.2, f\"{50}°\", fontsize=10, color=\"blue\")\nax.text(B[0] - 0.5, B[1] + 1, f\"{70}°\", fontsize=10, color=\"blue\")\n# ax.text(C[0] + arc_radius/2, B[1] + 1, f\"{70}°\", fontsize=12, color='blue')\nax.text(5, -1, \"AB = 10\", fontsize=12, color=\"black\", horizontalalignment=\"center\")\nax.text(\n    (P[0] + Q[0]) / 2,\n    (P[1] + Q[1]) / 2 + 1,\n    \"PQ = ???\",\n    fontsize=12,\n    color=\"black\",\n    horizontalalignment=\"center\",\n)\n\n\n# 図の表示\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 2\n\n\n\n\n\n\n\n\n\n\n\n\nSolution 1: 余弦定理を用いて解く\n\n\n\n\n\n\\(\\angle PAQ = {40}^\\circ\\) と問題分よりわかるので，\\(PA, QA\\) の長さがわかれば余弦定理より \\(PQ\\) が導出できます．\n正弦定理を用いて\n\\[\n\\begin{align}\nPA &= \\frac{AB}{\\sin({55}^\\circ)}\\times \\sin({50}^\\circ)\\\\\nQA &= \\frac{AB}{\\sin({25}^\\circ)}\\times \\sin({120}^\\circ)\n\\end{align}\n\\]\n余弦定理を用いると\n\\[\nPQ^2 = QA^2 + PA^2 - 2(PA)(QA)\\cos({40}^\\circ)\n\\]\nよって，\n\n\nCode\n# set variables\nAB = 10\nangle_APB = np.radians(55)\nangle_AQB = np.radians(25)\nangle_PBA = np.radians(50)\nangle_QBA = np.radians(120)\nangle_PAQ = np.radians(40)\n\n\n# compute PA and QA\nPA = AB / np.sin(angle_APB) * np.sin(angle_PBA)\nQA = AB / np.sin(angle_AQB) * np.sin(angle_QBA)\n\n\n# comnpute PQ using laws of cosines\nPQ = np.sqrt(PA ** 2 + QA **2 - 2 * PA * QA * np.cos(angle_PAQ))\n\nprint(f\"PQ = {PQ:.2f}\")\n\n\nPQ = 14.62\n\n\n\n\n\n\n\n\n\n\n\n\nSolution 2: 座標を用いて解く\n\n\n\n\n\n各点を \\(XY\\) 平明座標に以下のように置き換えます\n\n\\(A\\) = (0, 0)\n\\(B\\) = (0, 10)\n\nこのとき，点 \\(P\\) の座標 \\((P_X, P_Y)\\) は\n\\[\n\\begin{align}\nP_X & = PA \\cdot \\cos({75}^\\circ)\\\\\nP_Y & = PA \\cdot \\sin({75}^\\circ)\n\\end{align}\n\\]\n同様に点 \\(Q\\) の座標 \\((Q_X, Q_Y)\\) は\n\\[\n\\begin{align}\nQ_X & = QA \\cdot \\cos({35}^\\circ)\\\\\nQ_Y & = QA \\cdot \\sin({35}^\\circ)\n\\end{align}\n\\]\nこのとき，長さ \\(PQ\\) は点 \\(P, Q\\) の距離と表せるので\n\\[\n\\begin{align}\nPQ &= \\lVert P - Q \\rVert\\\\\n   &= \\sqrt{(P_X - Q_X)^2 + (P_Y - Q_Y)^2}\\\\\n   &= \\sqrt{(AQ^2 + PA^2 - 2(PA)(QA)(\\cos({35}^\\circ)\\cos({75}^\\circ) + \\sin({35}^\\circ)\\sin({75}^\\circ)))}\n\\end{align}\n\\]\n加法定理より\n\\[\n\\cos (A \\pm B) = \\cos A \\cos B \\mp \\sin A \\sin B\n\\]\nなので\n\\[\n\\cos({35}^\\circ)\\cos({75}^\\circ) + \\sin({35}^\\circ)\\sin({75}^\\circ) = \\cos({40}^\\circ)\n\\]\n従って，\n\\[\nPQ^2 = QA^2 + PA^2 - 2(PA)(QA)\\cos({40}^\\circ)\n\\]"
  },
  {
    "objectID": "posts/2025-02-26-law-of-cosines/index.html#余弦定理の考え方",
    "href": "posts/2025-02-26-law-of-cosines/index.html#余弦定理の考え方",
    "title": "余弦定理の考え方",
    "section": "",
    "text": "Exercise 1 \n\\(AC = 30, BC = 26, \\angle C = 70^\\circ\\) となるような \\(\\triangle ABC\\) が与えられたとします．このとき，長さ \\(AB\\) を求めよ\n\n\n\nCode\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport matplotlib.patches as patches\n\n# 辺の長さと角度\nAC = 30\nBC = 26\nangle_C = 70\n\n# 角度をラジアンに変換\nangle_C_rad = np.radians(angle_C)\n\n# 点Aの座標\nA = (0, 0)\n\nAB = np.sqrt(30**2 + 26**2 - 2 * 30 * 26 * np.cos(np.radians(70)))\n\n# 点Bの座標\nB = (AB, 0)\n\n# 点Cの座標\ncos_A = (30**2 + AB**2 - 26**2) / (2 * 30 * AB)\nsin_A = np.sqrt(1 - cos_A**2)\nC = (30 * cos_A, 30 * sin_A)\n\nslope = - (C[0] - B[0])/(C[1] - B[1])\nH = (24.6, 24.6 * slope)\n\n\n# 座標をリストに変換\nfig, ax = plt.subplots(figsize=(6, 6))\n\nax.plot([A[0], H[0]], [A[1], H[1]], \"k\")  # Black line with circle markers\nax.plot([A[0], B[0]], [A[1], B[1]], \"ko-\")  # Black line with circle markers\nax.plot([B[0], C[0]], [B[1], C[1]], \"ko-\")  # Black line with circle markers\nax.plot([C[0], A[0]], [C[1], A[1]], \"ko-\")  # Black line with circle markers\n\n# 点のラベル\nplt.text(H[0]-2, H[1], \"H\")\nplt.text(A[0]-2, A[1], \"A\")\nplt.text(B[0]+1, B[1], \"B\")\nplt.text(C[0]+1, C[1], \"C\")\n\n# 軸の範囲を設定\nplt.xlim(-5, 35)\nplt.ylim(-5, 35)\n\n# 軸のラベルを設定\nplt.xlabel(\"X\")\nplt.ylabel(\"Y\")\n\n# タイトルを設定\nplt.title(\"Triangle ABC\")\n\n# Add angles as arcs\narc_radius = 5  # Radius for the arcs\n\n# Angle at B\nangle_C_arc = patches.Arc(C, arc_radius*0.8, arc_radius*0.8, angle=250, theta1=np.degrees(320), theta2=np.degrees(70), color='blue')\nax.add_patch(angle_C_arc)\nax.text(C[0]-1, C[1] - arc_radius*.8, f\"{70}°\", fontsize=12, color='blue')\n# ax.text(C[0] + arc_radius/2, B[1] + 1, f\"{70}°\", fontsize=12, color='blue')\nax.text(5, 10, \"AC = 30\", fontsize=12, color='black', horizontalalignment='center')\nax.text(30, 10, \"BC = 26\", fontsize=12, color='black', horizontalalignment='center')\n\n# 図の表示\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 1\n\n\n\nこのとき，点 \\(A\\) から \\(BC\\) に対して垂線を下ろし，その交点を \\(H\\) とします．このとき\n\\[\n\\begin{align}\nCH &= AC * \\cos(C)\\\\\nBH &= BC - AC * \\cos(C)\\\\\nAH& = AC * \\sin(C)\n\\end{align}\n\\]\nピタゴラスの定理より\n\\[\nAB^2 = AH^2 + BH^2\n\\]\nなので\n\\[\n\\begin{align}\nAB^2 &= (BC - AC * \\cos(C))^2 + (AC * \\sin(C))^2\\\\\n     &= BC^2 + AC^2 - 2\\cdot BC\\cdot AC \\cos(C)\n\\end{align}\n\\]\n従って，\n\n\nCode\nprint(f\"AB = {AB:.2f}\")\n\n\nAB = 32.29\n\n\n ▶  ベクトルを用いた直感的理解\nベクトルの内積は \\(\\vec a \\cdot \\vec b = \\lvert a \\rvert \\lvert b \\rvert \\cos \\theta\\) で定義されることを利用すると，\n\\[\n\\begin{aligned}\nAB^2\n    &= \\left\\lvert \\overrightarrow{CA} - \\overrightarrow{CB} \\right\\rvert^2 \\\\\n    &= (\\overrightarrow{CA} - \\overrightarrow{CB}) \\cdot (\\overrightarrow{CA} - \\overrightarrow{CB}) \\\\\n    &= \\left\\lvert \\overrightarrow{CA} \\right\\rvert^2 + \\left\\lvert \\overrightarrow{CB} \\right\\rvert^2\n    - 2 \\overrightarrow{CA} \\cdot \\overrightarrow{CB} \\\\\n    &= \\left\\lvert \\overrightarrow{CA} \\right\\rvert^2 + \\left\\lvert \\overrightarrow{CB} \\right\\rvert^2\n    - 2 \\left\\lvert \\overrightarrow{CA} \\right\\rvert \\left\\lvert \\overrightarrow{CB} \\right\\rvert \\cos(\\angle ACB) \\\\\n    &= AC^2 + BC^2  - 2\\cdot AC\\cdot BC \\cos(C)\n\\end{aligned}\n\\]\n\n\n\n\nExercise 2 \n四角形PABQ が以下のように与えられている\n\n\\(AB = 10\\)\n\\(\\angle PAB = {75}^\\circ\\)\n\\(\\angle PBA = {50}^\\circ\\)\n\\(\\angle PAQ = {40}^\\circ\\)\n\\(\\angle QAB = {35}^\\circ\\)\n\\(\\angle PBQ = {70}^\\circ\\)\n\nこのとき，PQの距離を求めよ．\n\nCode\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport matplotlib.patches as patches\n\n# 辺の長さと角度\nAB = 10\nangle_PAB = np.radians(75)\nangle_PBA = np.radians(50)\nangle_QAB = np.radians(35)\nangle_AQB = np.radians(25)\nangle_QBA = np.radians(120)\nangle_APB = np.radians(55)\n\n\n# 点Aの座標\nA = (0, 0)\n\n# 点Bの座標\nB = (AB, 0)\n\n# 点Pの座標\nPA = AB / np.sin(angle_APB) * np.sin(angle_PBA)\nP = ((np.cos(angle_PAB)) * PA, (np.sin(angle_PAB)) * PA)\n\n# 点Qの座標\nQA = AB / np.sin(angle_AQB) * np.sin(angle_QBA)\nQ = ((np.cos(angle_QAB)) * QA, (np.sin(angle_QAB)) * QA)\n\n\n# 座標をリストに変換\nfig, ax = plt.subplots(figsize=(6, 6))\n\nax.plot([A[0], P[0]], [A[1], P[1]], \"k\")  # Black line with circle markers\nax.plot([A[0], B[0]], [A[1], B[1]], \"ko-\")  # Black line with circle markers\nax.plot([B[0], P[0]], [B[1], P[1]], \"ko-\")  # Black line with circle markers\nax.plot([Q[0], A[0]], [Q[1], A[1]], \"ko-\")  # Black line with circle markers\nax.plot([Q[0], B[0]], [Q[1], B[1]], \"ko-\")  # Black line with circle markers\nax.plot([Q[0], P[0]], [Q[1], P[1]], \"ko-\")  # Black line with circle markers\n\n# 点のラベル\nplt.text(A[0] - 1, A[1], \"A\")\nplt.text(B[0] + 1, B[1], \"B\")\nplt.text(P[0], P[1] + 1, \"P\")\nplt.text(Q[0] + 1, Q[1], \"Q\")\n\n# 軸の範囲を設定\nplt.xlim(-2, 20)\nplt.ylim(-2, 20)\n\n# 軸のラベルを設定\nplt.xlabel(\"X\")\nplt.ylabel(\"Y\")\n\n# タイトルを設定\nplt.title(\"How far is the distance between P and Q\")\n\n# Add angles as arcs\narc_radius = 5  # Radius for the arcs\n\n# Angle at B\nax.text(A[0] + 1, A[1] + 1.8, f\"{40}°\", fontsize=10, color=\"blue\")\nax.text(A[0] + 1, A[1] + 0.2, f\"{35}°\", fontsize=10, color=\"blue\")\nax.text(B[0] - 2, B[1] + 0.2, f\"{50}°\", fontsize=10, color=\"blue\")\nax.text(B[0] - 0.5, B[1] + 1, f\"{70}°\", fontsize=10, color=\"blue\")\n# ax.text(C[0] + arc_radius/2, B[1] + 1, f\"{70}°\", fontsize=12, color='blue')\nax.text(5, -1, \"AB = 10\", fontsize=12, color=\"black\", horizontalalignment=\"center\")\nax.text(\n    (P[0] + Q[0]) / 2,\n    (P[1] + Q[1]) / 2 + 1,\n    \"PQ = ???\",\n    fontsize=12,\n    color=\"black\",\n    horizontalalignment=\"center\",\n)\n\n\n# 図の表示\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 2\n\n\n\n\n\n\n\n\n\n\n\n\nSolution 1: 余弦定理を用いて解く\n\n\n\n\n\n\\(\\angle PAQ = {40}^\\circ\\) と問題分よりわかるので，\\(PA, QA\\) の長さがわかれば余弦定理より \\(PQ\\) が導出できます．\n正弦定理を用いて\n\\[\n\\begin{align}\nPA &= \\frac{AB}{\\sin({55}^\\circ)}\\times \\sin({50}^\\circ)\\\\\nQA &= \\frac{AB}{\\sin({25}^\\circ)}\\times \\sin({120}^\\circ)\n\\end{align}\n\\]\n余弦定理を用いると\n\\[\nPQ^2 = QA^2 + PA^2 - 2(PA)(QA)\\cos({40}^\\circ)\n\\]\nよって，\n\n\nCode\n# set variables\nAB = 10\nangle_APB = np.radians(55)\nangle_AQB = np.radians(25)\nangle_PBA = np.radians(50)\nangle_QBA = np.radians(120)\nangle_PAQ = np.radians(40)\n\n\n# compute PA and QA\nPA = AB / np.sin(angle_APB) * np.sin(angle_PBA)\nQA = AB / np.sin(angle_AQB) * np.sin(angle_QBA)\n\n\n# comnpute PQ using laws of cosines\nPQ = np.sqrt(PA ** 2 + QA **2 - 2 * PA * QA * np.cos(angle_PAQ))\n\nprint(f\"PQ = {PQ:.2f}\")\n\n\nPQ = 14.62\n\n\n\n\n\n\n\n\n\n\n\n\nSolution 2: 座標を用いて解く\n\n\n\n\n\n各点を \\(XY\\) 平明座標に以下のように置き換えます\n\n\\(A\\) = (0, 0)\n\\(B\\) = (0, 10)\n\nこのとき，点 \\(P\\) の座標 \\((P_X, P_Y)\\) は\n\\[\n\\begin{align}\nP_X & = PA \\cdot \\cos({75}^\\circ)\\\\\nP_Y & = PA \\cdot \\sin({75}^\\circ)\n\\end{align}\n\\]\n同様に点 \\(Q\\) の座標 \\((Q_X, Q_Y)\\) は\n\\[\n\\begin{align}\nQ_X & = QA \\cdot \\cos({35}^\\circ)\\\\\nQ_Y & = QA \\cdot \\sin({35}^\\circ)\n\\end{align}\n\\]\nこのとき，長さ \\(PQ\\) は点 \\(P, Q\\) の距離と表せるので\n\\[\n\\begin{align}\nPQ &= \\lVert P - Q \\rVert\\\\\n   &= \\sqrt{(P_X - Q_X)^2 + (P_Y - Q_Y)^2}\\\\\n   &= \\sqrt{(AQ^2 + PA^2 - 2(PA)(QA)(\\cos({35}^\\circ)\\cos({75}^\\circ) + \\sin({35}^\\circ)\\sin({75}^\\circ)))}\n\\end{align}\n\\]\n加法定理より\n\\[\n\\cos (A \\pm B) = \\cos A \\cos B \\mp \\sin A \\sin B\n\\]\nなので\n\\[\n\\cos({35}^\\circ)\\cos({75}^\\circ) + \\sin({35}^\\circ)\\sin({75}^\\circ) = \\cos({40}^\\circ)\n\\]\n従って，\n\\[\nPQ^2 = QA^2 + PA^2 - 2(PA)(QA)\\cos({40}^\\circ)\n\\]"
  },
  {
    "objectID": "posts/2025-02-27-how-to-compute-tan75/index.html",
    "href": "posts/2025-02-27-how-to-compute-tan75/index.html",
    "title": "tangent 75°の図形的計算",
    "section": "",
    "text": "Exercise 1 \n\\(\\tan {75}^\\circ\\) を求めよ\n\n\n\n\n\n\n\n\n\n解1: 加法定理を用いる場合\n\n\n\n\n\n\\[\n\\begin{align}\n\\tan {45}^\\circ &= 1\\\\\n\\tan {30}^\\circ &= \\frac{\\sqrt{3}}{3}\n\\end{align}\n\\]\nより，加法定理を用いて\n\\[\n\\begin{align}\n\\tan {75}^\\circ\n    &= \\frac{\\tan{30}^\\circ + \\tan{45}^\\circ}{1 - \\tan{30}^\\circ\\tan{45}^\\circ}\\\\\n    &= \\frac{1 + \\frac{\\sqrt{3}}{3}}{1 - \\frac{\\sqrt{3}}{3}}\\\\\n    &= 2 + \\sqrt{3}\n\\end{align}\n\\]\n\n\n\n\n\n\n\n\n\n\n解2: 平面幾何的に求める場合\n\n\n\n\n\n\\(\\angle A = {30}^\\circ, \\angle B = {90}^\\circ, \\angle C = {60}^\\circ\\) の \\(\\triangle ABC\\) を考えたとき，\\(\\angle A\\) の斜辺 \\(AC\\) を用いて 直角二等辺三角形 \\(\\triangle ACD\\) をまず作成します．\nこの点 \\(D\\) を通るように \\(AB\\) と平行な線を引き，長方形 \\(AEFB\\) を以下のように作成します．\n\nCode\nimport shapely.plotting\nimport matplotlib.pyplot as plt\nfrom shapely.geometry import Polygon\nimport numpy as np\n\nA = (0, 0)\nB = (1, 0)\nC = (1, np.sin(np.radians(30)))\nD = (np.sqrt(2) * np.cos(np.radians(75)), np.sqrt(2) * np.sin(np.radians(75)))\nE = (0, np.sqrt(2) * np.sin(np.radians(75)))\nF = (1, np.sqrt(2) * np.sin(np.radians(75)))\n\npolygon1 = Polygon([A, B, C])\npolygon2 = Polygon([A, C, D])\npolygon3 = Polygon([A, E, D])\npolygon4 = Polygon([C, D, F])\n\nfig, ax = plt.subplots(figsize=(6, 6))\n\nshapely.plotting.plot_polygon(polygon1, ax=ax)\nshapely.plotting.plot_polygon(polygon2, alpha=0.5, facecolor='none', ax=ax)\nshapely.plotting.plot_polygon(polygon3, alpha=0.5, facecolor='red', ax=ax)\nshapely.plotting.plot_polygon(polygon4, ax=ax)\n\n# 軸の範囲を設定\nplt.xlim(-0.1, 1.45)\nplt.ylim(-0.1, 1.45)\n\n# add label\nplt.text(A[0], A[1] - 0.05, 'A')\nplt.text(B[0]+0.02, B[1] - 0.05, 'B')\nplt.text(C[0]+0.02, C[1], 'C')\nplt.text(D[0], D[1] + 0.02, 'D')\nplt.text(E[0], E[1] + 0.02, 'E')\nplt.text(F[0], F[1] + 0.02, 'F')\n\n# Add Angles\nax.text(A[0] + 0.06, A[1], f\"{30}°\", fontsize=10)\nax.text(A[0] + 0.06, A[1] + 0.1, f\"{45}°\", fontsize=10)\nax.text(B[0] - 0.09, B[1], f\"{90}°\", fontsize=10)\nax.text(C[0] - 0.1, C[1], f\"{90}°\", fontsize=10)\nax.text(C[0] - 0.1, C[1] + 0.14, f\"{30}°\", fontsize=10)\nax.text(C[0] - 0.1, C[1] - 0.1, f\"{60}°\", fontsize=10)\n\n# Add length\nax.text(0.5, -0.08, \"$\\sqrt{3}$\", fontsize=12, color=\"black\", horizontalalignment=\"center\")\nax.text(0.5, 0.3, \"2\", fontsize=12, color=\"black\", horizontalalignment=\"center\")\nax.text(0.5, 1.0, \"2\", fontsize=12, color=\"black\", horizontalalignment=\"center\")\nax.text(1.05, 0.2, \"1\", fontsize=12, color=\"black\", horizontalalignment=\"left\")\nax.text(1.05, 1.0, \"$\\sqrt{3}$\", fontsize=12, color=\"black\", horizontalalignment=\"left\")\nax.text((D[0] + F[0])/2, 1.37,  \"1\", fontsize=12, color=\"black\", horizontalalignment=\"center\")\nax.text((D[0] + E[0])/2, 1.37,  \"$\\sqrt{3} - 1$\", fontsize=12, color=\"black\", horizontalalignment=\"center\")\n\n\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 1\n\n\n\nこのとき， \\(\\triangle CFD  \\equiv \\triangle ABC\\) なので\n\n\\(AE = 1 + \\sqrt{3}\\)\n\\(DE = \\sqrt{3} - 1\\)\n\nであることがわかります．\\(\\triangle ACD\\) は直角二等辺三角形なので \\(\\angle ADC = {45}^\\circ\\)．従って，\n\\[\n\\angle ADE = {75}^\\circ\n\\]\nよって，\n\\[\n\\begin{align}\n\\tan{75}^\\circ\n    &= \\frac{1 + \\sqrt{3}}{\\sqrt{3} - 1} \\\\\n    &= \\frac{4 + 2\\sqrt{3}}{2}\\\\\n    &= 2 + \\sqrt{3}\n\\end{align}\n\\]"
  },
  {
    "objectID": "posts/2025-03-02-find-coordinates/index.html",
    "href": "posts/2025-03-02-find-coordinates/index.html",
    "title": "敵の砲台の座標を探せ 1/N",
    "section": "",
    "text": "\\((a, b)\\) を中心点とする半径 \\(r\\) の円をplotすることを考えます．\n半径 \\(r\\) の円の中心点の座標が原点 \\((0, 0)\\) にある場合，円周上の点 \\(P = (x, y)\\) は，\\(P\\) から \\(x\\) 軸に下ろした垂線と \\(x\\) 軸が交わる点を \\(Q\\) としたとき \\(\\triangle OPQ\\) は斜辺 \\(r\\)，高さ \\(y\\), 底辺の長さ \\(x\\) となる直角三角形を構成するので，三平方の定理より\n\\[\nr^2 = x^2 + y^2\n\\]\nこれが円上の座標が満たす方程式となります．原点を中心点とする場合を考えましたが，中心が \\((a, b)\\)，半径 \\(r\\) の円の式は同様の方法で\n\\[\nr^2 = (x - a)^2 + (y - b)^2 \\label{#eq-circle}\n\\]\nと表すことが出来ます．\n\n\nCode\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport matplotlib.tri as mtri\n\n# set params\nR = 1\nO = (2, 1)\n\n# variables\ntheta = np.linspace(0, 2 * np.pi, 1000)\nx = np.cos(theta) * R + O[0]\ny = np.sin(theta) * R + O[1]\n\nA = (x[100], y[100])\ntriangles = [[0, 1, 2]]\nx_trinagle = [O[0], A[0], A[0]]\ny_trinagle = [O[1], O[1], A[1]]\ntriang = mtri.Triangulation(x_trinagle, y_trinagle, triangles)\n\n# plot\nfig, ax = plt.subplots(figsize=(8, 6))\nax.grid()\nax.set_aspect(\"equal\")\nax.set_xlim(0.5, 3.5)\nax.set_ylim(-0.5, 2.5)\n\n\nax.plot(x, y)\nax.scatter(*O, s=8, color=\"k\")\nax.scatter(*A, s=8, color=\"k\")\nax.text(*O, s=\"O\",  ha='center', va='bottom')\nax.text(*A, s=\"A = ($x_1, y_1$)\", ha='left', va='bottom')\nax.text(2.4, 1.35, s=\"r\")\nax.text(2.4, 0.9, s=\"$x_1 - 2$\", ha='center', va='bottom')\nax.text(A[0]+0.05, 1.35, s=\"$y_1 - 1$\", ha='left', va='bottom')\n\n# add lines\nax.triplot(triang, 'ko-')\n\n\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\n# set params\nR = 2.5\nO = (3, 1/2)\n\n# variables\ntheta = np.linspace(0, 2 * np.pi, 1000)\nx = np.cos(theta) * R + O[0]\ny = np.sin(theta) * R + O[1]\n\nP = (1, -1)\nQ = (3, 3)\nR = (1, 2)\n\n# plot\nfig, ax = plt.subplots(figsize=(8, 6))\nax.grid()\nax.set_aspect(\"equal\")\n\nax.plot(x, y)\nax.scatter(*O, s=8, color=\"k\")\nax.scatter(*P, s=8, color=\"k\")\nax.scatter(*Q, s=8, color=\"k\")\nax.scatter(*R, s=8, color=\"k\")\nax.text(*O, s=\"O\",  ha='center', va='bottom')\nax.text(*P, s=\"P\",  ha='center', va='bottom')\nax.text(*Q, s=\"Q\", ha='left', va='bottom')\nax.text(*R, s=\"R\", ha='left', va='bottom')\n\n\nplt.show()\n\n\n\n\n\n\n\n\n\n３点 \\(P = (1, -1), Q = (3, 3), R = (1, 2)\\) が与えられたとして，この３点を通る円を求める問題を考えます．\n\\(\\eqref{#eq-circle}\\) を展開すると\n\\[\nx^2 + y^2 - 2ax - 2by + a^2 + b^2 = r^2\n\\]\nこれを整理して\n\\[\nx^2 + y^2 + Ax + By + C = 0 \\label{#eq-basemodel}\n\\]\nと変形します．ここで，\\(P = (1, -1), Q = (3, 3), R = (1, 2)\\) の情報を用いると\n\\[\n\\begin{gather}\n2 + A - B + C = 0\\\\\n18 + 3A + 3B + C = 0\\\\\n5 + A +2B + C = 0\n\\end{gather}\n\\]\nという \\(A,B,C\\) についての連立方程式を得ることが出来ます．これを解くと\n\\[\nA = -6, B = -1, C = 3\n\\]\n従って，\n\\[\n(x - 3)^2 + (y - 0.5)^2 = 2.5^2 \\label{#eq-ans1}\n\\]\n\n\n点 \\(P, Q, R\\) からなる三角形の外接円として求めたい円を捉えることも出来ます． 外接円の円心は三角形の各線分の垂直二等分線の交点として求めることが出来ます．\n\n\nCode\ndef func_pq(x):\n    a = - (P[0] - Q[0]) / (P[1] - Q[1])\n    b = - a * (P[0] + Q[0]) / 2 + (P[1] + Q[1]) / 2\n\n    return a*x + b\n\ndef func_pr(x):\n    a = - (P[0] - R[0]) / (P[1] - R[1])\n    b = - a * (P[0] + R[0]) / 2 + (P[1] + R[1]) / 2\n\n    return a*x + b\n\nx_lin = np.array([0, 6])\ntriangles = [[0, 1, 2]]\nx_trinagle = [P[0], Q[0], R[0]]\ny_trinagle = [P[1], Q[1], R[1]]\ntriang = mtri.Triangulation(x_trinagle, y_trinagle, triangles)\n\n\n\n# plot\nfig, ax = plt.subplots(figsize=(8, 6))\nax.grid()\nax.set_aspect(\"equal\")\nax.set_xlim(0, 6)\nax.set_ylim(-2.5, 3.5)\nax.plot(x_lin, func_pq(x_lin), label='PQ Perpendicular bisector', linestyle='--', color='gray')\nax.plot(x_lin, func_pr(x_lin), label='PR Perpendicular bisector', linestyle=':', color='gray')\n\n\nax.plot(x, y)\nax.scatter(*O, s=8, color=\"k\")\nax.scatter(*P, s=8, color=\"k\")\nax.scatter(*Q, s=8, color=\"k\")\nax.scatter(*R, s=8, color=\"k\")\nax.text(*O, s=\"O\",  ha='center', va='bottom')\nax.text(*P, s=\"P\",  ha='center', va='bottom')\nax.text(*Q, s=\"Q\", ha='left', va='bottom')\nax.text(*R, s=\"R\", ha='left', va='bottom')\n\n# add lines\nax.triplot(triang, 'ko-')\n\nplt.legend(loc='center left', bbox_to_anchor=(1, 0.95))\nplt.show()\n\n\n\n\n\n\n\n\n\n\\(PQ\\) の垂直二等分線 \\(f(x)\\) は\n\\[\n\\begin{align}\nf(x)\n    &= -\\frac{P_x - Q_x}{P_y - Q_y}x + \\frac{P_y + Q_y}{2} + \\frac{P_x - Q_x}{P_y - Q_y} \\frac{P_x + Q_y}{2}\\\\\n    &= -\\frac{P_x - Q_x}{P_y - Q_y}x + \\frac{P_x^2 - Q_x^2 + P_y^2 - Q_y^2}{2(P_y - Q_y)}\n\\end{align}\n\\]\n同様に \\(PR\\) の垂直二等分線 \\(g(x)\\) は\n\\[\n\\begin{align}\ng(x)\n    &= -\\frac{P_x - R_x}{P_y - R_y}x + \\frac{P_y + R_y}{2} + \\frac{P_x - R_x}{P_y - R_y} \\frac{P_x + R_y}{2}\\\\\n    &= -\\frac{P_x - R_x}{P_y - R_y}x + \\frac{P_x^2 - R_x^2 + P_y^2 - R_y^2}{2(P_y - R_y)}\n\\end{align}\n\\]\nここから \\(f(x), g(x)\\) が交差する点を求めることで外接円の円心を求めることが出来ます．\n少しめんどくさいので，数値計算で説いてみると\n\n\nCode\na = - (P[0] - Q[0]) / (P[1] - Q[1])\nb = - a * (P[0] + Q[0]) / 2 + (P[1] + Q[1]) / 2\nc = - (P[0] - R[0]) / (P[1] - R[1])\nd = - c * (P[0] + R[0]) / 2 + (P[1] + R[1]) / 2\n\nprint((d-b)/(a-c), a * (d-b)/(a-c) + b)\n\n\n3.0 0.5\n\n\n\\(\\eqref{#eq-ans1}\\) と一致する計算結果となることが確かめられました．\n\n📘 REMARKS \n上記の垂直二等分線の交点を \\((x_0, y_0)\\) としたとき，整理すると以下のようになります．\n\\[\nA = \\left(\\begin{array}{cc}\nR_y - Q_y & -(P_y - Q_y)\\\\\n-(R_x - Q_x) & P_x - Q_x\\\\\n\\end{array}\\right)\n\\]\nとしたとき，\n\\[\n\\left(\\begin{array}{c}\nx_0\\\\\ny_0\n\\end{array}\\right)\n    = \\frac{1}{\\operatorname{det}A} A\\left(\\begin{array}{c}\n(P_x^2 - Q_x^2 + P_y^2 - Q_y^2)/2\\\\\n(R_x^2 - Q_x^2 + R_y^2 - Q_y^2)/2\n\\end{array}\\right)\n\\]\n実際に計算してみると\n\n\nCode\nA_array = np.array([[R[1] - Q[1], -(P[1] - Q[1])], [-(R[0] - Q[0]), P[0] - Q[0]]])\nB_array = np.array(\n    [\n        [(P[0]**2 - Q[0]**2 + P[1]**2 - Q[1]**2) / 2],\n        [(R[0]**2 - Q[0]**2 + R[1]**2 - Q[1]**2) / 2],\n    ]\n)\n\nresult = np.ravel((A_array @ B_array) / np.linalg.det(A_array))\nradius = np.sqrt(np.sum((np.array(P) - result) **2))\nprint(f\"中心点 = ({result}), 半径 = {radius}\")\n\n\n中心点 = ([3.  0.5]), 半径 = 2.5"
  },
  {
    "objectID": "posts/2025-03-02-find-coordinates/index.html#円の式",
    "href": "posts/2025-03-02-find-coordinates/index.html#円の式",
    "title": "敵の砲台の座標を探せ 1/N",
    "section": "",
    "text": "\\((a, b)\\) を中心点とする半径 \\(r\\) の円をplotすることを考えます．\n半径 \\(r\\) の円の中心点の座標が原点 \\((0, 0)\\) にある場合，円周上の点 \\(P = (x, y)\\) は，\\(P\\) から \\(x\\) 軸に下ろした垂線と \\(x\\) 軸が交わる点を \\(Q\\) としたとき \\(\\triangle OPQ\\) は斜辺 \\(r\\)，高さ \\(y\\), 底辺の長さ \\(x\\) となる直角三角形を構成するので，三平方の定理より\n\\[\nr^2 = x^2 + y^2\n\\]\nこれが円上の座標が満たす方程式となります．原点を中心点とする場合を考えましたが，中心が \\((a, b)\\)，半径 \\(r\\) の円の式は同様の方法で\n\\[\nr^2 = (x - a)^2 + (y - b)^2 \\label{#eq-circle}\n\\]\nと表すことが出来ます．\n\n\nCode\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport matplotlib.tri as mtri\n\n# set params\nR = 1\nO = (2, 1)\n\n# variables\ntheta = np.linspace(0, 2 * np.pi, 1000)\nx = np.cos(theta) * R + O[0]\ny = np.sin(theta) * R + O[1]\n\nA = (x[100], y[100])\ntriangles = [[0, 1, 2]]\nx_trinagle = [O[0], A[0], A[0]]\ny_trinagle = [O[1], O[1], A[1]]\ntriang = mtri.Triangulation(x_trinagle, y_trinagle, triangles)\n\n# plot\nfig, ax = plt.subplots(figsize=(8, 6))\nax.grid()\nax.set_aspect(\"equal\")\nax.set_xlim(0.5, 3.5)\nax.set_ylim(-0.5, 2.5)\n\n\nax.plot(x, y)\nax.scatter(*O, s=8, color=\"k\")\nax.scatter(*A, s=8, color=\"k\")\nax.text(*O, s=\"O\",  ha='center', va='bottom')\nax.text(*A, s=\"A = ($x_1, y_1$)\", ha='left', va='bottom')\nax.text(2.4, 1.35, s=\"r\")\nax.text(2.4, 0.9, s=\"$x_1 - 2$\", ha='center', va='bottom')\nax.text(A[0]+0.05, 1.35, s=\"$y_1 - 1$\", ha='left', va='bottom')\n\n# add lines\nax.triplot(triang, 'ko-')\n\n\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\n# set params\nR = 2.5\nO = (3, 1/2)\n\n# variables\ntheta = np.linspace(0, 2 * np.pi, 1000)\nx = np.cos(theta) * R + O[0]\ny = np.sin(theta) * R + O[1]\n\nP = (1, -1)\nQ = (3, 3)\nR = (1, 2)\n\n# plot\nfig, ax = plt.subplots(figsize=(8, 6))\nax.grid()\nax.set_aspect(\"equal\")\n\nax.plot(x, y)\nax.scatter(*O, s=8, color=\"k\")\nax.scatter(*P, s=8, color=\"k\")\nax.scatter(*Q, s=8, color=\"k\")\nax.scatter(*R, s=8, color=\"k\")\nax.text(*O, s=\"O\",  ha='center', va='bottom')\nax.text(*P, s=\"P\",  ha='center', va='bottom')\nax.text(*Q, s=\"Q\", ha='left', va='bottom')\nax.text(*R, s=\"R\", ha='left', va='bottom')\n\n\nplt.show()\n\n\n\n\n\n\n\n\n\n３点 \\(P = (1, -1), Q = (3, 3), R = (1, 2)\\) が与えられたとして，この３点を通る円を求める問題を考えます．\n\\(\\eqref{#eq-circle}\\) を展開すると\n\\[\nx^2 + y^2 - 2ax - 2by + a^2 + b^2 = r^2\n\\]\nこれを整理して\n\\[\nx^2 + y^2 + Ax + By + C = 0 \\label{#eq-basemodel}\n\\]\nと変形します．ここで，\\(P = (1, -1), Q = (3, 3), R = (1, 2)\\) の情報を用いると\n\\[\n\\begin{gather}\n2 + A - B + C = 0\\\\\n18 + 3A + 3B + C = 0\\\\\n5 + A +2B + C = 0\n\\end{gather}\n\\]\nという \\(A,B,C\\) についての連立方程式を得ることが出来ます．これを解くと\n\\[\nA = -6, B = -1, C = 3\n\\]\n従って，\n\\[\n(x - 3)^2 + (y - 0.5)^2 = 2.5^2 \\label{#eq-ans1}\n\\]\n\n\n点 \\(P, Q, R\\) からなる三角形の外接円として求めたい円を捉えることも出来ます． 外接円の円心は三角形の各線分の垂直二等分線の交点として求めることが出来ます．\n\n\nCode\ndef func_pq(x):\n    a = - (P[0] - Q[0]) / (P[1] - Q[1])\n    b = - a * (P[0] + Q[0]) / 2 + (P[1] + Q[1]) / 2\n\n    return a*x + b\n\ndef func_pr(x):\n    a = - (P[0] - R[0]) / (P[1] - R[1])\n    b = - a * (P[0] + R[0]) / 2 + (P[1] + R[1]) / 2\n\n    return a*x + b\n\nx_lin = np.array([0, 6])\ntriangles = [[0, 1, 2]]\nx_trinagle = [P[0], Q[0], R[0]]\ny_trinagle = [P[1], Q[1], R[1]]\ntriang = mtri.Triangulation(x_trinagle, y_trinagle, triangles)\n\n\n\n# plot\nfig, ax = plt.subplots(figsize=(8, 6))\nax.grid()\nax.set_aspect(\"equal\")\nax.set_xlim(0, 6)\nax.set_ylim(-2.5, 3.5)\nax.plot(x_lin, func_pq(x_lin), label='PQ Perpendicular bisector', linestyle='--', color='gray')\nax.plot(x_lin, func_pr(x_lin), label='PR Perpendicular bisector', linestyle=':', color='gray')\n\n\nax.plot(x, y)\nax.scatter(*O, s=8, color=\"k\")\nax.scatter(*P, s=8, color=\"k\")\nax.scatter(*Q, s=8, color=\"k\")\nax.scatter(*R, s=8, color=\"k\")\nax.text(*O, s=\"O\",  ha='center', va='bottom')\nax.text(*P, s=\"P\",  ha='center', va='bottom')\nax.text(*Q, s=\"Q\", ha='left', va='bottom')\nax.text(*R, s=\"R\", ha='left', va='bottom')\n\n# add lines\nax.triplot(triang, 'ko-')\n\nplt.legend(loc='center left', bbox_to_anchor=(1, 0.95))\nplt.show()\n\n\n\n\n\n\n\n\n\n\\(PQ\\) の垂直二等分線 \\(f(x)\\) は\n\\[\n\\begin{align}\nf(x)\n    &= -\\frac{P_x - Q_x}{P_y - Q_y}x + \\frac{P_y + Q_y}{2} + \\frac{P_x - Q_x}{P_y - Q_y} \\frac{P_x + Q_y}{2}\\\\\n    &= -\\frac{P_x - Q_x}{P_y - Q_y}x + \\frac{P_x^2 - Q_x^2 + P_y^2 - Q_y^2}{2(P_y - Q_y)}\n\\end{align}\n\\]\n同様に \\(PR\\) の垂直二等分線 \\(g(x)\\) は\n\\[\n\\begin{align}\ng(x)\n    &= -\\frac{P_x - R_x}{P_y - R_y}x + \\frac{P_y + R_y}{2} + \\frac{P_x - R_x}{P_y - R_y} \\frac{P_x + R_y}{2}\\\\\n    &= -\\frac{P_x - R_x}{P_y - R_y}x + \\frac{P_x^2 - R_x^2 + P_y^2 - R_y^2}{2(P_y - R_y)}\n\\end{align}\n\\]\nここから \\(f(x), g(x)\\) が交差する点を求めることで外接円の円心を求めることが出来ます．\n少しめんどくさいので，数値計算で説いてみると\n\n\nCode\na = - (P[0] - Q[0]) / (P[1] - Q[1])\nb = - a * (P[0] + Q[0]) / 2 + (P[1] + Q[1]) / 2\nc = - (P[0] - R[0]) / (P[1] - R[1])\nd = - c * (P[0] + R[0]) / 2 + (P[1] + R[1]) / 2\n\nprint((d-b)/(a-c), a * (d-b)/(a-c) + b)\n\n\n3.0 0.5\n\n\n\\(\\eqref{#eq-ans1}\\) と一致する計算結果となることが確かめられました．\n\n📘 REMARKS \n上記の垂直二等分線の交点を \\((x_0, y_0)\\) としたとき，整理すると以下のようになります．\n\\[\nA = \\left(\\begin{array}{cc}\nR_y - Q_y & -(P_y - Q_y)\\\\\n-(R_x - Q_x) & P_x - Q_x\\\\\n\\end{array}\\right)\n\\]\nとしたとき，\n\\[\n\\left(\\begin{array}{c}\nx_0\\\\\ny_0\n\\end{array}\\right)\n    = \\frac{1}{\\operatorname{det}A} A\\left(\\begin{array}{c}\n(P_x^2 - Q_x^2 + P_y^2 - Q_y^2)/2\\\\\n(R_x^2 - Q_x^2 + R_y^2 - Q_y^2)/2\n\\end{array}\\right)\n\\]\n実際に計算してみると\n\n\nCode\nA_array = np.array([[R[1] - Q[1], -(P[1] - Q[1])], [-(R[0] - Q[0]), P[0] - Q[0]]])\nB_array = np.array(\n    [\n        [(P[0]**2 - Q[0]**2 + P[1]**2 - Q[1]**2) / 2],\n        [(R[0]**2 - Q[0]**2 + R[1]**2 - Q[1]**2) / 2],\n    ]\n)\n\nresult = np.ravel((A_array @ B_array) / np.linalg.det(A_array))\nradius = np.sqrt(np.sum((np.array(P) - result) **2))\nprint(f\"中心点 = ({result}), 半径 = {radius}\")\n\n\n中心点 = ([3.  0.5]), 半径 = 2.5"
  },
  {
    "objectID": "posts/2025-03-02-find-coordinates/index.html#敵の砲台の座標を探せ",
    "href": "posts/2025-03-02-find-coordinates/index.html#敵の砲台の座標を探せ",
    "title": "敵の砲台の座標を探せ 1/N",
    "section": "敵の砲台の座標を探せ",
    "text": "敵の砲台の座標を探せ\n\n\nExercise 1 \nとある固定の１地点から自軍領地に対して敵が砲撃をかけてきているとします. 敵の砲台は角度のみを調整できるだけで，砲撃予定距離 \\(r\\) は一定とします．ただし，実際の砲撃距離は風向などの外乱要因によってノイズが混じっているとします．\nとある日に敵から50回の攻撃を受けたとき，その砲台座標を推定してください．砲撃のノイズは\\(\\operatorname{i.i.d}\\)とする．\n\n\n\\(\\eqref{#eq-basemodel}\\) より\n\\[\n\\begin{align}\nz_i = - x_i^2 - y_i^2\n\\end{align}\n\\]\nと定義すると，\\(e_i\\) をresidualとして\n\\[\nz_i = \\beta_0 + \\beta_1 x_i + \\beta_2 y_i + e_i\n\\]\nについて \\((\\beta_0, \\beta_1, \\beta_2)\\) をLinear modelで推定し，その推定値を \\((\\hat\\beta_0, \\hat\\beta_1, \\hat\\beta_2)\\) と表せば 敵の砲台の推定座標 \\((\\hat x, \\hat y)\\) 及び推定距離 \\(\\hat r\\) は\n\\[\n\\begin{align}\n\\hat x &= -\\hat\\beta_1/2\\\\\n\\hat y &= -\\hat\\beta_2/2\\\\\n\\hat r &= \\sqrt{\\hat x^2 + \\hat y^2 - \\hat\\beta_0}\n\\end{align}\n\\]\nと計算できそうに思えます．\n ▶  Data Generating Process\n\n敵の砲台の座標は \\((0, 0)\\)\n敵は \\((0, 0)\\) の地点から砲撃距離 \\(20\\) で攻撃してくる\n実際の砲撃距離 \\(r \\sim N(20, 1)\\)\n砲撃角度は \\(\\left[\\displaystyle{\\frac{\\pi}{3}, \\frac{\\pi}{2}}\\right]\\) の範囲で一様分布で定まる\n\nというData Generating Processとします．\n\n\nCode\ndef gdp(x_0: float, y_0: float, noise: float = 1.0, radius: float = 20,  attack_num: int = 50):\n    # params\n    theta = np.random.uniform(np.pi/3 , np.pi/2 , attack_num)\n    r = radius + np.random.normal(0, noise, attack_num)\n\n    x = np.cos(theta) * r + x_0\n    y = np.sin(theta) * r + y_0\n\n    return x, y\n\n\nこのGDPに従う形で攻撃されたとするとき，その散布図は以下のようになります．\n\n\nCode\nnp.random.seed(42)\n\nx_attack, y_attack = gdp(0, 0)\n\nfig, ax = plt.subplots()\nax.scatter(x_attack, y_attack)\nax.set_xlim(-1, np.max([np.max(x_attack), np.max(y_attack)]) + 1)\nax.set_ylim(-1, np.max([np.max(x_attack), np.max(y_attack)]) + 1)\nax.grid()\nax.set_aspect('equal')\nplt.show()\n\n\n\n\n\n\n\n\n\n ▶  OLS Monte Carlo Simulation\nOLSによるパラメータ推定値を \\(1,000\\) 回simulationし，その組み合わせをkde plotしたものが以下となります．x座標についてバイアスがあることがわかります． 砲撃距離に関しても不自然な推定値となっています．\n\n\nCode\nimport pandas as pd\nimport statsmodels.api as sm\nimport seaborn as sns\n\ndef gpd_dataframe(x: float = 0, y: float = 0, noise: float = 1.0):\n    x_attack, y_attack = gdp(x, y, noise)\n    df = pd.DataFrame(\n        {\n            \"x_coordinate\": x_attack,\n            \"y_coordinate\": y_attack,\n        }\n    )\n\n    return df\n\n\ndef ols_solver(\n    df: pd.DataFrame, xy_columns: tuple[str] = (\"x_coordinate\", \"y_coordinate\")\n):\n    Y = -(df[xy_columns[0]] ** 2) - df[xy_columns[1]]\n    X = sm.add_constant(df.loc[:, xy_columns])\n\n    # regression\n    model = sm.OLS(Y, X)\n    results = model.fit()\n\n    # convert estimates to target params\n    x_hat = -results.params[xy_columns[0]] / 2\n    y_hat = -results.params[xy_columns[1]] / 2\n    r_hat_sqr = (x_hat**2 + y_hat**2 - results.params['const'])\n    r_hat = np.sqrt(r_hat_sqr) if r_hat_sqr &gt; 0 else np.nan\n\n    return [x_hat, y_hat, r_hat]\n\n\ndef estimator_simulator(func, noise: float = 1.0, iter: int = 1000):\n    res = list(map(lambda x: func(gpd_dataframe(0, 0, noise)), range(iter)))\n    return np.array(res)\n\nfig, ax = plt.subplots(1, 2)\n\nols_res = estimator_simulator(ols_solver)\nsns.kdeplot(x=ols_res[:, 0], y=ols_res[:, 1], cmap=\"Blues\", fill=True, ax=ax[0])\nsns.kdeplot(x=ols_res[:, 2], cmap=\"Blues\", fill=True, ax=ax[1])\n\n# Show the plot\nax[0].set_xlabel(\"estimated x coordinate\")\nax[0].set_ylabel(\"estimated y coordinate\")\nax[0].set_aspect('equal')\nax[0].set_title(\"OLS 2D Density Plot\\nwith 1000 iterations\")\nax[1].set_title(\"Raidus Density Plot\\nwith 1000 iterations\")\nplt.show()\n\n\n\n\n\n\n\n\n\nそもそも \\(r_i = 20 + \\epsilon_i\\) と決定されていますが\n\\[\n\\beta_0 = a^2 + b^2 - (r + \\epsilon_i)^2\n\\]\nで決定されており，これを踏まえて OLSのモデルを見てみると\n\\[\nz_i = \\left(a^2 + b^2 - r^2 - \\epsilon_i^2 - 2r\\epsilon \\right) - 2ax_i - 2by_i\n\\]\nとなるので，そもそもunbiasedな推定量になっていないと判断できます\n ▶  Regression with MLE\n\\(\\eqref{#eq-circle}\\) に則り，もっと直接的に\n\\[\nL(\\beta) = (\\sqrt{(x_i - \\beta_1)^2 + (y_i - \\beta_2)^2} - \\beta_0)^2\n\\]\nを最小する形でパラメーターを推定してみます．このとき．residualが\\(N(0, \\sigma)\\) に従うならばLikelihoodは\n\\[\nf(X_i\\vert \\beta, \\sigma) = \\frac{1}{\\sqrt{2\\pi}\\sigma}\\exp\\left(-\\frac{L(\\beta)}{2\\sigma^2}\\right)\n\\]\nと表せるので，これを用いて解いてみます．\n\n\nCode\nimport numpy as np\nfrom scipy.optimize import minimize\n\n\ndef lik(parameters, x, y):\n    x_0 = parameters[0]\n    y_0 = parameters[1]\n    r_0 = parameters[2]\n    sigma = parameters[3]\n    g_x = (np.sqrt((np.sqrt((x - x_0) ** 2 + (y - y_0) ** 2) - r_0)**2)) ** 2\n\n    L = len(x) / 2 * np.log(sigma**2) +  1 / (2 * sigma**2) * np.sum(g_x)\n    return L\n\n\ndef mle_solver(\n    df: pd.DataFrame, xy_columns: tuple[str] = (\"x_coordinate\", \"y_coordinate\")\n):\n\n    x_attack = df[xy_columns[0]].values\n    y_attack = df[xy_columns[1]].values\n    lik_model = minimize(\n        lambda params: lik(params, x_attack, y_attack),\n        np.array([1, 1, 20, 1]),\n        method=\"L-BFGS-B\",\n    )\n    return lik_model[\"x\"]\n\n\nmle_res = estimator_simulator(mle_solver)\n\n# plot\nfig, axes= plt.subplots(1, 2)\n\nsns.kdeplot(x=mle_res[:, 0], y=mle_res[:, 1], cmap=\"Blues\", fill=True, ax=axes[0])\nsns.kdeplot(x=mle_res[:, 2], cmap=\"Blues\", fill=True, ax=axes[1])\n\n# Show the plot\naxes[0].set_xlabel(\"estimated x coordinate\")\naxes[0].set_ylabel(\"estimated y coordinate\")\naxes[0].set_title(\"MLE 2D Density Plot\\nwith 1000 iterations\")\naxes[0].set_aspect(\"equal\")\naxes[1].set_title(\"Raidus Density Plot\\nwith 1000 iterations\")\n\nplt.show()\n\n\n\n\n\n\n\n\n\n定式化は正しいはずですが，\\((x_0, y_0, r_0)\\) は効率的な推定量となっていない疑いがあることが読み取れます．\n次に，\n\\[\nL(\\beta) = \\sqrt{(x_i - \\beta_1)^2 + (y_i - \\beta_2)^2 - \\beta_0^2} \\label{#eq-mle}\n\\]\nをLoss functionとして推定してみます．\n\n\nCode\nimport numpy as np\nfrom scipy.optimize import minimize\n\n\ndef lik(parameters, x, y):\n    x_0 = parameters[0]\n    y_0 = parameters[1]\n    r_0 = parameters[2]\n    sigma = parameters[3]\n    g_x = (x - x_0) ** 2 + (y - y_0) ** 2 - r_0**2\n\n    L = len(x) / 2 * np.log(sigma**2) +  1 / (2 * sigma**2) * np.sum(g_x)\n    return L\n\n\ndef mle_solver(\n    df: pd.DataFrame, xy_columns: tuple[str] = (\"x_coordinate\", \"y_coordinate\")\n):\n\n    x_attack = df[xy_columns[0]].values\n    y_attack = df[xy_columns[1]].values\n    lik_model = minimize(\n        lambda params: lik(params, x_attack, y_attack),\n        np.array([1, 1, 20, 1]),\n        method=\"L-BFGS-B\",\n    )\n    return lik_model[\"x\"]\n\n\nmle_res = estimator_simulator(mle_solver)\n\n# plot\nfig, axes= plt.subplots(1, 2)\n\nsns.kdeplot(x=mle_res[:, 0], y=mle_res[:, 1], cmap=\"Blues\", fill=True, ax=axes[0])\nsns.kdeplot(x=mle_res[:, 2], cmap=\"Blues\", fill=True, ax=axes[1])\n\n# Show the plot\naxes[0].set_xlabel(\"estimated x coordinate\")\naxes[0].set_ylabel(\"estimated y coordinate\")\naxes[0].set_title(\"MLE 2D Density Plot\\nwith 1000 iterations\")\naxes[0].set_aspect(\"equal\")\naxes[1].set_title(\"Raidus Density Plot\\nwith 1000 iterations\")\n\nplt.show()\n\n\n\n\n\n\n\n\n\n先程よりは精度良く推定できているように見えますが，\\(\\eqref{#eq-mle}\\) は\n\\[\nL(\\beta) = \\sqrt{\\epsilon_i^2 + 2\\beta_0 \\epsilon_i}\n\\]\nとなるので，そもそもMLEの定式化が間違っていることがわかります．また，\\(\\beta_0\\) が大きいほどresidualが大きくなる傾向があることから，unbiasedな推定量は得られていないことがわかります．\n ▶  Regression with stan\ncmdstanを用いて砲台座標を推定する例を紹介します．まずstan modelを以下のように設定します．\n\n砲撃距離のノイズについて \\(N(0, 1)\\) であることが既にわかっている状況を想定\n予定砲撃距離 \\(r_0\\) は \\(\\operatorname{Uniform}(2, 30)\\) の事前分布がある\n\ndata {\n    int&lt;lower=1&gt; N;  // Number of data points\n    array[N] real y; // outcomes\n    array[N] real x; // outcomes\n}\n\nparameters {\n    real&lt;lower=0&gt; r_0; // probability of success\n    real x_0;             // Center x-coordinate\n    real y_0;             // Center y-coordinate\n}\n\nmodel {\n    // priors\n    r_0 ~ uniform(2, 30);\n    real sigma = 1;\n\n    // objective loss\n    array[N] real circle_equation;\n    for (i in 1:N) {\n        circle_equation[i] = sqrt((x[i] - x_0)^2 + (y[i] - y_0)^2) - r_0;\n    }\n\n    circle_equation ~ normal(0, sigma);\n}\nその後，このモデルを用いて推定したものが以下となります．\n\nfrom cmdstanpy import CmdStanModel\n\ndf_stan = gpd_dataframe(0, 0, 1)\ndata = {\n    \"N\": df_stan.shape[0],\n    \"y\": df_stan.y_coordinate.values,\n    \"x\": df_stan.x_coordinate.values,\n    \"sigma\": 1,\n}\n\nmodel = CmdStanModel(stan_file=\"./stanmodel.stan\")\nfit = model.sample(data=data, seed=42)\nfit.summary()\n\n14:58:05 - cmdstanpy - INFO - compiling stan file /home/runner/work/regmonkey-datascience-blog/regmonkey-datascience-blog/posts/2025-03-02-find-coordinates/stanmodel.stan to exe file /home/runner/work/regmonkey-datascience-blog/regmonkey-datascience-blog/posts/2025-03-02-find-coordinates/stanmodel\n14:58:12 - cmdstanpy - INFO - compiled model executable: /home/runner/work/regmonkey-datascience-blog/regmonkey-datascience-blog/posts/2025-03-02-find-coordinates/stanmodel\n14:58:12 - cmdstanpy - INFO - CmdStan start processing\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n                                                                                                                                                                                                                                                                                                                                \n\n\n14:58:14 - cmdstanpy - INFO - CmdStan done processing.\n14:58:14 - cmdstanpy - WARNING - Some chains may have failed to converge.\n    Chain 1 had 310 divergent transitions (31.0%)\n    Chain 2 had 341 divergent transitions (34.1%)\n    Chain 3 had 293 divergent transitions (29.3%)\n    Chain 4 had 321 divergent transitions (32.1%)\n    Use the \"diagnose()\" method on the CmdStanMCMC object to see further information.\n\n\n\n\n\n\n\n\n\n\n\n\nMean\nMCSE\nStdDev\nMAD\n5%\n50%\n95%\nESS_bulk\nESS_tail\nR_hat\n\n\n\n\nlp__\n-22.627700\n0.044143\n1.21901\n0.873029\n-25.04740\n-22.267300\n-21.44630\n886.927\n1292.320\n1.00150\n\n\nr_0\n20.167700\n0.429917\n6.21166\n7.274600\n9.15979\n20.889900\n29.01690\n208.132\n258.641\n1.01910\n\n\nx_0\n0.151580\n0.131551\n1.88887\n1.973310\n-3.05708\n0.195963\n3.10467\n199.726\n234.533\n1.02554\n\n\ny_0\n-0.299075\n0.419656\n6.11452\n7.154340\n-8.93022\n-1.015920\n10.49850\n220.609\n278.533\n1.01959\n\n\n\n\n\n\n\nCredible intervalを見ると \\((0, 0)\\) は推定区間に含まれている一方，Mean, Medianともに \\(y_0\\) の方は乖離した値が推定されてしまっています．"
  },
  {
    "objectID": "posts/2025-03-01-herons-formula/index.html",
    "href": "posts/2025-03-01-herons-formula/index.html",
    "title": "ヘロンの公式の導出",
    "section": "",
    "text": "Theorem 1 : ヘロンの公式 \n\\(\\triangle ABC\\) の3辺の長さがそれぞれ \\(a, b, c\\) で与えられているとき，\n\\[\ns = \\frac{1}{2}(a + b + c)\n\\]\nとおくと，\\(\\triangle ABC\\) の面積 \\(S\\) は\n\\[\nS = \\sqrt{s(s-a)(s-b)(s-c)}\n\\]\n\n\n\n\n\n\n\n\n\n余弦定理を用いた証明\n\n\n\n\n\n3辺の長さがわかっているので，余弦定理より\n\\[\n\\begin{align}\na^2 &= b^2 + c^2 - 2bc\\cos A\\\\\n\\Rightarrow &\\cos A = \\frac{b^2+c^2-a^2}{2bc}\n\\end{align}\n\\]\n\\(\\sin^2 A + \\cos^2 A = 1\\) より\n\\[\n\\sin A = \\sqrt{1 - \\cos^2 A}\n\\]\n従って，面積 \\(S\\) は\n\\[\nS = \\frac{1}{2}bc\\sqrt{1 - \\cos^2 A}\n\\]\nこれを展開すると\n\\[\n\\begin{align}\nS\n    &= \\frac{1}{2}bc\\sqrt{1 - \\cos^2 A}\\\\\n    &= \\frac{1}{2}bc\\sqrt{1 - \\frac{(b^2+c^2-a^2)^2}{4b^2c^2}}\\\\\n    &= \\frac{1}{2}\\sqrt{b^2c^2 - \\left(\\frac{(b^2+c^2-a^2)}{2}\\right)^2}\\\\\n    &= \\frac{1}{2}\\sqrt{\\left(-\\frac{b^2+c^2-a^2-2bc}{2}\\right)\\left(\\frac{b^2+c^2-a^2+2bc}{2}\\right)}\\\\\n    &= \\frac{1}{2}\\sqrt{\\left(-\\frac{(b-c)^2-a^2}{2}\\right)\\left(\\frac{(b+c)^2-a^2}{2}\\right)}\\\\\n    &= \\frac{1}{2}\\sqrt{\\frac{(a+b-c)(a+c-b)}{2}\\frac{(a+b+c)(b+c-a)}{2}}\\\\\n    &= \\sqrt{\\frac{(a+b-c)}{2}\\frac{(a+c-b)}{2}\\frac{(a+b+c)}{2}\\frac{(b+c-a)}{2}}\\\\\n    &= \\sqrt{s(s-a)(s-b)(s-c)}\n\\end{align}\n\\]\n\n\n\n\n\n\n\n\n\n\n三角形の傍接円からのヘロンの公式\n\n\n\n\n\n下記のように \\(\\triangle ABC\\) について内心 \\(D\\) と傍心 \\(G\\) を考えます．\n\n前準備として \\(\\triangle ABC\\) のそれぞれの角の対辺を \\(a, b, c\\) として\n\\[\ns = \\frac{1}{2}(a + b + c)\n\\]\nと変数 \\(s\\) を定義します．また，内接円の性質（各頂点の内角の二等分線上に内心が存在）より\n\\[\n\\begin{align}\nAH &= AN\\\\\nCN &= CI\\\\\nBH &= BI\n\\end{align}\n\\]\n従って，\n\\[\n\\begin{align}\nAH &= s - a\\\\\nBH &= s - b\\\\\nCN &= s = c\n\\end{align}\n\\]\n傍接円の傍心 \\(G\\) は\n\n\\(\\angle A\\) の二等分線上\n\\(B\\) と \\(C\\)の外角の二等分線上\n\nに存在することから\n\\[\nAL = AE\n\\]\nまた，\n\\[\n\\begin{align}\nAL + AE\n    &= (AC + CL) + (AB + BE)\\\\\n    &= (AC + CO) + (AB + BO)\\\\\n    &=  a + b + c\\\\\n    &= 2s\n\\end{align}\n\\]\n従って，\n\\[\nAL = AE = s\n\\]\n内接円の内心 \\(D\\) が \\(\\angle B, \\angle C\\) の二等分線上に存在するので\n\\[\n\\begin{align}\n180^\\circ\n    &= 2\\angle HBD + 2\\angle EBG\\\\\n\\Rightarrow & 90^\\circ = \\angle HBD + \\angle EBG\n\\end{align}\n\\]\n従って，\n\\[\n\\begin{align}\n\\angle BDH &= \\angle EBG\n\\angle HBD &= \\angle BGE\n\\end{align}\n\\]\nここから\n\\[\n\\triangle HBD \\sim \\triangle EGB\n\\]\nこれより\n\\[\n\\frac{s - b}{r_1}=\\frac{r_2}{s - c}\n\\]\nこれを整理すると\n\\[\nr_1r_2 = (s-b)(s-c) \\label{#eq-1}\n\\]\nまた，\\(\\triangle HDE\\) と \\(\\triangle HDO\\) の面積が等しいことから\n\\[\nsr_1 = (s-a)r_2  \\label{#eq-2}\n\\]\n\\(\\eqref{#eq-1}\\), \\(\\eqref{#eq-2}\\) を 掛け合わせて \\(r_2\\) を両辺から除して \\(s\\) を両辺にかけると\n\\[\ns^2r_1^2 = s(s-a)(s-b)(s-c)\n\\]\n従って\n\\[\nsr_1 = \\sqrt{s(s-a)(s-b)(s-c)}\n\\]\nLHSは \\(\\triangle ABC\\) の面積と一致するので，これでヘロンの公式が示された．"
  },
  {
    "objectID": "posts/2025-03-01-herons-formula/index.html#辺から三角形の面積を求める",
    "href": "posts/2025-03-01-herons-formula/index.html#辺から三角形の面積を求める",
    "title": "ヘロンの公式の導出",
    "section": "",
    "text": "Theorem 1 : ヘロンの公式 \n\\(\\triangle ABC\\) の3辺の長さがそれぞれ \\(a, b, c\\) で与えられているとき，\n\\[\ns = \\frac{1}{2}(a + b + c)\n\\]\nとおくと，\\(\\triangle ABC\\) の面積 \\(S\\) は\n\\[\nS = \\sqrt{s(s-a)(s-b)(s-c)}\n\\]\n\n\n\n\n\n\n\n\n\n余弦定理を用いた証明\n\n\n\n\n\n3辺の長さがわかっているので，余弦定理より\n\\[\n\\begin{align}\na^2 &= b^2 + c^2 - 2bc\\cos A\\\\\n\\Rightarrow &\\cos A = \\frac{b^2+c^2-a^2}{2bc}\n\\end{align}\n\\]\n\\(\\sin^2 A + \\cos^2 A = 1\\) より\n\\[\n\\sin A = \\sqrt{1 - \\cos^2 A}\n\\]\n従って，面積 \\(S\\) は\n\\[\nS = \\frac{1}{2}bc\\sqrt{1 - \\cos^2 A}\n\\]\nこれを展開すると\n\\[\n\\begin{align}\nS\n    &= \\frac{1}{2}bc\\sqrt{1 - \\cos^2 A}\\\\\n    &= \\frac{1}{2}bc\\sqrt{1 - \\frac{(b^2+c^2-a^2)^2}{4b^2c^2}}\\\\\n    &= \\frac{1}{2}\\sqrt{b^2c^2 - \\left(\\frac{(b^2+c^2-a^2)}{2}\\right)^2}\\\\\n    &= \\frac{1}{2}\\sqrt{\\left(-\\frac{b^2+c^2-a^2-2bc}{2}\\right)\\left(\\frac{b^2+c^2-a^2+2bc}{2}\\right)}\\\\\n    &= \\frac{1}{2}\\sqrt{\\left(-\\frac{(b-c)^2-a^2}{2}\\right)\\left(\\frac{(b+c)^2-a^2}{2}\\right)}\\\\\n    &= \\frac{1}{2}\\sqrt{\\frac{(a+b-c)(a+c-b)}{2}\\frac{(a+b+c)(b+c-a)}{2}}\\\\\n    &= \\sqrt{\\frac{(a+b-c)}{2}\\frac{(a+c-b)}{2}\\frac{(a+b+c)}{2}\\frac{(b+c-a)}{2}}\\\\\n    &= \\sqrt{s(s-a)(s-b)(s-c)}\n\\end{align}\n\\]\n\n\n\n\n\n\n\n\n\n\n三角形の傍接円からのヘロンの公式\n\n\n\n\n\n下記のように \\(\\triangle ABC\\) について内心 \\(D\\) と傍心 \\(G\\) を考えます．\n\n前準備として \\(\\triangle ABC\\) のそれぞれの角の対辺を \\(a, b, c\\) として\n\\[\ns = \\frac{1}{2}(a + b + c)\n\\]\nと変数 \\(s\\) を定義します．また，内接円の性質（各頂点の内角の二等分線上に内心が存在）より\n\\[\n\\begin{align}\nAH &= AN\\\\\nCN &= CI\\\\\nBH &= BI\n\\end{align}\n\\]\n従って，\n\\[\n\\begin{align}\nAH &= s - a\\\\\nBH &= s - b\\\\\nCN &= s = c\n\\end{align}\n\\]\n傍接円の傍心 \\(G\\) は\n\n\\(\\angle A\\) の二等分線上\n\\(B\\) と \\(C\\)の外角の二等分線上\n\nに存在することから\n\\[\nAL = AE\n\\]\nまた，\n\\[\n\\begin{align}\nAL + AE\n    &= (AC + CL) + (AB + BE)\\\\\n    &= (AC + CO) + (AB + BO)\\\\\n    &=  a + b + c\\\\\n    &= 2s\n\\end{align}\n\\]\n従って，\n\\[\nAL = AE = s\n\\]\n内接円の内心 \\(D\\) が \\(\\angle B, \\angle C\\) の二等分線上に存在するので\n\\[\n\\begin{align}\n180^\\circ\n    &= 2\\angle HBD + 2\\angle EBG\\\\\n\\Rightarrow & 90^\\circ = \\angle HBD + \\angle EBG\n\\end{align}\n\\]\n従って，\n\\[\n\\begin{align}\n\\angle BDH &= \\angle EBG\n\\angle HBD &= \\angle BGE\n\\end{align}\n\\]\nここから\n\\[\n\\triangle HBD \\sim \\triangle EGB\n\\]\nこれより\n\\[\n\\frac{s - b}{r_1}=\\frac{r_2}{s - c}\n\\]\nこれを整理すると\n\\[\nr_1r_2 = (s-b)(s-c) \\label{#eq-1}\n\\]\nまた，\\(\\triangle HDE\\) と \\(\\triangle HDO\\) の面積が等しいことから\n\\[\nsr_1 = (s-a)r_2  \\label{#eq-2}\n\\]\n\\(\\eqref{#eq-1}\\), \\(\\eqref{#eq-2}\\) を 掛け合わせて \\(r_2\\) を両辺から除して \\(s\\) を両辺にかけると\n\\[\ns^2r_1^2 = s(s-a)(s-b)(s-c)\n\\]\n従って\n\\[\nsr_1 = \\sqrt{s(s-a)(s-b)(s-c)}\n\\]\nLHSは \\(\\triangle ABC\\) の面積と一致するので，これでヘロンの公式が示された．"
  },
  {
    "objectID": "posts/2024-12-07-meta-address/index.html",
    "href": "posts/2024-12-07-meta-address/index.html",
    "title": "IPアドレス 0.0.0.0",
    "section": "",
    "text": "pythonでhttp serverを立てて，Quartoで作成したウェブサイトを以下のコマンドで公開するとします\n% python -m http.server 3000 --directory ./_site/\nServing HTTP on 0.0.0.0 port 3000 (http://0.0.0.0:3000/) ..\nバインド先を設定せずにserverを立ち上げたところ，0.0.0.0 で立ち上げているようです． このとき，Firewallの3000 portをホスト側でAllowすると，同じnetworkの他の端末(例:iPad)からでもアクセスできるようになりました．\n ▶  プライベートIPアドレスをバインド先に指定した場合 \n自宅内のネットワークのみで有効なプライベートIPアドレス（クラスC 192.168.0.0 ~ 192.168.255.255）を指定してhttp serverを立たてみます．\n% python -m http.server 3000 --directory ./_site/ --bind 192.168.10.105\nServing HTTP on 192.168.10.105 port 3000 (http://192.168.10.105:3000/) ...\nこのとき，同じネットワーク内にあるiPadからアクセスできるようになりました． iPad側では http://192.168.10.105:3000 に接続することでQuarto contentsにアクセスできるようになりましたが， このiPad側での操作は 0.0.0.0 で立ち上げたときと同じ操作となります．\n\n❓ Question \npython http.server を使用して 0.0.0.0 にバインドしてhttp serverを立てたときの挙動がプライベートネットワーク内部で割り当てられたプライベートIPアドレスを指定したときと同じ挙動をするのか？\n\n\n\nIPv4において 0.0.0.0 (IPv6では::/0) はSepcial-Purpose Address Registry，つまり特別な目的用に予約されたアドレスです．\n\nRFC6890\n\n\n\n\n\n\nAttribute\nValue\n\n\n\n\nAddress Block\n0.0.0.0/8\n\n\nName\nThis host on this network\n\n\nRFC\n[RFC1122], Section 3.2.1.3\n\n\nAllocation Date\nSeptember 1981\n\n\nTermination Date\nN/A\n\n\nSource\nTrue\n\n\nDestination\nFalse\n\n\nForwardable\nFalse\n\n\nGlobal\nFalse\n\n\nReserved-by-Protocol\nTrue\n\n\n\n上記より0.0.0.0 ~ 0.255.255.255について以下の情報を得ることができます\n\nGlobalセクションがFalseとなっていることから，グローバルIPアドレスとして使用できない．利用はローカルネットワークに限定される\nSourceセクションTrueより，送信元アドレスとして有効\nDestinationセクションFalseより，宛先アドレスとして使用できない = ルーティング不可\n\nただし，0.0.0.0の具体的な意味はここからではまだわかりません．\n ▶  0.0.0.0/0 vs 0.0.0.0/32 \n\n\n\n\n\n\n\n\nAttribute\n0.0.0.0/0\n0.0.0.0/32\n\n\n\n\nSubnet Mask\n0.0.0.0 (all bits variable)\n255.255.255.255 (all bits fixed)\n\n\nRange\nAll IPv4 addresses (0.0.0.0 to 255.255.255.255)\n0.0.0.0\n\n\n\n\n\n\nバインド先を指定しないでhttp serverを立てるとき，バインド先を指定しない = 有効な宛先がないことを意味します． このとき使用されるのが 0.0.0.0 です．\nこの文脈での 0.0.0.0 は catch-all wildcard と呼ばれるもので，同じネットワーク上のすべてのインターフェースに対して， バインドするという特別な意味を持っています．コンピューターが複数のネットワークに接続していて，すべてのネットワークにバインドしたい場合に 0.0.0.0を指定します．ただし，不必要に使用してしまうと誤って外部のネットワークに共有してしまったりするので使用は控えたほうが良いです．\n\n📘 REMARKS \n\nPython HTTP Serverにおける 0.0.0.0 はルーティングにおけるデフォルトルートとしての0.0.0.0は異なります\n文脈に応じて 0.0.0.0 が指す内容が異なることに注意してください\npython hhtp.serverの文脈では0.0.0.0にバインドすると以下のインターフェースからアクセス可能となります\n\nLocalhost (127.0.0.1)\nThe private network (例: 192.168.x.x)\nPublic network interfaces (Firewallでアクセスを許容していた場合)\n\n\n\nPython http serverをprivate networkに限定する意図を込めて，以下のスクリプトでホスティングすることが望ましいです\n$ python3 -m http.server -b &lt;your-local-private-network IP&gt; 8080 --directory ./_site/"
  },
  {
    "objectID": "posts/2024-12-07-meta-address/index.html#ipアドレス-0.0.0.0にバインド",
    "href": "posts/2024-12-07-meta-address/index.html#ipアドレス-0.0.0.0にバインド",
    "title": "IPアドレス 0.0.0.0",
    "section": "",
    "text": "pythonでhttp serverを立てて，Quartoで作成したウェブサイトを以下のコマンドで公開するとします\n% python -m http.server 3000 --directory ./_site/\nServing HTTP on 0.0.0.0 port 3000 (http://0.0.0.0:3000/) ..\nバインド先を設定せずにserverを立ち上げたところ，0.0.0.0 で立ち上げているようです． このとき，Firewallの3000 portをホスト側でAllowすると，同じnetworkの他の端末(例:iPad)からでもアクセスできるようになりました．\n ▶  プライベートIPアドレスをバインド先に指定した場合 \n自宅内のネットワークのみで有効なプライベートIPアドレス（クラスC 192.168.0.0 ~ 192.168.255.255）を指定してhttp serverを立たてみます．\n% python -m http.server 3000 --directory ./_site/ --bind 192.168.10.105\nServing HTTP on 192.168.10.105 port 3000 (http://192.168.10.105:3000/) ...\nこのとき，同じネットワーク内にあるiPadからアクセスできるようになりました． iPad側では http://192.168.10.105:3000 に接続することでQuarto contentsにアクセスできるようになりましたが， このiPad側での操作は 0.0.0.0 で立ち上げたときと同じ操作となります．\n\n❓ Question \npython http.server を使用して 0.0.0.0 にバインドしてhttp serverを立てたときの挙動がプライベートネットワーク内部で割り当てられたプライベートIPアドレスを指定したときと同じ挙動をするのか？\n\n\n\nIPv4において 0.0.0.0 (IPv6では::/0) はSepcial-Purpose Address Registry，つまり特別な目的用に予約されたアドレスです．\n\nRFC6890\n\n\n\n\n\n\nAttribute\nValue\n\n\n\n\nAddress Block\n0.0.0.0/8\n\n\nName\nThis host on this network\n\n\nRFC\n[RFC1122], Section 3.2.1.3\n\n\nAllocation Date\nSeptember 1981\n\n\nTermination Date\nN/A\n\n\nSource\nTrue\n\n\nDestination\nFalse\n\n\nForwardable\nFalse\n\n\nGlobal\nFalse\n\n\nReserved-by-Protocol\nTrue\n\n\n\n上記より0.0.0.0 ~ 0.255.255.255について以下の情報を得ることができます\n\nGlobalセクションがFalseとなっていることから，グローバルIPアドレスとして使用できない．利用はローカルネットワークに限定される\nSourceセクションTrueより，送信元アドレスとして有効\nDestinationセクションFalseより，宛先アドレスとして使用できない = ルーティング不可\n\nただし，0.0.0.0の具体的な意味はここからではまだわかりません．\n ▶  0.0.0.0/0 vs 0.0.0.0/32 \n\n\n\n\n\n\n\n\nAttribute\n0.0.0.0/0\n0.0.0.0/32\n\n\n\n\nSubnet Mask\n0.0.0.0 (all bits variable)\n255.255.255.255 (all bits fixed)\n\n\nRange\nAll IPv4 addresses (0.0.0.0 to 255.255.255.255)\n0.0.0.0\n\n\n\n\n\n\nバインド先を指定しないでhttp serverを立てるとき，バインド先を指定しない = 有効な宛先がないことを意味します． このとき使用されるのが 0.0.0.0 です．\nこの文脈での 0.0.0.0 は catch-all wildcard と呼ばれるもので，同じネットワーク上のすべてのインターフェースに対して， バインドするという特別な意味を持っています．コンピューターが複数のネットワークに接続していて，すべてのネットワークにバインドしたい場合に 0.0.0.0を指定します．ただし，不必要に使用してしまうと誤って外部のネットワークに共有してしまったりするので使用は控えたほうが良いです．\n\n📘 REMARKS \n\nPython HTTP Serverにおける 0.0.0.0 はルーティングにおけるデフォルトルートとしての0.0.0.0は異なります\n文脈に応じて 0.0.0.0 が指す内容が異なることに注意してください\npython hhtp.serverの文脈では0.0.0.0にバインドすると以下のインターフェースからアクセス可能となります\n\nLocalhost (127.0.0.1)\nThe private network (例: 192.168.x.x)\nPublic network interfaces (Firewallでアクセスを許容していた場合)\n\n\n\nPython http serverをprivate networkに限定する意図を込めて，以下のスクリプトでホスティングすることが望ましいです\n$ python3 -m http.server -b &lt;your-local-private-network IP&gt; 8080 --directory ./_site/"
  },
  {
    "objectID": "posts/2024-12-07-meta-address/index.html#references",
    "href": "posts/2024-12-07-meta-address/index.html#references",
    "title": "IPアドレス 0.0.0.0",
    "section": "References",
    "text": "References\n\nRFC5735"
  },
  {
    "objectID": "posts/2025-01-27-differentiation_of_exponential_function/index.html",
    "href": "posts/2025-01-27-differentiation_of_exponential_function/index.html",
    "title": "指数関数の微分",
    "section": "",
    "text": "底 \\(a&gt;1\\) のとき，\n\n指数関数 \\(y = a^x\\) は区間 \\(-\\infty &lt; x &lt; \\infty\\) において連続かつ単調増大で, \\(y \\in (0, \\infty)\\)\n対数関数 \\(y = \\log_a x\\) は \\(y = a^x\\) の逆関数で，区間 \\(0 &lt; x &lt; \\infty\\) において連続かつ単調増大で, \\(y \\in (\\infty, \\infty)\\)\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# PARAMS\nbase = 2\nN = 1000 # data points\nmin_lim = -2\nmax_lim = 5\nx = np.linspace(min_lim, max_lim, N)\n\n# exponential\ny_exp = base ** x\n\n# logarithm\ny_log = np.log(x[x&gt;0]) / np.log(base) \n\n# plot\nfig, ax = plt.subplots(ncols=1)\nax.plot(x, y_exp, label='$ y = a^x$')\nax.plot(x[x&gt;0], y_log, label='$y = \\log_a x$')\nax.plot(x*0.8, x*0.8, label='45 Degree Line', linestyle='--', color='gray')\nax.axhline(0, color='black', linewidth=0.5)\nax.axvline(0, color='black', linewidth=0.5)\nax.set_xlim(min_lim, max_lim)\nax.set_xticks([])\nax.set_yticks([])\nax.text(0, 0, 'O', fontsize=12, ha='right')\nax.text(1, -0.5, '1', fontsize=12, ha='right')\nax.text(0, 1, '1', fontsize=12, ha='right')\nax.set_ylim(min_lim, max_lim)\nax.set_xlabel('$x$')\nax.set_ylabel('$y$')\nfor spine in ax.spines.values():\n    spine.set_visible(False)\nax.legend()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 1: 指数関数と対数関数\n\n\n\n\n\nTheorem 1 \n任意の \\(a &gt; 0\\) に対して，\\(y = a^x\\) の導関数は\n\\[\n\\frac{d(a^x)}{dx} = a^x\\log a\n\\]\n\n\n\n\n\n\n\n\n\nProof\n\n\n\n\n\n\\(a &gt; 1\\) のケースを考える\n\\[\n\\begin{align}\n\\frac{d(a^x)}{dx}\n    &= \\lim_{h\\to 0}\\frac{a^{x+h} - a^x}{h}\\\\\n    &= a^x\\lim_{h\\to 0}\\frac{a^{h} - 1}{h}\\label{base-eq}\n\\end{align}\n\\]\n ▶  \\(h &gt; 0\\)の場合\n\\(h &gt; 0\\) であるならば，\\(a^h &gt; 1\\)．よって\n\\[\na^h = 1 + \\frac{1}{t}\n\\]\nとおくと，\\(t &gt; 0\\)．指数関数の連続性より，\\(h\\to 0\\) のとき，\\(a^h\\to 1\\). 従って，\\(t\\to\\infty\\)．\nここで，\\(\\displaystyle h = \\log_a\\left(1 + \\frac{1}{t}\\right)\\) より\n\\[\n\\begin{align}\n\\frac{a^{h} - 1}{h}\n    & = \\frac{1/t}{\\log_a\\left(1 + \\frac{1}{t}\\right)}\\\\\n    &= \\frac{1}{\\log_a\\left(1 + \\frac{1}{t}\\right)^t}\n\\end{align}\n\\]\n\\[\n\\lim_{t\\to\\infty}\\left(1 + \\frac{1}{t}\\right)^t = e\n\\]\n対数関数 \\(\\log_a(x)\\) は連続関数なので，\\(h\\to 0\\) のとき，\\(\\log_a\\left(1 + \\frac{1}{t}\\right)^t\\to \\log_a e\\)．従って，\n\\[\n\\begin{align}\n\\lim_{h\\to 0}\\frac{a^{h} - 1}{h}\n    &= \\frac{1}{\\log_a e}\\\\\n    &= \\log a\n\\end{align}\n\\]\n ▶  \\(h &lt; 0\\)の場合\n\\(h = -z\\) を満たす \\(z&gt;0\\) を考える．このとき，\n\\[\n\\begin{align}\n\\frac{a^h - 1}{h}\n    &= \\frac{a^{-z} - 1}{-z}\\\\\n    &= \\frac{1 - a^z}{-z}\\frac{1}{a^z}\\\\\n    &= \\frac{a^z - 1}{z}\\frac{1}{a^z}\n\\end{align}\n\\]\n\\(z\\to 0\\) のとき，\\(a^z \\to 1\\) なので\n\\[\n\\frac{a^h - 1}{h}\\to \\log a\n\\]\n従って，\\(a &gt; 1\\) のとき，\\(\\displaystyle \\frac{d(a^x)}{dx} = a^x \\log a\\)\n ▶  \\(0 &lt; a &lt; 1\\) の場合 \n\\(\\eqref{base-eq}\\) と展開したとき，\\(h&gt;0\\) のとき \\(a^h &lt; 1\\) となるので\n\\[\na^h = 1 - \\frac{1}{t}\\qquad(t&gt;0)\n\\]\n指数関数の連続性より, \\(h\\to 0\\) のとき，\\(a^h\\to 0\\)，従って，\\(t\\to\\infty\\)．\n\\[\n\\begin{align}\n\\frac{a^h-1}{h}\n    &= \\frac{-\\frac{1}{t}}{\\log_a(1 - \\frac{1}{t})}\\\\\n    &= -\\frac{1}{\\log_a(1 - \\frac{1}{t})^{t}}\n\\end{align}\n\\]\nここで\n\\[\n\\lim_{t\\to\\infty} (1 - \\frac{1}{t})^{t} = \\frac{1}{e}\n\\]\nであるので，対数関数の連続性より，\\(h\\to 0\\) のとき \\(h\\to\\infty\\) だから\n\\[\n\\log_a\\left(1 - \\frac{1}{t}\\right)^{t}\\to \\log_a\\frac{1}{e} = -\\log_a e\n\\]\n従って，\n\\[\n\\lim_{h\\to 0}\\frac{a^h-1}{h} = \\log a\n\\]\n\\(h&lt;0\\) の場合も同様に示せるので，以上より\n任意の \\(a &gt; 0\\) に対して，\\(y = a^x\\) の導関数は\n\\[\n\\frac{d(a^x)}{dx} = a^x\\log a\n\\]\nが成立する．\n\n\n\n\n\n\\(a &gt; 0\\) としたとき，\n\\[\n\\log a^x = x\\log a\n\\]\nこのとき，両辺を \\(x\\) で微分すると\n\\[\n\\frac{D(a^x)}{a^x} = \\log a\n\\]\n従って，\n\\[\nD(a^x) = a^x\\log a\n\\]\nを得る．"
  },
  {
    "objectID": "posts/2025-01-27-differentiation_of_exponential_function/index.html#指数関数の微分",
    "href": "posts/2025-01-27-differentiation_of_exponential_function/index.html#指数関数の微分",
    "title": "指数関数の微分",
    "section": "",
    "text": "底 \\(a&gt;1\\) のとき，\n\n指数関数 \\(y = a^x\\) は区間 \\(-\\infty &lt; x &lt; \\infty\\) において連続かつ単調増大で, \\(y \\in (0, \\infty)\\)\n対数関数 \\(y = \\log_a x\\) は \\(y = a^x\\) の逆関数で，区間 \\(0 &lt; x &lt; \\infty\\) において連続かつ単調増大で, \\(y \\in (\\infty, \\infty)\\)\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# PARAMS\nbase = 2\nN = 1000 # data points\nmin_lim = -2\nmax_lim = 5\nx = np.linspace(min_lim, max_lim, N)\n\n# exponential\ny_exp = base ** x\n\n# logarithm\ny_log = np.log(x[x&gt;0]) / np.log(base) \n\n# plot\nfig, ax = plt.subplots(ncols=1)\nax.plot(x, y_exp, label='$ y = a^x$')\nax.plot(x[x&gt;0], y_log, label='$y = \\log_a x$')\nax.plot(x*0.8, x*0.8, label='45 Degree Line', linestyle='--', color='gray')\nax.axhline(0, color='black', linewidth=0.5)\nax.axvline(0, color='black', linewidth=0.5)\nax.set_xlim(min_lim, max_lim)\nax.set_xticks([])\nax.set_yticks([])\nax.text(0, 0, 'O', fontsize=12, ha='right')\nax.text(1, -0.5, '1', fontsize=12, ha='right')\nax.text(0, 1, '1', fontsize=12, ha='right')\nax.set_ylim(min_lim, max_lim)\nax.set_xlabel('$x$')\nax.set_ylabel('$y$')\nfor spine in ax.spines.values():\n    spine.set_visible(False)\nax.legend()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 1: 指数関数と対数関数\n\n\n\n\n\nTheorem 1 \n任意の \\(a &gt; 0\\) に対して，\\(y = a^x\\) の導関数は\n\\[\n\\frac{d(a^x)}{dx} = a^x\\log a\n\\]\n\n\n\n\n\n\n\n\n\nProof\n\n\n\n\n\n\\(a &gt; 1\\) のケースを考える\n\\[\n\\begin{align}\n\\frac{d(a^x)}{dx}\n    &= \\lim_{h\\to 0}\\frac{a^{x+h} - a^x}{h}\\\\\n    &= a^x\\lim_{h\\to 0}\\frac{a^{h} - 1}{h}\\label{base-eq}\n\\end{align}\n\\]\n ▶  \\(h &gt; 0\\)の場合\n\\(h &gt; 0\\) であるならば，\\(a^h &gt; 1\\)．よって\n\\[\na^h = 1 + \\frac{1}{t}\n\\]\nとおくと，\\(t &gt; 0\\)．指数関数の連続性より，\\(h\\to 0\\) のとき，\\(a^h\\to 1\\). 従って，\\(t\\to\\infty\\)．\nここで，\\(\\displaystyle h = \\log_a\\left(1 + \\frac{1}{t}\\right)\\) より\n\\[\n\\begin{align}\n\\frac{a^{h} - 1}{h}\n    & = \\frac{1/t}{\\log_a\\left(1 + \\frac{1}{t}\\right)}\\\\\n    &= \\frac{1}{\\log_a\\left(1 + \\frac{1}{t}\\right)^t}\n\\end{align}\n\\]\n\\[\n\\lim_{t\\to\\infty}\\left(1 + \\frac{1}{t}\\right)^t = e\n\\]\n対数関数 \\(\\log_a(x)\\) は連続関数なので，\\(h\\to 0\\) のとき，\\(\\log_a\\left(1 + \\frac{1}{t}\\right)^t\\to \\log_a e\\)．従って，\n\\[\n\\begin{align}\n\\lim_{h\\to 0}\\frac{a^{h} - 1}{h}\n    &= \\frac{1}{\\log_a e}\\\\\n    &= \\log a\n\\end{align}\n\\]\n ▶  \\(h &lt; 0\\)の場合\n\\(h = -z\\) を満たす \\(z&gt;0\\) を考える．このとき，\n\\[\n\\begin{align}\n\\frac{a^h - 1}{h}\n    &= \\frac{a^{-z} - 1}{-z}\\\\\n    &= \\frac{1 - a^z}{-z}\\frac{1}{a^z}\\\\\n    &= \\frac{a^z - 1}{z}\\frac{1}{a^z}\n\\end{align}\n\\]\n\\(z\\to 0\\) のとき，\\(a^z \\to 1\\) なので\n\\[\n\\frac{a^h - 1}{h}\\to \\log a\n\\]\n従って，\\(a &gt; 1\\) のとき，\\(\\displaystyle \\frac{d(a^x)}{dx} = a^x \\log a\\)\n ▶  \\(0 &lt; a &lt; 1\\) の場合 \n\\(\\eqref{base-eq}\\) と展開したとき，\\(h&gt;0\\) のとき \\(a^h &lt; 1\\) となるので\n\\[\na^h = 1 - \\frac{1}{t}\\qquad(t&gt;0)\n\\]\n指数関数の連続性より, \\(h\\to 0\\) のとき，\\(a^h\\to 0\\)，従って，\\(t\\to\\infty\\)．\n\\[\n\\begin{align}\n\\frac{a^h-1}{h}\n    &= \\frac{-\\frac{1}{t}}{\\log_a(1 - \\frac{1}{t})}\\\\\n    &= -\\frac{1}{\\log_a(1 - \\frac{1}{t})^{t}}\n\\end{align}\n\\]\nここで\n\\[\n\\lim_{t\\to\\infty} (1 - \\frac{1}{t})^{t} = \\frac{1}{e}\n\\]\nであるので，対数関数の連続性より，\\(h\\to 0\\) のとき \\(h\\to\\infty\\) だから\n\\[\n\\log_a\\left(1 - \\frac{1}{t}\\right)^{t}\\to \\log_a\\frac{1}{e} = -\\log_a e\n\\]\n従って，\n\\[\n\\lim_{h\\to 0}\\frac{a^h-1}{h} = \\log a\n\\]\n\\(h&lt;0\\) の場合も同様に示せるので，以上より\n任意の \\(a &gt; 0\\) に対して，\\(y = a^x\\) の導関数は\n\\[\n\\frac{d(a^x)}{dx} = a^x\\log a\n\\]\nが成立する．\n\n\n\n\n\n\\(a &gt; 0\\) としたとき，\n\\[\n\\log a^x = x\\log a\n\\]\nこのとき，両辺を \\(x\\) で微分すると\n\\[\n\\frac{D(a^x)}{a^x} = \\log a\n\\]\n従って，\n\\[\nD(a^x) = a^x\\log a\n\\]\nを得る．"
  },
  {
    "objectID": "posts/2024-12-18-secure-shell/index.html",
    "href": "posts/2024-12-18-secure-shell/index.html",
    "title": "Secure Shellの仕組み",
    "section": "",
    "text": "Def: Secure Shell \nSSH(Secure SHell)は，ネットワークで接続された他コンピューターを遠隔操作するためのプロトコルのこと\n\nSSHプロトコルには現在，SSH1とSSH2という２つのプロトコルがあります. それぞれのプロトコルには互換性はありません. 一般的には，SSH1プロトコルには脆弱性が発見されているのでSSH2を用います. Ubuntu Serverでは，デフォルトでSSH2のみが有効となっています.\n ▶  特徴\n\n強力な認証機能と暗号化により，ファイル転送やリモート操作を安全に行うことができる\nユーザーログイン時のユーザー認証に先立って，クライアントがサーバーの正当性を確認するホスト認証が毎回行われるため偽サーバーに接続することで発生する情報漏えいリスクを低減することができる\nクライアント側から ssh コマンドを用いてSSH接続を試みる場合は，接続先のコンピュータでsshd（SSH daemon：SSHのサーバプログラム）が 動作している必要がある\n\n\n\n\n\n\n\n\nSSH接続の認証手順\n\n\n\n\n\nSSH接続を試みる際の認証は\n\nホスト認証\nユーザー認証\n\nの２段階に分かれます\n ▶  ホスト認証\n\n\n\n\n\nsequenceDiagram\n    participant A as ssh(client)\n    participant B as sshd(server)\n    A-&gt;&gt;B: ssh接続要求\n    B-&gt;&gt;A: ホスト認証鍵をクライアントへ渡す\n    A-&gt;&gt;B: ホスト認証鍵で暗号化した乱数をサーバーへ渡す\n    B-&gt;&gt;A: ホスト認証鍵の秘密鍵で復号化し，そのハッシュ値を送付\n    Note over A,B: ハッシュ値を比較し一致していれば接続成功&lt;br&gt;=ホスト認証完了\n\n\n\n\n\n\n ▶  秘密鍵公開鍵によるユーザー認証\nユーザー認証はホスト認証完了後に行われる処理となります.\n\n\n\n\n\nsequenceDiagram\n    participant A as ssh(client)\n    participant B as sshd(server)\n    A--&gt;&gt;B: 公開鍵をサーバーに設置\n    A-&gt;&gt;B: ssh接続要求\n    B-&gt;&gt;A: 公開鍵で暗号化した乱数をssh側に渡す\n    A-&gt;&gt;B: 秘密鍵で復号化し，そのハッシュ値を送付\n    Note over A,B: ハッシュ値を比較し一致していれば接続成功&lt;br&gt;=ユーザー認証完了\n\n\n\n\n\n\n\n\n\n\n\n\nDef: ホスト認証 \n接続先が正当な相手であるのかどうかの認証のこと\n\nsshコマンドで初めてサーバーに接続するとき，サーバーから送られてきた公開鍵のフィンガープリントの値が表示される. このフィンガープリントをクライアント側で受け入れると，~/.ssh/known_hostsに以下の情報が登録されます\n\n接続先サーバーのホスト名\n接続先サーバーのIPアドレス\n接続先サーバーの公開鍵\n\n初回接続時の際は，接続先サーバーのホスト認証鍵を持っていないので,接続先ホストが登録されていない旨のWarningが表示されます. このとき，接続をこのまま続けるか？と聞かれます. yesと選択すると，SSH接続先サーバーが~/.ssh/known_hostsに登録されます.\n% ssh hogehoge@123.456.78.9\nThe authenticity of host '123.456.78.9 (123.456.78.9)' can not be established.\nECDSA key fingerprint is SHA256:ghzvH/1TBjI0wvlYiRNDJvUsiYAX/R9eip5bw6+Rv10.\nAre you sure you want to continue connecting (yes/no/[fingerprint])?\n$ yes\nWarning: Permanently added '123.456.78.9' (ECDSA) to the list of known hosts.\nPassword:\nLast login: Thu Apr 11 04:16:45 2021\n上記におけるECDSA key fingerprintSHA256:ghzvH/1TBjI0wvlYiRNDJvUsiYAX/R9eip5bw6+Rv10，の意味はSHA256で公開鍵をハッシュ化すると ghzvH/1TBjI0wvlYiRNDJvUsiYAX/R9eip5bw6+Rv10というフィンガープリントが発行されることを指しています.\n一度接続するとクライアントの known_hosts というファイルにサーバーの公開鍵が保存されるので，初回接続以降は自動的に認証が行われるため警告が表示されなくなります.\n ▶  WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED! \n目的外のサーバーに接続している場合やサーバーの公開鍵が変わっている場合，警告が表示されます.一般的にはホストキーの変更は滅多に行わなれないため、許可済みのサーバーに接続した際、 WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED! のような警告が出た場合は注意する必要があります.\n% ssh ubuntu@12.3.4.56\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n\n\n@@\nIT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!\nSomeone could be eavesdropping on you right now (man-in-the-middle attack)!\nIt is also possible that a host key has just been changed.\nThe fingerprint for the ECDSA key sent by the remote host is\nSHA256:tfZBzQ16o7O7SH6u4ixBmL061Sxz8DOo1cFZ9oMuGjE.\nPlease contact your system administrator.\nAdd correct host key in /home/hogehoge/.ssh/known_hosts to get rid of this message.\nOffending ECDSA key in /home/hogehoge/.ssh/known_hosts:4\n  remove with:\n  ssh-keygen -f \"/home/hogehoge/.ssh/known_hosts\" -R \"12.3.4.56\"\nECDSA host key for 12.3.4.56 has changed and you have requested strict checking.\nHost key verification failed.\n\n\n\nホスト認証後に実施されるユーザー認証は，デフォルトでは，公開鍵認証，パスワード認証の順に実施されます. 公開鍵認証を行うには予めクライアントの公開鍵を接続先サーバーに登録する必要があります.\n ▶  公開鍵の置き場所\n公開鍵によるユーザー認証を行うにはクライアントが作成した秘密鍵/公開鍵キーペアのうち，後者をサーバー側にコピーする必要があります. 一般的には\n\n~/.ssh/authorized_keysファイルに登録する\n~/.ssh/authorized_keys以外のファイルに保存したい場合は，サーバー側の設定ファイルsshd_configで明示的に参照ファイルを指定する\n\n\nExample 1 : sshd_config設定 \netc/ssh/sshd_config にて AuthorizedKeysFile フィールドに\nAuthorizedKeysFile     .ssh/authorized_keys .ssh/authorized_keys2\nと設定することで .ssh/authorized_keys，.ssh/authorized_keys2 の２つを公開鍵読み込みファイルとして認識させることができます"
  },
  {
    "objectID": "posts/2024-12-18-secure-shell/index.html#sshの仕組み",
    "href": "posts/2024-12-18-secure-shell/index.html#sshの仕組み",
    "title": "Secure Shellの仕組み",
    "section": "",
    "text": "Def: Secure Shell \nSSH(Secure SHell)は，ネットワークで接続された他コンピューターを遠隔操作するためのプロトコルのこと\n\nSSHプロトコルには現在，SSH1とSSH2という２つのプロトコルがあります. それぞれのプロトコルには互換性はありません. 一般的には，SSH1プロトコルには脆弱性が発見されているのでSSH2を用います. Ubuntu Serverでは，デフォルトでSSH2のみが有効となっています.\n ▶  特徴\n\n強力な認証機能と暗号化により，ファイル転送やリモート操作を安全に行うことができる\nユーザーログイン時のユーザー認証に先立って，クライアントがサーバーの正当性を確認するホスト認証が毎回行われるため偽サーバーに接続することで発生する情報漏えいリスクを低減することができる\nクライアント側から ssh コマンドを用いてSSH接続を試みる場合は，接続先のコンピュータでsshd（SSH daemon：SSHのサーバプログラム）が 動作している必要がある\n\n\n\n\n\n\n\n\nSSH接続の認証手順\n\n\n\n\n\nSSH接続を試みる際の認証は\n\nホスト認証\nユーザー認証\n\nの２段階に分かれます\n ▶  ホスト認証\n\n\n\n\n\nsequenceDiagram\n    participant A as ssh(client)\n    participant B as sshd(server)\n    A-&gt;&gt;B: ssh接続要求\n    B-&gt;&gt;A: ホスト認証鍵をクライアントへ渡す\n    A-&gt;&gt;B: ホスト認証鍵で暗号化した乱数をサーバーへ渡す\n    B-&gt;&gt;A: ホスト認証鍵の秘密鍵で復号化し，そのハッシュ値を送付\n    Note over A,B: ハッシュ値を比較し一致していれば接続成功&lt;br&gt;=ホスト認証完了\n\n\n\n\n\n\n ▶  秘密鍵公開鍵によるユーザー認証\nユーザー認証はホスト認証完了後に行われる処理となります.\n\n\n\n\n\nsequenceDiagram\n    participant A as ssh(client)\n    participant B as sshd(server)\n    A--&gt;&gt;B: 公開鍵をサーバーに設置\n    A-&gt;&gt;B: ssh接続要求\n    B-&gt;&gt;A: 公開鍵で暗号化した乱数をssh側に渡す\n    A-&gt;&gt;B: 秘密鍵で復号化し，そのハッシュ値を送付\n    Note over A,B: ハッシュ値を比較し一致していれば接続成功&lt;br&gt;=ユーザー認証完了\n\n\n\n\n\n\n\n\n\n\n\n\nDef: ホスト認証 \n接続先が正当な相手であるのかどうかの認証のこと\n\nsshコマンドで初めてサーバーに接続するとき，サーバーから送られてきた公開鍵のフィンガープリントの値が表示される. このフィンガープリントをクライアント側で受け入れると，~/.ssh/known_hostsに以下の情報が登録されます\n\n接続先サーバーのホスト名\n接続先サーバーのIPアドレス\n接続先サーバーの公開鍵\n\n初回接続時の際は，接続先サーバーのホスト認証鍵を持っていないので,接続先ホストが登録されていない旨のWarningが表示されます. このとき，接続をこのまま続けるか？と聞かれます. yesと選択すると，SSH接続先サーバーが~/.ssh/known_hostsに登録されます.\n% ssh hogehoge@123.456.78.9\nThe authenticity of host '123.456.78.9 (123.456.78.9)' can not be established.\nECDSA key fingerprint is SHA256:ghzvH/1TBjI0wvlYiRNDJvUsiYAX/R9eip5bw6+Rv10.\nAre you sure you want to continue connecting (yes/no/[fingerprint])?\n$ yes\nWarning: Permanently added '123.456.78.9' (ECDSA) to the list of known hosts.\nPassword:\nLast login: Thu Apr 11 04:16:45 2021\n上記におけるECDSA key fingerprintSHA256:ghzvH/1TBjI0wvlYiRNDJvUsiYAX/R9eip5bw6+Rv10，の意味はSHA256で公開鍵をハッシュ化すると ghzvH/1TBjI0wvlYiRNDJvUsiYAX/R9eip5bw6+Rv10というフィンガープリントが発行されることを指しています.\n一度接続するとクライアントの known_hosts というファイルにサーバーの公開鍵が保存されるので，初回接続以降は自動的に認証が行われるため警告が表示されなくなります.\n ▶  WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED! \n目的外のサーバーに接続している場合やサーバーの公開鍵が変わっている場合，警告が表示されます.一般的にはホストキーの変更は滅多に行わなれないため、許可済みのサーバーに接続した際、 WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED! のような警告が出た場合は注意する必要があります.\n% ssh ubuntu@12.3.4.56\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n\n\n@@\nIT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!\nSomeone could be eavesdropping on you right now (man-in-the-middle attack)!\nIt is also possible that a host key has just been changed.\nThe fingerprint for the ECDSA key sent by the remote host is\nSHA256:tfZBzQ16o7O7SH6u4ixBmL061Sxz8DOo1cFZ9oMuGjE.\nPlease contact your system administrator.\nAdd correct host key in /home/hogehoge/.ssh/known_hosts to get rid of this message.\nOffending ECDSA key in /home/hogehoge/.ssh/known_hosts:4\n  remove with:\n  ssh-keygen -f \"/home/hogehoge/.ssh/known_hosts\" -R \"12.3.4.56\"\nECDSA host key for 12.3.4.56 has changed and you have requested strict checking.\nHost key verification failed.\n\n\n\nホスト認証後に実施されるユーザー認証は，デフォルトでは，公開鍵認証，パスワード認証の順に実施されます. 公開鍵認証を行うには予めクライアントの公開鍵を接続先サーバーに登録する必要があります.\n ▶  公開鍵の置き場所\n公開鍵によるユーザー認証を行うにはクライアントが作成した秘密鍵/公開鍵キーペアのうち，後者をサーバー側にコピーする必要があります. 一般的には\n\n~/.ssh/authorized_keysファイルに登録する\n~/.ssh/authorized_keys以外のファイルに保存したい場合は，サーバー側の設定ファイルsshd_configで明示的に参照ファイルを指定する\n\n\nExample 1 : sshd_config設定 \netc/ssh/sshd_config にて AuthorizedKeysFile フィールドに\nAuthorizedKeysFile     .ssh/authorized_keys .ssh/authorized_keys2\nと設定することで .ssh/authorized_keys，.ssh/authorized_keys2 の２つを公開鍵読み込みファイルとして認識させることができます"
  },
  {
    "objectID": "posts/2024-12-18-secure-shell/index.html#ssh-コマンドの実践",
    "href": "posts/2024-12-18-secure-shell/index.html#ssh-コマンドの実践",
    "title": "Secure Shellの仕組み",
    "section": "ssh コマンドの実践",
    "text": "ssh コマンドの実践\n\nsshコマンド\nSSHを使ってサーバーに接続するには，以下のようにsshコマンドを使います. 終了する場合は，exit，または Ctrl + Dを入力します.\n% ssh [option] &lt;username&gt;@&lt;hostname&gt;\n\n\n\n\n\n\n\nOption\n説明\n\n\n\n\n-p ポート番号\n接続に使用するポート番号を指定する\n\n\n-l ユーザー名\n接続に使用するユーザー名を指定する\n\n\n-i IDファイル\n接続に使用する公開鍵ファイルを指定する\n\n\n-f\nコマンドを実行する際にsshをバックグラウンドにする（Xアプリケーションを実行する際に使用）\n\n\n-F 設定ファイル\n設定ファイルを指定する\n\n\n\n ▶  接続先情報の設定ファイル: ~/.ssh/config\nsshコマンド実行時のオプションを~/.ssh/configで登録することができます.\nHost DEDEDE\n  HostName 100.21.209.82\n  User kirby_MBP\n  Port 1000\n  IdentityFile ~/.ssh/my_id_rsa\n  LocalForward 9999 localhost:9999\nと設定すると以下のコマンドは同じ挙動になります\n% ssh DEDEDE\n% ssh kirby_MBP@100.21.209.82 -p 1000 -i ~/.ssh/my_id_rsa -L 9999:localhost:9999\n\n\nssh-keygenコマンドによる認証鍵生成\n% ssh-keygen [option]\n\n\n\n\n\n\n\nOption\n説明\n\n\n\n\n-t タイプ\n暗号化タイプの指定\n\n\n-l\n鍵のフィンガープリントを表示する\n\n\n-f ファイル名\n鍵ファイルを指定する（生成または読み出すファイルを指定）\n\n\n-R ホスト名\n指定したホスト情報をknwon_hostsファイルから削除する\n\n\n-C コメント\nコメントを指定する（デフォルトは「ユーザー名@ホスト名」。「-C ““」でコメントを削除）\n\n\n\n ▶  暗号化アルゴリズムの種類\n\n\n\n\n\n\n\nSSH version\nssh-keygenコマンド\n\n\n\n\nSSH1 RSA\nssh-keygen -t rsa1\n\n\nSSH2 DSA\nssh-keygen -t dsa\n\n\nSSH2 RSA\nssh-keygen -t rsa\n\n\nSSH2 ECDSA\nssh-keygen -t ecdsa\n\n\nSSH2 ED25519\nssh-keygen -t ed25519\n\n\n\n\n\n\n\n\n\n🍵 ED25519のススメ\n\n\n\nGitHubやGitLabのドキュメントを確認すると，ED25519の使用が推奨されています.\nGitLabより引用すると\n\nThe book Practical Cryptography With Go suggests that ED25519 keys are more secure and performant than RSA keys. OpenSSH 6.5 introduced ED25519 SSH keys in 2014，and they should be available on most operating systems.\n\nED25519は以下のような特徴があります\n\n楕円曲線を用いた暗号\nRSAやDSAの鍵長の約半分以下で同等のセキュリティ強度が得られる\n鍵長が短いので，暗号化/復号化の計算を高速に行える\n\n従って，以下のコマンドで鍵を生成するようにしてください.\n% ssh-keygen -t e\n\n\n ▶  鍵の生成\nssh-keygenコマンドを使うと\n\n鍵ファイル名の指定（そのままEnterを入力するとデフォルトのファイル名となる）\nパスフレーズの入力（特別な理由がない限り設定する）\n\nが求められます. 特段の事情がない限り個人的には設定する方針としています. なお生成される公開鍵には，デフォルトではユーザ名とホスト名がコメントとして記載されています(以下の例ではhoge@foofoo)\n% ssh-keygen -t ed25519                                           \nGenerating public/private ed25519 key pair.\nEnter file in which to save the key (/home/hogehoge/.ssh/id_ed25519): hogehoge_ed25519\nEnter passphrase (empty for no passphrase): \nEnter same passphrase again: \nYour identification has been saved in hogehoge_ed25519\nYour public key has been saved in hogehoge_ed25519.pub\nThe key fingerprint is:\nSHA256:MnM1r0IqwugnLCTEnSHjuPoTk7mdmSMExw+r5cOkrwQ hoge@foofoo\nThe key's randomart image is:\n+--[ED25519 256]--+\n|@+%.  o  o       |\n|.o.Eo *  + S     |\n|. o..oo +        |\n|@+%.  o  o       |\n| .oo=.= S =      |\n|   ..B o + +     |\n|    = * . o .    |\n| o++o            |\n|+B==.. ....      |\n+----[SHA256]-----+\n秘密鍵の作成後，誤って内容が書き換わってしまうリスクを抑えるため，Permissionを400に設定しときます:\n% sudo chmod 400 id_ed25519\n\n\nssh-copy-idコマンド: 接続先ホストへの公開鍵登録\n鍵ペア作成後，公開鍵を接続先ホストへ登録する必要あります. この時使われるコマンドが ssh-copy-idコマンドです. なお，初回登録時点では接続先ホストではパスワード認証によるログインが許可されている必要があります.\n\nExample 2 : ssh-copy-idコマンド \n以下のコマンドで接続先サーバーの.ssh/authorized_keysに公開鍵を追記することができます\n% ssh-copy-id [-p ポート番号] -i 公開鍵ファイル名 USERNAME@$HOST\n\n# 以下のコマンドと同義\n# cat 公開鍵ファイル名 \\\n#  | ssh -p ポート番号 USERNAME@$HOST \\\n#  \"mkdir -p ~/.ssh; cat &gt;&gt; ~/.ssh/authorized_keys\"\n\n.ssh/authorized_keysファイルが存在しなくても，自動的に作成してくれます\nこのコマンド実施時には接続先ホストのパスワード入力が求められます.\n登録後はOpenSSHサーバーの設定を変更し，パスワード認証を無効にすることが推奨されます.\n\n\n\n\n\nsshpass コマンド\n\nsshpass(noninteractive ssh password provider)とは，sshコマンドでSSH接続を試みる際に要求されるログインパスワードを 事前に指定した方法でコマンドプロンプトへ渡し，簡単にSSH接続を実現するCLI機能のこと\nsshpass -p &lt;password&gt; ssh &lt;usename@&gt;接続先ホスト という形で実行するとシステムユーザーによるpsコマンドで パスワードがバレてしまうというリスクがあるので，便利さの一方，セキュリティリスクがある点について留意が必要\n\n ▶  インストール方法\n% sudo apt install sshpass ## Ubuntu\nMacだと以下のようなメッセージで怒られます.\n#Error: No available formula or cask with the name \"sshpass\".\n#We won't add sshpass because it makes it too easy for novice SSH users to\n#ruin SSH's security.\nそれでもインストールしたい場合は，ソースから直接以下のような方法でインストールします:\n% wget http://sourceforge.net/projects/sshpass/files/latest/download -O sshpass.tar.gz\n% tar -xvf sshpass.tar.gz\n% cd sshpass-1.08\n% ./configure\n% sudo make install \n% which sshpass ##pathが通っているか確認\n ▶  sshpassコマンドの利用方法\nヘルプコマンドで利用方法を確認してみます:\n% sshpass -h\nUsage: sshpass [-f|-d|-p|-e] [-hV] command parameters\n   -f filename   Take password to use from file\n   -d number     Use number as file descriptor for getting password\n   -p password   Provide password as argument (security unwise)\n   -e            Password is passed as env-var \"SSHPASS\"\n   With no parameters - password will be taken from stdin\n\n   -P prompt     Which string should sshpass search for to detect a password prompt\n   -v            Be verbose about what you're doing\n   -h            Show help (this screen)\n   -V            Print version information\nAt most one of -f，-d，-p or -e should be used\n% sshpass -p '&lt;passphrase&gt;' ssh username@host \nという形で利用することもできますが，psコマンドでpassphraseがダダ漏れになってしまうので\n% sshpass -f &lt;configfilepath&gt; ssh username@host\nまたは，-eオプションを指定することで環境変数SSHPASSを参照することができるので\n% export SSHPASS='my_pass_here'\n% echo $SSHPASS\n% sshpass -e ssh username@host \n\n\nscp コマンド: ホストとクライアント間のファイル転送\n% scp [オプション] コピー元 コピー先 \nコピー元，コピー先はそれぞれのPATHを入力しますがリモート側/ローカル側の書式例は以下です:\n\nリモートサーバー側: username@hostname：PATH\nローカルクライアント側:PATH\n\n\n\n\n\n\n\n\nOption\n説明\n\n\n\n\n-i 秘密鍵ファイル\nRSAまたはDSA認証の秘密鍵ファイルを指定する\n\n\n-P ポート番号\nポート番号を指定する\n\n\n-p\nコピー元ファイルとディレクトリの更新時間、アクセス時間、パーミッションを保持したまま転送する場合\n\n\n-r\nディレクトリ内を再帰的にコピーする\n\n\n\n ▶  ローカルからリモートホストにファイル/ディレクトリをコピー\n## ファイルのコピー\n% scp ~/tmp/file1 user@192.168.10.1:/home/user/tmp/ \n\n## ディレクトリのコピー\n% scp -r ~/tmp user1@192.168.10.1:/home/user/tmp\n\n## sshpassとの組合せ\n% sshpass -f passwordFile scp ~/tmp/file1 user@192.168.10.1:/home/user/tmp/ \n ▶  リモートホストからローカルにファイル/ディレクトリをコピー\n## ファイルのコピー\n% scp user@192.168.10.1:/home/user/file1 ~/tmp\n \n## ディレクトリのコピー\n% scp -r user@192.168.10.1:/home/user/tmp ~/tmp\n \n## 複数のファイルを、{}で囲んで「,」で区切り指定しコピーする例\n% scp user@192.168.10.1:/home/user/{file1,file2,file3} ~/tmp\n ▶  リモートホストから別のリモートホストにファイル/ディレクトリをコピー\n% scp user1@192.168.10.1:/home/user/tmp/file1 user2@192.168.10.2:/home/user/tmp/"
  },
  {
    "objectID": "posts/2025-03-03-triangle-inequality/index.html",
    "href": "posts/2025-03-03-triangle-inequality/index.html",
    "title": "いろいろな三角不等式",
    "section": "",
    "text": "Theorem 1 : シュワルツの不等式 \n任意の２つのベクトル \\(\\pmb{a}, \\pmb{b}\\) に対して，\n\\[\n\\vert (\\pmb{a}, \\pmb{b})\\vert \\leq ||\\pmb{a}||\\,||\\pmb{b}||\n\\]\n等号が成り立つのは \\(\\pmb a = k\\pmb b\\) または, \\(\\pmb b = k^\\prime\\pmb a\\) が成り立つ場合に限る(\\(k,k^\\prime \\in \\mathbf R\\))．\n\n\n\n\n\n\n\n\n\nProof\n\n\n\n\n\n ▶  \\(\\pmb b = \\pmb 0\\) のとき\n\\(\\pmb b = \\pmb 0\\) のときは等号が成り立つことは自明．\n ▶  \\(\\pmb b \\neq \\pmb 0\\) のとき\n\\(\\displaystyle k = \\frac{(\\pmb a, \\pmb b)}{||\\pmb b||^2}\\) とおくと，\n\\[\n\\begin{align}\n||\\pmb a - k\\pmb b||^2\n    &= ||\\pmb a||^2 - 2k(\\pmb a, \\pmb b) + k^2 ||\\pmb b||^2\\\\\n    &= ||\\pmb a||^2 - 2\\frac{(\\pmb a, \\pmb b)^2}{||\\pmb b||^2} + \\frac{(\\pmb a, \\pmb b)^2}{||\\pmb b||^2}\\\\\n    &= ||\\pmb a||^2 - \\frac{(\\pmb a, \\pmb b)^2}{||\\pmb b||^2}\n\\end{align}\n\\]\nここで，\\(||\\pmb a - k\\pmb b||^2 \\geq 0\\) であるので\n\\[\n||\\pmb a||^2 \\geq \\frac{(\\pmb a, \\pmb b)^2}{||\\pmb b||^2}\n\\]\nこれを整理すると\n\\[\n||\\pmb a||^2||\\pmb b||^2 \\geq (\\pmb a, \\pmb b)^2 \\Rightarrow ||\\pmb a||\\,||\\pmb b|| \\geq |(\\pmb a, \\pmb b)|\n\\]\n等号成立が成立するとき \\(||\\pmb a - k\\pmb b||^2 = 0\\) であるので，\\(\\pmb a = k\\pmb b\\) が必要条件であることがわかります．\n ▶  \\(\\pmb a = k\\pmb b\\) の十分条件性 \n\\[\n\\begin{align}\n||\\pmb a||\\,||\\pmb b||\n    &= |k|||\\pmb b||\\,||\\pmb b||\\\\\n    &= |k|||\\pmb b||^2\n\\end{align}\n\\]\nまた\n\\[\n\\begin{align}\n|(\\pmb a, \\pmb b)|\n    &= |k|(\\pmb b, \\pmb b)\\\\\n    &= |k|||\\pmb b||^2\n\\end{align}\n\\]\nしたがって，\\(|\\pmb a||\\,||\\pmb b|| = |(\\pmb a, \\pmb b)|\\) が成り立つことがわかります．\n\n\n\n\n\nTheorem 2 : シュワルツの不等式と三角不等式 \n任意の２つのベクトル \\(\\pmb{a}, \\pmb{b}\\) に対して，\n\\[\n||\\pmb{a} + \\pmb{b}|| \\leq ||\\pmb{a}||\\, ||\\pmb{b}||\n\\]\n等号が成り立つのは \\(\\pmb a = k\\pmb b, k\\geq 0\\) または, \\(\\pmb b = k^\\prime\\pmb a, k^\\prime\\geq 0\\) が成り立つ場合に限る．\n\n\n\n\n\n\n\n\n\nProof\n\n\n\n\n\nシュワルツの不等式を用いると\n\\[\n\\begin{align}\n||\\pmb{a} + \\pmb{b}||^2\n    &= ||\\pmb{a}||^2 + 2(\\pmb{a},\\pmb{b}) + ||\\pmb{b}||^2\\\\\n    &\\leq ||\\pmb{a}||^2 + 2||\\pmb{a}||\\,||\\pmb{b}|| + ||\\pmb{b}||^2\\\\\n    &= (||\\pmb{a}|| + ||\\pmb{b}||)^2\n\\end{align}\n\\]\nしたがって，\n\\[\n||\\pmb{a} + \\pmb{b}|| \\leq ||\\pmb{a}||\\, ||\\pmb{b}||\n\\]\n等号成立はシュワルツの不等式の等号が成立し，かつ\n\\[\n(\\pmb{a},\\pmb{b}) \\geq 0\n\\]\nが成立するときとなるので， \\(\\pmb a = k\\pmb b, k\\geq 0\\) または, \\(\\pmb b = k^\\prime\\pmb a, k^\\prime\\geq 0\\) が成り立つ場合に限ることがわかる．"
  },
  {
    "objectID": "posts/2025-03-03-triangle-inequality/index.html#シュワルツの不等式と三角不等式",
    "href": "posts/2025-03-03-triangle-inequality/index.html#シュワルツの不等式と三角不等式",
    "title": "いろいろな三角不等式",
    "section": "",
    "text": "Theorem 1 : シュワルツの不等式 \n任意の２つのベクトル \\(\\pmb{a}, \\pmb{b}\\) に対して，\n\\[\n\\vert (\\pmb{a}, \\pmb{b})\\vert \\leq ||\\pmb{a}||\\,||\\pmb{b}||\n\\]\n等号が成り立つのは \\(\\pmb a = k\\pmb b\\) または, \\(\\pmb b = k^\\prime\\pmb a\\) が成り立つ場合に限る(\\(k,k^\\prime \\in \\mathbf R\\))．\n\n\n\n\n\n\n\n\n\nProof\n\n\n\n\n\n ▶  \\(\\pmb b = \\pmb 0\\) のとき\n\\(\\pmb b = \\pmb 0\\) のときは等号が成り立つことは自明．\n ▶  \\(\\pmb b \\neq \\pmb 0\\) のとき\n\\(\\displaystyle k = \\frac{(\\pmb a, \\pmb b)}{||\\pmb b||^2}\\) とおくと，\n\\[\n\\begin{align}\n||\\pmb a - k\\pmb b||^2\n    &= ||\\pmb a||^2 - 2k(\\pmb a, \\pmb b) + k^2 ||\\pmb b||^2\\\\\n    &= ||\\pmb a||^2 - 2\\frac{(\\pmb a, \\pmb b)^2}{||\\pmb b||^2} + \\frac{(\\pmb a, \\pmb b)^2}{||\\pmb b||^2}\\\\\n    &= ||\\pmb a||^2 - \\frac{(\\pmb a, \\pmb b)^2}{||\\pmb b||^2}\n\\end{align}\n\\]\nここで，\\(||\\pmb a - k\\pmb b||^2 \\geq 0\\) であるので\n\\[\n||\\pmb a||^2 \\geq \\frac{(\\pmb a, \\pmb b)^2}{||\\pmb b||^2}\n\\]\nこれを整理すると\n\\[\n||\\pmb a||^2||\\pmb b||^2 \\geq (\\pmb a, \\pmb b)^2 \\Rightarrow ||\\pmb a||\\,||\\pmb b|| \\geq |(\\pmb a, \\pmb b)|\n\\]\n等号成立が成立するとき \\(||\\pmb a - k\\pmb b||^2 = 0\\) であるので，\\(\\pmb a = k\\pmb b\\) が必要条件であることがわかります．\n ▶  \\(\\pmb a = k\\pmb b\\) の十分条件性 \n\\[\n\\begin{align}\n||\\pmb a||\\,||\\pmb b||\n    &= |k|||\\pmb b||\\,||\\pmb b||\\\\\n    &= |k|||\\pmb b||^2\n\\end{align}\n\\]\nまた\n\\[\n\\begin{align}\n|(\\pmb a, \\pmb b)|\n    &= |k|(\\pmb b, \\pmb b)\\\\\n    &= |k|||\\pmb b||^2\n\\end{align}\n\\]\nしたがって，\\(|\\pmb a||\\,||\\pmb b|| = |(\\pmb a, \\pmb b)|\\) が成り立つことがわかります．\n\n\n\n\n\nTheorem 2 : シュワルツの不等式と三角不等式 \n任意の２つのベクトル \\(\\pmb{a}, \\pmb{b}\\) に対して，\n\\[\n||\\pmb{a} + \\pmb{b}|| \\leq ||\\pmb{a}||\\, ||\\pmb{b}||\n\\]\n等号が成り立つのは \\(\\pmb a = k\\pmb b, k\\geq 0\\) または, \\(\\pmb b = k^\\prime\\pmb a, k^\\prime\\geq 0\\) が成り立つ場合に限る．\n\n\n\n\n\n\n\n\n\nProof\n\n\n\n\n\nシュワルツの不等式を用いると\n\\[\n\\begin{align}\n||\\pmb{a} + \\pmb{b}||^2\n    &= ||\\pmb{a}||^2 + 2(\\pmb{a},\\pmb{b}) + ||\\pmb{b}||^2\\\\\n    &\\leq ||\\pmb{a}||^2 + 2||\\pmb{a}||\\,||\\pmb{b}|| + ||\\pmb{b}||^2\\\\\n    &= (||\\pmb{a}|| + ||\\pmb{b}||)^2\n\\end{align}\n\\]\nしたがって，\n\\[\n||\\pmb{a} + \\pmb{b}|| \\leq ||\\pmb{a}||\\, ||\\pmb{b}||\n\\]\n等号成立はシュワルツの不等式の等号が成立し，かつ\n\\[\n(\\pmb{a},\\pmb{b}) \\geq 0\n\\]\nが成立するときとなるので， \\(\\pmb a = k\\pmb b, k\\geq 0\\) または, \\(\\pmb b = k^\\prime\\pmb a, k^\\prime\\geq 0\\) が成り立つ場合に限ることがわかる．"
  },
  {
    "objectID": "posts/2025-03-03-triangle-inequality/index.html#複素数と三角不等式",
    "href": "posts/2025-03-03-triangle-inequality/index.html#複素数と三角不等式",
    "title": "いろいろな三角不等式",
    "section": "複素数と三角不等式",
    "text": "複素数と三角不等式\n\n\nTheorem 3 \n複素平面上に2点 \\(z = a_1 + b_1i, w = a_2 + b_2i\\) をとったとき，次の不等式が成立する\n\\[\n\\begin{gather}\n\\vert z + w \\vert \\leq \\vert z\\vert + \\vert w \\vert\\\\\n\\vert z\\vert - \\vert w \\vert \\leq \\vert z - w \\vert\n\\end{gather}\n\\]\nこれを三角不等式と呼ぶ．\n\n\n\n\n\n\n\n\n\nProof 1\n\n\n\n\n\n注意: この証明は平面空間における三角不等式を前提にしているのでトートロジー疑惑が有ります\n\n\nCode\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Define the complex numbers\nalpha1 = 3 + 4j\nalpha2 = 5 + 2j\nalpha3 = alpha1 + alpha2\nalpha4 = alpha1 - alpha2\n\n# Extract the real and imaginary parts\na1_real, a1_imag = alpha1.real, alpha1.imag\na2_real, a2_imag = alpha2.real, alpha2.imag\na3_real, a3_imag = alpha3.real, alpha3.imag\na4_real, a4_imag = alpha4.real, alpha4.imag\n\n# Create the plot\nfig, ax = plt.subplots()\n\n# Plot the vectors\nax.quiver(0, 0, a1_real, a1_imag, angles=\"xy\", scale_units=\"xy\", scale=1, color=\"k\")\nax.quiver(0, 0, a2_real, a2_imag, angles=\"xy\", scale_units=\"xy\", scale=1, color=\"k\")\nax.quiver(\n    a1_real,\n    a1_imag,\n    a2_real,\n    a2_imag,\n    angles=\"xy\",\n    scale_units=\"xy\",\n    linewidth=1,\n    scale=1,\n    edgecolor=\"gray\",\n    color=\"gray\",\n)\nax.quiver(0, 0, a3_real, a3_imag, angles=\"xy\", scale_units=\"xy\", scale=1, color=\"k\")\nax.quiver(0, 0, a4_real, a4_imag, angles=\"xy\", scale_units=\"xy\", scale=1, color=\"k\")\nax.quiver(\n    a1_real,\n    a1_imag,\n    -a2_real,\n    -a2_imag,\n    angles=\"xy\",\n    scale_units=\"xy\",\n    linewidth=1,\n    scale=1,\n    edgecolor=\"gray\",\n    color=\"gray\",\n)\n\n\n# add point\nax.text(a1_real, a1_imag * 1.1, \"$z$\")\nax.text(a2_real, a2_imag, \"$w$\")\nax.text(a3_real, a3_imag, \"$z+w$\")\nax.text(a4_real, a4_imag + 0.5, \"$z-w$\")\n\n\n# Set the plot limits\nax.set_xlim(a4_real - 1, max(a1_real, a3_real) + 3)\nax.set_ylim(-1, max(a1_imag, a3_imag) + 3)\n\n# Add grid, labels, and legend\nax.grid()\nax.set_aspect(\"equal\")\nax.set_xlabel(\"Real Part\")\nax.set_ylabel(\"Imaginary Part\")\n\n# Add title\nax.set_title(\"Complex Number Vectors\")\n\n# Show the plot\nplt.show()\n\n\n\n\n\n\n\n\n\n原点と \\(z, z+w\\) を頂点とする三角形を考えます．このときそれぞれの辺の長さは \\(\\vert z\\vert, \\vert w\\vert, \\vert z + w\\vert\\) となります．\n三角形の二辺の和は他の１辺の長さより長いので\n\\[\n\\vert z + w \\vert \\leq \\vert z\\vert + \\vert w \\vert\n\\]\nが成立する．\n同様に\\(z, z-w\\) を頂点とする三角形についても\n\\[\n\\vert z \\vert \\leq \\vert z + w \\vert + \\vert w \\vert\n\\]\nが成り立つので，これを整理すると\n\\[\n\\vert z\\vert - \\vert w \\vert \\leq \\vert z - w \\vert\n\\]\n\n\n\n\n\n\n\n\n\n\nProof 2\n\n\n\n\n\n複素数の絶対値と共役複素数の関係より\n\\[\n\\begin{align}\n\\vert  z + w \\vert^2\n    &= (z + w)(\\bar z + \\bar w)\\\\\n    &= z\\bar z + w\\bar w + w\\bar z + z\\bar w\\\\\n    &= \\vert z\\vert^2 + \\vert w\\vert^2 + w \\overline z + z \\overline w\\\\\n    &= \\vert z\\vert^2 + \\vert w\\vert^2 + w \\overline z + \\overline{\\overline z w}\\\\\n    &= \\vert z\\vert^2 + \\vert w\\vert^2 + 2\\operatorname{Re}w \\overline z\\\\\n    &\\leq \\vert z\\vert^2 + \\vert w\\vert^2 + 2\\vert w \\overline z\\vert\\\\\n    &= \\vert z\\vert^2 + \\vert w\\vert^2 + 2\\vert w\\vert \\vert\\overline z\\vert\\\\\n    &= \\vert z\\vert^2 + \\vert w\\vert^2 + 2\\vert w\\vert \\vert z\\vert\\\\\n    &= (\\vert z \\vert + \\vert w \\vert)^2\n\\end{align}\n\\]\nしたがって，\n\\[\n\\vert  z + w \\vert \\leq \\vert z \\vert + \\vert w \\vert\n\\]"
  },
  {
    "objectID": "posts/2025-02-25-law-of-sines/index.html",
    "href": "posts/2025-02-25-law-of-sines/index.html",
    "title": "正弦定理の考え方",
    "section": "",
    "text": "Exercise 1 \n\\(BC = 30, \\angle B = 70^\\circ, \\angle C = 63^\\circ\\) となるような \\(\\triangle ABC\\) が与えられたとします．このとき，長さ \\(AB\\) を求めよ\n\n\n設問の \\(\\triangle ABC\\) を図示すると以下のようになります．\\(B\\) から \\(AC\\) に対して垂線を垂らし，その交点を \\(BH\\) とします．\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport matplotlib.patches as patches\n\ndef plot_triangular(base_length: float, angles: tuple, fig_size=(6,6)):\n    # Given values\n    BC = 30  # Side BC\n    angle_B = np.radians(angles[0])  # Convert degrees to radians\n    angle_C = np.radians(angles[1])  # Convert degrees to radians\n\n    # Calculate angle A\n    angle_A = np.radians(180 - sum(angles))\n\n    # Use Law of Sines to find AB and AC\n    AB = BC * np.sin(angle_B) / np.sin(angle_A)\n    AC = BC * np.sin(angle_C) / np.sin(angle_A)\n\n    # Set points in a 2D coordinate system\n    B = np.array([0, 0])  # Point B at the origin\n    C = np.array([BC, 0])  # Point C on the x-axis\n\n    # Calculate A's coordinates using trigonometry\n    A_x = BC - AC * np.cos(angle_B)  # Projection of AC on x-axis\n    A_y = AC * np.sin(angle_B)  # Height of A\n\n    A = np.array([A_x, A_y])\n\n    # Plot the triangle using ax\n    fig, ax = plt.subplots(figsize = fig_size)\n    ax.plot([A[0], B[0]], [A[1], B[1]], 'ko-')  # Black line with circle markers\n    ax.plot([B[0], C[0]], [B[1], C[1]], 'ko-')  # Black line with circle markers\n    ax.plot([C[0], A[0]], [C[1], A[1]], 'ko-')  # Black line with circle markers\n\n    # Annotate points\n    ax.text(A[0], A[1], '  A', fontsize=12, verticalalignment='bottom')\n    ax.text(B[0], B[1], '  B', fontsize=12, verticalalignment='top', horizontalalignment='right')\n    ax.text(C[0], C[1], '  C', fontsize=12, verticalalignment='top', horizontalalignment='left')\n\n    # Add angles as arcs\n    arc_radius = 5  # Radius for the arcs\n\n    # Angle at B\n    angle_B_arc = patches.Arc(B, arc_radius, arc_radius, angle=0, theta1=0, theta2=np.degrees(angle_B), color='blue')\n    ax.add_patch(angle_B_arc)\n    ax.text(B[0] + arc_radius/2, B[1] + 1, f\"{70}°\", fontsize=12, color='blue')\n\n    # Angle at C\n    angle_C_arc = patches.Arc(C, arc_radius, arc_radius, angle=0, theta1=180 - np.degrees(angle_C), theta2=180, color='red')\n    ax.add_patch(angle_C_arc)\n    ax.text((C[0] - arc_radius/2) - 2, C[1] + 1, f\"{63}°\", fontsize=12, color='red')\n\n    return fig, ax, (A, B, C)\n\n# plot\nfig, ax, coordinates = plot_triangular(30, (70, 63))\n\n# add BH\nslope = -1/((coordinates[2][1] - coordinates[0][1])/(coordinates[2][0] - coordinates[0][0]))\nax.plot((0, 26.5), (0, slope * 26.5))\nax.text(26.5, slope * 26.5, '  H', fontsize=12, verticalalignment='top', horizontalalignment='left')\n\n# add labels\nax.text(15, -2, \"BC = 30\", fontsize=12, color='black', horizontalalignment='center')\nax.axhline(0, color='black',linewidth=0.5)\nax.axvline(0, color='black',linewidth=0.5)\nax.grid(True, linestyle='--', alpha=0.6)\nax.set_xlim(-5, 35)\nax.set_ylim(-5, 42)\nax.set_title(\"Triangle ABC\")\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 1\n\n\n\n\\(\\triangle BCH, \\triangle ABH\\) を考えると，\n\\[\n\\begin{align}\nBH &= \\sin( A) * AB\\\\\nBH &= \\sin( C) * BC\n\\end{align}\n\\]\nこれを整理すると\n\\[\n\\begin{align}\nAB &= \\frac{\\sin(C) * BC}{\\sin A}\\label{eq-law-of-sines-1}\\\\\n   &= \\frac{30 \\cdot \\sin(63^\\circ)}{\\sin(47^\\circ)}\\label{eq-law-of-sines-2}\n\\end{align}\n\\]\n従って，\n\n\nCode\nprint(f\"BC = {30 * np.sin(63/180 * np.pi)/np.sin(47/180 * np.pi):.4f}\")\n\n\nBC = 36.5489\n\n\nと計算されます．\n\n\n\\(\\eqref{eq-law-of-sines-1}\\), \\(\\eqref{eq-law-of-sines-2}\\) を整理すると\n\\[\n\\frac{AB}{\\sin A} = \\frac{BC}{\\sin C}\n\\]\nを得ます．同様の方法で \\(AC\\) を求めて整理すると，\n\\[\n\\frac{AB}{\\sin A}= \\frac{AC}{\\sin B} = \\frac{BC}{\\sin C}\n\\]\nこれは，\\(\\triangle ABC\\) の外接円を考えたとき，その外接円の半径を \\(R\\) としたとき\n\\[\n\\frac{AB}{\\sin A}= \\frac{AC}{\\sin B} = \\frac{BC}{\\sin C} = 2R\n\\]\nという正弦定理へ繋がります．\n ▶  対辺と\\(\\sin\\) の比率が直径 \\(2R\\)に一致する証明\n\n\n\n\n\n\n\nProof\n\n\n\n\n\n\\(\\triangle ABC\\) の外接円について，弧BC以外の円周上の点 \\(P\\) を適当に取ったときに形成される角度 \\(\\angle BPC\\) を弧BCの円周角といいます． 中心角と円周角の関係として，\n\\[\n\\text{中心角} = 2\\times (\\text{円周角})\n\\]\nここから，「同じ弧に対する円周角は等しい」ことがいえます．ここで，\\(CP\\) が外接円の直径となるように \\(P\\) を取ると直径に対する円周角は直角なので \\(\\triangle BCP\\) は直角三角形となります．\\(CP\\) を斜辺，\\(BC\\)を対辺とすると\n\\[\nBC = 2R \\times \\sin(\\angle BPC) = 2R \\times \\sin(A)\n\\]\n従って，\n\\[\n\\frac{BC}{\\sin A} = 2R\n\\]\n従って，\n\\[\n\\frac{AB}{\\sin A}= \\frac{AC}{\\sin B} = \\frac{BC}{\\sin C} = 2R\n\\]\n\n\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# 与えられた条件\nBC = 30  # 辺BC\nangle_B = np.radians(70)  # 角B (ラジアン変換)\nangle_C = np.radians(63)  # 角C (ラジアン変換)\n\n# 角Aを計算\nangle_A = np.radians(180 - (70 + 63))\n\n# 正弦定理を使ってABとACを求める\nAB = BC * np.sin(angle_B) / np.sin(angle_A)\nAC = BC * np.sin(angle_C) / np.sin(angle_A)\n\n# 頂点座標\nB = np.array([0, 0])  # Bを原点に配置\nC = np.array([BC, 0])  # Cをx軸上に配置\nA_x = BC - AC * np.cos(angle_B)  # Aのx座標\nA_y = AC * np.sin(angle_B)  # Aのy座標\nA = np.array([A_x, A_y])\n\n# 垂直二等分線の交点（外心）を求める\ndef circumcenter(A, B, C):\n    D = 2 * (A[0] * (B[1] - C[1]) + B[0] * (C[1] - A[1]) + C[0] * (A[1] - B[1]))\n    Ux = ((A[0]**2 + A[1]**2) * (B[1] - C[1]) + (B[0]**2 + B[1]**2) * (C[1] - A[1]) + (C[0]**2 + C[1]**2) * (A[1] - B[1])) / D\n    Uy = ((A[0]**2 + A[1]**2) * (C[0] - B[0]) + (B[0]**2 + B[1]**2) * (A[0] - C[0]) + (C[0]**2 + C[1]**2) * (B[0] - A[0])) / D\n    return np.array([Ux, Uy])\n\ncircumcenter_point = circumcenter(A, B, C)\nradius = np.linalg.norm(A - circumcenter_point)  # 外接円の半径\n\n# 円周上の点P（円周角を示す）\ntheta_P = np.radians(120)  # 任意の角度 (120°)\nP_x = circumcenter_point[0] + radius * np.cos(theta_P)\nP_y = circumcenter_point[1] + radius * np.sin(theta_P)\nP = np.array([0, 30/np.sin(angle_A) * np.sin(np.pi/2 - angle_A)])\n\n# 図を作成\nfig, ax = plt.subplots(figsize=(6,6))\n\n# 三角形ABCをプロット\nax.plot([A[0], B[0]], [A[1], B[1]], 'bo-', label=\"AB\")\nax.plot([B[0], C[0]], [B[1], C[1]], 'ro-', label=\"BC\")\nax.plot([C[0], A[0]], [C[1], A[1]], 'go-', label=\"CA\")\n\n# 外接円をプロット\ncircle = plt.Circle(circumcenter_point, radius, color='cyan', fill=False, linestyle='dashed', label=\"Circumcircle\")\nax.add_patch(circle)\n\n# 円周角を示す点Pと三角形BPC\nax.plot([B[0], P[0]], [B[1], P[1]], 'purple', linestyle='dotted', label=\"BP\")\nax.plot([C[0], P[0]], [C[1], P[1]], 'purple', linestyle='dotted', label=\"CP\")\n\n# 点のラベル\nax.text(A[0], A[1], '  A', fontsize=12, verticalalignment='bottom')\nax.text(B[0], B[1], '  B', fontsize=12, verticalalignment='top', horizontalalignment='right')\nax.text(C[0], C[1], '  C', fontsize=12, verticalalignment='top', horizontalalignment='left')\nax.text(P[0], P[1], '  P', fontsize=12, verticalalignment='bottom', horizontalalignment='right', color='purple')\nax.scatter(circumcenter_point[0], circumcenter_point[1], color='black')  # 外心O\n\n# グリッドと範囲設定\nax.axhline(0, color='black', linewidth=0.5)\nax.axvline(0, color='black', linewidth=0.5)\nax.grid(True, linestyle='--', alpha=0.6)\nax.set_xlim(-radius-5, BC+radius+5)\nax.set_ylim(-radius-5, radius+AC+5)\nax.legend()\nax.set_title(\"Triangle ABC with Circumcircle and Inscribed Angle\")\n\n# 図を表示\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 2\n\n\n\n\n\n\n\n\nExercise 2 \nとある山へハイキングにいくとします．\n\n山頂をC\n山の麓のA地点から同じ標高で直線距離で1000m離れている地点をB\nA地点からCを見たときの仰角は \\(30^\\circ\\)\n\\(\\triangle ABC\\) について，\\(\\angle CAB = 75^\\circ, \\angle ABC = 45^\\circ\\)\n\nということがわかっているとします．このとき，Cの標高を求めよ．なお，\\(A, B\\) の標高は 0m とする．\n\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.mplot3d.art3d import Poly3DCollection\n\n# Given angles and side lengths\nangle_A = np.radians(75)\nangle_B = np.radians(45)\nAB = 1000  # Given\n\n# Compute angle C\nangle_C = np.radians(180 - 75 - 45)  # C = 60 degrees\n\n# Compute sides using the Law of Sines\nBC = AB * np.sin(angle_A) / np.sin(angle_C)\nAC = AB * np.sin(angle_B) / np.sin(angle_C)\n\n# Compute coordinates of A, B, and C\nA = np.array([0, 0, 0])  # A is the origin\nB = np.array([AB, 0, 0])  # B is along the x-axis\nC_x = 0  # Projection of AC on x-axis\nC_y = AC * np.cos(np.radians(30))\nC_z = AC * np.sin(np.radians(30))  # Projection on y-axis\nC = np.array([0, C_y, C_z])  # C remains in the XY plane\n\n# Triangle ACH: Given CAH = 30°, CHA = 90° (Right Triangle)\nangle_CAH = np.radians(30)\n\n# H's coordinates (directly above C in the Z direction)\nH = np.array([0, C_y, 0])\n\n# Create 3D plot\nfig = plt.figure(figsize=(8, 8))\nax = fig.add_subplot(111, projection='3d')\n\n# Plot edges of tetrahedron\nedges = [\n    (A, B), (B, C), (C, A),  # Triangle ABC\n    (A, H), (C, H), (B, H)   # Connecting H to A, C, and B\n]\n\nfor edge in edges:\n    ax.plot(*zip(*edge), 'k-')\n\n# Define faces for tetrahedron visualization\nfaces = [\n    [A, B, C],  # Base ABC\n    [A, C, H],  # Side ACH\n    [C, B, H],  # Side CBH\n    [A, H, B]   # Side AHB\n]\n\n# Add face shading\nax.add_collection3d(Poly3DCollection(faces, alpha=0.3, color='cyan'))\n\n# Annotate points\nax.text(*A, \" A\", color='black', fontsize=12)\nax.text(*B, \" B\", color='black', fontsize=12)\nax.text(*C, \" C\", color='black', fontsize=12)\nax.text(*H, \" H\", color='black', fontsize=12)\n\n# Labels and grid\nax.set_xlabel(\"X-axis\")\nax.set_ylabel(\"Y-axis\")\nax.set_zlabel(\"Z-axis\")\nax.set_title(\"3D Tetrahedron CAHB\")\nax.grid(True)\n\nax.view_init(elev=20, azim=-55) \n\n# Show the plot\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 3\n\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n上の図のようにCから\\(XY\\)平面に垂線を下ろして，XY平面との交点を \\(H\\) としたとき，今回求めたい長さは \\(CH\\)．\n問題文の情報を用いて正弦定理を利用すると\n\\[\n\\displaystyle AC = \\frac{AB}{\\sin (\\angle ACB)} \\cdot \\sin(\\angle ABC)\n\\]\nここで\n\\[\n\\begin{align}\nCH &= AC \\cdot \\sin(\\angle CAH)\\\\\n    &= \\frac{AB}{\\sin (\\angle ACB)} \\cdot \\sin(\\angle ABC) \\cdot \\sin(\\angle CAH)\n\\end{align}\n\\]\n従って，\n\n\nCode\nprint(f\"CH = {C_z:.2f}\")\n\n\nCH = 408.25"
  },
  {
    "objectID": "posts/2025-02-25-law-of-sines/index.html#正弦定理の考え方",
    "href": "posts/2025-02-25-law-of-sines/index.html#正弦定理の考え方",
    "title": "正弦定理の考え方",
    "section": "",
    "text": "Exercise 1 \n\\(BC = 30, \\angle B = 70^\\circ, \\angle C = 63^\\circ\\) となるような \\(\\triangle ABC\\) が与えられたとします．このとき，長さ \\(AB\\) を求めよ\n\n\n設問の \\(\\triangle ABC\\) を図示すると以下のようになります．\\(B\\) から \\(AC\\) に対して垂線を垂らし，その交点を \\(BH\\) とします．\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport matplotlib.patches as patches\n\ndef plot_triangular(base_length: float, angles: tuple, fig_size=(6,6)):\n    # Given values\n    BC = 30  # Side BC\n    angle_B = np.radians(angles[0])  # Convert degrees to radians\n    angle_C = np.radians(angles[1])  # Convert degrees to radians\n\n    # Calculate angle A\n    angle_A = np.radians(180 - sum(angles))\n\n    # Use Law of Sines to find AB and AC\n    AB = BC * np.sin(angle_B) / np.sin(angle_A)\n    AC = BC * np.sin(angle_C) / np.sin(angle_A)\n\n    # Set points in a 2D coordinate system\n    B = np.array([0, 0])  # Point B at the origin\n    C = np.array([BC, 0])  # Point C on the x-axis\n\n    # Calculate A's coordinates using trigonometry\n    A_x = BC - AC * np.cos(angle_B)  # Projection of AC on x-axis\n    A_y = AC * np.sin(angle_B)  # Height of A\n\n    A = np.array([A_x, A_y])\n\n    # Plot the triangle using ax\n    fig, ax = plt.subplots(figsize = fig_size)\n    ax.plot([A[0], B[0]], [A[1], B[1]], 'ko-')  # Black line with circle markers\n    ax.plot([B[0], C[0]], [B[1], C[1]], 'ko-')  # Black line with circle markers\n    ax.plot([C[0], A[0]], [C[1], A[1]], 'ko-')  # Black line with circle markers\n\n    # Annotate points\n    ax.text(A[0], A[1], '  A', fontsize=12, verticalalignment='bottom')\n    ax.text(B[0], B[1], '  B', fontsize=12, verticalalignment='top', horizontalalignment='right')\n    ax.text(C[0], C[1], '  C', fontsize=12, verticalalignment='top', horizontalalignment='left')\n\n    # Add angles as arcs\n    arc_radius = 5  # Radius for the arcs\n\n    # Angle at B\n    angle_B_arc = patches.Arc(B, arc_radius, arc_radius, angle=0, theta1=0, theta2=np.degrees(angle_B), color='blue')\n    ax.add_patch(angle_B_arc)\n    ax.text(B[0] + arc_radius/2, B[1] + 1, f\"{70}°\", fontsize=12, color='blue')\n\n    # Angle at C\n    angle_C_arc = patches.Arc(C, arc_radius, arc_radius, angle=0, theta1=180 - np.degrees(angle_C), theta2=180, color='red')\n    ax.add_patch(angle_C_arc)\n    ax.text((C[0] - arc_radius/2) - 2, C[1] + 1, f\"{63}°\", fontsize=12, color='red')\n\n    return fig, ax, (A, B, C)\n\n# plot\nfig, ax, coordinates = plot_triangular(30, (70, 63))\n\n# add BH\nslope = -1/((coordinates[2][1] - coordinates[0][1])/(coordinates[2][0] - coordinates[0][0]))\nax.plot((0, 26.5), (0, slope * 26.5))\nax.text(26.5, slope * 26.5, '  H', fontsize=12, verticalalignment='top', horizontalalignment='left')\n\n# add labels\nax.text(15, -2, \"BC = 30\", fontsize=12, color='black', horizontalalignment='center')\nax.axhline(0, color='black',linewidth=0.5)\nax.axvline(0, color='black',linewidth=0.5)\nax.grid(True, linestyle='--', alpha=0.6)\nax.set_xlim(-5, 35)\nax.set_ylim(-5, 42)\nax.set_title(\"Triangle ABC\")\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 1\n\n\n\n\\(\\triangle BCH, \\triangle ABH\\) を考えると，\n\\[\n\\begin{align}\nBH &= \\sin( A) * AB\\\\\nBH &= \\sin( C) * BC\n\\end{align}\n\\]\nこれを整理すると\n\\[\n\\begin{align}\nAB &= \\frac{\\sin(C) * BC}{\\sin A}\\label{eq-law-of-sines-1}\\\\\n   &= \\frac{30 \\cdot \\sin(63^\\circ)}{\\sin(47^\\circ)}\\label{eq-law-of-sines-2}\n\\end{align}\n\\]\n従って，\n\n\nCode\nprint(f\"BC = {30 * np.sin(63/180 * np.pi)/np.sin(47/180 * np.pi):.4f}\")\n\n\nBC = 36.5489\n\n\nと計算されます．\n\n\n\\(\\eqref{eq-law-of-sines-1}\\), \\(\\eqref{eq-law-of-sines-2}\\) を整理すると\n\\[\n\\frac{AB}{\\sin A} = \\frac{BC}{\\sin C}\n\\]\nを得ます．同様の方法で \\(AC\\) を求めて整理すると，\n\\[\n\\frac{AB}{\\sin A}= \\frac{AC}{\\sin B} = \\frac{BC}{\\sin C}\n\\]\nこれは，\\(\\triangle ABC\\) の外接円を考えたとき，その外接円の半径を \\(R\\) としたとき\n\\[\n\\frac{AB}{\\sin A}= \\frac{AC}{\\sin B} = \\frac{BC}{\\sin C} = 2R\n\\]\nという正弦定理へ繋がります．\n ▶  対辺と\\(\\sin\\) の比率が直径 \\(2R\\)に一致する証明\n\n\n\n\n\n\n\nProof\n\n\n\n\n\n\\(\\triangle ABC\\) の外接円について，弧BC以外の円周上の点 \\(P\\) を適当に取ったときに形成される角度 \\(\\angle BPC\\) を弧BCの円周角といいます． 中心角と円周角の関係として，\n\\[\n\\text{中心角} = 2\\times (\\text{円周角})\n\\]\nここから，「同じ弧に対する円周角は等しい」ことがいえます．ここで，\\(CP\\) が外接円の直径となるように \\(P\\) を取ると直径に対する円周角は直角なので \\(\\triangle BCP\\) は直角三角形となります．\\(CP\\) を斜辺，\\(BC\\)を対辺とすると\n\\[\nBC = 2R \\times \\sin(\\angle BPC) = 2R \\times \\sin(A)\n\\]\n従って，\n\\[\n\\frac{BC}{\\sin A} = 2R\n\\]\n従って，\n\\[\n\\frac{AB}{\\sin A}= \\frac{AC}{\\sin B} = \\frac{BC}{\\sin C} = 2R\n\\]\n\n\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# 与えられた条件\nBC = 30  # 辺BC\nangle_B = np.radians(70)  # 角B (ラジアン変換)\nangle_C = np.radians(63)  # 角C (ラジアン変換)\n\n# 角Aを計算\nangle_A = np.radians(180 - (70 + 63))\n\n# 正弦定理を使ってABとACを求める\nAB = BC * np.sin(angle_B) / np.sin(angle_A)\nAC = BC * np.sin(angle_C) / np.sin(angle_A)\n\n# 頂点座標\nB = np.array([0, 0])  # Bを原点に配置\nC = np.array([BC, 0])  # Cをx軸上に配置\nA_x = BC - AC * np.cos(angle_B)  # Aのx座標\nA_y = AC * np.sin(angle_B)  # Aのy座標\nA = np.array([A_x, A_y])\n\n# 垂直二等分線の交点（外心）を求める\ndef circumcenter(A, B, C):\n    D = 2 * (A[0] * (B[1] - C[1]) + B[0] * (C[1] - A[1]) + C[0] * (A[1] - B[1]))\n    Ux = ((A[0]**2 + A[1]**2) * (B[1] - C[1]) + (B[0]**2 + B[1]**2) * (C[1] - A[1]) + (C[0]**2 + C[1]**2) * (A[1] - B[1])) / D\n    Uy = ((A[0]**2 + A[1]**2) * (C[0] - B[0]) + (B[0]**2 + B[1]**2) * (A[0] - C[0]) + (C[0]**2 + C[1]**2) * (B[0] - A[0])) / D\n    return np.array([Ux, Uy])\n\ncircumcenter_point = circumcenter(A, B, C)\nradius = np.linalg.norm(A - circumcenter_point)  # 外接円の半径\n\n# 円周上の点P（円周角を示す）\ntheta_P = np.radians(120)  # 任意の角度 (120°)\nP_x = circumcenter_point[0] + radius * np.cos(theta_P)\nP_y = circumcenter_point[1] + radius * np.sin(theta_P)\nP = np.array([0, 30/np.sin(angle_A) * np.sin(np.pi/2 - angle_A)])\n\n# 図を作成\nfig, ax = plt.subplots(figsize=(6,6))\n\n# 三角形ABCをプロット\nax.plot([A[0], B[0]], [A[1], B[1]], 'bo-', label=\"AB\")\nax.plot([B[0], C[0]], [B[1], C[1]], 'ro-', label=\"BC\")\nax.plot([C[0], A[0]], [C[1], A[1]], 'go-', label=\"CA\")\n\n# 外接円をプロット\ncircle = plt.Circle(circumcenter_point, radius, color='cyan', fill=False, linestyle='dashed', label=\"Circumcircle\")\nax.add_patch(circle)\n\n# 円周角を示す点Pと三角形BPC\nax.plot([B[0], P[0]], [B[1], P[1]], 'purple', linestyle='dotted', label=\"BP\")\nax.plot([C[0], P[0]], [C[1], P[1]], 'purple', linestyle='dotted', label=\"CP\")\n\n# 点のラベル\nax.text(A[0], A[1], '  A', fontsize=12, verticalalignment='bottom')\nax.text(B[0], B[1], '  B', fontsize=12, verticalalignment='top', horizontalalignment='right')\nax.text(C[0], C[1], '  C', fontsize=12, verticalalignment='top', horizontalalignment='left')\nax.text(P[0], P[1], '  P', fontsize=12, verticalalignment='bottom', horizontalalignment='right', color='purple')\nax.scatter(circumcenter_point[0], circumcenter_point[1], color='black')  # 外心O\n\n# グリッドと範囲設定\nax.axhline(0, color='black', linewidth=0.5)\nax.axvline(0, color='black', linewidth=0.5)\nax.grid(True, linestyle='--', alpha=0.6)\nax.set_xlim(-radius-5, BC+radius+5)\nax.set_ylim(-radius-5, radius+AC+5)\nax.legend()\nax.set_title(\"Triangle ABC with Circumcircle and Inscribed Angle\")\n\n# 図を表示\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 2\n\n\n\n\n\n\n\n\nExercise 2 \nとある山へハイキングにいくとします．\n\n山頂をC\n山の麓のA地点から同じ標高で直線距離で1000m離れている地点をB\nA地点からCを見たときの仰角は \\(30^\\circ\\)\n\\(\\triangle ABC\\) について，\\(\\angle CAB = 75^\\circ, \\angle ABC = 45^\\circ\\)\n\nということがわかっているとします．このとき，Cの標高を求めよ．なお，\\(A, B\\) の標高は 0m とする．\n\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.mplot3d.art3d import Poly3DCollection\n\n# Given angles and side lengths\nangle_A = np.radians(75)\nangle_B = np.radians(45)\nAB = 1000  # Given\n\n# Compute angle C\nangle_C = np.radians(180 - 75 - 45)  # C = 60 degrees\n\n# Compute sides using the Law of Sines\nBC = AB * np.sin(angle_A) / np.sin(angle_C)\nAC = AB * np.sin(angle_B) / np.sin(angle_C)\n\n# Compute coordinates of A, B, and C\nA = np.array([0, 0, 0])  # A is the origin\nB = np.array([AB, 0, 0])  # B is along the x-axis\nC_x = 0  # Projection of AC on x-axis\nC_y = AC * np.cos(np.radians(30))\nC_z = AC * np.sin(np.radians(30))  # Projection on y-axis\nC = np.array([0, C_y, C_z])  # C remains in the XY plane\n\n# Triangle ACH: Given CAH = 30°, CHA = 90° (Right Triangle)\nangle_CAH = np.radians(30)\n\n# H's coordinates (directly above C in the Z direction)\nH = np.array([0, C_y, 0])\n\n# Create 3D plot\nfig = plt.figure(figsize=(8, 8))\nax = fig.add_subplot(111, projection='3d')\n\n# Plot edges of tetrahedron\nedges = [\n    (A, B), (B, C), (C, A),  # Triangle ABC\n    (A, H), (C, H), (B, H)   # Connecting H to A, C, and B\n]\n\nfor edge in edges:\n    ax.plot(*zip(*edge), 'k-')\n\n# Define faces for tetrahedron visualization\nfaces = [\n    [A, B, C],  # Base ABC\n    [A, C, H],  # Side ACH\n    [C, B, H],  # Side CBH\n    [A, H, B]   # Side AHB\n]\n\n# Add face shading\nax.add_collection3d(Poly3DCollection(faces, alpha=0.3, color='cyan'))\n\n# Annotate points\nax.text(*A, \" A\", color='black', fontsize=12)\nax.text(*B, \" B\", color='black', fontsize=12)\nax.text(*C, \" C\", color='black', fontsize=12)\nax.text(*H, \" H\", color='black', fontsize=12)\n\n# Labels and grid\nax.set_xlabel(\"X-axis\")\nax.set_ylabel(\"Y-axis\")\nax.set_zlabel(\"Z-axis\")\nax.set_title(\"3D Tetrahedron CAHB\")\nax.grid(True)\n\nax.view_init(elev=20, azim=-55) \n\n# Show the plot\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 3\n\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n上の図のようにCから\\(XY\\)平面に垂線を下ろして，XY平面との交点を \\(H\\) としたとき，今回求めたい長さは \\(CH\\)．\n問題文の情報を用いて正弦定理を利用すると\n\\[\n\\displaystyle AC = \\frac{AB}{\\sin (\\angle ACB)} \\cdot \\sin(\\angle ABC)\n\\]\nここで\n\\[\n\\begin{align}\nCH &= AC \\cdot \\sin(\\angle CAH)\\\\\n    &= \\frac{AB}{\\sin (\\angle ACB)} \\cdot \\sin(\\angle ABC) \\cdot \\sin(\\angle CAH)\n\\end{align}\n\\]\n従って，\n\n\nCode\nprint(f\"CH = {C_z:.2f}\")\n\n\nCH = 408.25"
  },
  {
    "objectID": "posts/2025-02-28-cavalieri-principle/index.html",
    "href": "posts/2025-02-28-cavalieri-principle/index.html",
    "title": "カバリエリの原理",
    "section": "",
    "text": "一辺長さ \\(2\\) の正方形を底面として高さ3の直方体と，それをちょっとずつねじる形でずらした立体を以下のように考えます． 右図において，\\(xy\\) 平面に並行な各断面はどれも等しく一辺の長さ \\(2\\) の正方形で，その面積は \\(4\\) となってるとします．\nこのとき，カバリエリの原理よりどちらの立体像の体積は等しいことが言えます．\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.mplot3d.art3d import Poly3DCollection\n\n\ndef plot_cuboid(data, length=2, width=2, height=3, ax=None):\n    if ax is None:\n        fig = plt.figure()\n        ax = fig.add_subplot(111, projection=\"3d\")\n    poly3d = Poly3DCollection(data, alpha=0.2, edgecolor=\"k\")\n    ax.add_collection3d(poly3d)\n\n    # Set limits\n    max_dim = max(length, width, height)\n    ax.set_xlim([-max_dim, max_dim])\n    ax.set_ylim([-max_dim, max_dim])\n    ax.set_zlim([0, height * 1.1])\n    ax.set_xlabel(\"X\")\n    ax.set_ylabel(\"Y\")\n    ax.set_zlabel(\"Z\")\n\n\ndef twisted_cuboid(\n    length=2, width=2, height=3, twist_angle=np.pi / 2, num_segments=500\n):\n    # Define the base (bottom) of the cuboid\n    base_vertices = np.array(\n        [\n            [-length / 2, -width / 2, 0],\n            [length / 2, -width / 2, 0],\n            [length / 2, width / 2, 0],\n            [-length / 2, width / 2, 0],\n        ]\n    )\n\n    # Define the top face with a twist\n    rotation_matrix = np.array(\n        [\n            [np.cos(twist_angle), -np.sin(twist_angle), 0],\n            [np.sin(twist_angle), np.cos(twist_angle), 0],\n            [0, 0, 1],\n        ]\n    )\n    top_vertices = base_vertices @ rotation_matrix.T + np.array([0, 0, height])\n\n    # Interpolate between base and top vertices\n    vertices = []\n    for i in range(num_segments + 1):\n        t = i / num_segments\n        interpolated_vertices = (1 - t) * base_vertices + t * top_vertices\n        vertices.append(interpolated_vertices)\n    vertices = np.vstack(vertices)\n\n    # Define faces\n    faces = []\n    for i in range(num_segments):\n        for j in range(4):\n            next_j = (j + 1) % 4\n            faces.append(\n                [\n                    vertices[i * 4 + j],\n                    vertices[i * 4 + next_j],\n                    vertices[(i + 1) * 4 + next_j],\n                    vertices[(i + 1) * 4 + j],\n                ]\n            )\n\n    return faces\n\n\ndef cuboid(length=2, width=2, height=3, num_segments=100, ax=None):\n    # Define the base (bottom) of the cuboid\n    base_vertices = np.array(\n        [\n            [-length / 2, -width / 2, 0],\n            [length / 2, -width / 2, 0],\n            [length / 2, width / 2, 0],\n            [-length / 2, width / 2, 0],\n        ]\n    )\n\n    # Define the top face without a twist\n    top_vertices = base_vertices + np.array([0, 0, height])\n\n    # Interpolate between base and top vertices\n    vertices = []\n    for i in range(num_segments + 1):\n        t = i / num_segments\n        interpolated_vertices = (1 - t) * base_vertices + t * top_vertices\n        vertices.append(interpolated_vertices)\n    vertices = np.vstack(vertices)\n\n    # Define faces\n    faces = []\n    for i in range(num_segments):\n        for j in range(4):\n            next_j = (j + 1) % 4\n            faces.append(\n                [\n                    vertices[i * 4 + j],\n                    vertices[i * 4 + next_j],\n                    vertices[(i + 1) * 4 + next_j],\n                    vertices[(i + 1) * 4 + j],\n                ]\n            )\n\n    return faces\n\n\n# compute points\ncuboid_records = cuboid()\ntwisted_cuboid_records = twisted_cuboid()\n\n# plots\nfig = plt.figure(figsize=(12, 6))\nax1 = fig.add_subplot(121, projection=\"3d\")\nax2 = fig.add_subplot(122, projection=\"3d\")\n\nplot_cuboid(cuboid_records, ax=ax1)\nplot_cuboid(twisted_cuboid_records, ax=ax2)\n\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\nTheorem 1 : カバリエリの原理 \n2つの立体について，平行な平面で切った切り口を比べる．互いの面積がいつも等しいならば，この２つの立体の体積は等しい．\n\n\n半径 \\(r\\) の円を底面とする高さ \\(h\\) の円柱を考えます． なお \\(h = r\\) とします．この円柱から，半径 \\(r\\) の円を底面とする円錐を以下のように抜き取った立体を作ります（以降，穴あき円柱と呼ぶ）．\n\n\n\nカバリエリの原理\n\n\nこの穴開き円柱の体積は\n\\[\n\\begin{align}\n\\pi r^2\\times h - \\pi r^2\\times \\frac{h}{3}\n    &= \\frac{2}{3} \\pi r^2 h\n\\end{align}\n\\]\n一方，半径 \\(r\\) の半球の体積は\n\\[\n\\begin{align}\n\\frac{1}{2} \\times \\frac{4}{3}\\pi r^3 = \\frac{2}{3} \\pi r^2h\n\\end{align}\n\\]\n２つの立体の体積が一致することがわかります．これをカバリエリの原理を使って確かめてみます．\nまず穴あき円錐について，高さ \\(a \\in [0, h]\\) における断面積（緑色の部分）は\n\\[\nr^2\\pi - \\left(\\frac{a}{r}r\\right)^2\\pi = (r^2 - a^2)\\pi\n\\]\n半球の方は，ピタゴラスの定理より高さ \\(a\\) のときの半径が \\(\\sqrt{r^2 - a^2}\\) と求まるので\n\\[\n(\\sqrt{r^2 - a^2})^2\\pi = (r^2 - a^2)\\pi\n\\]\n従って，２つの立体について任意の高さ \\(a \\in [0, h]\\) において互いの面積がいつも等しいことがわかります．\n\n\n半径 \\(r\\), 弧の長さ \\(l\\) の扇形の面積を求めたいとします．扇形に対し，分割交互ずらしをして以下のように長方形へ極限等積変形を実施します．\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom matplotlib.patches import Wedge, Polygon\n\n# Parameters\nr = 1  # radius\nl = 0.5  # arc length\n\n# Calculate the angle of the sector\ntheta = l / r  # in radians\ndivide_num = 4\n\n# Create the sector\nfig, ax = plt.subplots(1, 2, figsize=(12, 6))\n\n# Plot the original sector\nsector = Wedge(\n    (0, 0), r, 0, np.degrees(theta), facecolor=\"lightblue\", edgecolor=\"black\"\n)\nax[0].add_patch(sector)\nax[0].set_xlim(-0.1, r * 1.2)\nax[0].set_ylim(-0.1, l)\nax[0].set_aspect(\"equal\", \"box\")\nax[0].set_title(\"Original Sector\")\n\n# Divide the sector into four parts\nangles = np.linspace(0, theta, divide_num+1)\nfor i in range(divide_num):\n    wedge = Wedge(\n        (0, 0),\n        r,\n        np.degrees(angles[i]),\n        np.degrees(angles[i + 1]),\n        facecolor=\"none\",\n        edgecolor=\"black\",\n    )\n    ax[0].add_patch(wedge)\n\n# Rearrange the parts into a parallelogram\n\n# Create the parallelogram by shifting the parts\nfor i in range(divide_num):\n    if i % 2 == 0:\n        sector = Wedge(\n            (0, np.sin(theta / divide_num) * (i // 2)), r, 0, np.degrees(theta / divide_num), facecolor=\"lightblue\", edgecolor=\"black\"\n        )\n    else:\n        sector = Wedge(\n            (np.cos(theta / divide_num), np.sin(theta / divide_num) * (i // 2 + 1 )),\n            r,\n            np.degrees(np.pi),\n            np.degrees(theta / divide_num + np.pi),\n            facecolor=\"lightblue\",\n            edgecolor=\"black\",\n        )\n    ax[1].add_patch(sector)\n    \n\n# add info\nax[1].text(1.01, l/4, f\"Height = $l/2$\", horizontalalignment=\"left\")\n\nax[1].set_xlim(-0.1, r * 1.2)\nax[1].set_ylim(-0.1, l)\nax[1].set_aspect(\"equal\", \"box\")\nax[1].set_title(\"Rearranged into Parallelogram\")\n\nplt.show()\n\n\n\n\n\n\n\n\n\n上の図では４分割ですが，これを細かくすると横の長さ \\(r\\), 縦の長さ \\(l/2\\) の長方形へ変形することができるとみなせるので\n\\[\nS = \\frac{l}{2}r\n\\]\nと計算することが出来ます．半径 \\(r\\), 弧の長さ \\(l = 2\\pi r\\) のとき，扇形は円になりますが，その円の面積も同様に\n\\[\nS = \\frac{2\\pi r}{2}r = r^2 \\pi\n\\]\nと計算でき，円の面積の公式と一致することがわかります\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom matplotlib.patches import Wedge, Polygon\n\n# Parameters\nr = 2  # radius\nl = 2*np.pi * r  # arc length\n\n# Calculate the angle of the sector\ntheta = l / r  # in radians\ndivide_num = 100\n\n# Create the sector\nfig, ax = plt.subplots(1, 2, figsize=(12, 6))\n\n# Plot the original sector\nsector = Wedge(\n    (0, 0), r, 0, np.degrees(theta), facecolor=\"lightblue\", edgecolor=\"black\"\n)\nax[0].add_patch(sector)\nax[0].set_xlim(-r * 1.2, r * 1.2)\nax[0].set_ylim(-r * 1.2, r * 1.2)\nax[0].set_aspect(\"equal\", \"box\")\nax[0].set_title(\"Original Sector\")\n\n# Divide the sector into four parts\nangles = np.linspace(0, theta, divide_num+1)\nfor i in range(divide_num):\n    wedge = Wedge(\n        (0, 0),\n        r,\n        np.degrees(angles[i]),\n        np.degrees(angles[i + 1]),\n        facecolor=\"none\",\n        edgecolor=\"black\",\n    )\n    ax[0].add_patch(wedge)\n\n# Rearrange the parts into a parallelogram\n\n# Create the parallelogram by shifting the parts\nfor i in range(divide_num):\n    if i % 2 == 0:\n        sector = Wedge(\n            (0, np.sin(theta / divide_num) * (i // 2)* r), r, 0, np.degrees(theta / divide_num), facecolor=\"lightblue\", edgecolor=\"black\"\n        )\n    else:\n        sector = Wedge(\n            (np.cos(theta / divide_num)* r, np.sin(theta / divide_num) * r * (i // 2 + 1 )),\n            r,\n            np.degrees(np.pi),\n            np.degrees(theta / divide_num + np.pi),\n            facecolor=\"lightblue\",\n            edgecolor=\"black\",\n        )\n    ax[1].add_patch(sector)\n    \n\n# add info\nax[1].text(r + 0.01, l/4, f\"Height = $r\\pi$\", horizontalalignment=\"left\")\n\nax[1].set_xlim(-0.5, r * 1.2)\nax[1].set_ylim(-0.5, l/2 * 1.05)\nax[1].set_aspect(\"equal\", \"box\")\nax[1].set_title(\"Rearranged into Parallelogram\")\n\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n半径 \\(2\\), 弧の長さが \\(\\displaystyle L = \\frac{2}{3}\\pi\\) の扇形から，半径 \\(2/3\\), 弧の長さが \\(\\displaystyle l = \\frac{2}{9}\\pi\\) の扇形を除いたパイン形を考えます．このパイン形に対して，「分割交互ずらし」を適用して極限を取ると，底辺の長さ \\(\\displaystyle \\frac{4}{3}\\)，高さ\n\\[\n\\text{height} = \\frac{l + L}{2} = \\frac{4}{9}\\pi\n\\]\nの長方形へ収束します．このとき，このパイン型の面積は\n\\[\nS = \\frac{l + L}{2}\\times \\frac{4}{3} = \\frac{16}{27}\\pi\n\\]\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom shapely.geometry import Polygon\nfrom shapely.affinity import translate\nfrom shapely.ops import unary_union\nfrom shapely.affinity import rotate\nimport geopandas as gpd\n\n\ndef create_sector(center, radius, angle_start, angle_end, num_points=100):\n    \"\"\"Creates a sector shape as a polygon using Shapely.\"\"\"\n    angles = np.linspace(np.radians(angle_start), np.radians(angle_end), num_points)\n    outer_arc = [\n        (center[0] + radius * np.cos(a), center[1] + radius * np.sin(a)) for a in angles\n    ]\n    return Polygon([center] + outer_arc + [center])  # Close the polygon\n\n\n# Parameters\ndivide_num = 20\nring_sector_list = []\nouter_radius = 2\nangle = 60 / divide_num\n\nfor i in range(divide_num):\n    center = (0, 0)\n    inner_radius = outer_radius / 3\n    angle_start, angle_end = angle * i, angle * (i + 1)  # Angle in degrees\n\n    # Create outer and inner sectors\n    outer_sector = create_sector(center, outer_radius, angle_start, angle_end)\n    inner_sector = create_sector(center, inner_radius, angle_start, angle_end)\n\n    # Subtract inner sector from outer sector to get the ring shape\n    ring_sector = outer_sector.difference(inner_sector)\n    ring_sector_list.append(ring_sector)\n\n\n# plot\nfig, ax = plt.subplots(1, 2, figsize=(12, 6))\n\nfor ring_sector in ring_sector_list:\n    # Plot using GeoPandas\n    gdf = gpd.GeoSeries([ring_sector])\n    gdf.plot(ax=ax[0], color=\"lightblue\", edgecolor=\"black\")\n\n# Formatting\nax[0].set_xlim(-0.05, outer_radius + 0.1)\nax[0].set_ylim(-0.05, outer_radius + 0.1)\n\ngdf = gpd.GeoSeries([ring_sector_list[0]])\nrotated_gdf = gpd.GeoSeries(rotate(ring_sector_list[0], 180, origin=\"center\"))\nfor i in range(len(ring_sector_list)):\n    # Plot using GeoPandas\n    if i % 2 == 0:\n        gdf_tmp = gdf.apply(\n            lambda geom: translate(\n                geom, xoff=-2/3, yoff=np.sin(np.radians(angle))*8/3 * (i//2)\n            )\n        )\n        gdf_tmp.plot(ax=ax[1], color=\"lightblue\", edgecolor=\"black\")\n    else:\n        gdf_tmp = rotated_gdf.apply(\n            lambda geom: translate(\n                geom, xoff=-2/3, yoff=np.sin(np.radians(angle))*2/3 * (i//2 + 1) + np.sin(np.radians(angle))*6/3 * (i//2)\n            ))\n        gdf_tmp.plot(ax=ax[1], color=\"lightblue\", edgecolor=\"black\")\n\n\nplt.show()"
  },
  {
    "objectID": "posts/2025-02-28-cavalieri-principle/index.html#カバリエリの原理",
    "href": "posts/2025-02-28-cavalieri-principle/index.html#カバリエリの原理",
    "title": "カバリエリの原理",
    "section": "",
    "text": "一辺長さ \\(2\\) の正方形を底面として高さ3の直方体と，それをちょっとずつねじる形でずらした立体を以下のように考えます． 右図において，\\(xy\\) 平面に並行な各断面はどれも等しく一辺の長さ \\(2\\) の正方形で，その面積は \\(4\\) となってるとします．\nこのとき，カバリエリの原理よりどちらの立体像の体積は等しいことが言えます．\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.mplot3d.art3d import Poly3DCollection\n\n\ndef plot_cuboid(data, length=2, width=2, height=3, ax=None):\n    if ax is None:\n        fig = plt.figure()\n        ax = fig.add_subplot(111, projection=\"3d\")\n    poly3d = Poly3DCollection(data, alpha=0.2, edgecolor=\"k\")\n    ax.add_collection3d(poly3d)\n\n    # Set limits\n    max_dim = max(length, width, height)\n    ax.set_xlim([-max_dim, max_dim])\n    ax.set_ylim([-max_dim, max_dim])\n    ax.set_zlim([0, height * 1.1])\n    ax.set_xlabel(\"X\")\n    ax.set_ylabel(\"Y\")\n    ax.set_zlabel(\"Z\")\n\n\ndef twisted_cuboid(\n    length=2, width=2, height=3, twist_angle=np.pi / 2, num_segments=500\n):\n    # Define the base (bottom) of the cuboid\n    base_vertices = np.array(\n        [\n            [-length / 2, -width / 2, 0],\n            [length / 2, -width / 2, 0],\n            [length / 2, width / 2, 0],\n            [-length / 2, width / 2, 0],\n        ]\n    )\n\n    # Define the top face with a twist\n    rotation_matrix = np.array(\n        [\n            [np.cos(twist_angle), -np.sin(twist_angle), 0],\n            [np.sin(twist_angle), np.cos(twist_angle), 0],\n            [0, 0, 1],\n        ]\n    )\n    top_vertices = base_vertices @ rotation_matrix.T + np.array([0, 0, height])\n\n    # Interpolate between base and top vertices\n    vertices = []\n    for i in range(num_segments + 1):\n        t = i / num_segments\n        interpolated_vertices = (1 - t) * base_vertices + t * top_vertices\n        vertices.append(interpolated_vertices)\n    vertices = np.vstack(vertices)\n\n    # Define faces\n    faces = []\n    for i in range(num_segments):\n        for j in range(4):\n            next_j = (j + 1) % 4\n            faces.append(\n                [\n                    vertices[i * 4 + j],\n                    vertices[i * 4 + next_j],\n                    vertices[(i + 1) * 4 + next_j],\n                    vertices[(i + 1) * 4 + j],\n                ]\n            )\n\n    return faces\n\n\ndef cuboid(length=2, width=2, height=3, num_segments=100, ax=None):\n    # Define the base (bottom) of the cuboid\n    base_vertices = np.array(\n        [\n            [-length / 2, -width / 2, 0],\n            [length / 2, -width / 2, 0],\n            [length / 2, width / 2, 0],\n            [-length / 2, width / 2, 0],\n        ]\n    )\n\n    # Define the top face without a twist\n    top_vertices = base_vertices + np.array([0, 0, height])\n\n    # Interpolate between base and top vertices\n    vertices = []\n    for i in range(num_segments + 1):\n        t = i / num_segments\n        interpolated_vertices = (1 - t) * base_vertices + t * top_vertices\n        vertices.append(interpolated_vertices)\n    vertices = np.vstack(vertices)\n\n    # Define faces\n    faces = []\n    for i in range(num_segments):\n        for j in range(4):\n            next_j = (j + 1) % 4\n            faces.append(\n                [\n                    vertices[i * 4 + j],\n                    vertices[i * 4 + next_j],\n                    vertices[(i + 1) * 4 + next_j],\n                    vertices[(i + 1) * 4 + j],\n                ]\n            )\n\n    return faces\n\n\n# compute points\ncuboid_records = cuboid()\ntwisted_cuboid_records = twisted_cuboid()\n\n# plots\nfig = plt.figure(figsize=(12, 6))\nax1 = fig.add_subplot(121, projection=\"3d\")\nax2 = fig.add_subplot(122, projection=\"3d\")\n\nplot_cuboid(cuboid_records, ax=ax1)\nplot_cuboid(twisted_cuboid_records, ax=ax2)\n\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\nTheorem 1 : カバリエリの原理 \n2つの立体について，平行な平面で切った切り口を比べる．互いの面積がいつも等しいならば，この２つの立体の体積は等しい．\n\n\n半径 \\(r\\) の円を底面とする高さ \\(h\\) の円柱を考えます． なお \\(h = r\\) とします．この円柱から，半径 \\(r\\) の円を底面とする円錐を以下のように抜き取った立体を作ります（以降，穴あき円柱と呼ぶ）．\n\n\n\nカバリエリの原理\n\n\nこの穴開き円柱の体積は\n\\[\n\\begin{align}\n\\pi r^2\\times h - \\pi r^2\\times \\frac{h}{3}\n    &= \\frac{2}{3} \\pi r^2 h\n\\end{align}\n\\]\n一方，半径 \\(r\\) の半球の体積は\n\\[\n\\begin{align}\n\\frac{1}{2} \\times \\frac{4}{3}\\pi r^3 = \\frac{2}{3} \\pi r^2h\n\\end{align}\n\\]\n２つの立体の体積が一致することがわかります．これをカバリエリの原理を使って確かめてみます．\nまず穴あき円錐について，高さ \\(a \\in [0, h]\\) における断面積（緑色の部分）は\n\\[\nr^2\\pi - \\left(\\frac{a}{r}r\\right)^2\\pi = (r^2 - a^2)\\pi\n\\]\n半球の方は，ピタゴラスの定理より高さ \\(a\\) のときの半径が \\(\\sqrt{r^2 - a^2}\\) と求まるので\n\\[\n(\\sqrt{r^2 - a^2})^2\\pi = (r^2 - a^2)\\pi\n\\]\n従って，２つの立体について任意の高さ \\(a \\in [0, h]\\) において互いの面積がいつも等しいことがわかります．\n\n\n半径 \\(r\\), 弧の長さ \\(l\\) の扇形の面積を求めたいとします．扇形に対し，分割交互ずらしをして以下のように長方形へ極限等積変形を実施します．\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom matplotlib.patches import Wedge, Polygon\n\n# Parameters\nr = 1  # radius\nl = 0.5  # arc length\n\n# Calculate the angle of the sector\ntheta = l / r  # in radians\ndivide_num = 4\n\n# Create the sector\nfig, ax = plt.subplots(1, 2, figsize=(12, 6))\n\n# Plot the original sector\nsector = Wedge(\n    (0, 0), r, 0, np.degrees(theta), facecolor=\"lightblue\", edgecolor=\"black\"\n)\nax[0].add_patch(sector)\nax[0].set_xlim(-0.1, r * 1.2)\nax[0].set_ylim(-0.1, l)\nax[0].set_aspect(\"equal\", \"box\")\nax[0].set_title(\"Original Sector\")\n\n# Divide the sector into four parts\nangles = np.linspace(0, theta, divide_num+1)\nfor i in range(divide_num):\n    wedge = Wedge(\n        (0, 0),\n        r,\n        np.degrees(angles[i]),\n        np.degrees(angles[i + 1]),\n        facecolor=\"none\",\n        edgecolor=\"black\",\n    )\n    ax[0].add_patch(wedge)\n\n# Rearrange the parts into a parallelogram\n\n# Create the parallelogram by shifting the parts\nfor i in range(divide_num):\n    if i % 2 == 0:\n        sector = Wedge(\n            (0, np.sin(theta / divide_num) * (i // 2)), r, 0, np.degrees(theta / divide_num), facecolor=\"lightblue\", edgecolor=\"black\"\n        )\n    else:\n        sector = Wedge(\n            (np.cos(theta / divide_num), np.sin(theta / divide_num) * (i // 2 + 1 )),\n            r,\n            np.degrees(np.pi),\n            np.degrees(theta / divide_num + np.pi),\n            facecolor=\"lightblue\",\n            edgecolor=\"black\",\n        )\n    ax[1].add_patch(sector)\n    \n\n# add info\nax[1].text(1.01, l/4, f\"Height = $l/2$\", horizontalalignment=\"left\")\n\nax[1].set_xlim(-0.1, r * 1.2)\nax[1].set_ylim(-0.1, l)\nax[1].set_aspect(\"equal\", \"box\")\nax[1].set_title(\"Rearranged into Parallelogram\")\n\nplt.show()\n\n\n\n\n\n\n\n\n\n上の図では４分割ですが，これを細かくすると横の長さ \\(r\\), 縦の長さ \\(l/2\\) の長方形へ変形することができるとみなせるので\n\\[\nS = \\frac{l}{2}r\n\\]\nと計算することが出来ます．半径 \\(r\\), 弧の長さ \\(l = 2\\pi r\\) のとき，扇形は円になりますが，その円の面積も同様に\n\\[\nS = \\frac{2\\pi r}{2}r = r^2 \\pi\n\\]\nと計算でき，円の面積の公式と一致することがわかります\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom matplotlib.patches import Wedge, Polygon\n\n# Parameters\nr = 2  # radius\nl = 2*np.pi * r  # arc length\n\n# Calculate the angle of the sector\ntheta = l / r  # in radians\ndivide_num = 100\n\n# Create the sector\nfig, ax = plt.subplots(1, 2, figsize=(12, 6))\n\n# Plot the original sector\nsector = Wedge(\n    (0, 0), r, 0, np.degrees(theta), facecolor=\"lightblue\", edgecolor=\"black\"\n)\nax[0].add_patch(sector)\nax[0].set_xlim(-r * 1.2, r * 1.2)\nax[0].set_ylim(-r * 1.2, r * 1.2)\nax[0].set_aspect(\"equal\", \"box\")\nax[0].set_title(\"Original Sector\")\n\n# Divide the sector into four parts\nangles = np.linspace(0, theta, divide_num+1)\nfor i in range(divide_num):\n    wedge = Wedge(\n        (0, 0),\n        r,\n        np.degrees(angles[i]),\n        np.degrees(angles[i + 1]),\n        facecolor=\"none\",\n        edgecolor=\"black\",\n    )\n    ax[0].add_patch(wedge)\n\n# Rearrange the parts into a parallelogram\n\n# Create the parallelogram by shifting the parts\nfor i in range(divide_num):\n    if i % 2 == 0:\n        sector = Wedge(\n            (0, np.sin(theta / divide_num) * (i // 2)* r), r, 0, np.degrees(theta / divide_num), facecolor=\"lightblue\", edgecolor=\"black\"\n        )\n    else:\n        sector = Wedge(\n            (np.cos(theta / divide_num)* r, np.sin(theta / divide_num) * r * (i // 2 + 1 )),\n            r,\n            np.degrees(np.pi),\n            np.degrees(theta / divide_num + np.pi),\n            facecolor=\"lightblue\",\n            edgecolor=\"black\",\n        )\n    ax[1].add_patch(sector)\n    \n\n# add info\nax[1].text(r + 0.01, l/4, f\"Height = $r\\pi$\", horizontalalignment=\"left\")\n\nax[1].set_xlim(-0.5, r * 1.2)\nax[1].set_ylim(-0.5, l/2 * 1.05)\nax[1].set_aspect(\"equal\", \"box\")\nax[1].set_title(\"Rearranged into Parallelogram\")\n\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n半径 \\(2\\), 弧の長さが \\(\\displaystyle L = \\frac{2}{3}\\pi\\) の扇形から，半径 \\(2/3\\), 弧の長さが \\(\\displaystyle l = \\frac{2}{9}\\pi\\) の扇形を除いたパイン形を考えます．このパイン形に対して，「分割交互ずらし」を適用して極限を取ると，底辺の長さ \\(\\displaystyle \\frac{4}{3}\\)，高さ\n\\[\n\\text{height} = \\frac{l + L}{2} = \\frac{4}{9}\\pi\n\\]\nの長方形へ収束します．このとき，このパイン型の面積は\n\\[\nS = \\frac{l + L}{2}\\times \\frac{4}{3} = \\frac{16}{27}\\pi\n\\]\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom shapely.geometry import Polygon\nfrom shapely.affinity import translate\nfrom shapely.ops import unary_union\nfrom shapely.affinity import rotate\nimport geopandas as gpd\n\n\ndef create_sector(center, radius, angle_start, angle_end, num_points=100):\n    \"\"\"Creates a sector shape as a polygon using Shapely.\"\"\"\n    angles = np.linspace(np.radians(angle_start), np.radians(angle_end), num_points)\n    outer_arc = [\n        (center[0] + radius * np.cos(a), center[1] + radius * np.sin(a)) for a in angles\n    ]\n    return Polygon([center] + outer_arc + [center])  # Close the polygon\n\n\n# Parameters\ndivide_num = 20\nring_sector_list = []\nouter_radius = 2\nangle = 60 / divide_num\n\nfor i in range(divide_num):\n    center = (0, 0)\n    inner_radius = outer_radius / 3\n    angle_start, angle_end = angle * i, angle * (i + 1)  # Angle in degrees\n\n    # Create outer and inner sectors\n    outer_sector = create_sector(center, outer_radius, angle_start, angle_end)\n    inner_sector = create_sector(center, inner_radius, angle_start, angle_end)\n\n    # Subtract inner sector from outer sector to get the ring shape\n    ring_sector = outer_sector.difference(inner_sector)\n    ring_sector_list.append(ring_sector)\n\n\n# plot\nfig, ax = plt.subplots(1, 2, figsize=(12, 6))\n\nfor ring_sector in ring_sector_list:\n    # Plot using GeoPandas\n    gdf = gpd.GeoSeries([ring_sector])\n    gdf.plot(ax=ax[0], color=\"lightblue\", edgecolor=\"black\")\n\n# Formatting\nax[0].set_xlim(-0.05, outer_radius + 0.1)\nax[0].set_ylim(-0.05, outer_radius + 0.1)\n\ngdf = gpd.GeoSeries([ring_sector_list[0]])\nrotated_gdf = gpd.GeoSeries(rotate(ring_sector_list[0], 180, origin=\"center\"))\nfor i in range(len(ring_sector_list)):\n    # Plot using GeoPandas\n    if i % 2 == 0:\n        gdf_tmp = gdf.apply(\n            lambda geom: translate(\n                geom, xoff=-2/3, yoff=np.sin(np.radians(angle))*8/3 * (i//2)\n            )\n        )\n        gdf_tmp.plot(ax=ax[1], color=\"lightblue\", edgecolor=\"black\")\n    else:\n        gdf_tmp = rotated_gdf.apply(\n            lambda geom: translate(\n                geom, xoff=-2/3, yoff=np.sin(np.radians(angle))*2/3 * (i//2 + 1) + np.sin(np.radians(angle))*6/3 * (i//2)\n            ))\n        gdf_tmp.plot(ax=ax[1], color=\"lightblue\", edgecolor=\"black\")\n\n\nplt.show()"
  },
  {
    "objectID": "posts/2025-02-28-cavalieri-principle/index.html#線分の運動とずらし面積",
    "href": "posts/2025-02-28-cavalieri-principle/index.html#線分の運動とずらし面積",
    "title": "カバリエリの原理",
    "section": "線分の運動とずらし面積",
    "text": "線分の運動とずらし面積\n野球グラウンドをならすときトンボという道具を使ったりします．このトンボを引きづる用な形でグラウンドを適当に歩くと，トンボがなす線分がグラウンドを通過することで図形が出来ます． 線分の運動の観点から，この図形の面積を求める方法をここでは紹介します．\n\n\nCode\nfrom scipy import interpolate\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nN = 1000\n\nx = np.linspace(0, 5, N)\n\ny = (\n    np.sin(x)\n    + np.cos(x ** 2) / 10\n)\n\ndydx = np.cos(x) - (2 / 10) * np.sin(x ** 2) * x\ndydx = np.where(abs(dydx) &gt; 1e-10, dydx, 0)\n\n\nupper_x = []\nupper_y = []\nlower_x = []\nlower_y = []\n\nfor i in range(N):\n    if dydx[i] &lt; 0:\n        dy = abs(1/dydx[i])\n        dist = np.sqrt(dy**2 + 1) * 10\n        dx = 1 / dist\n        dy = dy / dist\n    elif dydx[i] &gt; 0:\n        dy = abs(1/dydx[i])\n        dist = np.sqrt(dy**2 + 1)  * 10\n        dx = -1/ dist\n        dy = dy / dist\n    else:\n        dx, dy = (0, 1 / 10)\n    \n    upper_y.append(y[i] + dy)\n    upper_x.append(x[i] + dx)\n    lower_y.append(y[i] - dy)\n    lower_x.append(x[i] - dx)\n\nfig, ax = plt.subplots()\n\nax.plot(x, y, label = 'Trajectory of the center point')\nax.plot(upper_x, upper_y, color='gray', linestyle='--')\nax.plot(lower_x, lower_y, color='gray', linestyle='--')\n\nax.set_aspect('equal', 'box')  # Ensure the x and y axes have the same ratio\n\nax.set_title(\"Trajectory of a bar with length 0.2\")\n\nplt.legend()\nplt.show()\n\n\n\n\n\n\n\n\n\n一般に，大きさのある物体（剛体という）の運動は，「並進運動」と「回転運動」の合成で表されます．長さ \\(0.2\\) のトンボがグラウンドを並進運動と回転運動で通過する際に描かれる図形をplotしたものが上の図となります． 灰色の点線がそれぞれトンボの両端の軌跡を描いており，青の実線がトンボの中心点の軌跡となります．トンボがならしたグラウンドの面積は灰色で囲まれたエリアとなります．\n ▶  shapely.Polygonを用いた面積の計算\n上記で中心点の軌跡から両端の軌跡の座標を計算してあるので，それらを用いて shapely.Polygon をまず定義します．\n\n\nCode\n# shapely.Polygonの設定\npolygon_coords = list(zip(upper_x, upper_y)) + list(zip(lower_x[::-1], lower_y[::-1]))\npolygon = Polygon(polygon_coords)\n\n# Plot the polygon\nfig, ax = plt.subplots()\nx, y = polygon.exterior.xy\nax.plot(x, y, color='black')\nax.fill(x, y, color='lightblue', alpha=0.5)\nax.set_title(\"Shapely Polygon from Upper and Lower Coordinates\")\nax.set_aspect('equal', 'box')  # Ensure the x and y axes have the same ratio\nplt.show()\n\n\n\n\n\n\n\n\n\nその後，Polygon によって定義された図形の面積を計算すれば良いので\n\n\nCode\npolygon.area\n\n\n1.2470071445781767\n\n\n ▶  曲線の長さの公式と線分の移動\n詳しい説明はのちの機会としますが，線分が履く面積は\n\\[\n\\text{線分がはく面積} = \\text{中点の移動距離} \\times \\text{線分の長さ}\n\\]\nで計算することが出来ます．線分の長さは \\(0.2\\) とわかっているので，「中点の移動距離」を求めれば面積が求まりそうなことがわかります．\n\n\nTheorem 2 : 曲線の長さ \n\\(y=f(x)\\) で表される曲線の \\(x \\in [a, b]\\) の部分の長さ \\(L\\) は，\n\\[\nL = \\int^b_a \\sqrt{1 + f^\\prime(x)^2} dx\n\\]\n​（ただし，\\(f(x)\\) は微分可能で \\(f^\\prime(x)\\) は連続とする）\n\n\n点 \\(x\\) から\\(\\Delta x\\) 動いたとき，\\(\\Delta y \\approx f^\\prime(x)\\Delta x\\) 動くことから，その区間での曲線の長さは\n\\[\n\\sqrt{(\\Delta x)^2 + (f^\\prime(x)\\Delta x)^2} = \\sqrt{1 + f^\\prime(x)^2}\\Delta x\n\\]\nで近似できます．従って，\\(\\Delta x \\to dx\\) と極限を取ることで\n\\[\nL = \\int^b_a \\sqrt{1 + f^\\prime(x)^2} dx\n\\]\nと理解することが出来ます．\n今回の曲線 \\(f(x)\\) は \\([0, 5]\\) 区間で以下のように記述することができるとします．\n\\[\nf(x) =  \\sin(x) + 0.1\\cos(x^2)\n\\]\nこのとき，\\(f(x)\\) の1次導関数は\n\\[\nf^\\prime(x) = \\cos(x) - 0.2 x \\sin(x^2)\n\\]\n従って，曲線の公式より\n\\[\nL = \\int^5_0 \\sqrt{1 +  \\cos^2(x) + 0.04 x^2 \\sin^2(x^2) - 0.4x\\cos(x)\\sin(x^2)}dx\n\\]\nscipy.integrate.quad を用いて数値計算すると\n\n\nCode\nfrom scipy.integrate import quad\n\n\ndef curve_length(x):\n    return np.sqrt(\n        np.cos(x) ** 2\n        + 1 / 25 * np.sin(x**2) ** 2 * x**2\n        - 2 / 5 * np.cos(x) * np.sin(x**2) * x\n        + 1\n    )\n\n\nprint(quad(curve_length, 0, 5)[0] * 0.2)\n\n\n1.24703476690297\n\n\nshapely.Polygon を用いた計算結果と近しい値であることから計算結果の妥当性をうかがい知ることができます．"
  },
  {
    "objectID": "posts/2025-02-04-add-distance-measurement/index.html",
    "href": "posts/2025-02-04-add-distance-measurement/index.html",
    "title": "単曲線と追加距離の計算",
    "section": "",
    "text": "▶  基本用語"
  },
  {
    "objectID": "posts/2025-02-04-add-distance-measurement/index.html#基本問題-曲線の長さを求める",
    "href": "posts/2025-02-04-add-distance-measurement/index.html#基本問題-曲線の長さを求める",
    "title": "単曲線と追加距離の計算",
    "section": "基本問題: 曲線の長さを求める",
    "text": "基本問題: 曲線の長さを求める\n\n\nExercise 1 \n下図に示すような単曲線ABを含む路線の中心線を設置することになった．\n\n扇形 \\(OAB\\) の半径 \\(r = 300\\)\n\\(\\displaystyle\\angle (IP) = \\frac{\\pi}{3}\\)\n\\(IP\\) までの追加距離を623(中心杭はAの手前にあるとする)\n\nとする．このとき，曲線の始点 \\(A\\) と 曲線の終点 \\(B\\) それぞれの追加距離を求めよ．なお，直線 \\(A(IP)\\) と \\(B(IP)\\) はそれぞれ円の接線であるとする．\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n\ndef draw_circle_with_two_tangent(x0, y0, r, ax, theta_start=0, theta_end=2 * np.pi, notations=('O', 'A', 'B', 'IP')):\n    # Generate circle points\n    theta = np.linspace(theta_start, theta_end, 720)\n    x_circle = x0 + r * np.cos(theta)\n    y_circle = y0 + r * np.sin(theta)\n\n    # plot\n    ax.plot(x_circle, y_circle, \"gray\", label=\"Circle (r={radius})\")\n    ax.plot([x0, x_circle[0]], [y0, y_circle[0]], \"gray\", linestyle=\"--\")\n    ax.plot([x0, x_circle[-1]], [y0, y_circle[-1]], \"gray\", linestyle=\"--\")\n    ax.text(x0, y0, notations[0], verticalalignment=\"top\", horizontalalignment=\"left\")\n    ax.scatter(x0, y0, color=\"k\")\n\n    # add text\n    ax.text(x_circle[-1], y_circle[-1], notations[1], label=\"Circle (r={radius})\")\n    ax.scatter(x_circle[-1], y_circle[-1], color=\"k\")\n    ax.text(x_circle[0], y_circle[0], notations[2], label=\"Circle (r={radius})\")\n    ax.scatter(x_circle[0], y_circle[0], color=\"k\")\n\n    # plot external intersection points\n    mid_theta = (theta_start + theta_end) / 2\n    diff_theta = (theta_end - theta_start) / 2 \n    external_x = np.cos(mid_theta) * abs(r / np.cos(diff_theta)) + x0\n    external_y = np.sin(mid_theta) * abs(r / np.cos(diff_theta)) + y0\n\n    ax.scatter(external_x, external_y, color=\"k\")\n    ax.text(external_x, external_y, notations[3], verticalalignment=\"bottom\", horizontalalignment=\"left\")\n    ax.plot(\n        [external_x, x_circle[0]], [external_y, y_circle[0]], \"gray\", linestyle=\"-\"\n    )\n    ax.plot(\n        [external_x, x_circle[-1]], [external_y, y_circle[-1]], \"gray\", linestyle=\"-\"\n    )\n\n    return {'A': (x_circle[-1], y_circle[-1]), 'B': (x_circle[0], y_circle[0]), 'IP': (external_x, external_y )}\n\n\n# params\nx0, y0, r0 = 200, 100, 300\ntheta_start = np.pi / 10\ntheta_end = np.pi / 10 + np.pi * 2/ 3\n\nfig, ax = plt.subplots(figsize=(6, 6))\ncoordinates = draw_circle_with_two_tangent(x0, y0, r0, ax, theta_start, theta_end)\nax.grid(True, linestyle=\"--\", alpha=0.6)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n曲線の始点 \\(A\\) の追加距離は\n\\[\nA\\text{の追加距離} = IP\\text{の追加距離} - \\text{A(IP)の長さ}\n\\]\n直線 \\(A(IP)\\) は中心点 \\(O\\) とする円に接しているので\n\\[\n\\text{AOの長さ} \\times \\tan(\\angle (IP)OA)\n\\]\n接弦定理と円周角の定理より \\(\\angle (IP)\\) の外角を \\(I\\) とすると\n\\[\n\\begin{align}\n\\angle AOB &= I\\\\\n\\angle (IP)OA &= \\frac{I}{2}\n\\end{align}\n\\]\nしたがって，\n\\[\n\\text{AOの長さ} \\times \\tan \\frac{I}{2}\n\\]\n以上より\n\\[\n\\begin{align}\nA\\text{の追加距離}\n    &= 623 - 300 \\times \\tan \\frac{\\pi}{3}\\\\\n    &= 623 - 300\\sqrt{3} \\approx 103.4\n\\end{align}\n\\]\nまた，\\(B\\text{の追加距離}\\) は，弧 \\(AB\\) の長さがわかれば\n\\[\nB\\text{の追加距離} = A\\text{の追加距離} + \\text{弧}AB\\text{の長さ}\n\\]\nと計算できる．\n\\[\n\\begin{align}\n\\text{弧}AB\\text{の長さ}\n    &= R \\times I\\\\\n    &= 300 \\times \\frac{2}{3}\\pi\\\\\n    &= 200\\pi\n\\end{align}\n\\]\nしたがって，\n\\[\nB\\text{の追加距離} \\approx 103.4 + 628.40 = 731.80\n\\]\n実際にAの追加距離をPythonで近似計算してみると\n\n\nCode\nA, IP = np.array(coordinates['A']), np.array(coordinates['IP'])\nA_add_distance = 623 - np.linalg.norm(A - IP)\nprint(f\"Aの追加距離 = {A_add_distance:.2f}\")\n\n\nAの追加距離 = 103.38\n\n\n\n\n\n\n\nExercise 2 \n曲線半径 \\(r_1 = 400\\), \\(\\displaystyle\\angle AO_1B = \\frac{\\pi}{2}\\) となるような形で現道路 \\(AB\\) が存在するとする． 現在の道路を改良し \\(O_2\\) を中心とする円曲線からなる新しい道路 \\(AB_2\\) を建設したいとします．\n新しい道路の交点 \\(IP\\) の１は現道路と変わらないとする．\n\\(\\displaystyle\\angle AO_2B_2 = \\frac{\\pi}{3}\\) としたとき，\\(AB_2\\) の路線長を求めよ．\n\n\nCode\n# params\nx0, y0, r0 = 200, 100, 400\ntheta_start = np.pi / 3\ntheta_end = np.pi / 3 + np.pi / 2\n\nfig, ax = plt.subplots(figsize=(6, 6))\ncoordinates = draw_circle_with_two_tangent(x0, y0, r0, ax, theta_start, theta_end, ('$O_1$', '$A$', '$B_1$', '$IP$'))\nax.grid(True, linestyle=\"--\", alpha=0.6)\n\nr_new = 400 / np.tan(np.pi/6) \nA = np.array(coordinates['A'])\nO = np.array((200, 100))\nAO = O - A\nO_new = A + (AO / np.linalg.norm(AO)) * r_new\n\ncoordinates_new = draw_circle_with_two_tangent(*O_new, r_new, ax, theta_end - np.pi/3, theta_end, ('$O_2$', '$A$', '$B_2$', '$IP$'))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n新道路の曲線半径を \\(r_2\\) としたとき，\\(A(IP)\\) の長さは\n\\[\n\\begin{align}\nA(IP)\n    &= r_1 \\times \\tan \\frac{\\pi}{4}\\\\\n    &= r_2 \\times \\tan \\frac{\\pi}{6}\n\\end{align}\n\\]\nと表されるので\n\\[\n\\begin{align}\nr_2\n    &= \\frac{400 \\times 1 }{\\tan \\frac{\\pi}{6}}\\\\\n    &= 400\\times \\sqrt{3}\n    &\\approx 400\\times 1.732\\\\\n    &= 692.8\n\\end{align}\n\\]\nしたがって，\n\\[\n\\text{曲線}AB_2 = 692.8 \\times \\frac{\\pi}{3} \\approx 725.1\n\\]"
  },
  {
    "objectID": "posts/2025-02-04-add-distance-measurement/index.html#障害物がある場合の曲線設定",
    "href": "posts/2025-02-04-add-distance-measurement/index.html#障害物がある場合の曲線設定",
    "title": "単曲線と追加距離の計算",
    "section": "障害物がある場合の曲線設定",
    "text": "障害物がある場合の曲線設定\n\n\nExercise 3 \n\n曲線半径 \\(r = 200\\)\n\\(A_1B_1\\) の長さ 100\n\\(\\angle AA_1B_1 = 150^\\circ\\)\n\\(\\angle BB_1A_1 = 120^\\circ\\)\n\nという情報が与えられているとき，線分 \\(AA_1\\) の長さを求めよ．なお，直線 \\(A(IP)\\) と \\(B(IP)\\) はそれぞれ円の接線であるとする．\n\n\nCode\n# params\nx0, y0, r0 = 200, 100, 200\ntheta_start = np.pi / 3\ntheta_end = theta_start + np.pi / 2\n\nfig, ax = plt.subplots(figsize=(6, 6))\nax.grid(True, linestyle=\"--\", alpha=0.6)\n\n## draw an arc\ncoordinates = draw_circle_with_two_tangent(x0, y0, r0, ax, theta_start, theta_end, ('$O$', '$A$', '$B$', '$IP$'))\n\n## drar mid-points\nB_IP = np.array(coordinates['B']) - np.array(coordinates['IP'])\nA_IP = np.array(coordinates['A']) - np.array(coordinates['IP'])\nB_1 = np.array(coordinates['IP']) + B_IP / np.linalg.norm(B_IP) * 100 / 2\nA_1 = np.array(coordinates['IP']) + A_IP / np.linalg.norm(A_IP) * 100 / 2 * np.sqrt(3)\n\nax.plot(\n        [A_1[0], B_1[0]], [A_1[1], B_1[1]], \"gray\", linestyle=\"-\"\n    )\n\nax.text(A_1[0], A_1[1], \"$A_1$\")\nax.text(B_1[0], B_1[1], \"$B_1$\")\n\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\\(\\displaystyle\\angle AOB = \\frac{\\pi}{2}\\) であるので\n\\[\n\\text{length of }A(IP) = 200 \\times \\tan 45^\\circ = 200\n\\]\n正弦定理より\n\\[\n\\frac{A_1B_1}{\\sin \\angle (IP)} = \\frac{A_1(IP)}{\\sin \\angle (IP)B_1A_1}\n\\]\nしたがって，\n\\[\n\\begin{align}\n\\text{length of }A_1(IP)\n    &= 100 \\times \\sin \\angle (IP)B_1A_1\\\\\n    &= 100 \\times \\frac{\\sqrt{3}}{2}\\\\\n    &\\approx 50 \\times 1.732 = 86.60\n\\end{align}\n\\]\n以上より\n\\[\n\\text{length of }AA_1 = 200 - 86.60 = 113.40\n\\]\nPythonで確認すると\n\n\nCode\nres = np.linalg.norm(np.array(coordinates['A']) - A_1)\nprint(f\"点Aから点A_1までの距離 = {res:.2f}\")\n\n\n点Aから点A_1までの距離 = 113.40"
  }
]