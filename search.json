[
  {
    "objectID": "dashboard/dashboard.html",
    "href": "dashboard/dashboard.html",
    "title": "regmonkey datascience blog",
    "section": "",
    "text": "Total Posts\n\n\n83\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPosts in This Month\n\n\n3\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLast Update\n\n\n\n\n2025-09-14"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Regmonkey Datascience Blog",
    "section": "",
    "text": "Order By\n      Default\n      \n        Date - Oldest\n      \n      \n        Date - Newest\n      \n      \n        Title\n      \n    \n  \n    \n      \n      \n    \n\n\n\n\n\n\nDate\n\n\n\nTitle\n\n\n\nCategories\n\n\n\nReading Time\n\n\n\n\n\n\n\n\n2025-09-12\n\n\n代表的なカーネル関数\n\n\n統計\n\n\n3 min\n\n\n\n\n\n\n2025-09-05\n\n\nSambaの設定とiPad連携\n\n\n環境構築, Linux\n\n\n20 min\n\n\n\n\n\n\n2025-09-02\n\n\nThesis Statementの書き方\n\n\n方法論\n\n\n5 min\n\n\n\n\n\n\n2025-08-27\n\n\nBias-Variance Tradeoff\n\n\n統計\n\n\n3 min\n\n\n\n\n\n\n2025-08-26\n\n\nシェルスクリプト用のUnit Testingフレームワーク: Bats\n\n\n環境構築, shell\n\n\n8 min\n\n\n\n\n\n\n2025-08-25\n\n\nColumnar Storageの特徴\n\n\nSQL\n\n\n2 min\n\n\n\n\n\n\n2025-08-18\n\n\nflatpak経由でMeldをインストール\n\n\n環境構築\n\n\n7 min\n\n\n\n\n\n\n2025-08-17\n\n\nclam antivirusの導入\n\n\n環境構築, Linux, security\n\n\n5 min\n\n\n\n\n\n\n2025-08-16\n\n\nUbuntu 24.04.3へのupgrade\n\n\n環境構築, Linux\n\n\n6 min\n\n\n\n\n\n\n2025-08-02\n\n\n環境変数 PYTHONSTARTUP の目的\n\n\n環境構築, python\n\n\n4 min\n\n\n\n\n\n\n2025-08-01\n\n\nUbuntu 22.04でのfirewall設定\n\n\n環境構築, Linux, firewall\n\n\n10 min\n\n\n\n\n\n\n2025-07-31\n\n\nQuarto Projectへのpseudocode extensions導入\n\n\npseudocode, quarto\n\n\n8 min\n\n\n\n\n\n\n2025-07-30\n\n\nなぜテキストファイルは改行で終わるべきなのか？\n\n\ncoding\n\n\n7 min\n\n\n\n\n\n\n2025-07-29\n\n\nQuarto Version更新用スクリプト\n\n\nquarto\n\n\n3 min\n\n\n\n\n\n\n2025-07-20\n\n\n実行時間計測デコレーター\n\n\n環境構築, python\n\n\n4 min\n\n\n\n\n\n\n2025-07-19\n\n\nNautilusからSSH先のファイルを操作する\n\n\n環境構築, Linux\n\n\n1 min\n\n\n\n\n\n\n2025-07-18\n\n\nbq commandを用いたPatitioned BigQuery External Tableの作成\n\n\n環境構築, gcloud, BigQuery\n\n\n2 min\n\n\n\n\n\n\n2025-07-17\n\n\nモデル管理プラットフォームMLflowの設定\n\n\n環境構築\n\n\n5 min\n\n\n\n\n\n\n2025-07-11\n\n\nGitHub OSS Contribution: ForkからPull Request\n\n\n方法論\n\n\n5 min\n\n\n\n\n\n\n2025-07-09\n\n\n集合列の和集合・直和・共通部分\n\n\n集合論\n\n\n2 min\n\n\n\n\n\n\n2025-07-08\n\n\nLaw of Large Numbers\n\n\n統計\n\n\n3 min\n\n\n\n\n\n\n2025-07-07\n\n\n平方完成と確率密度関数\n\n\n統計\n\n\n1 min\n\n\n\n\n\n\n2025-07-06\n\n\n統計学におけるBig OpとLittle Op\n\n\n統計\n\n\n10 min\n\n\n\n\n\n\n2025-07-05\n\n\n集合 \\((0,1)^N\\) の濃度\n\n\n集合論\n\n\n4 min\n\n\n\n\n\n\n2025-07-03\n\n\n理想気体の全微分\n\n\n解析, 熱力学\n\n\n2 min\n\n\n\n\n\n\n2025-07-02\n\n\n収束の条件とCauchyの判定法\n\n\n解析, 収束\n\n\n3 min\n\n\n\n\n\n\n2025-07-01\n\n\nある慣性系で２つの平行な軌道\n\n\n線形代数, physics\n\n\n1 min\n\n\n\n\n\n\n2025-06-28\n\n\nDatamart作成Tips\n\n\nSQL\n\n\n1 min\n\n\n\n\n\n\n2025-06-27\n\n\nWindowsライクなスナップ機能をUbuntuで使う\n\n\nLinux\n\n\n1 min\n\n\n\n\n\n\n2025-06-24\n\n\nCSVファイルの特定のカラムをawkで計算変換する\n\n\n前処理, shell, awk\n\n\n9 min\n\n\n\n\n\n\n2025-06-18\n\n\nカントールの対関数の全単射性の証明\n\n\n集合論\n\n\n5 min\n\n\n\n\n\n\n2025-06-17\n\n\n可算集合と濃度\n\n\n集合論\n\n\n2 min\n\n\n\n\n\n\n2025-06-16\n\n\n冷凍機油\n\n\n空調機\n\n\n7 min\n\n\n\n\n\n\n2025-06-15\n\n\n断熱圧縮とポリトロープ変化\n\n\n熱力学\n\n\n7 min\n\n\n\n\n\n\n2025-06-14\n\n\nPH線図: pressure-enthalpy chart\n\n\n熱力学\n\n\n9 min\n\n\n\n\n\n\n2025-06-13\n\n\nエントロピーとエンタルピー\n\n\n熱力学\n\n\n11 min\n\n\n\n\n\n\n2025-06-12\n\n\n物質量と気体の体積\n\n\n熱力学\n\n\n3 min\n\n\n\n\n\n\n2025-06-11\n\n\n冷凍サイクルとヒートポンプの基礎\n\n\n熱力学, 空調機\n\n\n9 min\n\n\n\n\n\n\n2025-06-03\n\n\n目標設定例および設定ガイドライン\n\n\n方法論\n\n\n2 min\n\n\n\n\n\n\n2025-06-02\n\n\nボイル=シャルルの法則の導出\n\n\n熱力学\n\n\n2 min\n\n\n\n\n\n\n2025-05-30\n\n\nドキュメントの書き方\n\n\n方法論\n\n\n2 min\n\n\n\n\n\n\n2025-05-23\n\n\nwikiにどのような情報をどのように残すか？\n\n\n方法論, 環境構築\n\n\n5 min\n\n\n\n\n\n\n2025-05-19\n\n\nRoo Code環境構築\n\n\n環境構築\n\n\n7 min\n\n\n\n\n\n\n2025-05-01\n\n\nCSSの組み込み方\n\n\nhtml, quarto\n\n\n1 min\n\n\n\n\n\n\n2025-04-30\n\n\nCSSで使う単位\n\n\nhtml, quarto\n\n\n4 min\n\n\n\n\n\n\n2025-04-29\n\n\nシェルコマンドTips\n\n\nshell\n\n\n3 min\n\n\n\n\n\n\n2025-04-24\n\n\nレシプロエンジンの仕組み\n\n\n製造業\n\n\n1 min\n\n\n\n\n\n\n2025-04-10\n\n\nD3を用いた散布図生成\n\n\nD3, EDA\n\n\n1 min\n\n\n\n\n\n\n2025-04-09\n\n\nベクトル空間における外積\n\n\n線形代数\n\n\n18 min\n\n\n\n\n\n\n2025-04-08\n\n\n確率行列と固有値\n\n\n線形代数, 統計\n\n\n2 min\n\n\n\n\n\n\n2025-04-07\n\n\nベクトル空間における内積\n\n\n線形代数, 複素数\n\n\n10 min\n\n\n\n\n\n\n2025-04-01\n\n\n地図と標準誤差\n\n\n統計, 地図\n\n\n1 min\n\n\n\n\n\n\n2025-03-05\n\n\n三角関数の加法定理\n\n\n三角関数\n\n\n7 min\n\n\n\n\n\n\n2025-03-03\n\n\nいろいろな三角不等式\n\n\n複素数, 幾何, 線形代数\n\n\n5 min\n\n\n\n\n\n\n2025-03-02\n\n\n敵の砲台の座標を探せ 1/N\n\n\n幾何\n\n\n9 min\n\n\n\n\n\n\n2025-03-01\n\n\nヘロンの公式の導出\n\n\n幾何\n\n\n2 min\n\n\n\n\n\n\n2025-02-28\n\n\nカバリエリの原理\n\n\n幾何\n\n\n14 min\n\n\n\n\n\n\n2025-02-27\n\n\ntangent 75°の図形的計算\n\n\n三角関数\n\n\n2 min\n\n\n\n\n\n\n2025-02-26\n\n\n余弦定理の考え方\n\n\n三角関数\n\n\n5 min\n\n\n\n\n\n\n2025-02-25\n\n\n正弦定理の考え方\n\n\n三角関数\n\n\n7 min\n\n\n\n\n\n\n2025-02-20\n\n\npivot tableのcolumn, rowのsort\n\n\npython, 前処理\n\n\n3 min\n\n\n\n\n\n\n2025-02-19\n\n\nGroup毎に定義されたラグ変数の作成\n\n\npython, 前処理\n\n\n9 min\n\n\n\n\n\n\n2025-02-14\n\n\n本日の詰将棋: Quiz 1~5\n\n\n将棋\n\n\n1 min\n\n\n\n\n\n\n2025-02-13\n\n\n複素平面と複素数による回転\n\n\n複素数\n\n\n12 min\n\n\n\n\n\n\n2025-02-07\n\n\nwget vs curl\n\n\nshell\n\n\n8 min\n\n\n\n\n\n\n2025-02-05\n\n\n測量法における測量の分類\n\n\n測量\n\n\n1 min\n\n\n\n\n\n\n2025-02-04\n\n\n単曲線と追加距離の計算\n\n\n三角関数, 測量\n\n\n4 min\n\n\n\n\n\n\n2025-02-03\n\n\n関数の連続性\n\n\n解析\n\n\n7 min\n\n\n\n\n\n\n2025-02-02\n\n\n有限個の多項式のテイラー展開\n\n\n解析\n\n\n4 min\n\n\n\n\n\n\n2025-02-01\n\n\n18世紀までの関数論とテイラー展開\n\n\n解析\n\n\n5 min\n\n\n\n\n\n\n2025-01-30\n\n\n微分方程式を用いたToy models\n\n\n微分方程式\n\n\n5 min\n\n\n\n\n\n\n2025-01-29\n\n\nフーリエ級数と積分理論再考\n\n\nフーリエ変換\n\n\n4 min\n\n\n\n\n\n\n2025-01-28\n\n\n数理モデルの作り方\n\n\n方法論\n\n\n1 min\n\n\n\n\n\n\n2025-01-27\n\n\n指数関数の微分\n\n\n解析\n\n\n2 min\n\n\n\n\n\n\n2025-01-10\n\n\nLinuxシステム上のユーザー一覧を条件に応じて表示する\n\n\nshell, Linux\n\n\n3 min\n\n\n\n\n\n\n2025-01-08\n\n\nBigQuery: TIME型カラムを指定したレベルで丸めて集計する\n\n\nSQL\n\n\n2 min\n\n\n\n\n\n\n2024-12-19\n\n\n自分用ショートカットシート\n\n\n環境構築, shortcuts\n\n\n37 min\n\n\n\n\n\n\n2024-12-18\n\n\nSecure Shellの仕組み\n\n\nssh\n\n\n5 min\n\n\n\n\n\n\n2024-12-17\n\n\nFirefoxを用いたsocks5 proxyブラウザアクセス設定\n\n\nfirefox, network\n\n\n2 min\n\n\n\n\n\n\n2024-12-16\n\n\nmacOSへのssh接続\n\n\nssh, 環境構築\n\n\n1 min\n\n\n\n\n\n\n2024-12-11\n\n\nCloud StorageからExternal Tableの作成\n\n\nBigQuery\n\n\n2 min\n\n\n\n\n\n\n2024-12-07\n\n\nIPアドレス 0.0.0.0\n\n\nnetwork, quarto\n\n\n3 min\n\n\n\n\n\n\n2021-01-16\n\n\n追加されたPersonal Package Archive(PPA)の管理\n\n\n環境構築, Linux\n\n\n7 min\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/2025-06-17-countable-set-and-cardinality/index.html",
    "href": "posts/2025-06-17-countable-set-and-cardinality/index.html",
    "title": "可算集合と濃度",
    "section": "",
    "text": "自然数の集合 \\(\\mathbb N\\) と1対1に対応している集合は，\\(\\mathbb N\\) と「同じ個数の元」を持つと考えても良いと思われますが，無限集合の場合は 「元をすべて数え上げるということはできない」．ここで登場するのが「濃度」という概念です．\n\n\n\nDefinition 1 1対1対応\n集合 \\(M\\) から集合 \\(N\\) への写像 \\(\\varphi\\) で，次の(1), (2) の性質を満たすものが存在するとき，\\(M, N\\) は1対1対応しているという\n\n\\(a, a^\\prime \\in M\\) で \\(a\\neq a^\\prime\\) ならば \\(\\varphi(a)\\neq \\varphi(a^\\prime)\\)\n任意の \\(\\tilde b \\in N\\) に対して，ある \\(\\tilde a\\in M\\) が存在して，\\(\\varphi(\\tilde a) = \\tilde b\\)\n\n\n\nDefinition 2 濃度\n\\(M, N\\) は1対1対応しているとき，\\(M\\) と \\(N\\) は同じ濃度をもつという．\n\nカントールの対関数の全単射性の証明より，自然数の対 \\((m, n)\\) 全体の作る集合は \\(\\mathbb N\\) と1対1対応している = 同じ濃度であることがわかります．\nこれを一般的な定理に拡張すると，\n\n\\(M, N\\) を可算集合とすると，直積集合 \\(M\\times N\\) も可算集合である\n\nということになります．ただし，可算集合 \\(A_i\\) について \\(\\displaystyle\\Pi_{i=1}^\\infty A_i\\) は可算集合とはなりません，\n\nDefinition 3 可算\n自然数の集合 \\(\\mathbb N\\) と同じ濃度を持つ集合を，可算集合と呼ぶ．この可算集合の濃度を \\(\\mathfrak{N}_0\\) と表す．\n\n\nExample 1 偶数と奇数の集合\n偶数の自然数の全体の集合を \\(\\pmb{E}_0\\) としたとき，写像 \\(f: \\mathbb N \\to \\pmb{E}_0\\) を\n\\[\nf(n) = 2n\n\\]\nとすると，\\(f\\) は全単射になります．このとき，\\(\\pmb{E}_0 \\subset \\mathbb N\\) であるが，\n\\[\n|\\pmb{E}_0| = |\\mathbb N|\n\\]\nという有限集合ではありえない性質が成立します．\nまた，奇数の自然数の全体の集合を \\(\\pmb{E}_1\\) としたとき，写像 \\(g: \\mathbb N \\to \\pmb{E}_1\\) を\n\\[\ng(n) = 2(n - 1) + 1\n\\]\nとすると，\\(g\\) も全単射となります．\n\n\n\nExample 2 整数の集合と可算集合\n整数の集合 \\(\\mathbb Z\\) について，写像 \\(\\varphi: \\mathbb N \\to \\mathbb Z\\) を\n\\[\n\\begin{align}\n\\varphi(n) =\n  \\left\\{\\begin{array}{c}\n  \\frac{n}{2} & ( n \\in \\mathbb E_0 )\\\\\n  -\\frac{n-1}{2} & ( n \\in \\mathbb E_1)\n  \\end{array}\\right.\n\\end{align}\n\\]\nとすると，\\(\\varphi\\) は全単射になります．\n\n\n\n\n\n\nTheorem 1 \n\\(M\\) を可算集合とする，\\(S\\subset M\\) が無限集合であるとすると，\\(S\\) は可算集合である\n\n\n\n\n\n\n\nNoteProof\n\n\n\n\n\n\\(M\\) は可算集合であるので，\\(M\\) は\n\\[\nM = \\{a_1, a_2, a_3, \\cdots, a_n, \\cdots\\}\n\\]\nと表すことができます．\\(S\\) の元で，この並び方の最初に現れるものを \\(a_{i_1}\\) とすると，\n\\[\nS =  \\{a_{i_1}, a_{i_2}, a_{i_3}, \\cdots, a_{i_n}, \\cdots\\}\n\\]\nとなり，また，\\(S\\) は無限集合なのでこの系列が途中で止まることはありません．写像 \\(f: \\mathbb N\\to S\\) を\n\\[\nf(n) = a_{i_n}\n\\]\nとすると，\\(f\\) は1対1写像となるので，\\(S\\) は可算集合であることがわかります．\n\n\n\n\nExample 3 素数集合と可算集合\n素数が無限にあることは，背理法を用いると示しやすいです，素数が有限個しかないとして，その総数を \\(n\\) とすると素数全体の集合 \\(\\mathbb P\\) は\n\\[\n\\mathbb P = \\{2, 3, 5, \\cdots, p_n\\}\n\\]\nこのとき自然数 \\(q\\) を\n\\[\nq = 2 \\cdot 3 \\cdot \\cdots p_n + 1\n\\]\nは \\(q\\) はどんな素数でも割り切れないものになってしまうので，素数となりますが，これは素数の総数 \\(n\\) という仮定と矛盾．つまり，素数は無限に存在します．\n素数集合は\n\\[\n\\mathbb P \\subset \\mathbb N\n\\]\nであるので，素数集合は可算集合となります．"
  },
  {
    "objectID": "posts/2025-06-17-countable-set-and-cardinality/index.html#可算集合と濃度",
    "href": "posts/2025-06-17-countable-set-and-cardinality/index.html#可算集合と濃度",
    "title": "可算集合と濃度",
    "section": "",
    "text": "自然数の集合 \\(\\mathbb N\\) と1対1に対応している集合は，\\(\\mathbb N\\) と「同じ個数の元」を持つと考えても良いと思われますが，無限集合の場合は 「元をすべて数え上げるということはできない」．ここで登場するのが「濃度」という概念です．\n\n\n\nDefinition 1 1対1対応\n集合 \\(M\\) から集合 \\(N\\) への写像 \\(\\varphi\\) で，次の(1), (2) の性質を満たすものが存在するとき，\\(M, N\\) は1対1対応しているという\n\n\\(a, a^\\prime \\in M\\) で \\(a\\neq a^\\prime\\) ならば \\(\\varphi(a)\\neq \\varphi(a^\\prime)\\)\n任意の \\(\\tilde b \\in N\\) に対して，ある \\(\\tilde a\\in M\\) が存在して，\\(\\varphi(\\tilde a) = \\tilde b\\)\n\n\n\nDefinition 2 濃度\n\\(M, N\\) は1対1対応しているとき，\\(M\\) と \\(N\\) は同じ濃度をもつという．\n\nカントールの対関数の全単射性の証明より，自然数の対 \\((m, n)\\) 全体の作る集合は \\(\\mathbb N\\) と1対1対応している = 同じ濃度であることがわかります．\nこれを一般的な定理に拡張すると，\n\n\\(M, N\\) を可算集合とすると，直積集合 \\(M\\times N\\) も可算集合である\n\nということになります．ただし，可算集合 \\(A_i\\) について \\(\\displaystyle\\Pi_{i=1}^\\infty A_i\\) は可算集合とはなりません，\n\nDefinition 3 可算\n自然数の集合 \\(\\mathbb N\\) と同じ濃度を持つ集合を，可算集合と呼ぶ．この可算集合の濃度を \\(\\mathfrak{N}_0\\) と表す．\n\n\nExample 1 偶数と奇数の集合\n偶数の自然数の全体の集合を \\(\\pmb{E}_0\\) としたとき，写像 \\(f: \\mathbb N \\to \\pmb{E}_0\\) を\n\\[\nf(n) = 2n\n\\]\nとすると，\\(f\\) は全単射になります．このとき，\\(\\pmb{E}_0 \\subset \\mathbb N\\) であるが，\n\\[\n|\\pmb{E}_0| = |\\mathbb N|\n\\]\nという有限集合ではありえない性質が成立します．\nまた，奇数の自然数の全体の集合を \\(\\pmb{E}_1\\) としたとき，写像 \\(g: \\mathbb N \\to \\pmb{E}_1\\) を\n\\[\ng(n) = 2(n - 1) + 1\n\\]\nとすると，\\(g\\) も全単射となります．\n\n\n\nExample 2 整数の集合と可算集合\n整数の集合 \\(\\mathbb Z\\) について，写像 \\(\\varphi: \\mathbb N \\to \\mathbb Z\\) を\n\\[\n\\begin{align}\n\\varphi(n) =\n  \\left\\{\\begin{array}{c}\n  \\frac{n}{2} & ( n \\in \\mathbb E_0 )\\\\\n  -\\frac{n-1}{2} & ( n \\in \\mathbb E_1)\n  \\end{array}\\right.\n\\end{align}\n\\]\nとすると，\\(\\varphi\\) は全単射になります．\n\n\n\n\n\n\nTheorem 1 \n\\(M\\) を可算集合とする，\\(S\\subset M\\) が無限集合であるとすると，\\(S\\) は可算集合である\n\n\n\n\n\n\n\nNoteProof\n\n\n\n\n\n\\(M\\) は可算集合であるので，\\(M\\) は\n\\[\nM = \\{a_1, a_2, a_3, \\cdots, a_n, \\cdots\\}\n\\]\nと表すことができます．\\(S\\) の元で，この並び方の最初に現れるものを \\(a_{i_1}\\) とすると，\n\\[\nS =  \\{a_{i_1}, a_{i_2}, a_{i_3}, \\cdots, a_{i_n}, \\cdots\\}\n\\]\nとなり，また，\\(S\\) は無限集合なのでこの系列が途中で止まることはありません．写像 \\(f: \\mathbb N\\to S\\) を\n\\[\nf(n) = a_{i_n}\n\\]\nとすると，\\(f\\) は1対1写像となるので，\\(S\\) は可算集合であることがわかります．\n\n\n\n\nExample 3 素数集合と可算集合\n素数が無限にあることは，背理法を用いると示しやすいです，素数が有限個しかないとして，その総数を \\(n\\) とすると素数全体の集合 \\(\\mathbb P\\) は\n\\[\n\\mathbb P = \\{2, 3, 5, \\cdots, p_n\\}\n\\]\nこのとき自然数 \\(q\\) を\n\\[\nq = 2 \\cdot 3 \\cdot \\cdots p_n + 1\n\\]\nは \\(q\\) はどんな素数でも割り切れないものになってしまうので，素数となりますが，これは素数の総数 \\(n\\) という仮定と矛盾．つまり，素数は無限に存在します．\n素数集合は\n\\[\n\\mathbb P \\subset \\mathbb N\n\\]\nであるので，素数集合は可算集合となります．"
  },
  {
    "objectID": "posts/2025-06-17-countable-set-and-cardinality/index.html#references",
    "href": "posts/2025-06-17-countable-set-and-cardinality/index.html#references",
    "title": "可算集合と濃度",
    "section": "References",
    "text": "References\n\nカントールの対関数の全単射性の証明"
  },
  {
    "objectID": "posts/2024-12-11-BQ-create-external-table/index.html",
    "href": "posts/2024-12-11-BQ-create-external-table/index.html",
    "title": "Cloud StorageからExternal Tableの作成",
    "section": "",
    "text": "Google Cloud StorageからBigQuery上にExternal tabaleを作成する\nPartition Fieldが定義されたExternal tabaleを作成するための条件を確認する"
  },
  {
    "objectID": "posts/2024-12-11-BQ-create-external-table/index.html#このノートのスコープ",
    "href": "posts/2024-12-11-BQ-create-external-table/index.html#このノートのスコープ",
    "title": "Cloud StorageからExternal Tableの作成",
    "section": "",
    "text": "Google Cloud StorageからBigQuery上にExternal tabaleを作成する\nPartition Fieldが定義されたExternal tabaleを作成するための条件を確認する"
  },
  {
    "objectID": "posts/2024-12-11-BQ-create-external-table/index.html#external-tableとは",
    "href": "posts/2024-12-11-BQ-create-external-table/index.html#external-tableとは",
    "title": "Cloud StorageからExternal Tableの作成",
    "section": "External Tableとは？",
    "text": "External Tableとは？\n\nDefinition 1 External Table\n\nBigQueryのExternal Table（外部テーブル）は，BigQuery内にデータをコピーまたはインポートすることなく， 外部データソースに直接アクセスしてクエリを実行できる機能\nBigQueryにおけるExternal Tableの利用形式として，permanent tableとtemporary tableの２つがあります\n\n\npermanent tableとtemporary table\n\npermanent table: BigQuery dataset内に作成され，外部データソースにリンクされるテーブル\ntemporary table: 外部データソースに対して一時的にクエリを実行する場合に利用されるテーブル\n\n\n\n\n\n\n\nNote\n\n\n\n一時的なテスト処理などでtemporary tableを用いることは有用ですが，分析者間でクエリやコードを共有して分析を進める場合はpermanent tableを用いないと テーブルアクセスを共有できません．\n\n\nサポートされているデータストア&lt;\nBigQueryからアクセス可能な外部データソースとしてサポートされているデータストアは以下:\n\nBigLake\nCloud Storage\nBigtable\nGoogle Drive\nAmazon S3\nAzure Blob Storage\n\nPricing\nBigQueryのPricingは\n\nCompute pricing: クエリの処理にかかる費用\nStorage pricing: データ保存費用\n\nの２つから構成されています．External Tableを用いると，後者の方はCloud Storage換算の費用となるため，一般的には ストレージコストを抑えることができます．ただし，External Tableにアクセスして分析するたびに\n\nQuery cost: クエリ計算処理時間に比例するコスト\nBytes cost: External tableからのデータ読み取りサイズに比例するコスト\n\nが発生します．\n\n\n\n\n\n\nNotePricing費用低減のTips\n\n\n\nExternal Tableを用いた分析が一時的なものであるならばExternal Tableを用いたほうが良いと思いますが， 頻繁にBigQueryからアクセスする場合は\n\nPartitioning/Clusteringを用いてアクセスサイズを抑える\nSELECT以下で*を使用せず，分析に用いるカラムを明示的に指定して，スキャンサイズを抑える\n\nという工夫，またはBigQuery native tableとしてデータを保持することを検討したほうが良いと思います．\n\n\n\nExternal Table use cases\n\nExternal Tableの特徴\n\nBigQuery native tableとしてデータは保持しない\nExternal Tableと紐づく外部ストアの最新データに対して，クエリ処理が走る\n\nがあります．そのため，PoCや営業段階での分析や頻繁にupdateされるデータに対してのオンライン分析といった場面で活用されるケースが多いです．\n\n\nExample 1 営業段階でのアドホック分析\n\nBtoC向けサービスを展開している企業Aに対して営業をしているとする\nNDAを結んだ後に，企業Aが保有しているデータのサンプルとして２年間分の連携してもらった\nこのデータを用いて簡易的な分析を行い，どのようなインサイトが導けそうか？を次の営業会議で企業Aに伝え説得したい\n\nという場面を考えます．このとき，\n\nわざわざテーブルスキーマを定義する時間はあまりない→早くEDAをやりたい\nサンプルデータなので，プロジェクト受注後に連携されるであろうデータセットよりも情報量が少ない→わざわざテーブルスキーマしても再利用可能性は低い\n\nExternal Tableを利用することで以下のようなメリットを享受することができます:\n\nテーブルスキーマをわざわざ定義しなくても，BigQueryを用いた大容量のデータに対しての分析が可能\n複数の分析者間でサンプルデータをCloud Storageベースで簡単に共有できる\nPythonなどの言語を用いた分析でも，予めBigQueryで前処理して小さいdatamartを作成し，それに対してEDAが実施できる"
  },
  {
    "objectID": "posts/2024-12-11-BQ-create-external-table/index.html#external-table作成",
    "href": "posts/2024-12-11-BQ-create-external-table/index.html#external-table作成",
    "title": "Cloud StorageからExternal Tableの作成",
    "section": "External Table作成",
    "text": "External Table作成\nここでは，EXTERNAL PARTITION TABLEの作成を目的に\n\ngoogle cloud storageへのupload\nEXTERNAL TABLEの作成\n\nの２段階の流れで説明します．\n\nCloud Storageへのupload\n~/pupupuland_store_posというdirectory以下に，yyyymmdd形式の日付でpartitionされたPARQUET形式のデータがあるとします．\npupupuland_store_pos\n├── partition_dt=2023-09-23\n│   └── purchase_history_2023-09-23.parquet\n├── partition_dt=2023-09-24\n│   └── purchase_history_2023-09-24.parquet\n├── partition_dt=2023-09-25\n│   └── purchase_history_2023-09-25.parquet\n├── partition_dt=2023-09-26\n│   └── purchase_history_2023-09-26.parquet\n├── partition_dt=2023-09-27\n│   └── purchase_history_2023-09-27.parquet\n├── partition_dt=2023-09-28\n│   └── purchase_history_2023-09-28.parquet\n├── partition_dt=2023-09-29\n│   └── purchase_history_2023-09-29.parquet\n└── partition_dt=2023-09-30\n    └── purchase_history_2023-09-30.parquet\nこのディレクトリ構造を保持したまま，gs://project-make-dedede-great-again/というcloud storage bucketに格納したいとします．このとき\ngcloud storage cp -r ~/pupupuland_store_pos/ gs://project-make-dedede-great-again/\n以上で下準備は完了です．\nExternal Tableの作成\nGoogle Cloud project pupupuland-businessdata の dedede-holdings dataset以下に先程上げた pupupuland_store_pos tableを作成したいと思います．\nCREATE EXTERNAL TABLE `pupupuland-businessdata.dedede-holdings.pupupuland_store_pos`\nOPTIONS (\n  format = 'PARQUET',\n  uris = ['gs://project-make-dedede-great-again/pupupuland_store_pos/*'],\n  hive_partition_uri_prefix = 'gs://project-make-dedede-great-again/pupupuland_store_pos/', -- 末尾にスラッシュを追加\n  require_hive_partition_filter = false\n);\nrequire_hive_partition_filter フィールド\n\nrequire_hive_partition_filter フィールドはクエリ時にpartition_dtによるWHERE句フィルタリングを強制するか否かの設定フィールドです．\nデフォルトではfalseとなっており，この場合はフィルタリングしなくてもクエリできることを意味します．"
  },
  {
    "objectID": "posts/2024-12-11-BQ-create-external-table/index.html#appendix-hive形式",
    "href": "posts/2024-12-11-BQ-create-external-table/index.html#appendix-hive形式",
    "title": "Cloud StorageからExternal Tableの作成",
    "section": "Appendix: Hive形式",
    "text": "Appendix: Hive形式\n\nDefinition 2 Hive形式\n\n&lt;ベースパス&gt;/&lt;列名&gt;=&lt;値&gt;/&lt;ファイル名&gt;という構造を用いたファイルパスベースのパーティション構造\n\n\ngs://bucket/retail_data/partition_month=2022-07-01/part-0001.parquet\ngs://bucket/retail_data/partition_month=2022-08-01/part-0001.parquet\nという形式でparquetが格納されているときに, hive_partitioning_mode=AUTO を指定して外部テーブルを作成すると\n\npartition_month 列が自動で追加される\nWHERE partition_month = '2022-07-01' のようなクエリが使える\nクエリ効率もよくなる（パーティションプルーニング）\n\nというメリットがあります．"
  },
  {
    "objectID": "posts/2024-12-11-BQ-create-external-table/index.html#references",
    "href": "posts/2024-12-11-BQ-create-external-table/index.html#references",
    "title": "Cloud StorageからExternal Tableの作成",
    "section": "References",
    "text": "References\n\nIntroduction to external tables"
  },
  {
    "objectID": "posts/2025-06-16-refrigerating-machine-oil/index.html",
    "href": "posts/2025-06-16-refrigerating-machine-oil/index.html",
    "title": "冷凍機油",
    "section": "",
    "text": "Definition 1 冷凍機油\n\n冷凍空調機用の圧縮機に使用される潤滑油を冷凍機油と呼ぶ\n冷媒と直接接触する(冷媒と一緒に冷凍サイクルを流れる可能性がある)\nJIS Ｋ2211(摩擦試験方法」または「摩擦試験に関する規格」)等で規格化もされている\n\n\n冷凍機油の使用目的\n\n圧縮機の回転部分やシリンダとピストンの隙間などの摺動部分の摩擦/摩耗の防止\n圧縮機内の摩擦熱や作動熱を吸収・除去という冷却作用\n金属部品の腐食を防ぐ防錆目的\n圧縮機内部で冷媒ガスが漏れるのを防ぐために，ピストンや軸の隙間を密封するシーリング目的\n\n\n\n冷凍機油は冷凍サイクル内を冷媒と一緒に流れるので\n\n超低温からかなりの高温まで耐えること\n冷媒との相溶性に優れていること(溶け過ぎも溶けなさすぎもダメ)\n\nが必要です．相溶性が悪いと，分離した油が滞留し冷媒の流れを妨げるだけでなく，冷却装置の構成効果を低下させたり，キャピラリで閉塞を起こすこともあります． 使用目的と合わせて冷凍機油に求められる性質をまとめると以下のようになります\n\n\n\n\n\n\n\n\n性質\n説明\n\n\n\n\n適切な粘度\n潤滑性能の観点から，粘度は適切で，運転温度範囲内で安定していることが必要\n\n\n油膜形成性\n金属表面の接触を油膜が遮断することで，部品の摩耗や損傷を防ぐことができる\n\n\n低い凝固点\n凝固点が低いこと．冷凍機は低温環境で動くため，油が固まってしまうと潤滑性能が失われる\n\n\n化学的安定性\n高温や圧力の条件下でも分解や劣化が起こりにくいこと\n\n\n水分を含まないこと\n金属部品を腐食させない．水分を含んでしまうと，低温で氷ができ，配管やバルブの閉塞の原因になる\n\n\n酸分を含まないこと\n金属部品を酸化を通して腐食させない．\n\n\n硫黄分を含まないこと\n硫黄が酸化・分解すると腐食性の硫黄酸化物が発生し，金属の腐食を促進してしまう\n\n\n酸化しにくいこと\n酸化が進むと油の分子構造が変化し，粘度が変動したり，潤滑効果が低下．酸化分解物が集まるとスラッジができてしまう\n\n\n絶縁性\n冷凍機のコンプレッサーには電動モーターが使われているため，冷凍機油が絶縁性を持っていないとショートサーキットが発生してしまう\n\n\n絶縁材・シール材との適合性\n絶縁材・シール材とと化学的に反応せず，膨潤や硬化，脆化を起こさないこと\n\n\nワックス非析出\nワックスが生成されると配管や油路，フィルター詰まりを起こすリスクが上がる\n\n\n\n\n\n\n\n\n\n\nNote冷凍機油と冷媒液が二層分離した場合\n\n\n\n二層分離とは，冷凍機油と冷媒が混ざらずに，上層・下層の二層に分かれる状態のことです．冷凍機油と冷媒の「溶解度」が低いと，二層分離が起こる可能性が高くなります，二層分離による悪影響として\n\n\n\n\n\n\n\n項目\n内容\n\n\n\n\n① 潤滑不良\n油が冷媒と一緒に圧縮機を回らなくなり，潤滑部に油が届かない．→ 摩耗・焼き付きの原因\n\n\n② 冷媒循環不良\n油が冷媒ラインに滞留・詰まり，熱交換器での冷媒の流れが阻害される\n\n\n③ 起動不良・故障\n起動時に油が偏在すると，液圧縮や過負荷の原因になる\n\n\n④ 圧縮機温度上昇\n油膜が切れ，摩擦が増えることで発熱 → 過熱・絶縁劣化・寿命短縮\n\n\n⑤ 圧力損失\n油が冷媒と共に移動しないため，配管内の圧力損失が大きくなる\n\n\n\nそのため，\n\n冷媒と相溶性のある油を選定\n油戻し設計\n油分離器の設置\n定期点検・交換\n\nが重要になってきます．\n\n\n冷凍機器の構成と潤滑油に要求される性能\n\n\n\n\n\n\n\n\n主な構成部品\n油に要求される性能\n主な評価試験\n\n\n\n\n蒸発器（エバポレータ）\n① 低温流動性② 冷媒相溶性③ ワックス等の非析出性\n① 流動点② 冷媒溶解度，粘度，シールドチューブ冷媒共存流動点③ フロック点\n\n\n膨張弁（キャピラリ）\n① 耐スラッジ性② 剪断安定性③ 低温流動性④ ワックス非析出\n① 熱安定性②（剪断安定性）③，④ 同上\n\n\n凝縮器（コンデンサー）\n① 冷媒との高温相溶性\n冷媒との相溶性\n\n\n圧縮機（コンプレッサ）\n① 潤滑性，極圧性② 熱安定性，化学的安定性③ 冷媒相溶性④ モーター等材料適合性⑤ 密閉型圧縮機では電気絶縁性\n① ファレックス試験，高速四球，高圧摩擦試験② シールドチューブ加水分解安定性③ 冷媒相溶性④ シールドチューブ，オートクレーブ⑤ 絶縁破壊電圧・体積抵抗率"
  },
  {
    "objectID": "posts/2025-06-16-refrigerating-machine-oil/index.html#冷凍機油の使用目的",
    "href": "posts/2025-06-16-refrigerating-machine-oil/index.html#冷凍機油の使用目的",
    "title": "冷凍機油",
    "section": "",
    "text": "Definition 1 冷凍機油\n\n冷凍空調機用の圧縮機に使用される潤滑油を冷凍機油と呼ぶ\n冷媒と直接接触する(冷媒と一緒に冷凍サイクルを流れる可能性がある)\nJIS Ｋ2211(摩擦試験方法」または「摩擦試験に関する規格」)等で規格化もされている\n\n\n冷凍機油の使用目的\n\n圧縮機の回転部分やシリンダとピストンの隙間などの摺動部分の摩擦/摩耗の防止\n圧縮機内の摩擦熱や作動熱を吸収・除去という冷却作用\n金属部品の腐食を防ぐ防錆目的\n圧縮機内部で冷媒ガスが漏れるのを防ぐために，ピストンや軸の隙間を密封するシーリング目的\n\n\n\n冷凍機油は冷凍サイクル内を冷媒と一緒に流れるので\n\n超低温からかなりの高温まで耐えること\n冷媒との相溶性に優れていること(溶け過ぎも溶けなさすぎもダメ)\n\nが必要です．相溶性が悪いと，分離した油が滞留し冷媒の流れを妨げるだけでなく，冷却装置の構成効果を低下させたり，キャピラリで閉塞を起こすこともあります． 使用目的と合わせて冷凍機油に求められる性質をまとめると以下のようになります\n\n\n\n\n\n\n\n\n性質\n説明\n\n\n\n\n適切な粘度\n潤滑性能の観点から，粘度は適切で，運転温度範囲内で安定していることが必要\n\n\n油膜形成性\n金属表面の接触を油膜が遮断することで，部品の摩耗や損傷を防ぐことができる\n\n\n低い凝固点\n凝固点が低いこと．冷凍機は低温環境で動くため，油が固まってしまうと潤滑性能が失われる\n\n\n化学的安定性\n高温や圧力の条件下でも分解や劣化が起こりにくいこと\n\n\n水分を含まないこと\n金属部品を腐食させない．水分を含んでしまうと，低温で氷ができ，配管やバルブの閉塞の原因になる\n\n\n酸分を含まないこと\n金属部品を酸化を通して腐食させない．\n\n\n硫黄分を含まないこと\n硫黄が酸化・分解すると腐食性の硫黄酸化物が発生し，金属の腐食を促進してしまう\n\n\n酸化しにくいこと\n酸化が進むと油の分子構造が変化し，粘度が変動したり，潤滑効果が低下．酸化分解物が集まるとスラッジができてしまう\n\n\n絶縁性\n冷凍機のコンプレッサーには電動モーターが使われているため，冷凍機油が絶縁性を持っていないとショートサーキットが発生してしまう\n\n\n絶縁材・シール材との適合性\n絶縁材・シール材とと化学的に反応せず，膨潤や硬化，脆化を起こさないこと\n\n\nワックス非析出\nワックスが生成されると配管や油路，フィルター詰まりを起こすリスクが上がる\n\n\n\n\n\n\n\n\n\n\nNote冷凍機油と冷媒液が二層分離した場合\n\n\n\n二層分離とは，冷凍機油と冷媒が混ざらずに，上層・下層の二層に分かれる状態のことです．冷凍機油と冷媒の「溶解度」が低いと，二層分離が起こる可能性が高くなります，二層分離による悪影響として\n\n\n\n\n\n\n\n項目\n内容\n\n\n\n\n① 潤滑不良\n油が冷媒と一緒に圧縮機を回らなくなり，潤滑部に油が届かない．→ 摩耗・焼き付きの原因\n\n\n② 冷媒循環不良\n油が冷媒ラインに滞留・詰まり，熱交換器での冷媒の流れが阻害される\n\n\n③ 起動不良・故障\n起動時に油が偏在すると，液圧縮や過負荷の原因になる\n\n\n④ 圧縮機温度上昇\n油膜が切れ，摩擦が増えることで発熱 → 過熱・絶縁劣化・寿命短縮\n\n\n⑤ 圧力損失\n油が冷媒と共に移動しないため，配管内の圧力損失が大きくなる\n\n\n\nそのため，\n\n冷媒と相溶性のある油を選定\n油戻し設計\n油分離器の設置\n定期点検・交換\n\nが重要になってきます．\n\n\n冷凍機器の構成と潤滑油に要求される性能\n\n\n\n\n\n\n\n\n主な構成部品\n油に要求される性能\n主な評価試験\n\n\n\n\n蒸発器（エバポレータ）\n① 低温流動性② 冷媒相溶性③ ワックス等の非析出性\n① 流動点② 冷媒溶解度，粘度，シールドチューブ冷媒共存流動点③ フロック点\n\n\n膨張弁（キャピラリ）\n① 耐スラッジ性② 剪断安定性③ 低温流動性④ ワックス非析出\n① 熱安定性②（剪断安定性）③，④ 同上\n\n\n凝縮器（コンデンサー）\n① 冷媒との高温相溶性\n冷媒との相溶性\n\n\n圧縮機（コンプレッサ）\n① 潤滑性，極圧性② 熱安定性，化学的安定性③ 冷媒相溶性④ モーター等材料適合性⑤ 密閉型圧縮機では電気絶縁性\n① ファレックス試験，高速四球，高圧摩擦試験② シールドチューブ加水分解安定性③ 冷媒相溶性④ シールドチューブ，オートクレーブ⑤ 絶縁破壊電圧・体積抵抗率"
  },
  {
    "objectID": "posts/2025-06-16-refrigerating-machine-oil/index.html#冷凍機油の種類",
    "href": "posts/2025-06-16-refrigerating-machine-oil/index.html#冷凍機油の種類",
    "title": "冷凍機油",
    "section": "冷凍機油の種類",
    "text": "冷凍機油の種類\n冷凍機油は\n\n鉱物油\n合成油\n\nに大別されます．鉱油は石油由来の非極性炭化水素系を基油としており，ナフテン系鉱油やパラフィン系鉱油があります．非極性の炭化水素分子は，同じ非極性分子同士とはよく混ざり合うので，ＨＦＣ冷媒はＣＦＣ冷媒やＨＣＦＣ冷媒とは相溶性が良いです．一方，ＨＦＣ冷媒対応冷凍機油の場合，ＨＦＣ冷媒はＣＦＣ冷媒やＨＣＦＣ冷媒とは異なり構造的に電気的に極性を有するため，従来の鉱油とは相溶しません．そのため，冷凍機油の分子にエステル結合（-ＣＯＯ-） 等の極性を有する結合を導入し合成したＨＦＣ冷媒と相溶する冷凍機油が開発されています．\n具体的には，エステル結合を有するエステル油，カーボネート油，エーテル結合（-Ｏ-）を有するポリアルキレングリコール油（略称ＰＡＧ），ポリビニールエーテル油（略称ＰＶＥ）等が該当し，ＨＦＣ134ａ 対応のカーエアコンにはＰＡＧ，冷蔵庫にはポリオールエステル油（ヒンダードアルコール利用のエステル油，略称ＰＯＥ） が既に導入されており，Ｒ407ＣやＲ410Ａ対応空調機にはＰＯＥ，ＰＶＥが適応される傾向が有ります．\n\n\n\n\n\n\n\n\n\n\n用途\n主な圧縮機の形式\n主たる冷媒\n主たる潤滑油\n\n\n\n\n家庭用冷蔵庫\nレシプロ等\nR134a\nポリオールエステル（POE）\n\n\nカーエアコン\n斜板式，ロータリー，スクロール等\nR134a\nポリアルキレングリコール（PAG）\n\n\nエアコン\nロータリー，スクロール等\nR410A，R407C\nポリオールエステル（POE），ポリビニルエーテル（PVE）\n\n\nショーケース\nロータリー，スクロール，ターボ等\nR404A，R507\nポリオールエステル（POE）\n\n\n産業用冷凍機\nレシプロ，スクリュー，スクロール，ターボ等\nアンモニア\nポリアルキレングリコール（PAG）\n\n\n産業用冷凍機\nレシプロ，スクリュー，スクロール，ターボ等\nR404A，R507\nポリオールエステル（POE）\n\n\n\n\n\n\n\n\n\n\nNoteアンモニア冷媒圧縮機と冷凍機油\n\n\n\n\nアンモニアを冷媒とする往復圧縮機では，吐出しガス温度が高く，冷凍機油が劣化しやすい\n圧縮機から吐き出された冷凍機油が非相溶性の場合には，圧縮機に戻さず，冷凍装置の外部に放出する場合もある\nアンモニアと相溶性のある合成油を用いた場合は，フルオロカーボン冷媒と同様に油分離期から直接油を圧縮機に戻したり，装置内を循環させて圧縮機に戻したりする"
  },
  {
    "objectID": "posts/2025-06-16-refrigerating-machine-oil/index.html#冷凍機油と冷媒の相互溶解性",
    "href": "posts/2025-06-16-refrigerating-machine-oil/index.html#冷凍機油と冷媒の相互溶解性",
    "title": "冷凍機油",
    "section": "冷凍機油と冷媒の相互溶解性",
    "text": "冷凍機油と冷媒の相互溶解性\n相溶性は温度と圧力で定まり，二層分離するものから完全相溶するものに大別されます．\n\n温度条件: -40~90℃, 冷凍機油分率: 20~30 mass%\n\n\n\n冷凍機油\nR32\nR125\nR134a\nR143a\nR152a\n\n\n\n\nナフテン系\n分離\n分離\n分離\n分離\n分離\n\n\nPAG油\n-40℃以下で分離\n溶解\n溶解\n分離\n溶解\n\n\nエステル油\n溶解\n溶解\n溶解\n分離\n溶解\n\n\nエステル油\n分離\n溶解\n溶解\n-10℃以下で分離\n分離\n\n\n\n\n分離: 冷凍機油リッチな液相と冷媒液リッチな液相との２つの液相に分離すること\n\n\n\n\n\n\n\n\nNote\n\n\n\n溶解，部分溶解，分離は温度帯によって変化しますがR410とPOE油との溶解性をみると以下のように変化します\n\n\n\n\n\n温度帯\n40 mass%のR410Aの溶解性\n\n\n\n\n-59~-32℃\n分離\n\n\n-32~-23℃\n部分溶解\n\n\n-23~50℃\n溶解\n\n\n\n\n\n\n\n温度帯\n60 mass%のR410A\n\n\n\n\n-59~-15℃\n分離\n\n\n-15~-1℃\n部分溶解\n\n\n-1~30℃\n分離\n\n\n30~-37℃\n部分溶解\n\n\n37~-41℃\n分離\n\n\n\n\n\n\n\n温度帯\n95 mass%のR410A\n\n\n\n\n-59~-30℃\n分離\n\n\n-30~-10℃\n部分溶解\n\n\n-10~48℃\n溶解\n\n\n\n\n\n\n\n下の図では冷凍機油に対するR22の溶解度を示しています．横軸は溶解度ですが，質量分率で表されています．つまり 質量分率 = 冷媒質量 / 冷凍機油質量 です．平衡線図より\n\n圧力が同じであれば，温度が高いとR22の溶解度が小さい\n温度が同じであれば，圧力が低いときにR22の溶解度が小さくなる\n\n始動時のオイルフォーミングは，急に圧力が下がると平衡溶解度が小さくなるので，余分な冷媒が気化して追い出される現象です．\n\n\n\n冷凍機油とR22の平衡線図\n\n\n\n冷媒が冷凍機油に多量に溶け込むときの問題\n① 潤滑性能の低下（粘度低下）\n\n冷媒が油に多く溶け込むと，油の粘度が著しく低下します\n粘度が低いと，潤滑油膜が形成されにくくなり，摩擦・摩耗が増加\n\n② 発泡現象（フォーミング）\n\n圧縮機起動時や急激な圧力変化時に，冷媒が油から急に気化し，泡が発生\nこの泡によって油の供給が不安定になり，潤滑不足やキャビテーションを引き起こす可能性がある"
  },
  {
    "objectID": "posts/2025-06-16-refrigerating-machine-oil/index.html#油分離器-oil-separator",
    "href": "posts/2025-06-16-refrigerating-machine-oil/index.html#油分離器-oil-separator",
    "title": "冷凍機油",
    "section": "油分離器: Oil Separator",
    "text": "油分離器: Oil Separator\n\nDefinition 2 油分離器\n\n油分離器は，冷凍装置の圧縮機と凝縮器との間に設置し，圧縮機吐出しガスに含まれている冷凍機油を分離する機器\nフルオロカーボン冷凍装置や総妖精の冷凍機油を用いたアンモニア冷凍装置では，分離した冷凍機油を圧縮機のクランクケースへ戻す\n非相溶性の冷凍機油を用いたアンモニア冷凍装置では，分離した冷凍機油を油溜め器に送り出す場合もある\n小型のフルオロカーボン冷凍装置では配管距離が短いので油分離機を設けないことが多い\n\n\nなぜ凝縮器にそのまま冷凍機油を送り出してはいけないのか？\n\n吐出しガス中に含まれる冷凍機油をそのまま凝縮器に送り込むと，圧縮機の湯量は減少し，潤滑不良の原因となる\n凝縮器の伝熱作用を阻害する可能性もある\n凝縮器・膨張弁を経由して蒸発器に流入すると，冷凍機油が蒸発器に蓄積され，蒸発器での伝熱作用を阻害するリスクがある\n相溶性の冷凍機油を冷凍装置では，以下の観点から冷媒に混入した冷凍機油を蒸発器から圧縮機へ戻すことが難しい\n\n低圧配管ではガス密度が小さく，配管断面積が大きいため流速が遅い → 油を押し流す力が弱い\n一般に油は温度が低下するにつれ粘度は増大し，増大する分だけ油を押し流す力が必要になる\n\n\n\n\n\n\n\n\nNote複数圧縮機や蒸発器の台数が多い場合\n\n\n\n圧縮機や蒸発器の台数が多い場合，油を均等にクランケースに戻すのが難しくなります．そのため，油分離機を圧縮機後，凝縮器前に設置することが求められます．\n\n\n\n油分離器の原理\n\n\n圧縮機から吐出された油交じりの冷媒ガスを油分離器の側面にあてることで，油は壁面に付着し下部へ滴下する．（遠心分離）\nガスは上部から排出され，不要な油を系外へ排出しないようにしている．\n滴下した油は下部の油戻し穴を通って，圧縮機の吸入配管へ戻る．\n\n\n\n\n\n遠心分離系油分離器"
  },
  {
    "objectID": "posts/2025-06-16-refrigerating-machine-oil/index.html#油戻し運転",
    "href": "posts/2025-06-16-refrigerating-machine-oil/index.html#油戻し運転",
    "title": "冷凍機油",
    "section": "油戻し運転",
    "text": "油戻し運転\n\nDefinition 3 油戻し運転\n油戻し運転とは，冷媒回路内に拡散・滞留してしまった冷凍機油を圧縮機へ戻すための特別な運転のこと\n\n\n油戻し運転の方式\n方式①\n\n縦配管でも油が戻っていくまでの冷媒流速まで上げて冷媒ガスで冷凍機油を戻す\n流速を上げるので，インバータ周波数を高回転にする必要があり，その為に，室内機側の冷媒通過音が大きくなる。また能力が過剰になるため冷え過ぎる\n\n方式②\n\n液冷媒と一緒に油を戻す\n湿り運転させる必要があるので，液冷媒が圧縮機内に戻り，圧縮機故障につながる可能性がある"
  },
  {
    "objectID": "posts/2025-06-16-refrigerating-machine-oil/index.html#理解度チェック",
    "href": "posts/2025-06-16-refrigerating-machine-oil/index.html#理解度チェック",
    "title": "冷凍機油",
    "section": "📘 理解度チェック",
    "text": "📘 理解度チェック\n\nExercise 1 冷凍機油の使用目的\n次の記述の内，正しいものを選べ\n\n冷凍・空調用の圧縮機に使用されている潤滑油を冷凍機油と呼ぶ．HFC系冷媒用冷凍機油の合成油は水分を吸収しやすいものが多いので保守管理には注意を要する\n冷凍機油の役割は，圧縮機の軸受，ロータやピストンなどの潤滑面に油膜をつくり，金属どうしの直接接触を避け，円滑なしゅう動と摩耗防止とともに，摩擦によって生じる熱を除去することなどである\n\n\n\n\n\n\n\n\nNoteSolution\n\n\n\n\n\na, b\n\n\n\n\nExercise 2 冷凍機油の種類\n次の記述の内，正しいものを選べ\n\n冷凍機油は，鉱油と合成油の2種類がある\n鉱油は，炭化水素を基油にしている．ナフテン系鉱油，パラフィン系鉱油がある\n合成油の主なものは，ポリアルキレングリコール（PAG）油，ポリビニルエーテル（PVE）油，ポリオールエステル（POE）油などがある\n鉱油や合成油と混合して冷凍機油として用いているアルキルベンゼンがある\nHFC系冷媒は，アルキルベンゼン系鉱油などの炭化水素系冷凍機油には溶解しないが，合成油であるポリオールエステル（POE）油などには相溶性がある\n\n\n\n\n\n\n\n\nNoteSolution\n\n\n\n\n\na, b, c, d, e\n\n\n\n\nExercise 3 冷媒と冷凍機油の組合せ\n次の記述の内，正しいものを選べ\n\nフルオロカーボン中に水分が入ると，冷媒が加水分解されて腐食性物質を発生し，金属が腐食を起こす原因になる\nフルオロカーボン冷媒が油に溶け込む割合は，冷媒の圧力が高いほど，または温度が低いほど大きい\nフルオロカーボン冷媒は油とよく溶け合うので，吐出し管に脂分力を設けても，油を分離することはできない\nR22は油をよく溶解するので，蒸発器内に油が大量に滞留しても伝熱上支障がない\nフルオロカーボン容圧縮機のクランクケース内の油温が低い場合，始動時にオイルフォーミングを起こし，油上がりが多くなる\n\n\n\n\n\n\n\n\nNoteSolution\n\n\n\n\n\na, b, e"
  },
  {
    "objectID": "posts/2025-03-02-find-coordinates/index.html",
    "href": "posts/2025-03-02-find-coordinates/index.html",
    "title": "敵の砲台の座標を探せ 1/N",
    "section": "",
    "text": "\\((a, b)\\) を中心点とする半径 \\(r\\) の円をplotすることを考えます．\n半径 \\(r\\) の円の中心点の座標が原点 \\((0, 0)\\) にある場合，円周上の点 \\(P = (x, y)\\) は，\\(P\\) から \\(x\\) 軸に下ろした垂線と \\(x\\) 軸が交わる点を \\(Q\\) としたとき \\(\\triangle OPQ\\) は斜辺 \\(r\\)，高さ \\(y\\), 底辺の長さ \\(x\\) となる直角三角形を構成するので，三平方の定理より\n\\[\nr^2 = x^2 + y^2\n\\]\nこれが円上の座標が満たす方程式となります．原点を中心点とする場合を考えましたが，中心が \\((a, b)\\)，半径 \\(r\\) の円の式は同様の方法で\n\\[\nr^2 = (x - a)^2 + (y - b)^2 \\label{#eq-circle}\n\\]\nと表すことが出来ます．\n\n\nCode\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport matplotlib.tri as mtri\n\n# set params\nR = 1\nO = (2, 1)\n\n# variables\ntheta = np.linspace(0, 2 * np.pi, 1000)\nx = np.cos(theta) * R + O[0]\ny = np.sin(theta) * R + O[1]\n\nA = (x[100], y[100])\ntriangles = [[0, 1, 2]]\nx_trinagle = [O[0], A[0], A[0]]\ny_trinagle = [O[1], O[1], A[1]]\ntriang = mtri.Triangulation(x_trinagle, y_trinagle, triangles)\n\n# plot\nfig, ax = plt.subplots(figsize=(8, 6))\nax.grid()\nax.set_aspect(\"equal\")\nax.set_xlim(0.5, 3.5)\nax.set_ylim(-0.5, 2.5)\n\n\nax.plot(x, y)\nax.scatter(*O, s=8, color=\"k\")\nax.scatter(*A, s=8, color=\"k\")\nax.text(*O, s=\"O\",  ha='center', va='bottom')\nax.text(*A, s=\"A = ($x_1, y_1$)\", ha='left', va='bottom')\nax.text(2.4, 1.35, s=\"r\")\nax.text(2.4, 0.9, s=\"$x_1 - 2$\", ha='center', va='bottom')\nax.text(A[0]+0.05, 1.35, s=\"$y_1 - 1$\", ha='left', va='bottom')\n\n# add lines\nax.triplot(triang, 'ko-')\n\n\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\n# set params\nR = 2.5\nO = (3, 1/2)\n\n# variables\ntheta = np.linspace(0, 2 * np.pi, 1000)\nx = np.cos(theta) * R + O[0]\ny = np.sin(theta) * R + O[1]\n\nP = (1, -1)\nQ = (3, 3)\nR = (1, 2)\n\n# plot\nfig, ax = plt.subplots(figsize=(8, 6))\nax.grid()\nax.set_aspect(\"equal\")\n\nax.plot(x, y)\nax.scatter(*O, s=8, color=\"k\")\nax.scatter(*P, s=8, color=\"k\")\nax.scatter(*Q, s=8, color=\"k\")\nax.scatter(*R, s=8, color=\"k\")\nax.text(*O, s=\"O\",  ha='center', va='bottom')\nax.text(*P, s=\"P\",  ha='center', va='bottom')\nax.text(*Q, s=\"Q\", ha='left', va='bottom')\nax.text(*R, s=\"R\", ha='left', va='bottom')\n\n\nplt.show()\n\n\n\n\n\n\n\n\n\n３点 \\(P = (1, -1), Q = (3, 3), R = (1, 2)\\) が与えられたとして，この３点を通る円を求める問題を考えます．\n\\(\\eqref{#eq-circle}\\) を展開すると\n\\[\nx^2 + y^2 - 2ax - 2by + a^2 + b^2 = r^2\n\\]\nこれを整理して\n\\[\nx^2 + y^2 + Ax + By + C = 0 \\label{#eq-basemodel}\n\\]\nと変形します．ここで，\\(P = (1, -1), Q = (3, 3), R = (1, 2)\\) の情報を用いると\n\\[\n\\begin{gather}\n2 + A - B + C = 0\\\\\n18 + 3A + 3B + C = 0\\\\\n5 + A +2B + C = 0\n\\end{gather}\n\\]\nという \\(A,B,C\\) についての連立方程式を得ることが出来ます．これを解くと\n\\[\nA = -6, B = -1, C = 3\n\\]\n従って，\n\\[\n(x - 3)^2 + (y - 0.5)^2 = 2.5^2 \\label{#eq-ans1}\n\\]\n\n\n点 \\(P, Q, R\\) からなる三角形の外接円として求めたい円を捉えることも出来ます． 外接円の円心は三角形の各線分の垂直二等分線の交点として求めることが出来ます．\n\n\nCode\ndef func_pq(x):\n    a = - (P[0] - Q[0]) / (P[1] - Q[1])\n    b = - a * (P[0] + Q[0]) / 2 + (P[1] + Q[1]) / 2\n\n    return a*x + b\n\ndef func_pr(x):\n    a = - (P[0] - R[0]) / (P[1] - R[1])\n    b = - a * (P[0] + R[0]) / 2 + (P[1] + R[1]) / 2\n\n    return a*x + b\n\nx_lin = np.array([0, 6])\ntriangles = [[0, 1, 2]]\nx_trinagle = [P[0], Q[0], R[0]]\ny_trinagle = [P[1], Q[1], R[1]]\ntriang = mtri.Triangulation(x_trinagle, y_trinagle, triangles)\n\n\n\n# plot\nfig, ax = plt.subplots(figsize=(8, 6))\nax.grid()\nax.set_aspect(\"equal\")\nax.set_xlim(0, 6)\nax.set_ylim(-2.5, 3.5)\nax.plot(x_lin, func_pq(x_lin), label='PQ Perpendicular bisector', linestyle='--', color='gray')\nax.plot(x_lin, func_pr(x_lin), label='PR Perpendicular bisector', linestyle=':', color='gray')\n\n\nax.plot(x, y)\nax.scatter(*O, s=8, color=\"k\")\nax.scatter(*P, s=8, color=\"k\")\nax.scatter(*Q, s=8, color=\"k\")\nax.scatter(*R, s=8, color=\"k\")\nax.text(*O, s=\"O\",  ha='center', va='bottom')\nax.text(*P, s=\"P\",  ha='center', va='bottom')\nax.text(*Q, s=\"Q\", ha='left', va='bottom')\nax.text(*R, s=\"R\", ha='left', va='bottom')\n\n# add lines\nax.triplot(triang, 'ko-')\n\nplt.legend(loc='center left', bbox_to_anchor=(1, 0.95))\nplt.show()\n\n\n\n\n\n\n\n\n\n\\(PQ\\) の垂直二等分線 \\(f(x)\\) は\n\\[\n\\begin{align}\nf(x)\n    &= -\\frac{P_x - Q_x}{P_y - Q_y}x + \\frac{P_y + Q_y}{2} + \\frac{P_x - Q_x}{P_y - Q_y} \\frac{P_x + Q_y}{2}\\\\\n    &= -\\frac{P_x - Q_x}{P_y - Q_y}x + \\frac{P_x^2 - Q_x^2 + P_y^2 - Q_y^2}{2(P_y - Q_y)}\n\\end{align}\n\\]\n同様に \\(PR\\) の垂直二等分線 \\(g(x)\\) は\n\\[\n\\begin{align}\ng(x)\n    &= -\\frac{P_x - R_x}{P_y - R_y}x + \\frac{P_y + R_y}{2} + \\frac{P_x - R_x}{P_y - R_y} \\frac{P_x + R_y}{2}\\\\\n    &= -\\frac{P_x - R_x}{P_y - R_y}x + \\frac{P_x^2 - R_x^2 + P_y^2 - R_y^2}{2(P_y - R_y)}\n\\end{align}\n\\]\nここから \\(f(x), g(x)\\) が交差する点を求めることで外接円の円心を求めることが出来ます．\n少しめんどくさいので，数値計算で説いてみると\n\n\nCode\na = - (P[0] - Q[0]) / (P[1] - Q[1])\nb = - a * (P[0] + Q[0]) / 2 + (P[1] + Q[1]) / 2\nc = - (P[0] - R[0]) / (P[1] - R[1])\nd = - c * (P[0] + R[0]) / 2 + (P[1] + R[1]) / 2\n\nprint((d-b)/(a-c), a * (d-b)/(a-c) + b)\n\n\n3.0 0.5\n\n\n\\(\\eqref{#eq-ans1}\\) と一致する計算結果となることが確かめられました．\n\n📘 REMARKS \n上記の垂直二等分線の交点を \\((x_0, y_0)\\) としたとき，整理すると以下のようになります．\n\\[\nA = \\left(\\begin{array}{cc}\nR_y - Q_y & -(P_y - Q_y)\\\\\n-(R_x - Q_x) & P_x - Q_x\\\\\n\\end{array}\\right)\n\\]\nとしたとき，\n\\[\n\\left(\\begin{array}{c}\nx_0\\\\\ny_0\n\\end{array}\\right)\n    = \\frac{1}{\\operatorname{det}A} A\\left(\\begin{array}{c}\n(P_x^2 - Q_x^2 + P_y^2 - Q_y^2)/2\\\\\n(R_x^2 - Q_x^2 + R_y^2 - Q_y^2)/2\n\\end{array}\\right)\n\\]\n実際に計算してみると\n\n\nCode\nA_array = np.array([[R[1] - Q[1], -(P[1] - Q[1])], [-(R[0] - Q[0]), P[0] - Q[0]]])\nB_array = np.array(\n    [\n        [(P[0]**2 - Q[0]**2 + P[1]**2 - Q[1]**2) / 2],\n        [(R[0]**2 - Q[0]**2 + R[1]**2 - Q[1]**2) / 2],\n    ]\n)\n\nresult = np.ravel((A_array @ B_array) / np.linalg.det(A_array))\nradius = np.sqrt(np.sum((np.array(P) - result) **2))\nprint(f\"中心点 = ({result}), 半径 = {radius}\")\n\n\n中心点 = ([3.  0.5]), 半径 = 2.5"
  },
  {
    "objectID": "posts/2025-03-02-find-coordinates/index.html#円の式",
    "href": "posts/2025-03-02-find-coordinates/index.html#円の式",
    "title": "敵の砲台の座標を探せ 1/N",
    "section": "",
    "text": "\\((a, b)\\) を中心点とする半径 \\(r\\) の円をplotすることを考えます．\n半径 \\(r\\) の円の中心点の座標が原点 \\((0, 0)\\) にある場合，円周上の点 \\(P = (x, y)\\) は，\\(P\\) から \\(x\\) 軸に下ろした垂線と \\(x\\) 軸が交わる点を \\(Q\\) としたとき \\(\\triangle OPQ\\) は斜辺 \\(r\\)，高さ \\(y\\), 底辺の長さ \\(x\\) となる直角三角形を構成するので，三平方の定理より\n\\[\nr^2 = x^2 + y^2\n\\]\nこれが円上の座標が満たす方程式となります．原点を中心点とする場合を考えましたが，中心が \\((a, b)\\)，半径 \\(r\\) の円の式は同様の方法で\n\\[\nr^2 = (x - a)^2 + (y - b)^2 \\label{#eq-circle}\n\\]\nと表すことが出来ます．\n\n\nCode\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport matplotlib.tri as mtri\n\n# set params\nR = 1\nO = (2, 1)\n\n# variables\ntheta = np.linspace(0, 2 * np.pi, 1000)\nx = np.cos(theta) * R + O[0]\ny = np.sin(theta) * R + O[1]\n\nA = (x[100], y[100])\ntriangles = [[0, 1, 2]]\nx_trinagle = [O[0], A[0], A[0]]\ny_trinagle = [O[1], O[1], A[1]]\ntriang = mtri.Triangulation(x_trinagle, y_trinagle, triangles)\n\n# plot\nfig, ax = plt.subplots(figsize=(8, 6))\nax.grid()\nax.set_aspect(\"equal\")\nax.set_xlim(0.5, 3.5)\nax.set_ylim(-0.5, 2.5)\n\n\nax.plot(x, y)\nax.scatter(*O, s=8, color=\"k\")\nax.scatter(*A, s=8, color=\"k\")\nax.text(*O, s=\"O\",  ha='center', va='bottom')\nax.text(*A, s=\"A = ($x_1, y_1$)\", ha='left', va='bottom')\nax.text(2.4, 1.35, s=\"r\")\nax.text(2.4, 0.9, s=\"$x_1 - 2$\", ha='center', va='bottom')\nax.text(A[0]+0.05, 1.35, s=\"$y_1 - 1$\", ha='left', va='bottom')\n\n# add lines\nax.triplot(triang, 'ko-')\n\n\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\n# set params\nR = 2.5\nO = (3, 1/2)\n\n# variables\ntheta = np.linspace(0, 2 * np.pi, 1000)\nx = np.cos(theta) * R + O[0]\ny = np.sin(theta) * R + O[1]\n\nP = (1, -1)\nQ = (3, 3)\nR = (1, 2)\n\n# plot\nfig, ax = plt.subplots(figsize=(8, 6))\nax.grid()\nax.set_aspect(\"equal\")\n\nax.plot(x, y)\nax.scatter(*O, s=8, color=\"k\")\nax.scatter(*P, s=8, color=\"k\")\nax.scatter(*Q, s=8, color=\"k\")\nax.scatter(*R, s=8, color=\"k\")\nax.text(*O, s=\"O\",  ha='center', va='bottom')\nax.text(*P, s=\"P\",  ha='center', va='bottom')\nax.text(*Q, s=\"Q\", ha='left', va='bottom')\nax.text(*R, s=\"R\", ha='left', va='bottom')\n\n\nplt.show()\n\n\n\n\n\n\n\n\n\n３点 \\(P = (1, -1), Q = (3, 3), R = (1, 2)\\) が与えられたとして，この３点を通る円を求める問題を考えます．\n\\(\\eqref{#eq-circle}\\) を展開すると\n\\[\nx^2 + y^2 - 2ax - 2by + a^2 + b^2 = r^2\n\\]\nこれを整理して\n\\[\nx^2 + y^2 + Ax + By + C = 0 \\label{#eq-basemodel}\n\\]\nと変形します．ここで，\\(P = (1, -1), Q = (3, 3), R = (1, 2)\\) の情報を用いると\n\\[\n\\begin{gather}\n2 + A - B + C = 0\\\\\n18 + 3A + 3B + C = 0\\\\\n5 + A +2B + C = 0\n\\end{gather}\n\\]\nという \\(A,B,C\\) についての連立方程式を得ることが出来ます．これを解くと\n\\[\nA = -6, B = -1, C = 3\n\\]\n従って，\n\\[\n(x - 3)^2 + (y - 0.5)^2 = 2.5^2 \\label{#eq-ans1}\n\\]\n\n\n点 \\(P, Q, R\\) からなる三角形の外接円として求めたい円を捉えることも出来ます． 外接円の円心は三角形の各線分の垂直二等分線の交点として求めることが出来ます．\n\n\nCode\ndef func_pq(x):\n    a = - (P[0] - Q[0]) / (P[1] - Q[1])\n    b = - a * (P[0] + Q[0]) / 2 + (P[1] + Q[1]) / 2\n\n    return a*x + b\n\ndef func_pr(x):\n    a = - (P[0] - R[0]) / (P[1] - R[1])\n    b = - a * (P[0] + R[0]) / 2 + (P[1] + R[1]) / 2\n\n    return a*x + b\n\nx_lin = np.array([0, 6])\ntriangles = [[0, 1, 2]]\nx_trinagle = [P[0], Q[0], R[0]]\ny_trinagle = [P[1], Q[1], R[1]]\ntriang = mtri.Triangulation(x_trinagle, y_trinagle, triangles)\n\n\n\n# plot\nfig, ax = plt.subplots(figsize=(8, 6))\nax.grid()\nax.set_aspect(\"equal\")\nax.set_xlim(0, 6)\nax.set_ylim(-2.5, 3.5)\nax.plot(x_lin, func_pq(x_lin), label='PQ Perpendicular bisector', linestyle='--', color='gray')\nax.plot(x_lin, func_pr(x_lin), label='PR Perpendicular bisector', linestyle=':', color='gray')\n\n\nax.plot(x, y)\nax.scatter(*O, s=8, color=\"k\")\nax.scatter(*P, s=8, color=\"k\")\nax.scatter(*Q, s=8, color=\"k\")\nax.scatter(*R, s=8, color=\"k\")\nax.text(*O, s=\"O\",  ha='center', va='bottom')\nax.text(*P, s=\"P\",  ha='center', va='bottom')\nax.text(*Q, s=\"Q\", ha='left', va='bottom')\nax.text(*R, s=\"R\", ha='left', va='bottom')\n\n# add lines\nax.triplot(triang, 'ko-')\n\nplt.legend(loc='center left', bbox_to_anchor=(1, 0.95))\nplt.show()\n\n\n\n\n\n\n\n\n\n\\(PQ\\) の垂直二等分線 \\(f(x)\\) は\n\\[\n\\begin{align}\nf(x)\n    &= -\\frac{P_x - Q_x}{P_y - Q_y}x + \\frac{P_y + Q_y}{2} + \\frac{P_x - Q_x}{P_y - Q_y} \\frac{P_x + Q_y}{2}\\\\\n    &= -\\frac{P_x - Q_x}{P_y - Q_y}x + \\frac{P_x^2 - Q_x^2 + P_y^2 - Q_y^2}{2(P_y - Q_y)}\n\\end{align}\n\\]\n同様に \\(PR\\) の垂直二等分線 \\(g(x)\\) は\n\\[\n\\begin{align}\ng(x)\n    &= -\\frac{P_x - R_x}{P_y - R_y}x + \\frac{P_y + R_y}{2} + \\frac{P_x - R_x}{P_y - R_y} \\frac{P_x + R_y}{2}\\\\\n    &= -\\frac{P_x - R_x}{P_y - R_y}x + \\frac{P_x^2 - R_x^2 + P_y^2 - R_y^2}{2(P_y - R_y)}\n\\end{align}\n\\]\nここから \\(f(x), g(x)\\) が交差する点を求めることで外接円の円心を求めることが出来ます．\n少しめんどくさいので，数値計算で説いてみると\n\n\nCode\na = - (P[0] - Q[0]) / (P[1] - Q[1])\nb = - a * (P[0] + Q[0]) / 2 + (P[1] + Q[1]) / 2\nc = - (P[0] - R[0]) / (P[1] - R[1])\nd = - c * (P[0] + R[0]) / 2 + (P[1] + R[1]) / 2\n\nprint((d-b)/(a-c), a * (d-b)/(a-c) + b)\n\n\n3.0 0.5\n\n\n\\(\\eqref{#eq-ans1}\\) と一致する計算結果となることが確かめられました．\n\n📘 REMARKS \n上記の垂直二等分線の交点を \\((x_0, y_0)\\) としたとき，整理すると以下のようになります．\n\\[\nA = \\left(\\begin{array}{cc}\nR_y - Q_y & -(P_y - Q_y)\\\\\n-(R_x - Q_x) & P_x - Q_x\\\\\n\\end{array}\\right)\n\\]\nとしたとき，\n\\[\n\\left(\\begin{array}{c}\nx_0\\\\\ny_0\n\\end{array}\\right)\n    = \\frac{1}{\\operatorname{det}A} A\\left(\\begin{array}{c}\n(P_x^2 - Q_x^2 + P_y^2 - Q_y^2)/2\\\\\n(R_x^2 - Q_x^2 + R_y^2 - Q_y^2)/2\n\\end{array}\\right)\n\\]\n実際に計算してみると\n\n\nCode\nA_array = np.array([[R[1] - Q[1], -(P[1] - Q[1])], [-(R[0] - Q[0]), P[0] - Q[0]]])\nB_array = np.array(\n    [\n        [(P[0]**2 - Q[0]**2 + P[1]**2 - Q[1]**2) / 2],\n        [(R[0]**2 - Q[0]**2 + R[1]**2 - Q[1]**2) / 2],\n    ]\n)\n\nresult = np.ravel((A_array @ B_array) / np.linalg.det(A_array))\nradius = np.sqrt(np.sum((np.array(P) - result) **2))\nprint(f\"中心点 = ({result}), 半径 = {radius}\")\n\n\n中心点 = ([3.  0.5]), 半径 = 2.5"
  },
  {
    "objectID": "posts/2025-03-02-find-coordinates/index.html#敵の砲台の座標を探せ",
    "href": "posts/2025-03-02-find-coordinates/index.html#敵の砲台の座標を探せ",
    "title": "敵の砲台の座標を探せ 1/N",
    "section": "敵の砲台の座標を探せ",
    "text": "敵の砲台の座標を探せ\n\n\nExercise 1 \nとある固定の１地点から自軍領地に対して敵が砲撃をかけてきているとします. 敵の砲台は角度のみを調整できるだけで，砲撃予定距離 \\(r\\) は一定とします．ただし，実際の砲撃距離は風向などの外乱要因によってノイズが混じっているとします．\nとある日に敵から50回の攻撃を受けたとき，その砲台座標を推定してください．砲撃のノイズは\\(\\operatorname{i.i.d}\\)とする．\n\n\n\\(\\eqref{#eq-basemodel}\\) より\n\\[\n\\begin{align}\nz_i = - x_i^2 - y_i^2\n\\end{align}\n\\]\nと定義すると，\\(e_i\\) をresidualとして\n\\[\nz_i = \\beta_0 + \\beta_1 x_i + \\beta_2 y_i + e_i\n\\]\nについて \\((\\beta_0, \\beta_1, \\beta_2)\\) をLinear modelで推定し，その推定値を \\((\\hat\\beta_0, \\hat\\beta_1, \\hat\\beta_2)\\) と表せば 敵の砲台の推定座標 \\((\\hat x, \\hat y)\\) 及び推定距離 \\(\\hat r\\) は\n\\[\n\\begin{align}\n\\hat x &= -\\hat\\beta_1/2\\\\\n\\hat y &= -\\hat\\beta_2/2\\\\\n\\hat r &= \\sqrt{\\hat x^2 + \\hat y^2 - \\hat\\beta_0}\n\\end{align}\n\\]\nと計算できそうに思えます．\n ▶  Data Generating Process\n\n敵の砲台の座標は \\((0, 0)\\)\n敵は \\((0, 0)\\) の地点から砲撃距離 \\(20\\) で攻撃してくる\n実際の砲撃距離 \\(r \\sim N(20, 1)\\)\n砲撃角度は \\(\\left[\\displaystyle{\\frac{\\pi}{3}, \\frac{\\pi}{2}}\\right]\\) の範囲で一様分布で定まる\n\nというData Generating Processとします．\n\n\nCode\ndef gdp(x_0: float, y_0: float, noise: float = 1.0, radius: float = 20,  attack_num: int = 50):\n    # params\n    theta = np.random.uniform(np.pi/3 , np.pi/2 , attack_num)\n    r = radius + np.random.normal(0, noise, attack_num)\n\n    x = np.cos(theta) * r + x_0\n    y = np.sin(theta) * r + y_0\n\n    return x, y\n\n\nこのGDPに従う形で攻撃されたとするとき，その散布図は以下のようになります．\n\n\nCode\nnp.random.seed(42)\n\nx_attack, y_attack = gdp(0, 0)\n\nfig, ax = plt.subplots()\nax.scatter(x_attack, y_attack)\nax.set_xlim(-1, np.max([np.max(x_attack), np.max(y_attack)]) + 1)\nax.set_ylim(-1, np.max([np.max(x_attack), np.max(y_attack)]) + 1)\nax.grid()\nax.set_aspect('equal')\nplt.show()\n\n\n\n\n\n\n\n\n\n ▶  OLS Monte Carlo Simulation\nOLSによるパラメータ推定値を \\(1,000\\) 回simulationし，その組み合わせをkde plotしたものが以下となります．x座標についてバイアスがあることがわかります． 砲撃距離に関しても不自然な推定値となっています．\n\n\nCode\nimport pandas as pd\nimport statsmodels.api as sm\nimport seaborn as sns\n\ndef gpd_dataframe(x: float = 0, y: float = 0, noise: float = 1.0):\n    x_attack, y_attack = gdp(x, y, noise)\n    df = pd.DataFrame(\n        {\n            \"x_coordinate\": x_attack,\n            \"y_coordinate\": y_attack,\n        }\n    )\n\n    return df\n\n\ndef ols_solver(\n    df: pd.DataFrame, xy_columns: tuple[str] = (\"x_coordinate\", \"y_coordinate\")\n):\n    Y = -(df[xy_columns[0]] ** 2) - df[xy_columns[1]]\n    X = sm.add_constant(df.loc[:, xy_columns])\n\n    # regression\n    model = sm.OLS(Y, X)\n    results = model.fit()\n\n    # convert estimates to target params\n    x_hat = -results.params[xy_columns[0]] / 2\n    y_hat = -results.params[xy_columns[1]] / 2\n    r_hat_sqr = (x_hat**2 + y_hat**2 - results.params['const'])\n    r_hat = np.sqrt(r_hat_sqr) if r_hat_sqr &gt; 0 else np.nan\n\n    return [x_hat, y_hat, r_hat]\n\n\ndef estimator_simulator(func, noise: float = 1.0, iter: int = 1000):\n    res = list(map(lambda x: func(gpd_dataframe(0, 0, noise)), range(iter)))\n    return np.array(res)\n\nfig, ax = plt.subplots(1, 2)\n\nols_res = estimator_simulator(ols_solver)\nsns.kdeplot(x=ols_res[:, 0], y=ols_res[:, 1], cmap=\"Blues\", fill=True, ax=ax[0])\nsns.kdeplot(x=ols_res[:, 2], cmap=\"Blues\", fill=True, ax=ax[1])\n\n# Show the plot\nax[0].set_xlabel(\"estimated x coordinate\")\nax[0].set_ylabel(\"estimated y coordinate\")\nax[0].set_aspect('equal')\nax[0].set_title(\"OLS 2D Density Plot\\nwith 1000 iterations\")\nax[1].set_title(\"Raidus Density Plot\\nwith 1000 iterations\")\nplt.show()\n\n\n\n\n\n\n\n\n\nそもそも \\(r_i = 20 + \\epsilon_i\\) と決定されていますが\n\\[\n\\beta_0 = a^2 + b^2 - (r + \\epsilon_i)^2\n\\]\nで決定されており，これを踏まえて OLSのモデルを見てみると\n\\[\nz_i = \\left(a^2 + b^2 - r^2 - \\epsilon_i^2 - 2r\\epsilon \\right) - 2ax_i - 2by_i\n\\]\nとなるので，そもそもunbiasedな推定量になっていないと判断できます\n ▶  Regression with MLE\n\\(\\eqref{#eq-circle}\\) に則り，もっと直接的に\n\\[\nL(\\beta) = (\\sqrt{(x_i - \\beta_1)^2 + (y_i - \\beta_2)^2} - \\beta_0)^2\n\\]\nを最小する形でパラメーターを推定してみます．このとき．residualが\\(N(0, \\sigma)\\) に従うならばLikelihoodは\n\\[\nf(X_i\\vert \\beta, \\sigma) = \\frac{1}{\\sqrt{2\\pi}\\sigma}\\exp\\left(-\\frac{L(\\beta)}{2\\sigma^2}\\right)\n\\]\nと表せるので，これを用いて解いてみます．\n\n\nCode\nimport numpy as np\nfrom scipy.optimize import minimize\n\n\ndef lik(parameters, x, y):\n    x_0 = parameters[0]\n    y_0 = parameters[1]\n    r_0 = parameters[2]\n    sigma = parameters[3]\n    g_x = (np.sqrt((np.sqrt((x - x_0) ** 2 + (y - y_0) ** 2) - r_0)**2)) ** 2\n\n    L = len(x) / 2 * np.log(sigma**2) +  1 / (2 * sigma**2) * np.sum(g_x)\n    return L\n\n\ndef mle_solver(\n    df: pd.DataFrame, xy_columns: tuple[str] = (\"x_coordinate\", \"y_coordinate\")\n):\n\n    x_attack = df[xy_columns[0]].values\n    y_attack = df[xy_columns[1]].values\n    lik_model = minimize(\n        lambda params: lik(params, x_attack, y_attack),\n        np.array([1, 1, 20, 1]),\n        method=\"L-BFGS-B\",\n    )\n    return lik_model[\"x\"]\n\n\nmle_res = estimator_simulator(mle_solver)\n\n# plot\nfig, axes= plt.subplots(1, 2)\n\nsns.kdeplot(x=mle_res[:, 0], y=mle_res[:, 1], cmap=\"Blues\", fill=True, ax=axes[0])\nsns.kdeplot(x=mle_res[:, 2], cmap=\"Blues\", fill=True, ax=axes[1])\n\n# Show the plot\naxes[0].set_xlabel(\"estimated x coordinate\")\naxes[0].set_ylabel(\"estimated y coordinate\")\naxes[0].set_title(\"MLE 2D Density Plot\\nwith 1000 iterations\")\naxes[0].set_aspect(\"equal\")\naxes[1].set_title(\"Raidus Density Plot\\nwith 1000 iterations\")\n\nplt.show()\n\n\n\n\n\n\n\n\n\n定式化は正しいはずですが，\\((x_0, y_0, r_0)\\) は効率的な推定量となっていない疑いがあることが読み取れます．\n次に，\n\\[\nL(\\beta) = \\sqrt{(x_i - \\beta_1)^2 + (y_i - \\beta_2)^2 - \\beta_0^2} \\label{#eq-mle}\n\\]\nをLoss functionとして推定してみます．\n\n\nCode\nimport numpy as np\nfrom scipy.optimize import minimize\n\n\ndef lik(parameters, x, y):\n    x_0 = parameters[0]\n    y_0 = parameters[1]\n    r_0 = parameters[2]\n    sigma = parameters[3]\n    g_x = (x - x_0) ** 2 + (y - y_0) ** 2 - r_0**2\n\n    L = len(x) / 2 * np.log(sigma**2) +  1 / (2 * sigma**2) * np.sum(g_x)\n    return L\n\n\ndef mle_solver(\n    df: pd.DataFrame, xy_columns: tuple[str] = (\"x_coordinate\", \"y_coordinate\")\n):\n\n    x_attack = df[xy_columns[0]].values\n    y_attack = df[xy_columns[1]].values\n    lik_model = minimize(\n        lambda params: lik(params, x_attack, y_attack),\n        np.array([1, 1, 20, 1]),\n        method=\"L-BFGS-B\",\n    )\n    return lik_model[\"x\"]\n\n\nmle_res = estimator_simulator(mle_solver)\n\n# plot\nfig, axes= plt.subplots(1, 2)\n\nsns.kdeplot(x=mle_res[:, 0], y=mle_res[:, 1], cmap=\"Blues\", fill=True, ax=axes[0])\nsns.kdeplot(x=mle_res[:, 2], cmap=\"Blues\", fill=True, ax=axes[1])\n\n# Show the plot\naxes[0].set_xlabel(\"estimated x coordinate\")\naxes[0].set_ylabel(\"estimated y coordinate\")\naxes[0].set_title(\"MLE 2D Density Plot\\nwith 1000 iterations\")\naxes[0].set_aspect(\"equal\")\naxes[1].set_title(\"Raidus Density Plot\\nwith 1000 iterations\")\n\nplt.show()\n\n\n\n\n\n\n\n\n\n先程よりは精度良く推定できているように見えますが，\\(\\eqref{#eq-mle}\\) は\n\\[\nL(\\beta) = \\sqrt{\\epsilon_i^2 + 2\\beta_0 \\epsilon_i}\n\\]\nとなるので，そもそもMLEの定式化が間違っていることがわかります．また，\\(\\beta_0\\) が大きいほどresidualが大きくなる傾向があることから，unbiasedな推定量は得られていないことがわかります．\n ▶  Regression with stan\ncmdstanを用いて砲台座標を推定する例を紹介します．まずstan modelを以下のように設定します．\n\n砲撃距離のノイズについて \\(N(0, 1)\\) であることが既にわかっている状況を想定\n予定砲撃距離 \\(r_0\\) は \\(\\operatorname{Uniform}(2, 30)\\) の事前分布がある\n\ndata {\n    int&lt;lower=1&gt; N;  // Number of data points\n    array[N] real y; // outcomes\n    array[N] real x; // outcomes\n}\n\nparameters {\n    real&lt;lower=0&gt; r_0; // probability of success\n    real x_0;             // Center x-coordinate\n    real y_0;             // Center y-coordinate\n}\n\nmodel {\n    // priors\n    r_0 ~ uniform(2, 30);\n    real sigma = 1;\n\n    // objective loss\n    array[N] real circle_equation;\n    for (i in 1:N) {\n        circle_equation[i] = sqrt((x[i] - x_0)^2 + (y[i] - y_0)^2) - r_0;\n    }\n\n    circle_equation ~ normal(0, sigma);\n}\nその後，このモデルを用いて推定したものが以下となります．\n\nfrom cmdstanpy import CmdStanModel\n\ndf_stan = gpd_dataframe(0, 0, 1)\ndata = {\n    \"N\": df_stan.shape[0],\n    \"y\": df_stan.y_coordinate.values,\n    \"x\": df_stan.x_coordinate.values,\n    \"sigma\": 1,\n}\n\nmodel = CmdStanModel(stan_file=\"./stanmodel.stan\")\nfit = model.sample(data=data, seed=42)\nfit.summary()\n\n06:16:55 - cmdstanpy - INFO - compiling stan file /home/runner/work/regmonkey-datascience-blog/regmonkey-datascience-blog/posts/2025-03-02-find-coordinates/stanmodel.stan to exe file /home/runner/work/regmonkey-datascience-blog/regmonkey-datascience-blog/posts/2025-03-02-find-coordinates/stanmodel\n06:17:02 - cmdstanpy - INFO - compiled model executable: /home/runner/work/regmonkey-datascience-blog/regmonkey-datascience-blog/posts/2025-03-02-find-coordinates/stanmodel\n06:17:02 - cmdstanpy - INFO - CmdStan start processing\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n                                                                                                                                                                                                                                                                                                                                \n\n\n06:17:03 - cmdstanpy - INFO - CmdStan done processing.\n06:17:03 - cmdstanpy - WARNING - Some chains may have failed to converge.\n    Chain 1 had 310 divergent transitions (31.0%)\n    Chain 2 had 341 divergent transitions (34.1%)\n    Chain 3 had 293 divergent transitions (29.3%)\n    Chain 4 had 321 divergent transitions (32.1%)\n    Use the \"diagnose()\" method on the CmdStanMCMC object to see further information.\n\n\n\n\n\n\n\n\n\n\n\n\nMean\nMCSE\nStdDev\nMAD\n5%\n50%\n95%\nESS_bulk\nESS_tail\nESS_bulk/s\nR_hat\n\n\n\n\nlp__\n-22.627700\n0.044144\n1.21901\n0.873056\n-25.04740\n-22.267300\n-21.44630\n886.907\n1292.320\n377.8890\n1.00150\n\n\nr_0\n20.167700\n0.429917\n6.21166\n7.274600\n9.15980\n20.889900\n29.01690\n208.133\n258.641\n88.6806\n1.01911\n\n\nx_0\n0.151580\n0.131551\n1.88887\n1.973320\n-3.05708\n0.195962\n3.10467\n199.727\n234.533\n85.0987\n1.02554\n\n\ny_0\n-0.299075\n0.419656\n6.11452\n7.154330\n-8.93022\n-1.015920\n10.49840\n220.608\n278.533\n93.9959\n1.01959\n\n\n\n\n\n\n\nCredible intervalを見ると \\((0, 0)\\) は推定区間に含まれている一方，Mean, Medianともに \\(y_0\\) の方は乖離した値が推定されてしまっています．"
  },
  {
    "objectID": "posts/2025-05-01-how-css-works/index.html",
    "href": "posts/2025-05-01-how-css-works/index.html",
    "title": "CSSの組み込み方",
    "section": "",
    "text": "NoteKey Takeaways\n\n\n\n\n\n\n\n方法\n保守性\n再利用性\n適している場面\n\n\n\n\nインライン\n悪い\nなし\n一時的・緊急の変更\n\n\n内部CSS\n普通\nなし\n単一ページのスタイリング\n\n\n外部CSS\n良い\n高い\n大規模・再利用が前提の開発\n\n\n\n\n\n\nCSSをHTMLに組み込む方法として，\n\nインラインCSS\n内部参照CSS\n外部参照CSS\n\nの3つがあります．それぞれの使い分けも簡潔に解説します．\n1: インラインCSS\n&lt;p style=\"color: #ff0000; font-weight: bold;\"&gt;これは赤い太字のテキストです&lt;/p&gt;\n\nHTMLタグのstyle属性に直接書く方法\n特定の要素だけ一時的にスタイルを指定したいときに使用するが，構造であるHTMLドキュメントに直接デザインの指定をしてしまうので，多用するとメンテナンスが難しくなります\n一時的にテストするとき以外は原則として使用しないこと\n\nセレクタ(selector)とプロパティ(property)\n\nセレクタ: 「どのHTML要素にスタイルを適用するか」を指定する部分\nプロパティ: 「何をどうスタイルするか」の内容部分\n\nh1 {\n    color:#FF0000;\n}\nこの例では，h1がセレクタ，colorがプロパティ，#FF0000がプロパティに対応するValue\n2: 内部参照CSS\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n  &lt;style&gt;\n    p {\n      color: blue;\n      font-size: 18px;\n    }\n  &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;p&gt;これは青いテキストです。&lt;/p&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\nHTMLの&lt;head&gt;内に&lt;style&gt;タグでCSSを書く方法\nHTMLに直接書き込むスタイルなので，そのHTML1ページだけのスタイル指定(=使い回しができない)\n一時的にテストするとき以外は原則として使用しないこと\n\n3. 外部参照CSS\n\n\nhtml file\n\n&lt;head&gt;\n    &lt;link rel=\"stylesheet\" href=\"styles.css\" media=\"all\"&gt;\n&lt;/head&gt;\n\n\n\nstyle.css\n\np {\n  color: green;\n}\n\n\nHTMLの中に直接スタイルを書くのではなく，別ファイル（.css）として分けて管理し参照するスタイル\n複数ページに共通するデザインを一箇所で管理できるため，保守性や再利用性が高い\nブラウザがCSSファイルをキャッシュできるため，2回目以降の読み込みが速い\nHTML（構造）とCSS（デザイン）を分離するのはベストプラクティスとされている\n\n外部CSS参照の基本書式\n\n\n\n\n\n\n\n\n引数\n内容\n\n\n\n\nrel属性\n外部リソースとの関係性を指定．CSSを読み込む場合は \"stylesheet\"\n\n\nhref属性\n読み込むCSSファイルのURLやパスを指定\n\n\nmedia属性\nスタイルを適用するメディアタイプを指定．通常は \"all\" や \"screen\""
  },
  {
    "objectID": "posts/2025-05-01-how-css-works/index.html#cssをhtmlに組み込む方法",
    "href": "posts/2025-05-01-how-css-works/index.html#cssをhtmlに組み込む方法",
    "title": "CSSの組み込み方",
    "section": "",
    "text": "NoteKey Takeaways\n\n\n\n\n\n\n\n方法\n保守性\n再利用性\n適している場面\n\n\n\n\nインライン\n悪い\nなし\n一時的・緊急の変更\n\n\n内部CSS\n普通\nなし\n単一ページのスタイリング\n\n\n外部CSS\n良い\n高い\n大規模・再利用が前提の開発\n\n\n\n\n\n\nCSSをHTMLに組み込む方法として，\n\nインラインCSS\n内部参照CSS\n外部参照CSS\n\nの3つがあります．それぞれの使い分けも簡潔に解説します．\n1: インラインCSS\n&lt;p style=\"color: #ff0000; font-weight: bold;\"&gt;これは赤い太字のテキストです&lt;/p&gt;\n\nHTMLタグのstyle属性に直接書く方法\n特定の要素だけ一時的にスタイルを指定したいときに使用するが，構造であるHTMLドキュメントに直接デザインの指定をしてしまうので，多用するとメンテナンスが難しくなります\n一時的にテストするとき以外は原則として使用しないこと\n\nセレクタ(selector)とプロパティ(property)\n\nセレクタ: 「どのHTML要素にスタイルを適用するか」を指定する部分\nプロパティ: 「何をどうスタイルするか」の内容部分\n\nh1 {\n    color:#FF0000;\n}\nこの例では，h1がセレクタ，colorがプロパティ，#FF0000がプロパティに対応するValue\n2: 内部参照CSS\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n  &lt;style&gt;\n    p {\n      color: blue;\n      font-size: 18px;\n    }\n  &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;p&gt;これは青いテキストです。&lt;/p&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\nHTMLの&lt;head&gt;内に&lt;style&gt;タグでCSSを書く方法\nHTMLに直接書き込むスタイルなので，そのHTML1ページだけのスタイル指定(=使い回しができない)\n一時的にテストするとき以外は原則として使用しないこと\n\n3. 外部参照CSS\n\n\nhtml file\n\n&lt;head&gt;\n    &lt;link rel=\"stylesheet\" href=\"styles.css\" media=\"all\"&gt;\n&lt;/head&gt;\n\n\n\nstyle.css\n\np {\n  color: green;\n}\n\n\nHTMLの中に直接スタイルを書くのではなく，別ファイル（.css）として分けて管理し参照するスタイル\n複数ページに共通するデザインを一箇所で管理できるため，保守性や再利用性が高い\nブラウザがCSSファイルをキャッシュできるため，2回目以降の読み込みが速い\nHTML（構造）とCSS（デザイン）を分離するのはベストプラクティスとされている\n\n外部CSS参照の基本書式\n\n\n\n\n\n\n\n\n引数\n内容\n\n\n\n\nrel属性\n外部リソースとの関係性を指定．CSSを読み込む場合は \"stylesheet\"\n\n\nhref属性\n読み込むCSSファイルのURLやパスを指定\n\n\nmedia属性\nスタイルを適用するメディアタイプを指定．通常は \"all\" や \"screen\""
  },
  {
    "objectID": "posts/2024-12-18-secure-shell/index.html",
    "href": "posts/2024-12-18-secure-shell/index.html",
    "title": "Secure Shellの仕組み",
    "section": "",
    "text": "Def: Secure Shell \nSSH(Secure SHell)は，ネットワークで接続された他コンピューターを遠隔操作するためのプロトコルのこと\n\nSSHプロトコルには現在，SSH1とSSH2という２つのプロトコルがあります. それぞれのプロトコルには互換性はありません. 一般的には，SSH1プロトコルには脆弱性が発見されているのでSSH2を用います. Ubuntu Serverでは，デフォルトでSSH2のみが有効となっています.\n ▶  特徴\n\n強力な認証機能と暗号化により，ファイル転送やリモート操作を安全に行うことができる\nユーザーログイン時のユーザー認証に先立って，クライアントがサーバーの正当性を確認するホスト認証が毎回行われるため偽サーバーに接続することで発生する情報漏えいリスクを低減することができる\nクライアント側から ssh コマンドを用いてSSH接続を試みる場合は，接続先のコンピュータでsshd（SSH daemon：SSHのサーバプログラム）が 動作している必要がある\n\n\n\n\n\n\n\n\nNoteSSH接続の認証手順\n\n\n\n\n\nSSH接続を試みる際の認証は\n\nホスト認証\nユーザー認証\n\nの２段階に分かれます\n ▶  ホスト認証\n\n\n\n\n\nsequenceDiagram\n    participant A as ssh(client)\n    participant B as sshd(server)\n    A-&gt;&gt;B: ssh接続要求\n    B-&gt;&gt;A: ホスト認証鍵をクライアントへ渡す\n    A-&gt;&gt;B: ホスト認証鍵で暗号化した乱数をサーバーへ渡す\n    B-&gt;&gt;A: ホスト認証鍵の秘密鍵で復号化し，そのハッシュ値を送付\n    Note over A,B: ハッシュ値を比較し一致していれば接続成功&lt;br&gt;=ホスト認証完了\n\n\n\n\n\n\n ▶  秘密鍵公開鍵によるユーザー認証\nユーザー認証はホスト認証完了後に行われる処理となります.\n\n\n\n\n\nsequenceDiagram\n    participant A as ssh(client)\n    participant B as sshd(server)\n    A--&gt;&gt;B: 公開鍵をサーバーに設置\n    A-&gt;&gt;B: ssh接続要求\n    B-&gt;&gt;A: 公開鍵で暗号化した乱数をssh側に渡す\n    A-&gt;&gt;B: 秘密鍵で復号化し，そのハッシュ値を送付\n    Note over A,B: ハッシュ値を比較し一致していれば接続成功&lt;br&gt;=ユーザー認証完了\n\n\n\n\n\n\n\n\n\n\n\n\nDef: ホスト認証 \n接続先が正当な相手であるのかどうかの認証のこと\n\nsshコマンドで初めてサーバーに接続するとき，サーバーから送られてきた公開鍵のフィンガープリントの値が表示される. このフィンガープリントをクライアント側で受け入れると，~/.ssh/known_hostsに以下の情報が登録されます\n\n接続先サーバーのホスト名\n接続先サーバーのIPアドレス\n接続先サーバーの公開鍵\n\n初回接続時の際は，接続先サーバーのホスト認証鍵を持っていないので,接続先ホストが登録されていない旨のWarningが表示されます. このとき，接続をこのまま続けるか？と聞かれます. yesと選択すると，SSH接続先サーバーが~/.ssh/known_hostsに登録されます.\n% ssh hogehoge@123.456.78.9\nThe authenticity of host '123.456.78.9 (123.456.78.9)' can not be established.\nECDSA key fingerprint is SHA256:ghzvH/1TBjI0wvlYiRNDJvUsiYAX/R9eip5bw6+Rv10.\nAre you sure you want to continue connecting (yes/no/[fingerprint])?\n$ yes\nWarning: Permanently added '123.456.78.9' (ECDSA) to the list of known hosts.\nPassword:\nLast login: Thu Apr 11 04:16:45 2021\n上記におけるECDSA key fingerprintSHA256:ghzvH/1TBjI0wvlYiRNDJvUsiYAX/R9eip5bw6+Rv10，の意味はSHA256で公開鍵をハッシュ化すると ghzvH/1TBjI0wvlYiRNDJvUsiYAX/R9eip5bw6+Rv10というフィンガープリントが発行されることを指しています.\n一度接続するとクライアントの known_hosts というファイルにサーバーの公開鍵が保存されるので，初回接続以降は自動的に認証が行われるため警告が表示されなくなります.\n ▶  WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED! \n目的外のサーバーに接続している場合やサーバーの公開鍵が変わっている場合，警告が表示されます.一般的にはホストキーの変更は滅多に行わなれないため、許可済みのサーバーに接続した際、 WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED! のような警告が出た場合は注意する必要があります.\n% ssh ubuntu@12.3.4.56\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n\n\n@@\nIT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!\nSomeone could be eavesdropping on you right now (man-in-the-middle attack)!\nIt is also possible that a host key has just been changed.\nThe fingerprint for the ECDSA key sent by the remote host is\nSHA256:tfZBzQ16o7O7SH6u4ixBmL061Sxz8DOo1cFZ9oMuGjE.\nPlease contact your system administrator.\nAdd correct host key in /home/hogehoge/.ssh/known_hosts to get rid of this message.\nOffending ECDSA key in /home/hogehoge/.ssh/known_hosts:4\n  remove with:\n  ssh-keygen -f \"/home/hogehoge/.ssh/known_hosts\" -R \"12.3.4.56\"\nECDSA host key for 12.3.4.56 has changed and you have requested strict checking.\nHost key verification failed.\n\n\n\nホスト認証後に実施されるユーザー認証は，デフォルトでは，公開鍵認証，パスワード認証の順に実施されます. 公開鍵認証を行うには予めクライアントの公開鍵を接続先サーバーに登録する必要があります.\n ▶  公開鍵の置き場所\n公開鍵によるユーザー認証を行うにはクライアントが作成した秘密鍵/公開鍵キーペアのうち，後者をサーバー側にコピーする必要があります. 一般的には\n\n~/.ssh/authorized_keysファイルに登録する\n~/.ssh/authorized_keys以外のファイルに保存したい場合は，サーバー側の設定ファイルsshd_configで明示的に参照ファイルを指定する\n\n\nExample 1 : sshd_config設定 \netc/ssh/sshd_config にて AuthorizedKeysFile フィールドに\nAuthorizedKeysFile     .ssh/authorized_keys .ssh/authorized_keys2\nと設定することで .ssh/authorized_keys，.ssh/authorized_keys2 の２つを公開鍵読み込みファイルとして認識させることができます"
  },
  {
    "objectID": "posts/2024-12-18-secure-shell/index.html#sshの仕組み",
    "href": "posts/2024-12-18-secure-shell/index.html#sshの仕組み",
    "title": "Secure Shellの仕組み",
    "section": "",
    "text": "Def: Secure Shell \nSSH(Secure SHell)は，ネットワークで接続された他コンピューターを遠隔操作するためのプロトコルのこと\n\nSSHプロトコルには現在，SSH1とSSH2という２つのプロトコルがあります. それぞれのプロトコルには互換性はありません. 一般的には，SSH1プロトコルには脆弱性が発見されているのでSSH2を用います. Ubuntu Serverでは，デフォルトでSSH2のみが有効となっています.\n ▶  特徴\n\n強力な認証機能と暗号化により，ファイル転送やリモート操作を安全に行うことができる\nユーザーログイン時のユーザー認証に先立って，クライアントがサーバーの正当性を確認するホスト認証が毎回行われるため偽サーバーに接続することで発生する情報漏えいリスクを低減することができる\nクライアント側から ssh コマンドを用いてSSH接続を試みる場合は，接続先のコンピュータでsshd（SSH daemon：SSHのサーバプログラム）が 動作している必要がある\n\n\n\n\n\n\n\n\nNoteSSH接続の認証手順\n\n\n\n\n\nSSH接続を試みる際の認証は\n\nホスト認証\nユーザー認証\n\nの２段階に分かれます\n ▶  ホスト認証\n\n\n\n\n\nsequenceDiagram\n    participant A as ssh(client)\n    participant B as sshd(server)\n    A-&gt;&gt;B: ssh接続要求\n    B-&gt;&gt;A: ホスト認証鍵をクライアントへ渡す\n    A-&gt;&gt;B: ホスト認証鍵で暗号化した乱数をサーバーへ渡す\n    B-&gt;&gt;A: ホスト認証鍵の秘密鍵で復号化し，そのハッシュ値を送付\n    Note over A,B: ハッシュ値を比較し一致していれば接続成功&lt;br&gt;=ホスト認証完了\n\n\n\n\n\n\n ▶  秘密鍵公開鍵によるユーザー認証\nユーザー認証はホスト認証完了後に行われる処理となります.\n\n\n\n\n\nsequenceDiagram\n    participant A as ssh(client)\n    participant B as sshd(server)\n    A--&gt;&gt;B: 公開鍵をサーバーに設置\n    A-&gt;&gt;B: ssh接続要求\n    B-&gt;&gt;A: 公開鍵で暗号化した乱数をssh側に渡す\n    A-&gt;&gt;B: 秘密鍵で復号化し，そのハッシュ値を送付\n    Note over A,B: ハッシュ値を比較し一致していれば接続成功&lt;br&gt;=ユーザー認証完了\n\n\n\n\n\n\n\n\n\n\n\n\nDef: ホスト認証 \n接続先が正当な相手であるのかどうかの認証のこと\n\nsshコマンドで初めてサーバーに接続するとき，サーバーから送られてきた公開鍵のフィンガープリントの値が表示される. このフィンガープリントをクライアント側で受け入れると，~/.ssh/known_hostsに以下の情報が登録されます\n\n接続先サーバーのホスト名\n接続先サーバーのIPアドレス\n接続先サーバーの公開鍵\n\n初回接続時の際は，接続先サーバーのホスト認証鍵を持っていないので,接続先ホストが登録されていない旨のWarningが表示されます. このとき，接続をこのまま続けるか？と聞かれます. yesと選択すると，SSH接続先サーバーが~/.ssh/known_hostsに登録されます.\n% ssh hogehoge@123.456.78.9\nThe authenticity of host '123.456.78.9 (123.456.78.9)' can not be established.\nECDSA key fingerprint is SHA256:ghzvH/1TBjI0wvlYiRNDJvUsiYAX/R9eip5bw6+Rv10.\nAre you sure you want to continue connecting (yes/no/[fingerprint])?\n$ yes\nWarning: Permanently added '123.456.78.9' (ECDSA) to the list of known hosts.\nPassword:\nLast login: Thu Apr 11 04:16:45 2021\n上記におけるECDSA key fingerprintSHA256:ghzvH/1TBjI0wvlYiRNDJvUsiYAX/R9eip5bw6+Rv10，の意味はSHA256で公開鍵をハッシュ化すると ghzvH/1TBjI0wvlYiRNDJvUsiYAX/R9eip5bw6+Rv10というフィンガープリントが発行されることを指しています.\n一度接続するとクライアントの known_hosts というファイルにサーバーの公開鍵が保存されるので，初回接続以降は自動的に認証が行われるため警告が表示されなくなります.\n ▶  WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED! \n目的外のサーバーに接続している場合やサーバーの公開鍵が変わっている場合，警告が表示されます.一般的にはホストキーの変更は滅多に行わなれないため、許可済みのサーバーに接続した際、 WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED! のような警告が出た場合は注意する必要があります.\n% ssh ubuntu@12.3.4.56\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n\n\n@@\nIT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!\nSomeone could be eavesdropping on you right now (man-in-the-middle attack)!\nIt is also possible that a host key has just been changed.\nThe fingerprint for the ECDSA key sent by the remote host is\nSHA256:tfZBzQ16o7O7SH6u4ixBmL061Sxz8DOo1cFZ9oMuGjE.\nPlease contact your system administrator.\nAdd correct host key in /home/hogehoge/.ssh/known_hosts to get rid of this message.\nOffending ECDSA key in /home/hogehoge/.ssh/known_hosts:4\n  remove with:\n  ssh-keygen -f \"/home/hogehoge/.ssh/known_hosts\" -R \"12.3.4.56\"\nECDSA host key for 12.3.4.56 has changed and you have requested strict checking.\nHost key verification failed.\n\n\n\nホスト認証後に実施されるユーザー認証は，デフォルトでは，公開鍵認証，パスワード認証の順に実施されます. 公開鍵認証を行うには予めクライアントの公開鍵を接続先サーバーに登録する必要があります.\n ▶  公開鍵の置き場所\n公開鍵によるユーザー認証を行うにはクライアントが作成した秘密鍵/公開鍵キーペアのうち，後者をサーバー側にコピーする必要があります. 一般的には\n\n~/.ssh/authorized_keysファイルに登録する\n~/.ssh/authorized_keys以外のファイルに保存したい場合は，サーバー側の設定ファイルsshd_configで明示的に参照ファイルを指定する\n\n\nExample 1 : sshd_config設定 \netc/ssh/sshd_config にて AuthorizedKeysFile フィールドに\nAuthorizedKeysFile     .ssh/authorized_keys .ssh/authorized_keys2\nと設定することで .ssh/authorized_keys，.ssh/authorized_keys2 の２つを公開鍵読み込みファイルとして認識させることができます"
  },
  {
    "objectID": "posts/2024-12-18-secure-shell/index.html#ssh-コマンドの実践",
    "href": "posts/2024-12-18-secure-shell/index.html#ssh-コマンドの実践",
    "title": "Secure Shellの仕組み",
    "section": "ssh コマンドの実践",
    "text": "ssh コマンドの実践\n\nsshコマンド\nSSHを使ってサーバーに接続するには，以下のようにsshコマンドを使います. 終了する場合は，exit，または Ctrl + Dを入力します.\n% ssh [option] &lt;username&gt;@&lt;hostname&gt;\n\n\n\n\n\n\n\nOption\n説明\n\n\n\n\n-p ポート番号\n接続に使用するポート番号を指定する\n\n\n-l ユーザー名\n接続に使用するユーザー名を指定する\n\n\n-i IDファイル\n接続に使用する公開鍵ファイルを指定する\n\n\n-f\nコマンドを実行する際にsshをバックグラウンドにする（Xアプリケーションを実行する際に使用）\n\n\n-F 設定ファイル\n設定ファイルを指定する\n\n\n\n ▶  接続先情報の設定ファイル: ~/.ssh/config\nsshコマンド実行時のオプションを~/.ssh/configで登録することができます.\nHost DEDEDE\n  HostName 100.21.209.82\n  User kirby_MBP\n  Port 1000\n  IdentityFile ~/.ssh/my_id_rsa\n  LocalForward 9999 localhost:9999\nと設定すると以下のコマンドは同じ挙動になります\n% ssh DEDEDE\n% ssh kirby_MBP@100.21.209.82 -p 1000 -i ~/.ssh/my_id_rsa -L 9999:localhost:9999\n\n\nssh-keygenコマンドによる認証鍵生成\n% ssh-keygen [option]\n\n\n\n\n\n\n\nOption\n説明\n\n\n\n\n-t タイプ\n暗号化タイプの指定\n\n\n-l\n鍵のフィンガープリントを表示する\n\n\n-f ファイル名\n鍵ファイルを指定する（生成または読み出すファイルを指定）\n\n\n-R ホスト名\n指定したホスト情報をknwon_hostsファイルから削除する\n\n\n-C コメント\nコメントを指定する（デフォルトは「ユーザー名@ホスト名」。「-C ““」でコメントを削除）\n\n\n\n ▶  暗号化アルゴリズムの種類\n\n\n\n\n\n\n\nSSH version\nssh-keygenコマンド\n\n\n\n\nSSH1 RSA\nssh-keygen -t rsa1\n\n\nSSH2 DSA\nssh-keygen -t dsa\n\n\nSSH2 RSA\nssh-keygen -t rsa\n\n\nSSH2 ECDSA\nssh-keygen -t ecdsa\n\n\nSSH2 ED25519\nssh-keygen -t ed25519\n\n\n\n\n\n\n\n\n\nTip🍵 ED25519のススメ\n\n\n\nGitHubやGitLabのドキュメントを確認すると，ED25519の使用が推奨されています.\nGitLabより引用すると\n\nThe book Practical Cryptography With Go suggests that ED25519 keys are more secure and performant than RSA keys. OpenSSH 6.5 introduced ED25519 SSH keys in 2014，and they should be available on most operating systems.\n\nED25519は以下のような特徴があります\n\n楕円曲線を用いた暗号\nRSAやDSAの鍵長の約半分以下で同等のセキュリティ強度が得られる\n鍵長が短いので，暗号化/復号化の計算を高速に行える\n\n従って，以下のコマンドで鍵を生成するようにしてください.\n% ssh-keygen -t e\n\n\n ▶  鍵の生成\nssh-keygenコマンドを使うと\n\n鍵ファイル名の指定（そのままEnterを入力するとデフォルトのファイル名となる）\nパスフレーズの入力（特別な理由がない限り設定する）\n\nが求められます. 特段の事情がない限り個人的には設定する方針としています. なお生成される公開鍵には，デフォルトではユーザ名とホスト名がコメントとして記載されています(以下の例ではhoge@foofoo)\n% ssh-keygen -t ed25519                                           \nGenerating public/private ed25519 key pair.\nEnter file in which to save the key (/home/hogehoge/.ssh/id_ed25519): hogehoge_ed25519\nEnter passphrase (empty for no passphrase): \nEnter same passphrase again: \nYour identification has been saved in hogehoge_ed25519\nYour public key has been saved in hogehoge_ed25519.pub\nThe key fingerprint is:\nSHA256:MnM1r0IqwugnLCTEnSHjuPoTk7mdmSMExw+r5cOkrwQ hoge@foofoo\nThe key's randomart image is:\n+--[ED25519 256]--+\n|@+%.  o  o       |\n|.o.Eo *  + S     |\n|. o..oo +        |\n|@+%.  o  o       |\n| .oo=.= S =      |\n|   ..B o + +     |\n|    = * . o .    |\n| o++o            |\n|+B==.. ....      |\n+----[SHA256]-----+\n秘密鍵の作成後，誤って内容が書き換わってしまうリスクを抑えるため，Permissionを400に設定しときます:\n% sudo chmod 400 id_ed25519\n\n\nssh-copy-idコマンド: 接続先ホストへの公開鍵登録\n鍵ペア作成後，公開鍵を接続先ホストへ登録する必要あります. この時使われるコマンドが ssh-copy-idコマンドです. なお，初回登録時点では接続先ホストではパスワード認証によるログインが許可されている必要があります.\n\nExample 2 : ssh-copy-idコマンド \n以下のコマンドで接続先サーバーの.ssh/authorized_keysに公開鍵を追記することができます\n% ssh-copy-id [-p ポート番号] -i 公開鍵ファイル名 USERNAME@$HOST\n\n# 以下のコマンドと同義\n# cat 公開鍵ファイル名 \\\n#  | ssh -p ポート番号 USERNAME@$HOST \\\n#  \"mkdir -p ~/.ssh; cat &gt;&gt; ~/.ssh/authorized_keys\"\n\n.ssh/authorized_keysファイルが存在しなくても，自動的に作成してくれます\nこのコマンド実施時には接続先ホストのパスワード入力が求められます.\n登録後はOpenSSHサーバーの設定を変更し，パスワード認証を無効にすることが推奨されます.\n\n\n\n\n\nsshpass コマンド\n\nsshpass(noninteractive ssh password provider)とは，sshコマンドでSSH接続を試みる際に要求されるログインパスワードを 事前に指定した方法でコマンドプロンプトへ渡し，簡単にSSH接続を実現するCLI機能のこと\nsshpass -p &lt;password&gt; ssh &lt;usename@&gt;接続先ホスト という形で実行するとシステムユーザーによるpsコマンドで パスワードがバレてしまうというリスクがあるので，便利さの一方，セキュリティリスクがある点について留意が必要\n\n ▶  インストール方法\n% sudo apt install sshpass ## Ubuntu\nMacだと以下のようなメッセージで怒られます.\n#Error: No available formula or cask with the name \"sshpass\".\n#We won't add sshpass because it makes it too easy for novice SSH users to\n#ruin SSH's security.\nそれでもインストールしたい場合は，ソースから直接以下のような方法でインストールします:\n% wget http://sourceforge.net/projects/sshpass/files/latest/download -O sshpass.tar.gz\n% tar -xvf sshpass.tar.gz\n% cd sshpass-1.08\n% ./configure\n% sudo make install \n% which sshpass ##pathが通っているか確認\n ▶  sshpassコマンドの利用方法\nヘルプコマンドで利用方法を確認してみます:\n% sshpass -h\nUsage: sshpass [-f|-d|-p|-e] [-hV] command parameters\n   -f filename   Take password to use from file\n   -d number     Use number as file descriptor for getting password\n   -p password   Provide password as argument (security unwise)\n   -e            Password is passed as env-var \"SSHPASS\"\n   With no parameters - password will be taken from stdin\n\n   -P prompt     Which string should sshpass search for to detect a password prompt\n   -v            Be verbose about what you're doing\n   -h            Show help (this screen)\n   -V            Print version information\nAt most one of -f，-d，-p or -e should be used\n% sshpass -p '&lt;passphrase&gt;' ssh username@host \nという形で利用することもできますが，psコマンドでpassphraseがダダ漏れになってしまうので\n% sshpass -f &lt;configfilepath&gt; ssh username@host\nまたは，-eオプションを指定することで環境変数SSHPASSを参照することができるので\n% export SSHPASS='my_pass_here'\n% echo $SSHPASS\n% sshpass -e ssh username@host \n\n\nscp コマンド: ホストとクライアント間のファイル転送\n% scp [オプション] コピー元 コピー先 \nコピー元，コピー先はそれぞれのPATHを入力しますがリモート側/ローカル側の書式例は以下です:\n\nリモートサーバー側: username@hostname：PATH\nローカルクライアント側:PATH\n\n\n\n\n\n\n\n\nOption\n説明\n\n\n\n\n-i 秘密鍵ファイル\nRSAまたはDSA認証の秘密鍵ファイルを指定する\n\n\n-P ポート番号\nポート番号を指定する\n\n\n-p\nコピー元ファイルとディレクトリの更新時間、アクセス時間、パーミッションを保持したまま転送する場合\n\n\n-r\nディレクトリ内を再帰的にコピーする\n\n\n\n ▶  ローカルからリモートホストにファイル/ディレクトリをコピー\n## ファイルのコピー\n% scp ~/tmp/file1 user@192.168.10.1:/home/user/tmp/ \n\n## ディレクトリのコピー\n% scp -r ~/tmp user1@192.168.10.1:/home/user/tmp\n\n## sshpassとの組合せ\n% sshpass -f passwordFile scp ~/tmp/file1 user@192.168.10.1:/home/user/tmp/ \n ▶  リモートホストからローカルにファイル/ディレクトリをコピー\n## ファイルのコピー\n% scp user@192.168.10.1:/home/user/file1 ~/tmp\n \n## ディレクトリのコピー\n% scp -r user@192.168.10.1:/home/user/tmp ~/tmp\n \n## 複数のファイルを、{}で囲んで「,」で区切り指定しコピーする例\n% scp user@192.168.10.1:/home/user/{file1,file2,file3} ~/tmp\n ▶  リモートホストから別のリモートホストにファイル/ディレクトリをコピー\n% scp user1@192.168.10.1:/home/user/tmp/file1 user2@192.168.10.2:/home/user/tmp/"
  },
  {
    "objectID": "posts/2025-02-28-cavalieri-principle/index.html",
    "href": "posts/2025-02-28-cavalieri-principle/index.html",
    "title": "カバリエリの原理",
    "section": "",
    "text": "一辺長さ \\(2\\) の正方形を底面として高さ3の直方体と，それをちょっとずつねじる形でずらした立体を以下のように考えます． 右図において，\\(xy\\) 平面に並行な各断面はどれも等しく一辺の長さ \\(2\\) の正方形で，その面積は \\(4\\) となってるとします．\nこのとき，カバリエリの原理よりどちらの立体像の体積は等しいことが言えます．\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.mplot3d.art3d import Poly3DCollection\n\n\ndef plot_cuboid(data, length=2, width=2, height=3, ax=None):\n    if ax is None:\n        fig = plt.figure()\n        ax = fig.add_subplot(111, projection=\"3d\")\n    poly3d = Poly3DCollection(data, alpha=0.2, edgecolor=\"k\")\n    ax.add_collection3d(poly3d)\n\n    # Set limits\n    max_dim = max(length, width, height)\n    ax.set_xlim([-max_dim, max_dim])\n    ax.set_ylim([-max_dim, max_dim])\n    ax.set_zlim([0, height * 1.1])\n    ax.set_xlabel(\"X\")\n    ax.set_ylabel(\"Y\")\n    ax.set_zlabel(\"Z\")\n\n\ndef twisted_cuboid(\n    length=2, width=2, height=3, twist_angle=np.pi / 2, num_segments=500\n):\n    # Define the base (bottom) of the cuboid\n    base_vertices = np.array(\n        [\n            [-length / 2, -width / 2, 0],\n            [length / 2, -width / 2, 0],\n            [length / 2, width / 2, 0],\n            [-length / 2, width / 2, 0],\n        ]\n    )\n\n    # Define the top face with a twist\n    rotation_matrix = np.array(\n        [\n            [np.cos(twist_angle), -np.sin(twist_angle), 0],\n            [np.sin(twist_angle), np.cos(twist_angle), 0],\n            [0, 0, 1],\n        ]\n    )\n    top_vertices = base_vertices @ rotation_matrix.T + np.array([0, 0, height])\n\n    # Interpolate between base and top vertices\n    vertices = []\n    for i in range(num_segments + 1):\n        t = i / num_segments\n        interpolated_vertices = (1 - t) * base_vertices + t * top_vertices\n        vertices.append(interpolated_vertices)\n    vertices = np.vstack(vertices)\n\n    # Define faces\n    faces = []\n    for i in range(num_segments):\n        for j in range(4):\n            next_j = (j + 1) % 4\n            faces.append(\n                [\n                    vertices[i * 4 + j],\n                    vertices[i * 4 + next_j],\n                    vertices[(i + 1) * 4 + next_j],\n                    vertices[(i + 1) * 4 + j],\n                ]\n            )\n\n    return faces\n\n\ndef cuboid(length=2, width=2, height=3, num_segments=100, ax=None):\n    # Define the base (bottom) of the cuboid\n    base_vertices = np.array(\n        [\n            [-length / 2, -width / 2, 0],\n            [length / 2, -width / 2, 0],\n            [length / 2, width / 2, 0],\n            [-length / 2, width / 2, 0],\n        ]\n    )\n\n    # Define the top face without a twist\n    top_vertices = base_vertices + np.array([0, 0, height])\n\n    # Interpolate between base and top vertices\n    vertices = []\n    for i in range(num_segments + 1):\n        t = i / num_segments\n        interpolated_vertices = (1 - t) * base_vertices + t * top_vertices\n        vertices.append(interpolated_vertices)\n    vertices = np.vstack(vertices)\n\n    # Define faces\n    faces = []\n    for i in range(num_segments):\n        for j in range(4):\n            next_j = (j + 1) % 4\n            faces.append(\n                [\n                    vertices[i * 4 + j],\n                    vertices[i * 4 + next_j],\n                    vertices[(i + 1) * 4 + next_j],\n                    vertices[(i + 1) * 4 + j],\n                ]\n            )\n\n    return faces\n\n\n# compute points\ncuboid_records = cuboid()\ntwisted_cuboid_records = twisted_cuboid()\n\n# plots\nfig = plt.figure(figsize=(12, 6))\nax1 = fig.add_subplot(121, projection=\"3d\")\nax2 = fig.add_subplot(122, projection=\"3d\")\n\nplot_cuboid(cuboid_records, ax=ax1)\nplot_cuboid(twisted_cuboid_records, ax=ax2)\n\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\nTheorem 1 : カバリエリの原理 \n2つの立体について，平行な平面で切った切り口を比べる．互いの面積がいつも等しいならば，この２つの立体の体積は等しい．\n\n\n半径 \\(r\\) の円を底面とする高さ \\(h\\) の円柱を考えます． なお \\(h = r\\) とします．この円柱から，半径 \\(r\\) の円を底面とする円錐を以下のように抜き取った立体を作ります（以降，穴あき円柱と呼ぶ）．\n\n\n\nカバリエリの原理\n\n\nこの穴開き円柱の体積は\n\\[\n\\begin{align}\n\\pi r^2\\times h - \\pi r^2\\times \\frac{h}{3}\n    &= \\frac{2}{3} \\pi r^2 h\n\\end{align}\n\\]\n一方，半径 \\(r\\) の半球の体積は\n\\[\n\\begin{align}\n\\frac{1}{2} \\times \\frac{4}{3}\\pi r^3 = \\frac{2}{3} \\pi r^2h\n\\end{align}\n\\]\n２つの立体の体積が一致することがわかります．これをカバリエリの原理を使って確かめてみます．\nまず穴あき円錐について，高さ \\(a \\in [0, h]\\) における断面積（緑色の部分）は\n\\[\nr^2\\pi - \\left(\\frac{a}{r}r\\right)^2\\pi = (r^2 - a^2)\\pi\n\\]\n半球の方は，ピタゴラスの定理より高さ \\(a\\) のときの半径が \\(\\sqrt{r^2 - a^2}\\) と求まるので\n\\[\n(\\sqrt{r^2 - a^2})^2\\pi = (r^2 - a^2)\\pi\n\\]\n従って，２つの立体について任意の高さ \\(a \\in [0, h]\\) において互いの面積がいつも等しいことがわかります．\n\n\n半径 \\(r\\), 弧の長さ \\(l\\) の扇形の面積を求めたいとします．扇形に対し，分割交互ずらしをして以下のように長方形へ極限等積変形を実施します．\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom matplotlib.patches import Wedge, Polygon\n\n# Parameters\nr = 1  # radius\nl = 0.5  # arc length\n\n# Calculate the angle of the sector\ntheta = l / r  # in radians\ndivide_num = 4\n\n# Create the sector\nfig, ax = plt.subplots(1, 2, figsize=(12, 6))\n\n# Plot the original sector\nsector = Wedge(\n    (0, 0), r, 0, np.degrees(theta), facecolor=\"lightblue\", edgecolor=\"black\"\n)\nax[0].add_patch(sector)\nax[0].set_xlim(-0.1, r * 1.2)\nax[0].set_ylim(-0.1, l)\nax[0].set_aspect(\"equal\", \"box\")\nax[0].set_title(\"Original Sector\")\n\n# Divide the sector into four parts\nangles = np.linspace(0, theta, divide_num+1)\nfor i in range(divide_num):\n    wedge = Wedge(\n        (0, 0),\n        r,\n        np.degrees(angles[i]),\n        np.degrees(angles[i + 1]),\n        facecolor=\"none\",\n        edgecolor=\"black\",\n    )\n    ax[0].add_patch(wedge)\n\n# Rearrange the parts into a parallelogram\n\n# Create the parallelogram by shifting the parts\nfor i in range(divide_num):\n    if i % 2 == 0:\n        sector = Wedge(\n            (0, np.sin(theta / divide_num) * (i // 2)), r, 0, np.degrees(theta / divide_num), facecolor=\"lightblue\", edgecolor=\"black\"\n        )\n    else:\n        sector = Wedge(\n            (np.cos(theta / divide_num), np.sin(theta / divide_num) * (i // 2 + 1 )),\n            r,\n            np.degrees(np.pi),\n            np.degrees(theta / divide_num + np.pi),\n            facecolor=\"lightblue\",\n            edgecolor=\"black\",\n        )\n    ax[1].add_patch(sector)\n    \n\n# add info\nax[1].text(1.01, l/4, f\"Height = $l/2$\", horizontalalignment=\"left\")\n\nax[1].set_xlim(-0.1, r * 1.2)\nax[1].set_ylim(-0.1, l)\nax[1].set_aspect(\"equal\", \"box\")\nax[1].set_title(\"Rearranged into Parallelogram\")\n\nplt.show()\n\n\n\n\n\n\n\n\n\n上の図では４分割ですが，これを細かくすると横の長さ \\(r\\), 縦の長さ \\(l/2\\) の長方形へ変形することができるとみなせるので\n\\[\nS = \\frac{l}{2}r\n\\]\nと計算することが出来ます．半径 \\(r\\), 弧の長さ \\(l = 2\\pi r\\) のとき，扇形は円になりますが，その円の面積も同様に\n\\[\nS = \\frac{2\\pi r}{2}r = r^2 \\pi\n\\]\nと計算でき，円の面積の公式と一致することがわかります\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom matplotlib.patches import Wedge, Polygon\n\n# Parameters\nr = 2  # radius\nl = 2*np.pi * r  # arc length\n\n# Calculate the angle of the sector\ntheta = l / r  # in radians\ndivide_num = 100\n\n# Create the sector\nfig, ax = plt.subplots(1, 2, figsize=(12, 6))\n\n# Plot the original sector\nsector = Wedge(\n    (0, 0), r, 0, np.degrees(theta), facecolor=\"lightblue\", edgecolor=\"black\"\n)\nax[0].add_patch(sector)\nax[0].set_xlim(-r * 1.2, r * 1.2)\nax[0].set_ylim(-r * 1.2, r * 1.2)\nax[0].set_aspect(\"equal\", \"box\")\nax[0].set_title(\"Original Sector\")\n\n# Divide the sector into four parts\nangles = np.linspace(0, theta, divide_num+1)\nfor i in range(divide_num):\n    wedge = Wedge(\n        (0, 0),\n        r,\n        np.degrees(angles[i]),\n        np.degrees(angles[i + 1]),\n        facecolor=\"none\",\n        edgecolor=\"black\",\n    )\n    ax[0].add_patch(wedge)\n\n# Rearrange the parts into a parallelogram\n\n# Create the parallelogram by shifting the parts\nfor i in range(divide_num):\n    if i % 2 == 0:\n        sector = Wedge(\n            (0, np.sin(theta / divide_num) * (i // 2)* r), r, 0, np.degrees(theta / divide_num), facecolor=\"lightblue\", edgecolor=\"black\"\n        )\n    else:\n        sector = Wedge(\n            (np.cos(theta / divide_num)* r, np.sin(theta / divide_num) * r * (i // 2 + 1 )),\n            r,\n            np.degrees(np.pi),\n            np.degrees(theta / divide_num + np.pi),\n            facecolor=\"lightblue\",\n            edgecolor=\"black\",\n        )\n    ax[1].add_patch(sector)\n    \n\n# add info\nax[1].text(r + 0.01, l/4, f\"Height = $r\\pi$\", horizontalalignment=\"left\")\n\nax[1].set_xlim(-0.5, r * 1.2)\nax[1].set_ylim(-0.5, l/2 * 1.05)\nax[1].set_aspect(\"equal\", \"box\")\nax[1].set_title(\"Rearranged into Parallelogram\")\n\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n半径 \\(2\\), 弧の長さが \\(\\displaystyle L = \\frac{2}{3}\\pi\\) の扇形から，半径 \\(2/3\\), 弧の長さが \\(\\displaystyle l = \\frac{2}{9}\\pi\\) の扇形を除いたパイン形を考えます．このパイン形に対して，「分割交互ずらし」を適用して極限を取ると，底辺の長さ \\(\\displaystyle \\frac{4}{3}\\)，高さ\n\\[\n\\text{height} = \\frac{l + L}{2} = \\frac{4}{9}\\pi\n\\]\nの長方形へ収束します．このとき，このパイン型の面積は\n\\[\nS = \\frac{l + L}{2}\\times \\frac{4}{3} = \\frac{16}{27}\\pi\n\\]\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom shapely.geometry import Polygon\nfrom shapely.affinity import translate\nfrom shapely.ops import unary_union\nfrom shapely.affinity import rotate\nimport geopandas as gpd\n\n\ndef create_sector(center, radius, angle_start, angle_end, num_points=100):\n    \"\"\"Creates a sector shape as a polygon using Shapely.\"\"\"\n    angles = np.linspace(np.radians(angle_start), np.radians(angle_end), num_points)\n    outer_arc = [\n        (center[0] + radius * np.cos(a), center[1] + radius * np.sin(a)) for a in angles\n    ]\n    return Polygon([center] + outer_arc + [center])  # Close the polygon\n\n\n# Parameters\ndivide_num = 20\nring_sector_list = []\nouter_radius = 2\nangle = 60 / divide_num\n\nfor i in range(divide_num):\n    center = (0, 0)\n    inner_radius = outer_radius / 3\n    angle_start, angle_end = angle * i, angle * (i + 1)  # Angle in degrees\n\n    # Create outer and inner sectors\n    outer_sector = create_sector(center, outer_radius, angle_start, angle_end)\n    inner_sector = create_sector(center, inner_radius, angle_start, angle_end)\n\n    # Subtract inner sector from outer sector to get the ring shape\n    ring_sector = outer_sector.difference(inner_sector)\n    ring_sector_list.append(ring_sector)\n\n\n# plot\nfig, ax = plt.subplots(1, 2, figsize=(12, 6))\n\nfor ring_sector in ring_sector_list:\n    # Plot using GeoPandas\n    gdf = gpd.GeoSeries([ring_sector])\n    gdf.plot(ax=ax[0], color=\"lightblue\", edgecolor=\"black\")\n\n# Formatting\nax[0].set_xlim(-0.05, outer_radius + 0.1)\nax[0].set_ylim(-0.05, outer_radius + 0.1)\n\ngdf = gpd.GeoSeries([ring_sector_list[0]])\nrotated_gdf = gpd.GeoSeries(rotate(ring_sector_list[0], 180, origin=\"center\"))\nfor i in range(len(ring_sector_list)):\n    # Plot using GeoPandas\n    if i % 2 == 0:\n        gdf_tmp = gdf.apply(\n            lambda geom: translate(\n                geom, xoff=-2/3, yoff=np.sin(np.radians(angle))*8/3 * (i//2)\n            )\n        )\n        gdf_tmp.plot(ax=ax[1], color=\"lightblue\", edgecolor=\"black\")\n    else:\n        gdf_tmp = rotated_gdf.apply(\n            lambda geom: translate(\n                geom, xoff=-2/3, yoff=np.sin(np.radians(angle))*2/3 * (i//2 + 1) + np.sin(np.radians(angle))*6/3 * (i//2)\n            ))\n        gdf_tmp.plot(ax=ax[1], color=\"lightblue\", edgecolor=\"black\")\n\n\nplt.show()"
  },
  {
    "objectID": "posts/2025-02-28-cavalieri-principle/index.html#カバリエリの原理",
    "href": "posts/2025-02-28-cavalieri-principle/index.html#カバリエリの原理",
    "title": "カバリエリの原理",
    "section": "",
    "text": "一辺長さ \\(2\\) の正方形を底面として高さ3の直方体と，それをちょっとずつねじる形でずらした立体を以下のように考えます． 右図において，\\(xy\\) 平面に並行な各断面はどれも等しく一辺の長さ \\(2\\) の正方形で，その面積は \\(4\\) となってるとします．\nこのとき，カバリエリの原理よりどちらの立体像の体積は等しいことが言えます．\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.mplot3d.art3d import Poly3DCollection\n\n\ndef plot_cuboid(data, length=2, width=2, height=3, ax=None):\n    if ax is None:\n        fig = plt.figure()\n        ax = fig.add_subplot(111, projection=\"3d\")\n    poly3d = Poly3DCollection(data, alpha=0.2, edgecolor=\"k\")\n    ax.add_collection3d(poly3d)\n\n    # Set limits\n    max_dim = max(length, width, height)\n    ax.set_xlim([-max_dim, max_dim])\n    ax.set_ylim([-max_dim, max_dim])\n    ax.set_zlim([0, height * 1.1])\n    ax.set_xlabel(\"X\")\n    ax.set_ylabel(\"Y\")\n    ax.set_zlabel(\"Z\")\n\n\ndef twisted_cuboid(\n    length=2, width=2, height=3, twist_angle=np.pi / 2, num_segments=500\n):\n    # Define the base (bottom) of the cuboid\n    base_vertices = np.array(\n        [\n            [-length / 2, -width / 2, 0],\n            [length / 2, -width / 2, 0],\n            [length / 2, width / 2, 0],\n            [-length / 2, width / 2, 0],\n        ]\n    )\n\n    # Define the top face with a twist\n    rotation_matrix = np.array(\n        [\n            [np.cos(twist_angle), -np.sin(twist_angle), 0],\n            [np.sin(twist_angle), np.cos(twist_angle), 0],\n            [0, 0, 1],\n        ]\n    )\n    top_vertices = base_vertices @ rotation_matrix.T + np.array([0, 0, height])\n\n    # Interpolate between base and top vertices\n    vertices = []\n    for i in range(num_segments + 1):\n        t = i / num_segments\n        interpolated_vertices = (1 - t) * base_vertices + t * top_vertices\n        vertices.append(interpolated_vertices)\n    vertices = np.vstack(vertices)\n\n    # Define faces\n    faces = []\n    for i in range(num_segments):\n        for j in range(4):\n            next_j = (j + 1) % 4\n            faces.append(\n                [\n                    vertices[i * 4 + j],\n                    vertices[i * 4 + next_j],\n                    vertices[(i + 1) * 4 + next_j],\n                    vertices[(i + 1) * 4 + j],\n                ]\n            )\n\n    return faces\n\n\ndef cuboid(length=2, width=2, height=3, num_segments=100, ax=None):\n    # Define the base (bottom) of the cuboid\n    base_vertices = np.array(\n        [\n            [-length / 2, -width / 2, 0],\n            [length / 2, -width / 2, 0],\n            [length / 2, width / 2, 0],\n            [-length / 2, width / 2, 0],\n        ]\n    )\n\n    # Define the top face without a twist\n    top_vertices = base_vertices + np.array([0, 0, height])\n\n    # Interpolate between base and top vertices\n    vertices = []\n    for i in range(num_segments + 1):\n        t = i / num_segments\n        interpolated_vertices = (1 - t) * base_vertices + t * top_vertices\n        vertices.append(interpolated_vertices)\n    vertices = np.vstack(vertices)\n\n    # Define faces\n    faces = []\n    for i in range(num_segments):\n        for j in range(4):\n            next_j = (j + 1) % 4\n            faces.append(\n                [\n                    vertices[i * 4 + j],\n                    vertices[i * 4 + next_j],\n                    vertices[(i + 1) * 4 + next_j],\n                    vertices[(i + 1) * 4 + j],\n                ]\n            )\n\n    return faces\n\n\n# compute points\ncuboid_records = cuboid()\ntwisted_cuboid_records = twisted_cuboid()\n\n# plots\nfig = plt.figure(figsize=(12, 6))\nax1 = fig.add_subplot(121, projection=\"3d\")\nax2 = fig.add_subplot(122, projection=\"3d\")\n\nplot_cuboid(cuboid_records, ax=ax1)\nplot_cuboid(twisted_cuboid_records, ax=ax2)\n\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\nTheorem 1 : カバリエリの原理 \n2つの立体について，平行な平面で切った切り口を比べる．互いの面積がいつも等しいならば，この２つの立体の体積は等しい．\n\n\n半径 \\(r\\) の円を底面とする高さ \\(h\\) の円柱を考えます． なお \\(h = r\\) とします．この円柱から，半径 \\(r\\) の円を底面とする円錐を以下のように抜き取った立体を作ります（以降，穴あき円柱と呼ぶ）．\n\n\n\nカバリエリの原理\n\n\nこの穴開き円柱の体積は\n\\[\n\\begin{align}\n\\pi r^2\\times h - \\pi r^2\\times \\frac{h}{3}\n    &= \\frac{2}{3} \\pi r^2 h\n\\end{align}\n\\]\n一方，半径 \\(r\\) の半球の体積は\n\\[\n\\begin{align}\n\\frac{1}{2} \\times \\frac{4}{3}\\pi r^3 = \\frac{2}{3} \\pi r^2h\n\\end{align}\n\\]\n２つの立体の体積が一致することがわかります．これをカバリエリの原理を使って確かめてみます．\nまず穴あき円錐について，高さ \\(a \\in [0, h]\\) における断面積（緑色の部分）は\n\\[\nr^2\\pi - \\left(\\frac{a}{r}r\\right)^2\\pi = (r^2 - a^2)\\pi\n\\]\n半球の方は，ピタゴラスの定理より高さ \\(a\\) のときの半径が \\(\\sqrt{r^2 - a^2}\\) と求まるので\n\\[\n(\\sqrt{r^2 - a^2})^2\\pi = (r^2 - a^2)\\pi\n\\]\n従って，２つの立体について任意の高さ \\(a \\in [0, h]\\) において互いの面積がいつも等しいことがわかります．\n\n\n半径 \\(r\\), 弧の長さ \\(l\\) の扇形の面積を求めたいとします．扇形に対し，分割交互ずらしをして以下のように長方形へ極限等積変形を実施します．\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom matplotlib.patches import Wedge, Polygon\n\n# Parameters\nr = 1  # radius\nl = 0.5  # arc length\n\n# Calculate the angle of the sector\ntheta = l / r  # in radians\ndivide_num = 4\n\n# Create the sector\nfig, ax = plt.subplots(1, 2, figsize=(12, 6))\n\n# Plot the original sector\nsector = Wedge(\n    (0, 0), r, 0, np.degrees(theta), facecolor=\"lightblue\", edgecolor=\"black\"\n)\nax[0].add_patch(sector)\nax[0].set_xlim(-0.1, r * 1.2)\nax[0].set_ylim(-0.1, l)\nax[0].set_aspect(\"equal\", \"box\")\nax[0].set_title(\"Original Sector\")\n\n# Divide the sector into four parts\nangles = np.linspace(0, theta, divide_num+1)\nfor i in range(divide_num):\n    wedge = Wedge(\n        (0, 0),\n        r,\n        np.degrees(angles[i]),\n        np.degrees(angles[i + 1]),\n        facecolor=\"none\",\n        edgecolor=\"black\",\n    )\n    ax[0].add_patch(wedge)\n\n# Rearrange the parts into a parallelogram\n\n# Create the parallelogram by shifting the parts\nfor i in range(divide_num):\n    if i % 2 == 0:\n        sector = Wedge(\n            (0, np.sin(theta / divide_num) * (i // 2)), r, 0, np.degrees(theta / divide_num), facecolor=\"lightblue\", edgecolor=\"black\"\n        )\n    else:\n        sector = Wedge(\n            (np.cos(theta / divide_num), np.sin(theta / divide_num) * (i // 2 + 1 )),\n            r,\n            np.degrees(np.pi),\n            np.degrees(theta / divide_num + np.pi),\n            facecolor=\"lightblue\",\n            edgecolor=\"black\",\n        )\n    ax[1].add_patch(sector)\n    \n\n# add info\nax[1].text(1.01, l/4, f\"Height = $l/2$\", horizontalalignment=\"left\")\n\nax[1].set_xlim(-0.1, r * 1.2)\nax[1].set_ylim(-0.1, l)\nax[1].set_aspect(\"equal\", \"box\")\nax[1].set_title(\"Rearranged into Parallelogram\")\n\nplt.show()\n\n\n\n\n\n\n\n\n\n上の図では４分割ですが，これを細かくすると横の長さ \\(r\\), 縦の長さ \\(l/2\\) の長方形へ変形することができるとみなせるので\n\\[\nS = \\frac{l}{2}r\n\\]\nと計算することが出来ます．半径 \\(r\\), 弧の長さ \\(l = 2\\pi r\\) のとき，扇形は円になりますが，その円の面積も同様に\n\\[\nS = \\frac{2\\pi r}{2}r = r^2 \\pi\n\\]\nと計算でき，円の面積の公式と一致することがわかります\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom matplotlib.patches import Wedge, Polygon\n\n# Parameters\nr = 2  # radius\nl = 2*np.pi * r  # arc length\n\n# Calculate the angle of the sector\ntheta = l / r  # in radians\ndivide_num = 100\n\n# Create the sector\nfig, ax = plt.subplots(1, 2, figsize=(12, 6))\n\n# Plot the original sector\nsector = Wedge(\n    (0, 0), r, 0, np.degrees(theta), facecolor=\"lightblue\", edgecolor=\"black\"\n)\nax[0].add_patch(sector)\nax[0].set_xlim(-r * 1.2, r * 1.2)\nax[0].set_ylim(-r * 1.2, r * 1.2)\nax[0].set_aspect(\"equal\", \"box\")\nax[0].set_title(\"Original Sector\")\n\n# Divide the sector into four parts\nangles = np.linspace(0, theta, divide_num+1)\nfor i in range(divide_num):\n    wedge = Wedge(\n        (0, 0),\n        r,\n        np.degrees(angles[i]),\n        np.degrees(angles[i + 1]),\n        facecolor=\"none\",\n        edgecolor=\"black\",\n    )\n    ax[0].add_patch(wedge)\n\n# Rearrange the parts into a parallelogram\n\n# Create the parallelogram by shifting the parts\nfor i in range(divide_num):\n    if i % 2 == 0:\n        sector = Wedge(\n            (0, np.sin(theta / divide_num) * (i // 2)* r), r, 0, np.degrees(theta / divide_num), facecolor=\"lightblue\", edgecolor=\"black\"\n        )\n    else:\n        sector = Wedge(\n            (np.cos(theta / divide_num)* r, np.sin(theta / divide_num) * r * (i // 2 + 1 )),\n            r,\n            np.degrees(np.pi),\n            np.degrees(theta / divide_num + np.pi),\n            facecolor=\"lightblue\",\n            edgecolor=\"black\",\n        )\n    ax[1].add_patch(sector)\n    \n\n# add info\nax[1].text(r + 0.01, l/4, f\"Height = $r\\pi$\", horizontalalignment=\"left\")\n\nax[1].set_xlim(-0.5, r * 1.2)\nax[1].set_ylim(-0.5, l/2 * 1.05)\nax[1].set_aspect(\"equal\", \"box\")\nax[1].set_title(\"Rearranged into Parallelogram\")\n\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n半径 \\(2\\), 弧の長さが \\(\\displaystyle L = \\frac{2}{3}\\pi\\) の扇形から，半径 \\(2/3\\), 弧の長さが \\(\\displaystyle l = \\frac{2}{9}\\pi\\) の扇形を除いたパイン形を考えます．このパイン形に対して，「分割交互ずらし」を適用して極限を取ると，底辺の長さ \\(\\displaystyle \\frac{4}{3}\\)，高さ\n\\[\n\\text{height} = \\frac{l + L}{2} = \\frac{4}{9}\\pi\n\\]\nの長方形へ収束します．このとき，このパイン型の面積は\n\\[\nS = \\frac{l + L}{2}\\times \\frac{4}{3} = \\frac{16}{27}\\pi\n\\]\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom shapely.geometry import Polygon\nfrom shapely.affinity import translate\nfrom shapely.ops import unary_union\nfrom shapely.affinity import rotate\nimport geopandas as gpd\n\n\ndef create_sector(center, radius, angle_start, angle_end, num_points=100):\n    \"\"\"Creates a sector shape as a polygon using Shapely.\"\"\"\n    angles = np.linspace(np.radians(angle_start), np.radians(angle_end), num_points)\n    outer_arc = [\n        (center[0] + radius * np.cos(a), center[1] + radius * np.sin(a)) for a in angles\n    ]\n    return Polygon([center] + outer_arc + [center])  # Close the polygon\n\n\n# Parameters\ndivide_num = 20\nring_sector_list = []\nouter_radius = 2\nangle = 60 / divide_num\n\nfor i in range(divide_num):\n    center = (0, 0)\n    inner_radius = outer_radius / 3\n    angle_start, angle_end = angle * i, angle * (i + 1)  # Angle in degrees\n\n    # Create outer and inner sectors\n    outer_sector = create_sector(center, outer_radius, angle_start, angle_end)\n    inner_sector = create_sector(center, inner_radius, angle_start, angle_end)\n\n    # Subtract inner sector from outer sector to get the ring shape\n    ring_sector = outer_sector.difference(inner_sector)\n    ring_sector_list.append(ring_sector)\n\n\n# plot\nfig, ax = plt.subplots(1, 2, figsize=(12, 6))\n\nfor ring_sector in ring_sector_list:\n    # Plot using GeoPandas\n    gdf = gpd.GeoSeries([ring_sector])\n    gdf.plot(ax=ax[0], color=\"lightblue\", edgecolor=\"black\")\n\n# Formatting\nax[0].set_xlim(-0.05, outer_radius + 0.1)\nax[0].set_ylim(-0.05, outer_radius + 0.1)\n\ngdf = gpd.GeoSeries([ring_sector_list[0]])\nrotated_gdf = gpd.GeoSeries(rotate(ring_sector_list[0], 180, origin=\"center\"))\nfor i in range(len(ring_sector_list)):\n    # Plot using GeoPandas\n    if i % 2 == 0:\n        gdf_tmp = gdf.apply(\n            lambda geom: translate(\n                geom, xoff=-2/3, yoff=np.sin(np.radians(angle))*8/3 * (i//2)\n            )\n        )\n        gdf_tmp.plot(ax=ax[1], color=\"lightblue\", edgecolor=\"black\")\n    else:\n        gdf_tmp = rotated_gdf.apply(\n            lambda geom: translate(\n                geom, xoff=-2/3, yoff=np.sin(np.radians(angle))*2/3 * (i//2 + 1) + np.sin(np.radians(angle))*6/3 * (i//2)\n            ))\n        gdf_tmp.plot(ax=ax[1], color=\"lightblue\", edgecolor=\"black\")\n\n\nplt.show()"
  },
  {
    "objectID": "posts/2025-02-28-cavalieri-principle/index.html#線分の運動とずらし面積",
    "href": "posts/2025-02-28-cavalieri-principle/index.html#線分の運動とずらし面積",
    "title": "カバリエリの原理",
    "section": "線分の運動とずらし面積",
    "text": "線分の運動とずらし面積\n野球グラウンドをならすときトンボという道具を使ったりします．このトンボを引きづる用な形でグラウンドを適当に歩くと，トンボがなす線分がグラウンドを通過することで図形が出来ます． 線分の運動の観点から，この図形の面積を求める方法をここでは紹介します．\n\n\nCode\nfrom scipy import interpolate\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nN = 1000\n\nx = np.linspace(0, 5, N)\n\ny = (\n    np.sin(x)\n    + np.cos(x ** 2) / 10\n)\n\ndydx = np.cos(x) - (2 / 10) * np.sin(x ** 2) * x\ndydx = np.where(abs(dydx) &gt; 1e-10, dydx, 0)\n\n\nupper_x = []\nupper_y = []\nlower_x = []\nlower_y = []\n\nfor i in range(N):\n    if dydx[i] &lt; 0:\n        dy = abs(1/dydx[i])\n        dist = np.sqrt(dy**2 + 1) * 10\n        dx = 1 / dist\n        dy = dy / dist\n    elif dydx[i] &gt; 0:\n        dy = abs(1/dydx[i])\n        dist = np.sqrt(dy**2 + 1)  * 10\n        dx = -1/ dist\n        dy = dy / dist\n    else:\n        dx, dy = (0, 1 / 10)\n    \n    upper_y.append(y[i] + dy)\n    upper_x.append(x[i] + dx)\n    lower_y.append(y[i] - dy)\n    lower_x.append(x[i] - dx)\n\nfig, ax = plt.subplots()\n\nax.plot(x, y, label = 'Trajectory of the center point')\nax.plot(upper_x, upper_y, color='gray', linestyle='--')\nax.plot(lower_x, lower_y, color='gray', linestyle='--')\n\nax.set_aspect('equal', 'box')  # Ensure the x and y axes have the same ratio\n\nax.set_title(\"Trajectory of a bar with length 0.2\")\n\nplt.legend()\nplt.show()\n\n\n\n\n\n\n\n\n\n一般に，大きさのある物体（剛体という）の運動は，「並進運動」と「回転運動」の合成で表されます．長さ \\(0.2\\) のトンボがグラウンドを並進運動と回転運動で通過する際に描かれる図形をplotしたものが上の図となります． 灰色の点線がそれぞれトンボの両端の軌跡を描いており，青の実線がトンボの中心点の軌跡となります．トンボがならしたグラウンドの面積は灰色で囲まれたエリアとなります．\n ▶  shapely.Polygonを用いた面積の計算\n上記で中心点の軌跡から両端の軌跡の座標を計算してあるので，それらを用いて shapely.Polygon をまず定義します．\n\n\nCode\n# shapely.Polygonの設定\npolygon_coords = list(zip(upper_x, upper_y)) + list(zip(lower_x[::-1], lower_y[::-1]))\npolygon = Polygon(polygon_coords)\n\n# Plot the polygon\nfig, ax = plt.subplots()\nx, y = polygon.exterior.xy\nax.plot(x, y, color='black')\nax.fill(x, y, color='lightblue', alpha=0.5)\nax.set_title(\"Shapely Polygon from Upper and Lower Coordinates\")\nax.set_aspect('equal', 'box')  # Ensure the x and y axes have the same ratio\nplt.show()\n\n\n\n\n\n\n\n\n\nその後，Polygon によって定義された図形の面積を計算すれば良いので\n\n\nCode\npolygon.area\n\n\n1.2470071445781767\n\n\n ▶  曲線の長さの公式と線分の移動\n詳しい説明はのちの機会としますが，線分が履く面積は\n\\[\n\\text{線分がはく面積} = \\text{中点の移動距離} \\times \\text{線分の長さ}\n\\]\nで計算することが出来ます．線分の長さは \\(0.2\\) とわかっているので，「中点の移動距離」を求めれば面積が求まりそうなことがわかります．\n\n\nTheorem 2 : 曲線の長さ \n\\(y=f(x)\\) で表される曲線の \\(x \\in [a, b]\\) の部分の長さ \\(L\\) は，\n\\[\nL = \\int^b_a \\sqrt{1 + f^\\prime(x)^2} dx\n\\]\n​（ただし，\\(f(x)\\) は微分可能で \\(f^\\prime(x)\\) は連続とする）\n\n\n点 \\(x\\) から\\(\\Delta x\\) 動いたとき，\\(\\Delta y \\approx f^\\prime(x)\\Delta x\\) 動くことから，その区間での曲線の長さは\n\\[\n\\sqrt{(\\Delta x)^2 + (f^\\prime(x)\\Delta x)^2} = \\sqrt{1 + f^\\prime(x)^2}\\Delta x\n\\]\nで近似できます．従って，\\(\\Delta x \\to dx\\) と極限を取ることで\n\\[\nL = \\int^b_a \\sqrt{1 + f^\\prime(x)^2} dx\n\\]\nと理解することが出来ます．\n今回の曲線 \\(f(x)\\) は \\([0, 5]\\) 区間で以下のように記述することができるとします．\n\\[\nf(x) =  \\sin(x) + 0.1\\cos(x^2)\n\\]\nこのとき，\\(f(x)\\) の1次導関数は\n\\[\nf^\\prime(x) = \\cos(x) - 0.2 x \\sin(x^2)\n\\]\n従って，曲線の公式より\n\\[\nL = \\int^5_0 \\sqrt{1 +  \\cos^2(x) + 0.04 x^2 \\sin^2(x^2) - 0.4x\\cos(x)\\sin(x^2)}dx\n\\]\nscipy.integrate.quad を用いて数値計算すると\n\n\nCode\nfrom scipy.integrate import quad\n\n\ndef curve_length(x):\n    return np.sqrt(\n        np.cos(x) ** 2\n        + 1 / 25 * np.sin(x**2) ** 2 * x**2\n        - 2 / 5 * np.cos(x) * np.sin(x**2) * x\n        + 1\n    )\n\n\nprint(quad(curve_length, 0, 5)[0] * 0.2)\n\n\n1.24703476690297\n\n\nshapely.Polygon を用いた計算結果と近しい値であることから計算結果の妥当性をうかがい知ることができます．"
  },
  {
    "objectID": "posts/2025-09-12-kernel-function/index.html",
    "href": "posts/2025-09-12-kernel-function/index.html",
    "title": "代表的なカーネル関数",
    "section": "",
    "text": "Noteカーネル関数例\n\n\n\n\\[\n\\begin{align}\n\\text{Gaussian kernel: } & k(u) = \\frac{1}{\\sqrt{2\\pi}}\\exp\\left(-\\frac{u^2}{2}\\right)\\\\\n\\text{Epanechnikov kernel: } & k(u) = \\frac{3}{4}(1 - u^2)\\mathbf I\\{|u| \\leq 1\\} = \\frac{3}{4}\\max\\{1 - u^2, 0\\}\\\\\n\\text{Biweight kernel: } & k(u) = \\frac{15}{16}(1 - u^2)^2\\mathbf I\\{|u| \\leq 1\\}\\\\\n\\text{Uniform kernel: } & k(u) = \\frac{1}{2}\\mathbf I\\{|u| \\leq 1\\}\\\\[5pt]\n\\text{Triangular kernel: } & k(u) = (1 - |u|)\\mathbf I\\{|u| \\leq 1\\}\n\\end{align}\n\\]\n\n\n上記のカーネル関数は以下のような特徴があります\n\n\\(K(u)\\) is symmetric\n\\(\\int k(u)du = 1\\): KDEで推定された関数が密度関数であるための必要条件\n\\(\\lim_{u\\to\\infty}k(u) = \\lim_{u\\to-\\infty}k(u) = 0\\)\n\n\n\nカーネル密度関数推定量を\n\\[\n\\hat f(x) = \\frac{1}{nh}\\sum_{i=1}^n k\\left(\\frac{X_i - x}{h}\\right)\n\\]\nとして，それぞれのカーネル関数を用いた推定結果を以下可視化します．\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nfrom sklearn.neighbors import KernelDensity\n\n# okabe-ito color\ncolor = [\n    \"#E69F00\",\n    \"#56B4E9\",\n    \"#009E73\",\n    \"#F0E442\",\n    \"#0072B2\",\n    \"#D55E00\",\n    \"#CC79A7\",\n    \"#000000\",\n]\n\n\n# Gaussian kernel function\ndef gaussian_kernel(u):\n    return (1 / np.sqrt(2 * np.pi)) * np.exp(-0.5 * u**2)\n\n\ndef epanechnikov_kernel(u):\n    const = 3 / 4\n    return const * (1 - u**2) * (np.abs(u) &lt;= 1).astype(float)\n\n\ndef biweight_kernel(u):\n    const = 15 / 16\n    return const * ((1 - u**2) ** 2) * (np.abs(u) &lt;= 1).astype(float)\n\n\ndef uniform_kernel(u):\n    return 0.5 * (np.abs(u) &lt;= 1).astype(float)\n\n\ndef triangular_kernel(u):\n    return (1 - np.abs(u)) * (np.abs(u) &lt;= 1).astype(float)\n\n\n# KDE\ndef kde(x, data, bandwidth, kernel_func):\n    n = len(data)\n    return (1 / (n * bandwidth)) * np.sum(kernel_func((x - data) / bandwidth))\n\n\n# Load Old Faithful dataset (from seaborn)\ndata = sns.load_dataset(\"geyser\")  # modern version of faithful dataset\nwaiting = data[\"waiting\"].dropna().values\n\n# Plot kernels\nu = np.linspace(-3, 3, 200)\nx_plot = np.linspace(40, 100, 1000)\nfig, axes = plt.subplots(5, 2, figsize=(16, 6 * 5))\n\n# gaussian\nkde_vals = list(map(lambda x: kde(x, waiting, 0.5, gaussian_kernel), x_plot))\naxes[0, 0].plot(u, gaussian_kernel(u), color[0], lw=2)\naxes[0, 0].set_ylabel(\"value\", fontsize=12)\naxes[0, 0].set_title(\"Gaussian Kernel\", fontsize=14)\naxes[0, 1].plot(x_plot, kde_vals, color[1], lw=1)\naxes[0, 1].set_ylabel(\"Density\", fontsize=12)\naxes[0, 1].set_xlabel(\"geyser$waiting\", fontsize=12)\naxes[0, 1].set_title(\"Gaussian KDE with bandwidth: 0.5\", fontsize=14)\n\n\n# epanechnikov\nkde_vals = list(map(lambda x: kde(x, waiting, 2, epanechnikov_kernel), x_plot))\naxes[1, 0].plot(u, epanechnikov_kernel(u), color[0], lw=2)\naxes[1, 0].set_ylabel(\"value\", fontsize=12)\naxes[1, 0].set_title(\"Epanechnikov Kernel\", fontsize=14)\naxes[1, 1].plot(x_plot, kde_vals, color[1], lw=1)\naxes[1, 1].set_ylabel(\"Density\", fontsize=12)\naxes[1, 1].set_xlabel(\"geyser$waiting\", fontsize=12)\naxes[1, 1].set_title(\"Epanechnikov KDE with bandwidth: 2\", fontsize=14)\n\n# Biweight\nkde_vals = list(map(lambda x: kde(x, waiting, 1, biweight_kernel), x_plot))\naxes[2, 0].plot(u, biweight_kernel(u), color[0], lw=2)\naxes[2, 0].set_ylabel(\"value\", fontsize=12)\naxes[2, 0].set_title(\"Biweight Kernel\", fontsize=14)\naxes[2, 1].plot(x_plot, kde_vals, color[1], lw=1)\naxes[2, 1].set_ylabel(\"Density\", fontsize=12)\naxes[2, 1].set_xlabel(\"geyser$waiting\", fontsize=12)\naxes[2, 1].set_title(\"Biweight KDE with bandwidth: 2\", fontsize=14)\n\n# Uniform\nkde_vals = list(map(lambda x: kde(x, waiting, 0.5, uniform_kernel), x_plot))\naxes[3, 0].plot(u, uniform_kernel(u), color[0], lw=2)\naxes[3, 0].set_ylabel(\"value\", fontsize=12)\naxes[3, 0].set_title(\"uniform Kernel\", fontsize=14)\naxes[3, 1].plot(x_plot, kde_vals, color[1], lw=1)\naxes[3, 1].set_ylabel(\"Density\", fontsize=12)\naxes[3, 1].set_xlabel(\"geyser$waiting\", fontsize=12)\naxes[3, 1].set_title(\"uniform KDE with bandwidth: 0.5\", fontsize=14)\n\n# Triangular\nkde_vals = list(map(lambda x: kde(x, waiting, 1.0, triangular_kernel), x_plot))\naxes[4, 0].plot(u, triangular_kernel(u), color[0], lw=2)\naxes[4, 0].set_ylabel(\"value\", fontsize=12)\naxes[4, 0].set_title(\"Triangular Kernel\", fontsize=14)\naxes[4, 1].plot(x_plot, kde_vals, color[1], lw=1)\naxes[4, 1].set_ylabel(\"Density\", fontsize=12)\naxes[4, 1].set_xlabel(\"geyser$waiting\", fontsize=12)\naxes[4, 1].set_title(\"Triangular KDE with bandwidth: 1.0\", fontsize=14)\n\nplt.show()"
  },
  {
    "objectID": "posts/2025-09-12-kernel-function/index.html#代表的なカーネル",
    "href": "posts/2025-09-12-kernel-function/index.html#代表的なカーネル",
    "title": "代表的なカーネル関数",
    "section": "",
    "text": "Noteカーネル関数例\n\n\n\n\\[\n\\begin{align}\n\\text{Gaussian kernel: } & k(u) = \\frac{1}{\\sqrt{2\\pi}}\\exp\\left(-\\frac{u^2}{2}\\right)\\\\\n\\text{Epanechnikov kernel: } & k(u) = \\frac{3}{4}(1 - u^2)\\mathbf I\\{|u| \\leq 1\\} = \\frac{3}{4}\\max\\{1 - u^2, 0\\}\\\\\n\\text{Biweight kernel: } & k(u) = \\frac{15}{16}(1 - u^2)^2\\mathbf I\\{|u| \\leq 1\\}\\\\\n\\text{Uniform kernel: } & k(u) = \\frac{1}{2}\\mathbf I\\{|u| \\leq 1\\}\\\\[5pt]\n\\text{Triangular kernel: } & k(u) = (1 - |u|)\\mathbf I\\{|u| \\leq 1\\}\n\\end{align}\n\\]\n\n\n上記のカーネル関数は以下のような特徴があります\n\n\\(K(u)\\) is symmetric\n\\(\\int k(u)du = 1\\): KDEで推定された関数が密度関数であるための必要条件\n\\(\\lim_{u\\to\\infty}k(u) = \\lim_{u\\to-\\infty}k(u) = 0\\)\n\n\n\nカーネル密度関数推定量を\n\\[\n\\hat f(x) = \\frac{1}{nh}\\sum_{i=1}^n k\\left(\\frac{X_i - x}{h}\\right)\n\\]\nとして，それぞれのカーネル関数を用いた推定結果を以下可視化します．\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nfrom sklearn.neighbors import KernelDensity\n\n# okabe-ito color\ncolor = [\n    \"#E69F00\",\n    \"#56B4E9\",\n    \"#009E73\",\n    \"#F0E442\",\n    \"#0072B2\",\n    \"#D55E00\",\n    \"#CC79A7\",\n    \"#000000\",\n]\n\n\n# Gaussian kernel function\ndef gaussian_kernel(u):\n    return (1 / np.sqrt(2 * np.pi)) * np.exp(-0.5 * u**2)\n\n\ndef epanechnikov_kernel(u):\n    const = 3 / 4\n    return const * (1 - u**2) * (np.abs(u) &lt;= 1).astype(float)\n\n\ndef biweight_kernel(u):\n    const = 15 / 16\n    return const * ((1 - u**2) ** 2) * (np.abs(u) &lt;= 1).astype(float)\n\n\ndef uniform_kernel(u):\n    return 0.5 * (np.abs(u) &lt;= 1).astype(float)\n\n\ndef triangular_kernel(u):\n    return (1 - np.abs(u)) * (np.abs(u) &lt;= 1).astype(float)\n\n\n# KDE\ndef kde(x, data, bandwidth, kernel_func):\n    n = len(data)\n    return (1 / (n * bandwidth)) * np.sum(kernel_func((x - data) / bandwidth))\n\n\n# Load Old Faithful dataset (from seaborn)\ndata = sns.load_dataset(\"geyser\")  # modern version of faithful dataset\nwaiting = data[\"waiting\"].dropna().values\n\n# Plot kernels\nu = np.linspace(-3, 3, 200)\nx_plot = np.linspace(40, 100, 1000)\nfig, axes = plt.subplots(5, 2, figsize=(16, 6 * 5))\n\n# gaussian\nkde_vals = list(map(lambda x: kde(x, waiting, 0.5, gaussian_kernel), x_plot))\naxes[0, 0].plot(u, gaussian_kernel(u), color[0], lw=2)\naxes[0, 0].set_ylabel(\"value\", fontsize=12)\naxes[0, 0].set_title(\"Gaussian Kernel\", fontsize=14)\naxes[0, 1].plot(x_plot, kde_vals, color[1], lw=1)\naxes[0, 1].set_ylabel(\"Density\", fontsize=12)\naxes[0, 1].set_xlabel(\"geyser$waiting\", fontsize=12)\naxes[0, 1].set_title(\"Gaussian KDE with bandwidth: 0.5\", fontsize=14)\n\n\n# epanechnikov\nkde_vals = list(map(lambda x: kde(x, waiting, 2, epanechnikov_kernel), x_plot))\naxes[1, 0].plot(u, epanechnikov_kernel(u), color[0], lw=2)\naxes[1, 0].set_ylabel(\"value\", fontsize=12)\naxes[1, 0].set_title(\"Epanechnikov Kernel\", fontsize=14)\naxes[1, 1].plot(x_plot, kde_vals, color[1], lw=1)\naxes[1, 1].set_ylabel(\"Density\", fontsize=12)\naxes[1, 1].set_xlabel(\"geyser$waiting\", fontsize=12)\naxes[1, 1].set_title(\"Epanechnikov KDE with bandwidth: 2\", fontsize=14)\n\n# Biweight\nkde_vals = list(map(lambda x: kde(x, waiting, 1, biweight_kernel), x_plot))\naxes[2, 0].plot(u, biweight_kernel(u), color[0], lw=2)\naxes[2, 0].set_ylabel(\"value\", fontsize=12)\naxes[2, 0].set_title(\"Biweight Kernel\", fontsize=14)\naxes[2, 1].plot(x_plot, kde_vals, color[1], lw=1)\naxes[2, 1].set_ylabel(\"Density\", fontsize=12)\naxes[2, 1].set_xlabel(\"geyser$waiting\", fontsize=12)\naxes[2, 1].set_title(\"Biweight KDE with bandwidth: 2\", fontsize=14)\n\n# Uniform\nkde_vals = list(map(lambda x: kde(x, waiting, 0.5, uniform_kernel), x_plot))\naxes[3, 0].plot(u, uniform_kernel(u), color[0], lw=2)\naxes[3, 0].set_ylabel(\"value\", fontsize=12)\naxes[3, 0].set_title(\"uniform Kernel\", fontsize=14)\naxes[3, 1].plot(x_plot, kde_vals, color[1], lw=1)\naxes[3, 1].set_ylabel(\"Density\", fontsize=12)\naxes[3, 1].set_xlabel(\"geyser$waiting\", fontsize=12)\naxes[3, 1].set_title(\"uniform KDE with bandwidth: 0.5\", fontsize=14)\n\n# Triangular\nkde_vals = list(map(lambda x: kde(x, waiting, 1.0, triangular_kernel), x_plot))\naxes[4, 0].plot(u, triangular_kernel(u), color[0], lw=2)\naxes[4, 0].set_ylabel(\"value\", fontsize=12)\naxes[4, 0].set_title(\"Triangular Kernel\", fontsize=14)\naxes[4, 1].plot(x_plot, kde_vals, color[1], lw=1)\naxes[4, 1].set_ylabel(\"Density\", fontsize=12)\naxes[4, 1].set_xlabel(\"geyser$waiting\", fontsize=12)\naxes[4, 1].set_title(\"Triangular KDE with bandwidth: 1.0\", fontsize=14)\n\nplt.show()"
  },
  {
    "objectID": "posts/2025-03-05-addition-theorem/index.html",
    "href": "posts/2025-03-05-addition-theorem/index.html",
    "title": "三角関数の加法定理",
    "section": "",
    "text": "Theorem 1 : 加法定理 \n\\[\n\\begin{align}\n\\sin (\\alpha + \\beta) &= \\sin \\alpha \\cos \\beta + \\cos \\alpha \\sin \\beta\\\\\n\\cos (\\alpha + \\beta) &= \\cos \\alpha \\cos \\beta - \\sin \\alpha \\sin \\beta\n\\end{align}\n\\]\n\n\n「咲いたコスモス，コスモス咲いた」なり「しこってこすってこすってしこって」と語呂合わせで加法定理を覚えたりしますが，ここでは加法定理を図形的に考えてみたいと思います．\n\n\n\n\n\n\nFigure 1\n\n\n\nFigure 1 のように半径 \\(1\\) の単位円周上に \\(\\angle DOB = \\alpha + \\beta\\) となる点 \\(B\\) をとります． 同じく \\(\\angle AOD = \\alpha\\) となるように点をとると，\\(\\angle BOA = \\beta\\) となります．このとき，点 \\(B\\) の \\(y\\) 成分は \\(\\sin(\\alpha + \\beta)\\) となります．\n点 \\(B\\) から直線 \\(OA\\) 上に垂線を下ろし，その交点を \\(C\\) とすると \\(OB = 1\\) より\n\\[\n\\begin{align}\nBC & = \\sin\\beta\\\\\nOC &= \\cos\\beta\n\\end{align}\n\\]\nとなることがわかります．点 \\(C\\) から垂線を下ろし，\\(x\\) 軸との交点を \\(E\\), \\(B\\) から直線 \\(CE\\) との交点を \\(F\\) とすると\n\\[\n\\begin{align}\nCE &= \\sin \\alpha\\cos\\beta\\\\\nCF &= \\cos\\alpha\\sin\\beta\n\\end{align}\n\\]\nしたがって，\\(CE + CF = \\sin(\\alpha + \\beta)\\) となることから\n\\[\n\\sin (\\alpha + \\beta) = \\sin \\alpha \\cos \\beta + \\cos \\alpha \\sin \\beta\n\\]\nとなることが図形的にわかります．同様に\n\\[\n\\begin{align}\nOE &= \\cos\\alpha\\cos\\beta\\\\\nBF&= \\sin\\alpha\\sin\\beta\n\\end{align}\n\\]\nより\n\\[\n\\cos(\\alpha + \\beta) = OE - BF = \\cos\\alpha\\cos\\beta - \\sin\\alpha\\sin\\beta\n\\]\n ▶  ２角の差 \\(\\alpha - \\beta\\) の場合\n\\(\\sin(-\\beta) = -\\sin(\\beta)\\) および \\(\\cos(-\\beta) = \\cos\\beta\\) より\n\\[\n\\begin{align}\n\\sin (\\alpha - \\beta)\n    &= \\sin (\\alpha  + (-\\beta))\\\\\n    &= \\sin \\alpha \\cos (-\\beta) + \\cos \\alpha \\sin (-\\beta)\\\\\n    &= \\sin \\alpha \\cos \\beta - \\cos \\alpha \\sin \\beta\n\\end{align}\n\\]\n同様に\n\\[\n\\begin{align}\n\\cos (\\alpha - \\beta)\n    &= \\cos (\\alpha  + (-\\beta))\\\\\n    &= \\cos \\alpha \\cos (-\\beta) - \\sin \\alpha \\sin (-\\beta)\\\\\n    &= \\cos \\alpha \\cos \\beta + \\sin \\alpha \\sin \\beta\n\\end{align}\n\\]\n以上より\n\\[\n\\begin{align}\n\\sin (\\alpha \\pm \\beta) &= \\sin \\alpha \\cos \\beta \\pm \\cos \\alpha \\sin \\beta\\\\\n\\cos (\\alpha \\pm \\beta) &= \\cos \\alpha \\cos \\beta \\mp \\sin \\alpha \\sin \\beta\n\\end{align}\n\\]\n\n📘 REMARKS \n\\(\\sin \\theta\\) は奇関数，\\(\\cos \\theta\\) は偶関数であることに留意すると\n\\[\n\\begin{align}\n\\text{奇関数} \\times \\text{偶関数} &= \\text{奇関数}\\\\\n\\text{偶関数} \\times \\text{偶関数} &= \\text{偶関数}\\\\\n\\text{偶関数} + \\text{偶関数} &= \\text{偶関数}\\\\\n\\text{奇関数} + \\text{奇関数} &= \\text{奇関数}\n\\end{align}\n\\]\nであるので，加法定理のRHSとLHSがそれぞれ対応していることがわかります．\n\n\n\n\n\nTheorem 2 : オイラーの公式 \n\\[\n\\exp(i\\theta) = \\cos\\theta + i\\sin\\theta\n\\]\n\n\n\n\n\n\n\n\n\nNoteオイラーの公式を用いた加法定理の導出\n\n\n\n\n\n\\[\n\\begin{align}\n\\exp(i(\\alpha + \\beta))\n    &= \\exp(i\\alpha)\\exp(i\\beta)\\\\\n    &= (\\cos\\alpha + i\\sin\\alpha)(\\cos\\beta + i\\sin\\beta)\\\\\n    &= \\cos\\alpha\\cos\\beta - \\sin\\alpha\\sin\\beta + i(\\sin\\alpha\\cos\\beta + \\cos\\alpha\\sin\\beta)\n\\end{align}\n\\]\n\\(\\exp(i(\\alpha + \\beta)) = \\cos(\\alpha + \\beta) + i\\sin(\\alpha + \\beta)\\) であることから実部と虚部の比較より\n\\[\n\\begin{align}\n\\sin (\\alpha + \\beta) &= \\sin \\alpha \\cos \\beta + \\cos \\alpha \\sin \\beta\\\\\n\\cos (\\alpha + \\beta) &= \\cos \\alpha \\cos \\beta - \\sin \\alpha \\sin \\beta\n\\end{align}\n\\]\n二角の差の場合は\n\\[\n\\exp(i(\\alpha - \\beta))= \\exp(i\\alpha)\\exp(-i\\beta)\n\\]\nから同様に示すことが出来ます．\n\n\n\n\n\n\n\n\n\n\n\n\n\nNoteProof\n\n\n\n\n\n正弦と余弦の加法定理より\n\\[\n\\begin{align}\n\\tan(\\alpha \\pm \\beta)\n    &= \\frac{\\sin(\\alpha \\pm \\beta)}{\\cos(\\alpha \\pm \\beta)}\\\\\n    &= \\frac{\\sin \\alpha \\cos \\beta \\pm \\cos \\alpha \\sin \\beta}{\\cos \\alpha \\cos \\beta \\mp \\sin \\alpha \\sin \\beta}\n\\end{align}\n\\]\n分子と分母を \\(\\cos \\alpha \\cos \\beta\\) で割ると\n\\[\n\\begin{align}\n\\tan(\\alpha \\pm \\beta) = \\frac{\\tan \\alpha \\pm \\tan \\beta}{1 \\mp \\tan \\alpha \\tan \\beta}\n\\end{align}\n\\]\n\n\n\n\n\nExercise 1 \n\\(\\tan 1^\\circ\\) が無理数であることを示せ\n\n\n\n\n\n\n\n\n\nNoteSolution\n\n\n\n\n\n\\(\\tan 1^\\circ\\) がとある有理数 \\(a\\) であると仮定すると，加法定理より\n\\[\n\\tan 2^\\circ = \\frac{2a}{1 - a^2}\n\\]\nとなり，有理数の四則演算は有理数で閉じていることから \\(\\tan 2^\\circ\\) も有理数であることがわかる．同様に \\(4^\\circ, 8^\\circ, 16^\\circ, 32^\\circ\\) も有理数であることがわかる．\nここで，\n\\[\n\\tan 30^\\circ = \\frac{\\sqrt{3}}{3}\n\\]\nより \\(\\tan 30^\\circ\\) は無理数であることに着目する．一方，\\(\\tan 30^\\circ\\) は加法定理より\n\\[\n\\begin{align}\n\\tan 30^\\circ\n    &= \\tan (32^\\circ - 2^\\circ)\\\\\n    &= \\frac{\\tan 32^\\circ + \\tan 2^\\circ}{1 + \\tan 32^\\circ\\tan 2^\\circ}\n\\end{align}\n\\]\nこのとき，\\(\\tan 32^\\circ, \\tan 2^\\circ\\) はともに有理数であるので， \\(\\tan 30^\\circ\\) は無理数であることと矛盾． したがって，\\(\\tan 1^\\circ\\) は無理数である．"
  },
  {
    "objectID": "posts/2025-03-05-addition-theorem/index.html#加法定理",
    "href": "posts/2025-03-05-addition-theorem/index.html#加法定理",
    "title": "三角関数の加法定理",
    "section": "",
    "text": "Theorem 1 : 加法定理 \n\\[\n\\begin{align}\n\\sin (\\alpha + \\beta) &= \\sin \\alpha \\cos \\beta + \\cos \\alpha \\sin \\beta\\\\\n\\cos (\\alpha + \\beta) &= \\cos \\alpha \\cos \\beta - \\sin \\alpha \\sin \\beta\n\\end{align}\n\\]\n\n\n「咲いたコスモス，コスモス咲いた」なり「しこってこすってこすってしこって」と語呂合わせで加法定理を覚えたりしますが，ここでは加法定理を図形的に考えてみたいと思います．\n\n\n\n\n\n\nFigure 1\n\n\n\nFigure 1 のように半径 \\(1\\) の単位円周上に \\(\\angle DOB = \\alpha + \\beta\\) となる点 \\(B\\) をとります． 同じく \\(\\angle AOD = \\alpha\\) となるように点をとると，\\(\\angle BOA = \\beta\\) となります．このとき，点 \\(B\\) の \\(y\\) 成分は \\(\\sin(\\alpha + \\beta)\\) となります．\n点 \\(B\\) から直線 \\(OA\\) 上に垂線を下ろし，その交点を \\(C\\) とすると \\(OB = 1\\) より\n\\[\n\\begin{align}\nBC & = \\sin\\beta\\\\\nOC &= \\cos\\beta\n\\end{align}\n\\]\nとなることがわかります．点 \\(C\\) から垂線を下ろし，\\(x\\) 軸との交点を \\(E\\), \\(B\\) から直線 \\(CE\\) との交点を \\(F\\) とすると\n\\[\n\\begin{align}\nCE &= \\sin \\alpha\\cos\\beta\\\\\nCF &= \\cos\\alpha\\sin\\beta\n\\end{align}\n\\]\nしたがって，\\(CE + CF = \\sin(\\alpha + \\beta)\\) となることから\n\\[\n\\sin (\\alpha + \\beta) = \\sin \\alpha \\cos \\beta + \\cos \\alpha \\sin \\beta\n\\]\nとなることが図形的にわかります．同様に\n\\[\n\\begin{align}\nOE &= \\cos\\alpha\\cos\\beta\\\\\nBF&= \\sin\\alpha\\sin\\beta\n\\end{align}\n\\]\nより\n\\[\n\\cos(\\alpha + \\beta) = OE - BF = \\cos\\alpha\\cos\\beta - \\sin\\alpha\\sin\\beta\n\\]\n ▶  ２角の差 \\(\\alpha - \\beta\\) の場合\n\\(\\sin(-\\beta) = -\\sin(\\beta)\\) および \\(\\cos(-\\beta) = \\cos\\beta\\) より\n\\[\n\\begin{align}\n\\sin (\\alpha - \\beta)\n    &= \\sin (\\alpha  + (-\\beta))\\\\\n    &= \\sin \\alpha \\cos (-\\beta) + \\cos \\alpha \\sin (-\\beta)\\\\\n    &= \\sin \\alpha \\cos \\beta - \\cos \\alpha \\sin \\beta\n\\end{align}\n\\]\n同様に\n\\[\n\\begin{align}\n\\cos (\\alpha - \\beta)\n    &= \\cos (\\alpha  + (-\\beta))\\\\\n    &= \\cos \\alpha \\cos (-\\beta) - \\sin \\alpha \\sin (-\\beta)\\\\\n    &= \\cos \\alpha \\cos \\beta + \\sin \\alpha \\sin \\beta\n\\end{align}\n\\]\n以上より\n\\[\n\\begin{align}\n\\sin (\\alpha \\pm \\beta) &= \\sin \\alpha \\cos \\beta \\pm \\cos \\alpha \\sin \\beta\\\\\n\\cos (\\alpha \\pm \\beta) &= \\cos \\alpha \\cos \\beta \\mp \\sin \\alpha \\sin \\beta\n\\end{align}\n\\]\n\n📘 REMARKS \n\\(\\sin \\theta\\) は奇関数，\\(\\cos \\theta\\) は偶関数であることに留意すると\n\\[\n\\begin{align}\n\\text{奇関数} \\times \\text{偶関数} &= \\text{奇関数}\\\\\n\\text{偶関数} \\times \\text{偶関数} &= \\text{偶関数}\\\\\n\\text{偶関数} + \\text{偶関数} &= \\text{偶関数}\\\\\n\\text{奇関数} + \\text{奇関数} &= \\text{奇関数}\n\\end{align}\n\\]\nであるので，加法定理のRHSとLHSがそれぞれ対応していることがわかります．\n\n\n\n\n\nTheorem 2 : オイラーの公式 \n\\[\n\\exp(i\\theta) = \\cos\\theta + i\\sin\\theta\n\\]\n\n\n\n\n\n\n\n\n\nNoteオイラーの公式を用いた加法定理の導出\n\n\n\n\n\n\\[\n\\begin{align}\n\\exp(i(\\alpha + \\beta))\n    &= \\exp(i\\alpha)\\exp(i\\beta)\\\\\n    &= (\\cos\\alpha + i\\sin\\alpha)(\\cos\\beta + i\\sin\\beta)\\\\\n    &= \\cos\\alpha\\cos\\beta - \\sin\\alpha\\sin\\beta + i(\\sin\\alpha\\cos\\beta + \\cos\\alpha\\sin\\beta)\n\\end{align}\n\\]\n\\(\\exp(i(\\alpha + \\beta)) = \\cos(\\alpha + \\beta) + i\\sin(\\alpha + \\beta)\\) であることから実部と虚部の比較より\n\\[\n\\begin{align}\n\\sin (\\alpha + \\beta) &= \\sin \\alpha \\cos \\beta + \\cos \\alpha \\sin \\beta\\\\\n\\cos (\\alpha + \\beta) &= \\cos \\alpha \\cos \\beta - \\sin \\alpha \\sin \\beta\n\\end{align}\n\\]\n二角の差の場合は\n\\[\n\\exp(i(\\alpha - \\beta))= \\exp(i\\alpha)\\exp(-i\\beta)\n\\]\nから同様に示すことが出来ます．\n\n\n\n\n\n\n\n\n\n\n\n\n\nNoteProof\n\n\n\n\n\n正弦と余弦の加法定理より\n\\[\n\\begin{align}\n\\tan(\\alpha \\pm \\beta)\n    &= \\frac{\\sin(\\alpha \\pm \\beta)}{\\cos(\\alpha \\pm \\beta)}\\\\\n    &= \\frac{\\sin \\alpha \\cos \\beta \\pm \\cos \\alpha \\sin \\beta}{\\cos \\alpha \\cos \\beta \\mp \\sin \\alpha \\sin \\beta}\n\\end{align}\n\\]\n分子と分母を \\(\\cos \\alpha \\cos \\beta\\) で割ると\n\\[\n\\begin{align}\n\\tan(\\alpha \\pm \\beta) = \\frac{\\tan \\alpha \\pm \\tan \\beta}{1 \\mp \\tan \\alpha \\tan \\beta}\n\\end{align}\n\\]\n\n\n\n\n\nExercise 1 \n\\(\\tan 1^\\circ\\) が無理数であることを示せ\n\n\n\n\n\n\n\n\n\nNoteSolution\n\n\n\n\n\n\\(\\tan 1^\\circ\\) がとある有理数 \\(a\\) であると仮定すると，加法定理より\n\\[\n\\tan 2^\\circ = \\frac{2a}{1 - a^2}\n\\]\nとなり，有理数の四則演算は有理数で閉じていることから \\(\\tan 2^\\circ\\) も有理数であることがわかる．同様に \\(4^\\circ, 8^\\circ, 16^\\circ, 32^\\circ\\) も有理数であることがわかる．\nここで，\n\\[\n\\tan 30^\\circ = \\frac{\\sqrt{3}}{3}\n\\]\nより \\(\\tan 30^\\circ\\) は無理数であることに着目する．一方，\\(\\tan 30^\\circ\\) は加法定理より\n\\[\n\\begin{align}\n\\tan 30^\\circ\n    &= \\tan (32^\\circ - 2^\\circ)\\\\\n    &= \\frac{\\tan 32^\\circ + \\tan 2^\\circ}{1 + \\tan 32^\\circ\\tan 2^\\circ}\n\\end{align}\n\\]\nこのとき，\\(\\tan 32^\\circ, \\tan 2^\\circ\\) はともに有理数であるので， \\(\\tan 30^\\circ\\) は無理数であることと矛盾． したがって，\\(\\tan 1^\\circ\\) は無理数である．"
  },
  {
    "objectID": "posts/2025-03-05-addition-theorem/index.html#倍角の公式とサインカーブ",
    "href": "posts/2025-03-05-addition-theorem/index.html#倍角の公式とサインカーブ",
    "title": "三角関数の加法定理",
    "section": "倍角の公式とサインカーブ",
    "text": "倍角の公式とサインカーブ\n\n\nTheorem 3 : 倍角の公式 \n\\[\n\\begin{align}\n\\sin 2\\theta &= 2\\sin\\theta\\cos\\theta\\\\\n\\cos 2\\theta &= \\cos^2\\theta - \\sin^2\\theta\\\\\n             &= 1 - 2\\sin^2\\theta = 2\\cos^2\\theta - 1\\\\\n\\tan 2\\theta &= \\frac{2\\tan\\theta}{1 - \\tan^2\\theta}\n\\end{align}\n\\]\n\n\n\\(y = \\sin x\\) は振幅 \\(1\\) で周期 \\(2\\pi\\) の周期関数ですが，\n\\[\ny = \\alpha\\sin \\beta x \\quad \\alpha &gt; 0, \\beta &gt; 0\n\\]\nと変形すると，振幅 \\(\\alpha\\) で周期 \\(\\displaystyle \\frac{2\\pi}{\\beta}\\) の周期関数となります．\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport matplotlib.ticker as ticker\n\n# Define the x values\nx = np.linspace(-2 * np.pi, 2 * np.pi, 400)\n\n# Define the y values for both functions\ny1 = np.sin(x)\ny2 = np.sin(x / 2)\ny3 = 3 * np.sin(2 * x)\n\n# Create the plot\nplt.figure(figsize=(10, 6))\nplt.plot(x, y1, label=r\"$y = \\sin(x)$\", color=\"b\")\nplt.plot(x, y2, label=r\"$y = \\sin(x/2)$\", color=\"r\", linestyle=\"--\")\nplt.plot(x, y3, label=r\"$y = 3\\sin(2x)$\", color=\"gray\", linestyle=\"--\")\n\n# Add labels, title, and legend\nplt.xlabel(\"x\")\nplt.ylabel(\"y\")\nplt.title(\"Comparison of $y = \\sin(x)$ and $y = \\sin(x/2)$, $y = 3\\sin(2x)$\")\nplt.axhline(0, color=\"black\", linewidth=0.5)\nplt.axvline(0, color=\"black\", linewidth=0.5)\nplt.legend()\nplt.grid(True)\n\n# Set x-ticks to multiples of pi\nxticks = np.arange(-2 * np.pi, 2.5 * np.pi, np.pi / 2)\nxtick_labels = [\n    r\"$-2\\pi$\",\n    r\"$-\\frac{3\\pi}{2}$\",\n    r\"$-\\pi$\",\n    r\"$-\\frac{\\pi}{2}$\",\n    \"0\",\n    r\"$\\frac{\\pi}{2}$\",\n    r\"$\\pi$\",\n    r\"$\\frac{3\\pi}{2}$\",\n    r\"$2\\pi$\",\n]\nplt.xticks(xticks, xtick_labels)\n\n# Show the plot\nplt.show()\n\n\n\n\n\n\n\n\n\n次に，\\(y = \\sin x \\cos x\\) のグラフを考えてみます．加法定理より\n\\[\n\\begin{align}\n\\sin 2x\n    &= \\sin (x + x)\\\\\n    &= 2\\sin x\\cos x\n\\end{align}\n\\]\nであることから\n\\[\n\\sin x \\cos x = \\frac{1}{2}\\sin 2x\n\\]\nつまり，\\(y = \\sin x \\cos x\\) のグラフは振幅 \\(\\displaystyle \\frac{1}{2}\\)，周期 \\(\\pi\\) のサインカーブとなることがわかります．\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport matplotlib.ticker as ticker\n\n# Define the x values\nx = np.linspace(-2 * np.pi, 2 * np.pi, 400)\n\n# Define the y values for both functions\ny1 = np.sin(x) * np.cos(x)\ny2 = np.sin(2 * x) /2\n\n# Create the plot\nplt.figure(figsize=(10, 6))\nplt.plot(x, y1, label=r\"$y = \\sin(x)$\", color=\"b\")\nplt.plot(x, y2, label=r\"$y = \\frac{1}{2}\\sin(2x)$\", color=\"gray\", linestyle=\"--\")\n\n# Add labels, title, and legend\nplt.xlabel(\"x\")\nplt.ylabel(\"y\")\nplt.axhline(0, color=\"black\", linewidth=0.5)\nplt.axvline(0, color=\"black\", linewidth=0.5)\nplt.legend()\nplt.grid(True)\n\n# Set x-ticks to multiples of pi\nxticks = np.arange(-2 * np.pi, 2.5 * np.pi, np.pi / 2)\nxtick_labels = [\n    r\"$-2\\pi$\",\n    r\"$-\\frac{3\\pi}{2}$\",\n    r\"$-\\pi$\",\n    r\"$-\\frac{\\pi}{2}$\",\n    \"0\",\n    r\"$\\frac{\\pi}{2}$\",\n    r\"$\\pi$\",\n    r\"$\\frac{3\\pi}{2}$\",\n    r\"$2\\pi$\",\n]\nplt.xticks(xticks, xtick_labels)\n\n# Show the plot\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\nTheorem 4 : 半角の公式 \n\\[\n\\begin{align}\n\\sin^2 \\frac{\\theta}{2} &= \\frac{1 - \\cos\\theta}{2}\\\\\n\\cos^2 \\frac{\\theta}{2} &= \\frac{1 + \\cos\\theta}{2}\\\\\n\\tan^2 \\frac{\\theta}{2} &= \\frac{1 - \\cos\\theta}{1 + \\cos\\theta}\n\\end{align}\n\\]\n\n\n\nExample 1 \n\\(y = \\sin^2 x\\) について考えてみます．正弦関数は奇関数であるので，\\(\\sin^2 x\\) は偶関数になるはずです．半角の公式を用いると\n\\[\n\\sin^2 x = \\frac{1 - \\cos 2x}{2}\n\\]\nとなるので，振幅 \\(\\displaystyle\\frac{1}{2}\\), 周期 \\(\\pi\\) のコサインカーブを \\(\\displaystyle\\frac{1}{2}\\) 平行移動したものであることがわかります．\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport matplotlib.ticker as ticker\n\n# Define the x values\nx = np.linspace(-2 * np.pi, 2 * np.pi, 400)\n\n# Define the y values for both functions\ny1 = (1 - np.cos(2 * x))/2\ny2 = np.cos(2 * x)\n\n# Create the plot\nplt.figure(figsize=(8, 6))\nplt.plot(x, y1, label=r\"$y = \\sin^2(x)$\", color=\"b\")\nplt.plot(x, y2, label=r\"$y = \\cos(x)$\", color=\"gray\", linestyle=\"--\")\n\n# Add labels, title, and legend\nplt.xlabel(\"x\")\nplt.ylabel(\"y\")\nplt.axhline(0, color=\"black\", linewidth=0.5)\nplt.axvline(0, color=\"black\", linewidth=0.5)\nplt.legend( loc='lower right',)\nplt.grid(True)\n\n# Set x-ticks to multiples of pi\nxticks = np.arange(-2 * np.pi, 2.5 * np.pi, np.pi / 2)\nxtick_labels = [\n    r\"$-2\\pi$\",\n    r\"$-\\frac{3\\pi}{2}$\",\n    r\"$-\\pi$\",\n    r\"$-\\frac{\\pi}{2}$\",\n    \"0\",\n    r\"$\\frac{\\pi}{2}$\",\n    r\"$\\pi$\",\n    r\"$\\frac{3\\pi}{2}$\",\n    r\"$2\\pi$\",\n]\nplt.xticks(xticks, xtick_labels)\n\n\n# Show the plot\nplt.show()"
  },
  {
    "objectID": "posts/2025-03-05-addition-theorem/index.html#和積の公式",
    "href": "posts/2025-03-05-addition-theorem/index.html#和積の公式",
    "title": "三角関数の加法定理",
    "section": "和積の公式",
    "text": "和積の公式\n\n\nTheorem 5 : 正弦関数の和積の公式 \n\\[\n\\begin{align}\n\\sin \\alpha + \\sin\\beta &= 2 \\sin \\frac{\\alpha+\\beta}{2}\\cos \\frac{\\alpha-\\beta}{2}\\\\\n\\sin \\alpha - \\sin\\beta &= 2 \\cos \\frac{\\alpha+\\beta}{2}\\sin \\frac{\\alpha-\\beta}{2}\\\\\n\\cos \\alpha + \\cos\\beta &= 2 \\cos \\frac{\\alpha+\\beta}{2}\\cos \\frac{\\alpha-\\beta}{2}\\\\\n\\cos \\alpha - \\cos\\beta &= -2 \\sin \\frac{\\alpha+\\beta}{2}\\sin \\frac{\\alpha-\\beta}{2}\n\\end{align}\n\\]\n\n\n\n\n\n\n\n\n\nNoteProof\n\n\n\n\n\n加法定理より\n\\[\n\\begin{align}\n\\sin (\\gamma + \\delta)\n    &= \\sin\\gamma \\cos\\delta + \\cos\\gamma \\sin\\delta\\\\\n\\sin (\\gamma - \\delta)\n    &= \\sin\\gamma \\cos\\delta - \\cos\\gamma \\sin\\delta\n\\end{align}\n\\]\nこれを整理すると\n\\[\n\\begin{align}\n\\sin (\\gamma + \\delta) + \\sin (\\gamma - \\delta) &= 2\\sin\\gamma \\cos\\delta\\\\\n\\sin (\\gamma + \\delta) - \\sin (\\gamma - \\delta) &= 2\\cos\\gamma \\sin\\delta\n\\end{align}\n\\]\nここで，\\(\\gamma + \\delta = \\alpha, \\gamma - \\delta = \\beta\\) とおくと\n\\[\n\\begin{gather}\n\\gamma = \\frac{ \\alpha + \\beta}{2}, \\quad \\delta = \\frac{\\alpha - \\beta}{2}\n\\end{gather}\n\\]\nとなるので\n\\[\n\\begin{align}\n\\sin \\alpha + \\sin\\beta &= 2 \\sin \\frac{\\alpha+\\beta}{2}\\cos \\frac{\\alpha-\\beta}{2}\\\\\n\\sin \\alpha - \\sin\\beta &= 2 \\cos \\frac{\\alpha+\\beta}{2}\\sin \\frac{\\alpha-\\beta}{2}\n\\end{align}\n\\]\n余弦関数も同様に\n\\[\n\\begin{align}\n\\cos (\\gamma + \\delta)\n    &= \\cos\\gamma \\cos\\delta - \\sin\\gamma \\sin\\delta\\\\\n\\cos (\\gamma - \\delta)\n    &= \\cos\\gamma \\cos\\delta + \\sin\\gamma \\sin\\delta\n\\end{align}\n\\]\nであるので\n\\[\n\\begin{align}\n\\cos (\\gamma + \\delta) + \\cos (\\gamma - \\delta) &= 2\\cos\\gamma \\cos\\delta\\\\\n\\cos (\\gamma + \\delta) - \\cos (\\gamma - \\delta) &= -2\\sin\\gamma \\sin\\delta\n\\end{align}\n\\]\nから導くことができます．\n\n\n\n\nExample 2 \n\\(x + y + z = \\pi\\) を満たす実数 \\(x, y, z\\) について\n\\[\n\\sin x + \\sin y + \\sin z = 4 \\cos\\frac{x}{2}\\cos\\frac{y}{2}\\cos\\frac{z}{2}\n\\]\nが成り立ちます．LHSを式変形すると\n\\[\n\\begin{align}\n\\sin x + \\sin y + \\sin z\n    &= \\sin x + \\sin y + \\sin (\\pi - (x + y))\\\\\n    &= \\sin x + \\sin y + \\sin (x + y)\\\\\n    &= 2\\sin\\frac{x+y}{2}\\cos\\frac{x-y}{2} + 2\\sin\\frac{x+y}{2}\\cos\\frac{x+y}{2}\\\\\n    &= 2\\sin\\frac{x+y}{2}\\left(\\cos\\frac{x-y}{2} + \\cos\\frac{x+y}{2}\\right)\\\\\n    &= 2\\sin\\frac{x+y}{2}\\times 2\\cos\\frac{\\frac{x-y}{2} + \\frac{x-y}{2}}{2}\\cos\\frac{\\frac{x-y}{2} - \\frac{x-y}{2}}{2}\\\\\n    &=4\\sin\\frac{x+y}{2}\\cos\\frac{x}{2}\\cos\\frac{-y}{2}\\\\\n    &=4\\sin\\frac{\\pi-z}{2}\\cos\\frac{x}{2}\\cos\\frac{y}{2}\\\\\n    &=4\\cos\\frac{z}{2}\\cos\\frac{x}{2}\\cos\\frac{y}{2}\n\\end{align}\n\\]"
  },
  {
    "objectID": "posts/2025-03-05-addition-theorem/index.html#references",
    "href": "posts/2025-03-05-addition-theorem/index.html#references",
    "title": "三角関数の加法定理",
    "section": "References",
    "text": "References\n\nRegmonkey Datascience Blog &gt; tangent 75°の図形的計算\nRegmonkey Datascience Blog &gt; 三角形の内接円"
  },
  {
    "objectID": "posts/2025-06-28-datamart-principle/index.html",
    "href": "posts/2025-06-28-datamart-principle/index.html",
    "title": "Datamart作成Tips",
    "section": "",
    "text": "Definition 1 データマート\n\n特定のクエリ群で必要とされるデータだけを保持する，相対的に小さなサイズのテーブルのこと\nアクセス対象テーブルサイズを小さくすることでI/O量を減らすのが種目的\n\n\n\nDefinition 2 ゾンビマート\n\nもう参照されていないのに無駄に同期処理が行われているデータマート"
  },
  {
    "objectID": "posts/2025-06-28-datamart-principle/index.html#データマートとは",
    "href": "posts/2025-06-28-datamart-principle/index.html#データマートとは",
    "title": "Datamart作成Tips",
    "section": "",
    "text": "Definition 1 データマート\n\n特定のクエリ群で必要とされるデータだけを保持する，相対的に小さなサイズのテーブルのこと\nアクセス対象テーブルサイズを小さくすることでI/O量を減らすのが種目的\n\n\n\nDefinition 2 ゾンビマート\n\nもう参照されていないのに無駄に同期処理が行われているデータマート"
  },
  {
    "objectID": "posts/2025-06-28-datamart-principle/index.html#データマートの実装方法",
    "href": "posts/2025-06-28-datamart-principle/index.html#データマートの実装方法",
    "title": "Datamart作成Tips",
    "section": "データマートの実装方法",
    "text": "データマートの実装方法\nデータマートをどう構築するかは要件次第で，大きく分けると以下の方法があります．\n方法A: 物理テーブルに実装\n\nデータマート専用のテーブルを作成し，ETL/ELT処理で定期的にロードする\n長所: 高速，データが安定している\n短所: ETLコストが高い，ストレージ消費が大きい\n\n方法B: ビュー (View) で実装\n\nDWHの基盤テーブルに対するSQLを「ビュー」として定義し，利用者はビューを参照\n長所: 柔軟で開発が早い，ストレージ不要\n短所: 元テーブルに毎回クエリが走るため重い集計では遅くなる\n\n方法C: マテリアライズドビューで実装\n\n上記の「ビュー」の欠点を補う形で，集計結果をあらかじめ保存\n基本的に「単一テーブルに対する単純な集計」が対象\n長所: 高速，利用者からはビュー同様に見える\n短所: 更新タイミングの設計が必要（鮮度とパフォーマンスのトレードオフ）\n\n\n\n\n\n\n\nTipBigQuery のマテリアライズドビューに関する制限事項\n\n\n\n\nマテリアライズドビューで使える集計関数は限定的で，「基本的な集約 + 一部の近似集計やビット演算」に限られる\n自己結合や RIGHT/FULL OUTER JOIN はサポートされていない\nユーザー定義関数（UDF）やウインドウ関数などは使用することができない"
  },
  {
    "objectID": "posts/2025-06-28-datamart-principle/index.html#データマート作成にあたっての観点",
    "href": "posts/2025-06-28-datamart-principle/index.html#データマート作成にあたっての観点",
    "title": "Datamart作成Tips",
    "section": "データマート作成にあたっての観点",
    "text": "データマート作成にあたっての観点\n\n\n\n\n\n\nNote1: データ同期のタイミング\n\n\n\n\nオリジナルテーブルとの動機タイミングが短いほどデータ鮮度は新しくなる\n一方，更新頻度が多いほどDWHに与える負荷は大きくなる\n一般的には，同期は夜間バッチにおいて実行されることが多く，この場合のデータ鮮度は最低１日前となる\n\n\n\n\n\n\n\n\n\nNote2: データマートのサイズ\n\n\n\n\nオリジナルテーブルとサイズがあまり変わらないデータマートを作ってもI/O量の節約にはつながらない\nデータマート設計段階で，取引単位や日次集計かなどを観測単位を設計し，事前にGROUP BY処理を実施することが推奨\n\n\n\n\n\n\n\n\n\nNote3: データマートの数\n\n\n\n\nデータマートは分析用途ごとに作成されることが多く，数が増えるほど管理工数やストレージ負荷が増加する\n同じ指標やマスタを複数のデータマートでばらばらに管理すると，分析結果の整合性が崩れるリスクがある\n過剰に細分化すると更新処理や同期の複雑さが増すため，必要最小限の粒度で統合・共通化を検討\n\n\n\n\n\n\n\n\n\nNote4: バッチウィンドウ\n\n\n\n\nデータマートのETL処理自体にもコンピュテーションリソースを消費する\n夜間や利用が少ない時間帯にバッチ処理を集中させることで，システム負荷を分散できる\nバッチウィンドウの長さが短い場合，大規模データや複雑な処理が間に合わないリスクがある\n\n\n\n\n\n\n\n\n\nNote5: データ品質・正規化\n\n\n\n\n欠損値や異常値の補正方針を明確にしておく\n名寄せやコード体系の統一（部門コード・商品コードなど）が必要\nデータマート内のデータ品質を保証することで，分析結果の信頼性を向上\n\n\n\n\n\n\n\n\n\nNote6: パフォーマンス最適化\n\n\n\n\nインデックスやパーティション分割の活用を検討\nデータマートの実装方法として，materialized viewでの実装を検討\nクエリ実行時間やI/O負荷を抑え，利用者のストレスを低減"
  },
  {
    "objectID": "posts/2025-06-28-datamart-principle/index.html#references",
    "href": "posts/2025-06-28-datamart-principle/index.html#references",
    "title": "Datamart作成Tips",
    "section": "References",
    "text": "References\n\nSQL実践入門: 高速でわかりやすいクエリの書き方\nBigQueey &gt; Introduction to materialized views\nBigQueey &gt; Materialized views query support"
  },
  {
    "objectID": "posts/2025-08-01-firewall-settings/index.html",
    "href": "posts/2025-08-01-firewall-settings/index.html",
    "title": "Ubuntu 22.04でのfirewall設定",
    "section": "",
    "text": "ufwを用いてUbuntu 22.04用のファイアウォールルールを設定する\n\nPrerequisites\n\n\n\n\n条件\n備考\n\n\n\n\nufwインストール済み\napt-get install ufw\n\n\nufw有効化\nsudo  ufw enable"
  },
  {
    "objectID": "posts/2025-08-01-firewall-settings/index.html#ゴール",
    "href": "posts/2025-08-01-firewall-settings/index.html#ゴール",
    "title": "Ubuntu 22.04でのfirewall設定",
    "section": "",
    "text": "ufwを用いてUbuntu 22.04用のファイアウォールルールを設定する\n\nPrerequisites\n\n\n\n\n条件\n備考\n\n\n\n\nufwインストール済み\napt-get install ufw\n\n\nufw有効化\nsudo  ufw enable"
  },
  {
    "objectID": "posts/2025-08-01-firewall-settings/index.html#ufwとは",
    "href": "posts/2025-08-01-firewall-settings/index.html#ufwとは",
    "title": "Ubuntu 22.04でのfirewall設定",
    "section": "ufwとは？",
    "text": "ufwとは？\n\nDefinition 1 ufw(Unbcomplicated Firewall)\n\nUbuntu のファイアウォール設定ツール\niptablesのフロントエンド\n初期状態では無効になっており，ユーザーが手動で有効にする必要がある\n設定内容は /etc/ufw/user.rules (IPv4) と /etc/ufw/user6.rules (IPv6) に保存される\n\n\nufwは，netfilter を管理するためのフレームワークと，ファイアウォールを操作するためのCLIを提供してくれるソフトです．\nLinuxカーネルには，Netfilterというパケットフィルタリング機能があります．パケットの通過の可否の判断は，基本的に通信経路，IPアドレス，ポート番号，ポリシーの組み合わせで行われます． なお，デフォルトでは外部からは必要最低限のネットワーク通信しか受け付けないようにファイアウォールが設定されています．\n通信経路\n\n\n\n\n通信経路\n説明\n\n\n\n\n入力(Incoming)\n外部からLinuxへ入ってくる通信経路\n\n\n出力(Outgoing)\nLinuxから外部へ出ていく通信経路\n\n\n転送(Routed)\n別ホストへ転送する通信経路\n\n\n\n\nIPアドレス\n\n特定のクライアントのみに接続を許可したい場合のルール\n不特定多数に提供するサービスのサーバーでは設定が困難\n\n特定のIPからだけ3000ポートへの入力を許可する場合は\nsudo ufw allow from 192.168.1.100 to any port 3000\n送信先ポート番号\n入力方向(IN)の場合，任意の送信元IPからポート3000へのアクセス許可をする場合は\nsudo ufw allow to any port 3000\nポリシー\n\n\n\n\nポリシー\n説明\n\n\n\n\nallow\nルールにマッチしなかった通信を許可\n\n\ndeny\n通信を破棄\n\n\nreject\n通信を拒否してエラーを返す\n\n\n\n\n\nufw defaultの設定書式\n\nSyntax\nufw default allow|deny|reject [incomming|outgoing|routed]\n\n\n通常は内部から外部へのOutgoingのみallowにすることを推奨"
  },
  {
    "objectID": "posts/2025-08-01-firewall-settings/index.html#ufwコマンドを用いたファイヤーウォール設定",
    "href": "posts/2025-08-01-firewall-settings/index.html#ufwコマンドを用いたファイヤーウォール設定",
    "title": "Ubuntu 22.04でのfirewall設定",
    "section": "ufwコマンドを用いたファイヤーウォール設定",
    "text": "ufwコマンドを用いたファイヤーウォール設定\n\n\n\n\nファイル\n説明\n\n\n\n\n/etc/ufw/ufw.conf\nufwの有効ステータス及びLOGLEVELの設定ファイル\n\n\n/etc/ufw/user.rules\nIPv4に関連するufwルールの設定ファイル\n\n\n/etc/ufw/user6.rules\nIPv6に関連するufwルールの設定ファイル\n\n\n\n\n基本的には以下で解説するコマンド経由の設定で十分\nきめ細かい設定をする場合を上記のファイルを直接編集\n\n\nufw enable/disable\n# ufwを有効にしたい場合\nsudo ufw enable\n\n# ufwを無効にしたい場合\nsudo ufw disable\nufw disableしても，設定したルールは残されています．次回有効にしたときに以前設定したファイアウォールルールを再利用することができます．\nufw status\n設定と動作状況を確認したい場合は ufw status コマンドを実行します．コマンド実行により以下の内容が確認できます\n\nファイアウォールの動作状況: active or inactive\n設定されているルール一覧\n\n# 設定と動作状況を表示\n% sudo ufw status\nStatus: active\n\nTo                         Action      From\n--                         ------      ----\nAnywhere on tailscale0     ALLOW       Anywhere                  \n22/tcp                     LIMIT       Anywhere                  \nAnywhere (v6) on tailscale0 ALLOW       Anywhere (v6)             \n22/tcp (v6)                LIMIT       Anywhere (v6)  \nルールを削除挿入する場合はルール番号がわかると便利です．ルール番号を表示させたい場合は\n# ルール番号を表示する\n% sudo ufw status numbered\nStatus: active\n\n     To                         Action      From\n     --                         ------      ----\n[ 1] Anywhere on tailscale0     ALLOW IN    Anywhere                  \n[ 2] 22/tcp                     LIMIT IN    Anywhere                  \n[ 3] Anywhere (v6) on tailscale0 ALLOW IN    Anywhere (v6)             \n[ 4] 22/tcp (v6)                LIMIT IN    Anywhere (v6)   \nufw status verbose\nロギングモードやデフォルトポリシーを表示させる場合は ufw status verbose を実行します\n% sudo ufw status verbose \nStatus: active\nLogging: on (high)\nDefault: deny (incoming), allow (outgoing), deny (routed)\nNew profiles: skip\n\nTo                         Action      From\n--                         ------      ----\nAnywhere on tailscale0     ALLOW IN    Anywhere                  \n22/tcp                     LIMIT IN    Anywhere                  \nAnywhere (v6) on tailscale0 ALLOW IN    Anywhere (v6)             \n22/tcp (v6)                LIMIT IN    Anywhere (v6)    \nufw logging\n\nSyntax\nufw logging off|low|medium|high|full\n\nrsyslogが設定されているシステムでは，/var/log/ufw.log にログが記録される\nLEVEL(off|low|medium|high|full)を指定すると，logging頻度が設定される\ndefaultのlog levelは low\n\n\n\n\n\n\n\n\n\n\nパラメーター\n説明\n\n\n\n\noff\nログを記録しない\n\n\nlow\n定義されたポリシーに一致しないすべてのブロックされたパケット（レート制限付き） + ログルールに一致するパケットを記録\n\n\nmedium\nlowに加え，ポリシーにマッチせず許可された通信，INVALIDなパケット，新規の接続をレート制限付きで記録\n\n\nhigh\nmedium レベルのログ（レート制限なし）に加え，すべてのパケットをレート制限付きでログに記録\n\n\nfull\nhigh レベルのログ（レート制限なし）をすべて記録\n\n\n\n\nmedium より上のログレベルは，たくさんのログ出力を生成し，ディスクを短時間で使い切ってしまう可能性があります．ですので迷ったならば\n\nサーバー使用: medium\n個人用デスクトップ: low\n\nという設定で十分だと思います．\nufw allow\n\nSynatx\nufw allow service|port|protocol|IP address\n\n特定のポートやサービスへのアクセスを許可するルールを設定する際に使用\n\n\n# SSH を許可\nsudo ufw allow 22/tcp\n\n# HTTP を許可\nsudo ufw allow http\n\n# 192.168.1.0/24の範囲からのアクセスを許可\nsudo ufw allow from 192.168.1.0/24\n\n# 192.168.1.0/24の範囲からport 80へのアクセスを許可\nsudo ufw allow from 192.168.1.0/24 to any port 80\nufw deny\n\nSyntax\nufw deny service|port|protocol|IP address\n\n特定のポートやサービスへのアクセスを拒否するルールを設定する際に使用\n\n\n# Telnet を拒否\nsudo ufw deny 23/tcp\n\n# 10.0.0.5からのアクセスを拒否\nsudo ufw deny from 10.0.0.5\nufw delete\n\nSyntax\nufw delete NUM|rule\n\n既存のルールを削除する際に使用\nNUM は ufw status numbered で確認したルール番号\n\n\n# 22番ポートの許可を削除\nsudo ufw delete allow 22/tcp\n\n# 23番ポートの拒否を削除\nsudo ufw delete deny 23/tcp\n\n# 23番ポートの制限許可を削除\nsudo ufw delete limit 22/tcp \n\n# ルール 5~9 を削除(降順にすること)\nfor n in 9 8 7 6 5; do ufw delete $n; done \nufw insert\n\nSyntax\nufw insert NUM allow|deny service|port|protocol|IP address\n\nルールを指定した順番に挿入する際に使用\nNUM は挿入する位置番号\n\n\n# 80番ポート許可を最初のルールに挿入\nsudo ufw insert 1 allow 80/tcp\n\n# 192.168.1.100からのアクセス拒否ルールを２番に挿入\nsudo ufw insert 2 deny from 192.168.1.100\nufw limit\n\nSyntax\nufw limit service|port\n\n指定したポートやサービスへのアクセスを制限（レート制限）する際に使用\nDoS 攻撃やブルートフォース攻撃対策に便利\n\n\n# SSH に対して接続レート制限を設定\nsudo ufw limit 22/tcp\n\n# 192.168.1.0/24範囲からポート443への接続をレート制限\nsudo ufw limit from 192.168.1.0/24 to any port 443\n\nufw + tailscaleの設定\n\n\n\n\n\n\nNoteファイアウォール設定方針\n\n\n\n\nTailscale以外のすべてのincoming通信を拒絶\nすべてのOutgoingトラフィックを許可\n\n\n\nPrerequisites\n\ntailscaleがサーバー側でインストール済み\nufwがサーバー側でインストール済み\ntailscale経由でssh接続可能\n\n\nDefaultルールの設定\ntailscale sshでサーバーにログインした後に，ufw defaultルールを設定します\n# incoming rule\nsudo ufw default deny incoming\n\n# outgoing rule\nsudo ufw default allow outgoing\nverboseを用いてDefaultルール設定を確認します．Defaultセクションについて，以下のような設定になっていればOKです\n$ sudo ufw status verbose\nStatus: active\nLogging: on (high)\nDefault: deny (incoming), allow (outgoing), deny (routed)\nNew profiles: skip\n\nTo                         Action      From\n--                         ------      ----\n...\n次に，tailscale のincoming設定をします\n$ sudo ufw allow in on tailscale0\n改めてルール設定を確認します\n$ sudo ufw status                \nStatus: active\n\nTo                         Action      From\n--                         ------      ----\nAnywhere on tailscale0     ALLOW       Anywhere                  \nAnywhere (v6) on tailscale0 ALLOW       Anywhere (v6) \nルール設定後，ufwをリフレッシュして完了です\n$ sudo ufw reload\n\n📘 REMARKS\n\n上記のufwルール設定ではincomingがデフォルトでdeny, tailscale経由のみをincomingアクセスを許可\ntailscaleを経由しないsshは拒絶されるが，tailscale + sshは機能するはずです"
  },
  {
    "objectID": "posts/2025-08-01-firewall-settings/index.html#トラブルシューティング",
    "href": "posts/2025-08-01-firewall-settings/index.html#トラブルシューティング",
    "title": "Ubuntu 22.04でのfirewall設定",
    "section": "トラブルシューティング",
    "text": "トラブルシューティング\n\n/var/log/ufw.logが生成されない\n\n\n\n\n\n\nWarningProblem\n\n\n\nsudo ufw status verbose でlogging on担っているにも関わらず，/var/log/ufw.log が生成されない\n\n\n原因調査\nufw.log は rsyslog 経由で書き込まれるはずなので，rsyslog 自体のログを確認してみます．\nsudo cat /var/log/syslog | grep \"ufw\"\nファイルを見てみると\nrsyslogd: file '/var/log/ufw.log': open error: Permission denied [v8.2312.0 try https://www.rsyslog.com/e/2433 ]\nというラインが登場したならば，Permissionの問題であると考えることができます．\n対策\n/var/logのdefault permissonは\n\n\n\n\n項目\n設定値\n\n\n\n\nowner\nroot\n\n\ngroup\nsyslog\n\n\npermission\n755(drwxr-xr-x)\n\n\n\n\n/var/log 自体には 書き込み権限を付けないのが推奨及びデフォルトなので，個別ファイル(今回ならば /var/log/ufw.log) に権限をつけることが対応策となります．従って，\n# 空のlogファイル生成\nsudo touch /var/log/ufw.log\n\n# owner:groupの変更\nsudo chown syslog:adm /var/log/ufw.log\nもろもろがめんどくさい場合は sudo chmod 775 /var/log を実行します．"
  },
  {
    "objectID": "posts/2025-08-01-firewall-settings/index.html#appendix-ipアドレスとサブネットマスク",
    "href": "posts/2025-08-01-firewall-settings/index.html#appendix-ipアドレスとサブネットマスク",
    "title": "Ubuntu 22.04でのfirewall設定",
    "section": "Appendix: IPアドレスとサブネットマスク",
    "text": "Appendix: IPアドレスとサブネットマスク\n\nDefinition 2 IPアドレスの構成\nIP address:   192.168.0.1\nSubnet mask:  255.255.255.0\nというIPv4アドレスはネットワークパートとホストパートの２つの要素によって構成されています：\n\nNewwork Identifier: デバイスがどのネットワークに属しているかを示す識別子\nHost Identifier: 属しているネットワーク上でデバイスに対して付与される識別子\n\nサブネットマスクはIPアドレスの内，どのビットまでがNetwork Identifierなのかを示します．\n\nIPv4アドレスは32-bitで定義されています．192.168.0.1はそれを読みやすくしたものであり，binary表記と対応させると\n192.168.0.1 =\n11000000.10101000.00000000.00000001\nサブネットマスクも同様で\n255.255.255.0 =\n11111111.11111111.11111111.00000000\n\n1: network portion\n0: host portion\n\n解釈すると，192.168.0 がネットワーク識別子で，1がホスト識別子となります．\nIPv4とサブネットマスクの解釈\n\n\n\n\n\n\n\n\n\nNetwork ID\n192.168.0.0\n\n\n\nBroadcast address\n192.168.0.255\n同じネットワークに属するすべてのデバイスに一斉にメッセージを届けるための特別なIPアドレスのこと\n\n\nValid hosts\n192.168.0.1 ~ 192.168.0.254\n254個のデバイスが同一ネットワークに登録可能\n\n\n\n\n\n\n\n\n\n\nNoteBroadcast address vs 0.0.0.0\n\n\n\nBroadcast addressは通信の宛先アドレスですが，0.0.0.0 は宛先ではなく「このマシンが持つ全てのIPv4アドレスで待ち受ける」という意味になります．間隔としては，\n\n0.0.0.0: 自分の家の全てのドアを開けて待っている（誰でも入れる状態にする）\n192.168.0.255: 町内の 全住人にスピーカーで呼びかける\n\n\n\n\n\n\n\n\n\n\nアドレス\n意味\n使い方\n\n\n\n\n0.0.0.0\n「全ての自分のIPアドレスで待ち受ける」\nサーバープログラムのバインド用\n\n\n192.168.0.255\n「192.168.0.0/24 の全ホストに送信する」\nブロードキャスト通信の宛先\n\n\n\n\n\n\n\nCIDR表記\nフルのサブネットマスク（255.255.255.0）のように表記する代わりに，ネットワーク部に使うビット数だけを指定する方法をCIDR表記といいます．\n\n192.168.1.10/24: 24 はネットワーク部が 24 ビットという意味（マスクは 255.255.255.0）\n10.0.0.1/8: /8 はネットワーク部が 8 ビットという意味（マスクは 255.0.0.0）\n\n\nExample 1 \n172.18.1.10/12 のネットワークの有効ホスト範囲とブロードキャストアドレスは\n\n有効ホスト範囲: 172.16.0.1～ 172.31.255.254\nブロードキャストアドレス: 172.31.255.255"
  },
  {
    "objectID": "posts/2025-08-01-firewall-settings/index.html#references",
    "href": "posts/2025-08-01-firewall-settings/index.html#references",
    "title": "Ubuntu 22.04でのfirewall設定",
    "section": "References",
    "text": "References\n\nUbuntu manuals &gt; ufw\nTailscale &gt; Use UFW to lock down an Ubuntu server"
  },
  {
    "objectID": "posts/2025-07-08-WLLN-SLLN/index.html",
    "href": "posts/2025-07-08-WLLN-SLLN/index.html",
    "title": "Law of Large Numbers",
    "section": "",
    "text": "Exercise 1 WLLN\n\\(|m|&lt; \\infty, |\\sigma| &lt; \\infty\\) として \\(X_i \\overset{\\mathrm{iid}}{\\sim} D(m, \\sigma^2)\\) とする．このとき任意の \\(\\epsilon &gt; 0\\) について，\n\\[\n\\lim_{n\\to\\infty} P\\left[\\left|\\frac{X_1 + \\cdots + X_n}{n} - m\\right| &gt; \\epsilon\\right] = 0\n\\]\nが成り立つ．\n\n\n\n\n\n\n\nNoteProof\n\n\n\n\n\n\\(Z \\equiv \\sum X_i\\) とおくと，i.i.d の仮定より\n\\[\n\\begin{align}\n\\mathbb E[Z] &= nm\\\\\n\\operatorname{Var}(Z) &= n\\sigma^2\n\\end{align}\n\\]\nよって，\n\\[\n\\begin{align}\nP\\bigg[\\bigg|\\frac{Z}{n} - m\\bigg| &gt; \\epsilon\\bigg]\n  &= P[|Z - nm| &gt; n\\epsilon]\\\\\n  &= P[(Z - nm)^2 &gt; n^2\\epsilon^2]\\\\\n  &\\leq \\frac{\\mathbb E[(Z - nm)^2]}{n^2\\epsilon^2} \\, \\ \\because{\\text{Markov不等式}}\\\\\n  &= \\frac{\\sigma^2}{n\\epsilon^2}\n\\end{align}\n\\]\n従って，\n\\[\n\\lim_{n\\to\\infty} P\\left[\\left|\\frac{X_1 + \\cdots + X_n}{n} - m\\right| &gt; \\epsilon\\right] = 0\n\\]"
  },
  {
    "objectID": "posts/2025-07-08-WLLN-SLLN/index.html#review-question",
    "href": "posts/2025-07-08-WLLN-SLLN/index.html#review-question",
    "title": "Law of Large Numbers",
    "section": "",
    "text": "Exercise 1 WLLN\n\\(|m|&lt; \\infty, |\\sigma| &lt; \\infty\\) として \\(X_i \\overset{\\mathrm{iid}}{\\sim} D(m, \\sigma^2)\\) とする．このとき任意の \\(\\epsilon &gt; 0\\) について，\n\\[\n\\lim_{n\\to\\infty} P\\left[\\left|\\frac{X_1 + \\cdots + X_n}{n} - m\\right| &gt; \\epsilon\\right] = 0\n\\]\nが成り立つ．\n\n\n\n\n\n\n\nNoteProof\n\n\n\n\n\n\\(Z \\equiv \\sum X_i\\) とおくと，i.i.d の仮定より\n\\[\n\\begin{align}\n\\mathbb E[Z] &= nm\\\\\n\\operatorname{Var}(Z) &= n\\sigma^2\n\\end{align}\n\\]\nよって，\n\\[\n\\begin{align}\nP\\bigg[\\bigg|\\frac{Z}{n} - m\\bigg| &gt; \\epsilon\\bigg]\n  &= P[|Z - nm| &gt; n\\epsilon]\\\\\n  &= P[(Z - nm)^2 &gt; n^2\\epsilon^2]\\\\\n  &\\leq \\frac{\\mathbb E[(Z - nm)^2]}{n^2\\epsilon^2} \\, \\ \\because{\\text{Markov不等式}}\\\\\n  &= \\frac{\\sigma^2}{n\\epsilon^2}\n\\end{align}\n\\]\n従って，\n\\[\n\\lim_{n\\to\\infty} P\\left[\\left|\\frac{X_1 + \\cdots + X_n}{n} - m\\right| &gt; \\epsilon\\right] = 0\n\\]"
  },
  {
    "objectID": "posts/2025-07-08-WLLN-SLLN/index.html#the-weak-law-of-large-numbers",
    "href": "posts/2025-07-08-WLLN-SLLN/index.html#the-weak-law-of-large-numbers",
    "title": "Law of Large Numbers",
    "section": "The Weak Law of Large Numbers",
    "text": "The Weak Law of Large Numbers\n\nTheorem 1 The Weak Law of Large Numbers\n\\(X_i\\) がi.i.d.にmean \\(\\mu\\) の分布に従うとする．このとき，任意の \\(\\epsilon &gt;0\\) について\n\\[\n\\lim_{n\\to\\infty} P\\left[\\left|\\frac{X_1 + \\cdots + X_n}{n} - \\mu\\right| &gt; \\epsilon\\right] = 0\n\\]\n\n\nWLLNは，\\(n\\) が十分大きいとき，標本平均の分布の大部分が母平均 \\(\\mu\\) の近くに集中することを示しています\n\\(\\mu\\) を中心とした長さのある正の区間 \\([\\mu−\\epsilon, \\mu+\\epsilon]\\) を考えると、\\(\\frac{\\sum X_i}{N}\\) がその区間内に入る確率は高い\n\n\nExample 1 conservativeな出口調査推定\n有権者の内，\\(p\\) の割合がA党を支持しているとします．\\(n\\) 人を”randomly selected”して，その結果 \\(M_n\\) の割合の人がA等を支持していたとします．マルコフ不等式より\n\\[\nP(|M_n - p|&gt;\\epsilon)\\leq \\frac{p(1-p)}{n\\epsilon^2}\n\\]\n\\(p(1-p)\\leq \\frac{1}{4}\\) から保守的に見積もると\n\\[\nP(|M_n - p|&gt;\\epsilon)\\leq \\frac{1}{4n\\epsilon^2}\n\\]\n例として \\(\\epsilon =0.01, n=50,000\\) の水準を考えると\n\\[\nP(|M_n - p|&gt;\\epsilon)\\leq \\frac{1}{4\\cdot 10,000\\cdot 0.01^2} = 0.05\n\\]\nつまり，\\(n=50,000\\) インタビューしてようやく誤差 \\(0.01\\) 未満の水準となることがわかります．\n\n\n\n\n\n\nTipREMARKS\n\n\n\n\nCLTを用いるともっと少ないサンプルサイズ \\(n\\) で誤差 \\(0.01\\) 未満の水準を達成できます"
  },
  {
    "objectID": "posts/2025-07-08-WLLN-SLLN/index.html#the-strong-law-of-large-numbers",
    "href": "posts/2025-07-08-WLLN-SLLN/index.html#the-strong-law-of-large-numbers",
    "title": "Law of Large Numbers",
    "section": "The Strong Law of Large Numbers",
    "text": "The Strong Law of Large Numbers\n\nTheorem 2 The Strong Law of Large Numbers\n\\(X_i\\) がi.i.d.にmean \\(\\mu\\) の分布に従うとする．また，\\(\\mathbb E[|X_i|] &lt; \\infty\\) であるとする．このとき，sample mean列\n\\[\nM_n = \\frac{X_1 + \\cdots + X_n}{n}\n\\]\nについて\n\\[\nP\\left(\\lim_{n\\to\\infty}\\frac{X_1 + \\cdots + X_n}{n} = \\mu\\right) = 1\n\\]\nが成り立つことを強大数の法則という．これはつまり，\n\\[\nM_n \\overset{a.s.}{\\to} \\mu\n\\]\n\n\nボレル＝カンテリの補題\n\nTheorem 3 ボレル＝カンテリの補題 I\n\\((\\Omega, \\mathcal{F}, P)\\) を確率空間とするとき，\\(A_i \\in \\mathcal{F}\\) に対して，\n\\[\n\\sum_{i=1}^\\infty P(A_i) &lt; \\infty \\Rightarrow P(\\underset{n\\to\\infty}{\\lim\\sup} A_n) = 0\n\\]\n\n\n\n\n\n\n\nNoteProof\n\n\n\n\n\n上極限の定義と確率の劣加法性より，\n\\[\n\\begin{align}\nP(\\underset{n\\to\\infty}{\\lim\\sup} A_n)\n  &= P\\left(\\bigcap_{n=1}^\\infty\\bigcup_{k=n}^\\infty A_k\\right)\\\\\n  &= \\lim_{n\\to\\infty} P\\left(\\bigcup_{k=n}^\\infty A_k\\right)\\\\\n  &\\leq \\lim_{n}\\sum_{k=n}^\\infty P(A_k)\n\\end{align}\n\\]\nここで，\\(\\sum_{i=1}^\\infty P(A_i)\\) であるので，\\(\\displaystyle\\lim_{n}\\sum_{k=n}^\\infty P(A_k) = 0\\). 従って，\n\\[\n\\sum_{i=1}^\\infty P(A_i) &lt; \\infty \\Rightarrow P(\\underset{n\\to\\infty}{\\lim\\sup} A_n) = 0\n\\]\n\n\n\nTheorem 3 は \\((A_i)_{i\\in\\mathbb N}\\) のうち高々有限個の \\(A_i\\) しか起こらないことを意味します．また，書き換えると\n\\[\nP(\\underset{n\\to\\infty}{\\lim\\sup} A_n) = 0 \\Leftrightarrow P(\\underset{n\\to\\infty}{\\lim\\inf} A^c_n)= 1\n\\]\n\nExample 2 コイン投げ問題とボレル＝カンテリの補題 I\nコインを何度も独立に投げる試行を考えます．ただし，毎回投げるコインは違いものとし，\\(n\\) 回目に投げるコインの表の出る確率は\n\\[\np_n \\in (0, 1)\n\\]\nとします．このとき，ボレル＝カンテリの補題 Iより\n\\[\n\\sum_{n=1}^\\infty p_n &lt; \\infty \\Rightarrow P(\\text{表が出る回数は有限回}) = 1\n\\]\nとなります．（\\(\\sum_{n=1}^\\infty p_n &lt; \\infty\\) の一例としてはバーゼル問題など参照）\n例として，確率変数\n\\[\nX_n = \\left\\{\\begin{array}{c}\n1 & \\text{$n$回目に表が出る}\\\\\n0 & \\text{$n$回目に裏が出る}\n\\end{array}\\right.\n\\]\nとして，\\(A_n = \\{X_n = 1\\} \\in \\mathcal{F}\\) を考えると，\n\\[\n\\sum_{n=1}^\\infty P(A_n) = \\sum_{n=1}^\\infty p_n &lt; \\infty\n\\]\nボレル=カンテリの補題 I を用いると\n\\[\nP(\\underset{n\\to\\infty}{\\lim\\inf} A^c_n) = P\\left(\\lim_{n\\to\\infty}\\bigcup_{n=1}^\\infty\\bigcap_{k=n}^\\infty\\{X_n = 0\\} \\right) =  1\n\\]\nこれは，確率1で，ある \\(n = N\\) が存在して \\(k\\geq n\\) に対して \\(\\{X_n = 0\\}\\), つまり裏が出るということを意味します．これは，表が出る回数は有限回と同じ意味です．\n\n\n\nTheorem 4 Almost surely convergence\n確率変数列 \\(\\{X_n\\}\\) について，任意の \\(\\epsilon &gt;0\\) に対して\n\\[\n\\sum_{n=1}^\\infty P(|X_n - X| &gt; \\epsilon) &lt; \\infty\n\\]\nを満たすとします．このとき，\n\\[\nX_n \\overset{\\text{a.s.}}{\\to}X\n\\]\n\n\n\n\n\n\n\nNoteProof\n\n\n\n\n\n任意の \\(p \\in \\mathbb N\\) に対して，確率事象を\n\\[\nA_n^p = \\{|X_n - X| &gt; p^{-1}\\}\n\\]\nとおきます．仮定より\n\\[\n\\sum_{n=1}^\\infty P(A_n^p) &lt; \\infty\n\\]\nであるので，ボレル=カンテリの補題 I を用いると，任意の \\(p \\in \\mathbb N\\) に対して\n\\[\nP\\left(\\underset{n\\to\\infty}{\\lim\\sup} A_n^p \\right) = 0 \\Leftrightarrow P\\left(\\underset{n\\to\\infty}{\\lim\\inf} (A_n^p)^c \\right) = 1\n\\]\n任意の \\(p\\in\\mathbb N\\) で成立することから\n\\[\n\\begin{align}\n1\n  &= P\\left(\\bigcap_{p=1}^\\infty \\left\\{\\underset{n\\to\\infty}{\\lim\\inf} (A_n^p)^c\\right\\} \\right)\\\\\n  &= P\\left(\\bigcap_{p=1}^\\infty\\bigcup_{n=1}^\\infty\\bigcap_{k\\geq n} (A_k^p)^c\\right)\\\\\n  &= P\\left(\\bigcap_{p=1}^\\infty\\bigcup_{n=1}^\\infty\\bigcap_{k\\geq n} \\{|X_k - X| \\leq p^{-1}\\}\\right)\n\\end{align}\n\\]\n\\(\\epsilon = p^{-1}\\) と対応させると，任意の \\(\\epsilon &gt;0\\) にたいして，ある \\(n\\in\\mathbb N\\) が存在して，\\(k\\geq n\\) となるすべての \\(k\\) について，\n\\[\n|X_k - X| \\leq \\epsilon\n\\]\nとなる確率が１である，ことを意味しており，これは概収束の定義と一致している．"
  },
  {
    "objectID": "posts/2025-07-05-power-set/index.html",
    "href": "posts/2025-07-05-power-set/index.html",
    "title": "集合 \\((0,1)^N\\) の濃度",
    "section": "",
    "text": "Definition 1 べき集合\n集合 \\(M\\) があたえられたとき，\\(M\\) の部分集合全体の作る集合を \\(\\mathfrak{B}(M)\\) と表し，\\(M\\) のべき集合と呼ぶ．\n\n\\(M = \\{1, 2\\}\\) のとき，\\(M\\)の部分集合全体の作る集合は\n\\[\n\\mathfrak{B}(M) = \\{\\emptyset, \\{1\\}, \\{2\\}, \\{1,2\\}\\}\n\\]\nまた，冪集合も集合なので，\n\\[\n\\begin{align*}\n\\mathfrak{B}(\\mathfrak{B}(M)) =& \\{\n  \\emptyset,\\{\\emptyset\\}, \\{\\{1\\}\\},  \\{\\{2\\}\\}, \\{\\{1, 2\\}\\}, \\\\\n& \\{\\emptyset,  \\{1\\}\\}, \\{\\emptyset,  \\{2\\}\\}, \\{\\emptyset,  \\{1,2\\}\\}, \\{\\{1\\},  \\{2\\}\\}, \\{\\{1\\},  \\{1,2\\}\\}, \\{\\{2\\},  \\{1,2\\}\\}, \\\\\n& \\{\\emptyset, \\{1\\},  \\{2\\}\\}, \\{\\emptyset, \\{1\\},  \\{1,2\\}\\}, \\{\\emptyset, \\{2\\},  \\{1,2\\}\\}, \\{\\{1\\}, \\{2\\}, \\{1,2\\}\\}\\\\\n& \\{\\emptyset, \\{1\\},  \\{2\\}, \\{1, 2\\}\\}\n\\end{align*}\n\\]\nこれらを元の個数の観点から見てみると\n\\[\n\\begin{align}\n|M| &= |\\{1, 2\\}| = 2\\\\\n|\\mathfrak{B}(M)| &= 2^2 = 4\\\\\n|\\mathfrak{B}(\\mathfrak{B}(M))| &= 2^4 = 16\n\\end{align}\n\\]"
  },
  {
    "objectID": "posts/2025-07-05-power-set/index.html#べき集合",
    "href": "posts/2025-07-05-power-set/index.html#べき集合",
    "title": "集合 \\((0,1)^N\\) の濃度",
    "section": "",
    "text": "Definition 1 べき集合\n集合 \\(M\\) があたえられたとき，\\(M\\) の部分集合全体の作る集合を \\(\\mathfrak{B}(M)\\) と表し，\\(M\\) のべき集合と呼ぶ．\n\n\\(M = \\{1, 2\\}\\) のとき，\\(M\\)の部分集合全体の作る集合は\n\\[\n\\mathfrak{B}(M) = \\{\\emptyset, \\{1\\}, \\{2\\}, \\{1,2\\}\\}\n\\]\nまた，冪集合も集合なので，\n\\[\n\\begin{align*}\n\\mathfrak{B}(\\mathfrak{B}(M)) =& \\{\n  \\emptyset,\\{\\emptyset\\}, \\{\\{1\\}\\},  \\{\\{2\\}\\}, \\{\\{1, 2\\}\\}, \\\\\n& \\{\\emptyset,  \\{1\\}\\}, \\{\\emptyset,  \\{2\\}\\}, \\{\\emptyset,  \\{1,2\\}\\}, \\{\\{1\\},  \\{2\\}\\}, \\{\\{1\\},  \\{1,2\\}\\}, \\{\\{2\\},  \\{1,2\\}\\}, \\\\\n& \\{\\emptyset, \\{1\\},  \\{2\\}\\}, \\{\\emptyset, \\{1\\},  \\{1,2\\}\\}, \\{\\emptyset, \\{2\\},  \\{1,2\\}\\}, \\{\\{1\\}, \\{2\\}, \\{1,2\\}\\}\\\\\n& \\{\\emptyset, \\{1\\},  \\{2\\}, \\{1, 2\\}\\}\n\\end{align*}\n\\]\nこれらを元の個数の観点から見てみると\n\\[\n\\begin{align}\n|M| &= |\\{1, 2\\}| = 2\\\\\n|\\mathfrak{B}(M)| &= 2^2 = 4\\\\\n|\\mathfrak{B}(\\mathfrak{B}(M))| &= 2^4 = 16\n\\end{align}\n\\]"
  },
  {
    "objectID": "posts/2025-07-05-power-set/index.html#直積集合",
    "href": "posts/2025-07-05-power-set/index.html#直積集合",
    "title": "集合 \\((0,1)^N\\) の濃度",
    "section": "直積集合",
    "text": "直積集合\n\nDefinition 2 直積集合\n2つの有限集合 \\(M, N\\) が与えられたとき，\\(a\\in M, b\\in N\\) からなる対 \\((a, b)\\) を考える．このような１つ１つの対を元と考え，この全体を１つの集合と考えたものを \\(M\\) と \\(N\\) の直積集合といい\n\\[\nM\\times N\n\\]\nと表す\n\n\nTheorem 1 直積集合の濃度\n集合 \\(M\\), \\(N\\) を有限集合とする．このとき，\n\\[\n|M\\times N| = |M| \\times |N|\n\\]\n\n\n\n\n\n\n\nNoteProof\n\n\n\n\n\n証明は直積集合の濃度を参照してください．"
  },
  {
    "objectID": "posts/2025-07-05-power-set/index.html#集合-mn",
    "href": "posts/2025-07-05-power-set/index.html#集合-mn",
    "title": "集合 \\((0,1)^N\\) の濃度",
    "section": "集合 \\(M^N\\)",
    "text": "集合 \\(M^N\\)\n有限集合 \\(M，N\\) が与えられたとき，\n\\[\nM^N\n\\]\nという集合を考えることができます．この集合は，\\(N\\) の元の個数だけ，\\(M\\) を直積させたものとして定義します．つまり， \\(N = \\{b_1, \\cdots, b_n\\}\\) であるならば，\n\\[\nM^N = \\underbrace{M\\times \\cdots \\times M}_{n個}\n\\]\nまた，濃度についても以下のように計算ができます\n\\[\n|M^N| = \\underbrace{|M|\\times \\cdots \\times |M|}_{n個} = m^n\n\\]"
  },
  {
    "objectID": "posts/2025-07-05-power-set/index.html#m-から-n-への写像全体の作る集合",
    "href": "posts/2025-07-05-power-set/index.html#m-から-n-への写像全体の作る集合",
    "title": "集合 \\((0,1)^N\\) の濃度",
    "section": "\\(M\\) から \\(N\\) への写像全体の作る集合",
    "text": "\\(M\\) から \\(N\\) への写像全体の作る集合\n\nDefinition 3 写像\n\\(M, N\\) を有限集合とします．\\(M\\) の各元から，\\(N\\) の各元を対応させる仕方が与えられているとき， \\(M\\) から \\(N\\) の写像 \\(\\varphi\\) が与えられたという．\n写像 \\(\\varphi\\) によって \\(a\\in M\\) が \\(b\\in N\\) にうつされるとき\n\\[\nb= \\varphi(a)\n\\]\nとあらわす．\n\n\\(M = \\{x, y, z\\}\\), \\(N = \\{0, 1\\}\\) のとき，MからNへの写像は以下のように \\(2^3\\) 個考えることができます．\n\n\nCode\nfrom itertools import product\nimport pandas as pd\n\n# 集合の定義\nM = ['x', 'y', 'z']\nN = [0, 1]\n\n# 写像の全列挙\nmappings = list(product(N, repeat=len(M)))\n\n# DataFrameに変換\ndf = pd.DataFrame(mappings, columns=M)\ndf.index = df.index + 1  # 1始まりにする\n\n# 表示\ndf\n\n\n\n\n\n\n\n\n\nx\ny\nz\n\n\n\n\n1\n0\n0\n0\n\n\n2\n0\n0\n1\n\n\n3\n0\n1\n0\n\n\n4\n0\n1\n1\n\n\n5\n1\n0\n0\n\n\n6\n1\n0\n1\n\n\n7\n1\n1\n0\n\n\n8\n1\n1\n1\n\n\n\n\n\n\n\n\nDefinition 4 写像全体の集合\n有限集合 \\(M\\) から 有限集合 \\(N\\) への写像の１つ１つを元と考えて，その全体を１つのまとまった集合と考えたものを\n\\[\n\\operatorname{Map}(M, N)\n\\]\nと表す．\n\n\nTheorem 2 \\[\n|\\operatorname{Map}(M, N)| = |N^M|\n\\]\n\n\n\n\n\n\n\nNoteProof\n\n\n\n\n\n\\(M = \\{a_1, \\cdots, a_m\\}, N = \\{b_1, \\cdots, b_n\\}\\) とする．\\(\\varphi\\) を \\(\\operatorname{Map}(M, N)\\) の元とする．\\(\\varphi\\) がきまるということは \\(M\\) の元の移り先が決まっていること，つまり\n\\[\n(\\varphi(a_1), \\varphi(a_2), \\cdots, \\varphi(a_m))\n\\]\nによって決まる．\\(i=1, 2, \\cdots, m\\) について \\(\\varphi(a_i) \\in N\\) であるので\n\\[\n(\\varphi(a_1), \\varphi(a_2), \\cdots, \\varphi(a_m)) \\in N\\times N\\times \\cdots \\times N = N^M\n\\]\n逆に \\(N^M\\) の元 \\((b_{i_1}, b_{i_2}, \\cdots, b_{i_m})\\) があたえられると\n\\[\n\\varphi(a_k) = b_{i_k}\n\\]\nで，\\(M \\to N\\) の写像が定まる．従って，\\(\\operatorname{Map}(M, N)\\) の元 \\(\\varphi\\) と \\(N^M\\) の元が1対1対応している．従って，\n\\[\n|\\operatorname{Map}(M, N)| = |N^M|\n\\]\n\n\n\nべき集合との関係\n有限集合 \\(M\\) に対して，その部分集合 \\(S\\) を１つとるということは \\(x\\in M\\) に対して\n\n「含める」か「含めない」かをきめる\n「含めるを1」「含めないを0」とするならば写像 \\(\\varphi: M\\to \\{0, 1\\}\\) を１つ決めることと同じ\n\nであるので \\(M\\) から \\(\\{0, 1\\}\\) への写像 \\(\\varphi\\) を１つ決めることと1対1対応します． 従って，\\(\\mathfrak{B}(M)\\) の元と，\\(\\operatorname{Map}(M, \\{0, 1\\})\\) が1対1に対応することから．\\(m = |M|\\) とすると\n\\[\n|\\operatorname{Map}(M, \\{0, 1\\})| = |\\mathfrak{B}(M)| = 2^m\n\\]\n\nExample 1 \n\\(M = \\{a, b, c\\}\\) とするとそのすべての部分集合と対応する写像は\n\n\n\n部分集合 \\(S\\)\n写像 \\(\\varphi: M \\to \\{0,1\\}\\)\n\n\n\n\n\\(\\emptyset\\)\n\\(\\varphi(a)=0, \\varphi(b)=0, \\varphi(c)=0\\)\n\n\n\\(\\{a\\}\\)\n\\(\\varphi(a)=1, \\varphi(b)=0, \\varphi(c)=0\\)\n\n\n\\(\\{b\\}\\)\n\\(\\varphi(a)=0, \\varphi(b)=1, \\varphi(c)=0\\)\n\n\n\\(\\{c\\}\\)\n\\(\\varphi(a)=0, \\varphi(b)=0, \\varphi(c)=1\\)\n\n\n\\(\\{a, b\\}\\)\n\\(\\varphi(a)=1, \\varphi(b)=1, \\varphi(c)=0\\)\n\n\n\\(\\{a, c\\}\\)\n\\(\\varphi(a)=1, \\varphi(b)=0, \\varphi(c)=1\\)\n\n\n\\(\\{b, c\\}\\)\n\\(\\varphi(a)=0, \\varphi(b)=1, \\varphi(c)=1\\)\n\n\n\\(\\{a, b, c\\}\\)\n\\(\\varphi(a)=1, \\varphi(b)=1, \\varphi(c)=1\\)"
  },
  {
    "objectID": "posts/2025-07-05-power-set/index.html#無限集合と高々加算集合の直和",
    "href": "posts/2025-07-05-power-set/index.html#無限集合と高々加算集合の直和",
    "title": "集合 \\((0,1)^N\\) の濃度",
    "section": "無限集合と高々加算集合の直和",
    "text": "無限集合と高々加算集合の直和\n\nDefinition 5 高々加算集合\n集合 \\(M\\) が，有限集合か，加算集合のとき，\\(M\\) を高々加算集合という\n\n\\(M\\) を加算集合として，\\(S\\subset M\\) となるような無限集合を考えます．\\(M\\) は加算集合であるので\n\\[\nM = \\{a_1, a_2, \\cdots, a_n, \\cdots\\}\n\\]\nと集合を \\(\\mathbb N\\) と対応させて表現することができます．次に，\\(S\\) の元について，\\(M\\) の元の並び方のうち最初に \\(S\\) の元として現れるものを \\(a_{i_1}\\), 次は \\(a_{i_2}, \\cdots\\) とすると\n\\[\nS = \\{a_{i_1}, a_{i_2}, \\cdots\\}\n\\]\nとなります．\\(S\\) は定義より無限集合であり，また写像 \\(\\varphi: \\mathbb N\\to S\\) を\n\\[\n\\varphi(n) = a_{i_n}\n\\]\nとすると，\\(\\varphi\\) は1対1写像となります．従って，\\(S\\) は加算集合となります．つまり，\\(M\\) を加算集合とすると，\\(M\\) の任意の部分集合は高々加算集合ということになります．\n\nTheorem 3 \n\\(M\\) を無限集合，\\(A\\) を高々加算集合とする．このとき，\\(M\\) と \\(M\\sqcup A\\) の間には１対１の対応があり，そのため，２つの濃度は等しい:\n\\[\n|M| = |M \\sqcup A|\n\\]\n\n\n\n\n\n\n\nNoteProof\n\n\n\n\n\n\\(M\\) から１つの元 \\(b_1\\) をとると，\\(M - \\{b_1\\}\\) は空襲号ではないので，同じ操作を繰り返すことができます．また，\\(M\\) は無限集合であるので，無限回繰り返して，その結果得られた \\(b_i\\) を以下のような集合で表現する\n\\[\nB = \\{b_1, b_2, \\cdots, b_n, \\cdots \\}\n\\]\nこのとき，\\(B\\subset M\\) かつ \\(B\\) は加算集合です．加算集合と加算集合の和は加算集合なので \\(B\\sqcup A\\) も加算集合となります．従って，\\(B\\) と \\(B\\sqcup A\\) はある写像 \\(\\varphi\\) によって1対1に対応します．\n次に\n\\[\n\\tilde\\varphi: (M-B) \\sqcup B\\to (M-B)\\sqcup (B\\sqcup A)\n\\]\nを考えます．\n\n\\(x\\in M -B\\) ならば \\(\\tilde\\varphi(x) = x\\)\n\\(x\\in B\\) ならば \\(\\tilde\\varphi(x) = \\varphi(x)\\)\n\nとすると，\\(\\tilde\\varphi\\) も1対1写像となります．\n\\[\n\\begin{align}\nM-B \\sqcup B &= M\\\\\n(M-B)\\sqcup (B\\sqcup A) &= M \\sqcup A\n\\end{align}\n\\]\nであることから\n\\[\n|M| = |M| + |A|\n\\]"
  },
  {
    "objectID": "posts/2025-07-05-power-set/index.html#mathfrakbmathbb-n-の濃度",
    "href": "posts/2025-07-05-power-set/index.html#mathfrakbmathbb-n-の濃度",
    "title": "集合 \\((0,1)^N\\) の濃度",
    "section": "\\(\\mathfrak{B}(\\mathbb N)\\) の濃度",
    "text": "\\(\\mathfrak{B}(\\mathbb N)\\) の濃度\nこれまでは有限集合を前提に話してきましたが，ここからは自然数集合 \\(\\mathbb N\\) という加算無限集合を取り扱います．\n\\[\n|\\mathbb N| = \\aleph_0\n\\]\nであることに留意すると，\n\\[\n|\\mathfrak{B}(\\mathbb N)| = 2^{\\aleph_0}\n\\]\nこれがどれくらいの濃度を持つのか考えてみます．\n\nTheorem 4 \\[\n2^{\\aleph_0} = \\aleph\n\\]\n\n\n\n\n\n\n\nNoteProof\n\n\n\n\n\n濃度 \\(2\\) を持つ集合として \\(\\{0, 1\\}\\) を考えます．このとき，\\(2^{\\aleph_0}\\) は，直積集合\n\\[\nP = \\{0, 1\\}\\times \\{0, 1\\}\\times \\{0, 1\\}\\times \\cdots\n\\]\nの濃度と等しくなります．\\(\\aleph\\) が実数集合の濃度と等しいので，\\(|(0, 1]|= \\aleph\\) であることから\n\\[\n|P| = |(0, 1]|\n\\]\nを示せれば良いとなります．\n\\(P\\) の元は 0と1 からなる数列として，\\((a_1, a_2, \\cdots)\\) と表せるので，これを2進小数で表現された実数と対応させることができます．つまり，\n\\[\n0.a_1a_2\\cdots\n\\]\n\\((0, 1]\\) に属する実数を無限２進小数で表現すると，その表し方はただ１通りとなります．\n次に，\\((0, 1]\\) に属する実数について，有限2進小数に表せる集合 \\(S\\) を考えてみます．このとき，\\(S \\subset \\mathbb Q\\) であることから\n\\[\n|S| = \\aleph_0\n\\]\n次に，写像 \\(\\varphi: P\\to (0, 1] \\sqcup S\\) を考えてみます．\\(x\\in P\\) について，\n\\[\nx = (a_1, \\cdots, a_n, 0, 0, \\cdots)\n\\]\nとあるところから先すべてが0になっているものについて，\n\\[\n\\varphi(x) = 0.a_1a_2\\cdots a_n \\in S\n\\]\nと対応させます．また，それ以外の場合は\n\\[\n\\varphi(x) = 0.a_1a_2\\cdots a_n\\cdots \\in (0, 1]\n\\]\nとなるので，\\(x\\in P \\Rightarrow \\varphi(x) \\in ((0, 1] \\sqcup S)\\)，また \\(\\varphi\\) は \\(P\\) から \\((0, 1] \\sqcup S\\) に対して１対１の対応を与えてます．つまり，\n\\[\n|P| = |(0, 1] \\sqcup S|\n\\]\nまた無限集合 Aと高々加算集合 B について Theorem 3 より\n\\[\n|A| = |A\\sqcup B|\n\\]\nであることから\n\\[\n|P| = |(0, 1] \\sqcup S| = |(0, 1]|\n\\]\n従って，\n\\[\n2^{\\aleph_0} = \\aleph\n\\]"
  },
  {
    "objectID": "posts/2025-08-18-install-meld-via-flatpak/index.html",
    "href": "posts/2025-08-18-install-meld-via-flatpak/index.html",
    "title": "flatpak経由でMeldをインストール",
    "section": "",
    "text": "NoteMeldの導入\n\n\n\n\nMeldはファイル間やディレクトリ間のdiffをGUIベースで可視化してくれるツール\nLinux版のWinMergeみたいなツール\n\n\n\nGit管理されたディレクトリでは.gitconfigで設定したEditorでのgit difftoolで十分かなと考えていますが， Git管理されていないファイルをアドホックに差分比較したいときに使うツールとしてMeldの利用を考えています．\nGUI差分ツールでの利用のみなので，今回はaptではなくflatpak経由でのインストールを実行します．\n環境情報\n% lsb_release -a\nDistributor ID: Ubuntu\nDescription:    Ubuntu 24.04.3 LTS\nRelease:    24.04\nCodename:   noble\nflatpakでインストール可能なVersion\n% flatpak search Meld                                                                                       \nName       Description                        Application ID       Version       Branch       Remotes\nMeld       Compare and merge your files       org.gnome.meld       3.22.3        stable       flathub\naptでインストール可能なversion\n% apt-cache policy meld\nmeld:\n  Installed: (none)\n  Candidate: 3.22.2-1\n  Version table:\n     3.22.2-1 500\n        500 http://jp.archive.ubuntu.com/ubuntu noble/universe amd64 Packages\n        500 http://jp.archive.ubuntu.com/ubuntu noble/universe i386 Packages\nまとめ時点ではあんまりバージョン変わらない．．．"
  },
  {
    "objectID": "posts/2025-08-18-install-meld-via-flatpak/index.html#今回の方針",
    "href": "posts/2025-08-18-install-meld-via-flatpak/index.html#今回の方針",
    "title": "flatpak経由でMeldをインストール",
    "section": "",
    "text": "NoteMeldの導入\n\n\n\n\nMeldはファイル間やディレクトリ間のdiffをGUIベースで可視化してくれるツール\nLinux版のWinMergeみたいなツール\n\n\n\nGit管理されたディレクトリでは.gitconfigで設定したEditorでのgit difftoolで十分かなと考えていますが， Git管理されていないファイルをアドホックに差分比較したいときに使うツールとしてMeldの利用を考えています．\nGUI差分ツールでの利用のみなので，今回はaptではなくflatpak経由でのインストールを実行します．\n環境情報\n% lsb_release -a\nDistributor ID: Ubuntu\nDescription:    Ubuntu 24.04.3 LTS\nRelease:    24.04\nCodename:   noble\nflatpakでインストール可能なVersion\n% flatpak search Meld                                                                                       \nName       Description                        Application ID       Version       Branch       Remotes\nMeld       Compare and merge your files       org.gnome.meld       3.22.3        stable       flathub\naptでインストール可能なversion\n% apt-cache policy meld\nmeld:\n  Installed: (none)\n  Candidate: 3.22.2-1\n  Version table:\n     3.22.2-1 500\n        500 http://jp.archive.ubuntu.com/ubuntu noble/universe amd64 Packages\n        500 http://jp.archive.ubuntu.com/ubuntu noble/universe i386 Packages\nまとめ時点ではあんまりバージョン変わらない．．．"
  },
  {
    "objectID": "posts/2025-08-18-install-meld-via-flatpak/index.html#flatpak経由でのmeldインストール",
    "href": "posts/2025-08-18-install-meld-via-flatpak/index.html#flatpak経由でのmeldインストール",
    "title": "flatpak経由でMeldをインストール",
    "section": "flatpak経由でのMeldインストール",
    "text": "flatpak経由でのMeldインストール\n\nDefinition 1 ユニバーサルパッケージ\n\nLinuxディストリビューションに依存しないパッケージのこと\n依存関係は原則存在せず，必要なものはすべてパッケージの中に取り込んだ状態で提供(アプリ用の環境まるごと提供)\nサンドボックス化によるセキュリティの向上と，ディストリビューションとアプリケーションの分離の推進\nsnap や flatpak でインストール可能なパッケージがユニバーサルパッケージ\n\n\nDebianならapt, dpkg，RHEL系ならdnf, yum, prm などLinuxディストリビューションに応じてパッケージマネージャを使い分ける必要があります． なにかしらのアプリをインストールしたいとき，ユーザーはディストリビューションに応じてコマンドがありますし，アプリの開発者はディストリビューション毎に「依存関係の解決」に対応したパッケージを作る必要があります．\nLinuxユーザー，Linux用アプリ開発者が直面したこのような状況への対応作として登場したのがユニバーサルパッケージという概念です． 基本的に必要なものはすべてパッケージの中に取り込んだ状態で提供するので，Linuxカーネルとパッケージ管理システムが動いているシステムならどこでも利用可能です．\nユニバーサルパッケージのデメリット\n\n\n\n\n\n\n\n\n項目\n内容\n\n\n\n\nディスク容量\nライブラリを同梱するため，同種のライブラリが重複し容量を消費する\n\n\n起動・性能\nサンドボックスや抽象化層を経由するため，ネイティブパッケージより起動が遅い場合がある\n\n\nシステム統合性\nテーマやフォント，ファイルシステムとの統合が弱く，見た目や操作感がネイティブより不自然になることがある\n\n\n\n\n\nsnap vs flatpak\n\n\n\n\n\n\n\n\n\n観点\nSnap\nFlatpak\n\n\n\n\n依存関係と容量\n依存関係を各パッケージに同梱．重複が発生しやすく，容量効率が悪い\n依存関係を各パッケージに同梱するが，ランタイム共有とデータ重複排除（deduplication）により容量効率が良い\n\n\nセキュリティ\nサンドボックス化は可能だが必須ではない\nデフォルトでサンドボックス化され，明示的な権限許可が必要\n\n\n運営主体\nCanonical（Ubuntu開発元）が中央管理．バックエンドは事実上プロプライエタリ\nコミュニティ主体．仕様やコードはオープン\n\n\nシステム統合\nSnapごとにマウントされるため，lsblk 出力を汚す（多数のloopデバイスが見える）\nそうした副作用はない\n\n\nアップデート制御\n強制的に自動更新され，ユーザーが制御できない\nユーザーが更新のタイミングを選べる\n\n\nアプリ（バックエンド系）\nCLIツールやバックエンド系アプリなどインフラ関連をCanonicalが公式に提供\n基本はGUIデスクトップアプリ中心\n\n\n\n\n\n\nflatpak Setup and Meld Install\nStep 1: Flatpakのインストール\n% sudo apt install flatpak\nStep 2: GNOME Software pluginのインストール\nFlatpak アプリを GNOME Softwareから扱えるようにするためFlatpak用のpluginを導入します．\n# プラグイン導入\n% sudo apt install gnome-software-plugin-flatpak\nStep 3: リポジトリ登録\n初期状態ではどこのリポジトリも登録されていないので，リポジトリ登録します\n# Flathub（Flatpak のメインリポジトリ）を追加\n% flatpak remote-add --if-not-exists flathub https://flathub.org/repo/flathub.flatpakrepo\nStep 4: Restart system\nシステムの再起動を行うことで，GNOME Softwareが Flatpak への対応が完了します．\nStep 5: Meldのインストール\nCLIでインストールする場合は以下のコマンドを実行します\n% flatpak install flathub org.gnome.meld\n\n\n\n\n\n\nWarningPublisherの確認のすすめ\n\n\n\n\n\nFlatpakでGoogle chromeパッケージは提供されていますが，提供元は verified されていません．おそらく問題はないですがパッケージインストール時に確認するクセをつけましょう．\nFirefoxの方はverified されたMozillaが提供していることが確認できます\n\n\n\n\n\n\n\nchrome not verified\n\n\n\n\n\n\n\nfirefox verified\n\n\n\n\n\n\n\n\n\nflatpakの使い方\ninstall syntax\nflatpak install flathub com.github.tchx84.Flatseal\n\n\n\n\n項目\n説明\n\n\n\n\nflatpak\nfaltpak command\n\n\ninstall\nfaltpak commandへの指示コマンド\n\n\nflathub\nダウンロードパッケージの登録レポジトリ\n\n\ncom.github.tchx84.Flatseal\nパッケージ名\n\n\n\n\n\n\n\n\n\n\nNoteFlatsealパッケージ\n\n\n\n\nFlatpakパッケージのpermission管理用のツール\nGUIベースでAppごとにリソースマネジメントが可能\n\n\n\n[インストールの種類: User vs System Mode]\nデフォルトではFlatpakはアプリをsystem modeでインストールします．ユーザーAがThunderbirdをflatpakでインストールすると，同じシステムの別ユーザーもアプリを利用することができます． ユーザー専用でアプリを使用したい場合は\nflatpak --user install flathub org.mozilla.Thunderbird\nとなります．--user optionを利用してインストールしたアプリを削除するときは\nflatpak --user uninstall org.mozilla.Thunderbird\nとする必要があります．flatpak update についても同様です．\nflatpak appのconfig格納先\nhomeディレクトリ下の .var に以下にconfigファイルを含めた形で格納されています\n% ls ~/.var/app\norg.gnome.meld/\nその他コマンド\n\n\n\n\n\n\n\nコマンド\n説明\n\n\n\n\nflatpak remotes\n登録されたリポジトリリストの確認\n\n\nflatpak remote-delete &lt;repository&gt;\n登録されたリポジトリの削除\n\n\nflatpak update\nインストール済み Flatpak アプリ・ランタイムを更新する\n\n\nflatpak list\nインストール済みのすべての Flatpak を一覧表示する\n\n\nflatpak list --app\nインストール済みのアプリ（アプリケーションのみ）を一覧表示する\n\n\nflatpak history\nインストール・削除・更新などの操作履歴を確認する\n\n\nflatpak uninstall &lt;app-id&gt;\nflatpak appの削除．ただし，~/.var/app/&lt;app-id&gt; のデータは残る\n\n\nflatpak uninstall --delete-data &lt;app-id&gt;\n~/.var/app/&lt;app-id&gt; のデータとともにアプリを削除"
  },
  {
    "objectID": "posts/2025-08-18-install-meld-via-flatpak/index.html#references",
    "href": "posts/2025-08-18-install-meld-via-flatpak/index.html#references",
    "title": "flatpak経由でMeldをインストール",
    "section": "References",
    "text": "References\n\nMeld\nFlatpak Ubuntu Quick Setup\nFlatpak documentation &gt; Using Flatpak\nFlatpak Uninstallation\nFlathub &gt; Meld"
  },
  {
    "objectID": "posts/2025-08-16-ubuntu-upgrade/index.html",
    "href": "posts/2025-08-16-ubuntu-upgrade/index.html",
    "title": "Ubuntu 24.04.3へのupgrade",
    "section": "",
    "text": "Ubuntu 24.04.3 LTSが2025-08-07にリリースされたので，22.04.4 LTSからアップグレード\nUbuntuはLTSといっても xx.xx.2 以降を待ったほうが，安定性やセキュリティパッチの恩恵を利用開始時から享受することができる\n\n\n\n\n\n\n項目\n22.04 LTS\n24.04 LTS\n\n\n\n\ngnome-shell --versio\n42.x\n46.x\n\n\npython3 --version\n3.10.x\n3.12.x\n\n\ngcc --version\n11.x\n13.x\n\n\nSystem monitorバー表示\n-\nSystem Extensionsで設定可能\n\n\n\n\n\n\n\n\n\n\n\n\nNoteUbuntu OS upgradeの手順\n\n\n\n基本的には, 以下の手順で行います\n\nsudo update-manager -cを実行し，Ubuntu の GUI アップデートマネージャ経由で新しいリリースがあるか確認\n表示内容に応じて「OSアップグレード」を実行\nアップグレードが完了したら，指示に従い reboot\n\n\n\n今回この手順で実行したところエラーが表示されたのでその解決方法を備忘録的に以下にまとめます．\nStep 1: パッケージ情報の更新\nsudo apt update\nsudo apt upgrade\nStep 2: OS upgradeの実行と問題の発覚\n% sudo update-manager -c\n...\nErrors were encountered while processing:\n thunderbird-locale-en\n thunderbird-locale-en-us\n thunderbird-locale-ja\n thunderbird-locale-en-gb\n上記のコマンドでOSのupgradeを試したところ，thunderbird関連のパッケージが原因でOSアップグレードができないというエラーが発生．\nStep 3: 問題パッケージの再確認\napt upgrade や apt install 実行中に失敗したDebianパッケージの一覧にthunderbirdは出てくるはずです．\nsudo dpkg --configure -a\nで何も出力されないのが理想ですが，設定途中に失敗したパッケージがあると一覧として出力されます．\nStep 4: thunderbirdのpurge\nthunderbirdはあとでもう一回設定しなおせば良いので，apt remove --purgeの実行を決断．\nsudo apt remove --purge 'thunderbird*'\nsudo apt autoremove\nsudo apt clean\n\napt-get purge ではなくて apt remove --purge を用いた理由は対話式で削除パッケージを確認したかったため\napt autoremove で不要なパッケージ（メタ情報的に依存関係に組み込まれていないパッケージ）を削除\napt cleanは/var/cache/apt/archives以下にキャッシュされた .deb形式ファイルを削除するコマンド\n\n\n\n\n\n\n\nWarningapt autoremove の注意点\n\n\n\napt autoremove の対象は以下の２つの基準によって抽出されます\n\nmanualではなくautoとしてapt-markされている(=インストールが手動ではない)\nそのパッケージに対して，手動でインストールされたパッケージが依存していない\n\nたまに使っているけれども auto でインストールされたパッケージがある場合，apt autoremove の候補に上がってきてしまう可能性があるので，事前にどのパッケージが削除されるのか ユーザー自身で確認することが重要です．\n自動的にインストールされたパッケージの確認\naptitude search '~i !~M'\n\n\n\n\nパターン\n説明\n\n\n\n\n!pattern\npattern に一致しないパッケージを選択\n\n\n~M\n自動的にインストールされたパッケージを選択\n\n\n~i\nインストールされているパッケージを選択\n\n\n\n\n\n\nStep 5: OS upgrade\nOSアップグレード中断の原因となったパッケージを除去した後，再度GUIベースでupdate managerを起動し作業を進めます．\nsudo update-manager -c\nこれで晴れて Ubuntu 24.04.3 LTSへのアップグレードが完了．"
  },
  {
    "objectID": "posts/2025-08-16-ubuntu-upgrade/index.html#ltsから24.04-ltsへのupgrade備忘録",
    "href": "posts/2025-08-16-ubuntu-upgrade/index.html#ltsから24.04-ltsへのupgrade備忘録",
    "title": "Ubuntu 24.04.3へのupgrade",
    "section": "",
    "text": "Ubuntu 24.04.3 LTSが2025-08-07にリリースされたので，22.04.4 LTSからアップグレード\nUbuntuはLTSといっても xx.xx.2 以降を待ったほうが，安定性やセキュリティパッチの恩恵を利用開始時から享受することができる\n\n\n\n\n\n\n項目\n22.04 LTS\n24.04 LTS\n\n\n\n\ngnome-shell --versio\n42.x\n46.x\n\n\npython3 --version\n3.10.x\n3.12.x\n\n\ngcc --version\n11.x\n13.x\n\n\nSystem monitorバー表示\n-\nSystem Extensionsで設定可能\n\n\n\n\n\n\n\n\n\n\n\n\nNoteUbuntu OS upgradeの手順\n\n\n\n基本的には, 以下の手順で行います\n\nsudo update-manager -cを実行し，Ubuntu の GUI アップデートマネージャ経由で新しいリリースがあるか確認\n表示内容に応じて「OSアップグレード」を実行\nアップグレードが完了したら，指示に従い reboot\n\n\n\n今回この手順で実行したところエラーが表示されたのでその解決方法を備忘録的に以下にまとめます．\nStep 1: パッケージ情報の更新\nsudo apt update\nsudo apt upgrade\nStep 2: OS upgradeの実行と問題の発覚\n% sudo update-manager -c\n...\nErrors were encountered while processing:\n thunderbird-locale-en\n thunderbird-locale-en-us\n thunderbird-locale-ja\n thunderbird-locale-en-gb\n上記のコマンドでOSのupgradeを試したところ，thunderbird関連のパッケージが原因でOSアップグレードができないというエラーが発生．\nStep 3: 問題パッケージの再確認\napt upgrade や apt install 実行中に失敗したDebianパッケージの一覧にthunderbirdは出てくるはずです．\nsudo dpkg --configure -a\nで何も出力されないのが理想ですが，設定途中に失敗したパッケージがあると一覧として出力されます．\nStep 4: thunderbirdのpurge\nthunderbirdはあとでもう一回設定しなおせば良いので，apt remove --purgeの実行を決断．\nsudo apt remove --purge 'thunderbird*'\nsudo apt autoremove\nsudo apt clean\n\napt-get purge ではなくて apt remove --purge を用いた理由は対話式で削除パッケージを確認したかったため\napt autoremove で不要なパッケージ（メタ情報的に依存関係に組み込まれていないパッケージ）を削除\napt cleanは/var/cache/apt/archives以下にキャッシュされた .deb形式ファイルを削除するコマンド\n\n\n\n\n\n\n\nWarningapt autoremove の注意点\n\n\n\napt autoremove の対象は以下の２つの基準によって抽出されます\n\nmanualではなくautoとしてapt-markされている(=インストールが手動ではない)\nそのパッケージに対して，手動でインストールされたパッケージが依存していない\n\nたまに使っているけれども auto でインストールされたパッケージがある場合，apt autoremove の候補に上がってきてしまう可能性があるので，事前にどのパッケージが削除されるのか ユーザー自身で確認することが重要です．\n自動的にインストールされたパッケージの確認\naptitude search '~i !~M'\n\n\n\n\nパターン\n説明\n\n\n\n\n!pattern\npattern に一致しないパッケージを選択\n\n\n~M\n自動的にインストールされたパッケージを選択\n\n\n~i\nインストールされているパッケージを選択\n\n\n\n\n\n\nStep 5: OS upgrade\nOSアップグレード中断の原因となったパッケージを除去した後，再度GUIベースでupdate managerを起動し作業を進めます．\nsudo update-manager -c\nこれで晴れて Ubuntu 24.04.3 LTSへのアップグレードが完了．"
  },
  {
    "objectID": "posts/2025-08-16-ubuntu-upgrade/index.html#upgrade後の対応",
    "href": "posts/2025-08-16-ubuntu-upgrade/index.html#upgrade後の対応",
    "title": "Ubuntu 24.04.3へのupgrade",
    "section": "Upgrade後の対応",
    "text": "Upgrade後の対応\n\nX11の有効化\nUbuntu 22.04 LTSの段階から /etc/gdm3/custom.conf にて\n[daemon]\n# Uncomment the line below to force the login screen to use Xorg\nWaylandEnable=false\nと設定していたので，作業は特段発生しません．セッションがX11かどうかを確認する場合は\necho $XDG_SESSION_TYPE\nを実行して，x11 と表示されれば問題ありません．\n\n\n\n\n\n\nNoteWaylandを採用しない理由\n\n\n\n\nスクリーンレコーダーソフト Kazam が未対応のため\n\n\n\n\n\n24.04 HWEのインストール\nなぜか uname -r で確認するとkernelがまだ 6.8.0-78-generic であったので，24.04 HWEを改めてインストールする\n% sudo apt install --install-recommends linux-generic-hwe-24.04\n\n# 依存関係エラーが発生していたなら\n% sudo apt --fix-broken install\nその後, rebootして以下のようになっていれば問題なしです．\n% uname -r\n6.14.0-28-generic\n古いkernelとパッケージの削除\ndpkg -lでシステムにインストール済みのパッケージを確認すると\n% dpkg -l | grep linux-generic\nii  linux-generic-hwe-22.04                        6.8.0-65.68~22.04.1                     amd64        Complete Generic Linux kernel and header\nii  linux-generic-hwe-24.04                        6.14.0-28.28~24.04.1                    amd64        Complete Generic Linux kernel and headers\nとなっていました．linux-generic-hwe-22.04は必要ないので\nsudo apt-get purge linux-generic-hwe-22.04\nで消し去ります．また合わせて，古いカーネルを sudo apt autoremove などで除去しとします．最後にGRUBの設定(/etc/default/grub)をupdateしときます\nsudo update-grub\n\n\n\n\n\n\nNoteGRUB\n\n\n\n\nGRUB(GRand Unified Bootloader)はLinuxで一般的に使われているブートローダー\n複数のOSやカーネルがインストールされている場合は，それらの切り替えを行うことができる\n設定ファイルは /etc/default/grub\n設定を変更する際は必ずバックアップを取るようにしましょう\n\n\n\n\n\n/etc/apt/sources.list.d/以下の.listファイルの更新\n\n\n\n\n\n\nNote再設定方針\n\n\n\n\nOS upgradeの際に，自動的にjammyからnobleに書き換えてくれますが，ユーザーが設定したパッケージレポジトリ設定は書き換えてくれないので，強引に設定し直します．\n基本的には公式インストール手順の内，レポジトリ設定の箇所だけ実行します\n\n\n\nDocker Engine\n基本的にはgpg keyとかはUbuntuならば共通のものを使っているようだったので，repository updateのみで十分と判断\necho \\\n  \"deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.asc] https://download.docker.com/linux/ubuntu \\\n  $(. /etc/os-release && echo \"${UBUNTU_CODENAME:-$VERSION_CODENAME}\") stable\" | \\\n  sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null\nsudo apt-get update\ntailscale\ncurl -fsSL https://pkgs.tailscale.com/stable/ubuntu/noble.noarmor.gpg | sudo tee /usr/share/keyrings/tailscale-archive-keyring.gpg &gt;/dev/null\\ncurl -fsSL https://pkgs.tailscale.com/stable/ubuntu/noble.tailscale-keyring.list | sudo tee /etc/apt/sources.list.d/tailscale.list\nその他\ngrep -r \"jammy\" /etc/apt/sources.list.d/ | egrep -v \"distUpgrade:\"\nで22.04 LTSベースの.listファイルがないかを確認し，必要に応じてrmを実行．\n\n\nNVIDIA GPU Driverとcuda13.0のupgrade\nsection\n% ubuntu-drivers devices\nudevadm hwdb is deprecated. Use systemd-hwdb instead.\n...\ndriver   : nvidia-driver-580-open - third-party non-free recommended\nとあったので，\nsudo apt install -y nvidia-driver-580-open\ncuda toolkit\n公式のインストール手順に従い以下を実行\n% wget https://developer.download.nvidia.com/compute/cuda/repos/ubuntu2404/x86_64/cuda-ubuntu2404.pin\n% sudo mv cuda-ubuntu2404.pin /etc/apt/preferences.d/cuda-repository-pin-600\n% wget https://developer.download.nvidia.com/compute/cuda/13.0.0/local_installers/cuda-repo-ubuntu2404-13-0-local_13.0.0-580.65.06-1_amd64.deb\n% sudo dpkg -i cuda-repo-ubuntu2404-13-0-local_13.0.0-580.65.06-1_amd64.deb\n% sudo cp /var/cuda-repo-ubuntu2404-13-0-local/cuda-*-keyring.gpg /usr/share/keyrings/\n% sudo apt-get update\n% sudo apt-get -y install cuda-toolkit-13-0\nreboot後の確認\n# GPU driver\n% nvidia-smi\n\n# CUDA compiler version\nnvcc --version\n\n# pathが通っていない場合\n/usr/local/cuda-13.0/bin/nvcc --version\n\n\n\n\n\n\nNotenvidia-smiのcuda version\n\n\n\n\nnvidia-smiで出力される CUDA Versionは実際のCUDA versionではなく，対応可能な最大バージョンを示しています\nインストールされているCUDA versionを確認する場合は nvcc --version を実行する必要があります\n\n% nvidia-smi         \nWed Aug 20 02:15:15 2025       \n+-----------------------------------------------------------------------------------------+\n| NVIDIA-SMI 580.65.06              Driver Version: 580.65.06      CUDA Version: 13.0     |\n+-----------------------------------------+------------------------+----------------------+\n| GPU  Name                 Persistence-M | Bus-Id          Disp.A | Volatile Uncorr. ECC |\n| Fan  Temp   Perf          Pwr:Usage/Cap |           Memory-Usage | GPU-Util  Compute M. |\n|                                         |                        |               MIG M. |\n|=========================================+========================+======================|\n|   0  NVIDIA GeForce RTX 4070        On  |   00000000:01:00.0  On |                  N/A |\n|  0%   33C    P5             13W /  215W |    1167MiB /  12282MiB |      4%      Default |\n|                                         |                        |                  N/A |\n+-----------------------------------------+------------------------+----------------------+\n\n\n\n\npipx関係パッケージの再インストール\n\n\n\n\n\n\nNote\n\n\n\n\nDefaultのPython versisonが変化したので基本的にpipxで導入したものは再インストールが必要です\npipx uninstallはconfigファイルまでは消去しないので，uninstall→installの手順でOKです\n\n\n\ngpustatsの再インストール\n## uninstall\n% pipx uninstall gpustat\n\n## re-intsall\n% pipx install gpustat\n\n## check command\n% gpustat\nPoetryの再インストール\n## uninstall\n% pipx uninstall poetry\n\n## re-intsall\n% pipx install poetry\n\n## check command\n% poetry --versison\n\n## extensionsのre-innstall\n% pipx inject poetry poetry-plugin-shell\n\n\nDocker Desktopの再インストール\n問題事象\n\nDocker Desktopがうまく起動しない問題が発生\n\n原因調査\nDocker自体が死んでいるかどうかをまず調査\n% docker run hello-world\n\n\nHello from Docker!\nThis message shows that your installation appears to be working correctly.\n\nTo generate this message, Docker took the following steps:\n 1. The Docker client contacted the Docker daemon.\n 2. The Docker daemon pulled the \"hello-world\" image from the Docker Hub.\n    (amd64)\n 3. The Docker daemon created a new container from that image which runs the\n    executable that produces the output you are currently reading.\n 4. The Docker daemon streamed that output to the Docker client, which sent it\n    to your terminal.\n\nTo try something more ambitious, you can run an Ubuntu container with:\n $ docker run -it ubuntu bash\n\nShare images, automate workflows, and more with a free Docker ID:\n https://hub.docker.com/\n\nFor more examples and ideas, visit:\n https://docs.docker.com/get-started/\n\n% docker --version\nDocker version 28.3.3, build 980b856\nDocker自体は問題がないと判断し，あくまでdocker-desktopがうまく起動しないとして問題に対処しました．\nトラブルシューティング\nsystemctl --failed や sudo journalctl -p err | grep \"docker\" | less コマンドを実行すると\nFailed to start app-gnome-docker\nというエラーメッセージが出現していたので，設定ファイルを消さずに再インストールを行います．\nsudo apt remove docker-desktop\nその後，Docker公式ページが配布しているDebianパッケージをダウンロードして，\nsudo apt-get install ./docker-desktop-amd64.deb\nを実行すれば終了です．\n\n\ncups-browsed serviceの無効化\ncups-browsedサービス\n\nDNS-SD を使ってネットワーク上のプリンタや USB 接続の IPP プリンタ，プリンタアプリ，リモート CUPS キューなどの印刷サービスを自動で見つけてくれるサービス\nプリンターは特に使わないのでdisableしておく\n\n手順\n# サービスのstop\n% sudo systemctl stop cups-browsed\n\n# サービスの無効化\nsudo systemctl disable cups-browsed\n\n# status確認\n% systemctl status cups-browsed   \n○ cups-browsed.service - Make remote CUPS printers available locally\n     Loaded: loaded (/usr/lib/systemd/system/cups-browsed.service; disabled; preset: enabled)\n     Active: inactive (dead)"
  },
  {
    "objectID": "posts/2025-08-16-ubuntu-upgrade/index.html#appendix-インストール後の-.debファイルの取り扱い",
    "href": "posts/2025-08-16-ubuntu-upgrade/index.html#appendix-インストール後の-.debファイルの取り扱い",
    "title": "Ubuntu 24.04.3へのupgrade",
    "section": "Appendix: インストール後の .debファイルの取り扱い",
    "text": "Appendix: インストール後の .debファイルの取り扱い\n\n\n\n\n\n\nNote.debファイルの取り扱い\n\n\n\nプログラムのインストールに必要なファイルをまとめたものが.debファイルなので，インストール後は基本的に削除してしまって問題ありません．\n\n\nUbuntuでapt-getを使ってインストールする場合，\n\n/var/cache/apt/archives に .debファイルをダウンロード\ndpkgコマンドを用いて，プログラムをインストール\n\nという流れになります．/var/cache/apt/archives以下は基本的に再インストールしたい場合などを除いて使いみちがないので削除してしまっても問題ありません． rm コマンドを用いるよりかは，\n## interactiveに結果を確認したい場合\nsudo apt clean\n\n## スクリプトで実行する場合(標準出力が簡素)\nsudo apt-get clean\nを実行してクリーンすることが推奨されます．"
  },
  {
    "objectID": "posts/2025-08-16-ubuntu-upgrade/index.html#references",
    "href": "posts/2025-08-16-ubuntu-upgrade/index.html#references",
    "title": "Ubuntu 24.04.3へのupgrade",
    "section": "References",
    "text": "References\n\nask Ubuntu &gt; Ubuntu 24.04 Nvidia drivers\naptitude Search patterns\ncups-browsed"
  },
  {
    "objectID": "posts/2025-01-28-mathmatical-modelling/index.html",
    "href": "posts/2025-01-28-mathmatical-modelling/index.html",
    "title": "数理モデルの作り方",
    "section": "",
    "text": "モデリングとは，現実の事象を説明するために実施するプロセスです．モデリングを通じて，これまで未知であった自然現象を解明したり，または解明を通じて将来の予測や，モデルに基づく意思決定を行ったりします．\nモデリングの流れとしては，\n\n単純化した仮定をたくさん立てる\n重要な変数が何であるのか明らかにする\n変数間の関係性について何かしらの仮定を考える\n\nこれらのステップを行いながら，現実の問題を数理モデルの問題に置き換えます．その後，適切な手法を用いて，モデルを解きます．解が出てきたならば，\n\nその解を現実の問題の文脈に翻訳し解釈\nモデルの解が現実のデータと一致しているかの妥当性検証\n\nを行いモデルを評価します．もしモデルの妥当性に疑念が認められたならば，仮定や変数の見直しなど定式化をやり直します．もしモデルが現実の事象に対して良い適合を示していたならば，意思決定目的関数に従ってモデル予測に基づく決定を行います．この一連の流れを表したのが (Figure 1) となります．\n\n\n\n\n\n\n\n\nflowchart BT\n    problem_setup[\"1: 解きたい現象の選択\"]\n    assumption[\"2: 仮説 & 仮定立案\"]\n    define_objective[\"3: 数理問題のモデル定式化\"]\n    solve[\"4: 数理問題を解く\"]\n    analysis[\"5: 解の意味を解釈する\"]\n    validation[\"6: モデル妥当性検証\"]\n    decision[\"7: モデルを用いた意思決定\"]\n    \n\n    subgraph problem-framing-phase[\"**phase 1: モデル定式化**\"]\n        direction TB\n        problem_setup --&gt; assumption\n        assumption --&gt; define_objective\n    end\n\n    subgraph analysis-phase[\"**phase 2: モデルを解く**\"]\n        direction LR\n        solve --&gt; analysis\n        analysis --&gt; validation\n    end\n\n    subgraph decision-phase[\"**phase 3: 意思決定**\"]\n        decision\n    end\n\n    analysis-phase --仮定/変数/モデル&lt;br&gt;の見直し--&gt; problem-framing-phase\n    problem-framing-phase ----&gt; analysis-phase\n    analysis-phase ----&gt; decision-phase\n\n\n\n\n\n\n\n\nFigure 1\n\n\n\n注意点として，なにを解きたいか？・知りたいか？がすでに決定されている状況からモデリングへというステップに入ります．なにを解くべきか？は意思決定問題の定式化や文脈に依存します．「解くべきもの・解く価値のあるもの」の議論を実施した上で，モデリングという過程に入ることを意識することが重要です．"
  },
  {
    "objectID": "posts/2025-01-28-mathmatical-modelling/index.html#モデリングのステップ",
    "href": "posts/2025-01-28-mathmatical-modelling/index.html#モデリングのステップ",
    "title": "数理モデルの作り方",
    "section": "",
    "text": "モデリングとは，現実の事象を説明するために実施するプロセスです．モデリングを通じて，これまで未知であった自然現象を解明したり，または解明を通じて将来の予測や，モデルに基づく意思決定を行ったりします．\nモデリングの流れとしては，\n\n単純化した仮定をたくさん立てる\n重要な変数が何であるのか明らかにする\n変数間の関係性について何かしらの仮定を考える\n\nこれらのステップを行いながら，現実の問題を数理モデルの問題に置き換えます．その後，適切な手法を用いて，モデルを解きます．解が出てきたならば，\n\nその解を現実の問題の文脈に翻訳し解釈\nモデルの解が現実のデータと一致しているかの妥当性検証\n\nを行いモデルを評価します．もしモデルの妥当性に疑念が認められたならば，仮定や変数の見直しなど定式化をやり直します．もしモデルが現実の事象に対して良い適合を示していたならば，意思決定目的関数に従ってモデル予測に基づく決定を行います．この一連の流れを表したのが (Figure 1) となります．\n\n\n\n\n\n\n\n\nflowchart BT\n    problem_setup[\"1: 解きたい現象の選択\"]\n    assumption[\"2: 仮説 & 仮定立案\"]\n    define_objective[\"3: 数理問題のモデル定式化\"]\n    solve[\"4: 数理問題を解く\"]\n    analysis[\"5: 解の意味を解釈する\"]\n    validation[\"6: モデル妥当性検証\"]\n    decision[\"7: モデルを用いた意思決定\"]\n    \n\n    subgraph problem-framing-phase[\"**phase 1: モデル定式化**\"]\n        direction TB\n        problem_setup --&gt; assumption\n        assumption --&gt; define_objective\n    end\n\n    subgraph analysis-phase[\"**phase 2: モデルを解く**\"]\n        direction LR\n        solve --&gt; analysis\n        analysis --&gt; validation\n    end\n\n    subgraph decision-phase[\"**phase 3: 意思決定**\"]\n        decision\n    end\n\n    analysis-phase --仮定/変数/モデル&lt;br&gt;の見直し--&gt; problem-framing-phase\n    problem-framing-phase ----&gt; analysis-phase\n    analysis-phase ----&gt; decision-phase\n\n\n\n\n\n\n\n\nFigure 1\n\n\n\n注意点として，なにを解きたいか？・知りたいか？がすでに決定されている状況からモデリングへというステップに入ります．なにを解くべきか？は意思決定問題の定式化や文脈に依存します．「解くべきもの・解く価値のあるもの」の議論を実施した上で，モデリングという過程に入ることを意識することが重要です．"
  },
  {
    "objectID": "posts/2025-04-07-inner-product/index.html",
    "href": "posts/2025-04-07-inner-product/index.html",
    "title": "ベクトル空間における内積",
    "section": "",
    "text": "\\(\\pmb{a}, \\pmb{b} \\in \\mathbb R^2\\) を空間内の２つのベクトルでいずれもゼロベクトルではないとします．原点 \\(O\\) を始点として\n\\[\n\\begin{gather}\n\\pmb{a} = \\overrightarrow{OA}\\\\\n\\pmb{b} = \\overrightarrow{OB}\n\\end{gather}\n\\]\nとなる点 \\(A, B\\) をとります．このとき，\n\\[\n\\theta = \\angle AOB\n\\]\nを ベクトル \\(\\pmb{a}, \\pmb{b}\\) の成す角 といいいます．ただし，\\(0 \\leq \\theta \\leq \\pi\\) とします．\n\n\nDefinition 1 : ベクトルの内積 \n\\[\n\\|\\pmb{a}\\|\\,\\|\\pmb{b}\\| \\cos \\theta\n\\]\nを \\(\\pmb{a}\\) と \\(\\pmb{b}\\) の内積，またはスカラー積といい，\\((\\pmb{a}, \\pmb{b})\\) や \\(\\pmb{a} \\cdot \\pmb{b}\\) で表す．\\(\\pmb{a}, \\pmb{b}\\) のいずれかがゼロベクトルの場合は\n\\[\n(\\pmb{a}, \\pmb{b}) = 0\n\\]\nとする．\n\n\n ▶  シュワルツの不等式\n内積の定義\n\\[\n(\\pmb{a}, \\pmb{b}) = \\|\\pmb{a}\\|\\,\\|\\pmb{b}\\| \\cos \\theta\n\\]\nより， \\(-1 \\leq \\cos\\theta \\leq 1\\) であるから\n\\[\n\\vert(\\pmb{a}, \\pmb{b})\\vert \\leq \\|\\pmb{a}\\|\\,\\|\\pmb{b}\\|\n\\]\nであることがわかります．証明は いろいろな三角不等式 &gt; シュワルツの不等式と三角不等式 を参考にしてください．\n ▶  直交(orthogonal)\nベクトル \\(\\pmb{a}, \\pmb{b}\\) の成す角が直角のとき，ベクトル \\(\\pmb{a}, \\pmb{b}\\) は直交すると呼びます．このとき，\\(\\cos\\theta = 0\\) であることから\n\\[\n\\pmb{a} \\perp \\pmb{b} \\Longleftrightarrow (\\pmb{a}, \\pmb{b}) = 0\n\\]\n ▶  ベクトルの角度と幾何学的理解\nベクトルの成す角の定義より\n\\[\n\\theta = \\arccos \\frac{(\\pmb a, \\pmb b)}{\\|\\pmb a\\|\\,\\|\\pmb b\\|}\n\\]\nこの定義が幾何学的に見て妥当なものかどうかを以下確認します．\nFigure 1 のように \\(\\pmb{a}, \\pmb{b}\\) を考えたとき，\\(\\pmb{b}\\) の先端から \\(\\pmb{a}\\) に対して垂線を下ろします．その足 \\(B'\\) のベクトルを \\(k\\pmb a\\) とおくと，２つのベクトルが直交 \\(\\displaystyle\\theta = \\frac{\\pi}{2}\\)するとき，その内積は \\(0\\) になることから\n\\[\n(\\pmb {b} - k\\pmb {a}, \\pmb {a}) = 0\n\\]\n内積演算の性質より\n\\[\n\\begin{align}\n&(\\pmb {a}, \\pmb {b}) = k \\|\\pmb {a}\\|^2\\\\\n&\\Rightarrow k = \\frac{(\\pmb {a}, \\pmb {b})}{\\|\\pmb {a}\\|^2} \\label{#eq-inner-angle}\n\\end{align}\n\\]\n\\(\\triangle BOB'\\) は直角三角形なので \\(\\angle BOB'\\) に対応する \\(\\cos \\theta\\) は\n\\[\n\\cos \\theta = \\frac{k\\|\\pmb a\\|}{\\|\\pmb b\\|}\n\\]\n\\(\\eqref{#eq-inner-angle}\\) をもちいると\n\\[\n\\begin{align}\n\\cos \\theta\n    &= \\frac{k\\|\\pmb a\\|}{\\|\\pmb b\\|}\\\\\n    &= \\frac{(\\pmb {a}, \\pmb {b})}{\\|\\pmb {a}\\|^2}\\frac{\\|\\pmb a\\|}{\\|\\pmb b\\|}\\\\\n    &= \\frac{(\\pmb {a}, \\pmb {b})}{\\|\\pmb a\\|\\,\\|\\pmb b\\|}\n\\end{align}\n\\]\nと整理することができ，これは Definition 1 と一致することがわかります．\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport matplotlib.patches as patches\nimport cmath\n\n\n# Define two vectors\nv0 = np.array([1, 0])\nv1 = np.array([3, 1])\nv2 = np.array([1, 3])\n\n# Calculate the angle using the dot product\ndot_product = np.dot(v1, v2)\nnorm_v1 = np.linalg.norm(v1)\nnorm_v2 = np.linalg.norm(v2)\ncos_theta_0 = np.dot(v0, v1) / (norm_v1)\ncos_theta = dot_product / (norm_v1 * norm_v2)\ntheta_rad_0 = np.arccos(cos_theta_0)\ntheta_rad = np.arccos(cos_theta)\ntheta_deg = np.degrees(theta_rad)\n\n# define projection of B into A\nv3 =  v1 * norm_v2 * cos_theta / norm_v1\n\n\n# Plot the vectors\nfig, ax = plt.subplots(figsize=(6,6))\nax.grid(True)\n\norigin = np.array([0, 0])\nax.quiver(*origin, *v1, color='r', scale=1, scale_units='xy', angles='xy')\nax.quiver(*origin, *v2, color='b', scale=1, scale_units='xy', angles='xy')\n\n# Add angle arc using a circle segment\nangle_range = np.linspace(np.arccos(cos_theta_0), theta_rad + np.arccos(cos_theta_0), 100)\narc_radius = 0.5\narc_x = arc_radius * np.cos(angle_range)\narc_y = arc_radius * np.sin(angle_range)\nax.plot(arc_x, arc_y, 'k--', linewidth=1)\nax.plot((v2[0], v3[0]), (v2[1], v3[1]), 'k--', linewidth=1)\n\n# add square box at B'\ntheta = np.angle(complex(v3[0], v3[1]))  # 60 degrees\northogonal_theta = theta + np.pi / 2  # 90° 直交\noffset = np.linalg.norm(v3)\nsize = 0.15\n# 直角マークの位置を作成（60°方向に少し移動 → 90°方向に正方形を描く）\nbase_x = offset * np.cos(theta)\nbase_y = offset * np.sin(theta)\nrect_dx = size * np.cos(orthogonal_theta)\nrect_dy = size * np.sin(orthogonal_theta)\n\n\n# 小さな直角マーク（平行四辺形を回転して表現）\nright_angle = patches.Polygon(\n    [\n        (base_x, base_y),\n        (base_x + rect_dx, base_y + rect_dy),\n        (\n            base_x + rect_dx + size * np.cos(theta),\n            base_y + rect_dy + size * np.sin(theta),\n        ),\n        (base_x + size * np.cos(theta), base_y + size * np.sin(theta)),\n    ],\n    closed=True,\n    edgecolor=\"black\",\n    facecolor=\"none\",\n)\n\nax.add_patch(right_angle)\n\n# Annotate angle\nax.text(np.median(arc_x), np.median(arc_y), f\"{theta_deg:.1f}°\", fontsize=12)\nax.text(*origin-0.1, f\"O\", fontsize=12)\nax.text(*v1, f\"A\", fontsize=12)\nax.text(*v2, f\"B\", fontsize=12)\nax.text(*v3*0.9, f\"B'\", fontsize=12)\n\n# Plot settings\nax.set_xlim(-1, 3.5)\nax.set_ylim(-1, 3.5)\nax.set_aspect('equal')\n\nax.set_title(\"Angle Between Vectors Using Inner Product\")\nax.set_xlabel(\"X\")\nax.set_ylabel(\"Y\")\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 1\n\n\n\n\n\nTheorem 1 \n２つのベクトル \\(\\pmb a, \\pmb b\\) の成分表示を \\(\\pmb a = (a_1, \\cdots, a_n), \\pmb b = (b_1, \\cdots, b_n)\\) とするとき\n\\[\n(\\pmb a, \\pmb b) = \\sum_{i=1}^n a_ib_i\n\\]\nが成り立つ．ただし，証明にあたってノルムの定義は与えられているものとする\n\\[\n\\|\\pmb a\\| = \\sqrt{a_1^2 + \\cdots + a_n^2}\n\\]\n\n\n\n\n\n\n\n\n\nNoteProof\n\n\n\n\n\n\\(\\pmb a, \\pmb b\\) のなす角を \\(\\theta\\) とすると，余弦定理より\n\\[\n\\begin{align}\n\\|\\pmb a\\|^2 + \\|\\pmb b\\|^2 - \\|\\pmb a - \\pmb b\\|^2 = 2 \\|\\pmb a\\| \\, \\|\\pmb b\\| \\cos\\theta\n\\end{align}\n\\]\nノルムの定義より\n\\[\n\\begin{gather}\n\\|\\pmb a\\|^2 = a_1^2 + \\cdots + a_n^2\\\\\n\\|\\pmb b\\|^2 = b_1^2 + \\cdots + b_n^2\\\\\n\\|\\pmb a - \\pmb b\\|^2 = (a_1 - b_1)^2 + \\cdots + (a_n - b_n)^2\n\\end{gather}\n\\]\nまた，内積の定義より\n\\[\n\\|\\pmb a\\| \\, \\|\\pmb b\\| \\cos\\theta = \\|\\pmb a\\| \\, \\|\\pmb b\\|\\frac{(\\pmb a, \\pmb b)}{\\|\\pmb a\\| \\, \\|\\pmb b\\|} = (\\pmb a, \\pmb b)\n\\]\n従って，\n\\[\n\\begin{align}\n\\|\\pmb a\\|^2 + \\|\\pmb b\\|^2 - \\|\\pmb a - \\pmb b\\|^2\n    &= 2\\sum_i a_ib_i\\\\\n    &= 2(\\pmb a, \\pmb b)\n\\end{align}\n\\]\nよって，\n\\[\n(\\pmb a, \\pmb b) = \\sum_{i=1}^n a_ib_i\n\\]\n\n\n\n\n\n\\(\\mathbb R^n\\) の属する\\(n\\)次元実ベクトル \\(\\pmb a = (a_1, \\cdots, a_n)^T, \\pmb b = (b_1, \\cdots, b_n)^T\\) を考えます．この２つのベクトルの内積は上で確認したように\n\\[\n(\\pmb a, \\pmb b) = \\sum_{i=1}^n a_ib_i\n\\]\nとなります．ここで，\\(\\pmb a, \\pmb b\\) を \\((n \\times 1)\\) 行列とみなすと\n\\[\n(\\pmb a, \\pmb b) = \\pmb a^T\\pmb b\n\\]\nと一致します．ここから\\(n\\)次元実ベクトルの内積について次の演算性質を確認することができます．\n\n\nTheorem 2 \n\\(h, k \\in \\mathbb R\\) とすると\n\\[\n\\begin{align}\n\\text{対称性:} \\quad& (\\pmb a, \\pmb b)  = (\\pmb b, \\pmb a)\\\\\n\\text{線形性:} \\quad& (h\\pmb a + k\\pmb a^\\prime, \\pmb b)  = h(\\pmb a, \\pmb b) + k(\\pmb a^\\prime, \\pmb b)\\\\\n& (\\pmb a, h\\pmb b + k\\pmb b^\\prime)  = h(\\pmb a, \\pmb b) + k(\\pmb a, \\pmb b^\\prime)\\\\\n\\label{#eq-positivity}\\text{正値性:} \\quad& (\\pmb a, \\pmb a)  \\geq 0\n\\end{align}\n\\]\n\n\n\n\n\n\n\n\n\nNoteProof\n\n\n\n\n\n ▶  対称性\n\\[\n\\begin{align}\n(\\pmb a, \\pmb b)\n    &= \\pmb a^T\\pmb b\\\\\n    &= (\\pmb a^T\\pmb b)^T\\\\\n    &= (\\pmb b^T\\pmb a)\\\\\n    &= (\\pmb b, \\pmb a)\n\\end{align}\n\\]\n ▶  線形性 \n\\[\n\\begin{align}\n(h\\pmb a + k\\pmb a^\\prime, \\pmb b)\n    &= (h\\pmb a + k\\pmb a^\\prime)^T\\pmb b\\\\\n    &= h\\pmb a^T \\pmb b + k{\\pmb a^\\prime}^T \\pmb b\\\\\n    &= h(\\pmb a^T \\pmb b) + k({\\pmb a^\\prime}^T \\pmb b)\\\\\n    &= h(\\pmb a, \\pmb b) + k(\\pmb a^\\prime, \\pmb b)\n\\end{align}\n\\]\n ▶  正値性\n\\[\n\\begin{align}\n(\\pmb a, \\pmb a)\n    &= \\pmb a^T\\pmb a\\\\\n    &= \\sum_i a_i^2\n\\end{align}\n\\]\n\\(a_i^2 \\geq 0 \\, (\\forall i \\in (1, \\cdots, n))\\) であるので \\((\\pmb a, \\pmb a) \\geq 0\\) が成立します．また等号成立条件は\n\\[\na_i^2 = 0 \\, (\\forall i \\in (1, \\cdots, n)) \\Leftrightarrow a_i = 0 \\, (\\forall i \\in (1, \\cdots, n))\n\\]\n従って，\n\\[\n(\\pmb a, \\pmb a) = 0 \\Leftrightarrow \\pmb a = \\pmb 0\n\\]\n\n\n\n\n\n\n\n\n\nTip🍵 計量ベクトル空間\n\n\n\n\n内積の定義されたベクトル空間を計量ベクトル空間といいます．\n\n\n\n\n\n\n\n\nDefinition 2 : ノルム \n計量ベクトル空間 \\(V\\) の任意のベクトル \\(\\pmb a\\) に対して，\\(\\sqrt{(\\pmb a, \\pmb a)}\\) をベクトル \\(\\pmb a\\) の長さ, またはL2ノルムといい，\\(\\|\\pmb a\\|\\) と表す．\n\n\n内積の正値性 \\(\\eqref{#eq-positivity}\\) より \\(\\|\\pmb a\\| \\geq 0\\) が成り立ち，長さ の概念（長さが負にならない）と対応していることがわかります．\n\n\nTheorem 3 \n計量ベクトル空間 \\(V\\) の内積と長さについて，\\(\\pmb a, \\pmb b \\in V, k\\in \\mathbb R\\) としたとき以下が成り立つ\n\\[\n\\begin{align}\n&\\|\\pmb a\\| \\geq 0\\\\\n&\\|k\\pmb a\\| = |k\\||\\pmb a\\|\\\\\n&(\\pmb a,\\pmb b) = \\frac{1}{2}\\{\\|\\pmb a + \\pmb b\\|^2 - \\|\\pmb a\\|^2 - \\|\\pmb b\\|^2\\} = \\frac{1}{2}\\{\\|\\pmb a\\|^2 + \\|\\pmb b\\|^2 - \\|\\pmb a - \\pmb b\\|^2 \\}\\\\\n&\\|\\pmb a + \\pmb b\\|^2 + \\|\\pmb a - \\pmb b\\|^2 = 2(\\|\\pmb a\\|^2 + \\|\\pmb b\\|^2)\n\\end{align}\n\\]\n\n\n\n\n\n\n\n\n\nNoteProof\n\n\n\n\n\n ▶  \\(\\|k\\pmb a\\| = |k\\||\\pmb a\\|\\)\n\\[\n\\begin{align}\n\\|k\\pmb a\\|^2\n    &= (k\\pmb a, k\\pmb a)\\\\\n    &= k^2 (\\pmb a, \\pmb a)\\\\\n    &= k^2 \\|\\pmb a\\|^2\n\\end{align}\n\\]\n従って，\n\\[\n\\begin{align}\n\\|k\\pmb a\\|\n    &= \\sqrt{\\|k\\pmb a\\|^2}\\\\\n    &= \\sqrt{k^2 \\|\\pmb a\\|^2}\\\\\n    &= |k\\||\\pmb a\\|\n\\end{align}\n\\]\n ▶  \\((\\pmb a,\\pmb b) = \\frac{1}{2}\\{\\|\\pmb a + \\pmb b\\|^2 - \\|\\pmb a\\|^2 - \\|\\pmb b\\|^2\\}\\)\n\\[\n\\begin{align}\n\\|\\pmb a + \\pmb b\\|^2\n    &= (\\pmb a + \\pmb b, \\pmb a + \\pmb b)\\\\\n    &= (\\pmb a, \\pmb a) + 2(\\pmb a, \\pmb b) + (\\pmb b, \\pmb b)\\\\\n    &= \\|\\pmb a\\|^2 + \\|\\pmb b\\|^2 + 2(\\pmb a, \\pmb b)\n\\end{align}\n\\]\n従って，\n\\[\n(\\pmb a,\\pmb b) = \\frac{1}{2}\\{\\|\\pmb a + \\pmb b\\|^2 - \\|\\pmb a\\|^2 - \\|\\pmb b\\|^2\\}\n\\]\n ▶  \\((\\pmb a,\\pmb b) = \\frac{1}{2}\\{\\|\\pmb a\\|^2 + \\|\\pmb b\\|^2 - \\|\\pmb a - \\pmb b\\|^2 \\}\\)\n\\[\n\\begin{align}\n\\|\\pmb a - \\pmb b\\|^2\n    &= (\\pmb a - \\pmb b, \\pmb a - \\pmb b)\\\\\n    &= \\|\\pmb a\\|^2 + \\|\\pmb b\\|^2 -2(\\pmb a, \\pmb b)\n\\end{align}\n\\]\n従って，\n\\[\n(\\pmb a,\\pmb b) = \\frac{1}{2}\\{\\|\\pmb a\\|^2 + \\|\\pmb b\\|^2 - \\|\\pmb a - \\pmb b\\|^2 \\}\n\\]\n ▶  \\(\\|\\pmb a + \\pmb b\\|^2 + \\|\\pmb a - \\pmb b\\|^2 = 2(\\|\\pmb a\\|^2 + \\|\\pmb b\\|^2)\\)\n\\[\n\\begin{align}\n\\|\\pmb a + \\pmb b\\|^2 & = \\|\\pmb a\\|^2 + \\|\\pmb b\\|^2  + 2(\\pmb a, \\pmb b)\\\\\n\\|\\pmb a - \\pmb b\\|^2 & = \\|\\pmb a\\|^2 + \\|\\pmb b\\|^2 - 2(\\pmb a, \\pmb b)\n\\end{align}\n\\]\n両辺を足し合わせると\n\\[\n\\|\\pmb a + \\pmb b\\|^2 + \\|\\pmb a - \\pmb b\\|^2 = 2(\\|\\pmb a\\|^2 + \\|\\pmb b\\|^2)\n\\]\n\n\n\n ▶  ピタゴラスの定理\n\\(n\\) 次元実ベクトル空間 \\(V\\) に対して，\\(\\pmb a, \\pmb b \\in V\\) を考えます．\\(\\pmb a\\perp \\pmb b\\) が成立する場合，\n\\[\n\\begin{align}\n\\|\\pmb a + \\pmb b\\|^2\n    &= (\\pmb a + \\pmb b, \\pmb a + \\pmb b)\\\\\n    &= \\|\\pmb a\\|^2 + \\|\\pmb b\\|^2 + 2(\\pmb a, \\pmb b)\\\\\n    &= \\|\\pmb a\\|^2 + \\|\\pmb b\\|^2\n\\end{align}\n\\]\nこれは \\(\\pmb a\\perp \\pmb b \\Leftrightarrow (\\pmb a, \\pmb b) = 0\\) であることからわかります．\n ▶  一般化されたピタゴラスの定理\n\\(\\pmb a_1, \\cdots, \\pmb a_n \\in V\\) が互いに直交している場合，\n\\[\n\\|\\pmb a_1 + \\cdots + \\pmb a_n \\|^2 = \\|\\pmb a_1 \\|^2 + \\cdots + \\|\\pmb a_n \\|^2\n\\]"
  },
  {
    "objectID": "posts/2025-04-07-inner-product/index.html#ベクトルの成す角と内積",
    "href": "posts/2025-04-07-inner-product/index.html#ベクトルの成す角と内積",
    "title": "ベクトル空間における内積",
    "section": "",
    "text": "\\(\\pmb{a}, \\pmb{b} \\in \\mathbb R^2\\) を空間内の２つのベクトルでいずれもゼロベクトルではないとします．原点 \\(O\\) を始点として\n\\[\n\\begin{gather}\n\\pmb{a} = \\overrightarrow{OA}\\\\\n\\pmb{b} = \\overrightarrow{OB}\n\\end{gather}\n\\]\nとなる点 \\(A, B\\) をとります．このとき，\n\\[\n\\theta = \\angle AOB\n\\]\nを ベクトル \\(\\pmb{a}, \\pmb{b}\\) の成す角 といいいます．ただし，\\(0 \\leq \\theta \\leq \\pi\\) とします．\n\n\nDefinition 1 : ベクトルの内積 \n\\[\n\\|\\pmb{a}\\|\\,\\|\\pmb{b}\\| \\cos \\theta\n\\]\nを \\(\\pmb{a}\\) と \\(\\pmb{b}\\) の内積，またはスカラー積といい，\\((\\pmb{a}, \\pmb{b})\\) や \\(\\pmb{a} \\cdot \\pmb{b}\\) で表す．\\(\\pmb{a}, \\pmb{b}\\) のいずれかがゼロベクトルの場合は\n\\[\n(\\pmb{a}, \\pmb{b}) = 0\n\\]\nとする．\n\n\n ▶  シュワルツの不等式\n内積の定義\n\\[\n(\\pmb{a}, \\pmb{b}) = \\|\\pmb{a}\\|\\,\\|\\pmb{b}\\| \\cos \\theta\n\\]\nより， \\(-1 \\leq \\cos\\theta \\leq 1\\) であるから\n\\[\n\\vert(\\pmb{a}, \\pmb{b})\\vert \\leq \\|\\pmb{a}\\|\\,\\|\\pmb{b}\\|\n\\]\nであることがわかります．証明は いろいろな三角不等式 &gt; シュワルツの不等式と三角不等式 を参考にしてください．\n ▶  直交(orthogonal)\nベクトル \\(\\pmb{a}, \\pmb{b}\\) の成す角が直角のとき，ベクトル \\(\\pmb{a}, \\pmb{b}\\) は直交すると呼びます．このとき，\\(\\cos\\theta = 0\\) であることから\n\\[\n\\pmb{a} \\perp \\pmb{b} \\Longleftrightarrow (\\pmb{a}, \\pmb{b}) = 0\n\\]\n ▶  ベクトルの角度と幾何学的理解\nベクトルの成す角の定義より\n\\[\n\\theta = \\arccos \\frac{(\\pmb a, \\pmb b)}{\\|\\pmb a\\|\\,\\|\\pmb b\\|}\n\\]\nこの定義が幾何学的に見て妥当なものかどうかを以下確認します．\nFigure 1 のように \\(\\pmb{a}, \\pmb{b}\\) を考えたとき，\\(\\pmb{b}\\) の先端から \\(\\pmb{a}\\) に対して垂線を下ろします．その足 \\(B'\\) のベクトルを \\(k\\pmb a\\) とおくと，２つのベクトルが直交 \\(\\displaystyle\\theta = \\frac{\\pi}{2}\\)するとき，その内積は \\(0\\) になることから\n\\[\n(\\pmb {b} - k\\pmb {a}, \\pmb {a}) = 0\n\\]\n内積演算の性質より\n\\[\n\\begin{align}\n&(\\pmb {a}, \\pmb {b}) = k \\|\\pmb {a}\\|^2\\\\\n&\\Rightarrow k = \\frac{(\\pmb {a}, \\pmb {b})}{\\|\\pmb {a}\\|^2} \\label{#eq-inner-angle}\n\\end{align}\n\\]\n\\(\\triangle BOB'\\) は直角三角形なので \\(\\angle BOB'\\) に対応する \\(\\cos \\theta\\) は\n\\[\n\\cos \\theta = \\frac{k\\|\\pmb a\\|}{\\|\\pmb b\\|}\n\\]\n\\(\\eqref{#eq-inner-angle}\\) をもちいると\n\\[\n\\begin{align}\n\\cos \\theta\n    &= \\frac{k\\|\\pmb a\\|}{\\|\\pmb b\\|}\\\\\n    &= \\frac{(\\pmb {a}, \\pmb {b})}{\\|\\pmb {a}\\|^2}\\frac{\\|\\pmb a\\|}{\\|\\pmb b\\|}\\\\\n    &= \\frac{(\\pmb {a}, \\pmb {b})}{\\|\\pmb a\\|\\,\\|\\pmb b\\|}\n\\end{align}\n\\]\nと整理することができ，これは Definition 1 と一致することがわかります．\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport matplotlib.patches as patches\nimport cmath\n\n\n# Define two vectors\nv0 = np.array([1, 0])\nv1 = np.array([3, 1])\nv2 = np.array([1, 3])\n\n# Calculate the angle using the dot product\ndot_product = np.dot(v1, v2)\nnorm_v1 = np.linalg.norm(v1)\nnorm_v2 = np.linalg.norm(v2)\ncos_theta_0 = np.dot(v0, v1) / (norm_v1)\ncos_theta = dot_product / (norm_v1 * norm_v2)\ntheta_rad_0 = np.arccos(cos_theta_0)\ntheta_rad = np.arccos(cos_theta)\ntheta_deg = np.degrees(theta_rad)\n\n# define projection of B into A\nv3 =  v1 * norm_v2 * cos_theta / norm_v1\n\n\n# Plot the vectors\nfig, ax = plt.subplots(figsize=(6,6))\nax.grid(True)\n\norigin = np.array([0, 0])\nax.quiver(*origin, *v1, color='r', scale=1, scale_units='xy', angles='xy')\nax.quiver(*origin, *v2, color='b', scale=1, scale_units='xy', angles='xy')\n\n# Add angle arc using a circle segment\nangle_range = np.linspace(np.arccos(cos_theta_0), theta_rad + np.arccos(cos_theta_0), 100)\narc_radius = 0.5\narc_x = arc_radius * np.cos(angle_range)\narc_y = arc_radius * np.sin(angle_range)\nax.plot(arc_x, arc_y, 'k--', linewidth=1)\nax.plot((v2[0], v3[0]), (v2[1], v3[1]), 'k--', linewidth=1)\n\n# add square box at B'\ntheta = np.angle(complex(v3[0], v3[1]))  # 60 degrees\northogonal_theta = theta + np.pi / 2  # 90° 直交\noffset = np.linalg.norm(v3)\nsize = 0.15\n# 直角マークの位置を作成（60°方向に少し移動 → 90°方向に正方形を描く）\nbase_x = offset * np.cos(theta)\nbase_y = offset * np.sin(theta)\nrect_dx = size * np.cos(orthogonal_theta)\nrect_dy = size * np.sin(orthogonal_theta)\n\n\n# 小さな直角マーク（平行四辺形を回転して表現）\nright_angle = patches.Polygon(\n    [\n        (base_x, base_y),\n        (base_x + rect_dx, base_y + rect_dy),\n        (\n            base_x + rect_dx + size * np.cos(theta),\n            base_y + rect_dy + size * np.sin(theta),\n        ),\n        (base_x + size * np.cos(theta), base_y + size * np.sin(theta)),\n    ],\n    closed=True,\n    edgecolor=\"black\",\n    facecolor=\"none\",\n)\n\nax.add_patch(right_angle)\n\n# Annotate angle\nax.text(np.median(arc_x), np.median(arc_y), f\"{theta_deg:.1f}°\", fontsize=12)\nax.text(*origin-0.1, f\"O\", fontsize=12)\nax.text(*v1, f\"A\", fontsize=12)\nax.text(*v2, f\"B\", fontsize=12)\nax.text(*v3*0.9, f\"B'\", fontsize=12)\n\n# Plot settings\nax.set_xlim(-1, 3.5)\nax.set_ylim(-1, 3.5)\nax.set_aspect('equal')\n\nax.set_title(\"Angle Between Vectors Using Inner Product\")\nax.set_xlabel(\"X\")\nax.set_ylabel(\"Y\")\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 1\n\n\n\n\n\nTheorem 1 \n２つのベクトル \\(\\pmb a, \\pmb b\\) の成分表示を \\(\\pmb a = (a_1, \\cdots, a_n), \\pmb b = (b_1, \\cdots, b_n)\\) とするとき\n\\[\n(\\pmb a, \\pmb b) = \\sum_{i=1}^n a_ib_i\n\\]\nが成り立つ．ただし，証明にあたってノルムの定義は与えられているものとする\n\\[\n\\|\\pmb a\\| = \\sqrt{a_1^2 + \\cdots + a_n^2}\n\\]\n\n\n\n\n\n\n\n\n\nNoteProof\n\n\n\n\n\n\\(\\pmb a, \\pmb b\\) のなす角を \\(\\theta\\) とすると，余弦定理より\n\\[\n\\begin{align}\n\\|\\pmb a\\|^2 + \\|\\pmb b\\|^2 - \\|\\pmb a - \\pmb b\\|^2 = 2 \\|\\pmb a\\| \\, \\|\\pmb b\\| \\cos\\theta\n\\end{align}\n\\]\nノルムの定義より\n\\[\n\\begin{gather}\n\\|\\pmb a\\|^2 = a_1^2 + \\cdots + a_n^2\\\\\n\\|\\pmb b\\|^2 = b_1^2 + \\cdots + b_n^2\\\\\n\\|\\pmb a - \\pmb b\\|^2 = (a_1 - b_1)^2 + \\cdots + (a_n - b_n)^2\n\\end{gather}\n\\]\nまた，内積の定義より\n\\[\n\\|\\pmb a\\| \\, \\|\\pmb b\\| \\cos\\theta = \\|\\pmb a\\| \\, \\|\\pmb b\\|\\frac{(\\pmb a, \\pmb b)}{\\|\\pmb a\\| \\, \\|\\pmb b\\|} = (\\pmb a, \\pmb b)\n\\]\n従って，\n\\[\n\\begin{align}\n\\|\\pmb a\\|^2 + \\|\\pmb b\\|^2 - \\|\\pmb a - \\pmb b\\|^2\n    &= 2\\sum_i a_ib_i\\\\\n    &= 2(\\pmb a, \\pmb b)\n\\end{align}\n\\]\nよって，\n\\[\n(\\pmb a, \\pmb b) = \\sum_{i=1}^n a_ib_i\n\\]\n\n\n\n\n\n\\(\\mathbb R^n\\) の属する\\(n\\)次元実ベクトル \\(\\pmb a = (a_1, \\cdots, a_n)^T, \\pmb b = (b_1, \\cdots, b_n)^T\\) を考えます．この２つのベクトルの内積は上で確認したように\n\\[\n(\\pmb a, \\pmb b) = \\sum_{i=1}^n a_ib_i\n\\]\nとなります．ここで，\\(\\pmb a, \\pmb b\\) を \\((n \\times 1)\\) 行列とみなすと\n\\[\n(\\pmb a, \\pmb b) = \\pmb a^T\\pmb b\n\\]\nと一致します．ここから\\(n\\)次元実ベクトルの内積について次の演算性質を確認することができます．\n\n\nTheorem 2 \n\\(h, k \\in \\mathbb R\\) とすると\n\\[\n\\begin{align}\n\\text{対称性:} \\quad& (\\pmb a, \\pmb b)  = (\\pmb b, \\pmb a)\\\\\n\\text{線形性:} \\quad& (h\\pmb a + k\\pmb a^\\prime, \\pmb b)  = h(\\pmb a, \\pmb b) + k(\\pmb a^\\prime, \\pmb b)\\\\\n& (\\pmb a, h\\pmb b + k\\pmb b^\\prime)  = h(\\pmb a, \\pmb b) + k(\\pmb a, \\pmb b^\\prime)\\\\\n\\label{#eq-positivity}\\text{正値性:} \\quad& (\\pmb a, \\pmb a)  \\geq 0\n\\end{align}\n\\]\n\n\n\n\n\n\n\n\n\nNoteProof\n\n\n\n\n\n ▶  対称性\n\\[\n\\begin{align}\n(\\pmb a, \\pmb b)\n    &= \\pmb a^T\\pmb b\\\\\n    &= (\\pmb a^T\\pmb b)^T\\\\\n    &= (\\pmb b^T\\pmb a)\\\\\n    &= (\\pmb b, \\pmb a)\n\\end{align}\n\\]\n ▶  線形性 \n\\[\n\\begin{align}\n(h\\pmb a + k\\pmb a^\\prime, \\pmb b)\n    &= (h\\pmb a + k\\pmb a^\\prime)^T\\pmb b\\\\\n    &= h\\pmb a^T \\pmb b + k{\\pmb a^\\prime}^T \\pmb b\\\\\n    &= h(\\pmb a^T \\pmb b) + k({\\pmb a^\\prime}^T \\pmb b)\\\\\n    &= h(\\pmb a, \\pmb b) + k(\\pmb a^\\prime, \\pmb b)\n\\end{align}\n\\]\n ▶  正値性\n\\[\n\\begin{align}\n(\\pmb a, \\pmb a)\n    &= \\pmb a^T\\pmb a\\\\\n    &= \\sum_i a_i^2\n\\end{align}\n\\]\n\\(a_i^2 \\geq 0 \\, (\\forall i \\in (1, \\cdots, n))\\) であるので \\((\\pmb a, \\pmb a) \\geq 0\\) が成立します．また等号成立条件は\n\\[\na_i^2 = 0 \\, (\\forall i \\in (1, \\cdots, n)) \\Leftrightarrow a_i = 0 \\, (\\forall i \\in (1, \\cdots, n))\n\\]\n従って，\n\\[\n(\\pmb a, \\pmb a) = 0 \\Leftrightarrow \\pmb a = \\pmb 0\n\\]\n\n\n\n\n\n\n\n\n\nTip🍵 計量ベクトル空間\n\n\n\n\n内積の定義されたベクトル空間を計量ベクトル空間といいます．\n\n\n\n\n\n\n\n\nDefinition 2 : ノルム \n計量ベクトル空間 \\(V\\) の任意のベクトル \\(\\pmb a\\) に対して，\\(\\sqrt{(\\pmb a, \\pmb a)}\\) をベクトル \\(\\pmb a\\) の長さ, またはL2ノルムといい，\\(\\|\\pmb a\\|\\) と表す．\n\n\n内積の正値性 \\(\\eqref{#eq-positivity}\\) より \\(\\|\\pmb a\\| \\geq 0\\) が成り立ち，長さ の概念（長さが負にならない）と対応していることがわかります．\n\n\nTheorem 3 \n計量ベクトル空間 \\(V\\) の内積と長さについて，\\(\\pmb a, \\pmb b \\in V, k\\in \\mathbb R\\) としたとき以下が成り立つ\n\\[\n\\begin{align}\n&\\|\\pmb a\\| \\geq 0\\\\\n&\\|k\\pmb a\\| = |k\\||\\pmb a\\|\\\\\n&(\\pmb a,\\pmb b) = \\frac{1}{2}\\{\\|\\pmb a + \\pmb b\\|^2 - \\|\\pmb a\\|^2 - \\|\\pmb b\\|^2\\} = \\frac{1}{2}\\{\\|\\pmb a\\|^2 + \\|\\pmb b\\|^2 - \\|\\pmb a - \\pmb b\\|^2 \\}\\\\\n&\\|\\pmb a + \\pmb b\\|^2 + \\|\\pmb a - \\pmb b\\|^2 = 2(\\|\\pmb a\\|^2 + \\|\\pmb b\\|^2)\n\\end{align}\n\\]\n\n\n\n\n\n\n\n\n\nNoteProof\n\n\n\n\n\n ▶  \\(\\|k\\pmb a\\| = |k\\||\\pmb a\\|\\)\n\\[\n\\begin{align}\n\\|k\\pmb a\\|^2\n    &= (k\\pmb a, k\\pmb a)\\\\\n    &= k^2 (\\pmb a, \\pmb a)\\\\\n    &= k^2 \\|\\pmb a\\|^2\n\\end{align}\n\\]\n従って，\n\\[\n\\begin{align}\n\\|k\\pmb a\\|\n    &= \\sqrt{\\|k\\pmb a\\|^2}\\\\\n    &= \\sqrt{k^2 \\|\\pmb a\\|^2}\\\\\n    &= |k\\||\\pmb a\\|\n\\end{align}\n\\]\n ▶  \\((\\pmb a,\\pmb b) = \\frac{1}{2}\\{\\|\\pmb a + \\pmb b\\|^2 - \\|\\pmb a\\|^2 - \\|\\pmb b\\|^2\\}\\)\n\\[\n\\begin{align}\n\\|\\pmb a + \\pmb b\\|^2\n    &= (\\pmb a + \\pmb b, \\pmb a + \\pmb b)\\\\\n    &= (\\pmb a, \\pmb a) + 2(\\pmb a, \\pmb b) + (\\pmb b, \\pmb b)\\\\\n    &= \\|\\pmb a\\|^2 + \\|\\pmb b\\|^2 + 2(\\pmb a, \\pmb b)\n\\end{align}\n\\]\n従って，\n\\[\n(\\pmb a,\\pmb b) = \\frac{1}{2}\\{\\|\\pmb a + \\pmb b\\|^2 - \\|\\pmb a\\|^2 - \\|\\pmb b\\|^2\\}\n\\]\n ▶  \\((\\pmb a,\\pmb b) = \\frac{1}{2}\\{\\|\\pmb a\\|^2 + \\|\\pmb b\\|^2 - \\|\\pmb a - \\pmb b\\|^2 \\}\\)\n\\[\n\\begin{align}\n\\|\\pmb a - \\pmb b\\|^2\n    &= (\\pmb a - \\pmb b, \\pmb a - \\pmb b)\\\\\n    &= \\|\\pmb a\\|^2 + \\|\\pmb b\\|^2 -2(\\pmb a, \\pmb b)\n\\end{align}\n\\]\n従って，\n\\[\n(\\pmb a,\\pmb b) = \\frac{1}{2}\\{\\|\\pmb a\\|^2 + \\|\\pmb b\\|^2 - \\|\\pmb a - \\pmb b\\|^2 \\}\n\\]\n ▶  \\(\\|\\pmb a + \\pmb b\\|^2 + \\|\\pmb a - \\pmb b\\|^2 = 2(\\|\\pmb a\\|^2 + \\|\\pmb b\\|^2)\\)\n\\[\n\\begin{align}\n\\|\\pmb a + \\pmb b\\|^2 & = \\|\\pmb a\\|^2 + \\|\\pmb b\\|^2  + 2(\\pmb a, \\pmb b)\\\\\n\\|\\pmb a - \\pmb b\\|^2 & = \\|\\pmb a\\|^2 + \\|\\pmb b\\|^2 - 2(\\pmb a, \\pmb b)\n\\end{align}\n\\]\n両辺を足し合わせると\n\\[\n\\|\\pmb a + \\pmb b\\|^2 + \\|\\pmb a - \\pmb b\\|^2 = 2(\\|\\pmb a\\|^2 + \\|\\pmb b\\|^2)\n\\]\n\n\n\n ▶  ピタゴラスの定理\n\\(n\\) 次元実ベクトル空間 \\(V\\) に対して，\\(\\pmb a, \\pmb b \\in V\\) を考えます．\\(\\pmb a\\perp \\pmb b\\) が成立する場合，\n\\[\n\\begin{align}\n\\|\\pmb a + \\pmb b\\|^2\n    &= (\\pmb a + \\pmb b, \\pmb a + \\pmb b)\\\\\n    &= \\|\\pmb a\\|^2 + \\|\\pmb b\\|^2 + 2(\\pmb a, \\pmb b)\\\\\n    &= \\|\\pmb a\\|^2 + \\|\\pmb b\\|^2\n\\end{align}\n\\]\nこれは \\(\\pmb a\\perp \\pmb b \\Leftrightarrow (\\pmb a, \\pmb b) = 0\\) であることからわかります．\n ▶  一般化されたピタゴラスの定理\n\\(\\pmb a_1, \\cdots, \\pmb a_n \\in V\\) が互いに直交している場合，\n\\[\n\\|\\pmb a_1 + \\cdots + \\pmb a_n \\|^2 = \\|\\pmb a_1 \\|^2 + \\cdots + \\|\\pmb a_n \\|^2\n\\]"
  },
  {
    "objectID": "posts/2025-04-07-inner-product/index.html#エルミート内積",
    "href": "posts/2025-04-07-inner-product/index.html#エルミート内積",
    "title": "ベクトル空間における内積",
    "section": "エルミート内積",
    "text": "エルミート内積\n実数上のベクトル空間の内積に相当するものを複素数上のベクトル空間で考えます．\\(\\pmb a \\in \\mathbb C^2\\) について実数上のベクトル空間の内積と同じように考えると\n\\[\n\\begin{align}\n\\pmb a &= (1 + 2i, 0)\\\\\n(\\pmb a, \\pmb a) &= 1 - 4 + 4i = -3 + 4i\n\\end{align}\n\\]\nとなり，正値性 \\((\\pmb a, \\pmb a)\\geq 0\\) が崩れてしまい，長さが定義できなくなるという問題が発生してしまいます．そこで \\(\\mathbb C^n\\) 上のベクトル空間についての内積は\n\\[\n(\\pmb a, \\pmb b) = \\pmb a^T\\overline{\\pmb b} =  a_1\\overline{b_1} + a_2\\overline{b_2} + \\cdots + a_n\\overline{b_n}\n\\]\nによって定義します(\\(\\overline b_j\\) は \\(b_j\\) の共役複素数)．このように定義した場合\n\n\n\n\n\n\nNoteProperty: エルミート内積の性質\n\n\n\n\\(\\pmb a, \\pmb b, \\pmb c\\in V\\), \\(k\\in C\\) のとき，\n\\[\n\\begin{align}\n&(\\pmb a, \\pmb b) = \\overline{(\\pmb b, \\pmb a)}\\\\\n&(\\pmb a + \\pmb b, \\pmb c) = (\\pmb a, \\pmb c) + (\\pmb b, \\pmb c)\\\\\n&(\\pmb a, \\pmb b + \\pmb c) = (\\pmb a, \\pmb b) + (\\pmb a, \\pmb c)\\\\\n&(k\\pmb a, \\pmb b) = k(\\pmb a, \\pmb b)\\\\\n&(\\pmb a, k\\pmb b) = \\overline k(\\pmb a, \\pmb b)\\\\\n&(\\pmb a, \\pmb a) \\in \\mathbb R \\text{ であり } (\\pmb a, \\pmb a) \\geq 0, (\\pmb a, \\pmb a) = 0 \\Leftrightarrow \\pmb a = \\pmb 0\n\\end{align}\n\\]\n\n\n１つ目の性質はエルミート性や共役対称性と呼ばれますが，以下のように確認することができます\n\\[\n\\begin{align}\n\\overline{(\\pmb b, \\pmb a)}\n    &= \\sum_i \\overline{b_i \\overline{a_i}}\\\\\n    &= \\sum_i \\overline{b_i} a_i\\\\\n    &= \\sum_i a_i\\overline{b_i} \\\\\n    &= (\\pmb a, \\pmb b)\n\\end{align}\n\\]\n ▶  \\(\\mathbb C^n\\) における直交\n\\(\\mathbb C^n\\) の場合，内積 \\((\\pmb a, \\pmb b)\\) は一般に複素数であって実数とは限りません．そのため，ベクトルの成す角は \\(\\mathbb R^n\\) のようには定義できません． しかし，\\((\\pmb a, \\pmb b) = 0\\) のとき，\\(\\pmb a\\perp \\pmb b\\) ということにすれば，直交という概念だけは定義できます．\n\n\nTheorem 4 : シュワルツの不等式 \n\\(\\mathbb C^n\\) の任意のベクトル \\(\\pmb a, \\pmb b\\) に対し，次が成り立つ．\n\\[\n\\|(\\pmb a, \\pmb b)\\| \\leq \\|\\pmb a\\|\\|\\pmb b\\|\n\\]\n\n\n\n\n\n\n\n\n\nNoteProof\n\n\n\n\n\n\\(x, y \\in \\mathbb C\\) とすると，エルミート内積の正値性より\n\\[\n\\begin{align}\n0\n    &\\leq (x\\pmb a + y\\pmb b, x\\pmb a + y\\pmb b)\\\\\n    &= |x|^2(\\pmb a, \\pmb a) + x \\overline y (\\pmb a, \\pmb b) + \\overline x y (\\pmb b, \\pmb a) + |y|^2(\\pmb b, \\pmb b)\n\\end{align}\n\\]\nここで，\\(x = (\\pmb b, \\pmb b), y = - (\\pmb a, \\pmb b)\\) とすると，\n\\[\n\\begin{align}\n&|x|^2(\\pmb a, \\pmb a) + x \\overline y (\\pmb a, \\pmb b) + \\overline x y (\\pmb b, \\pmb a) + |y|^2(\\pmb b, \\pmb b)\\\\\n    &= (\\pmb b, \\pmb b)\\overline{(\\pmb b, \\pmb b)}(\\pmb a, \\pmb a) - (\\pmb b, \\pmb b)\\overline{(\\pmb a, \\pmb b)}(\\pmb a, \\pmb b) - \\overline{(\\pmb b, \\pmb b)}(\\pmb a, \\pmb b)(\\pmb b, \\pmb a) + (\\pmb a, \\pmb b)\\overline{(\\pmb a, \\pmb b)}(\\pmb b, \\pmb b)\\\\\\\n    &= (\\pmb b, \\pmb b)(\\pmb b, \\pmb b)(\\pmb a, \\pmb a) - (\\pmb b, \\pmb b)\\|(\\pmb a, \\pmb b)\\|^2 - (\\pmb b, \\pmb b)\\|(\\pmb a, \\pmb b)\\|^2 + (\\pmb b, \\pmb b)\\|(\\pmb a, \\pmb b)\\|^2\\\\\n    &= 2((\\pmb b, \\pmb b)(\\pmb b, \\pmb b)(\\pmb a, \\pmb a) - (\\pmb b, \\pmb b)\\|(\\pmb a, \\pmb b)\\|^2)\n\\end{align}\n\\]\n従って，\n\\[\n0 \\leq (\\pmb b, \\pmb b) \\{(\\pmb b, \\pmb b)(\\pmb a, \\pmb a) - \\|(\\pmb a, \\pmb b)\\|^2\\}\n\\]\n\\(\\pmb b \\neq \\pmb 0\\) なら \\((\\pmb b, \\pmb b) &gt; 0\\) であるので\n\\[\n\\|(\\pmb a, \\pmb b)\\|^2 \\leq \\|\\pmb a \\|^2\\|\\pmb b \\|^2 \\Rightarrow \\|(\\pmb a, \\pmb b)\\| \\leq \\|\\pmb a\\|\\|\\pmb b\\|\n\\]\n\n\n\n\nExample 1 : 関数空間 \n実数の区間 \\([a, b]\\) で定義され，\\(K\\) の値を取る連続関数全体の空間 \\(U\\) において，\\(f, g\\in U\\) に対し，\n\\[\n(f, g) = \\int^b_a f(x) \\overline{g(x)} dx\n\\]\nと定めると，これは内積となる．内積となることからSchwarzの不等式が適応できるので，次の不等式を得ることができます\n\\[\n\\begin{align}\n\\|(f, g)\\| &\\leq \\sqrt{(f, f)}\\sqrt{(g, g)}\\\\[5pt]\n\\Rightarrow \\left\\|\\int^b_a f(x) \\overline{g(x)} dx\\right\\|\n    &\\leq \\sqrt{\\int^b_a f(x) \\overline{f(x)} dx}\\sqrt{\\int^b_a g(x) \\overline{g(x)} dx}\\\\[5pt]\n    &= \\sqrt{\\int^b_a \\|f(x)\\|^2 dx}\\sqrt{\\int^b_a \\|g(x)\\|^2 dx}\\\\\n\\end{align}\n\\]"
  },
  {
    "objectID": "posts/2025-07-01-physics-exercise-001/index.html",
    "href": "posts/2025-07-01-physics-exercise-001/index.html",
    "title": "ある慣性系で２つの平行な軌道",
    "section": "",
    "text": "Definition 1 慣性の法則\n\n質点が何の力も受けないとき，その質点は静止たままか，一定の速度で運動する\n運動の第一法則とも呼ぶ\n\n\n慣性の法則が成り立つ座標系を慣性系といいます．ある座標系が慣性系であれば，それに対して静止しているか等速直線運動をする座標系はすべて慣性系です．"
  },
  {
    "objectID": "posts/2025-07-01-physics-exercise-001/index.html#慣性の法則と慣性系",
    "href": "posts/2025-07-01-physics-exercise-001/index.html#慣性の法則と慣性系",
    "title": "ある慣性系で２つの平行な軌道",
    "section": "",
    "text": "Definition 1 慣性の法則\n\n質点が何の力も受けないとき，その質点は静止たままか，一定の速度で運動する\n運動の第一法則とも呼ぶ\n\n\n慣性の法則が成り立つ座標系を慣性系といいます．ある座標系が慣性系であれば，それに対して静止しているか等速直線運動をする座標系はすべて慣性系です．"
  },
  {
    "objectID": "posts/2025-07-01-physics-exercise-001/index.html#exercise",
    "href": "posts/2025-07-01-physics-exercise-001/index.html#exercise",
    "title": "ある慣性系で２つの平行な軌道",
    "section": "Exercise",
    "text": "Exercise\n\nExercise 1 \n非相対論的(=ニュートン力学で十分に正確に記述できる)な一定の速さで運動する２つの物体の軌道を，ある慣性系で観測したところ平行だった．\n\n別の関係性を選んで，その系では２つの軌道が互いに交差するというのはあり得るか？\n(a)を満たす座標系があったとして，適当な初期条件のもとに物体が動き始めて，それらが同時に交差する点へ到達することはあり得るか？\n\n\n\n\n\n\n\n\nNoteSolution (a)\n\n\n\n\n\nもとの座標系 \\(K\\) で，２つの物体の速度ベクトルを \\(\\pmb{v}_1, \\pmb{v}_2\\) とする．これらは仮定より平行なので\n\\[\n\\pmb{v}_1\\times\\pmb{v}_2 = \\pmb{0}\n\\]\n\\(K\\) に対して，速度 \\(\\pmb v_0\\) で動いている座標系 \\(K^\\prime\\) で，２つの軌道が互いに交差するならば\n\\[\n\\begin{align}\n(\\pmb v_1 - \\pmb v_0) \\times (\\pmb v_2 - \\pmb v_0)\n  &= (\\pmb v_1 - \\pmb v_2) \\times \\pmb v_0\\\\\n  &\\neq \\pmb{0}\n\\end{align}\n\\]\nこの条件が満たされるには\n\n2つの \\(\\pmb{v}_1, \\pmb{v}_2\\) の速度の大きさが異なっている\n2つの \\(\\pmb{v}_1, \\pmb{v}_2\\) の速度差ベクトルが \\(\\pmb{v}_0\\) と平行ではない\n\nが必要となります．\n\n\n\n\n\n\n\n\n\nNoteSolution (b)\n\n\n\n\n\n物体１の \\(t=0\\) における位置を座標系 \\(K\\) の原点にとると，時刻 \\(t\\) における２つの物体の位置ベクトルは，\\(t=0\\) における２つの物体の相対位置ベクトルを \\(\\pmb{d}\\) とすると\n\\[\n\\begin{align}\n\\pmb{r}_1(t) &= \\pmb{v}_1t\\\\\n\\pmb{r}_2(t) &= \\pmb{v}_2t + \\pmb{d}\n\\end{align}\n\\]\nこれを座標 \\(K^\\prime\\) での位置ベクトルになおすと\n\\[\n\\begin{align}\n\\pmb{r}_1^\\prime(t) &= (\\pmb{v}_1 - \\pmb{v}_0)t\\\\\n\\pmb{r}_2^\\prime(t) &= (\\pmb{v}_2 - \\pmb{v}_0)t + \\pmb{d}\n\\end{align}\n\\]\nもし２つの物体が時刻 \\(t_0\\) にある点で出会うならば\n\\[\n\\pmb{r}_1^\\prime(t_0) = \\pmb{r}_2^\\prime(t_0)\n\\]\nつまり，\n\\[\n(\\pmb{v}_1 - \\pmb{v}_2) t_0 = \\pmb{d}\n\\]\nこの条件が満たされるには\n\n\\(\\pmb{d}\\) が２つの物体の軌道に平行であればよい\n\nつまり，物体２の出発地点が物体１の直線経路上にあれば良いことになります．言い換えると，座標系 \\(K^\\prime\\) で観測したときに， ２つの物体が同じ時刻に同じ場所にいるとすれば，座標系 \\(K\\) で観測しても，同じように出会うはずである．"
  },
  {
    "objectID": "posts/2025-07-01-physics-exercise-001/index.html#refereneces",
    "href": "posts/2025-07-01-physics-exercise-001/index.html#refereneces",
    "title": "ある慣性系で２つの平行な軌道",
    "section": "Refereneces",
    "text": "Refereneces\n\nベクトル空間における外積"
  },
  {
    "objectID": "posts/2024-12-16-ssh-to-macos/index.html",
    "href": "posts/2024-12-16-ssh-to-macos/index.html",
    "title": "macOSへのssh接続",
    "section": "",
    "text": "同じprivate networkに属しているmacOS端末に対して公開鍵認証を用いてssh接続したい\n\n同じprovate networkに属している前提の端末へのsshになるので\nssh hoshinokirby@192.168.10.110\nのように自宅内のネットワークのみで有効なプライベートIPアドレス（クラスC 192.168.0.0 ~ 192.168.255.255）を指定してアクセスすることを想定しています．"
  },
  {
    "objectID": "posts/2024-12-16-ssh-to-macos/index.html#what-we-want-to-do",
    "href": "posts/2024-12-16-ssh-to-macos/index.html#what-we-want-to-do",
    "title": "macOSへのssh接続",
    "section": "",
    "text": "同じprivate networkに属しているmacOS端末に対して公開鍵認証を用いてssh接続したい\n\n同じprovate networkに属している前提の端末へのsshになるので\nssh hoshinokirby@192.168.10.110\nのように自宅内のネットワークのみで有効なプライベートIPアドレス（クラスC 192.168.0.0 ~ 192.168.255.255）を指定してアクセスすることを想定しています．"
  },
  {
    "objectID": "posts/2024-12-16-ssh-to-macos/index.html#how-to-set-up",
    "href": "posts/2024-12-16-ssh-to-macos/index.html#how-to-set-up",
    "title": "macOSへのssh接続",
    "section": "How to set up",
    "text": "How to set up\n ▶  Server側\nSSHサーバー側はopenssh-serverなりssh serverが動いている必要があります．\n\nSystem Preferences &gt; Sharingをクリック\nRemote Loginを有効化\n\n以上の2ステップで，macOS側のSSH serverをactive状態にすることができます．\n ▶  Client側\nパスワード認証の場合は\n\narpコマンドでアクセス先端末のプライベートIPアドレスを検索\nsshコマンドでアクセス\n\nで完了となりますが，今回は公開鍵認証手順を紹介します．公開鍵認証の場合は\n\nSSH Key Pair の作成\n公開鍵の登録(接続先のauthorized_keysファイル（~/.ssh/authorized_keys）に追加)\nsshコマンドでアクセスとなります\n\n\n\nSSH Key Pair の作成\n\nssh-keygen -t rsa -b 4096 -f ~/.ssh/pupupu_land\n\n\n-t rsa: key typeの指定\n-b 4096: key lengthの指定(長いほどsecurity強固になる)\n-f  ~/.ssh/pupupu_land: key pairの生成先とファイル名（今回はpupupu_land, pupupu_land.pubが生成される）\n\n\n\n公開鍵の登録\n\nssh-copy-id -i ~/.ssh/pupupu_land.pub username@&lt;target-ip&gt;\n\n\n-i ~/.ssh/pupupu_land.pub: コピーする公開鍵ファイルを指定\n\n公開鍵を登録するには，\n\n公開鍵のファイルをコピー\n接続先のauthorized_keysファイル（~/.ssh/authorized_keys）に追加\nauthorized_keysファイルがない場合は作成後に適切なパーミッションを設定\n\nが必要となりますが，ssh-copy-idコマンドですべて自動実行することができるというメリットがあります．\n ▶  ssh connection\n上記の設定後，sshコマンド実行することで，macOSへアクセスすることができます． 毎回プライベートIPアドレスを調べるのが億劫な場合，デバイスのMACアドレスがわかればarpコマンドで以下のように検索することもできます．\narp -a | grep &lt;MAC-address&gt; | awk -F'[()]' '{print $2}'"
  },
  {
    "objectID": "posts/2025-08-26-bats-core/index.html",
    "href": "posts/2025-08-26-bats-core/index.html",
    "title": "シェルスクリプト用のUnit Testingフレームワーク: Bats",
    "section": "",
    "text": "Batsとは，TAP準拠のBash用テストフレームワーク\nBash 3.2以上をカバー\n\n\n\n# Run a single test file\nbats test.bats\n\n# Run all tests in a directory\nbats test/\n\n# Run tests recursively\nbats -r test/\n\n# Run tests in parallel (requires GNU parallel)\nbats --jobs 4 test/"
  },
  {
    "objectID": "posts/2025-08-26-bats-core/index.html#batsとは",
    "href": "posts/2025-08-26-bats-core/index.html#batsとは",
    "title": "シェルスクリプト用のUnit Testingフレームワーク: Bats",
    "section": "",
    "text": "Batsとは，TAP準拠のBash用テストフレームワーク\nBash 3.2以上をカバー\n\n\n\n# Run a single test file\nbats test.bats\n\n# Run all tests in a directory\nbats test/\n\n# Run tests recursively\nbats -r test/\n\n# Run tests in parallel (requires GNU parallel)\nbats --jobs 4 test/"
  },
  {
    "objectID": "posts/2025-08-26-bats-core/index.html#installation-via-git-submodule-add",
    "href": "posts/2025-08-26-bats-core/index.html#installation-via-git-submodule-add",
    "title": "シェルスクリプト用のUnit Testingフレームワーク: Bats",
    "section": "Installation via git submodule add",
    "text": "Installation via git submodule add\n\n\n\n\n\n\nNoteBats Version\n\n\n\n2025-08-28時点で下記の方法でインストールすると Bats 1.12.0 がインストールされます\n% bats --version\nBats 1.12.0\n\n\nRepository Rootで以下のコマンドを実行します\ngit submodule add https://github.com/bats-core/bats-core.git test/bats\ngit submodule add https://github.com/bats-core/bats-support.git test/test_helper/bats-support\ngit submodule add https://github.com/bats-core/bats-assert.git test/test_helper/bats-assert\n結果として以下のような構成になります\nscript/\n    bazaar_zen.sh\n    ...\ntest/\n    bats/               &lt;- submodule\n    test_helper/\n        bats-support/   &lt;- submodule\n        bats-assert/    &lt;- submodule\n    test.bats\nユニットテスト用のファイルは上記の例では test.bats にあります． このファイルを編集することでユニットテストケースを設定していきます．\nOptional: パラレル処理\nBatsはデフォルトではシリアルにテストを実行していきますが，--jobs を指定することでパラレル処理も実行可能です． ただし，パラレル処理のときはテストの実行順番は保証されないことに注意が必要です．\nこの処理を実現するためには GNU parallel が必要です．\nsudo apt-get install -y parallel"
  },
  {
    "objectID": "posts/2025-08-26-bats-core/index.html#bats-unit-testing",
    "href": "posts/2025-08-26-bats-core/index.html#bats-unit-testing",
    "title": "シェルスクリプト用のUnit Testingフレームワーク: Bats",
    "section": "Bats Unit Testing",
    "text": "Bats Unit Testing\n\n\n\n\n\n\nNoteKey Points\n\n\n\n\nテストファイルのshebangは #!/usr/bin/env bats と設定すること\nテストファイルは .bats 拡張子で終わること\nテストが return 0 で終了するとそのテストは成功と扱われる．それ以外(return 1)は失敗\ntest descriptionは絶対記載すること\nヘルパー関数を除いて，基本的には標準的なshell syntaxに従って記述すること\nテスト用環境の構築と削除に対応する関数 setup, teardownは活用すること\nsetup, teardownはテストの前に呼ばれる必要がある\n$BATS_TEST_FILENAME変数はテストファイル名を格納した変数\n\n\n\n例として，シェルスクリプトレポジトリに次のような bazaar_zen.sh があるとします\n#!/bin/bash\n\nset -euo pipefail\n\n# error if any arguments are passed\nif [ \"$#\" -ne 0 ]; then\n  echo \"Usage: no arguments allowed\" &gt;&2\n  exit 1\nfi\n\ncat &lt;&lt;EOF\n1. Every good work of software starts by scratching a developer's personal itch.\n2. Good programmers know what to write. Great ones know what to rewrite (and reuse).\n3. Plan to throw one away; you will, anyhow.\n4. If you have the right attitude, interesting problems will find you.\n5. When you lose interest in a program, your last duty to it is to hand it off to a competent successor.\n6. Treating your users as co-developers is your least-hassle route to rapid code improvement and effective debugging.\n7. Release early. Release often. And listen to your customers.\n8. Given a large enough beta-tester and co-developer base, almost every problem will be characterized quickly and the fix obvious to someone.\n9. Smart data structures and dumb code works a lot better than the other way around.\n10. If you treat your beta-testers as if they're your most valuable resource, they will respond by becoming your most valuable resource.\n11. The next best thing to having good ideas is recognizing good ideas from your users. Sometimes the latter is better.\n12. Often, the most striking and innovative solutions come from realizing that your concept of the problem was wrong.\n13. Perfection (in design) is achieved not when there is nothing more to add, but rather when there is nothing more to take away.\n14. Any tool should be useful in the expected way, but a truly great tool lends itself to uses you never expected.\n15. When writing gateway software of any kind, take pains to disturb the data stream as little as possible and never throw away information unless the recipient forces you to!\n16. When your language is nowhere near Turing-complete, syntactic sugar can be your friend.\n17. A security system is only as secure as its secret. Beware of pseudo-secrets.\n18. To solve an interesting problem, start by finding a problem that is interesting to you.\n19. Provided the development coordinator has a communications medium at least as good as the Internet, and knows how to lead without coercion, many heads are inevitably better than one.\nEOF\nこれは，プログラミング哲学を標準出力するだけのスクリプトです．\nUnit Test方針\n\n\n\n\n\n\n\n\n\n\nTest No\n確認観点\n方法・コマンド例\n意図・理由\n\n\n\n\n1\n基本動作の確認\nrun ./script.sh → status -eq 0\nスクリプトが正常終了するか（最低限の「実行可能性」の担保）\n\n\n2\n行数の検証\nwc -l &lt;&lt;&lt; \"$output\" → -eq 19\n出力が仕様通りの行数（19行）か確認し，欠落や余分な行がないことを保証\n\n\n3\n先頭行の確認\nhead -n 1 &lt;&lt;&lt; \"$output\" → 部分一致\n最初の行が期待通り始まっているかを確認し，仕様崩れを防止\n\n\n4\n末尾行の確認\ntail -n 1 &lt;&lt;&lt; \"$output\" → 部分一致\n最後の行が期待通り終わっているかを確認し，途中での欠落や追加を防止\n\n\n5\n引数エラーの確認\nrun ./script.sh unexpected_arg → status -ne 0\n不正な引数が与えられたときにエラー終了することを確認し，誤用を防止\n\n\n\n\nUnit Testの実装\n\n\n\n\n\n\nNoteKey Points\n\n\n\n\nsetup() にて，各テストケースに共通の設定を実施．今回は，スクリプトのPATHを通したのみ\n@test グループの記述が個別のテストケースに相当\n\n\n\nテストファイル test_bazaar_zen.bats の実装場所は以下を想定しています\nrepository root\n├── script\n│   └── bazaar_zen.sh\n└── test\n    ├── bats\n    ├── test_for_script\n    │   └── test_bazaar_zen.bats\n    └── test_helper\nこの構成の下，テストファイルを以下のように定義します\n#!/usr/bin/env bats\n\nsetup() {\n  load '../test_helper/bats-support/load'\n  load '../test_helper/bats-assert/load'\n  # get the containing directory of this file\n  # use $BATS_TEST_FILENAME instead of ${BASH_SOURCE[0]} or $0,\n  # as those will point to the bats executable's location or the preprocessed file respectively\n  DIR=\"$(cd \"$(dirname \"$BATS_TEST_FILENAME\")\" &gt;/dev/null 2&gt;&1 && pwd)\"\n  \n  # make executables in script/ visible to PATH\n  OLD_PATH=$PATH\n  PATH=\"$DIR/../../script:$PATH\"\n}\n\nteardown() {\n  # PATHを元に戻す\n  PATH=$OLD_PATH\n}\n\n\n@test \"bazaar_zen.sh runs successfully\" {\n  run bazaar_zen.sh\n  assert_success\n}\n\n@test \"outputs 19 lines\" {\n  run bazaar_zen.sh\n  line_count=$(echo \"$output\" | wc -l)\n  [ \"$line_count\" -eq 19 ] || { \n      echo \"FAILED: Expected 19 lines but got $line_count\" &gt;&2\n      return 1\n  }\n}\n\n@test \"first line is correct\" {\n  run bazaar_zen.sh\n  assert_line --index 0 --partial \"1. Every good work of software starts\"\n}\n\n@test \"last line is correct\" {\n  run bazaar_zen.sh\n  assert_line --index -1 --partial \"many heads are inevitably better than one\"\n}\n\n@test \"rules.sh fails with unexpected args\" {\n  run bazaar_zen.sh unexpected_arg\n  assert_failure\n  assert_output --partial \"Usage: no arguments allowed\"\n}\nUnit testの実行\n% bats test/test_for_script\ntest_bazaar_zen.bats\n ✓ bazaar_zen.sh runs successfully\n ✓ outputs 19 lines\n ✓ first line is correct\n ✓ last line is correct\n一つ以上のテストがFAILEDの場合は以下のような出力になります\n% bats test/test_for_script\ntest_bazaar_zen.bats\n ✓ bazaar-zen runs successfully\n ✗ outputs 19 lines\n   (in test file test/test_for_script/test_bazaar-zen.bats, line 33)\n     `return 1' failed\n   FAILED: Expected 19 lines but got 18\n ✓ first line is correct\n ✓ last line is correct\n ✓ rules.sh fails with unexpected args\n\n5 tests, 1 failure\n\nsetup 関数とteardown関数\n\n\n\n\n\n\nNote目的\n\n\n\n\nassert_successなどのヘルパー関数のload\nテストしたいシェルスクリプト bazaar_zen.sh へのPATHをbatsテスト環境用に定義する\nテスト終了後に環境用に定義した設定を破棄する\n\n\n\nsetup() {\n  load '../test_helper/bats-support/load'\n  load '../test_helper/bats-assert/load'\n  # get the containing directory of this file\n  # use $BATS_TEST_FILENAME instead of ${BASH_SOURCE[0]} or $0,\n  # as those will point to the bats executable's location or the preprocessed file respectively\n  DIR=\"$(cd \"$(dirname \"$BATS_TEST_FILENAME\")\" &gt;/dev/null 2&gt;&1 && pwd)\"\n\n  # make executables in script/ visible to PATH\n  OLD_PATH=$PATH\n  PATH=\"$DIR/../../script:$PATH\"\n}\n\nteardown() {\n  # PATHを元に戻す\n  PATH=$OLD_PATH\n}\nすべての関数が終わったタイミングで，その実行ステータスに関わらずteardown関数は実行されます．\n\n\n各テストケース\n1: スクリプトが正常終了するか（最低限の「実行可能性」の担保）\n@test \"bazaar-zen runs successfully\" {\n  run bazaar_zen.sh\n  assert_success\n}\n\n@test 以下の\"bazaar-zen runs successfully\" がtest description\nassert_successはrunコマンドが成功したときのステータスが0かどうかを検証\n\n2: 出力が仕様通りの行数（19行）か確認し，欠落や余分な行がないことを保証\n@test \"outputs 19 lines\" {\n  run bazaar_zen.sh_\n  line_count=$(echo \"$output\" | wc -l)\n  [ \"$line_count\" -eq 19 ] || { \n      echo \"FAILED: Expected 19 lines but got $line_count\" &gt;&2\n      return 1\n  }\n}\n\nrun commandの実行結果は $output 変数に格納されます\n$outputに対して，通常のshell操作で露わに変数を作り，その変数をベースにテストを実行することができます\n\n\n\n\n\n\n\nNoterun コマンドに生成される変数\n\n\n\n\n\n\n\n\n\n\n\n\n変数名\n説明\n例・用途\n\n\n\n\n$status\n実行したコマンドの 終了ステータス（整数）\nassert_success → $status -eq 0 の確認に利用\n\n\n$output\n実行したコマンドの 標準出力＋標準エラー出力を文字列で保持\n出力全体を一括で検証するときに使用（例：assert_output \"OK\"）\n\n\n$lines\n$output を 改行ごとに分割した配列\n個別行を確認するときに使用（例：assert_equal \"${lines[0]}\" \"header\"）\n\n\n\n\n\n\n3: 先頭行の確認\n@test \"first line is correct\" {\n  run bazaar_zen.sh\n  assert_line --index 0 --partial \"1. Every good work of software starts\"\n}\n\nassert_line --index 0で$output変数の1行目について，assert検証が実行できる\n--partialは部分一致の意味\n\n4: 末尾行の確認\n@test \"last line is correct\" {\n  run bazaar_zen.sh\n  assert_line --index -1 --partial \"many heads are inevitably better than one\"\n}\n\nassert_line --index -1で$output変数の最終行目について，assert検証が実行できる\n\n5: 引数エラーの確認\n@test \"rules.sh fails with unexpected args\" {\n  run bazaar_zen.sh unexpected_arg\n  assert_failure\n  assert_output --partial \"Usage: no arguments allowed\"\n}\n\nassert_failure で$statusが0意外であるかどうかを検証\nassert_outputは$output変数全体について，assert検証"
  },
  {
    "objectID": "posts/2025-08-26-bats-core/index.html#個人用セットアップ",
    "href": "posts/2025-08-26-bats-core/index.html#個人用セットアップ",
    "title": "シェルスクリプト用のUnit Testingフレームワーク: Bats",
    "section": "個人用セットアップ",
    "text": "個人用セットアップ\nAliasの設定\n基本的にgit submodule経由で使用することを想定しているので，.zshrc に以下のようなAliasを設定します\nalias bats='$(git rev-parse --show-toplevel)/test/bats/bin/bats'"
  },
  {
    "objectID": "posts/2025-08-26-bats-core/index.html#references",
    "href": "posts/2025-08-26-bats-core/index.html#references",
    "title": "シェルスクリプト用のUnit Testingフレームワーク: Bats",
    "section": "References",
    "text": "References\n\nbats-core"
  },
  {
    "objectID": "posts/2025-07-02-convergence-in-sequence/index.html",
    "href": "posts/2025-07-02-convergence-in-sequence/index.html",
    "title": "収束の条件とCauchyの判定法",
    "section": "",
    "text": "Theorem 1 区間縮小法\n閉区間 \\(I_n = [a_n, b_n] \\, \\ (n=1,2,\\cdots)\\) において，\n\n各区間 \\(I_n\\) がその前の区間 \\(I_{n-1}\\) に含まれ\n\\(n\\) が限りなく増すとき，区間 \\(I_n\\) の幅 \\(b_n - a_n\\) が限りなく小さくなる\n任意の \\(m, n\\) に対して，\\(a_n &lt; b_m\\)\n\nとき，これらの各区間に共通なるただ一つの点が存在する(=各区間に共通なる数が唯一つ確定する)\n\n\n\n\n\n\n\nNoteProof\n\n\n\n\n\n仮定 1, 3 より\n\\[\na_1 \\leq a_2 \\leq \\cdots a_n \\leq \\cdots b_n \\leq \\cdots b_2 \\leq b_1\n\\]\n数列 \\(\\{a_n\\}, \\{b_n\\}\\) は有界かつ単調増加/減少であるので，\n\\[\n\\lim_{n\\to\\infty}a_n = \\alpha, \\lim_{n\\to\\infty}b_n = \\beta\n\\]\n任意の \\(m, n\\) に対して，\\(a_n &lt; b_m\\) であるので，\n\\[\n\\begin{align}\nn\\to\\infty &\\Rightarrow \\alpha \\leq b_m\\\\\nm\\to\\infty &\\Rightarrow \\alpha \\leq \\beta\n\\end{align}\n\\]\nまた, 仮定 2 より，任意の \\(\\epsilon &gt; 0\\) に対応して\n\\[\nb_n - a_n &lt; \\epsilon\n\\]\nを満たす \\(n\\) が存在し，\n\\[\na_n \\leq \\alpha \\leq \\beta \\leq b_n\n\\]\n従って，\n\\[\n0 \\leq \\beta - \\alpha &lt; \\epsilon\n\\]\n任意の \\(\\epsilon &gt;0\\) について成立するので\n\\[\n\\alpha = \\beta\n\\]\n\n\n\n\n\n\nTheorem 2 Dedekindの定理\n実数の切断 \\((A, B)\\) が与えられたとき，ただ１つの数 \\(s\\) が存在し，\\(s\\) は Aの最大数 xor Bの最小数である．\n\n\n\n\n\n\n\nNoteProof: 区間縮小法を用いた証明\n\n\n\n\n\n\\(A, N\\) から一対の数 \\(a, b\\) を取り出して，区間 \\(I_0 = [a, b]\\) を定義します．\n\\[\n\\frac{a+b}{2}\n\\]\nは中間の数なので，A または B のどちらか一方に属していなければなりません．この条件に応じて\n\\[\n\\begin{align}\n\\frac{a+b}{2} \\in A &\\Rightarrow a_1 = \\frac{a+b}{2}, b_1 = b\\\\\n\\frac{a+b}{2} \\in B &\\Rightarrow a_1 = a, b_1 = \\frac{a+b}{2}\n\\end{align}\n\\]\nとして区間を更新していきます．\n区間が更新されるたびに\n\\[\n\\begin{align}\nI_0\\text{の幅} &= b-a\\\\\nI_1\\text{の幅} &= \\frac{b-a}{2}\\\\\nI_2\\text{の幅} &= \\frac{b-a}{4}\\\\\n\\vdots &\\\\\nI_n\\text{の幅} &= \\frac{b-a}{2^n}\n\\end{align}\n\\]\nとなるので，\n\\[\nI_1 \\supset I_2 \\supset \\cdots \\supset I_n \\supset \\cdots\n\\]\n従って，各区間に共通する数はただ１つ \\(s\\) と定まり，それは切断 \\((A, B)\\) の上組または下組の属す必要があります．\n\\(s\\in A\\) とすると，任意の \\(s^\\prime &gt; s\\) は \\(b_n \\to s\\) より\n\\[\ns &lt; b_n &lt; s^\\prime \\text{なる $b_n$ が存在する} \\Rightarrow s^\\prime \\in B\n\\]\nつまり，\\(s\\) は \\(A\\) の最大数であり，このとき \\(B\\) には最小数は存在しません．仮に，\\(s^\\prime\\) を \\(B\\) の最小数とすると\n\\[\ns_0 = \\frac{s^\\prime - s}{2}\n\\]\nなる数を考えると，十分大きな\\(n\\) について任意の\\(\\epsilon &gt; 0\\) で\n\\[\n|b_n - s| &lt; \\epsilon\\Rightarrow |b_n - s| &lt; \\frac{s^\\prime - s}{4}\n\\]\nを満たすような \\(b_n\\) が考えられ，このとき \\(b_n &lt; s^\\prime\\) であるので，最小数の仮定と矛盾します．\nもしも，\\(s\\in B\\) であるならば，同様のロジックで \\(s = \\min(B)\\) であり，\\(A\\) の最大数は存在しないことになります．"
  },
  {
    "objectID": "posts/2025-07-02-convergence-in-sequence/index.html#区間縮小法",
    "href": "posts/2025-07-02-convergence-in-sequence/index.html#区間縮小法",
    "title": "収束の条件とCauchyの判定法",
    "section": "",
    "text": "Theorem 1 区間縮小法\n閉区間 \\(I_n = [a_n, b_n] \\, \\ (n=1,2,\\cdots)\\) において，\n\n各区間 \\(I_n\\) がその前の区間 \\(I_{n-1}\\) に含まれ\n\\(n\\) が限りなく増すとき，区間 \\(I_n\\) の幅 \\(b_n - a_n\\) が限りなく小さくなる\n任意の \\(m, n\\) に対して，\\(a_n &lt; b_m\\)\n\nとき，これらの各区間に共通なるただ一つの点が存在する(=各区間に共通なる数が唯一つ確定する)\n\n\n\n\n\n\n\nNoteProof\n\n\n\n\n\n仮定 1, 3 より\n\\[\na_1 \\leq a_2 \\leq \\cdots a_n \\leq \\cdots b_n \\leq \\cdots b_2 \\leq b_1\n\\]\n数列 \\(\\{a_n\\}, \\{b_n\\}\\) は有界かつ単調増加/減少であるので，\n\\[\n\\lim_{n\\to\\infty}a_n = \\alpha, \\lim_{n\\to\\infty}b_n = \\beta\n\\]\n任意の \\(m, n\\) に対して，\\(a_n &lt; b_m\\) であるので，\n\\[\n\\begin{align}\nn\\to\\infty &\\Rightarrow \\alpha \\leq b_m\\\\\nm\\to\\infty &\\Rightarrow \\alpha \\leq \\beta\n\\end{align}\n\\]\nまた, 仮定 2 より，任意の \\(\\epsilon &gt; 0\\) に対応して\n\\[\nb_n - a_n &lt; \\epsilon\n\\]\nを満たす \\(n\\) が存在し，\n\\[\na_n \\leq \\alpha \\leq \\beta \\leq b_n\n\\]\n従って，\n\\[\n0 \\leq \\beta - \\alpha &lt; \\epsilon\n\\]\n任意の \\(\\epsilon &gt;0\\) について成立するので\n\\[\n\\alpha = \\beta\n\\]\n\n\n\n\n\n\nTheorem 2 Dedekindの定理\n実数の切断 \\((A, B)\\) が与えられたとき，ただ１つの数 \\(s\\) が存在し，\\(s\\) は Aの最大数 xor Bの最小数である．\n\n\n\n\n\n\n\nNoteProof: 区間縮小法を用いた証明\n\n\n\n\n\n\\(A, N\\) から一対の数 \\(a, b\\) を取り出して，区間 \\(I_0 = [a, b]\\) を定義します．\n\\[\n\\frac{a+b}{2}\n\\]\nは中間の数なので，A または B のどちらか一方に属していなければなりません．この条件に応じて\n\\[\n\\begin{align}\n\\frac{a+b}{2} \\in A &\\Rightarrow a_1 = \\frac{a+b}{2}, b_1 = b\\\\\n\\frac{a+b}{2} \\in B &\\Rightarrow a_1 = a, b_1 = \\frac{a+b}{2}\n\\end{align}\n\\]\nとして区間を更新していきます．\n区間が更新されるたびに\n\\[\n\\begin{align}\nI_0\\text{の幅} &= b-a\\\\\nI_1\\text{の幅} &= \\frac{b-a}{2}\\\\\nI_2\\text{の幅} &= \\frac{b-a}{4}\\\\\n\\vdots &\\\\\nI_n\\text{の幅} &= \\frac{b-a}{2^n}\n\\end{align}\n\\]\nとなるので，\n\\[\nI_1 \\supset I_2 \\supset \\cdots \\supset I_n \\supset \\cdots\n\\]\n従って，各区間に共通する数はただ１つ \\(s\\) と定まり，それは切断 \\((A, B)\\) の上組または下組の属す必要があります．\n\\(s\\in A\\) とすると，任意の \\(s^\\prime &gt; s\\) は \\(b_n \\to s\\) より\n\\[\ns &lt; b_n &lt; s^\\prime \\text{なる $b_n$ が存在する} \\Rightarrow s^\\prime \\in B\n\\]\nつまり，\\(s\\) は \\(A\\) の最大数であり，このとき \\(B\\) には最小数は存在しません．仮に，\\(s^\\prime\\) を \\(B\\) の最小数とすると\n\\[\ns_0 = \\frac{s^\\prime - s}{2}\n\\]\nなる数を考えると，十分大きな\\(n\\) について任意の\\(\\epsilon &gt; 0\\) で\n\\[\n|b_n - s| &lt; \\epsilon\\Rightarrow |b_n - s| &lt; \\frac{s^\\prime - s}{4}\n\\]\nを満たすような \\(b_n\\) が考えられ，このとき \\(b_n &lt; s^\\prime\\) であるので，最小数の仮定と矛盾します．\nもしも，\\(s\\in B\\) であるならば，同様のロジックで \\(s = \\min(B)\\) であり，\\(A\\) の最大数は存在しないことになります．"
  },
  {
    "objectID": "posts/2025-07-02-convergence-in-sequence/index.html#cauchyの判定法",
    "href": "posts/2025-07-02-convergence-in-sequence/index.html#cauchyの判定法",
    "title": "収束の条件とCauchyの判定法",
    "section": "Cauchyの判定法",
    "text": "Cauchyの判定法\n\nTheorem 3 Cauchyの判定法\n数列 \\(\\{a_n\\}\\) が収束するために必要かつ十分なる条件は，任意の \\(\\epsilon &gt; 0\\) に対応して \\(n_0\\) が定められて，\n\\[\np &gt; n_0, q &gt; n_0 \\Rightarrow |a_p - a_q| &lt; \\epsilon\n\\]\n\n\n\n\n\n\n\nNoteProof: 高木解析概論 p12 より\n\n\n\n\n\n必要条件\n\\(a_n \\to \\lambda\\) であるならば収束の定義より，ある \\(N(\\epsilon)\\) が存在して\n\\[\np &gt; N(\\epsilon), q &gt; N(\\epsilon) \\Rightarrow |a_p - \\lambda| &lt;\\frac{\\epsilon}{2}, |a_q - \\lambda| &lt;\\frac{\\epsilon}{2}\n\\]\n従って，\n\\[\n\\begin{align}\n|a_p - a_q|\n  &= |a_p - \\lambda + \\lambda  - a_q|\\\\\n  &\\leq |a_p - \\lambda| + |a_q - \\lambda| \\,\\ \\because{\\text{三角不等式}}\\\\\n  & &lt; \\epsilon\n\\end{align}\n\\]\nよって，収束列はコーシー列です．\n十分性\n\\({a_n}\\) がコーシー列であるとする：\n条件より以下のように \\({a_n}\\) は有界となります．\n\\[\np &gt; n_0 \\Rightarrow |a_p - a_{n_0 + 1}| &lt; \\epsilon, \\, \\ \\text{$n_0$ は確定なので有限個の数列 $\\{a_n\\}_{n=1}^{n_0}$ を加えても有界}\n\\]\n次に，任意の \\(n\\) について，\\(\\{a_k\\}_{k=n}^\\infty\\) を対応させて，その数列に対応する上限と下限を \\(l_n, m_n\\) として，\n\\[\nI_n = [m_n, l_n]\n\\]\nとおくと，\n\\[\n\\begin{gather}\nm_1 \\leq m_2 \\leq \\cdots \\leq m_n \\leq \\cdots l_n \\leq \\cdots l_2 \\leq l_1\\\\\nI_1 \\supset I_2 \\supset \\cdots \\supset I_n \\supset \\cdots\n\\end{gather}\n\\]\nここで改めて，任意の \\(\\epsilon &gt; 0\\) に対応して \\(n_0\\) が定められて，\n\\[\np &gt; n_0,  q &gt; n_0 \\Rightarrow |a_p - a_q| &lt; \\epsilon\n\\]\n\\(n &gt; n_0\\) とすると，上限の定義より任意の \\(q \\geq n\\) に対して\n\\[\nl_n - a_q &lt; \\epsilon\n\\]\nまた，下限の定義より，\n\\[\na_q - m_n &lt; \\epsilon\n\\]\nであるので，\n\\[\nl_n - m_n \\leq 2\\epsilon\n\\]\n\\(\\epsilon &gt; 0\\) は任意なので、区間 \\(I_{n}\\) の長さ \\(l_{n} - m_{n}\\) は \\(0\\) に収束し．\n\\[\nl_n \\to \\lambda, m_n \\to \\lambda \\, \\, \\because{\\text{区間縮小法}}\n\\]\nとなるような \\(\\lambda\\) が存在します．これは，\\(a_n \\to \\lambda\\) を意味します．実際，十分大きな \\(n\\) について\n\\[\n|a_n - \\lambda| \\leq l_n - m_n \\leq \\epsilon\n\\]\nが成立します．\n\n\n\n\n無限級数の収束とCauchyの判定法\n\nDefinition 1 無限級数の収束\n数列 \\(\\{a_n\\}\\) の最初の \\(n\\) 項の和を\n\\[\ns_n = a_1 + a_2 + \\cdots + a_n\n\\]\nとしたとき，\\(\\lim_{n\\to\\infty}s_n = s\\) が存在するならば，無限級数 \\(\\sum_{n=1}^\\infty a_n\\) は収束するといいます．\n\nCauchyの判定法により \\(n\\) を十分大きくして，任意の \\(m &gt; n\\) について\n\\[\n|s_n - s_m| = |a_{n+1} + \\cdots + a_m| &lt; \\epsilon\n\\]\nが \\(s_n\\) の収束の必要十分条件となります．故に収束の場合は，\n\\[\n\\lim_{n\\to\\infty}\\sum_{p=1}^\\infty a_{n+p} = 0\n\\]\nとなります．\n\\(\\lim_{n\\to\\infty}a_n = 0\\) は無限級数収束の必要条件 but not 十分条件\nCauchyの収束条件より \\(n\\) を十分大きくしたとき\n\\[\n|s_{n+1} - s_n| &lt; \\epsilon \\Rightarrow \\lim_{n\\to\\infty} a_n = 0\n\\]\nとなりますが，逆は成り立ちません．\n例えば\n\\[\ns_n = \\sum_{k=1}^n \\frac{1}{k}\n\\]\nを考えると，\n\\[\n\\lim_{n\\to\\infty}\\frac{1}{n} = 0\n\\]\nは成立しますが，級数についてのCauchy判定条件を見てみると，\\(n\\) を十分大きくしても\n\\[\n|s_{2n} - s_n| = \\underbrace{\\frac{1}{n+1} +\\cdots +\\frac{1}{2n}}_{n\\text{個}} &gt; \\frac{1}{2n} \\times n = \\frac{1}{2}\n\\]\nとなり，条件を満たさないため収束しません．実際にオイラー定数 \\(\\gamma\\) を用いると以下のような関係式になります\n\\[\n\\sum_{k=1}^n = \\ln N + \\gamma + \\omicron(1)\n\\]"
  },
  {
    "objectID": "posts/2025-07-02-convergence-in-sequence/index.html#references",
    "href": "posts/2025-07-02-convergence-in-sequence/index.html#references",
    "title": "収束の条件とCauchyの判定法",
    "section": "References",
    "text": "References\n\n定本 解析概論, 高木貞治 著\n数列の極限 Tips"
  },
  {
    "objectID": "posts/2025-01-08-bigquery-preprocess-01/index.html",
    "href": "posts/2025-01-08-bigquery-preprocess-01/index.html",
    "title": "BigQuery: TIME型カラムを指定したレベルで丸めて集計する",
    "section": "",
    "text": "▶  スーパーの来店時刻データ\n\n\n\nmember_id\nusage_date\nusage_time\n\n\n\n\n\n123456\n2024-02-01\n08:09:00\n\n\n\n223456\n2024-02-01\n08:10:00\n\n\n\n223456\n2024-02-11\n08:10:00\n\n\n\n123456\n2024-02-01\n20:09:00\n\n\n\n323456\n2024-02-01\n20:09:00\n\n\n\n\nという形でとあるスーパーの来店時刻データregmonkey-sample-data.restaurant_kawasaki.customer_recordが与えられているとします． このとき，以下の3つの処理を実施して，曜日×時間帯別平均来店者数の集計を行いたいとします．\n ▶  処理1: 24時間オーバーのデータへ変換\n\n00:01:00 → 24:00:00\n01:01:59 → 25:00:00\n\nのように夜中02:59:59までは26:59:59へ変換するという処理\n ▶  処理2: TIME型データを丸める\n\n08:09:00 → 08:00:00\n08:20:00 → 08:15:00\n\nのようにTIME型データを15分刻みに丸める処理\n ▶  処理3: DATE型データをISO day of weekへ変換\n\n月曜日を1, 日曜日を7とするISO day of weekに変換する\n祝日は8をアサインする\n\n2024-02-11, 2024-02-23は8がアサインされる"
  },
  {
    "objectID": "posts/2025-01-08-bigquery-preprocess-01/index.html#what-i-want-to-do",
    "href": "posts/2025-01-08-bigquery-preprocess-01/index.html#what-i-want-to-do",
    "title": "BigQuery: TIME型カラムを指定したレベルで丸めて集計する",
    "section": "",
    "text": "▶  スーパーの来店時刻データ\n\n\n\nmember_id\nusage_date\nusage_time\n\n\n\n\n\n123456\n2024-02-01\n08:09:00\n\n\n\n223456\n2024-02-01\n08:10:00\n\n\n\n223456\n2024-02-11\n08:10:00\n\n\n\n123456\n2024-02-01\n20:09:00\n\n\n\n323456\n2024-02-01\n20:09:00\n\n\n\n\nという形でとあるスーパーの来店時刻データregmonkey-sample-data.restaurant_kawasaki.customer_recordが与えられているとします． このとき，以下の3つの処理を実施して，曜日×時間帯別平均来店者数の集計を行いたいとします．\n ▶  処理1: 24時間オーバーのデータへ変換\n\n00:01:00 → 24:00:00\n01:01:59 → 25:00:00\n\nのように夜中02:59:59までは26:59:59へ変換するという処理\n ▶  処理2: TIME型データを丸める\n\n08:09:00 → 08:00:00\n08:20:00 → 08:15:00\n\nのようにTIME型データを15分刻みに丸める処理\n ▶  処理3: DATE型データをISO day of weekへ変換\n\n月曜日を1, 日曜日を7とするISO day of weekに変換する\n祝日は8をアサインする\n\n2024-02-11, 2024-02-23は8がアサインされる"
  },
  {
    "objectID": "posts/2025-01-08-bigquery-preprocess-01/index.html#query-example",
    "href": "posts/2025-01-08-bigquery-preprocess-01/index.html#query-example",
    "title": "BigQuery: TIME型カラムを指定したレベルで丸めて集計する",
    "section": "Query Example",
    "text": "Query Example\n ▶  処理1: 24時間オーバーのデータへ変換\nTIME型のままでは23:59:59までしかカバーされないので，extended timeの表記を試みたい場合はSTRING型へ変換する必要があります．\nCREATE TEMP FUNCTION convert_extended_time(standard_time TIME)\nRETURNS STRING\nAS (\n  CASE \n    WHEN EXTRACT(HOUR FROM standard_time) &lt; 3 THEN\n      FORMAT(\"%02d:%02d:%02d\", EXTRACT(HOUR FROM standard_time) + 24, EXTRACT(MINUTE FROM standard_time), EXTRACT(SECOND FROM standard_time))\n    ELSE \n      FORMAT(\"%02d:%02d:%02d\", EXTRACT(HOUR FROM standard_time), EXTRACT(MINUTE FROM standard_time), EXTRACT(SECOND FROM standard_time))\n  END\n);\n ▶  処理2: TIME型データを丸める\nCREATE TEMP FUNCTION round_to_nearest_15_minute(usage_time TIME, round_level INT64)\nRETURNS TIME\nAS (\n  TIME_TRUNC(\n    TIME_SUB(usage_time, INTERVAL MOD(EXTRACT(MINUTE FROM usage_time), round_level) MINUTE),\n    MINUTE\n  )\n);\n ▶  処理3: DATE型データをISO day of weekへ変換\nBigQueryが提供する EXTRACT(DAYOFWEEK FROM &lt;date-column&gt;) は日曜日1から始まり土曜日7で終わる形式となっているので自分で以下のように関数をUDFを定義することが必要になります．\nCREATE TEMP FUNCTION convert_iso_dayofweek(usage_date DATE)\nRETURNS INT64\nAS (\n  MOD(EXTRACT(DAYOFWEEK FROM usage_date) + 5, 7) + 1\n);\n ▶  データ抽出クエリ\nWITH\n  daily_summary AS(\n    SELECT \n        usage_date,\n        round_to_nearest_15_minute(usage_time, 15) AS rounded_usage_time,\n        CASE\n          WHEN usage_date in (DATE('2024-02-11'), DATE('2024-02-23')) THEN 8\n          ELSE convert_iso_dayofweek(usage_date) \n        END AS dayofweek,\n        COUNT(1) AS customer_count\n    FROM \n        `regmonkey-sample-data.restaurant_kawasaki.customer_record`\n    GROUP BY\n        1, 2\n  )\nSELECT\n    dayofweek,\n    convert_extended_time(rounded_usage_time) AS rounded_usage_time,\n    AVG(customer_count) AS mean_customer_count\nFROM\n    daily_summary \nGROUP BY \n  1, 2\nORDER BY\n  1, 2;"
  },
  {
    "objectID": "posts/2025-02-13-complex-plane/index.html",
    "href": "posts/2025-02-13-complex-plane/index.html",
    "title": "複素平面と複素数による回転",
    "section": "",
    "text": "NoteKey takeways\n\n\n\n\\(z_1, z_2\\in \\mathbb C\\) のとき，\n\\[\n\\begin{align}\nz_1 &= r_1(\\cos\\theta_1 + i\\sin\\theta_1)\\\\\nz_2 &= r_2(\\cos\\theta_2 + i\\sin\\theta_2)\n\\end{align}\n\\]\nとすると，以下が成立する\n\\[\n\\begin{align}\n&z_1z_2 = r_1r_2(\\cos(\\theta_1 + \\theta_2) + i\\sin(\\theta_1 + \\theta_2))\\\\\n&|z_1z_2| = |z_1||z_2|\\\\\n&\\operatorname{arg}(z_1z_2) = \\operatorname{arg}(z_1) + \\operatorname{arg}(z_2)\\\\\n&\\frac{z_1}{z_2} = r_1r_2(\\cos(\\theta_1 - \\theta_2) + i\\sin(\\theta_1 - \\theta_2))\\\\\n&\\left|\\frac{z_1}{z_2}\\right| = \\frac{|z_1|}{|z_2|}\\\\\n&\\operatorname{arg}\\left(\\frac{z_1}{z_2}\\right) = \\operatorname{arg}(z_1) - \\operatorname{arg}(z_2)\n\\end{align}\n\\]"
  },
  {
    "objectID": "posts/2025-02-13-complex-plane/index.html#複素数の性質",
    "href": "posts/2025-02-13-complex-plane/index.html#複素数の性質",
    "title": "複素平面と複素数による回転",
    "section": "複素数の性質",
    "text": "複素数の性質\n\nDef: 複素数と 0 \n複素数 \\(z = a + bi = 0\\) のとき，\\(a = b = 0\\) である．\n\nこの定義より，複素数 \\(z\\) の絶対値 \\(\\vert z \\vert = 0\\) であるならば，\n\\[\n\\begin{align}\n\\vert z \\vert = 0 \\Leftrightarrow (a^2 + b^2) = 0 \\Leftrightarrow a = b = 0 \\Leftrightarrow z = 0\n\\end{align}\n\\]\nであることがわかります．\n\nDef: 共役複素数 \n複素数 \\(z = a + bi\\) に対して，\\(a - bi\\) を \\(z\\) の共役複素数と呼び，\\(\\overline z\\) と表す．\n\n足すと 5 になり，掛けると 7 になる２つの数を考えてみたいと思います．それぞれの数を \\(\\alpha, \\beta\\) とすると解と係数の関係より\n\\[\nx^2 - 5x + 7 =0\n\\]\nという二次方程式の解を求めることで求まります．これをといてみると\n\\[\n\\alpha, \\beta = \\frac{5 \\pm \\sqrt{25 - 28}}{2} = \\frac{5 \\pm \\sqrt{3}i}{2}\n\\]\nという複素解がでてきます．また，共役複素数の定義より\n\\[\n\\overline \\alpha = \\beta\n\\]\nであることがわかります．また，もともとの問題が２つの和が \\(5\\), 積が \\(7\\) を満たす数を求める問題であったとことから\n\\[\n\\begin{gather}\n\\alpha + \\overline\\alpha = 5\\\\\n\\alpha \\overline\\alpha = 7\n\\end{gather}\n\\]\nとなりますが，このように共役複素数は積と和が実数になるという特徴が有ります．\n\n\nTheorem 1 \n複素数 \\(z = a + bi\\) について，\n\\[\nz\\overline z = a^2 + b^2\n\\]\nが成り立つ．\n\n\n\n\n\n\n\n\n\nNoteProof\n\n\n\n\n\n\\[\n\\begin{align}\n(a + bi)(a - bi)\n    &= a^2 - (bi)^2\\\\\n    &= a^2 - b^2i^2\\\\\n    &= a^2 + b^2\n\\end{align}\n\\]\n\n\n\n複素数 \\(z = a + bi\\) について，\\(z\\overline{z} = 1\\) となるような複素数 \\(\\overline{z}\\) を（乗法）逆元と呼ぶとき，\n\\[\n\\frac{z\\overline{z}}{a^2 + b^2} = 1\n\\]\nとなることから，\\(\\displaystyle \\frac{\\overline{z}}{\\vert z \\vert^2} = \\frac{\\overline{z}}{z\\overline{z}} = \\frac{a - bi}{a^2 + b^2}\\) が逆源となることがわかります．\n\n\nTheorem 2 : 共役複素数 \n２つの複素数 \\(z, w\\) に対して，\n\\[\n\\begin{gather}\n\\overline{z + w} = \\overline{z} + \\overline{w} \\label{#eq-complex-1}\\\\\n\\overline{z w} = \\overline{z}\\,\\overline{w} \\label{#eq-complex-2}\n\\end{gather}\n\\]\nが成り立つ．\n\n\n\n\n\n\n\n\n\nNoteProof\n\n\n\n\n\n以下では，\\(z = a + bi, w = c + di\\) とします．\n ▶  \\(\\eqref{#eq-complex-1}\\) の証明\n\\[\n\\begin{align}\n\\overline{z + w}\n    &= \\overline{(a + c) + (b+d)i}\\\\\n    &= (a + c) - (b+d)i\\\\\n    &= (a - bi) + (c - di)\\\\\n    &= \\overline{z} + \\overline{w}\n\\end{align}\n\\]\n ▶  \\(\\eqref{#eq-complex-2}\\) の証明\n\\[\n\\begin{align}\n&zw = (ac - bd) + (ad + bc)i\\\\\n\\Rightarrow & \\overline{zw} = (ac - bd) - (ad + bc)i\n\\end{align}\n\\]\n次に\n\\[\n\\begin{align}\n\\overline{z}\\,\\overline{w}\n    &=  (ac - bd) + (ad + bc)i\n\\end{align}\n\\]\nしたがって，\\(\\eqref{#eq-complex-2}\\) が成り立つ．"
  },
  {
    "objectID": "posts/2025-02-13-complex-plane/index.html#複素平面",
    "href": "posts/2025-02-13-complex-plane/index.html#複素平面",
    "title": "複素平面と複素数による回転",
    "section": "複素平面",
    "text": "複素平面\n複素数 \\(z = a + bi\\) は実部と虚部に着目すると２つの実数の組 \\((a, b)\\) と1:1対応していることがわかります．一方，２つの実数の組 \\((a, b)\\) を与えるということは 実数平面空間の１点と対応することと同じなので，平面上の点全体と複素数の全体は１対１に対応するということがわかります．\nこの対応によって，平面が複素数全体であると考えたものを複素平面またはガウス平面と呼びます．複素平面においては，\\(x\\) 軸を実軸，\\(y\\) 軸を虚軸といいます．\n\n極形式の導入\n複素平面において，複素数 \\(z = a + bi\\) の位置ベクトル \\(\\overrightarrow{OZ}\\) について\n\n\\(r\\): \\(||\\overrightarrow{OZ}||\\)\n\\(\\theta\\) : ベクトル \\(\\overrightarrow{OZ}\\) が実軸となす角\n\nと極座標に対応させて考えると，\\(r = |z|\\) となりますし，また偏角についても\n\\[\n\\theta = \\operatorname{arg} z\n\\]\nと表します．ここから複素数について次のような表し方を得ます\n\\[\nz = r(\\cos\\theta + i\\sin\\theta)\n\\]\nこれを \\(z\\) の極形式といいます．\n\n📘 REMARKS \n複素数 \\(z = a + bi\\) について，複素平面上では\n\n\\(-z = -a - bi\\): 原点に関する対称移動\n\\(\\overline{z} = a - bi\\): 実軸に関する対称移動\n\\(-\\overline{z} = -a + bi\\): 虚軸に関する対称移動\n\n\nCode\nimport matplotlib.pyplot as plt\n\n# 複素数の定義（例として z = 2 + 1i）\na, b = 2, 1\nz = complex(a, b)\n\n# 各変換\nminus_z = -z                # -z\nconj_z = z.conjugate()      # z̄\nminus_conj_z = -conj_z      # -z̄\n\n# 複素数の点とラベル\npoints = {\n    \"z\": z,\n    \"-z\": minus_z,\n    \"z̄\": conj_z,\n    \"-z̄\": minus_conj_z\n}\n\n# プロット\nfig, ax = plt.subplots(figsize=(6,6))\nax.set_facecolor(\"#EFF5F5\")\n\nfor label, point in points.items():\n    ax.plot(point.real, point.imag, 'o', c=\"#4477AA\")\n    ax.text(point.real + 0.1, point.imag + 0.1, label, fontsize=12)\n\ndef draw_arrow(from_point, to_point, color):\n    ax.annotate(\"\",\n                xy=(to_point.real, to_point.imag),\n                xytext=(from_point.real, from_point.imag),\n                arrowprops=dict(arrowstyle=\"-&gt;\", color=color, lw=1.2))\n\ndraw_arrow(0, z, \"#4477AA\")\ndraw_arrow(complex(0, z.imag), z, \"#4477AA\")\ndraw_arrow(complex(0, z.imag), minus_conj_z, \"gray\")\ndraw_arrow(0, minus_z, \"gray\")      # z → -z\ndraw_arrow(complex(z.real, 0), conj_z, \"gray\")\ndraw_arrow(complex(z.real, 0), z, \"#4477AA\")\n\n\n# 軸設定\nax.set_xlim(-2.5, 2.5)\nax.set_ylim(-2.5, 2.5)\nax.axhline(0, color='gray', linewidth=0.5)\nax.axvline(0, color='gray', linewidth=0.5)\nax.set_xlabel('Re')\nax.set_ylabel('Im')\n\nax.set_title('Symmetries of complex numbers')\nax.grid(True, which=\"both\", linestyle=\"--\", linewidth=0.5)\nax.set_aspect(\"equal\", adjustable=\"box\")  # Make axes equal scale\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 1\n\n\n\n\n\n\n複素数の積と回転\n２つの複素数 \\(z, w\\) の積を考えます．\n\\[\n\\begin{align}\n\\vert z \\vert = r_1, \\quad & \\operatorname{arg}z = \\theta_1\\\\\n\\vert w \\vert = r_2, \\quad & \\operatorname{arg}w = \\theta_2\n\\end{align}\n\\]\nとおくと，加法定理を用いて以下のように展開できます\n\\[\n\\begin{align}\nzw\n    &= r_1(\\cos\\theta_1 + i \\sin\\theta_1)r_2(\\cos\\theta_2 + i \\sin\\theta_2)\\\\\n    &= r_1r_2\\{(\\cos\\theta_1\\cos\\theta_2 - \\sin\\theta_1\\sin\\theta_1) + i(\\cos\\theta_1\\sin\\theta_2 + \\cos\\theta_2\\sin\\theta_1)\\}\\\\\n    &= r_1r_2(\\cos(\\theta_1 + \\theta_2) + i\\sin(\\theta_1 + \\theta_2))\n\\end{align}\n\\]\nここから以下のことがわかります\n\\[\n\\begin{gather}\n\\vert zw \\vert  = \\vert z\\vert\\, \\vert w \\vert\\\\\n\\operatorname{arg} zw \\equiv \\operatorname{arg} z + \\operatorname{arg} w \\quad(\\operatorname{mod} 2\\pi)\n\\end{gather}\n\\]\n積 \\(zw\\) の位置ベクトルは，\\(z\\) の位置ベクトルを \\(\\vert w \\vert\\) 倍に拡大し，原点 \\(O\\) のまわりに角 \\(\\operatorname{arg} w\\) だけ回転させたものであると解釈できます．\n\nCode\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# --- Define your complex numbers here ---\nz = 1 + 1j\nw = complex(1, np.sqrt(3))\n# ----------------------------------------\n\n## Calculate the product\nproduct = z * w\n\n# Points and labels for scattering (Origin + z, w, product)\nnums_to_label = {\"z\": z, \"w\": w, \"z*w\": product}\npoints = list(nums_to_label.values())\nreal_parts = [p.real for p in points]\nimag_parts = [p.imag for p in points]\nscatter_labels = [f\"{name} = {num:.2f}\" for name, num in nums_to_label.items()]\n\n\n# Create the plot\nfig, ax = plt.subplots(figsize=(6, 6))\nax.set_facecolor(\"#EFF5F5\")\n# Scatter plot for the points\ncolors = [\"#4477AA\", \"gray\", \"#2E45B8\"]  # Origin, z, w, product\nmarkers = [\"o\", \"o\", \"o\"]\nfor i in range(len(points)):\n    ax.scatter(\n        real_parts[i],\n        imag_parts[i],\n        color=colors[i],\n        marker=markers[i],\n        s=50,\n        label=scatter_labels[i],\n    )\n    # Add arrows from origin\n    ax.annotate(\n        \"\",\n        xy=(real_parts[i], imag_parts[i]),\n        xytext=(0, 0),\n        arrowprops=dict(arrowstyle=\"-&gt;\", color=colors[i]),\n    )\n\n# Add argument text annotations\ntext_offset = 0.15  # Small offset for text position, adjust as needed\nfor name, num in nums_to_label.items():\n    # Calculate argument in degrees\n    arg_rad = np.angle(num)\n    arg_deg = np.degrees(arg_rad)\n\n    # Create text label\n    text_label = f\"arg({name}) = {arg_deg:.1f}°\"  # Format to 1 decimal place\n\n    # Position the text slightly offset from the point\n    # You might need to fine-tune text_x, text_y for better placement\n    text_x = num.real + text_offset * np.cos(\n        arg_rad + np.pi / 8\n    )  # Offset slightly outwards\n    text_y = num.imag + text_offset * np.sin(arg_rad + np.pi / 8)\n\n    ax.text(\n        text_x,\n        text_y,\n        text_label,\n        fontsize=9,\n        color=colors[list(nums_to_label.keys()).index(name)],\n    )  # Use point's color\n\n\n# --- Plot Styling ---\n# Set plot limits to ensure all points and text are visible\nmax_abs_val = max(abs(p) for p in points[1:]) if len(points) &gt; 1 else 1\npadding = max_abs_val * 0.4  # Add padding based on magnitude\nax.set_xlim(min(real_parts) - padding, max(real_parts) + padding)\nax.set_ylim(min(imag_parts) - padding, max(imag_parts) + padding)\n\n# Determine symmetric limits centered at 0\nlim = max(abs(l) for l in ax.get_xlim() + ax.get_ylim())\nax.set_xlim(-2, lim)\nax.set_ylim(-1, lim)\n\n\n# Add grid, labels, and title\nax.grid(True, which=\"both\", linestyle=\"--\", linewidth=0.5)\nax.axhline(y=0, color=\"k\", linewidth=0.8)\nax.axvline(x=0, color=\"k\", linewidth=0.8)\nax.set_xlabel(\"Real Axis\")\nax.set_ylabel(\"Imaginary Axis\")\nax.set_title(\"Complex Numbers z, w, z*w, and their Arguments\")\nax.set_aspect(\"equal\", adjustable=\"box\")  # Make axes equal scale\nax.legend()\n\n# Show the plot\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 2\n\n\n\n ▶  加法定理を用いずに回転を理解する\nここでは加法定理を用いずに大きさが1の複素数 \\(\\cos\\theta + i\\sin\\theta\\) を掛ける操作が複素平面上の \\(\\theta\\) 回転を表すことを確認します．\n\\[\n\\begin{gather}\nz = a + ib\\\\\nw = \\cos\\theta + i\\sin\\theta\n\\end{gather}\n\\]\nの２つの複素数の積は\n\\[\n\\begin{align}\nzw\n    &= (a + ib)(\\cos\\theta + i\\sin\\theta)\\\\\n    &= (a\\cos\\theta - b\\sin\\theta) + i(a\\sin\\theta + b\\cos\\theta )\n\\end{align}\n\\]\n以下の図では \\(z = a + ib\\) として\n\n複素数 \\(z\\) と対応する点２次元実数空間に表した点を \\(P =(a, b)\\)\n\\(P\\) を \\(\\theta\\) 回転させた点を \\(Q\\)\n\\(P\\) を \\(90^\\prime\\) 回転させた点を \\(R  = (-b, a)\\)\n\\(\\overrightarrow{OQ}\\) を \\(\\overrightarrow{OP}\\) に正射影したベクトルを \\(\\overrightarrow{OP^\\prime}\\)\n\nとしています．ベクトルの正射影の考え方より\n\\[\n\\begin{align}\n\\overrightarrow{OP^\\prime} = \\vert OQ \\vert \\cos\\theta \\frac{\\overrightarrow{OP}}{\\vert OP\\vert} = \\cos\\theta \\overrightarrow{OP}\\\\\n\\overrightarrow{P^\\prime Q} = \\vert OQ \\vert \\sin\\theta \\frac{\\overrightarrow{OR}}{\\vert OR\\vert} = \\sin\\theta \\overrightarrow{OR}\n\\end{align}\n\\]\n従って，\n\\[\n\\begin{align}\n\\overrightarrow{OQ}\n    &= \\overrightarrow{OP^\\prime} + \\overrightarrow{P^\\prime Q}\\\\\n    &= \\cos\\theta \\overrightarrow{OP} + \\sin\\theta \\overrightarrow{OR}\n\\end{align}\n\\]\nここで，成分を考えると\n\\[\n\\overrightarrow{OQ} = (a\\cos\\theta - b\\sin\\theta, a\\sin\\theta + b\\cos\\theta)\n\\]\nこれは複素数 \\((a\\cos\\theta - b\\sin\\theta) + i(a\\sin\\theta + b\\cos\\theta )\\) に対応しているので，複素数の積 \\(zw\\) は \\(z\\) を \\(\\operatorname{arg} w\\) だけ回転させた複素平面の点に対応することがわかりました．\n\nCode\nimport matplotlib.patches as patches\nimport cmath\n\nfig, ax = plt.subplots(figsize=(6, 6))\nax.set_facecolor(\"#EFF5F5\")\n\n# Circle parameters\nr = 2  # radius\ntheta = np.linspace(0, 2 * np.pi, 500)\ncircle = r * np.exp(1j * theta)\nax.plot(circle.real, circle.imag, label=f\"|z| = {r}\", color=\"gray\")\n\n## define points\nOP = complex(np.sqrt(3), 1)\nOR = OP * 1j\nO = complex(0, 0)\nOQ = complex(np.cos(np.pi / 3), np.sin(np.pi / 3)) * OP\nOP_2 = np.cos(np.pi / 3) * OP\n\n\n## plots\npoints = [OP, OR, OQ]\nscatter_labels = [\"P\", \"R\", \"Q\"]\n\nax.text(\n    0,\n    -0.15,\n    \"O\",\n    fontsize=10,\n    color=\"black\",\n)\n\n# 直交する2本の線を描画\nfor i in range(len(points)):\n    point = points[i]\n    ax.plot([0, point.real], [0, point.imag], \"k\", linewidth=2)  # OP\n    ax.text(\n        point.real,\n        point.imag + 0.05,\n        scatter_labels[i],\n        fontsize=10,\n        color=\"black\",\n    )\n\n## ad P'Q\nax.plot([OP_2.real, OQ.real], [OP_2.imag, OQ.imag], color=\"gray\", linestyle=\"dotted\")\nax.text(\n    OP_2.real + 0.05,\n    OP_2.imag * 0.8,\n    r\"$P^\\prime$\",\n    fontsize=10,\n    color=\"black\",\n)\n\n\n# 直角記号（小さな四角）を原点付近に描画\n# 直角記号（原点から少しオフセット）\ntheta = cmath.phase(OP)  # 60 degrees\northogonal_theta = theta + np.pi / 2  # 90° 直交\noffset = 0.0\n# 直角マークの位置を作成（60°方向に少し移動 → 90°方向に正方形を描く）\nbase_x = offset * np.cos(theta)\nbase_y = offset * np.sin(theta)\nrect_dx = 0.2 * np.cos(orthogonal_theta)\nrect_dy = 0.2 * np.sin(orthogonal_theta)\n\n# 小さな直角マーク（平行四辺形を回転して表現）\nright_angle = patches.Polygon(\n    [\n        (base_x, base_y),\n        (base_x + rect_dx, base_y + rect_dy),\n        (\n            base_x + rect_dx + 0.2 * np.cos(theta),\n            base_y + rect_dy + 0.2 * np.sin(theta),\n        ),\n        (base_x + 0.2 * np.cos(theta), base_y + 0.2 * np.sin(theta)),\n    ],\n    closed=True,\n    edgecolor=\"black\",\n    facecolor=\"none\",\n)\n\nax.add_patch(right_angle)\narc = patches.Arc(\n    (0, 0),\n    0.8,\n    0.8,\n    angle=np.degrees(cmath.phase(OP)),  # start\n    theta1=0,\n    theta2=np.degrees(cmath.phase(OQ)) - np.degrees(cmath.phase(OP)),\n    color=\"black\",\n)\n\n## add angle theta\ntheta_r = 0.5\nax.text(\n    theta_r * np.cos(np.mean([cmath.phase(OQ), cmath.phase(OP)])),\n    theta_r * np.sin(np.mean([cmath.phase(OQ), cmath.phase(OP)])),\n    r\"$\\theta$\",\n    color=\"black\",\n    fontsize=10,\n)\n\nax.add_patch(arc)\n\n# 軸設定\nax.set_xlim(-2.5, 2.5)\nax.set_ylim(-2.5, 2.5)\nax.set_aspect(\"equal\")\nax.grid(True)\n\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 3\n\n\n\n ▶  複素数の割り算\n２つの複素数 \\(z, w\\) を上と同様に考えます． \\(\\vert w \\vert \\neq 0\\) であるとき，\n\\[\n\\begin{align}\n\\frac{1}{w}\n    &= \\frac{1}{r_2(\\cos \\theta_2 + i\\sin\\theta_2)}\\\\\n    &= \\frac{1}{r_2}(\\cos \\theta_2 - i\\sin\\theta_2)\\\\\n    &= \\frac{1}{r_2}(\\cos (-\\theta_2) + i\\sin(-\\theta_2))\\\\\n\\end{align}\n\\]\nであるので\n\\[\n\\begin{align}\n\\frac{z}{w}\n    &= \\frac{r_1}{r_2}\\{(\\cos\\theta_1\\cos(-\\theta_2) - \\sin\\theta_1\\sin(-\\theta_2)) + i(\\cos\\theta_1\\sin(-\\theta_2 )+ \\sin\\theta_1\\cos(-\\theta_2))\\}\\\\\n    &= \\frac{r_1}{r_2}\\{(\\cos\\theta_1\\cos\\theta_2 + \\sin\\theta_1\\sin\\theta_2) + i(-\\cos\\theta_1\\sin\\theta_2 +  \\sin\\theta_1\\cos\\theta_2)\\}\\\\\n    &= \\frac{r_1}{r_2}(\\cos(\\theta_1 - \\theta_2) + i (\\sin\\theta_1 - \\theta_2))\n\\end{align}\n\\]\nしたがって，\n\\[\n\\begin{gather}\n\\bigg\\vert \\frac{z}{w} \\bigg\\vert  = \\frac{\\vert z\\vert}{\\vert w \\vert}\\\\\n\\operatorname{arg}  \\frac{z}{w}  \\equiv \\operatorname{arg} z - \\operatorname{arg} w \\quad(\\operatorname{mod} 2\\pi)\n\\end{gather}\n\\]\n\n\nTheorem 3 : ド・モアブルの公式 \n正の整数 \\(n\\) に対して，\n\\[\n(\\cos\\theta + i\\sin\\theta)^n = \\cos n\\theta + i\\sin n \\theta\n\\]\nが成り立つ．\n\n\n\n\n\n\n\n\n\nNoteProof\n\n\n\n\n\n数学的帰納法を用いて示す．\\(n = 1\\) のとき成立するのは明らか．\\(n = k\\) のとき，ド・モアブルの公式が成立すると仮定すると\n\\[\n\\begin{align}\n(\\cos\\theta + i\\sin\\theta)^{k+1}\n    &= (\\cos\\theta + i\\sin\\theta)^{k} \\cdot (\\cos\\theta + i\\sin\\theta)\\\\\n    &= (\\cos k\\theta + i\\sin k\\theta)(\\cos\\theta + i\\sin\\theta)\\\\\n    &= (\\cos k\\theta \\cos \\theta - \\sin k\\theta\\sin \\theta) + i(\\cos k\\theta \\sin\\theta + \\sin k\\theta \\cos\\theta)\\\\\n    &= \\cos(k\\theta + \\theta) + i\\sin(k\\theta + \\theta)\\\\\n    &= \\cos(k+1)\\theta + i\\sin(k+1) \\theta\n\\end{align}\n\\]\n従って，\\(k+1\\) のときもド・モアブルの公式が成立することがわかる．\n\n\n\n ▶  1の \\(n\\) 乗根を複素数の範囲で求める\n\\(n\\) 乗すると \\(a\\) になる数を \\(a\\) の \\(n\\) 乗根といいます．ここで1の6乗根を求めてみたいと思います．\n\\(z^6 =1\\) より \\(\\vert z \\vert = 1\\). つまり，\n\\[\nz = \\cos\\theta + i \\sin\\theta\n\\]\nと表すことができます．ド・モアブルの公式より\n\\[\nz^6 = \\cos6\\theta + i \\sin6\\theta = 1\n\\]\nつまり，\n\\[\n\\begin{gather}\n6\\theta \\equiv 0 \\, \\operatorname{mod} 2\\pi\n\\end{gather}\n\\]\n\\(\\displaystyle \\zeta = \\cos\\frac{2\\pi}{6} + i \\sin \\frac{2\\pi}{6}\\) とおくと，\n\\[\n(1, \\zeta, \\zeta^2, \\zeta^3, \\zeta^4, \\zeta^5)\n\\]\nが解となります．これをplotすると以下のよう単位円周を６等分した点になることがわかります．\n\nCode\nzeta = complex(np.cos(2 * np.pi / 6), np.sin(2 * np.pi / 6))\npoints = [zeta ** i for i in range(6)]\nscatter_labels = [1] + [fr'$\\zeta^{i}$' for i in range(1, 6)]\n\n# Create the plot\nfig, ax = plt.subplots(figsize=(6, 6))\nax.set_facecolor(\"#EFF5F5\")\nfor i in range(len(points)):\n    ax.scatter(\n        points[i].real,\n        points[i].imag,\n        s=50,\n        color=\"#4477AA\",\n    )\n\n    ax.text(\n        points[i].real,\n        points[i].imag+0.05,\n        scatter_labels[i],\n        fontsize=9,\n        color='black',\n    )\n\n\n# Circle parameters\nr = 1  # radius\ntheta = np.linspace(0, 2 * np.pi, 500)\ncircle = r * np.exp(1j * theta) \nax.plot(circle.real, circle.imag, label=f'|z| = {r}', color='gray')\n\n# Add grids\nax.grid(True, which=\"both\", linestyle=\"--\", linewidth=0.5)\nax.axhline(y=0, color=\"k\", linewidth=0.8)\nax.axvline(x=0, color=\"k\", linewidth=0.8)\nax.set_xlabel(\"Real Axis\")\nax.set_ylabel(\"Imaginary Axis\")\nax.set_title(\"6th Roots of Unity on the Complex Plane\")\nax.set_aspect(\"equal\", adjustable=\"box\")  # Make axes equal scale\nax.legend()\n\n# Show the plot\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 4\n\n\n\n ▶  \\(\\alpha \\in \\mathbb C\\) の \\(n\\) 乗根\n\\(0\\) 出ない一般の複素数 \\(\\alpha = r(\\cos \\theta + i\\sin\\theta)\\) の \\(n\\) 乗根を求めます．\n\\[\nz^n = r(\\cos \\theta + i\\sin\\theta)\n\\]\nであるためには，ド・モアブルの定理より次の条件を満たすのが必要十分となります．\n\\[\n\\begin{align}\n|z|^n &= r\\\\\nn\\operatorname{arg}(z) &= \\theta  + 2k\\pi\\quad(k = 0, 1, 2, 3, \\cdots)\n\\end{align}\n\\]\n重複を避けるために，\\(k = 0, 1, \\cdots, n-1\\) とすると\n\\[\nz_k = r^{1/n}\\left\\{\\cos\\left(\\frac{\\theta}{n} + \\frac{2\\pi}{n}\\times k\\right) + i\\sin\\left(\\frac{\\theta}{n} + \\frac{2\\pi}{n}\\times k\\right)\\right\\}\n\\]\n ▶  大きさが1の複素数とLie群\n大きさが1の複素数の集合は，複素平面で考えると大きさが1の円周になります．この集合を\n\\[\nS = \\{z \\in \\mathbb C | \\vert z\\vert = 1\\}\n\\]\nと表すことができますが，オイラーの公式を用いると\n\\[\nS = \\{\\exp(i\\theta) \\in \\mathbb C | 0 \\leq \\theta &lt; 2\\pi\\}\n\\]\nと表すことができます．このとき，\\(S\\) の元は積の演算で閉じていることがわかります．つまり，\n\\[\n\\exp(i\\theta_1), \\exp(i\\theta_2) \\in S \\Rightarrow \\exp(i\\theta_1)\\exp(i\\theta_2) \\in S\n\\]\nこの積の演算に関して \\(S\\) は以下が成立するので群となります\n\n結合法則: \\((\\exp(i\\theta_1)\\exp(i\\theta_2))\\exp(i\\theta_3) = \\exp(i\\theta_1)(\\exp(i\\theta_2)\\exp(i\\theta_3)) = \\exp(i(\\theta_1 + \\theta_2 + \\theta_3))\\)\n単位元の存在: \\(\\exp(i\\cdot 0) = 1\\)\n逆元の存在: \\(\\exp(i\\theta)\\) に対して，\\(\\exp(-i\\theta)\\) が逆元として定義できる\n\nこのように，大きさが1である複素数の集合を考えることで，図形的な側面だけでなく，演算が定義された代数的な側面を持つ数学的な対象を考えることができます．\n\n\n\n\n\n\n\nNote📘 Key Takeaways\n\n\n\n\n\n ▶  複素ベクトル空間\n１次元複素ベクトル空間 \\(\\mathbb{C}\\) について，複素数 \\(z = a + bi, (a, b \\in \\mathbb R)\\) に対して\n\n\\((a, b)\\) を対応させる写像 \\(\\mathbb C\\to \\mathbb R^2\\) は全単射\n任意の \\(w, z \\in \\mathbb C\\) に対して，\\(w + z\\) の実部と虚部の組は \\(\\mathbb R^2\\) に含まれるので，和を保つ\nスカラーとして \\(\\lambda \\in \\mathbb R\\) を考えると，スカラー倍も保つ\n\n以上より，\\(\\mathbb{C}\\) は２次元実ベクトル空間 \\(\\mathbb R^2\\) と同一視できます．同様に \\(n\\)次元複素ベクトル空間 \\(\\mathbb C^n\\)は \\(2n\\)次元実ベクトル空間 \\(\\mathbb R^{2n}\\) とみなすことができます．\n ▶  複素ベクトル空間と実ベクトル空間の違い\n\nベクトル空間として，実数上で考えるのと複素数上で考えるのでは多くの場合大差はない\n一方，固有値や固有ベクトル，内積を考える場合には違いが生じる"
  },
  {
    "objectID": "posts/2025-07-03-total-differential-with-ideal-gas/index.html",
    "href": "posts/2025-07-03-total-differential-with-ideal-gas/index.html",
    "title": "理想気体の全微分",
    "section": "",
    "text": "関数 \\(z = f(x,y)\\) を \\(P = (x, y)\\) の近傍において考察します．\n\\[\n\\Delta z = f(x + \\Delta x, y + \\Delta y) - f(x, y)\n\\]\nとしたとき，次のように考える\n\\[\n\\Delta z = A\\Delta x + B\\Delta y + \\epsilon\\rho \\label{eq-differential}\n\\]\nこのとき，\n\n\\(A, B\\) は \\(\\Delta x, \\Delta y\\) には関係しない係数\n\\(\\rho = \\sqrt{\\Delta x^2 + \\Delta y^2}\\)\n\\(\\epsilon \\to 0 \\ \\ \\text{ as} \\ \\ \\rho \\to 0\\)\n\nが成立するならば，関数 \\(z\\) は点 \\(P\\) において微分可能であるといいます．\n\n\\(\\eqref{eq-differential}\\) が成り立つならば，\\(\\Delta y = 0\\) が成立するとき，\n\\[\n\\begin{align}\n\\rho &= |\\Delta x|\\\\\n\\frac{\\Delta z}{\\Delta x} &= A \\pm \\epsilon\n\\end{align}\n\\]\nこのとき，微分可能性の仮定より \\(\\Delta x \\to 0\\) と共に \\(\\epsilon \\to 0\\) だから，点P において\n\\[\n\\frac{\\partial z}{\\partial x} = A\n\\]\n同様に\n\\[\n\\frac{\\partial z}{\\partial y} = B\n\\]\n\n\n点 \\((x + \\Delta x, y + \\Delta y)\\) が一定の方向から \\((x, y)\\) に収束するとき，一定方向からなので\n\\[\n\\begin{align}\n\\Delta x &= \\rho \\cos\\alpha\\\\\n\\Delta y &= \\rho \\sin\\alpha\n\\end{align}\n\\]\nと考えることができます．このとき，\n\\[\n\\begin{gather}\n\\frac{\\Delta z}{\\rho} = A\\cos\\alpha + B\\sin\\alpha + \\epsilon\\\\\n\\lim_{\\rho\\to 0}\\frac{\\Delta z}{\\rho} = A\\cos\\alpha + B\\sin\\alpha = \\frac{\\partial z}{\\partial x} \\cos\\alpha + \\frac{\\partial z}{\\partial y} \\sin\\alpha\n\\end{gather}\n\\]\nつまり，\\(\\rho\\to 0\\) とするとき，\\(\\Delta z\\) などを \\(dz\\) と表記しなおすと\n\\[\ndz = \\frac{\\partial z}{\\partial x} dx + \\frac{\\partial z}{\\partial y} dy\n\\]\nこのように，\\(z\\) が微分可能なるとき，\\(dz\\) を \\(dx, dy\\) に関する一次式で表すことを \\(z\\) の全微分とよびます．\n\n\n\n\\(z = f(x, y)\\) がある領域の各店において微分可能であるとき，その領域において微分可能という．その場合，\\(f(x, y)\\) はその領域で連続です．\n\nTheorem 1 \nある領域で \\(\\displaystyle \\frac{\\partial z}{\\partial x}, \\frac{\\partial z}{\\partial y}\\) が存在してかつ連続であるならば，\\(z\\)はその領域において微分可能である．\n\n\n\n\n\n\n\n\nNoteProof\n\n\n\n\n\n\\(\\Delta x, \\Delta y\\) をそれぞれ \\(h, k\\) と書けば\n\\[\n\\begin{align}\n\\Delta z\n  &= f(x+h, y+k) - f(x, y)\\\\\n  &= \\underbrace{f(x + h, y +k) - f(x, y +k)}_{(A)} + \\underbrace{f(x, y +k) - f(x, y)}_{(B)}\n\\end{align}\n\\]\n\nについて，\\(\\displaystyle \\frac{\\partial z}{\\partial x}\\) が存在し，連続であるので，\\(x\\) に関して平均値の定理が利用できます．つまり，\n\n\\[\nf(x + h, y + k) - f(x, y + k) = hf_x(x+ \\theta h, y +k), \\ \\ 0&lt; \\theta &lt; 1\n\\]\n仮定より \\(f_x\\) は連続であるので\n\\[\nf_x(x+ \\theta h, y +k) = f_x(x, y) + \\epsilon\n\\]\nとおけば，\\(h, k\\to 0\\) のとき \\(\\epsilon \\to 0\\).\n同様に \\(y\\) について考えると\n\\[\nf(x, y+ k) - f(x, y) = kf_y(x, y) + k\\epsilon'\n\\]\n整理すると，\n\\[\n\\Delta z = hf_x(x, y) + kf_y(x, y) + h\\epsilon + k\\epsilon'\n\\]\n\\(\\rho = \\sqrt{h^2 + k^2}\\) とすると \\(|h|\\leq \\rho, |k|\\leq \\rho\\) であるので\n\\[\nh\\epsilon + k\\epsilon' \\leq (|\\epsilon| + |\\epsilon'|)\\rho\n\\]\n従って，\n\\[\n\\Delta z = hf_x(x, y) + kf_y(x, y) + o(\\rho)\n\\]\n従って，\\(z\\) は微分可能であることがわかります．"
  },
  {
    "objectID": "posts/2025-07-03-total-differential-with-ideal-gas/index.html#微分可能性",
    "href": "posts/2025-07-03-total-differential-with-ideal-gas/index.html#微分可能性",
    "title": "理想気体の全微分",
    "section": "",
    "text": "関数 \\(z = f(x,y)\\) を \\(P = (x, y)\\) の近傍において考察します．\n\\[\n\\Delta z = f(x + \\Delta x, y + \\Delta y) - f(x, y)\n\\]\nとしたとき，次のように考える\n\\[\n\\Delta z = A\\Delta x + B\\Delta y + \\epsilon\\rho \\label{eq-differential}\n\\]\nこのとき，\n\n\\(A, B\\) は \\(\\Delta x, \\Delta y\\) には関係しない係数\n\\(\\rho = \\sqrt{\\Delta x^2 + \\Delta y^2}\\)\n\\(\\epsilon \\to 0 \\ \\ \\text{ as} \\ \\ \\rho \\to 0\\)\n\nが成立するならば，関数 \\(z\\) は点 \\(P\\) において微分可能であるといいます．\n\n\\(\\eqref{eq-differential}\\) が成り立つならば，\\(\\Delta y = 0\\) が成立するとき，\n\\[\n\\begin{align}\n\\rho &= |\\Delta x|\\\\\n\\frac{\\Delta z}{\\Delta x} &= A \\pm \\epsilon\n\\end{align}\n\\]\nこのとき，微分可能性の仮定より \\(\\Delta x \\to 0\\) と共に \\(\\epsilon \\to 0\\) だから，点P において\n\\[\n\\frac{\\partial z}{\\partial x} = A\n\\]\n同様に\n\\[\n\\frac{\\partial z}{\\partial y} = B\n\\]\n\n\n点 \\((x + \\Delta x, y + \\Delta y)\\) が一定の方向から \\((x, y)\\) に収束するとき，一定方向からなので\n\\[\n\\begin{align}\n\\Delta x &= \\rho \\cos\\alpha\\\\\n\\Delta y &= \\rho \\sin\\alpha\n\\end{align}\n\\]\nと考えることができます．このとき，\n\\[\n\\begin{gather}\n\\frac{\\Delta z}{\\rho} = A\\cos\\alpha + B\\sin\\alpha + \\epsilon\\\\\n\\lim_{\\rho\\to 0}\\frac{\\Delta z}{\\rho} = A\\cos\\alpha + B\\sin\\alpha = \\frac{\\partial z}{\\partial x} \\cos\\alpha + \\frac{\\partial z}{\\partial y} \\sin\\alpha\n\\end{gather}\n\\]\nつまり，\\(\\rho\\to 0\\) とするとき，\\(\\Delta z\\) などを \\(dz\\) と表記しなおすと\n\\[\ndz = \\frac{\\partial z}{\\partial x} dx + \\frac{\\partial z}{\\partial y} dy\n\\]\nこのように，\\(z\\) が微分可能なるとき，\\(dz\\) を \\(dx, dy\\) に関する一次式で表すことを \\(z\\) の全微分とよびます．\n\n\n\n\\(z = f(x, y)\\) がある領域の各店において微分可能であるとき，その領域において微分可能という．その場合，\\(f(x, y)\\) はその領域で連続です．\n\nTheorem 1 \nある領域で \\(\\displaystyle \\frac{\\partial z}{\\partial x}, \\frac{\\partial z}{\\partial y}\\) が存在してかつ連続であるならば，\\(z\\)はその領域において微分可能である．\n\n\n\n\n\n\n\n\nNoteProof\n\n\n\n\n\n\\(\\Delta x, \\Delta y\\) をそれぞれ \\(h, k\\) と書けば\n\\[\n\\begin{align}\n\\Delta z\n  &= f(x+h, y+k) - f(x, y)\\\\\n  &= \\underbrace{f(x + h, y +k) - f(x, y +k)}_{(A)} + \\underbrace{f(x, y +k) - f(x, y)}_{(B)}\n\\end{align}\n\\]\n\nについて，\\(\\displaystyle \\frac{\\partial z}{\\partial x}\\) が存在し，連続であるので，\\(x\\) に関して平均値の定理が利用できます．つまり，\n\n\\[\nf(x + h, y + k) - f(x, y + k) = hf_x(x+ \\theta h, y +k), \\ \\ 0&lt; \\theta &lt; 1\n\\]\n仮定より \\(f_x\\) は連続であるので\n\\[\nf_x(x+ \\theta h, y +k) = f_x(x, y) + \\epsilon\n\\]\nとおけば，\\(h, k\\to 0\\) のとき \\(\\epsilon \\to 0\\).\n同様に \\(y\\) について考えると\n\\[\nf(x, y+ k) - f(x, y) = kf_y(x, y) + k\\epsilon'\n\\]\n整理すると，\n\\[\n\\Delta z = hf_x(x, y) + kf_y(x, y) + h\\epsilon + k\\epsilon'\n\\]\n\\(\\rho = \\sqrt{h^2 + k^2}\\) とすると \\(|h|\\leq \\rho, |k|\\leq \\rho\\) であるので\n\\[\nh\\epsilon + k\\epsilon' \\leq (|\\epsilon| + |\\epsilon'|)\\rho\n\\]\n従って，\n\\[\n\\Delta z = hf_x(x, y) + kf_y(x, y) + o(\\rho)\n\\]\n従って，\\(z\\) は微分可能であることがわかります．"
  },
  {
    "objectID": "posts/2025-07-03-total-differential-with-ideal-gas/index.html#理想気体の-pvt-の全微分",
    "href": "posts/2025-07-03-total-differential-with-ideal-gas/index.html#理想気体の-pvt-の全微分",
    "title": "理想気体の全微分",
    "section": "理想気体の \\(p,v,T\\) の全微分",
    "text": "理想気体の \\(p,v,T\\) の全微分\n1molの理想気体の状態方程式は\n\\[\npv = RT\n\\]\n\\(p\\) を \\(v, T\\) の関数とする場合\n\\[\np(v, T) = \\frac{RT}{v}\n\\]\nとして，圧力 \\(p\\) を2つの独立変数 \\(v, T\\) の2変数関数とすると，\n\\[\n\\begin{align}\ndp &= \\left(\\frac{\\partial p}{\\partial v}\\right)_T dv + \\left(\\frac{\\partial p}{\\partial T}\\right)_vdT\\\\\n   &= -\\frac{RT}{v^2}dv + \\frac{R}{v}dT\n\\end{align}\n\\]\n\\(v\\) を \\(p, T\\) の関数とする場合\n\\[\ndv = -\\frac{RT}{p^2}dp + \\frac{R}{p}dT\n\\]\n\\(T\\) を \\(p, v\\) の関数とする場合\n\\[\ndT = \\frac{v}{R}dp + \\frac{p}{R}dv\n\\]"
  },
  {
    "objectID": "posts/2025-07-11-oss-contribution/index.html",
    "href": "posts/2025-07-11-oss-contribution/index.html",
    "title": "GitHub OSS Contribution: ForkからPull Request",
    "section": "",
    "text": "GitHubで ForkからPull Requestを出す手順を紹介します\n修正箇所は事前に見つかっている前提とします"
  },
  {
    "objectID": "posts/2025-07-11-oss-contribution/index.html#スコープ",
    "href": "posts/2025-07-11-oss-contribution/index.html#スコープ",
    "title": "GitHub OSS Contribution: ForkからPull Request",
    "section": "",
    "text": "GitHubで ForkからPull Requestを出す手順を紹介します\n修正箇所は事前に見つかっている前提とします"
  },
  {
    "objectID": "posts/2025-07-11-oss-contribution/index.html#oss-contributionまでの手順",
    "href": "posts/2025-07-11-oss-contribution/index.html#oss-contributionまでの手順",
    "title": "GitHub OSS Contribution: ForkからPull Request",
    "section": "🔨 OSS contributionまでの手順",
    "text": "🔨 OSS contributionまでの手順\n\n\n\n\n\nsequenceDiagram\n    participant 開発者 as Local repo\n    participant フォークしたリポジトリ as fork repo\n    participant オリジナルのリポジトリ as original repo\n    participant リポジトリの所有者 as repository owner\n\n    オリジナルのリポジトリ-&gt;&gt;フォークしたリポジトリ: フォークする\n    フォークしたリポジトリ-&gt;&gt;開発者: クローンを作成\n    開発者-&gt;&gt;開発者: 機能ブランチを作成\n    開発者-&gt;&gt;開発者: コードの変更とテスト\n    開発者-&gt;&gt;フォークしたリポジトリ: 変更をpush\n    フォークしたリポジトリ-&gt;&gt;オリジナルのリポジトリ: プルリクエストを送信\n    オリジナルのリポジトリ-&gt;&gt;リポジトリの所有者: レビュー依頼\n    リポジトリの所有者-&gt;&gt;オリジナルのリポジトリ: コメントとフィードバック\n    オリジナルのリポジトリ-&gt;&gt;開発者: レビュー内容の共有\n    開発者-&gt;&gt;開発者: 修正作業（ローカル）\n    開発者-&gt;&gt;フォークしたリポジトリ: 修正をpush\n    フォークしたリポジトリ-&gt;&gt;オリジナルのリポジトリ: プルリクエストを更新\n    リポジトリの所有者-&gt;&gt;オリジナルのリポジトリ: プルリクエストを承認\n    リポジトリの所有者-&gt;&gt;オリジナルのリポジトリ: プルリクエストをマージ\n\n\n\n\n\n\n\n\n\n\n\n\nNoteREMARKS\n\n\n\n\n通常「repository owner」のみが，original repositoryに対して直接操作\n実際の運用では，レビューは複数人で行われることもあるが，上のシークエンス図ではシンプルに一人と仮定\n\n\n\n\nStep 1: プロジェクトルールの事前確認\n開発をスタートする前に，以下のルール文書を必ず確認してください．これらはコードレビューを円滑かつ効率的に進めるための共通認識を定めたもので，遵守することでPRは「内容」に集中した建設的なレビューになり，反復的なスタイル修正や手戻りを最小化できます．\n\n\n\n\n\n\n\n\nファイル名\n目的・レビュー効率への寄与\n\n\n\n\ncontribution.md\nPR 作成のフォーマットや粒度，コミットメッセージの書き方が明文化されており，認識のズレを減らせます．\n\n\nbranch-strategy.md\n適切なブランチ運用により，他の開発との競合やマージ事故を防ぎ，レビュー対象を明確にできます．\n\n\ncoding-convention.md\nスタイルや命名規則が統一されていることで，コード内容の議論に集中でき，フォーマットの指摘を減らせます．\n\n\n.editorconfig\nインデント幅・改行コード・文字コードなどのエディタ設定が統一され，スタイル差分の混入を防ぎます．\n\n\n\n\nプロジェクトルール確認チェックリスト\n\ncontribution.md を読んだ\nbranch-strategy.md に従ってブランチを作成した\ncoding-convention.md に準拠したコードを書いた\n.editorconfig に準拠したエディタ設定を行っている\n\n\n\nStep 2: Issueを作成\nPRを出す前に，まず Issue を作成して修正提案を相談します．\n\nExample 1 🐞 Bug Report: caption-number: false is not respected in metadata\n\n\nDescription\nWhen setting the following in Quarto YAML front matter:\npseudocode:\n  caption-number: false\nthe pseudocode filter still adds numbers to the captions. The expected behavior is that setting caption-number: false should disable caption numbering.\n\n\nCurrent Behavior\nThe false value is ignored, because false or x always evaluates to x in Lua. Therefore, the default is used even when false is explicitly specified.\n\n\nProposed Fix\nReplace line 268 in pseudocode.lua:\nglobal_options.caption_number = doc.meta[\"pseudocode\"][\"caption-number\"] or global_options.caption_number\nwith:\nif doc.meta.pseudocode and doc.meta.pseudocode[\"caption-number\"] ~= nil then\n  global_options.caption_number = doc.meta.pseudocode[\"caption-number\"]\nelse\n  global_options.caption_number = global_options.caption_number\nend\n\nBtw, thank you for developing this great extension — I really appreciate your work and love using it in my quarto projects!\n\n\n\n\n\n\nStep 3: Fork（リポジトリを複製）\n\nPRを送りたいリポジトリにアクセス\n右上の [Fork] ボタンをクリックして，自分のアカウントに複製\n\n\n\nStep 4: 自分の環境にClone & 開発用ブランチの作成\ngit clone https://github.com/your-username/project-name.git\ncd project-name\ngit switch -c my-feature-or-fix\n\n\n\n\n\n\nNote\n\n\n\n\nbranch strategyに則ったブランチ名をつけるようにします\n\n\n\n\n\nStep 4: git commit and push\nコードを編集し，コミットします\n# 編集後\ngit add .\ngit commit -m \"Fix: typo in README\"\n\n# fork repositoryへpush\ngit push origin my-feature-or-fix\n\n\n\n\n\n\nNotecommit message方針\n\n\n\ncontribution.md や開発者ガイドに則したコミットメッセージを記載します．基本構造としては．\n&lt;タイプ&gt;: &lt;短く要点を伝えるメッセージ（50文字以内）&gt;\nPrefix例\n\n\n\n\n\n\n\n\n\nPrefix\n意味・用途\n使用例（タイトル）\n\n\n\n\nFix\nバグ修正\nFix: crash when input is null\n\n\nImplement\nロジックや処理を新規実装\nImplement: user login logic with token generation\n\n\nEnhance\n仕様に基づいた変更や改善．振る舞いを変更するがバグではない場合\nEnhance: replace polling with websocket\n\n\nRemove\n機能やコードの削除．不要になった処理を明確に消すとき\nRemove: deprecated API endpoint\n\n\nRefactor\n動作に影響を与えない内部構造の改善（リネーム，分割，整理など）\nRefactor: split UserService into modules\n\n\nDocs\nドキュメントの変更（README，注釈，Wiki連携など）\nDocs: fix typo in usage example\n\n\nTest\nテストコードの追加・変更\nTest: add edge case test for empty array\n\n\nStyle\nフォーマット・コードスタイル修正（意味のある動作変更なし）\nStyle: format code with Prettier\n\n\nRevert\n以前のコミットを取り消す\nRevert: remove async version due to bug\n\n\nPerf\nパフォーマンス改善\nPerf: reduce image loading time by 50%\n\n\nBuild\nビルドシステムや依存関係の変更（npm, poetry, Dockerなど）\nBuild: upgrade TypeScript to v5.3\n\n\n\n\n\n\n\n\nStep 5: Pull Request作成\n\nGitHub上で，「Compare & pull request」をクリックし，PRを作成します\nPR作成後，diff内容に問題がなければ Create Pull Request をクリックします．\n\nこれらの手続きを実行すると，PR送り先リポジトリの管理者にPRが作成されたことが通知されます．\n\n\n\n\n\n\nNotePR作成チェックリスト\n\n\n\n\nIssueを事前に作成している\nタイトルと説明が明確\n関連Issueがリンクされている\n\n\n\n\nExample 2 FIX: respecting caption-number: false in user setting\n\n\nRelated Issue\n\n#8\n\n\n\nDescription\nThis PR updates the logic assigning global_options.caption_number so that a user-specified false value in doc.meta.pseudocode[\"caption-number\"] is not overridden by the default.\n\nBefore\nThe old logic:\n  global_options.caption_number = doc.meta[\"pseudocode\"][\"caption-number\"] or global_options.caption_number\ncaused issues when caption-number: false was explicitly set in metadata. Since false is false in Lua, it incorrectly fell back to the default.\n\n\nAfter\nThis fix ensures that false is respected by explicitly checking for nil:\nif doc.meta.pseudocode and doc.meta.pseudocode[\"caption-number\"] ~= nil then\n  global_options.caption_number = doc.meta.pseudocode[\"caption-number\"]\nelse\n  global_options.caption_number = global_options.caption_number\nend"
  },
  {
    "objectID": "posts/2025-07-11-oss-contribution/index.html#description",
    "href": "posts/2025-07-11-oss-contribution/index.html#description",
    "title": "GitHub OSS Contribution: ForkからPull Request",
    "section": "Description",
    "text": "Description\nWhen setting the following in Quarto YAML front matter:\npseudocode:\n  caption-number: false\nthe pseudocode filter still adds numbers to the captions. The expected behavior is that setting caption-number: false should disable caption numbering."
  },
  {
    "objectID": "posts/2025-07-11-oss-contribution/index.html#current-behavior",
    "href": "posts/2025-07-11-oss-contribution/index.html#current-behavior",
    "title": "GitHub OSS Contribution: ForkからPull Request",
    "section": "Current Behavior",
    "text": "Current Behavior\nThe false value is ignored, because false or x always evaluates to x in Lua. Therefore, the default is used even when false is explicitly specified."
  },
  {
    "objectID": "posts/2025-07-11-oss-contribution/index.html#proposed-fix",
    "href": "posts/2025-07-11-oss-contribution/index.html#proposed-fix",
    "title": "GitHub OSS Contribution: ForkからPull Request",
    "section": "Proposed Fix",
    "text": "Proposed Fix\nReplace line 268 in pseudocode.lua:\nglobal_options.caption_number = doc.meta[\"pseudocode\"][\"caption-number\"] or global_options.caption_number\nwith:\nif doc.meta.pseudocode and doc.meta.pseudocode[\"caption-number\"] ~= nil then\n  global_options.caption_number = doc.meta.pseudocode[\"caption-number\"]\nelse\n  global_options.caption_number = global_options.caption_number\nend\n\nBtw, thank you for developing this great extension — I really appreciate your work and love using it in my quarto projects!"
  },
  {
    "objectID": "posts/2025-07-11-oss-contribution/index.html#related-issue",
    "href": "posts/2025-07-11-oss-contribution/index.html#related-issue",
    "title": "GitHub OSS Contribution: ForkからPull Request",
    "section": "Related Issue",
    "text": "Related Issue\n\n#8"
  },
  {
    "objectID": "posts/2025-07-11-oss-contribution/index.html#description-1",
    "href": "posts/2025-07-11-oss-contribution/index.html#description-1",
    "title": "GitHub OSS Contribution: ForkからPull Request",
    "section": "Description",
    "text": "Description\nThis PR updates the logic assigning global_options.caption_number so that a user-specified false value in doc.meta.pseudocode[\"caption-number\"] is not overridden by the default.\n\nBefore\nThe old logic:\n  global_options.caption_number = doc.meta[\"pseudocode\"][\"caption-number\"] or global_options.caption_number\ncaused issues when caption-number: false was explicitly set in metadata. Since false is false in Lua, it incorrectly fell back to the default.\n\n\nAfter\nThis fix ensures that false is respected by explicitly checking for nil:\nif doc.meta.pseudocode and doc.meta.pseudocode[\"caption-number\"] ~= nil then\n  global_options.caption_number = doc.meta.pseudocode[\"caption-number\"]\nelse\n  global_options.caption_number = global_options.caption_number\nend"
  },
  {
    "objectID": "posts/2025-07-11-oss-contribution/index.html#references",
    "href": "posts/2025-07-11-oss-contribution/index.html#references",
    "title": "GitHub OSS Contribution: ForkからPull Request",
    "section": "References",
    "text": "References\n\nGitHub Docs &gt; Creating a pull request"
  },
  {
    "objectID": "posts/2025-02-20-sort-pivot-table/index.html",
    "href": "posts/2025-02-20-sort-pivot-table/index.html",
    "title": "pivot tableのcolumn, rowのsort",
    "section": "",
    "text": "Exercise 1 \n\n\nCode\nimport numpy as np\nimport pandas as pd\n\nnp.random.seed(42)\n\ndef random_choice_from_list(\n    candidate: list | np.ndarray,\n    sampling_size: int,\n    p: list | tuple | np.ndarray = None,\n):\n    if sampling_size &lt;= 0:\n        raise ValueError(\"sampling_size must be greater than 0.\")\n\n    if p is None:\n        p = np.repeat(1 / len(candidate), sampling_size)\n\n    if min(p) &lt; 0 or max(p) &gt; 1:\n        raise ValueError(\"All probabilities in 'p' must be between 0 and 1 inclusive.\")\n\n    if not np.isclose(sum(p), 1):\n        raise ValueError(\"The probabilities in 'p' must sum to 1.\")\n\n    return np.random.choice(candidate, size=sampling_size, p=p)\n\n\n# Params\nN = 100\nA_list = [\"H\", \"He\", \"Li\", \"Be\", \"B\", \"C\", \"N\", \"O\", \"F\", \"Ne\"]\nA_prob = np.array([1, 4, 3, 4, 1, 6, 7, 8, 9, 10])\nA_prob = A_prob / sum(A_prob)\n\nB_list = [\"one\", \"two\", \"three\", \"four\"]\nB_prob = np.array([7, 8, 6, 1])\nB_prob = B_prob / sum(B_prob)\n\n\n# DGP\ndf = pd.DataFrame(\n    {\n        \"element\": random_choice_from_list(A_list, N, A_prob),\n        \"class\": random_choice_from_list(B_list, N, B_prob),\n        \"density\": np.random.uniform(0, 1, N),\n    }\n)\n\ndf.head()\n\n\n\n\n\n\n\n\n\nelement\nclass\ndensity\n\n\n\n\n0\nN\none\n0.642032\n\n\n1\nNe\ntwo\n0.084140\n\n\n2\nF\none\n0.161629\n\n\n3\nO\ntwo\n0.898554\n\n\n4\nBe\nthree\n0.606429\n\n\n\n\n\n\n\n ▶  問題設定\n\n上記のデータについて (element, class) をkey，frequencyをvalueとした二次元分割表を作成する\n二次元分割表をcolumn, rowそれぞれの方向について，合計frequencyに基づいたsortを行う"
  },
  {
    "objectID": "posts/2025-02-20-sort-pivot-table/index.html#問題設定",
    "href": "posts/2025-02-20-sort-pivot-table/index.html#問題設定",
    "title": "pivot tableのcolumn, rowのsort",
    "section": "",
    "text": "Exercise 1 \n\n\nCode\nimport numpy as np\nimport pandas as pd\n\nnp.random.seed(42)\n\ndef random_choice_from_list(\n    candidate: list | np.ndarray,\n    sampling_size: int,\n    p: list | tuple | np.ndarray = None,\n):\n    if sampling_size &lt;= 0:\n        raise ValueError(\"sampling_size must be greater than 0.\")\n\n    if p is None:\n        p = np.repeat(1 / len(candidate), sampling_size)\n\n    if min(p) &lt; 0 or max(p) &gt; 1:\n        raise ValueError(\"All probabilities in 'p' must be between 0 and 1 inclusive.\")\n\n    if not np.isclose(sum(p), 1):\n        raise ValueError(\"The probabilities in 'p' must sum to 1.\")\n\n    return np.random.choice(candidate, size=sampling_size, p=p)\n\n\n# Params\nN = 100\nA_list = [\"H\", \"He\", \"Li\", \"Be\", \"B\", \"C\", \"N\", \"O\", \"F\", \"Ne\"]\nA_prob = np.array([1, 4, 3, 4, 1, 6, 7, 8, 9, 10])\nA_prob = A_prob / sum(A_prob)\n\nB_list = [\"one\", \"two\", \"three\", \"four\"]\nB_prob = np.array([7, 8, 6, 1])\nB_prob = B_prob / sum(B_prob)\n\n\n# DGP\ndf = pd.DataFrame(\n    {\n        \"element\": random_choice_from_list(A_list, N, A_prob),\n        \"class\": random_choice_from_list(B_list, N, B_prob),\n        \"density\": np.random.uniform(0, 1, N),\n    }\n)\n\ndf.head()\n\n\n\n\n\n\n\n\n\nelement\nclass\ndensity\n\n\n\n\n0\nN\none\n0.642032\n\n\n1\nNe\ntwo\n0.084140\n\n\n2\nF\none\n0.161629\n\n\n3\nO\ntwo\n0.898554\n\n\n4\nBe\nthree\n0.606429\n\n\n\n\n\n\n\n ▶  問題設定\n\n上記のデータについて (element, class) をkey，frequencyをvalueとした二次元分割表を作成する\n二次元分割表をcolumn, rowそれぞれの方向について，合計frequencyに基づいたsortを行う"
  },
  {
    "objectID": "posts/2025-02-20-sort-pivot-table/index.html#solution-with-pandas",
    "href": "posts/2025-02-20-sort-pivot-table/index.html#solution-with-pandas",
    "title": "pivot tableのcolumn, rowのsort",
    "section": "Solution with pandas",
    "text": "Solution with pandas\n\n\n\n\n\n\n\nNoteTask 1: (element, class) をkey，frequencyをvalueとした二次元分割表を作成する\n\n\n\n\n\npandas.pivot_tableを用いればかんたんに実行できます．\n\n\nCode\n# Compute the pivot table\npivot_table = pd.pivot_table(\n    df,\n    index=\"element\",  # Rows\n    columns=\"class\",  # Columns\n    aggfunc=\"size\",  # Frequency count\n    fill_value=0,  # Fill missing values with 0\n)\n\npivot_table\n\n\n\n\n\n\n\n\nclass\nfour\none\nthree\ntwo\n\n\nelement\n\n\n\n\n\n\n\n\nBe\n0\n4\n5\n1\n\n\nC\n0\n4\n4\n6\n\n\nF\n0\n6\n4\n6\n\n\nH\n0\n0\n0\n1\n\n\nHe\n0\n4\n2\n5\n\n\nLi\n1\n2\n3\n1\n\n\nN\n1\n4\n2\n1\n\n\nNe\n0\n5\n4\n7\n\n\nO\n1\n6\n4\n6\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNoteTask 2: 二次元分割表をcolumn, rowそれぞれの方向について，合計frequencyに基づいたsortを行う\n\n\n\n\n\npivot table化された pandas.DataFrame に対するソート操作は\n\nrow操作 ; .loc のindexの操作\ncolumn操作: .loc のcolumnの操作\n\nとなります．\n ▶  rowのsort\n\n\nCode\npivot_table = pivot_table.loc[\n    pivot_table.sum(axis=1).sort_values(ascending=False).index\n]\npivot_table\n\n\n\n\n\n\n\n\nclass\nfour\none\nthree\ntwo\n\n\nelement\n\n\n\n\n\n\n\n\nO\n1\n6\n4\n6\n\n\nNe\n0\n5\n4\n7\n\n\nF\n0\n6\n4\n6\n\n\nC\n0\n4\n4\n6\n\n\nHe\n0\n4\n2\n5\n\n\nBe\n0\n4\n5\n1\n\n\nN\n1\n4\n2\n1\n\n\nLi\n1\n2\n3\n1\n\n\nH\n0\n0\n0\n1\n\n\n\n\n\n\n\n ▶  columnのsort\n\n\nCode\npivot_table = pivot_table.loc[:, pivot_table.sum(axis=0).sort_values(ascending=False).index]\npivot_table\n\n\n\n\n\n\n\n\nclass\none\ntwo\nthree\nfour\n\n\nelement\n\n\n\n\n\n\n\n\nO\n6\n6\n4\n1\n\n\nNe\n5\n7\n4\n0\n\n\nF\n6\n6\n4\n0\n\n\nC\n4\n6\n4\n0\n\n\nHe\n4\n5\n2\n0\n\n\nBe\n4\n1\n5\n0\n\n\nN\n4\n1\n2\n1\n\n\nLi\n2\n1\n3\n1\n\n\nH\n0\n1\n0\n0\n\n\n\n\n\n\n\n ▶  検証\n\n\nCode\npivot_table_total = pivot_table.copy()\n\n# row sum\npivot_table_total['total'] = pivot_table_total.sum(axis=1)\n\n# column sum\npivot_table_total.loc['column_sum'] =  pivot_table_total.sum(axis=0)\n\n# 検証\npivot_table_total\n\n\n\n\n\n\n\n\nclass\none\ntwo\nthree\nfour\ntotal\n\n\nelement\n\n\n\n\n\n\n\n\n\nO\n6\n6\n4\n1\n17\n\n\nNe\n5\n7\n4\n0\n16\n\n\nF\n6\n6\n4\n0\n16\n\n\nC\n4\n6\n4\n0\n14\n\n\nHe\n4\n5\n2\n0\n11\n\n\nBe\n4\n1\n5\n0\n10\n\n\nN\n4\n1\n2\n1\n8\n\n\nLi\n2\n1\n3\n1\n7\n\n\nH\n0\n1\n0\n0\n1\n\n\ncolumn_sum\n35\n34\n28\n3\n100"
  },
  {
    "objectID": "posts/2025-02-20-sort-pivot-table/index.html#visualization",
    "href": "posts/2025-02-20-sort-pivot-table/index.html#visualization",
    "title": "pivot tableのcolumn, rowのsort",
    "section": "Visualization",
    "text": "Visualization\n\n可視化方針 \n\nclass出現割合はelement毎に大きく異なるのかみたい\nfrequencyそのままで比較すると出現割合比較にならないので，axis = 1の方向で割合として計算する(以後，normalized_pivotと呼ぶ)\nnormalized_pivotをheatmapで可視化する，可視化の際に出現頻度を右側に参照できるようにする(sample sizeが小さいところは無視したい)\n\n\n ▶  normalized_pivot の作成\n\n\nCode\nnormalized_pivot = pivot_table.div(pivot_table.sum(axis=1), axis=0)\nnormalized_pivot\n\n\n\n\n\n\n\n\nclass\none\ntwo\nthree\nfour\n\n\nelement\n\n\n\n\n\n\n\n\nO\n0.352941\n0.352941\n0.235294\n0.058824\n\n\nNe\n0.312500\n0.437500\n0.250000\n0.000000\n\n\nF\n0.375000\n0.375000\n0.250000\n0.000000\n\n\nC\n0.285714\n0.428571\n0.285714\n0.000000\n\n\nHe\n0.363636\n0.454545\n0.181818\n0.000000\n\n\nBe\n0.400000\n0.100000\n0.500000\n0.000000\n\n\nN\n0.500000\n0.125000\n0.250000\n0.125000\n\n\nLi\n0.285714\n0.142857\n0.428571\n0.142857\n\n\nH\n0.000000\n1.000000\n0.000000\n0.000000\n\n\n\n\n\n\n\n ▶  可視化コード\n\n\nCode\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n\n# Plot heatmap\nfig, ax = plt.subplots(1, 2, figsize=(10, 6), gridspec_kw={\"width_ratios\": [3, 1]})\n\nsns.heatmap(normalized_pivot, annot=True, fmt=\".2f\", cmap=\"PuBu\", ax=ax[0])\nax[0].set_title(\"Heatmap of Normalized Pivot Table\")\nax[0].set_ylabel(\"Element\")\nax[0].set_xlabel(\"Class\")\n\nsns.barplot(\n    y=pivot_table.index,\n    x=pivot_table.sum(axis=1),\n    alpha=0.8,\n    color=\"#0047AB\",\n    orient=\"h\",\n    ax=ax[1],\n)\nax[1].set_title(\"Element Frequency Barplot\")\nax[1].set_xlabel(\"Frequency\")\n\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTip🍵 color mapのカスタマイズ\n\n\n\ncolor sequenceをlightcoral, ivory, Dodgersblue という順番にしたい場合は\n\n\nCode\nfrom matplotlib.colors import LinearSegmentedColormap\n\ncustom_cpam = LinearSegmentedColormap.from_list(\"lightcoral_ivory_blue\", [\"#F08080\", \"#FFFFF0\", \"#1E90FF\"])\n\n\nとすることで自分好みにカスタマイズすることができます．\n\n\nCode\n# Plot heatmap\nfig, ax = plt.subplots(1, 2, figsize=(10, 6), gridspec_kw={\"width_ratios\": [3, 1]})\n\nsns.heatmap(normalized_pivot, annot=True, fmt=\".2f\", cmap=custom_cpam , ax=ax[0])\nax[0].set_title(\"Heatmap of Normalized Pivot Table\")\nax[0].set_ylabel(\"Element\")\nax[0].set_xlabel(\"Class\")\n\nsns.barplot(\n    y=pivot_table.index,\n    x=pivot_table.sum(axis=1),\n    alpha=1,\n    color=\"#6699CC\",\n    orient=\"h\",\n    ax=ax[1],\n)\nax[1].set_title(\"Element Frequency Barplot\")\nax[1].set_xlabel(\"Frequency\")\n\nplt.tight_layout()\nplt.show()"
  },
  {
    "objectID": "posts/2025-02-04-add-distance-measurement/index.html",
    "href": "posts/2025-02-04-add-distance-measurement/index.html",
    "title": "単曲線と追加距離の計算",
    "section": "",
    "text": "▶  基本用語"
  },
  {
    "objectID": "posts/2025-02-04-add-distance-measurement/index.html#基本問題-曲線の長さを求める",
    "href": "posts/2025-02-04-add-distance-measurement/index.html#基本問題-曲線の長さを求める",
    "title": "単曲線と追加距離の計算",
    "section": "基本問題: 曲線の長さを求める",
    "text": "基本問題: 曲線の長さを求める\n\n\nExercise 1 \n下図に示すような単曲線ABを含む路線の中心線を設置することになった．\n\n扇形 \\(OAB\\) の半径 \\(r = 300\\)\n\\(\\displaystyle\\angle (IP) = \\frac{\\pi}{3}\\)\n\\(IP\\) までの追加距離を623(中心杭はAの手前にあるとする)\n\nとする．このとき，曲線の始点 \\(A\\) と 曲線の終点 \\(B\\) それぞれの追加距離を求めよ．なお，直線 \\(A(IP)\\) と \\(B(IP)\\) はそれぞれ円の接線であるとする．\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n\ndef draw_circle_with_two_tangent(x0, y0, r, ax, theta_start=0, theta_end=2 * np.pi, notations=('O', 'A', 'B', 'IP')):\n    # Generate circle points\n    theta = np.linspace(theta_start, theta_end, 720)\n    x_circle = x0 + r * np.cos(theta)\n    y_circle = y0 + r * np.sin(theta)\n\n    # plot\n    ax.plot(x_circle, y_circle, \"gray\", label=\"Circle (r={radius})\")\n    ax.plot([x0, x_circle[0]], [y0, y_circle[0]], \"gray\", linestyle=\"--\")\n    ax.plot([x0, x_circle[-1]], [y0, y_circle[-1]], \"gray\", linestyle=\"--\")\n    ax.text(x0, y0, notations[0], verticalalignment=\"top\", horizontalalignment=\"left\")\n    ax.scatter(x0, y0, color=\"k\")\n\n    # add text\n    ax.text(x_circle[-1], y_circle[-1], notations[1], label=\"Circle (r={radius})\")\n    ax.scatter(x_circle[-1], y_circle[-1], color=\"k\")\n    ax.text(x_circle[0], y_circle[0], notations[2], label=\"Circle (r={radius})\")\n    ax.scatter(x_circle[0], y_circle[0], color=\"k\")\n\n    # plot external intersection points\n    mid_theta = (theta_start + theta_end) / 2\n    diff_theta = (theta_end - theta_start) / 2 \n    external_x = np.cos(mid_theta) * abs(r / np.cos(diff_theta)) + x0\n    external_y = np.sin(mid_theta) * abs(r / np.cos(diff_theta)) + y0\n\n    ax.scatter(external_x, external_y, color=\"k\")\n    ax.text(external_x, external_y, notations[3], verticalalignment=\"bottom\", horizontalalignment=\"left\")\n    ax.plot(\n        [external_x, x_circle[0]], [external_y, y_circle[0]], \"gray\", linestyle=\"-\"\n    )\n    ax.plot(\n        [external_x, x_circle[-1]], [external_y, y_circle[-1]], \"gray\", linestyle=\"-\"\n    )\n\n    return {'A': (x_circle[-1], y_circle[-1]), 'B': (x_circle[0], y_circle[0]), 'IP': (external_x, external_y )}\n\n\n# params\nx0, y0, r0 = 200, 100, 300\ntheta_start = np.pi / 10\ntheta_end = np.pi / 10 + np.pi * 2/ 3\n\nfig, ax = plt.subplots(figsize=(6, 6))\ncoordinates = draw_circle_with_two_tangent(x0, y0, r0, ax, theta_start, theta_end)\nax.grid(True, linestyle=\"--\", alpha=0.6)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNoteSolution\n\n\n\n\n\n曲線の始点 \\(A\\) の追加距離は\n\\[\nA\\text{の追加距離} = IP\\text{の追加距離} - \\text{A(IP)の長さ}\n\\]\n直線 \\(A(IP)\\) は中心点 \\(O\\) とする円に接しているので\n\\[\n\\text{AOの長さ} \\times \\tan(\\angle (IP)OA)\n\\]\n接弦定理と円周角の定理より \\(\\angle (IP)\\) の外角を \\(I\\) とすると\n\\[\n\\begin{align}\n\\angle AOB &= I\\\\\n\\angle (IP)OA &= \\frac{I}{2}\n\\end{align}\n\\]\nしたがって，\n\\[\n\\text{AOの長さ} \\times \\tan \\frac{I}{2}\n\\]\n以上より\n\\[\n\\begin{align}\nA\\text{の追加距離}\n    &= 623 - 300 \\times \\tan \\frac{\\pi}{3}\\\\\n    &= 623 - 300\\sqrt{3} \\approx 103.4\n\\end{align}\n\\]\nまた，\\(B\\text{の追加距離}\\) は，弧 \\(AB\\) の長さがわかれば\n\\[\nB\\text{の追加距離} = A\\text{の追加距離} + \\text{弧}AB\\text{の長さ}\n\\]\nと計算できる．\n\\[\n\\begin{align}\n\\text{弧}AB\\text{の長さ}\n    &= R \\times I\\\\\n    &= 300 \\times \\frac{2}{3}\\pi\\\\\n    &= 200\\pi\n\\end{align}\n\\]\nしたがって，\n\\[\nB\\text{の追加距離} \\approx 103.4 + 628.40 = 731.80\n\\]\n実際にAの追加距離をPythonで近似計算してみると\n\n\nCode\nA, IP = np.array(coordinates['A']), np.array(coordinates['IP'])\nA_add_distance = 623 - np.linalg.norm(A - IP)\nprint(f\"Aの追加距離 = {A_add_distance:.2f}\")\n\n\nAの追加距離 = 103.38\n\n\n\n\n\n\n\nExercise 2 \n曲線半径 \\(r_1 = 400\\), \\(\\displaystyle\\angle AO_1B = \\frac{\\pi}{2}\\) となるような形で現道路 \\(AB\\) が存在するとする． 現在の道路を改良し \\(O_2\\) を中心とする円曲線からなる新しい道路 \\(AB_2\\) を建設したいとします．\n新しい道路の交点 \\(IP\\) の１は現道路と変わらないとする．\n\\(\\displaystyle\\angle AO_2B_2 = \\frac{\\pi}{3}\\) としたとき，\\(AB_2\\) の路線長を求めよ．\n\n\nCode\n# params\nx0, y0, r0 = 200, 100, 400\ntheta_start = np.pi / 3\ntheta_end = np.pi / 3 + np.pi / 2\n\nfig, ax = plt.subplots(figsize=(6, 6))\ncoordinates = draw_circle_with_two_tangent(x0, y0, r0, ax, theta_start, theta_end, ('$O_1$', '$A$', '$B_1$', '$IP$'))\nax.grid(True, linestyle=\"--\", alpha=0.6)\n\nr_new = 400 / np.tan(np.pi/6) \nA = np.array(coordinates['A'])\nO = np.array((200, 100))\nAO = O - A\nO_new = A + (AO / np.linalg.norm(AO)) * r_new\n\ncoordinates_new = draw_circle_with_two_tangent(*O_new, r_new, ax, theta_end - np.pi/3, theta_end, ('$O_2$', '$A$', '$B_2$', '$IP$'))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNoteSolution\n\n\n\n\n\n新道路の曲線半径を \\(r_2\\) としたとき，\\(A(IP)\\) の長さは\n\\[\n\\begin{align}\nA(IP)\n    &= r_1 \\times \\tan \\frac{\\pi}{4}\\\\\n    &= r_2 \\times \\tan \\frac{\\pi}{6}\n\\end{align}\n\\]\nと表されるので\n\\[\n\\begin{align}\nr_2\n    &= \\frac{400 \\times 1 }{\\tan \\frac{\\pi}{6}}\\\\\n    &= 400\\times \\sqrt{3}\n    &\\approx 400\\times 1.732\\\\\n    &= 692.8\n\\end{align}\n\\]\nしたがって，\n\\[\n\\text{曲線}AB_2 = 692.8 \\times \\frac{\\pi}{3} \\approx 725.1\n\\]"
  },
  {
    "objectID": "posts/2025-02-04-add-distance-measurement/index.html#障害物がある場合の曲線設定",
    "href": "posts/2025-02-04-add-distance-measurement/index.html#障害物がある場合の曲線設定",
    "title": "単曲線と追加距離の計算",
    "section": "障害物がある場合の曲線設定",
    "text": "障害物がある場合の曲線設定\n\n\nExercise 3 \n\n曲線半径 \\(r = 200\\)\n\\(A_1B_1\\) の長さ 100\n\\(\\angle AA_1B_1 = 150^\\circ\\)\n\\(\\angle BB_1A_1 = 120^\\circ\\)\n\nという情報が与えられているとき，線分 \\(AA_1\\) の長さを求めよ．なお，直線 \\(A(IP)\\) と \\(B(IP)\\) はそれぞれ円の接線であるとする．\n\n\nCode\n# params\nx0, y0, r0 = 200, 100, 200\ntheta_start = np.pi / 3\ntheta_end = theta_start + np.pi / 2\n\nfig, ax = plt.subplots(figsize=(6, 6))\nax.grid(True, linestyle=\"--\", alpha=0.6)\n\n## draw an arc\ncoordinates = draw_circle_with_two_tangent(x0, y0, r0, ax, theta_start, theta_end, ('$O$', '$A$', '$B$', '$IP$'))\n\n## drar mid-points\nB_IP = np.array(coordinates['B']) - np.array(coordinates['IP'])\nA_IP = np.array(coordinates['A']) - np.array(coordinates['IP'])\nB_1 = np.array(coordinates['IP']) + B_IP / np.linalg.norm(B_IP) * 100 / 2\nA_1 = np.array(coordinates['IP']) + A_IP / np.linalg.norm(A_IP) * 100 / 2 * np.sqrt(3)\n\nax.plot(\n        [A_1[0], B_1[0]], [A_1[1], B_1[1]], \"gray\", linestyle=\"-\"\n    )\n\nax.text(A_1[0], A_1[1], \"$A_1$\")\nax.text(B_1[0], B_1[1], \"$B_1$\")\n\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNoteSolution\n\n\n\n\n\n\\(\\displaystyle\\angle AOB = \\frac{\\pi}{2}\\) であるので\n\\[\n\\text{length of }A(IP) = 200 \\times \\tan 45^\\circ = 200\n\\]\n正弦定理より\n\\[\n\\frac{A_1B_1}{\\sin \\angle (IP)} = \\frac{A_1(IP)}{\\sin \\angle (IP)B_1A_1}\n\\]\nしたがって，\n\\[\n\\begin{align}\n\\text{length of }A_1(IP)\n    &= 100 \\times \\sin \\angle (IP)B_1A_1\\\\\n    &= 100 \\times \\frac{\\sqrt{3}}{2}\\\\\n    &\\approx 50 \\times 1.732 = 86.60\n\\end{align}\n\\]\n以上より\n\\[\n\\text{length of }AA_1 = 200 - 86.60 = 113.40\n\\]\nPythonで確認すると\n\n\nCode\nres = np.linalg.norm(np.array(coordinates['A']) - A_1)\nprint(f\"点Aから点A_1までの距離 = {res:.2f}\")\n\n\n点Aから点A_1までの距離 = 113.40"
  },
  {
    "objectID": "posts/2025-04-01-how-to-read-map/index.html",
    "href": "posts/2025-04-01-how-to-read-map/index.html",
    "title": "地図と標準誤差",
    "section": "",
    "text": "すべての地物は地図上で正しい位置に表現されるのが理想ですが，縮尺化して表される性質上，表現が細かくなりすぎて見えなくなる地物があります． このような場合，以下のような処理がなされる場合があります：\n\n\n\n\n\n\n\n\n\n処理\n内容\nコメント\n\n\n\n\n取捨選択\n描ききれない地物を間引く\n目的の地図に建物を描く必要がなければ取捨選択によって省略される\n\n\n総描\n地形の形状を誇張・省略する\n河川や登山道などは曲がっていることを地図上では示していて，どのように曲がっているかは示さない\n\n\n転位\n地物を元の位置からずらして表現する\n一般道の上を走っている高架道路は，そのまま描くと一般道と重なってしまうので転位によって意図的にずらして両方を地図上に表示させる\n\n\n\n\n\n\n\n\n\n\nNote基本ルール\n\n\n\n\n取捨選択に当たっては，表示対象物は縮尺に応じて適切に取捨選択し，かつ正確に表示する。また，重要度の高い対象物を省略することのないようにする\n総描に当たっては，現地の形状と相似性を保ち，形状の特徴を失わないようにする。必要に応じて形状を多少修飾して現状を理解しやすく総描する\n公共測量において，地図情報レベル2500の数値地形図に表示する地物の水平位置の転位は，原則として行わない\n\n\n\n\n\n\n\n\n\n取捨選択\n\n\n\n\n\n\n\n総描\n\n\n\n\n\n\n\n転位\n\n\n\n\n\n\nExample 1 幅1m未満の徒歩道と理由のある嘘\n「幅員 1.0m 未満の道路として、道路中心線が取得されている道路」がいわゆる幅1m未満の徒歩道ですが，平成２５年２万５千分１地形図図式（標準基準）では 0.2mmの線幅として表現されます．\n一方，２万５千分１であるので\n\n\nCode\nprint(f\"地図上0.2mm相当の実際の幅: {0.2 / 1000 * 25000} m\")\nprint(f\"1mの縮尺幅: {1/ 25000 * 1000} mm\")\n\n\n地図上0.2mm相当の実際の幅: 5.0 m\n1mの縮尺幅: 0.04 mm\n\n\nとなります．0.04 mmとして地図で表現してしまうと，そもそも徒歩道がどこにあるのか地図上での判別が難しくなってしまうので，「徒歩道がこのあたりに存在しますよ」という情報を伝えるのが目的であるならば， 太さを誇張して表記するのも理由があるとわかります．"
  },
  {
    "objectID": "posts/2025-04-01-how-to-read-map/index.html#地図上でのオブジェクトの位置表現",
    "href": "posts/2025-04-01-how-to-read-map/index.html#地図上でのオブジェクトの位置表現",
    "title": "地図と標準誤差",
    "section": "",
    "text": "すべての地物は地図上で正しい位置に表現されるのが理想ですが，縮尺化して表される性質上，表現が細かくなりすぎて見えなくなる地物があります． このような場合，以下のような処理がなされる場合があります：\n\n\n\n\n\n\n\n\n\n処理\n内容\nコメント\n\n\n\n\n取捨選択\n描ききれない地物を間引く\n目的の地図に建物を描く必要がなければ取捨選択によって省略される\n\n\n総描\n地形の形状を誇張・省略する\n河川や登山道などは曲がっていることを地図上では示していて，どのように曲がっているかは示さない\n\n\n転位\n地物を元の位置からずらして表現する\n一般道の上を走っている高架道路は，そのまま描くと一般道と重なってしまうので転位によって意図的にずらして両方を地図上に表示させる\n\n\n\n\n\n\n\n\n\n\nNote基本ルール\n\n\n\n\n取捨選択に当たっては，表示対象物は縮尺に応じて適切に取捨選択し，かつ正確に表示する。また，重要度の高い対象物を省略することのないようにする\n総描に当たっては，現地の形状と相似性を保ち，形状の特徴を失わないようにする。必要に応じて形状を多少修飾して現状を理解しやすく総描する\n公共測量において，地図情報レベル2500の数値地形図に表示する地物の水平位置の転位は，原則として行わない\n\n\n\n\n\n\n\n\n\n取捨選択\n\n\n\n\n\n\n\n総描\n\n\n\n\n\n\n\n転位\n\n\n\n\n\n\nExample 1 幅1m未満の徒歩道と理由のある嘘\n「幅員 1.0m 未満の道路として、道路中心線が取得されている道路」がいわゆる幅1m未満の徒歩道ですが，平成２５年２万５千分１地形図図式（標準基準）では 0.2mmの線幅として表現されます．\n一方，２万５千分１であるので\n\n\nCode\nprint(f\"地図上0.2mm相当の実際の幅: {0.2 / 1000 * 25000} m\")\nprint(f\"1mの縮尺幅: {1/ 25000 * 1000} mm\")\n\n\n地図上0.2mm相当の実際の幅: 5.0 m\n1mの縮尺幅: 0.04 mm\n\n\nとなります．0.04 mmとして地図で表現してしまうと，そもそも徒歩道がどこにあるのか地図上での判別が難しくなってしまうので，「徒歩道がこのあたりに存在しますよ」という情報を伝えるのが目的であるならば， 太さを誇張して表記するのも理由があるとわかります．"
  },
  {
    "objectID": "posts/2025-04-01-how-to-read-map/index.html#ボーリング調査でトンネル貫通",
    "href": "posts/2025-04-01-how-to-read-map/index.html#ボーリング調査でトンネル貫通",
    "title": "地図と標準誤差",
    "section": "ボーリング調査でトンネル貫通",
    "text": "ボーリング調査でトンネル貫通\n\n\n\n\n\n\nNote事実\n\n\n\n2019年7月11日に午前10時25分ごろ，長崎発博多行きの特急「かもめ16号」が，トンネルの天井を貫通した掘削機に接触． 異音を聞いた乗務員が列車を緊急停車させ，先頭車両の前面左側などに損傷があるのを確認した．\n\n\n上記の事故原因としてに鉄道・運輸機構から以下のように発表されています\n\nボーリング工事発注の際に国土地理院の地図（2万5千分の1地形図）に基づき作成した発注図面において JR 長崎本線長崎トンネルの位置が、実際の位置と異なっていた．\n長崎トンネルとボーリング工事の位置が図面上で約 80ｍ離れていたため，ボーリング工事による長崎トンネルへの影響はないものと判断し，ボーリング工事前に現地で十分な確認を行っていなかった\n\n\n80m の誤差の程度\n「図面上で約 80ｍ離れていた」とありますが，2万5千分の1地形図だと80mのずれは髪の紙面上で\n\n\nCode\nerror_mm = 80 / 25000 * 1000\nprint(f\"{error_mm} mm誤差\")\n\n\n3.2 mm誤差\n\n\nとなります．また，国土地理院の地理院地図では，建物の形状が見える地図の拡大率における水平精度は原則として「17.5m(標準誤差)」となっており，地図が現実世界のすべてを精確に表現している訳ではありません． そのため，\n\n\n\n\n\n\n\n理由\nコメント\n\n\n\n\nボーリング工事発注の際に国土地理院の地図（2万5千分の1地形図）に基づき作成した発注図面において JR 長崎本線長崎トンネルの位置が、実際の位置と異なっていた．\n実際の位置と異なるのは想定の範囲内であるべき\n\n\n長崎トンネルとボーリング工事の位置が図面上で約 80ｍ離れていたため，ボーリング工事による長崎トンネルへの影響はないものと判断し，ボーリング工事前に現地で十分な確認を行っていなかった\n2万5千分の1地形図のような中縮尺地図で，構造物の精確な位置を判断するのが間違っている\n\n\n\nと考えるべきだと思います．"
  },
  {
    "objectID": "posts/2025-04-01-how-to-read-map/index.html#references",
    "href": "posts/2025-04-01-how-to-read-map/index.html#references",
    "title": "地図と標準誤差",
    "section": "References",
    "text": "References\n\n報道発表資料 JR 長崎本線長崎トンネル内で発生させた重大事故（渇水対策を目的とした試掘ボーリングによる走行車両との接触）の原因と対策について"
  },
  {
    "objectID": "posts/2025-02-19-make-lag-variable/index.html",
    "href": "posts/2025-02-19-make-lag-variable/index.html",
    "title": "Group毎に定義されたラグ変数の作成",
    "section": "",
    "text": "Exercise 1 \n次のようなpandas.DataFrameを考えます\n\n\nCode\nimport pandas as pd\nimport polars as pl\n\ndf = pd.DataFrame(\n    {\n        \"entity_col\": [\"A\", \"A\", \"A\", \"A\", \"A\", \"A\", \"B\", \"B\", \"B\", \"C\"],\n        \"state\": [1, 0, 1, 1, 1, 0, 0, 0, 0, 1],\n        \"time_col\": pd.to_datetime([\n            \"2021-01-02\",\n            \"2021-01-03\",\n            \"2021-01-04\",\n            \"2021-01-01\",\n            \"2021-01-03\",\n            \"2021-01-04\",\n            \"2021-02-02\",\n            \"2021-02-03\",\n            \"2021-02-10\",\n            \"2021-01-02\",\n        ]),\n        \"temp\": [1, 2, 11, 13, 12, 14, 10, 9, 8, 0],\n    }\n)\n\ndf\n\n\n\n\n\n\n\n\n\nentity_col\nstate\ntime_col\ntemp\n\n\n\n\n0\nA\n1\n2021-01-02\n1\n\n\n1\nA\n0\n2021-01-03\n2\n\n\n2\nA\n1\n2021-01-04\n11\n\n\n3\nA\n1\n2021-01-01\n13\n\n\n4\nA\n1\n2021-01-03\n12\n\n\n5\nA\n0\n2021-01-04\n14\n\n\n6\nB\n0\n2021-02-02\n10\n\n\n7\nB\n0\n2021-02-03\n9\n\n\n8\nB\n0\n2021-02-10\n8\n\n\n9\nC\n1\n2021-01-02\n0\n\n\n\n\n\n\n\n ▶  実施したい処理\n\n(entity_col, state)でGroup Keysとして，各Group内部で time_col の順番に応じて tempカラムについてラグ変数を作成したい\nラグ変数の名前は Defaultでは f\"{target_column}_1lag, 指定があった場合はそれに倣うとする"
  },
  {
    "objectID": "posts/2025-02-19-make-lag-variable/index.html#問題設定-ラグ変数の作成",
    "href": "posts/2025-02-19-make-lag-variable/index.html#問題設定-ラグ変数の作成",
    "title": "Group毎に定義されたラグ変数の作成",
    "section": "",
    "text": "Exercise 1 \n次のようなpandas.DataFrameを考えます\n\n\nCode\nimport pandas as pd\nimport polars as pl\n\ndf = pd.DataFrame(\n    {\n        \"entity_col\": [\"A\", \"A\", \"A\", \"A\", \"A\", \"A\", \"B\", \"B\", \"B\", \"C\"],\n        \"state\": [1, 0, 1, 1, 1, 0, 0, 0, 0, 1],\n        \"time_col\": pd.to_datetime([\n            \"2021-01-02\",\n            \"2021-01-03\",\n            \"2021-01-04\",\n            \"2021-01-01\",\n            \"2021-01-03\",\n            \"2021-01-04\",\n            \"2021-02-02\",\n            \"2021-02-03\",\n            \"2021-02-10\",\n            \"2021-01-02\",\n        ]),\n        \"temp\": [1, 2, 11, 13, 12, 14, 10, 9, 8, 0],\n    }\n)\n\ndf\n\n\n\n\n\n\n\n\n\nentity_col\nstate\ntime_col\ntemp\n\n\n\n\n0\nA\n1\n2021-01-02\n1\n\n\n1\nA\n0\n2021-01-03\n2\n\n\n2\nA\n1\n2021-01-04\n11\n\n\n3\nA\n1\n2021-01-01\n13\n\n\n4\nA\n1\n2021-01-03\n12\n\n\n5\nA\n0\n2021-01-04\n14\n\n\n6\nB\n0\n2021-02-02\n10\n\n\n7\nB\n0\n2021-02-03\n9\n\n\n8\nB\n0\n2021-02-10\n8\n\n\n9\nC\n1\n2021-01-02\n0\n\n\n\n\n\n\n\n ▶  実施したい処理\n\n(entity_col, state)でGroup Keysとして，各Group内部で time_col の順番に応じて tempカラムについてラグ変数を作成したい\nラグ変数の名前は Defaultでは f\"{target_column}_1lag, 指定があった場合はそれに倣うとする"
  },
  {
    "objectID": "posts/2025-02-19-make-lag-variable/index.html#前処理関数の実装",
    "href": "posts/2025-02-19-make-lag-variable/index.html#前処理関数の実装",
    "title": "Group毎に定義されたラグ変数の作成",
    "section": "前処理関数の実装",
    "text": "前処理関数の実装\n\n\n\n\n\n\nNoteSolution: generate_lag_variable_with_group_key\n\n\n\n\n\n\nfrom typing import Optional\n\n\ndef generate_lag_variable_with_group_key(\n    df: pd.DataFrame | pl.DataFrame,\n    target_column: str,\n    sort_key: list[str],\n    group_key: list[str],\n    lag_size: int,\n    ascending: list[bool] | bool = True,\n    lagged_col_name: Optional[str] = None,\n) -&gt; pd.DataFrame | pl.DataFrame:\n    \"\"\"\n    Generate a lagged variable in a DataFrame with a specified group key.\n\n    This function creates a new column in the DataFrame that contains\n    the lagged values of an existing column, grouped by specified keys.\n    It supports both pandas and polars DataFrames.\n\n    Parameters:\n        df (pd.DataFrame | pl.DataFrame):\n            The input DataFrame, either pandas or polars.\n\n        col (str):\n            The name of the column to generate the lagged variable from.\n\n        sort_key (list[str]):\n            The list of columns to sort the DataFrame by before generating the lagged variable.\n\n        group_key (list[str]):\n            The list of columns to group the DataFrame by before generating the lagged variable.\n\n        lag_size (int):\n            The number of periods to lag the variable.\n\n        ascending (list[bool] | bool, optional):\n            The sort order for each column in sort_key. Defaults to True.\n\n        lagged_col_name (Optional[str], optional):\n            The name of the new lagged column. If None, defaults to \"{col}_{lag_size}lag\".\n\n    Returns:\n        pd.DataFrame | pl.DataFrame: The DataFrame with the new lagged variable column.\n\n    Raises:\n        TypeError: If the input DataFrame is neither pandas.DataFrame nor polars.DataFrame.\n    \"\"\"\n\n    # set up common variables\n    if lagged_col_name is None:\n        lagged_col_name = f\"{target_column}_{lag_size}lag\"\n\n    result_sort_key = group_key + sort_key\n\n    if isinstance(df, pd.DataFrame):\n        # Sort the dataframe by the specified sort key\n        df_sorted = df.sort_values(by=sort_key, ascending=ascending)\n\n        # Generate the lagged variable\n        df_sorted[lagged_col_name] = df_sorted.groupby(group_key)[target_column].shift(\n            lag_size\n        )\n\n        # Sort the dataframe by the group key and sort key\n        result_sort_key = group_key + sort_key\n        df_result = df_sorted.sort_values(by=result_sort_key).reset_index(drop=True)\n\n    elif isinstance(df, pl.DataFrame):\n        if isinstance(ascending, list):\n            order_reverse = [not x for x in ascending]\n        else:\n            order_reverse = not ascending\n\n        df_sorted = df.sort(sort_key, descending=order_reverse)\n        df_sorted = df_sorted.with_columns(\n            pl.col(target_column)\n            .shift(lag_size)\n            .over(group_key)\n            .alias(lagged_col_name)\n        )\n        df_result = df_sorted.sort(result_sort_key)\n\n    else:\n        raise TypeError(\n            f\"type(df) is {type(df)}: df should be pandas.DataFrame or polars.DataFrame\"\n        )\n\n    return df_result\n\n\n\n\n\n挙動確認\n ▶  pandas.DataFrame\n\ngenerate_lag_variable_with_group_key(\n    df=df,\n    target_column=\"temp\",\n    sort_key=[\"time_col\"],\n    group_key=[\"entity_col\", \"state\"],\n    lag_size=1,\n    ascending= [True]\n)\n\n\n\n\n\n\n\n\nentity_col\nstate\ntime_col\ntemp\ntemp_1lag\n\n\n\n\n0\nA\n0\n2021-01-03\n2\nNaN\n\n\n1\nA\n0\n2021-01-04\n14\n2.0\n\n\n2\nA\n1\n2021-01-01\n13\nNaN\n\n\n3\nA\n1\n2021-01-02\n1\n13.0\n\n\n4\nA\n1\n2021-01-03\n12\n1.0\n\n\n5\nA\n1\n2021-01-04\n11\n12.0\n\n\n6\nB\n0\n2021-02-02\n10\nNaN\n\n\n7\nB\n0\n2021-02-03\n9\n10.0\n\n\n8\nB\n0\n2021-02-10\n8\n9.0\n\n\n9\nC\n1\n2021-01-02\n0\nNaN\n\n\n\n\n\n\n\n ▶  polars.DataFrame\n\ndf_polars = pl.DataFrame(df)\ngenerate_lag_variable_with_group_key(\n    df=df_polars,\n    target_column=\"temp\",\n    sort_key=[\"time_col\"],\n    group_key=[\"entity_col\", \"state\"],\n    lag_size=1,\n)\n\n\nshape: (10, 5)\n\n\n\nentity_col\nstate\ntime_col\ntemp\ntemp_1lag\n\n\nstr\ni64\ndatetime[ns]\ni64\ni64\n\n\n\n\n\"A\"\n0\n2021-01-03 00:00:00\n2\nnull\n\n\n\"A\"\n0\n2021-01-04 00:00:00\n14\n2\n\n\n\"A\"\n1\n2021-01-01 00:00:00\n13\nnull\n\n\n\"A\"\n1\n2021-01-02 00:00:00\n1\n13\n\n\n\"A\"\n1\n2021-01-03 00:00:00\n12\n1\n\n\n\"A\"\n1\n2021-01-04 00:00:00\n11\n12\n\n\n\"B\"\n0\n2021-02-02 00:00:00\n10\nnull\n\n\n\"B\"\n0\n2021-02-03 00:00:00\n9\n10\n\n\n\"B\"\n0\n2021-02-10 00:00:00\n8\n9\n\n\n\"C\"\n1\n2021-01-02 00:00:00\n0\nnull\n\n\n\n\n\n\n\n\nUnit test with pytest\n\n📘 テスト方針 \n\n異なるラグサイズ（lag size）の処理: ラグサイズの値を自由に指定できるか？\nカスタムラグカラム名の指定: ラグカラムに任意の名前を付けることができるか？。\nソート順の指定: 昇順（ascending=True）または降順（ascending=False）でソートできるか？\n不正な入力タイプのエラー処理: 入力値が不正な場合，適切なエラーメッセージを表示するか？\n\n\n ▶  Test Examples\n\nimport pytest\nimport pandas as pd\nimport polars as pl\nimport numpy as np\n\n# Import the function to be tested\n# from hogehoge import generate_lag_variable_with_group_key  # Replace with actual module name\n\n@pytest.fixture\ndef sample_pandas_df():\n    \"\"\"Fixture to provide a sample Pandas DataFrame\"\"\"\n    return pd.DataFrame({\n        \"entity\": [\"A\", \"A\", \"A\", \"B\", \"B\", \"B\"],\n        \"time\": [\"2023-01-01\", \"2023-01-02\", \"2023-01-03\",\n                 \"2023-01-01\", \"2023-01-02\", \"2023-01-03\"],\n        \"value\": [10, 20, 30, 100, 200, 300]\n    }).assign(time=lambda df: pd.to_datetime(df[\"time\"]))  # Ensure datetime type\n\n@pytest.fixture\ndef sample_polars_df():\n    \"\"\"Fixture to provide a sample Polars DataFrame\"\"\"\n    return pl.DataFrame({\n        \"entity\": [\"A\", \"A\", \"A\", \"B\", \"B\", \"B\"],\n        \"time\": [\"2023-01-01\", \"2023-01-02\", \"2023-01-03\",\n                 \"2023-01-01\", \"2023-01-02\", \"2023-01-03\"],\n        \"value\": [10, 20, 30, 100, 200, 300]\n    }).with_columns(pl.col(\"time\").str.to_date())  # Ensure datetime type\n\n@pytest.mark.parametrize(\"df_type\", [\"pandas\", \"polars\"])\ndef test_generate_lag_variable_basic(df_type, sample_pandas_df, sample_polars_df):\n    \"\"\"Test basic functionality with Pandas and Polars\"\"\"\n    df = sample_pandas_df if df_type == \"pandas\" else sample_polars_df\n    result = generate_lag_variable_with_group_key(\n        df=df,\n        target_column=\"value\",\n        sort_key=[\"time\"],\n        group_key=[\"entity\"],\n        lag_size=1\n    )\n\n    assert \"value_1lag\" in result.columns, \"Lagged column not found!\"\n    expected_values_pandas = [np.nan, 10.0, 20.0, np.nan, 100.0, 200.0]  # Expected shifted values\n    expected_values_polars = [None, 10, 20, None, 100, 200]  # Expected shifted values\n    if df_type == \"pandas\":\n        assert np.array_equal(result[\"value_1lag\"].to_list(), expected_values_pandas, equal_nan=True)\n    else:\n        assert result[\"value_1lag\"].to_list() == expected_values_polars \n\ndef test_generate_lag_variable_custom_column(sample_pandas_df):\n    \"\"\"Test if custom column name works correctly\"\"\"\n    result = generate_lag_variable_with_group_key(\n        df=sample_pandas_df,\n        target_column=\"value\",\n        sort_key=[\"time\"],\n        group_key=[\"entity\"],\n        lag_size=1,\n        lagged_col_name=\"custom_lag\"\n    )\n    assert \"custom_lag\" in result.columns, \"Custom lag column name not applied!\"\n\ndef test_generate_lag_variable_with_descending_order(sample_pandas_df):\n    \"\"\"Test sorting order with descending time\"\"\"\n    result = generate_lag_variable_with_group_key(\n        df=sample_pandas_df,\n        target_column=\"value\",\n        sort_key=[\"time\"],\n        group_key=[\"entity\"],\n        lag_size=1,\n        ascending=False  # Reverse sorting order\n    )\n    expected_values = [20.0, 30.0, np.nan, 200.0, 300.0, np.nan]  # Because order is reversed\n    assert np.array_equal(result[\"value_1lag\"].to_list(), expected_values, equal_nan=True)\n\ndef test_generate_lag_variable_invalid_input():\n    \"\"\"Test function raises TypeError for invalid input\"\"\"\n    with pytest.raises(TypeError):\n        generate_lag_variable_with_group_key(\n            df=\"not_a_dataframe\",  # Invalid type\n            target_column=\"value\",\n            sort_key=[\"time\"],\n            group_key=[\"entity\"],\n            lag_size=1\n        )\n\n\n注意点 ! \n\nnp.nan != np.nan であるため，np.nanを含むリストを比較する場合，== を直接使用しても正しく機能しません\nNaN は未定義値であるため，NaN は自身と等しくない"
  },
  {
    "objectID": "posts/2025-05-30-how-to-write-document/index.html",
    "href": "posts/2025-05-30-how-to-write-document/index.html",
    "title": "ドキュメントの書き方",
    "section": "",
    "text": "Noteこの記事のスコープ\n\n\n\n\nドキュメントを書くにあたっての基本ルールの紹介"
  },
  {
    "objectID": "posts/2025-05-30-how-to-write-document/index.html#ドキュメントに何を書くかwhat",
    "href": "posts/2025-05-30-how-to-write-document/index.html#ドキュメントに何を書くかwhat",
    "title": "ドキュメントの書き方",
    "section": "ドキュメントに何を書くか？(What)",
    "text": "ドキュメントに何を書くか？(What)\nドキュメントとは「ある情報を、ある対象に伝える」ための手段です．ドキュメントを書くにあたって事前に\n\n「誰に」対して\n「何を」伝えるか\n\nを明確化し，その目的に応じて構成や表現を設計することが重要です．\n\nExample 1 : ドキュメント種類別の読み手と目的整理表\n\n\n\n\n\n\n\n\n\nドキュメント種類\n誰に\n何を\n\n\n\n\n企画書\n経営層・チームマネジャー・開発メンバー\nPJの目的・スコープ・予算・スケジュール\n\n\n要件定義書\nエンジニア\nシステムの機能要件・非機能要件\n\n\n基本設計書\nエンジニア\nシステムの動作仕様・インターフェース仕様\n\n\n詳細設計\nエンジニア\nソフトウェアの内部構造・モジュール感のインターフェース・データ構造\n\n\nテスト仕様書\nプロダクトマネジャー・エンジニア\nテスト項目・テストデータ・テスト結果\n\n\nユーザーマニュアル\nユーザー\n機能の説明・利用目的・操作方法\n\n\n管理・保守マニュアル\nシステム管理者\n管理や保守に関する機能の説明・利用目的・操作方法\n\n\nリリースノート\nユーザー・システム管理者\nプロダクトのアップデートに伴う変更点\n\n\n\n\n\n\n読み手の定義\n\nルール\n「誰に」対してを特定する際，以下の３つを明確化することが有用です：\n\n読み手の目的・ニーズ\n読み手の知識レベル\n読み手の立場\n\n説明\n\n目的が違えば、必要な情報・深さ・順序が変わる\n\n\n意思決定者 → 意思決定や承認に足る根拠がほしい → 結論とインパクト重視\n現場担当者 → どう使うか／どう実装するかの具体的な手順を知りたい → 詳細手順や実装方法が重要\n\n\n知識レベルが違えば 説明の粒度・用語の選び方・例の使い方が変わる\n\n\n初心者 → 用語の定義や背景から丁寧に\n専門家 → 論点にフォーカスし冗長さを排除\n\n\n同じ事実でも、立場によって関心ポイントが異なる\n\n\n営業 → 顧客影響やKPIに注目\nエンジニア → 技術的妥当性や仕組みが重要\n\n例: ユーザーマニュアルと開発者マニュアルのアウトラインの差異\n\n\n\n\n\n\n\n\n\n種類\nアウトライン構成方針\n例\n\n\n\n\nユーザーマニュアル\nユーザーが操作する順番\n初期設定 → ログイン → 基本操作 → 応用操作 → トラブル対応\n\n\n開発者マニュアル\n開発者が開発する順番\n環境構築 → モジュール設計 → API定義 → データ構造 → エラーハンドリング\n\n\n\n\nアンチパターンと改善例\n\n\n\n\n\n\nImportantアンチパターン: 読み手の定義がぼやけている\n\n\n\n\nプロダクトのユーザーに，プロダクトの使い方を伝える\n\n\n\n\n\n\n\n\n\nTip改善例:\n\n\n\n\nプロダクトを新規導入するシステム管理者に，プロダクトの導入手順を伝える\nプロダクトの利用中にエラーに遭遇したユーザーに，エラーの原因と対処方法を伝える"
  },
  {
    "objectID": "posts/2025-05-30-how-to-write-document/index.html#どのようにドキュメントを書くかhow",
    "href": "posts/2025-05-30-how-to-write-document/index.html#どのようにドキュメントを書くかhow",
    "title": "ドキュメントの書き方",
    "section": "どのようにドキュメントを書くか？(How)",
    "text": "どのようにドキュメントを書くか？(How)\n良いドキュメントを書くためには、次の３点を押さえる必要があります：\n\nEffectiveness; 必要な情報を正しく伝えられる, 合目的的であること\nEfficiency: 効率よく内容が理解できる, readability\nSatisfaction: 読み手に対する配慮があること\n\n\nEffectiveness\n\n\n\n説明\n\n書き表された情報が読み手に一意に伝わること\n書き表された情報がドキュメントの目的と合致していること\n\nアクション\n\n\nメインメッセージの構成要素が漏れなく分解されている\n曖昧さを廃し，明確な文章で書く\n誤解なく読める文章で書く\nできるだけ具体的に書く\n\n\n\n\nEfficiency\n\n\n\n説明\n\n効率よく内容が理解できること\n読み手は流し読みする傾向があるので，流し読みでも情報が伝わるように構成立てること\n\nアクション\n\n\n要点を先に伝える(MMUF, Main Message Up-Front)\n話の流れを整理し，どこに何が書いてあるかわかりやすくする(=アウトライン設計)\n\nドキュメントを書く前に事前にアウトライン設計（どこに何を書くのか）\n文章ブロックに対して，書かれている内容を端的に表す見出しを付ける\none heading, one message\n\n必要な情報だけに絞り，簡潔で読みやすい文章にする\n\n\n\n\nSatisfaction\n\n\n\n説明\n\n読み手が「読んでよかった」「わかりやすかった」と感じられること\nストレスなく読める体験が提供されていること\n\nアクション\n\n\n読み手の立場・前提知識・目的を想定して内容や語り口を調整する\n図表・余白・見出しなどで視認性を高める\n論理の正確さだけでなく、文の印象・ニュアンスにも気を配る\n\n\n\n\nわかりやすい文の書き方\n\n\n\n\n\n\nWarning文を書き始めるのはアウトライン設計後\n\n\n\n\n文章はすぐに書き始めるのではなく，まず「構造」＝アウトラインを先に設計する\n\n\n\nわかりやすい文を書くにあたって，次の4点を抑える必要があります\n\n係り受けを明確にする\n並列関係を明確にする\n順序関係を明確にする\n「の」は一つの文に２つまでに留める\n\n\n係り受けを明確にする\n\n\n説明\n\n誤解を招く文の原因の一つが，係り受けの曖昧さ\n係り受けはできる限り近い位置に配置するべき\n\n例\n\n❌ 簡単なチャットアプリの作り方\n👍 チャットアプリの簡単な作り方\n\n\n\n並列関係を明確にする\n\n\n説明\n\n並列する要素（AとB、～や～など）は、文法的・意味的に対等な構造で書く必要がある\n並列構造が乱れると、何が並列なのか、読み手が混乱する\n\n例\n\n❌ このツールは、設定の保存、読み込み、そしてファイルの圧縮ができます\n👍 このツールは、設定の保存・読み込み、ファイルの圧縮ができます\n\n\n\n順序関係を明確にする\n\n\n説明\n\n複数の出来事や手順がある場合は、どの順で発生・実行されるかを明確にすることが重要\n順序が不明瞭だと、因果関係や手順が誤解されやすくなる\n\n例\n\n❌ 入力が完了したら、ファイルを保存し、名前を入力してください\n👍 入力が完了したら、名前を入力し、その後でファイルを保存してください\n\n\n\n「の」は一つの文に２つまでに留める\n\n\n説明\n\n「の」を多用すると、文の構造が複雑になり、意味があいまいになる\nそのため、一文に「の」は2つまでに抑えるのが、読みやすさの目安。\n\n例\n\n❌ データ処理の高速化のためのアルゴリズムの最適化手法の調査\n👍 データ処理を高速化するための、アルゴリズム最適化手法の調査\n👍 アルゴリズム最適化手法について、データ処理を高速化する観点から調査した"
  },
  {
    "objectID": "posts/2025-05-30-how-to-write-document/index.html#アンチパターンと発生原因",
    "href": "posts/2025-05-30-how-to-write-document/index.html#アンチパターンと発生原因",
    "title": "ドキュメントの書き方",
    "section": "アンチパターンと発生原因",
    "text": "アンチパターンと発生原因\n\n\n\n\n\n\nImportantProblem 1: なにを書いていいかわからない\n\n\n\n\n\n\n\n\nドキュメントの目的がわかっていない\nドキュメントの目的から導き出されるテーマについて，その構成要素を分解できていない\n\n\n\n\n\n\n\n\nImportantProblem 2: あれもこれもと，情報詰め込んでしまう\n\n\n\n\n\n\n\n\n読み手とテーマが明確に定義されていない\n\n\n\n\n\n\n\n\nImportantProblem 3: 自分で説明するとき，何故か説明しづらい\n\n\n\n\n\n\n\n\nドキュメントの目的に対して，テーマが十分分解されていない\n分解されたテーマの配置が不自然な流れになっている\n\nheadingsとkey takeawaysだけ読んでみたとき，目が止まってしまう or 順番が飛んでしまう\n\n\n\n\n\n\n\n\n\nImportantProblem 4: 何が言いたいかわからないheadingsがある\n\n\n\n\n\n\n\n\nkey takeawaysが定義されていない\nMMUFの構成になっていない\n\n\n\n\n\n\n\n\nImportantProblem 5: 作成したユーザーマニュアルが読みづらいと言われた\n\n\n\n\n\n\n\n\n各見出しにおける想定ユーザーが明確に定義されていない\n想定ユーザーについて，書き手が仮定した読み手知識レベルが対応していない\n読み手を主語にした文となっていない\n\nユーザーマニュアルは読者の立場に立った指示やガイドを提供するべき"
  },
  {
    "objectID": "posts/2025-05-30-how-to-write-document/index.html#appendix-パラグラフと段落の違い",
    "href": "posts/2025-05-30-how-to-write-document/index.html#appendix-パラグラフと段落の違い",
    "title": "ドキュメントの書き方",
    "section": "Appendix: パラグラフと段落の違い",
    "text": "Appendix: パラグラフと段落の違い\n「パラグラフ」と「段落」は、日常的には同じ意味で使われることも多いですが、ドキュメント作成の文脈では以下のような差異が有ります:\n\n\n\n\n\n\n\n\n\n用語\n視点\n意味\n\n\n\n\n段落\n見た目\n改行による文章の区切り何を１段落にまとめるかの自由度が高い\n\n\nパラグラフ\n意味\n1つの主張を持った論理的な文の集まり1 paragraph 1 topic\n\n\n\n\nPragraphの構成\n1つのパラグラフは、原則として以下のような構造で成り立っています：\n\n\n\n\n\n\n\n\n構成要素\n説明\n\n\n\n\ntopic sentence\nパラグラフの最初に置かれ、その段落で述べたい中心的な主張やポイントを示す\n\n\nsupport sentence\n「なぜそう言えるのか？」「どんな意味があるのか？」を展開する"
  },
  {
    "objectID": "posts/2025-05-30-how-to-write-document/index.html#references",
    "href": "posts/2025-05-30-how-to-write-document/index.html#references",
    "title": "ドキュメントの書き方",
    "section": "References",
    "text": "References\n\n構造化されたストーリーとしてのスライド"
  },
  {
    "objectID": "posts/2025-06-18-cantor-pairing-functions/index.html",
    "href": "posts/2025-06-18-cantor-pairing-functions/index.html",
    "title": "カントールの対関数の全単射性の証明",
    "section": "",
    "text": "Note自然数集合の定義\n\n\n\n\\(\\mathbb N = \\{1, 2, 3, \\cdots\\}\\) とする．\n\n\n\nDefinition 1 カントールの対関数\n次の関数 \\(J: \\mathbb N\\times \\mathbb N\\to \\mathbb N\\) をカントールの対関数という\n\\[\nJ(x, y) = \\frac{(x + y - 2)(x + y - 1)}{2} + y\n\\]\n\n\\(J\\) は全単射という性質があります\n\n\nカントールの対関数のイメージは Figure 1 です．\\(J: \\mathbb N\\times \\mathbb N\\to \\mathbb N\\) が全単射であることから，自然数の対 \\((m, n)\\) 全体の作る集合は \\(\\mathbb N\\) と濃度が同じ = 可算集合であることがわかるようになります．\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Define the grid size\nmax_val = 5\nX, Y = np.meshgrid(np.arange(1, max_val + 1), np.arange(1, max_val + 1))\n\n# Compute Cantor pairing number\nZ = ((X + Y - 2) * (X + Y - 1)) // 2 + Y\n\n# Flatten the arrays for easier iteration and sorting\npoints = []\nfor i in range(X.shape[0]):\n    for j in range(X.shape[1]):\n        x = X[i, j]\n        y = Y[i, j]\n        z = Z[i, j]\n        if z &lt;= 15:\n            points.append((z, x, y))  # (number, x, y)\n\n# Sort by the Cantor number\npoints.sort()\n\n# Plotting\nplt.figure(figsize=(7, 7))\nplt.xlim(0.3, max_val + 0.3)\nplt.ylim(0.3, max_val + 0.3)\nplt.xticks(np.arange(1, max_val + 1))\nplt.yticks(np.arange(1, max_val + 1))\nplt.grid(True)\n\n# Plot points and labels\nfor z, x, y in points:\n    plt.text(x, y + 0.1, str(z), ha='center', va='center', fontsize=12, color='black')\n    plt.plot(x, y, 'ko', markersize=5)\n\n# Draw arrows from one point to the next in order\nfor i in range(len(points) - 1):\n    _, x0, y0 = points[i]\n    _, x1, y1 = points[i + 1]\n    dx = x1 - x0\n    dy = y1 - y0\n    plt.arrow(x0, y0, dx * 0.85, dy * 0.85,\n              head_width=0.1, head_length=0.1,\n              length_includes_head=True, linestyle='dashed', color='#575757')\n\nplt.title('Cantor Pairing Function with Ordered Arrows')\nplt.xlabel('x')\nplt.ylabel('y')\nplt.gca().set_aspect('equal')\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\nFigure 1\n\n\n\n\n\n\n\n\n\n\n\nNoteProof: 全射性の証明\n\n\n\n\n\n任意の \\(k\\in \\mathbb N\\) について，ある \\(x, y \\in \\mathbb N\\) が存在して，\\(J(x, y) = k\\) になることを，数学的帰納法を用いると容易に示すことができます．\n\\(k = 1\\) について\n\\(k = 1\\) については，\\((x, y) = (1, 1)\\) とすると，\n\\[\nJ(1, 1) = \\frac{(1 + 1 - 2)(1 + 1 - 1)}{2} + 1\n\\]\nより自明．\n\\(k &gt; 1\\) について\nつぎに，ある \\(k\\in \\mathbb N\\) について，ある \\(x, y \\in \\mathbb N\\) が存在すると仮定して，\\(k+1\\) についても同様に成り立つことを示します．\n\\(x = 1\\) のときは \\((x^\\prime, y^\\prime) = (y + 1, 1)\\) とおくと，\n\\[\n\\begin{align}\nJ(x^\\prime, y^\\prime)\n  &= \\frac{(x^\\prime + y^\\prime - 2)(x^\\prime + y^\\prime - 1)}{2} + y^\\prime\\\\\n  &= \\frac{(y + 1 + 1 - 2)(y + 1 + 1 - 1)}{2} + 1\\\\\n  &= \\frac{(y)(y + 1)}{2} + 1\\\\\n  &= \\frac{(y - 1)(y)}{2} + y + 1\\\\\n  &= J(x, y) + 1\\\\\n  &= k + 1\n\\end{align}\n\\]\n\\(x &gt; 1\\) のときは \\((x^\\prime, y^\\prime) = (x - 1, y + 1)\\) とおくと，\n\\[\n\\begin{align}\nJ(x^\\prime, y^\\prime)\n  &= \\frac{(x + y - 2)(x + y - 1)}{2} + y + 1\\\\\n  &= J(x, y) + 1\\\\\n  &= k + 1\n\\end{align}\n\\]\n以上の数学的帰納法により，任意の \\(k \\in \\mathbb{N}\\) に対して，ある \\((x, y) \\in \\mathbb{N}^2\\) が存在して \\(J(x, y) = k\\) となる．\n\n\n\n\n\n\n\n\n\nNoteProof: 単射性の証明\n\n\n\n\n\n\\((x, y)\\neq (x^\\prime, y^\\prime)\\) を任意にとると，\n\\(x + y = x^\\prime + y^\\prime\\) のときは，\n\\[\nJ(x, y) - J(x^\\prime, y^\\prime) = y - y^\\prime \\neq 0\n\\]\n\\(x + y \\neq x^\\prime + y^\\prime\\) のときは，\\(x + y &lt; x^\\prime + y^\\prime\\) としても一般性を失わないので，\n\\[\n\\begin{align}\nJ(x, y)\n  &= \\sum^{x + y - 2}_i i + y\\\\\n  &\\leq \\sum^{x + y - 2}_i i + x + y - 1\\\\\n  &= \\sum^{x + y - 1}_i\\\\\n  &\\leq \\sum^{x^\\prime + y^\\prime - 2}_i\\\\\n  &&lt; \\sum^{x^\\prime + y^\\prime - 2}_i + y^\\prime\\\\\n  &= J(x^\\prime, y^\\prime)\n\\end{align}\n\\]\n従って，単射性が示された．"
  },
  {
    "objectID": "posts/2025-06-18-cantor-pairing-functions/index.html#カントールの対関数",
    "href": "posts/2025-06-18-cantor-pairing-functions/index.html#カントールの対関数",
    "title": "カントールの対関数の全単射性の証明",
    "section": "",
    "text": "Note自然数集合の定義\n\n\n\n\\(\\mathbb N = \\{1, 2, 3, \\cdots\\}\\) とする．\n\n\n\nDefinition 1 カントールの対関数\n次の関数 \\(J: \\mathbb N\\times \\mathbb N\\to \\mathbb N\\) をカントールの対関数という\n\\[\nJ(x, y) = \\frac{(x + y - 2)(x + y - 1)}{2} + y\n\\]\n\n\\(J\\) は全単射という性質があります\n\n\nカントールの対関数のイメージは Figure 1 です．\\(J: \\mathbb N\\times \\mathbb N\\to \\mathbb N\\) が全単射であることから，自然数の対 \\((m, n)\\) 全体の作る集合は \\(\\mathbb N\\) と濃度が同じ = 可算集合であることがわかるようになります．\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Define the grid size\nmax_val = 5\nX, Y = np.meshgrid(np.arange(1, max_val + 1), np.arange(1, max_val + 1))\n\n# Compute Cantor pairing number\nZ = ((X + Y - 2) * (X + Y - 1)) // 2 + Y\n\n# Flatten the arrays for easier iteration and sorting\npoints = []\nfor i in range(X.shape[0]):\n    for j in range(X.shape[1]):\n        x = X[i, j]\n        y = Y[i, j]\n        z = Z[i, j]\n        if z &lt;= 15:\n            points.append((z, x, y))  # (number, x, y)\n\n# Sort by the Cantor number\npoints.sort()\n\n# Plotting\nplt.figure(figsize=(7, 7))\nplt.xlim(0.3, max_val + 0.3)\nplt.ylim(0.3, max_val + 0.3)\nplt.xticks(np.arange(1, max_val + 1))\nplt.yticks(np.arange(1, max_val + 1))\nplt.grid(True)\n\n# Plot points and labels\nfor z, x, y in points:\n    plt.text(x, y + 0.1, str(z), ha='center', va='center', fontsize=12, color='black')\n    plt.plot(x, y, 'ko', markersize=5)\n\n# Draw arrows from one point to the next in order\nfor i in range(len(points) - 1):\n    _, x0, y0 = points[i]\n    _, x1, y1 = points[i + 1]\n    dx = x1 - x0\n    dy = y1 - y0\n    plt.arrow(x0, y0, dx * 0.85, dy * 0.85,\n              head_width=0.1, head_length=0.1,\n              length_includes_head=True, linestyle='dashed', color='#575757')\n\nplt.title('Cantor Pairing Function with Ordered Arrows')\nplt.xlabel('x')\nplt.ylabel('y')\nplt.gca().set_aspect('equal')\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\nFigure 1\n\n\n\n\n\n\n\n\n\n\n\nNoteProof: 全射性の証明\n\n\n\n\n\n任意の \\(k\\in \\mathbb N\\) について，ある \\(x, y \\in \\mathbb N\\) が存在して，\\(J(x, y) = k\\) になることを，数学的帰納法を用いると容易に示すことができます．\n\\(k = 1\\) について\n\\(k = 1\\) については，\\((x, y) = (1, 1)\\) とすると，\n\\[\nJ(1, 1) = \\frac{(1 + 1 - 2)(1 + 1 - 1)}{2} + 1\n\\]\nより自明．\n\\(k &gt; 1\\) について\nつぎに，ある \\(k\\in \\mathbb N\\) について，ある \\(x, y \\in \\mathbb N\\) が存在すると仮定して，\\(k+1\\) についても同様に成り立つことを示します．\n\\(x = 1\\) のときは \\((x^\\prime, y^\\prime) = (y + 1, 1)\\) とおくと，\n\\[\n\\begin{align}\nJ(x^\\prime, y^\\prime)\n  &= \\frac{(x^\\prime + y^\\prime - 2)(x^\\prime + y^\\prime - 1)}{2} + y^\\prime\\\\\n  &= \\frac{(y + 1 + 1 - 2)(y + 1 + 1 - 1)}{2} + 1\\\\\n  &= \\frac{(y)(y + 1)}{2} + 1\\\\\n  &= \\frac{(y - 1)(y)}{2} + y + 1\\\\\n  &= J(x, y) + 1\\\\\n  &= k + 1\n\\end{align}\n\\]\n\\(x &gt; 1\\) のときは \\((x^\\prime, y^\\prime) = (x - 1, y + 1)\\) とおくと，\n\\[\n\\begin{align}\nJ(x^\\prime, y^\\prime)\n  &= \\frac{(x + y - 2)(x + y - 1)}{2} + y + 1\\\\\n  &= J(x, y) + 1\\\\\n  &= k + 1\n\\end{align}\n\\]\n以上の数学的帰納法により，任意の \\(k \\in \\mathbb{N}\\) に対して，ある \\((x, y) \\in \\mathbb{N}^2\\) が存在して \\(J(x, y) = k\\) となる．\n\n\n\n\n\n\n\n\n\nNoteProof: 単射性の証明\n\n\n\n\n\n\\((x, y)\\neq (x^\\prime, y^\\prime)\\) を任意にとると，\n\\(x + y = x^\\prime + y^\\prime\\) のときは，\n\\[\nJ(x, y) - J(x^\\prime, y^\\prime) = y - y^\\prime \\neq 0\n\\]\n\\(x + y \\neq x^\\prime + y^\\prime\\) のときは，\\(x + y &lt; x^\\prime + y^\\prime\\) としても一般性を失わないので，\n\\[\n\\begin{align}\nJ(x, y)\n  &= \\sum^{x + y - 2}_i i + y\\\\\n  &\\leq \\sum^{x + y - 2}_i i + x + y - 1\\\\\n  &= \\sum^{x + y - 1}_i\\\\\n  &\\leq \\sum^{x^\\prime + y^\\prime - 2}_i\\\\\n  &&lt; \\sum^{x^\\prime + y^\\prime - 2}_i + y^\\prime\\\\\n  &= J(x^\\prime, y^\\prime)\n\\end{align}\n\\]\n従って，単射性が示された．"
  },
  {
    "objectID": "posts/2025-06-18-cantor-pairing-functions/index.html#カントールの対関数の逆関数",
    "href": "posts/2025-06-18-cantor-pairing-functions/index.html#カントールの対関数の逆関数",
    "title": "カントールの対関数の全単射性の証明",
    "section": "カントールの対関数の逆関数",
    "text": "カントールの対関数の逆関数\n証明の関係上，\\(\\mathbb N = \\{0, 1, 2, 3, \\cdots\\}\\) とします．\nこのとき，のカントール対関数は\n\\[\nJ(x, y) = \\frac{(x + y)(x + y + 1)}{2} + y\n\\]\nとなります．\n\nTheorem 1 カントールの対関数の逆関数\n\\[\nJ(x, y) = \\frac{(x + y)(x + y + 1)}{2} + y\n\\]\nの逆関数は\n\\[\nt = \\left\\lfloor \\frac{-1 + \\sqrt{1 + 8J}}{2}\\right\\rfloor\n\\]\nとおくと，\n\\[\n\\begin{cases}\nx =\\frac{t^3 + 3t}{2} - J\\\\\ny = J - \\frac{t^2 + t}{2}\n\\end{cases}\n\\]\n\n\n\n\n\n\n\nNoteProof\n\n\n\n\n\n\\(t = x + y\\) とおくと，カントールの対関数は\n\\[\n\\begin{align}\nJ(x, y) &= \\frac{t^2 + t}{2} + y\\\\\nJ(x, 0) &= \\frac{x^2 + x}{2}\n\\end{align}\n\\]\nまた定義より\n\\[\n\\begin{align}\nJ(x, y) &= J(x + y, 0) + y\\\\\nJ(x, y) &= J(0, x + y) - x\\\\\nJ(0, x+y) + 1 &= J(x + y + 1, 0)\n\\end{align}\n\\]\n従って，\n\\[\nJ(x + y, 0) \\leq J(x, y) \\leq J(0, x + y) &lt; J(x + y + 1, 0)\n\\]\nつまり，\n\\[\n\\frac{t^2 + t}{2} \\leq J(x, y)  = \\frac{t^2 + t}{2} + y &lt; \\frac{(t + 1)^2 + t + 1}{2}\n\\]\nこれを整理すると\n\\[\n\\begin{gather}\nt^2 + t - 2J \\leq 0\\\\\n(t + 1)^2 + (t + 1) - 2J &gt; 0\n\\end{gather}\n\\]\nこれを解くと，\n\\[\n\\begin{gather}\n\\frac{-1 - \\sqrt{1 + 8J}}{2} \\leq t \\leq \\frac{-1 + \\sqrt{1 + 8J}}{2}\\\\\nt + 1 &lt;\\frac{-1 - \\sqrt{1 + 8J}}{2} \\lor \\frac{-1 + \\sqrt{1 + 8J}}{2} &lt; t + 1\\\\\n\\end{gather}\n\\]\nここで，\\(t \\geq 0\\) であることから\n\\[\nt  \\leq \\frac{-1 + \\sqrt{1 + 8J}}{2} &lt; t + 1\n\\]\n\\(t \\in \\mathbb N\\) より\n\\[\nt = \\left\\lfloor \\frac{-1 + \\sqrt{1 + 8J}}{2}\\right\\rfloor\n\\]\nこれを，\\((x, y)\\) に対応させると\n\\[\n\\begin{align}\nx &= t - y\\\\\ny &= J - \\frac{t^2 + t}{2}\n\\end{align}\n\\]\nよって，\n\\[\n\\begin{cases}\nx =\\frac{t^3 + 3t}{2} - J\\\\\ny = J - \\frac{t^2 + t}{2}\n\\end{cases}\n\\]\n\n\n\n\n\n\n\n\n\nNote\n\n\n\n\\(\\mathbb N = \\{1, 2, 3, \\cdots\\}\\) とした場合は\n\\[\nt = \\left\\lfloor \\frac{-1 + \\sqrt{8J - 7}}{2}\\right\\rfloor\n\\]\n\\[\n\\begin{cases}\nx =\\frac{t^3 + 3t}{2} - J + 2\\\\\ny = J - \\frac{t^2 + t}{2}\n\\end{cases}\n\\]"
  },
  {
    "objectID": "posts/2025-03-01-herons-formula/index.html",
    "href": "posts/2025-03-01-herons-formula/index.html",
    "title": "ヘロンの公式の導出",
    "section": "",
    "text": "Theorem 1 : ヘロンの公式 \n\\(\\triangle ABC\\) の3辺の長さがそれぞれ \\(a, b, c\\) で与えられているとき，\n\\[\ns = \\frac{1}{2}(a + b + c)\n\\]\nとおくと，\\(\\triangle ABC\\) の面積 \\(S\\) は\n\\[\nS = \\sqrt{s(s-a)(s-b)(s-c)}\n\\]\n\n\n\n\n\n\n\n\n\nNote余弦定理を用いた証明\n\n\n\n\n\n3辺の長さがわかっているので，余弦定理より\n\\[\n\\begin{align}\na^2 &= b^2 + c^2 - 2bc\\cos A\\\\\n\\Rightarrow &\\cos A = \\frac{b^2+c^2-a^2}{2bc}\n\\end{align}\n\\]\n\\(\\sin^2 A + \\cos^2 A = 1\\) より\n\\[\n\\sin A = \\sqrt{1 - \\cos^2 A}\n\\]\n従って，面積 \\(S\\) は\n\\[\nS = \\frac{1}{2}bc\\sqrt{1 - \\cos^2 A}\n\\]\nこれを展開すると\n\\[\n\\begin{align}\nS\n    &= \\frac{1}{2}bc\\sqrt{1 - \\cos^2 A}\\\\\n    &= \\frac{1}{2}bc\\sqrt{1 - \\frac{(b^2+c^2-a^2)^2}{4b^2c^2}}\\\\\n    &= \\frac{1}{2}\\sqrt{b^2c^2 - \\left(\\frac{(b^2+c^2-a^2)}{2}\\right)^2}\\\\\n    &= \\frac{1}{2}\\sqrt{\\left(-\\frac{b^2+c^2-a^2-2bc}{2}\\right)\\left(\\frac{b^2+c^2-a^2+2bc}{2}\\right)}\\\\\n    &= \\frac{1}{2}\\sqrt{\\left(-\\frac{(b-c)^2-a^2}{2}\\right)\\left(\\frac{(b+c)^2-a^2}{2}\\right)}\\\\\n    &= \\frac{1}{2}\\sqrt{\\frac{(a+b-c)(a+c-b)}{2}\\frac{(a+b+c)(b+c-a)}{2}}\\\\\n    &= \\sqrt{\\frac{(a+b-c)}{2}\\frac{(a+c-b)}{2}\\frac{(a+b+c)}{2}\\frac{(b+c-a)}{2}}\\\\\n    &= \\sqrt{s(s-a)(s-b)(s-c)}\n\\end{align}\n\\]\n\n\n\n\n\n\n\n\n\n\nNote三角形の傍接円からのヘロンの公式\n\n\n\n\n\n下記のように \\(\\triangle ABC\\) について内心 \\(D\\) と傍心 \\(G\\) を考えます．\n\n前準備として \\(\\triangle ABC\\) のそれぞれの角の対辺を \\(a, b, c\\) として\n\\[\ns = \\frac{1}{2}(a + b + c)\n\\]\nと変数 \\(s\\) を定義します．また，内接円の性質（各頂点の内角の二等分線上に内心が存在）より\n\\[\n\\begin{align}\nAH &= AN\\\\\nCN &= CI\\\\\nBH &= BI\n\\end{align}\n\\]\n従って，\n\\[\n\\begin{align}\nAH &= s - a\\\\\nBH &= s - b\\\\\nCN &= s = c\n\\end{align}\n\\]\n傍接円の傍心 \\(G\\) は\n\n\\(\\angle A\\) の二等分線上\n\\(B\\) と \\(C\\)の外角の二等分線上\n\nに存在することから\n\\[\nAL = AE\n\\]\nまた，\n\\[\n\\begin{align}\nAL + AE\n    &= (AC + CL) + (AB + BE)\\\\\n    &= (AC + CO) + (AB + BO)\\\\\n    &=  a + b + c\\\\\n    &= 2s\n\\end{align}\n\\]\n従って，\n\\[\nAL = AE = s\n\\]\n内接円の内心 \\(D\\) が \\(\\angle B, \\angle C\\) の二等分線上に存在するので\n\\[\n\\begin{align}\n180^\\circ\n    &= 2\\angle HBD + 2\\angle EBG\\\\\n\\Rightarrow & 90^\\circ = \\angle HBD + \\angle EBG\n\\end{align}\n\\]\n従って，\n\\[\n\\begin{align}\n\\angle BDH &= \\angle EBG\n\\angle HBD &= \\angle BGE\n\\end{align}\n\\]\nここから\n\\[\n\\triangle HBD \\sim \\triangle EGB\n\\]\nこれより\n\\[\n\\frac{s - b}{r_1}=\\frac{r_2}{s - c}\n\\]\nこれを整理すると\n\\[\nr_1r_2 = (s-b)(s-c) \\label{#eq-1}\n\\]\nまた，\\(\\triangle HDE\\) と \\(\\triangle HDO\\) の面積が等しいことから\n\\[\nsr_1 = (s-a)r_2  \\label{#eq-2}\n\\]\n\\(\\eqref{#eq-1}\\), \\(\\eqref{#eq-2}\\) を 掛け合わせて \\(r_2\\) を両辺から除して \\(s\\) を両辺にかけると\n\\[\ns^2r_1^2 = s(s-a)(s-b)(s-c)\n\\]\n従って\n\\[\nsr_1 = \\sqrt{s(s-a)(s-b)(s-c)}\n\\]\nLHSは \\(\\triangle ABC\\) の面積と一致するので，これでヘロンの公式が示された．"
  },
  {
    "objectID": "posts/2025-03-01-herons-formula/index.html#辺から三角形の面積を求める",
    "href": "posts/2025-03-01-herons-formula/index.html#辺から三角形の面積を求める",
    "title": "ヘロンの公式の導出",
    "section": "",
    "text": "Theorem 1 : ヘロンの公式 \n\\(\\triangle ABC\\) の3辺の長さがそれぞれ \\(a, b, c\\) で与えられているとき，\n\\[\ns = \\frac{1}{2}(a + b + c)\n\\]\nとおくと，\\(\\triangle ABC\\) の面積 \\(S\\) は\n\\[\nS = \\sqrt{s(s-a)(s-b)(s-c)}\n\\]\n\n\n\n\n\n\n\n\n\nNote余弦定理を用いた証明\n\n\n\n\n\n3辺の長さがわかっているので，余弦定理より\n\\[\n\\begin{align}\na^2 &= b^2 + c^2 - 2bc\\cos A\\\\\n\\Rightarrow &\\cos A = \\frac{b^2+c^2-a^2}{2bc}\n\\end{align}\n\\]\n\\(\\sin^2 A + \\cos^2 A = 1\\) より\n\\[\n\\sin A = \\sqrt{1 - \\cos^2 A}\n\\]\n従って，面積 \\(S\\) は\n\\[\nS = \\frac{1}{2}bc\\sqrt{1 - \\cos^2 A}\n\\]\nこれを展開すると\n\\[\n\\begin{align}\nS\n    &= \\frac{1}{2}bc\\sqrt{1 - \\cos^2 A}\\\\\n    &= \\frac{1}{2}bc\\sqrt{1 - \\frac{(b^2+c^2-a^2)^2}{4b^2c^2}}\\\\\n    &= \\frac{1}{2}\\sqrt{b^2c^2 - \\left(\\frac{(b^2+c^2-a^2)}{2}\\right)^2}\\\\\n    &= \\frac{1}{2}\\sqrt{\\left(-\\frac{b^2+c^2-a^2-2bc}{2}\\right)\\left(\\frac{b^2+c^2-a^2+2bc}{2}\\right)}\\\\\n    &= \\frac{1}{2}\\sqrt{\\left(-\\frac{(b-c)^2-a^2}{2}\\right)\\left(\\frac{(b+c)^2-a^2}{2}\\right)}\\\\\n    &= \\frac{1}{2}\\sqrt{\\frac{(a+b-c)(a+c-b)}{2}\\frac{(a+b+c)(b+c-a)}{2}}\\\\\n    &= \\sqrt{\\frac{(a+b-c)}{2}\\frac{(a+c-b)}{2}\\frac{(a+b+c)}{2}\\frac{(b+c-a)}{2}}\\\\\n    &= \\sqrt{s(s-a)(s-b)(s-c)}\n\\end{align}\n\\]\n\n\n\n\n\n\n\n\n\n\nNote三角形の傍接円からのヘロンの公式\n\n\n\n\n\n下記のように \\(\\triangle ABC\\) について内心 \\(D\\) と傍心 \\(G\\) を考えます．\n\n前準備として \\(\\triangle ABC\\) のそれぞれの角の対辺を \\(a, b, c\\) として\n\\[\ns = \\frac{1}{2}(a + b + c)\n\\]\nと変数 \\(s\\) を定義します．また，内接円の性質（各頂点の内角の二等分線上に内心が存在）より\n\\[\n\\begin{align}\nAH &= AN\\\\\nCN &= CI\\\\\nBH &= BI\n\\end{align}\n\\]\n従って，\n\\[\n\\begin{align}\nAH &= s - a\\\\\nBH &= s - b\\\\\nCN &= s = c\n\\end{align}\n\\]\n傍接円の傍心 \\(G\\) は\n\n\\(\\angle A\\) の二等分線上\n\\(B\\) と \\(C\\)の外角の二等分線上\n\nに存在することから\n\\[\nAL = AE\n\\]\nまた，\n\\[\n\\begin{align}\nAL + AE\n    &= (AC + CL) + (AB + BE)\\\\\n    &= (AC + CO) + (AB + BO)\\\\\n    &=  a + b + c\\\\\n    &= 2s\n\\end{align}\n\\]\n従って，\n\\[\nAL = AE = s\n\\]\n内接円の内心 \\(D\\) が \\(\\angle B, \\angle C\\) の二等分線上に存在するので\n\\[\n\\begin{align}\n180^\\circ\n    &= 2\\angle HBD + 2\\angle EBG\\\\\n\\Rightarrow & 90^\\circ = \\angle HBD + \\angle EBG\n\\end{align}\n\\]\n従って，\n\\[\n\\begin{align}\n\\angle BDH &= \\angle EBG\n\\angle HBD &= \\angle BGE\n\\end{align}\n\\]\nここから\n\\[\n\\triangle HBD \\sim \\triangle EGB\n\\]\nこれより\n\\[\n\\frac{s - b}{r_1}=\\frac{r_2}{s - c}\n\\]\nこれを整理すると\n\\[\nr_1r_2 = (s-b)(s-c) \\label{#eq-1}\n\\]\nまた，\\(\\triangle HDE\\) と \\(\\triangle HDO\\) の面積が等しいことから\n\\[\nsr_1 = (s-a)r_2  \\label{#eq-2}\n\\]\n\\(\\eqref{#eq-1}\\), \\(\\eqref{#eq-2}\\) を 掛け合わせて \\(r_2\\) を両辺から除して \\(s\\) を両辺にかけると\n\\[\ns^2r_1^2 = s(s-a)(s-b)(s-c)\n\\]\n従って\n\\[\nsr_1 = \\sqrt{s(s-a)(s-b)(s-c)}\n\\]\nLHSは \\(\\triangle ABC\\) の面積と一致するので，これでヘロンの公式が示された．"
  },
  {
    "objectID": "posts/2025-02-01-function-and-taylor-expansion/index.html",
    "href": "posts/2025-02-01-function-and-taylor-expansion/index.html",
    "title": "18世紀までの関数論とテイラー展開",
    "section": "",
    "text": "Def: 関数 \n\\(X \\subset \\mathbb R^n, Y\\subset \\mathbb R^n\\) とする．\\(X\\) から \\(Y\\) への関数（実関数）とは，\\(X\\) の任意の元 \\(x\\) に対して，\\(Y\\) の１つの元を対応させる規則をいう． このような \\(X\\) から \\(Y\\) への関数を\n\\[\nf: X\\to Y\n\\]\nを記述し，集合 \\(X\\) を関数 \\(f\\) の定義域(domain)，\\(Y\\) を値域(range) という．\n\n\\(y = x^2\\) としたとき，\\(y\\) は区間 \\((-\\infty, \\infty)\\) における \\(x\\) の関数と呼ばれます．関数の例としては以下，\n\nCode\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nx = np.linspace(-1, 1, 100)\n\nplt.plot(x, x**2)\nplt.gca().set_aspect('equal', adjustable='box')\nplt.show()\n\nplt.plot(x , np.sqrt(1 - x**2))\nplt.gca().set_aspect('equal', adjustable='box')\nplt.show()\n\n\n\n\n\n\n\n\\(y = x^2\\)\n\n\n\n\n\n\n\n\\(y = \\sqrt{1 - x^2}\\)\n\n\n\n\n\n ▶  古典的な関数\n歴史的に関数はまず，\n\n四則演算で表される代数式（\\(x^2 + 2x +1\\), \\(x + \\frac{1}{x}\\), \\(x + \\sqrt{4x^2 + 1}\\)）\n独立変数の代数式で表せない超越関数（\\(a^x, \\log x, \\sin x, \\arctan x\\)）\n\nに限られていました．これら関数は，各点周りでテイラー展開ができるという特徴があります．"
  },
  {
    "objectID": "posts/2025-02-01-function-and-taylor-expansion/index.html#関数",
    "href": "posts/2025-02-01-function-and-taylor-expansion/index.html#関数",
    "title": "18世紀までの関数論とテイラー展開",
    "section": "",
    "text": "Def: 関数 \n\\(X \\subset \\mathbb R^n, Y\\subset \\mathbb R^n\\) とする．\\(X\\) から \\(Y\\) への関数（実関数）とは，\\(X\\) の任意の元 \\(x\\) に対して，\\(Y\\) の１つの元を対応させる規則をいう． このような \\(X\\) から \\(Y\\) への関数を\n\\[\nf: X\\to Y\n\\]\nを記述し，集合 \\(X\\) を関数 \\(f\\) の定義域(domain)，\\(Y\\) を値域(range) という．\n\n\\(y = x^2\\) としたとき，\\(y\\) は区間 \\((-\\infty, \\infty)\\) における \\(x\\) の関数と呼ばれます．関数の例としては以下，\n\nCode\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nx = np.linspace(-1, 1, 100)\n\nplt.plot(x, x**2)\nplt.gca().set_aspect('equal', adjustable='box')\nplt.show()\n\nplt.plot(x , np.sqrt(1 - x**2))\nplt.gca().set_aspect('equal', adjustable='box')\nplt.show()\n\n\n\n\n\n\n\n\\(y = x^2\\)\n\n\n\n\n\n\n\n\\(y = \\sqrt{1 - x^2}\\)\n\n\n\n\n\n ▶  古典的な関数\n歴史的に関数はまず，\n\n四則演算で表される代数式（\\(x^2 + 2x +1\\), \\(x + \\frac{1}{x}\\), \\(x + \\sqrt{4x^2 + 1}\\)）\n独立変数の代数式で表せない超越関数（\\(a^x, \\log x, \\sin x, \\arctan x\\)）\n\nに限られていました．これら関数は，各点周りでテイラー展開ができるという特徴があります．"
  },
  {
    "objectID": "posts/2025-02-01-function-and-taylor-expansion/index.html#平均値の定理からtaylorの公式へ",
    "href": "posts/2025-02-01-function-and-taylor-expansion/index.html#平均値の定理からtaylorの公式へ",
    "title": "18世紀までの関数論とテイラー展開",
    "section": "平均値の定理からTaylorの公式へ",
    "text": "平均値の定理からTaylorの公式へ\n\n\nTheorem 1 : 平均値の定理 \n区間 \\([a, b]\\) において，\\(f(x), g(x)\\) は連続で, \\((a, b)\\) において微分可能とする．このとき，ある点 \\(\\xi \\in (a, b)\\) において，\n\\[\n\\frac{f(b) - f(a)}{g(b) - g(a)} = \\frac{f^\\prime(\\xi)}{g^\\prime(\\xi)}\\label{eq-mean-value}\n\\]\nただし，\\(g(a)\\neq g(b)\\)．\\(f^\\prime(x), g^\\prime(x)\\) は区間内で同時に \\(0\\) にならないと仮定する．\n\n\n\n\n\n\n\n\n\nNoteProof\n\n\n\n\n\n\\(F(x) - \\mu f(x) - \\lambda g(x)\\) とおき，\\(F(a) = F(b) = k\\) となるように適当に \\(\\lambda:\\mu\\) を定める．\nこのとき，\n\\[\n\\begin{gather}\n\\mu f(a) - \\lambda g(a) = \\mu f(b) - \\lambda g(b)\\\\\n\\Rightarrow \\mu (f(b) - f(a)) = \\lambda (g(b) - g(a))\\\\\n\\Rightarrow \\mu (f(b) - f(a)) = \\lambda (g(b) - g(a))\\\\\n\\Rightarrow \\mu = g(b) - g(a), \\lambda = f(b) - f(a)\n\\end{gather}\n\\]\nとして，\n\\[\nF(x) = \\{g(b)-g(a)\\}f(x) - \\{f(b)-f(a)\\}g(x)\n\\]\nここで，\\(G(x) = F(x) - k\\) を考える．有界閉区間 \\([a, b]\\) において \\(f(x), g(x)\\) は連続であるので，有界閉区間 \\([a, b]\\) において \\(F(x)\\) および \\(G(x)\\) も連続関数である．関数の連続性より， とある \\(\\xi \\in [a, b]\\) で \\(G(x)\\) は最大値 \\(G(\\xi) = M &lt; \\infty\\) をとる．\n\\(M &gt; 0\\) のとき，\n\\(x = \\xi\\) において \\(\\Delta G \\leq 0\\). 故に\n\n\\(\\Delta x &gt; 0\\) とすれば \\(\\displaystyle\\frac{\\Delta G}{\\Delta x} \\leq 0\\), 従って，\\(G^\\prime(\\xi)\\leq 0\\)\n\\(\\Delta x &lt; 0\\) とすれば \\(\\displaystyle\\frac{\\Delta G}{\\Delta x} \\geq 0\\), 従って，\\(G^\\prime(\\xi)\\geq 0\\)\n\n従って，\\(G^\\prime(\\xi) = 0\\). \\(M = 0\\) のときは，同様に最小値 \\(G(\\xi) = M &gt; -\\infty\\) を考えると \\(G^\\prime(\\xi)\\geq 0\\) を得る．最小値と最大値が \\(0\\) の場合は \\(G(x)\\) が常に \\(0\\) であるので，\\(x \\in (a, b)\\) において \\(G^\\prime(x) = 0\\) は自明．\nこのとき，\\(F(x) - k = G(x)\\) より\n\\[\n\\begin{align}\nF^\\prime(\\xi) =  \\{g(b)-g(a)\\}f^\\prime(\\xi) - \\{f(b)-f(a)\\}g^\\prime(\\xi) = 0\n\\end{align}\n\\]\nよって，\n\\[\n\\frac{f(b) - f(a)}{g(b) - g(a)} = \\frac{f^\\prime(\\xi)}{g^\\prime(\\xi)}\n\\]\nが成立する．\n\n\n\n平均値の定理を幾何学的に考察してみます．独立変数 \\(t\\) について，曲線\n\\[\nx = f(t), y=g(t)\\qquad t \\in [a. b]\n\\]\nを考えます．このとき，\\(t=a, t=b\\) に対応する \\((x, y)\\) をそれぞれ \\(A, B\\) とすると，\\(\\eqref{eq-mean-value}\\) のLHSが弦ABの勾配に対応します． このとき，\\(x = f(t), y=g(t)\\) の曲線上のとある点 \\(P: t= \\xi\\) の接線が弦ABの勾配と平行になることを定理は示しています．\\(f^\\prime(x), g^\\prime(x)\\) は区間内で同時に \\(0\\) にならないと仮定は，曲線が各点において 確定の接線を有することを意味します．\n\nCode\ndef func_x(x):\n    return np.sin(x) + x\n\ndef func_y(x):\n    return x * np.log(x) ** 2\n\ndef tangent(x, x_0):\n    return func_y(x_0) + (x- func_x(x_0)) * (np.log(np.pi/2) ** 2.5)\n\n\nt = np.linspace(1e-18, np.pi/2, 1000)\nt2 = np.linspace(1.8, 2.6, 100)\nx, y = func_x(t), func_y(t)\nt_0 = 1.11\n\n# plot\nplt.plot(x, y, linewidth=2)\n\n# # add line\nplt.plot([0, func_x(np.pi/2)], [0, func_y(np.pi/2)], color=\"gray\")\nplt.text(-0.01, -0.03, \"A\")\nplt.text(2.55, 0.33, \"B\")\n\n# # add tangent\n# plt.text(x_0, sample_func(x_0)+1e-4, \"P: x = $\\exp(-2)$\")\nplt.scatter(func_x(t_0), func_y(t_0), color=\"gray\", linestyle=\"dotted\")\nplt.text(func_x(t_0), -0.02, \"P\")\nplt.plot(t2, tangent(t2, t_0))\n\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 1: \\(t\\in [0,\\pi/2]\\) 区間で定義された \\(x = \\sin(t) +t, y = \\begin{cases}t(\\log(t))^2  & (t\\in(0, \\pi/2))\\\\0 & t = 0\\end{cases}\\)\n\n\n\n\n\n\n\n\n\nTip🍵 Green Tea Break\n\n\n\n実数空間 \\(\\mathbb R\\) の部分集合 \\(I\\) で定義された関数 \\(f(x)\\) が区間 \\(I\\) の点 \\(a\\) において連続であるとは\n\\[\n\\lim_{x\\to a}f(x) = f(a)\n\\]\nが成り立つことをいいます．\n\\[\nf(t) = \\begin{cases}t(\\log(t))^2  & (t\\in(0, \\pi/2))\\\\0 & t = 0\\end{cases}\n\\]\nはロピタルの定理を用いると，\n\\[\n\\begin{align}\n\\lim_{t\\to 0} t(\\log(t))^2\n    &= \\lim_{t\\to 0} \\frac{(\\log(t))^2}{t^{-1}}\\\\\n    &= \\lim_{t\\to 0} \\frac{2(\\log(t))\\frac{1}{t}}{-t^{-2}}\\\\\n    &= \\lim_{t\\to 0} \\frac{2(\\log(t))}{-t^{-1}}\\\\\n    &= \\lim_{t\\to 0} \\frac{2t^{-1}}{t^{-2}}\\\\\n    &= \\lim_{t\\to 0} 2t = 0\n\\end{align}\n\\]\n以上のように連続性を示すことが出来ます．\n\n\n\nTaylorの公式\n\n\nTheorem 2 \nある区間において．\\(f(x)\\) は第 \\(n\\) 階まで微分可能とする．このときその区間において，\\(a\\) は定点，\\(x\\) を任意の点とするとき\n\\[\n\\begin{gather}\nf(x) = f(a) + \\frac{f^\\prime(a)}{1!}(x-a) + \\frac{f^{\\prime\\prime}(a)}{2!}(x-a)^2 + \\cdots + \\frac{f^{(n-1)}(a)}{(n-1)!}(x-a)^{n-1} + \\frac{f^{(n)}(\\xi)}{(n)!}(x-a)^{n}\\label{eq-taylor}\\\\\n\\text{s.t } \\quad \\xi = a + \\theta(x-a), \\qquad 0 &lt;\\theta&lt;1\n\\end{gather}\n\\]\n\n\n\\(\\frac{f^{(n)}(\\xi)}{(n)!}(x-a)^{n}\\) は \\(R_n\\) と表されることもあり，剰余項とよびます．\n\n\n\n\n\n\n\nNoteProof\n\n\n\n\n\n\\[\nF(x) = f(x) - \\{f(a) + \\frac{f^\\prime(a)}{1!}(x-a) + \\frac{f^{\\prime\\prime}(a)}{2!}(x-a)^2 + \\cdots + \\frac{f^{(n-1)}(a)}{(n-1)!}(x-a)^{n-1}\\}\\label{eq-residual}\n\\]\nとおく．このとき，定義より\n\\[\nF(a) = F^{\\prime}(a) = F^{\\prime\\prime}(a) = \\cdots = F^{n-1}(a) = 0\n\\]\nここで，\n\\[\nG(x) = (x - a)^n\n\\]\nと定義すると第 \\(n\\) 階まで微分可能であり，また \\(G(a) = 0\\)．このとき，中間値の定理より\n\\[\n\\begin{align}\n\\frac{F(x) - F(a)}{G(x) - G(a)}\n    &= \\frac{F(x)}{G(x)}\\\\\n    &= \\frac{F(x)}{(x-a)^n}\\\\\n    &= \\frac{F^\\prime(x_1)}{n(x_1-a)^{n-1}} \\qquad x_1 \\in (a, x)\n\\end{align}\n\\]\n同様に\n\\[\n\\frac{F^\\prime(x_1)}{n(x_1-a)^{n-1}} = \\frac{F^{\\prime\\prime}(x_2)}{n(n-1)(x_2-a)^{n-2}} \\qquad x_2 \\in (a, x_1)\n\\]\n\\(f(x)\\) は第 \\(n\\) 階まで微分可能であるので，\\(F(x)\\) も第 \\(n\\) 階まで微分可能．従って，\n\\[\n\\frac{F(x)}{(x-1)^n} = \\frac{F^{n}(\\xi)}{n!} \\qquad \\exists\\xi \\in (a, x)\n\\]\nつまり\n\\[\nF(x) = \\frac{F^{n}(\\xi)}{n!}(x-a)^n\n\\]\nこれを \\(\\eqref{eq-residual}\\) に代入して整理すると \\(\\eqref{eq-taylor}\\) を得る．\n\n\n\n整式はそれ自身が有限個の項で完結したテイラー展開のしていますし，無限等比級数の公式\n\\[\n\\frac{1}{1 + r} = 1 - r + r^2 - r^3 + \\cdots = \\sum_{i=0}(-r)^i \\qquad (-1 &lt; r &lt; 1)\n\\]\nは \\(x = 1\\) 周りでの関数 \\(f(x) = 1/ x\\) のテイラー展開となっており，\\(x = 1 + r\\) とすると\n\\[\n\\begin{align}\n\\frac{1}{1+r}\n    &= 1 + \\frac{(-1)}{1!}r + \\frac{(-1)\\times(-2)}{2!}r^2 + \\frac{(-1)\\times(-2)\\times(-3)}{3!}r^3 + \\cdots\\\\\n    &= 1 - r + r^2 - r^3 + \\cdots\n\\end{align}\n\\]\nと確認することが出来ます．三角関数も\n\\[\n\\begin{align}\n\\cos x &= 1 - \\frac{1}{2}x^2 + \\frac{1}{24}x^4 - \\cdots\\\\\n\\sin x &= x - \\frac{1}{6}x^3 + \\frac{1}{120}x^5 - \\cdots\n\\end{align}\n\\]\nとテイラー展開することが出来ます．そのため，18世紀までの数学界では，関数は各点周りで冪級数にテイラー展開できるので，微分や積分もテイラー展開を応用して形式的な代数的計算で十分と考えられてました． 19世紀になると任意の関数 \\(f(x)\\) は\n\\[\nf(x) \\sim \\frac{a_0}{2} + \\sum_{n=1}^\\infty(a_n\\cos nx + b_n \\sin nx)\n\\]\nで表すことができるのではないか？という主張が登場し，関数，微分，積分の理論の見直しの必要性が認識されるようになりました．\n\nExample 1 : テイラー展開の例 \n次の関数の点 \\(a\\) のまわりのテイラー展開を剰余項を含めて \\(h^3\\) まで書き下すと以下のようになります\n\\[\n\\begin{align}\n\\log(a+h) &= \\log(a) + \\frac{h}{a} - \\frac{1}{2}\\frac{h^2}{a^2} + \\frac{1}{3}\\frac{h^3}{(a+\\theta h)^3}\\\\\n(a+h)^\\beta &= a^\\beta + \\beta a^{\\beta-1}h + \\frac{\\beta(\\beta-1)}{2!}a^{\\beta-2}h^2+ \\frac{\\beta(\\beta-1)(\\beta-2)}{3!}(a+\\theta h)^{\\beta-3}h^3\n\\end{align}\n\\]\nただし，\\(0 &lt; \\theta &lt; 1\\) とします．\n\n\n\nTaylor展開の応用: \\(e\\) が無理数であることの証明\n\\(f(x) = \\exp(x)\\) を マクローリン展開すると\n\\[\n\\exp(x) = 1 + \\frac{x}{1!} + \\frac{x^2}{2!} + \\frac{x^3}{3!} + \\cdots + \\frac{x^n}{n!} + R_{n+1}\n\\]\n\\(x = 1\\) としたとき，\n\\[\ne =  1 + \\frac{1}{1!} + \\frac{1}{2!} + \\frac{1}{3!} + \\cdots + \\frac{1}{n!} + R_{n+1}\n\\]\n剰余項 \\(R_{n+1}0\\) は\n\\[\nR_{n+1} = \\frac{\\exp(\\theta)}{(n+1)!} &gt; 0 \\quad \\exists\\theta \\in (0, 1)\n\\]\nつまり，\n\\[\nR_{n+1} = \\frac{\\exp(\\theta)}{(n+1)!} &lt; \\frac{3}{(n+1)!}\n\\]\nここで，\\(e\\) を有理数として \\(e = m/n\\) と既約分数で表せると仮定する．このとき，\\(n!e\\) は仮定より整数となるので\n\\[\n1 \\leq n!R_{n+1} = \\frac{\\exp(\\theta)}{n+1} &lt; \\frac{3}{n+1}\n\\]\n従って，\\(n+1 &lt;3\\) つまり \\(n &lt; 2\\)，従って，\\(n = 1\\) を得る．このとき，\\(m\\) は整数なので \\(e = m\\) となるが \\(2 &lt; e &lt; 3\\) より矛盾．従って，\\(e\\) は無理数となる．"
  },
  {
    "objectID": "posts/2025-06-02-combined-gas-law/index.html",
    "href": "posts/2025-06-02-combined-gas-law/index.html",
    "title": "ボイル=シャルルの法則の導出",
    "section": "",
    "text": "Theorem 1 ボイルの法則\n温度 \\(T\\) が一定のとき，圧力 \\(p\\) と体積 \\(V\\) は反比例する．つまり，\n\\[\npV = \\text{constant}\n\\]\n\nある一定の温度 \\(T\\) の下では，\n\n圧力 \\(p\\) を上げれば，それに反比例して体積 \\(V\\) は収縮\n圧力 \\(p\\) を下げれば，それに反比例して体積 \\(V\\) は膨張\n\n\nTheorem 2 シャルルの法則\n圧力 \\(p\\) が一定のとき，温度 \\(T\\) と体積 \\(V\\) は比例する\n\\[\n\\frac{V}{T} = \\text{constant}\n\\]\n\n圧力 \\(p\\) が一定のとき\n\n温度 \\(T\\) を上げれば，それに比例して体積 \\(V\\) は膨張\n温度 \\(T\\) を下げれば，それに比例して体積 \\(V\\) は収縮"
  },
  {
    "objectID": "posts/2025-06-02-combined-gas-law/index.html#ボイルの法則とシャルルの法則",
    "href": "posts/2025-06-02-combined-gas-law/index.html#ボイルの法則とシャルルの法則",
    "title": "ボイル=シャルルの法則の導出",
    "section": "",
    "text": "Theorem 1 ボイルの法則\n温度 \\(T\\) が一定のとき，圧力 \\(p\\) と体積 \\(V\\) は反比例する．つまり，\n\\[\npV = \\text{constant}\n\\]\n\nある一定の温度 \\(T\\) の下では，\n\n圧力 \\(p\\) を上げれば，それに反比例して体積 \\(V\\) は収縮\n圧力 \\(p\\) を下げれば，それに反比例して体積 \\(V\\) は膨張\n\n\nTheorem 2 シャルルの法則\n圧力 \\(p\\) が一定のとき，温度 \\(T\\) と体積 \\(V\\) は比例する\n\\[\n\\frac{V}{T} = \\text{constant}\n\\]\n\n圧力 \\(p\\) が一定のとき\n\n温度 \\(T\\) を上げれば，それに比例して体積 \\(V\\) は膨張\n温度 \\(T\\) を下げれば，それに比例して体積 \\(V\\) は収縮"
  },
  {
    "objectID": "posts/2025-06-02-combined-gas-law/index.html#ボイルシャルルの法則",
    "href": "posts/2025-06-02-combined-gas-law/index.html#ボイルシャルルの法則",
    "title": "ボイル=シャルルの法則の導出",
    "section": "ボイル=シャルルの法則",
    "text": "ボイル=シャルルの法則\n\nTheorem 3 ボイル=シャルルの法則\nボイルの法則とシャルルの法則が成立するとき，\n\\[\n\\frac{pV}{T} = \\text{constant}\n\\]\nこれをボイル=シャルルの法則と呼ぶ\n\n\n\n\n\n\n\nNoteProof 1: 単射仮定\n\n\n\n\n\nボイルの法則より温度 \\(T\\) が一定のとき \\(pV = \\text{constant}\\)，つまり\n\\[\n\\begin{align}\npV = f(T) \\label{eq-base}\n\\end{align}\n\\]\n同様に，シャルルの法則より\n\\[\n\\frac{V}{T} = g(p)\n\\]\nここで関数 \\(g(\\cdot)\\) を単射と仮定すると\n\\[\nh\\left(\\frac{V}{T}\\right) = p\n\\]\n従って，\n\\[\nh\\left(\\frac{V}{T}\\right) = \\frac{f(T)}{v} \\ \\ \\forall v, T\n\\]\nここで，\\(\\displaystyle\\frac{V}{T} = x\\) とすると\n\\[\nh(x) = \\frac{f(T)}{x\\cdot T}\n\\]\nLHSは \\(x\\) の関数であることから，\n\\[\nh(x) = \\frac{f(T_1)}{x\\cdot T_1} = \\frac{f(T_2)}{x\\cdot T_2}\n\\]\n\\(\\displaystyle \\frac{f(T)}{T} = \\lambda\\)(定数) とおくと\n\\[\nh(x) = \\frac{\\lambda}{x}\n\\]\n従って，\\(f(T) = \\lambda T\\). これを \\(\\eqref{eq-base}\\) に代入すると\n\\[\npV = \\lambda T\n\\]\n\\(T &gt; 0\\) より\n\\[\n\\frac{pV}{T} = \\lambda\n\\]\n\n\n\n\n\n\n\n\n\nNoteProof: 独立変数\n\n\n\n\n\nボイルの法則とシャルルの法則より\n\\[\n\\begin{align}\npV &= f(T)\\\\\n\\frac{V}{T} &= g(p)\n\\end{align}\n\\]\nこれを \\(V\\) について解いて整理すると\n\\[\n\\frac{f(T)}{T} = pg(p)\n\\]\nこの式において，左辺は温度のみの関数，右辺は圧力のみの関数．圧力と温度は互いに独立しているため，この式が常に成り立つためには，両辺がそれぞれ定数でなければならない．つまり，\n\\[\n\\lambda = \\frac{f(T)}{T} = pg(p)\n\\]\n従って，\n\\[\n\\begin{align}\nf(T) &= \\lambda T\n\\end{align}\n\\]\nよって，\n\\[\n\\frac{pV}{T} = \\lambda\n\\]\n\n\n\n\n物理的現象としてボイル=シャルルの法則を見てみる\n\n\n\n\n\n\nsequenceDiagram\n    participant A as p₀, V₀, T₀\n    participant B as p₁, V', T₀\n    participant C as p₁, V₁, T₁\n    A-&gt;&gt;B: T₀一定&lt;br&gt;p₀V₀=p₁V'\n    B-&gt;&gt;C: p₁一定&lt;br&gt;V'/T₀ = V₁/T₁\n\n\n\n\n\n\n\nまず，\\(p_0, V_0, T_0\\) の１つの熱力学的な系を，温度 \\(T_0\\) のまま圧力を \\(p_1, V'\\) に変化させると，ボイルの法則より\n\\[\np_0V_0 = p_1V'\n\\]\nつぎに \\(p_1\\) を一定の下，\\(V_1, T_1\\) へ系を変化させると，シャルルの法則より\n\\[\n\\frac{V'}{T_0} = \\frac{V_1}{T_1}\n\\]\nここから\n\\[\nV' = T_0\\cdot\\frac{V_1}{T_1}\n\\]\nよって\n\\[\n\\frac{p_0V_0}{T_0} = \\frac{p_1V_1}{T_1} = \\text{constant}\n\\]\nを得る．\n\n\nボイル=シャルルの法則から理想気体の状態方程式を導く\n1 molの気体は 0℃, 1 atm の条件下で気体の種類によらず体積は 22.41 l になります．ここから\n\\[\n\\begin{align}\n\\frac{pV}{T}\n  &= \\frac{1.013 \\times 10^5 \\times 22.41 \\times 10^{-3}}{273.15}\\\\\n  &\\approx 8.31 \\text{[J/mol K]}\n\\end{align}\n\\]\n\n\\(pV\\) の単位あh [Pa･m³] = [Nm] = [J] つまり，エネルギーの単位となる\n\nこの定数を \\(R\\) とおくと \\(R \\approx 8.31 \\text{[J/mol K]}\\)．この定数 \\(R\\) を気体定数と呼ぶ．\\(n\\) molの気体に対しては\n\\[\n\\frac{pV}{T} = nR\n\\]\n\nExample 1 空気中の分子数\n20℃，1atmの空気 1cm³の質量と，それに含まれる分子数を求めてみます．条件として\n\n空気は酸素と窒素が1:4の比率として，1molあたり質量は28.8とする\nアボガドロ数 \\(N_a = 6.02 \\times 10^{23}\\)\n\n理想気体の状態方程式より\n\\[\n\\frac{22.41}{273.15} = \\frac{V}{293.15}\n\\]\n従って，\\(V = 24.05 \\text{[l]} = 24.05 \\times 10^3 \\text{[cm³]}\\)．1cm³あたり質量は\n\\[\n\\frac{28.8}{24.05 \\times 10^3 } \\approx 1.20 \\times 10^{-3} \\text{[g/cm³]}\n\\]\nこの空気1cm³あたり分子数は\n\\[\n\\frac{N_A}{24.05 \\times 10^3} \\approx 2.50 \\times 10^{19} \\text{[個/cm³]}\n\\]"
  },
  {
    "objectID": "posts/2025-02-25-law-of-sines/index.html",
    "href": "posts/2025-02-25-law-of-sines/index.html",
    "title": "正弦定理の考え方",
    "section": "",
    "text": "Exercise 1 \n\\(BC = 30, \\angle B = 70^\\circ, \\angle C = 63^\\circ\\) となるような \\(\\triangle ABC\\) が与えられたとします．このとき，長さ \\(AB\\) を求めよ\n\n\n設問の \\(\\triangle ABC\\) を図示すると以下のようになります．\\(B\\) から \\(AC\\) に対して垂線を垂らし，その交点を \\(BH\\) とします．\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport matplotlib.patches as patches\n\ndef plot_triangular(base_length: float, angles: tuple, fig_size=(6,6)):\n    # Given values\n    BC = 30  # Side BC\n    angle_B = np.radians(angles[0])  # Convert degrees to radians\n    angle_C = np.radians(angles[1])  # Convert degrees to radians\n\n    # Calculate angle A\n    angle_A = np.radians(180 - sum(angles))\n\n    # Use Law of Sines to find AB and AC\n    AB = BC * np.sin(angle_B) / np.sin(angle_A)\n    AC = BC * np.sin(angle_C) / np.sin(angle_A)\n\n    # Set points in a 2D coordinate system\n    B = np.array([0, 0])  # Point B at the origin\n    C = np.array([BC, 0])  # Point C on the x-axis\n\n    # Calculate A's coordinates using trigonometry\n    A_x = BC - AC * np.cos(angle_B)  # Projection of AC on x-axis\n    A_y = AC * np.sin(angle_B)  # Height of A\n\n    A = np.array([A_x, A_y])\n\n    # Plot the triangle using ax\n    fig, ax = plt.subplots(figsize = fig_size)\n    ax.plot([A[0], B[0]], [A[1], B[1]], 'ko-')  # Black line with circle markers\n    ax.plot([B[0], C[0]], [B[1], C[1]], 'ko-')  # Black line with circle markers\n    ax.plot([C[0], A[0]], [C[1], A[1]], 'ko-')  # Black line with circle markers\n\n    # Annotate points\n    ax.text(A[0], A[1], '  A', fontsize=12, verticalalignment='bottom')\n    ax.text(B[0], B[1], '  B', fontsize=12, verticalalignment='top', horizontalalignment='right')\n    ax.text(C[0], C[1], '  C', fontsize=12, verticalalignment='top', horizontalalignment='left')\n\n    # Add angles as arcs\n    arc_radius = 5  # Radius for the arcs\n\n    # Angle at B\n    angle_B_arc = patches.Arc(B, arc_radius, arc_radius, angle=0, theta1=0, theta2=np.degrees(angle_B), color='blue')\n    ax.add_patch(angle_B_arc)\n    ax.text(B[0] + arc_radius/2, B[1] + 1, f\"{70}°\", fontsize=12, color='blue')\n\n    # Angle at C\n    angle_C_arc = patches.Arc(C, arc_radius, arc_radius, angle=0, theta1=180 - np.degrees(angle_C), theta2=180, color='red')\n    ax.add_patch(angle_C_arc)\n    ax.text((C[0] - arc_radius/2) - 2, C[1] + 1, f\"{63}°\", fontsize=12, color='red')\n\n    return fig, ax, (A, B, C)\n\n# plot\nfig, ax, coordinates = plot_triangular(30, (70, 63))\n\n# add BH\nslope = -1/((coordinates[2][1] - coordinates[0][1])/(coordinates[2][0] - coordinates[0][0]))\nax.plot((0, 26.5), (0, slope * 26.5))\nax.text(26.5, slope * 26.5, '  H', fontsize=12, verticalalignment='top', horizontalalignment='left')\n\n# add labels\nax.text(15, -2, \"BC = 30\", fontsize=12, color='black', horizontalalignment='center')\nax.axhline(0, color='black',linewidth=0.5)\nax.axvline(0, color='black',linewidth=0.5)\nax.grid(True, linestyle='--', alpha=0.6)\nax.set_xlim(-5, 35)\nax.set_ylim(-5, 42)\nax.set_title(\"Triangle ABC\")\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 1\n\n\n\n\\(\\triangle BCH, \\triangle ABH\\) を考えると，\n\\[\n\\begin{align}\nBH &= \\sin( A) * AB\\\\\nBH &= \\sin( C) * BC\n\\end{align}\n\\]\nこれを整理すると\n\\[\n\\begin{align}\nAB &= \\frac{\\sin(C) * BC}{\\sin A}\\label{eq-law-of-sines-1}\\\\\n   &= \\frac{30 \\cdot \\sin(63^\\circ)}{\\sin(47^\\circ)}\\label{eq-law-of-sines-2}\n\\end{align}\n\\]\n従って，\n\n\nCode\nprint(f\"BC = {30 * np.sin(63/180 * np.pi)/np.sin(47/180 * np.pi):.4f}\")\n\n\nBC = 36.5489\n\n\nと計算されます．\n\n\n\\(\\eqref{eq-law-of-sines-1}\\), \\(\\eqref{eq-law-of-sines-2}\\) を整理すると\n\\[\n\\frac{AB}{\\sin A} = \\frac{BC}{\\sin C}\n\\]\nを得ます．同様の方法で \\(AC\\) を求めて整理すると，\n\\[\n\\frac{AB}{\\sin A}= \\frac{AC}{\\sin B} = \\frac{BC}{\\sin C}\n\\]\nこれは，\\(\\triangle ABC\\) の外接円を考えたとき，その外接円の半径を \\(R\\) としたとき\n\\[\n\\frac{AB}{\\sin A}= \\frac{AC}{\\sin B} = \\frac{BC}{\\sin C} = 2R\n\\]\nという正弦定理へ繋がります．\n ▶  対辺と\\(\\sin\\) の比率が直径 \\(2R\\)に一致する証明\n\n\n\n\n\n\n\nNoteProof\n\n\n\n\n\n\\(\\triangle ABC\\) の外接円について，弧BC以外の円周上の点 \\(P\\) を適当に取ったときに形成される角度 \\(\\angle BPC\\) を弧BCの円周角といいます． 中心角と円周角の関係として，\n\\[\n\\text{中心角} = 2\\times (\\text{円周角})\n\\]\nここから，「同じ弧に対する円周角は等しい」ことがいえます．ここで，\\(CP\\) が外接円の直径となるように \\(P\\) を取ると直径に対する円周角は直角なので \\(\\triangle BCP\\) は直角三角形となります．\\(CP\\) を斜辺，\\(BC\\)を対辺とすると\n\\[\nBC = 2R \\times \\sin(\\angle BPC) = 2R \\times \\sin(A)\n\\]\n従って，\n\\[\n\\frac{BC}{\\sin A} = 2R\n\\]\n従って，\n\\[\n\\frac{AB}{\\sin A}= \\frac{AC}{\\sin B} = \\frac{BC}{\\sin C} = 2R\n\\]\n\n\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# 与えられた条件\nBC = 30  # 辺BC\nangle_B = np.radians(70)  # 角B (ラジアン変換)\nangle_C = np.radians(63)  # 角C (ラジアン変換)\n\n# 角Aを計算\nangle_A = np.radians(180 - (70 + 63))\n\n# 正弦定理を使ってABとACを求める\nAB = BC * np.sin(angle_B) / np.sin(angle_A)\nAC = BC * np.sin(angle_C) / np.sin(angle_A)\n\n# 頂点座標\nB = np.array([0, 0])  # Bを原点に配置\nC = np.array([BC, 0])  # Cをx軸上に配置\nA_x = BC - AC * np.cos(angle_B)  # Aのx座標\nA_y = AC * np.sin(angle_B)  # Aのy座標\nA = np.array([A_x, A_y])\n\n# 垂直二等分線の交点（外心）を求める\ndef circumcenter(A, B, C):\n    D = 2 * (A[0] * (B[1] - C[1]) + B[0] * (C[1] - A[1]) + C[0] * (A[1] - B[1]))\n    Ux = ((A[0]**2 + A[1]**2) * (B[1] - C[1]) + (B[0]**2 + B[1]**2) * (C[1] - A[1]) + (C[0]**2 + C[1]**2) * (A[1] - B[1])) / D\n    Uy = ((A[0]**2 + A[1]**2) * (C[0] - B[0]) + (B[0]**2 + B[1]**2) * (A[0] - C[0]) + (C[0]**2 + C[1]**2) * (B[0] - A[0])) / D\n    return np.array([Ux, Uy])\n\ncircumcenter_point = circumcenter(A, B, C)\nradius = np.linalg.norm(A - circumcenter_point)  # 外接円の半径\n\n# 円周上の点P（円周角を示す）\ntheta_P = np.radians(120)  # 任意の角度 (120°)\nP_x = circumcenter_point[0] + radius * np.cos(theta_P)\nP_y = circumcenter_point[1] + radius * np.sin(theta_P)\nP = np.array([0, 30/np.sin(angle_A) * np.sin(np.pi/2 - angle_A)])\n\n# 図を作成\nfig, ax = plt.subplots(figsize=(6,6))\n\n# 三角形ABCをプロット\nax.plot([A[0], B[0]], [A[1], B[1]], 'bo-', label=\"AB\")\nax.plot([B[0], C[0]], [B[1], C[1]], 'ro-', label=\"BC\")\nax.plot([C[0], A[0]], [C[1], A[1]], 'go-', label=\"CA\")\n\n# 外接円をプロット\ncircle = plt.Circle(circumcenter_point, radius, color='cyan', fill=False, linestyle='dashed', label=\"Circumcircle\")\nax.add_patch(circle)\n\n# 円周角を示す点Pと三角形BPC\nax.plot([B[0], P[0]], [B[1], P[1]], 'purple', linestyle='dotted', label=\"BP\")\nax.plot([C[0], P[0]], [C[1], P[1]], 'purple', linestyle='dotted', label=\"CP\")\n\n# 点のラベル\nax.text(A[0], A[1], '  A', fontsize=12, verticalalignment='bottom')\nax.text(B[0], B[1], '  B', fontsize=12, verticalalignment='top', horizontalalignment='right')\nax.text(C[0], C[1], '  C', fontsize=12, verticalalignment='top', horizontalalignment='left')\nax.text(P[0], P[1], '  P', fontsize=12, verticalalignment='bottom', horizontalalignment='right', color='purple')\nax.scatter(circumcenter_point[0], circumcenter_point[1], color='black')  # 外心O\n\n# グリッドと範囲設定\nax.axhline(0, color='black', linewidth=0.5)\nax.axvline(0, color='black', linewidth=0.5)\nax.grid(True, linestyle='--', alpha=0.6)\nax.set_xlim(-radius-5, BC+radius+5)\nax.set_ylim(-radius-5, radius+AC+5)\nax.legend()\nax.set_title(\"Triangle ABC with Circumcircle and Inscribed Angle\")\n\n# 図を表示\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 2\n\n\n\n\n\n\n\n\nExercise 2 \nとある山へハイキングにいくとします．\n\n山頂をC\n山の麓のA地点から同じ標高で直線距離で1000m離れている地点をB\nA地点からCを見たときの仰角は \\(30^\\circ\\)\n\\(\\triangle ABC\\) について，\\(\\angle CAB = 75^\\circ, \\angle ABC = 45^\\circ\\)\n\nということがわかっているとします．このとき，Cの標高を求めよ．なお，\\(A, B\\) の標高は 0m とする．\n\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.mplot3d.art3d import Poly3DCollection\n\n# Given angles and side lengths\nangle_A = np.radians(75)\nangle_B = np.radians(45)\nAB = 1000  # Given\n\n# Compute angle C\nangle_C = np.radians(180 - 75 - 45)  # C = 60 degrees\n\n# Compute sides using the Law of Sines\nBC = AB * np.sin(angle_A) / np.sin(angle_C)\nAC = AB * np.sin(angle_B) / np.sin(angle_C)\n\n# Compute coordinates of A, B, and C\nA = np.array([0, 0, 0])  # A is the origin\nB = np.array([AB, 0, 0])  # B is along the x-axis\nC_x = 0  # Projection of AC on x-axis\nC_y = AC * np.cos(np.radians(30))\nC_z = AC * np.sin(np.radians(30))  # Projection on y-axis\nC = np.array([0, C_y, C_z])  # C remains in the XY plane\n\n# Triangle ACH: Given CAH = 30°, CHA = 90° (Right Triangle)\nangle_CAH = np.radians(30)\n\n# H's coordinates (directly above C in the Z direction)\nH = np.array([0, C_y, 0])\n\n# Create 3D plot\nfig = plt.figure(figsize=(8, 8))\nax = fig.add_subplot(111, projection='3d')\n\n# Plot edges of tetrahedron\nedges = [\n    (A, B), (B, C), (C, A),  # Triangle ABC\n    (A, H), (C, H), (B, H)   # Connecting H to A, C, and B\n]\n\nfor edge in edges:\n    ax.plot(*zip(*edge), 'k-')\n\n# Define faces for tetrahedron visualization\nfaces = [\n    [A, B, C],  # Base ABC\n    [A, C, H],  # Side ACH\n    [C, B, H],  # Side CBH\n    [A, H, B]   # Side AHB\n]\n\n# Add face shading\nax.add_collection3d(Poly3DCollection(faces, alpha=0.3, color='cyan'))\n\n# Annotate points\nax.text(*A, \" A\", color='black', fontsize=12)\nax.text(*B, \" B\", color='black', fontsize=12)\nax.text(*C, \" C\", color='black', fontsize=12)\nax.text(*H, \" H\", color='black', fontsize=12)\n\n# Labels and grid\nax.set_xlabel(\"X-axis\")\nax.set_ylabel(\"Y-axis\")\nax.set_zlabel(\"Z-axis\")\nax.set_title(\"3D Tetrahedron CAHB\")\nax.grid(True)\n\nax.view_init(elev=20, azim=-55) \n\n# Show the plot\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 3\n\n\n\n\n\n\n\n\n\n\nNoteSolution\n\n\n\n\n\n上の図のようにCから\\(XY\\)平面に垂線を下ろして，XY平面との交点を \\(H\\) としたとき，今回求めたい長さは \\(CH\\)．\n問題文の情報を用いて正弦定理を利用すると\n\\[\n\\displaystyle AC = \\frac{AB}{\\sin (\\angle ACB)} \\cdot \\sin(\\angle ABC)\n\\]\nここで\n\\[\n\\begin{align}\nCH &= AC \\cdot \\sin(\\angle CAH)\\\\\n    &= \\frac{AB}{\\sin (\\angle ACB)} \\cdot \\sin(\\angle ABC) \\cdot \\sin(\\angle CAH)\n\\end{align}\n\\]\n従って，\n\n\nCode\nprint(f\"CH = {C_z:.2f}\")\n\n\nCH = 408.25"
  },
  {
    "objectID": "posts/2025-02-25-law-of-sines/index.html#正弦定理の考え方",
    "href": "posts/2025-02-25-law-of-sines/index.html#正弦定理の考え方",
    "title": "正弦定理の考え方",
    "section": "",
    "text": "Exercise 1 \n\\(BC = 30, \\angle B = 70^\\circ, \\angle C = 63^\\circ\\) となるような \\(\\triangle ABC\\) が与えられたとします．このとき，長さ \\(AB\\) を求めよ\n\n\n設問の \\(\\triangle ABC\\) を図示すると以下のようになります．\\(B\\) から \\(AC\\) に対して垂線を垂らし，その交点を \\(BH\\) とします．\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport matplotlib.patches as patches\n\ndef plot_triangular(base_length: float, angles: tuple, fig_size=(6,6)):\n    # Given values\n    BC = 30  # Side BC\n    angle_B = np.radians(angles[0])  # Convert degrees to radians\n    angle_C = np.radians(angles[1])  # Convert degrees to radians\n\n    # Calculate angle A\n    angle_A = np.radians(180 - sum(angles))\n\n    # Use Law of Sines to find AB and AC\n    AB = BC * np.sin(angle_B) / np.sin(angle_A)\n    AC = BC * np.sin(angle_C) / np.sin(angle_A)\n\n    # Set points in a 2D coordinate system\n    B = np.array([0, 0])  # Point B at the origin\n    C = np.array([BC, 0])  # Point C on the x-axis\n\n    # Calculate A's coordinates using trigonometry\n    A_x = BC - AC * np.cos(angle_B)  # Projection of AC on x-axis\n    A_y = AC * np.sin(angle_B)  # Height of A\n\n    A = np.array([A_x, A_y])\n\n    # Plot the triangle using ax\n    fig, ax = plt.subplots(figsize = fig_size)\n    ax.plot([A[0], B[0]], [A[1], B[1]], 'ko-')  # Black line with circle markers\n    ax.plot([B[0], C[0]], [B[1], C[1]], 'ko-')  # Black line with circle markers\n    ax.plot([C[0], A[0]], [C[1], A[1]], 'ko-')  # Black line with circle markers\n\n    # Annotate points\n    ax.text(A[0], A[1], '  A', fontsize=12, verticalalignment='bottom')\n    ax.text(B[0], B[1], '  B', fontsize=12, verticalalignment='top', horizontalalignment='right')\n    ax.text(C[0], C[1], '  C', fontsize=12, verticalalignment='top', horizontalalignment='left')\n\n    # Add angles as arcs\n    arc_radius = 5  # Radius for the arcs\n\n    # Angle at B\n    angle_B_arc = patches.Arc(B, arc_radius, arc_radius, angle=0, theta1=0, theta2=np.degrees(angle_B), color='blue')\n    ax.add_patch(angle_B_arc)\n    ax.text(B[0] + arc_radius/2, B[1] + 1, f\"{70}°\", fontsize=12, color='blue')\n\n    # Angle at C\n    angle_C_arc = patches.Arc(C, arc_radius, arc_radius, angle=0, theta1=180 - np.degrees(angle_C), theta2=180, color='red')\n    ax.add_patch(angle_C_arc)\n    ax.text((C[0] - arc_radius/2) - 2, C[1] + 1, f\"{63}°\", fontsize=12, color='red')\n\n    return fig, ax, (A, B, C)\n\n# plot\nfig, ax, coordinates = plot_triangular(30, (70, 63))\n\n# add BH\nslope = -1/((coordinates[2][1] - coordinates[0][1])/(coordinates[2][0] - coordinates[0][0]))\nax.plot((0, 26.5), (0, slope * 26.5))\nax.text(26.5, slope * 26.5, '  H', fontsize=12, verticalalignment='top', horizontalalignment='left')\n\n# add labels\nax.text(15, -2, \"BC = 30\", fontsize=12, color='black', horizontalalignment='center')\nax.axhline(0, color='black',linewidth=0.5)\nax.axvline(0, color='black',linewidth=0.5)\nax.grid(True, linestyle='--', alpha=0.6)\nax.set_xlim(-5, 35)\nax.set_ylim(-5, 42)\nax.set_title(\"Triangle ABC\")\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 1\n\n\n\n\\(\\triangle BCH, \\triangle ABH\\) を考えると，\n\\[\n\\begin{align}\nBH &= \\sin( A) * AB\\\\\nBH &= \\sin( C) * BC\n\\end{align}\n\\]\nこれを整理すると\n\\[\n\\begin{align}\nAB &= \\frac{\\sin(C) * BC}{\\sin A}\\label{eq-law-of-sines-1}\\\\\n   &= \\frac{30 \\cdot \\sin(63^\\circ)}{\\sin(47^\\circ)}\\label{eq-law-of-sines-2}\n\\end{align}\n\\]\n従って，\n\n\nCode\nprint(f\"BC = {30 * np.sin(63/180 * np.pi)/np.sin(47/180 * np.pi):.4f}\")\n\n\nBC = 36.5489\n\n\nと計算されます．\n\n\n\\(\\eqref{eq-law-of-sines-1}\\), \\(\\eqref{eq-law-of-sines-2}\\) を整理すると\n\\[\n\\frac{AB}{\\sin A} = \\frac{BC}{\\sin C}\n\\]\nを得ます．同様の方法で \\(AC\\) を求めて整理すると，\n\\[\n\\frac{AB}{\\sin A}= \\frac{AC}{\\sin B} = \\frac{BC}{\\sin C}\n\\]\nこれは，\\(\\triangle ABC\\) の外接円を考えたとき，その外接円の半径を \\(R\\) としたとき\n\\[\n\\frac{AB}{\\sin A}= \\frac{AC}{\\sin B} = \\frac{BC}{\\sin C} = 2R\n\\]\nという正弦定理へ繋がります．\n ▶  対辺と\\(\\sin\\) の比率が直径 \\(2R\\)に一致する証明\n\n\n\n\n\n\n\nNoteProof\n\n\n\n\n\n\\(\\triangle ABC\\) の外接円について，弧BC以外の円周上の点 \\(P\\) を適当に取ったときに形成される角度 \\(\\angle BPC\\) を弧BCの円周角といいます． 中心角と円周角の関係として，\n\\[\n\\text{中心角} = 2\\times (\\text{円周角})\n\\]\nここから，「同じ弧に対する円周角は等しい」ことがいえます．ここで，\\(CP\\) が外接円の直径となるように \\(P\\) を取ると直径に対する円周角は直角なので \\(\\triangle BCP\\) は直角三角形となります．\\(CP\\) を斜辺，\\(BC\\)を対辺とすると\n\\[\nBC = 2R \\times \\sin(\\angle BPC) = 2R \\times \\sin(A)\n\\]\n従って，\n\\[\n\\frac{BC}{\\sin A} = 2R\n\\]\n従って，\n\\[\n\\frac{AB}{\\sin A}= \\frac{AC}{\\sin B} = \\frac{BC}{\\sin C} = 2R\n\\]\n\n\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# 与えられた条件\nBC = 30  # 辺BC\nangle_B = np.radians(70)  # 角B (ラジアン変換)\nangle_C = np.radians(63)  # 角C (ラジアン変換)\n\n# 角Aを計算\nangle_A = np.radians(180 - (70 + 63))\n\n# 正弦定理を使ってABとACを求める\nAB = BC * np.sin(angle_B) / np.sin(angle_A)\nAC = BC * np.sin(angle_C) / np.sin(angle_A)\n\n# 頂点座標\nB = np.array([0, 0])  # Bを原点に配置\nC = np.array([BC, 0])  # Cをx軸上に配置\nA_x = BC - AC * np.cos(angle_B)  # Aのx座標\nA_y = AC * np.sin(angle_B)  # Aのy座標\nA = np.array([A_x, A_y])\n\n# 垂直二等分線の交点（外心）を求める\ndef circumcenter(A, B, C):\n    D = 2 * (A[0] * (B[1] - C[1]) + B[0] * (C[1] - A[1]) + C[0] * (A[1] - B[1]))\n    Ux = ((A[0]**2 + A[1]**2) * (B[1] - C[1]) + (B[0]**2 + B[1]**2) * (C[1] - A[1]) + (C[0]**2 + C[1]**2) * (A[1] - B[1])) / D\n    Uy = ((A[0]**2 + A[1]**2) * (C[0] - B[0]) + (B[0]**2 + B[1]**2) * (A[0] - C[0]) + (C[0]**2 + C[1]**2) * (B[0] - A[0])) / D\n    return np.array([Ux, Uy])\n\ncircumcenter_point = circumcenter(A, B, C)\nradius = np.linalg.norm(A - circumcenter_point)  # 外接円の半径\n\n# 円周上の点P（円周角を示す）\ntheta_P = np.radians(120)  # 任意の角度 (120°)\nP_x = circumcenter_point[0] + radius * np.cos(theta_P)\nP_y = circumcenter_point[1] + radius * np.sin(theta_P)\nP = np.array([0, 30/np.sin(angle_A) * np.sin(np.pi/2 - angle_A)])\n\n# 図を作成\nfig, ax = plt.subplots(figsize=(6,6))\n\n# 三角形ABCをプロット\nax.plot([A[0], B[0]], [A[1], B[1]], 'bo-', label=\"AB\")\nax.plot([B[0], C[0]], [B[1], C[1]], 'ro-', label=\"BC\")\nax.plot([C[0], A[0]], [C[1], A[1]], 'go-', label=\"CA\")\n\n# 外接円をプロット\ncircle = plt.Circle(circumcenter_point, radius, color='cyan', fill=False, linestyle='dashed', label=\"Circumcircle\")\nax.add_patch(circle)\n\n# 円周角を示す点Pと三角形BPC\nax.plot([B[0], P[0]], [B[1], P[1]], 'purple', linestyle='dotted', label=\"BP\")\nax.plot([C[0], P[0]], [C[1], P[1]], 'purple', linestyle='dotted', label=\"CP\")\n\n# 点のラベル\nax.text(A[0], A[1], '  A', fontsize=12, verticalalignment='bottom')\nax.text(B[0], B[1], '  B', fontsize=12, verticalalignment='top', horizontalalignment='right')\nax.text(C[0], C[1], '  C', fontsize=12, verticalalignment='top', horizontalalignment='left')\nax.text(P[0], P[1], '  P', fontsize=12, verticalalignment='bottom', horizontalalignment='right', color='purple')\nax.scatter(circumcenter_point[0], circumcenter_point[1], color='black')  # 外心O\n\n# グリッドと範囲設定\nax.axhline(0, color='black', linewidth=0.5)\nax.axvline(0, color='black', linewidth=0.5)\nax.grid(True, linestyle='--', alpha=0.6)\nax.set_xlim(-radius-5, BC+radius+5)\nax.set_ylim(-radius-5, radius+AC+5)\nax.legend()\nax.set_title(\"Triangle ABC with Circumcircle and Inscribed Angle\")\n\n# 図を表示\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 2\n\n\n\n\n\n\n\n\nExercise 2 \nとある山へハイキングにいくとします．\n\n山頂をC\n山の麓のA地点から同じ標高で直線距離で1000m離れている地点をB\nA地点からCを見たときの仰角は \\(30^\\circ\\)\n\\(\\triangle ABC\\) について，\\(\\angle CAB = 75^\\circ, \\angle ABC = 45^\\circ\\)\n\nということがわかっているとします．このとき，Cの標高を求めよ．なお，\\(A, B\\) の標高は 0m とする．\n\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.mplot3d.art3d import Poly3DCollection\n\n# Given angles and side lengths\nangle_A = np.radians(75)\nangle_B = np.radians(45)\nAB = 1000  # Given\n\n# Compute angle C\nangle_C = np.radians(180 - 75 - 45)  # C = 60 degrees\n\n# Compute sides using the Law of Sines\nBC = AB * np.sin(angle_A) / np.sin(angle_C)\nAC = AB * np.sin(angle_B) / np.sin(angle_C)\n\n# Compute coordinates of A, B, and C\nA = np.array([0, 0, 0])  # A is the origin\nB = np.array([AB, 0, 0])  # B is along the x-axis\nC_x = 0  # Projection of AC on x-axis\nC_y = AC * np.cos(np.radians(30))\nC_z = AC * np.sin(np.radians(30))  # Projection on y-axis\nC = np.array([0, C_y, C_z])  # C remains in the XY plane\n\n# Triangle ACH: Given CAH = 30°, CHA = 90° (Right Triangle)\nangle_CAH = np.radians(30)\n\n# H's coordinates (directly above C in the Z direction)\nH = np.array([0, C_y, 0])\n\n# Create 3D plot\nfig = plt.figure(figsize=(8, 8))\nax = fig.add_subplot(111, projection='3d')\n\n# Plot edges of tetrahedron\nedges = [\n    (A, B), (B, C), (C, A),  # Triangle ABC\n    (A, H), (C, H), (B, H)   # Connecting H to A, C, and B\n]\n\nfor edge in edges:\n    ax.plot(*zip(*edge), 'k-')\n\n# Define faces for tetrahedron visualization\nfaces = [\n    [A, B, C],  # Base ABC\n    [A, C, H],  # Side ACH\n    [C, B, H],  # Side CBH\n    [A, H, B]   # Side AHB\n]\n\n# Add face shading\nax.add_collection3d(Poly3DCollection(faces, alpha=0.3, color='cyan'))\n\n# Annotate points\nax.text(*A, \" A\", color='black', fontsize=12)\nax.text(*B, \" B\", color='black', fontsize=12)\nax.text(*C, \" C\", color='black', fontsize=12)\nax.text(*H, \" H\", color='black', fontsize=12)\n\n# Labels and grid\nax.set_xlabel(\"X-axis\")\nax.set_ylabel(\"Y-axis\")\nax.set_zlabel(\"Z-axis\")\nax.set_title(\"3D Tetrahedron CAHB\")\nax.grid(True)\n\nax.view_init(elev=20, azim=-55) \n\n# Show the plot\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 3\n\n\n\n\n\n\n\n\n\n\nNoteSolution\n\n\n\n\n\n上の図のようにCから\\(XY\\)平面に垂線を下ろして，XY平面との交点を \\(H\\) としたとき，今回求めたい長さは \\(CH\\)．\n問題文の情報を用いて正弦定理を利用すると\n\\[\n\\displaystyle AC = \\frac{AB}{\\sin (\\angle ACB)} \\cdot \\sin(\\angle ABC)\n\\]\nここで\n\\[\n\\begin{align}\nCH &= AC \\cdot \\sin(\\angle CAH)\\\\\n    &= \\frac{AB}{\\sin (\\angle ACB)} \\cdot \\sin(\\angle ABC) \\cdot \\sin(\\angle CAH)\n\\end{align}\n\\]\n従って，\n\n\nCode\nprint(f\"CH = {C_z:.2f}\")\n\n\nCH = 408.25"
  },
  {
    "objectID": "posts/2025-06-27-ubuntu-snap-assistant/index.html",
    "href": "posts/2025-06-27-ubuntu-snap-assistant/index.html",
    "title": "Windowsライクなスナップ機能をUbuntuで使う",
    "section": "",
    "text": "デスクトップ上でウィンドウを簡単に配置できるようにする\n左右半分，上下半分という配置をキーボードショートカットで操作可能にする"
  },
  {
    "objectID": "posts/2025-06-27-ubuntu-snap-assistant/index.html#goal",
    "href": "posts/2025-06-27-ubuntu-snap-assistant/index.html#goal",
    "title": "Windowsライクなスナップ機能をUbuntuで使う",
    "section": "",
    "text": "デスクトップ上でウィンドウを簡単に配置できるようにする\n左右半分，上下半分という配置をキーボードショートカットで操作可能にする"
  },
  {
    "objectID": "posts/2025-06-27-ubuntu-snap-assistant/index.html#拡張機能-tilting-assistantのインストール",
    "href": "posts/2025-06-27-ubuntu-snap-assistant/index.html#拡張機能-tilting-assistantのインストール",
    "title": "Windowsライクなスナップ機能をUbuntuで使う",
    "section": "✅ 拡張機能 Tilting Assistantのインストール",
    "text": "✅ 拡張機能 Tilting Assistantのインストール\n\nsudo apt install gnome-shell-extension-manager でextension managerをインストールする\nFirefoxでGnome Extensions &gt; Tiling Assistantを開き，インストールする"
  },
  {
    "objectID": "posts/2025-06-27-ubuntu-snap-assistant/index.html#設定",
    "href": "posts/2025-06-27-ubuntu-snap-assistant/index.html#設定",
    "title": "Windowsライクなスナップ機能をUbuntuで使う",
    "section": "🔨 設定",
    "text": "🔨 設定\n挙動一般\n\nデフォルトではTilingした直後にアプリ一覧(Tiling Popup)が空きスペースに表示されるが，その機能をOffにする\n\n\nコマンド操作\n\n\n\n\nコマンド\n挙動\n\n\n\n\nSuper + Up\nWindowをモニターの上半分に移動するToggle\n\n\nSuper + Down\nWindowをモニターの下半分に移動するToggle\n\n\nSuper + Left\nWindowをモニターの左半分に移動するToggle\n\n\nSuper + Right\nWindowをモニターの右半分に移動するToggle\n\n\nSuper + F11\nWindowを最大サイズにするToggle\n\n\n\n\n\n設定実装\n\nExtension ManageをDesktop環境から開く\ntiling assistantを開き以下の画像のような設定にする\n\n\n\n\n\n\n\nGeneral設定\n\n\n\n\n\n\n\nKeybindings設定"
  },
  {
    "objectID": "posts/2025-06-27-ubuntu-snap-assistant/index.html#references",
    "href": "posts/2025-06-27-ubuntu-snap-assistant/index.html#references",
    "title": "Windowsライクなスナップ機能をUbuntuで使う",
    "section": "References",
    "text": "References\n\nTiling-Assistant Repository"
  },
  {
    "objectID": "posts/2025-01-27-differentiation_of_exponential_function/index.html",
    "href": "posts/2025-01-27-differentiation_of_exponential_function/index.html",
    "title": "指数関数の微分",
    "section": "",
    "text": "底 \\(a&gt;1\\) のとき，\n\n指数関数 \\(y = a^x\\) は区間 \\(-\\infty &lt; x &lt; \\infty\\) において連続かつ単調増大で, \\(y \\in (0, \\infty)\\)\n対数関数 \\(y = \\log_a x\\) は \\(y = a^x\\) の逆関数で，区間 \\(0 &lt; x &lt; \\infty\\) において連続かつ単調増大で, \\(y \\in (\\infty, \\infty)\\)\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# PARAMS\nbase = 2\nN = 1000 # data points\nmin_lim = -2\nmax_lim = 5\nx = np.linspace(min_lim, max_lim, N)\n\n# exponential\ny_exp = base ** x\n\n# logarithm\ny_log = np.log(x[x&gt;0]) / np.log(base) \n\n# plot\nfig, ax = plt.subplots(ncols=1)\nax.plot(x, y_exp, label='$ y = a^x$')\nax.plot(x[x&gt;0], y_log, label='$y = \\log_a x$')\nax.plot(x*0.8, x*0.8, label='45 Degree Line', linestyle='--', color='gray')\nax.axhline(0, color='black', linewidth=0.5)\nax.axvline(0, color='black', linewidth=0.5)\nax.set_xlim(min_lim, max_lim)\nax.set_xticks([])\nax.set_yticks([])\nax.text(0, 0, 'O', fontsize=12, ha='right')\nax.text(1, -0.5, '1', fontsize=12, ha='right')\nax.text(0, 1, '1', fontsize=12, ha='right')\nax.set_ylim(min_lim, max_lim)\nax.set_xlabel('$x$')\nax.set_ylabel('$y$')\nfor spine in ax.spines.values():\n    spine.set_visible(False)\nax.legend()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 1: 指数関数と対数関数\n\n\n\n\n\nTheorem 1 \n任意の \\(a &gt; 0\\) に対して，\\(y = a^x\\) の導関数は\n\\[\n\\frac{d(a^x)}{dx} = a^x\\log a\n\\]\n\n\n\n\n\n\n\n\n\nNoteProof\n\n\n\n\n\n\\(a &gt; 1\\) のケースを考える\n\\[\n\\begin{align}\n\\frac{d(a^x)}{dx}\n    &= \\lim_{h\\to 0}\\frac{a^{x+h} - a^x}{h}\\\\\n    &= a^x\\lim_{h\\to 0}\\frac{a^{h} - 1}{h}\\label{base-eq}\n\\end{align}\n\\]\n ▶  \\(h &gt; 0\\)の場合\n\\(h &gt; 0\\) であるならば，\\(a^h &gt; 1\\)．よって\n\\[\na^h = 1 + \\frac{1}{t}\n\\]\nとおくと，\\(t &gt; 0\\)．指数関数の連続性より，\\(h\\to 0\\) のとき，\\(a^h\\to 1\\). 従って，\\(t\\to\\infty\\)．\nここで，\\(\\displaystyle h = \\log_a\\left(1 + \\frac{1}{t}\\right)\\) より\n\\[\n\\begin{align}\n\\frac{a^{h} - 1}{h}\n    & = \\frac{1/t}{\\log_a\\left(1 + \\frac{1}{t}\\right)}\\\\\n    &= \\frac{1}{\\log_a\\left(1 + \\frac{1}{t}\\right)^t}\n\\end{align}\n\\]\n\\[\n\\lim_{t\\to\\infty}\\left(1 + \\frac{1}{t}\\right)^t = e\n\\]\n対数関数 \\(\\log_a(x)\\) は連続関数なので，\\(h\\to 0\\) のとき，\\(\\log_a\\left(1 + \\frac{1}{t}\\right)^t\\to \\log_a e\\)．従って，\n\\[\n\\begin{align}\n\\lim_{h\\to 0}\\frac{a^{h} - 1}{h}\n    &= \\frac{1}{\\log_a e}\\\\\n    &= \\log a\n\\end{align}\n\\]\n ▶  \\(h &lt; 0\\)の場合\n\\(h = -z\\) を満たす \\(z&gt;0\\) を考える．このとき，\n\\[\n\\begin{align}\n\\frac{a^h - 1}{h}\n    &= \\frac{a^{-z} - 1}{-z}\\\\\n    &= \\frac{1 - a^z}{-z}\\frac{1}{a^z}\\\\\n    &= \\frac{a^z - 1}{z}\\frac{1}{a^z}\n\\end{align}\n\\]\n\\(z\\to 0\\) のとき，\\(a^z \\to 1\\) なので\n\\[\n\\frac{a^h - 1}{h}\\to \\log a\n\\]\n従って，\\(a &gt; 1\\) のとき，\\(\\displaystyle \\frac{d(a^x)}{dx} = a^x \\log a\\)\n ▶  \\(0 &lt; a &lt; 1\\) の場合 \n\\(\\eqref{base-eq}\\) と展開したとき，\\(h&gt;0\\) のとき \\(a^h &lt; 1\\) となるので\n\\[\na^h = 1 - \\frac{1}{t}\\qquad(t&gt;0)\n\\]\n指数関数の連続性より, \\(h\\to 0\\) のとき，\\(a^h\\to 0\\)，従って，\\(t\\to\\infty\\)．\n\\[\n\\begin{align}\n\\frac{a^h-1}{h}\n    &= \\frac{-\\frac{1}{t}}{\\log_a(1 - \\frac{1}{t})}\\\\\n    &= -\\frac{1}{\\log_a(1 - \\frac{1}{t})^{t}}\n\\end{align}\n\\]\nここで\n\\[\n\\lim_{t\\to\\infty} (1 - \\frac{1}{t})^{t} = \\frac{1}{e}\n\\]\nであるので，対数関数の連続性より，\\(h\\to 0\\) のとき \\(h\\to\\infty\\) だから\n\\[\n\\log_a\\left(1 - \\frac{1}{t}\\right)^{t}\\to \\log_a\\frac{1}{e} = -\\log_a e\n\\]\n従って，\n\\[\n\\lim_{h\\to 0}\\frac{a^h-1}{h} = \\log a\n\\]\n\\(h&lt;0\\) の場合も同様に示せるので，以上より\n任意の \\(a &gt; 0\\) に対して，\\(y = a^x\\) の導関数は\n\\[\n\\frac{d(a^x)}{dx} = a^x\\log a\n\\]\nが成立する．\n\n\n\n\n\n\\(a &gt; 0\\) としたとき，\n\\[\n\\log a^x = x\\log a\n\\]\nこのとき，両辺を \\(x\\) で微分すると\n\\[\n\\frac{D(a^x)}{a^x} = \\log a\n\\]\n従って，\n\\[\nD(a^x) = a^x\\log a\n\\]\nを得る．"
  },
  {
    "objectID": "posts/2025-01-27-differentiation_of_exponential_function/index.html#指数関数の微分",
    "href": "posts/2025-01-27-differentiation_of_exponential_function/index.html#指数関数の微分",
    "title": "指数関数の微分",
    "section": "",
    "text": "底 \\(a&gt;1\\) のとき，\n\n指数関数 \\(y = a^x\\) は区間 \\(-\\infty &lt; x &lt; \\infty\\) において連続かつ単調増大で, \\(y \\in (0, \\infty)\\)\n対数関数 \\(y = \\log_a x\\) は \\(y = a^x\\) の逆関数で，区間 \\(0 &lt; x &lt; \\infty\\) において連続かつ単調増大で, \\(y \\in (\\infty, \\infty)\\)\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# PARAMS\nbase = 2\nN = 1000 # data points\nmin_lim = -2\nmax_lim = 5\nx = np.linspace(min_lim, max_lim, N)\n\n# exponential\ny_exp = base ** x\n\n# logarithm\ny_log = np.log(x[x&gt;0]) / np.log(base) \n\n# plot\nfig, ax = plt.subplots(ncols=1)\nax.plot(x, y_exp, label='$ y = a^x$')\nax.plot(x[x&gt;0], y_log, label='$y = \\log_a x$')\nax.plot(x*0.8, x*0.8, label='45 Degree Line', linestyle='--', color='gray')\nax.axhline(0, color='black', linewidth=0.5)\nax.axvline(0, color='black', linewidth=0.5)\nax.set_xlim(min_lim, max_lim)\nax.set_xticks([])\nax.set_yticks([])\nax.text(0, 0, 'O', fontsize=12, ha='right')\nax.text(1, -0.5, '1', fontsize=12, ha='right')\nax.text(0, 1, '1', fontsize=12, ha='right')\nax.set_ylim(min_lim, max_lim)\nax.set_xlabel('$x$')\nax.set_ylabel('$y$')\nfor spine in ax.spines.values():\n    spine.set_visible(False)\nax.legend()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 1: 指数関数と対数関数\n\n\n\n\n\nTheorem 1 \n任意の \\(a &gt; 0\\) に対して，\\(y = a^x\\) の導関数は\n\\[\n\\frac{d(a^x)}{dx} = a^x\\log a\n\\]\n\n\n\n\n\n\n\n\n\nNoteProof\n\n\n\n\n\n\\(a &gt; 1\\) のケースを考える\n\\[\n\\begin{align}\n\\frac{d(a^x)}{dx}\n    &= \\lim_{h\\to 0}\\frac{a^{x+h} - a^x}{h}\\\\\n    &= a^x\\lim_{h\\to 0}\\frac{a^{h} - 1}{h}\\label{base-eq}\n\\end{align}\n\\]\n ▶  \\(h &gt; 0\\)の場合\n\\(h &gt; 0\\) であるならば，\\(a^h &gt; 1\\)．よって\n\\[\na^h = 1 + \\frac{1}{t}\n\\]\nとおくと，\\(t &gt; 0\\)．指数関数の連続性より，\\(h\\to 0\\) のとき，\\(a^h\\to 1\\). 従って，\\(t\\to\\infty\\)．\nここで，\\(\\displaystyle h = \\log_a\\left(1 + \\frac{1}{t}\\right)\\) より\n\\[\n\\begin{align}\n\\frac{a^{h} - 1}{h}\n    & = \\frac{1/t}{\\log_a\\left(1 + \\frac{1}{t}\\right)}\\\\\n    &= \\frac{1}{\\log_a\\left(1 + \\frac{1}{t}\\right)^t}\n\\end{align}\n\\]\n\\[\n\\lim_{t\\to\\infty}\\left(1 + \\frac{1}{t}\\right)^t = e\n\\]\n対数関数 \\(\\log_a(x)\\) は連続関数なので，\\(h\\to 0\\) のとき，\\(\\log_a\\left(1 + \\frac{1}{t}\\right)^t\\to \\log_a e\\)．従って，\n\\[\n\\begin{align}\n\\lim_{h\\to 0}\\frac{a^{h} - 1}{h}\n    &= \\frac{1}{\\log_a e}\\\\\n    &= \\log a\n\\end{align}\n\\]\n ▶  \\(h &lt; 0\\)の場合\n\\(h = -z\\) を満たす \\(z&gt;0\\) を考える．このとき，\n\\[\n\\begin{align}\n\\frac{a^h - 1}{h}\n    &= \\frac{a^{-z} - 1}{-z}\\\\\n    &= \\frac{1 - a^z}{-z}\\frac{1}{a^z}\\\\\n    &= \\frac{a^z - 1}{z}\\frac{1}{a^z}\n\\end{align}\n\\]\n\\(z\\to 0\\) のとき，\\(a^z \\to 1\\) なので\n\\[\n\\frac{a^h - 1}{h}\\to \\log a\n\\]\n従って，\\(a &gt; 1\\) のとき，\\(\\displaystyle \\frac{d(a^x)}{dx} = a^x \\log a\\)\n ▶  \\(0 &lt; a &lt; 1\\) の場合 \n\\(\\eqref{base-eq}\\) と展開したとき，\\(h&gt;0\\) のとき \\(a^h &lt; 1\\) となるので\n\\[\na^h = 1 - \\frac{1}{t}\\qquad(t&gt;0)\n\\]\n指数関数の連続性より, \\(h\\to 0\\) のとき，\\(a^h\\to 0\\)，従って，\\(t\\to\\infty\\)．\n\\[\n\\begin{align}\n\\frac{a^h-1}{h}\n    &= \\frac{-\\frac{1}{t}}{\\log_a(1 - \\frac{1}{t})}\\\\\n    &= -\\frac{1}{\\log_a(1 - \\frac{1}{t})^{t}}\n\\end{align}\n\\]\nここで\n\\[\n\\lim_{t\\to\\infty} (1 - \\frac{1}{t})^{t} = \\frac{1}{e}\n\\]\nであるので，対数関数の連続性より，\\(h\\to 0\\) のとき \\(h\\to\\infty\\) だから\n\\[\n\\log_a\\left(1 - \\frac{1}{t}\\right)^{t}\\to \\log_a\\frac{1}{e} = -\\log_a e\n\\]\n従って，\n\\[\n\\lim_{h\\to 0}\\frac{a^h-1}{h} = \\log a\n\\]\n\\(h&lt;0\\) の場合も同様に示せるので，以上より\n任意の \\(a &gt; 0\\) に対して，\\(y = a^x\\) の導関数は\n\\[\n\\frac{d(a^x)}{dx} = a^x\\log a\n\\]\nが成立する．\n\n\n\n\n\n\\(a &gt; 0\\) としたとき，\n\\[\n\\log a^x = x\\log a\n\\]\nこのとき，両辺を \\(x\\) で微分すると\n\\[\n\\frac{D(a^x)}{a^x} = \\log a\n\\]\n従って，\n\\[\nD(a^x) = a^x\\log a\n\\]\nを得る．"
  },
  {
    "objectID": "posts/2024-12-07-meta-address/index.html",
    "href": "posts/2024-12-07-meta-address/index.html",
    "title": "IPアドレス 0.0.0.0",
    "section": "",
    "text": "pythonでhttp serverを立てて，Quartoで作成したウェブサイトを以下のコマンドで公開するとします\n% python -m http.server 3000 --directory ./_site/\nServing HTTP on 0.0.0.0 port 3000 (http://0.0.0.0:3000/) ..\nバインド先を設定せずにserverを立ち上げたところ，0.0.0.0 で立ち上げているようです． このとき，Firewallの3000 portをホスト側でAllowすると，同じnetworkの他の端末(例:iPad)からでもアクセスできるようになりました．\n ▶  プライベートIPアドレスをバインド先に指定した場合 \n自宅内のネットワークのみで有効なプライベートIPアドレス（クラスC 192.168.0.0 ~ 192.168.255.255）を指定してhttp serverを立たてみます．\n% python -m http.server 3000 --directory ./_site/ --bind 192.168.10.105\nServing HTTP on 192.168.10.105 port 3000 (http://192.168.10.105:3000/) ...\nこのとき，同じネットワーク内にあるiPadからアクセスできるようになりました． iPad側では http://192.168.10.105:3000 に接続することでQuarto contentsにアクセスできるようになりましたが， このiPad側での操作は 0.0.0.0 で立ち上げたときと同じ操作となります．\n\n❓ Question \npython http.server を使用して 0.0.0.0 にバインドしてhttp serverを立てたときの挙動がプライベートネットワーク内部で割り当てられたプライベートIPアドレスを指定したときと同じ挙動をするのか？\n\n\n\nIPv4において 0.0.0.0 (IPv6では::/0) はSepcial-Purpose Address Registry，つまり特別な目的用に予約されたアドレスです．\n\nRFC6890\n\n\n\n\n\n\nAttribute\nValue\n\n\n\n\nAddress Block\n0.0.0.0/8\n\n\nName\nThis host on this network\n\n\nRFC\n[RFC1122], Section 3.2.1.3\n\n\nAllocation Date\nSeptember 1981\n\n\nTermination Date\nN/A\n\n\nSource\nTrue\n\n\nDestination\nFalse\n\n\nForwardable\nFalse\n\n\nGlobal\nFalse\n\n\nReserved-by-Protocol\nTrue\n\n\n\n上記より0.0.0.0 ~ 0.255.255.255について以下の情報を得ることができます\n\nGlobalセクションがFalseとなっていることから，グローバルIPアドレスとして使用できない．利用はローカルネットワークに限定される\nSourceセクションTrueより，送信元アドレスとして有効\nDestinationセクションFalseより，宛先アドレスとして使用できない = ルーティング不可\n\nただし，0.0.0.0の具体的な意味はここからではまだわかりません．\n ▶  0.0.0.0/0 vs 0.0.0.0/32 \n\n\n\n\n\n\n\n\nAttribute\n0.0.0.0/0\n0.0.0.0/32\n\n\n\n\nSubnet Mask\n0.0.0.0 (all bits variable)\n255.255.255.255 (all bits fixed)\n\n\nRange\nAll IPv4 addresses (0.0.0.0 to 255.255.255.255)\n0.0.0.0\n\n\n\n\n\n\nバインド先を指定しないでhttp serverを立てるとき，バインド先を指定しない = 有効な宛先がないことを意味します． このとき使用されるのが 0.0.0.0 です．\nこの文脈での 0.0.0.0 は catch-all wildcard と呼ばれるもので，同じネットワーク上のすべてのインターフェースに対して， バインドするという特別な意味を持っています．コンピューターが複数のネットワークに接続していて，すべてのネットワークにバインドしたい場合に 0.0.0.0を指定します．ただし，不必要に使用してしまうと誤って外部のネットワークに共有してしまったりするので使用は控えたほうが良いです．\n\n📘 REMARKS \n\nPython HTTP Serverにおける 0.0.0.0 はルーティングにおけるデフォルトルートとしての0.0.0.0は異なります\n文脈に応じて 0.0.0.0 が指す内容が異なることに注意してください\npython hhtp.serverの文脈では0.0.0.0にバインドすると以下のインターフェースからアクセス可能となります\n\nLocalhost (127.0.0.1)\nThe private network (例: 192.168.x.x)\nPublic network interfaces (Firewallでアクセスを許容していた場合)\n\n\n\nPython http serverをprivate networkに限定する意図を込めて，以下のスクリプトでホスティングすることが望ましいです\n$ python3 -m http.server -b &lt;your-local-private-network IP&gt; 8080 --directory ./_site/"
  },
  {
    "objectID": "posts/2024-12-07-meta-address/index.html#ipアドレス-0.0.0.0にバインド",
    "href": "posts/2024-12-07-meta-address/index.html#ipアドレス-0.0.0.0にバインド",
    "title": "IPアドレス 0.0.0.0",
    "section": "",
    "text": "pythonでhttp serverを立てて，Quartoで作成したウェブサイトを以下のコマンドで公開するとします\n% python -m http.server 3000 --directory ./_site/\nServing HTTP on 0.0.0.0 port 3000 (http://0.0.0.0:3000/) ..\nバインド先を設定せずにserverを立ち上げたところ，0.0.0.0 で立ち上げているようです． このとき，Firewallの3000 portをホスト側でAllowすると，同じnetworkの他の端末(例:iPad)からでもアクセスできるようになりました．\n ▶  プライベートIPアドレスをバインド先に指定した場合 \n自宅内のネットワークのみで有効なプライベートIPアドレス（クラスC 192.168.0.0 ~ 192.168.255.255）を指定してhttp serverを立たてみます．\n% python -m http.server 3000 --directory ./_site/ --bind 192.168.10.105\nServing HTTP on 192.168.10.105 port 3000 (http://192.168.10.105:3000/) ...\nこのとき，同じネットワーク内にあるiPadからアクセスできるようになりました． iPad側では http://192.168.10.105:3000 に接続することでQuarto contentsにアクセスできるようになりましたが， このiPad側での操作は 0.0.0.0 で立ち上げたときと同じ操作となります．\n\n❓ Question \npython http.server を使用して 0.0.0.0 にバインドしてhttp serverを立てたときの挙動がプライベートネットワーク内部で割り当てられたプライベートIPアドレスを指定したときと同じ挙動をするのか？\n\n\n\nIPv4において 0.0.0.0 (IPv6では::/0) はSepcial-Purpose Address Registry，つまり特別な目的用に予約されたアドレスです．\n\nRFC6890\n\n\n\n\n\n\nAttribute\nValue\n\n\n\n\nAddress Block\n0.0.0.0/8\n\n\nName\nThis host on this network\n\n\nRFC\n[RFC1122], Section 3.2.1.3\n\n\nAllocation Date\nSeptember 1981\n\n\nTermination Date\nN/A\n\n\nSource\nTrue\n\n\nDestination\nFalse\n\n\nForwardable\nFalse\n\n\nGlobal\nFalse\n\n\nReserved-by-Protocol\nTrue\n\n\n\n上記より0.0.0.0 ~ 0.255.255.255について以下の情報を得ることができます\n\nGlobalセクションがFalseとなっていることから，グローバルIPアドレスとして使用できない．利用はローカルネットワークに限定される\nSourceセクションTrueより，送信元アドレスとして有効\nDestinationセクションFalseより，宛先アドレスとして使用できない = ルーティング不可\n\nただし，0.0.0.0の具体的な意味はここからではまだわかりません．\n ▶  0.0.0.0/0 vs 0.0.0.0/32 \n\n\n\n\n\n\n\n\nAttribute\n0.0.0.0/0\n0.0.0.0/32\n\n\n\n\nSubnet Mask\n0.0.0.0 (all bits variable)\n255.255.255.255 (all bits fixed)\n\n\nRange\nAll IPv4 addresses (0.0.0.0 to 255.255.255.255)\n0.0.0.0\n\n\n\n\n\n\nバインド先を指定しないでhttp serverを立てるとき，バインド先を指定しない = 有効な宛先がないことを意味します． このとき使用されるのが 0.0.0.0 です．\nこの文脈での 0.0.0.0 は catch-all wildcard と呼ばれるもので，同じネットワーク上のすべてのインターフェースに対して， バインドするという特別な意味を持っています．コンピューターが複数のネットワークに接続していて，すべてのネットワークにバインドしたい場合に 0.0.0.0を指定します．ただし，不必要に使用してしまうと誤って外部のネットワークに共有してしまったりするので使用は控えたほうが良いです．\n\n📘 REMARKS \n\nPython HTTP Serverにおける 0.0.0.0 はルーティングにおけるデフォルトルートとしての0.0.0.0は異なります\n文脈に応じて 0.0.0.0 が指す内容が異なることに注意してください\npython hhtp.serverの文脈では0.0.0.0にバインドすると以下のインターフェースからアクセス可能となります\n\nLocalhost (127.0.0.1)\nThe private network (例: 192.168.x.x)\nPublic network interfaces (Firewallでアクセスを許容していた場合)\n\n\n\nPython http serverをprivate networkに限定する意図を込めて，以下のスクリプトでホスティングすることが望ましいです\n$ python3 -m http.server -b &lt;your-local-private-network IP&gt; 8080 --directory ./_site/"
  },
  {
    "objectID": "posts/2024-12-07-meta-address/index.html#references",
    "href": "posts/2024-12-07-meta-address/index.html#references",
    "title": "IPアドレス 0.0.0.0",
    "section": "References",
    "text": "References\n\nRFC5735"
  },
  {
    "objectID": "posts/2025-06-14-pressure-enthalpy-chart/index.html",
    "href": "posts/2025-06-14-pressure-enthalpy-chart/index.html",
    "title": "PH線図: pressure-enthalpy chart",
    "section": "",
    "text": "PH線図（圧力－比エンタルピー線図）は，縦軸に圧力ｐ，横軸に比エンタルピーｈをとり， 実用上の便利さから縦軸は圧力の対数で目盛られています． 比エンタルピーは直接測定することは困難ですが，圧力と温度は測定することができるので，それらの値からPH線図をベースに比エンタルピーを計算し，冷媒の状態を把握します．\n\n\n\n\n\n\n\n\n\n用語\n意味\n図での位置\n\n\n\n\n飽和液線\n液体が蒸発を始める境界．この線の左側は「液体（サブクール液）」領域\n湿り蒸気領域の左端（青線）\n\n\n飽和蒸気線\n蒸気が凝縮を始める境界．この線の右側は「過熱蒸気（superheated vapor）」領域\n湿り蒸気領域の右端（オレンジ線）\n\n\n二相領域\n液体と蒸気が共存（沸騰 or 凝縮中）\n飽和液線と蒸気線の間\n\n\n\n\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom CoolProp.CoolProp import PropsSI  # ← インストール後に import\n\nfluid = \"R410A\"  # 任意の冷媒に変更可\npa_converter = 10**6\n\n\n# Saturation curve\nT_min = PropsSI(\"Ttriple\", fluid) + 1.0  # [K]\nT_crit = PropsSI(\"Tcrit\", fluid)  # [K]\nT_sat = np.linspace(T_min, T_crit - 1e-5, 200)\n\np_sat = PropsSI(\"P\", \"T\", T_sat, \"Q\", 0, fluid)\nh_liq = PropsSI(\"H\", \"T\", T_sat, \"Q\", 0, fluid) / 1000  # [kJ/kg]\nh_vap = PropsSI(\"H\", \"T\", T_sat, \"Q\", 1, fluid) / 1000  # [kJ/kg]\n\nplt.figure(figsize=(8, 6))\nplt.plot(h_liq, p_sat / pa_converter, label=\"Saturated Liquid\")\nplt.plot(h_vap, p_sat / pa_converter, label=\"Saturated Vapor\")\n\n# 適当な等温線（任意で）\nfor T_iso in np.linspace(T_crit - 123.5, T_crit + 60, 4):\n    p_iso = np.logspace(np.log10(p_sat.min()), np.log10(p_sat.max()), 150)\n    h_iso = PropsSI(\"H\", \"T\", T_iso, \"P\", p_iso, fluid) / 1000\n    plt.plot(\n        h_iso,\n        p_iso / pa_converter,\n        linestyle=\"--\",\n        label=f\"{T_iso - 273.15:.0f} °C Isotherm\",\n    )\n\nplt.yscale(\"log\")\nplt.xlabel(\"Enthalpy [kJ/kg]\")\nplt.ylabel(\"Pressure [MPa]\")\nplt.title(f\"Pressure–Enthalpy (p-h) Diagram for {fluid}\")\nplt.legend()\nplt.grid(True, which=\"both\", ls=\":\")\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\nFigure 1\n\n\n\n\n\n\n\n飽和蒸気と飽和液が共存している湿り蒸気状態は，温度と圧力の他に，湿り蒸気中の飽和蒸気の質量分率を指定しないと比エンタルピーの位置は定まりません．\n\nDefinition 1 乾き度\n\n湿り蒸気 1kg 中に飽和蒸気が x(kg) 含まれているとき，この湿り蒸気の乾き度は x であるという\n湿り度は，飽和液の質量分率 (1 - x) のことをいう\n\n\n\n\n\n\n\n\n\n\n\n状態\n説明\n乾き度 \\(x\\)\n\n\n\n\n過冷却液\n飽和液体よりも温度が低い状態（液体のみ）\n\\(x = 0\\)\n\n\n飽和液体\n蒸発開始直前の状態\n\\(x = 0\\)\n\n\n混合（液 + 蒸気）\n液体と蒸気が共存する状態（蒸発中），湿り蒸気\n\\(0 &lt; x &lt; 1\\)\n\n\n飽和蒸気\n蒸発終了直後の状態\n\\(x = 1\\)\n\n\n加熱蒸気\n飽和蒸気よりも高温の蒸気（完全に蒸気）\n\\(x = 1\\)\n\n\n\n\n\nCode\n# Define data arrays\nx_values = np.array([0.0, 1.0])\nkawaki_values = [0, 0.2, 1.0]\nh_vap_line = np.zeros_like(x_values)\nTC = -15\nT = TC + 273.15\n\nfor i, x in enumerate(x_values):\n    h_vap_line[i] = PropsSI(\"H\", \"T\", T, \"Q\", x, fluid) / 1000\np_sat_line = PropsSI(\"P\", \"T\", T, \"Q\", 0, fluid)\n\nplt.figure(figsize=(8, 6))\n\nfor i, kawaki in enumerate(kawaki_values):\n    plt.scatter(\n        (1 - kawaki) * h_vap_line[0] + kawaki * h_vap_line[1],\n        p_sat_line / pa_converter,\n        label=f\"h{i}\",\n    )\n\n# 飽和液～飽和蒸気を結ぶ -15 °C 等温線（破線）\nplt.plot([h_vap_line[0], h_vap_line[1]], [p_sat_line / pa_converter, p_sat_line / pa_converter],\n         linestyle='--', color='gray', label=f'{TC} °C Isotherm')\n\nplt.plot(h_liq, p_sat / pa_converter, label=\"Saturated Liquid\")\nplt.plot(h_vap, p_sat / pa_converter, label=\"Saturated Vapor\")\nplt.yscale(\"log\")\nplt.xlabel(\"Enthalpy [kJ/kg]\")\nplt.ylabel(\"Pressure [MPa]\")\nplt.legend()\nplt.grid(True, which=\"both\", ls=\":\")\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n\n\\(h_1\\) における乾き度の計算は以下\n\\[\nx = \\frac{h_1 - h_0}{h_2 - h_0}\n\\]\n\n\n\n\n\n\n\nNote熱伝達と粘性係数\n\n\n\n\n冷媒側熱伝達率はプラントル数に依存\nプラントル数は熱伝導に関する無次元の物性値であり，流体の動粘度と熱拡散係数の比です．\n\n\\[\nPr = \\frac{\\mu \\cdot C_p}{\\lambda}\n\\]\n\n\\(Pr\\): プラントル数\n\\(\\mu\\): 粘性係数 [kg/m･s]\n\\(C_p\\): 定圧比熱 [J/kg･K]\n\\(\\lambda\\): 熱伝導率 [W/m･K]\n\nそして粘性係数 \\(\\mu\\) はMcAdamsモデルを用いると\n\\[\n\\frac{1}{\\mu} = \\frac{x}{\\mu_v} + \\frac{1-x}{\\mu_l}\n\\]\n\n\\(x\\): 乾き度\n\\(v\\): ガス相\n\\(l\\): 液相\n\n\n\n\n\n\n加熱蒸気の比体積 \\(v_h\\) [m³/kg] は，加熱蒸気を理想気体と近似できる場合には理想気体の状態方程式より以下のように表すことができます\n\\[\n\\begin{align}\nv_h\n  &= \\frac{v_eT_h}{T_e}\\\\\n  &= v_e\\left(1 + \\frac{\\Delta_h}{T_e}\\right)\n\\end{align}\n\\]\n\n\\(v_e\\): 飽和蒸気線での比体積\n\\(T_h\\): 加熱蒸気の温度\n\\(\\Delta_h\\): 加熱度\n\n\n\n\n\n\n\nNote比体積と圧縮機と冷媒循環量\n\n\n\n系の冷媒循環量 \\(q_m\\) [kg/h] は熱交換量を決定する重要な要素です．そして，\\(q_m\\) は圧縮機の性能と運転条件に依存します． 容積型蒸気圧縮機は，単位時間あたり一定容積のガスを吸い込んで吐き出すものです．理論押しのけ量 \\(V_p\\) [m³/h] は\n\\[\nV_p = V_{st} \\times N_{comp} \\times 3600 \\times 10^{-6}\n\\]\n\n\\(V_{st}\\): ストロークボリューム [cm³]\n\\(N_{comp}\\): 回転 / 秒 = Hz\n\\(V_p\\): 理論ピストン押しのけ量 [m³/h]\n\nこれを質量に変換すると循環流量 \\(q_m\\) になります\n\\[\nq_m = V_p \\times \\frac{1}{v_g}\\times \\eta_v\n\\]\n\n\\(v_g\\): 吸入冷媒ガスの比容積\n\\(1/v_g\\): 密度\n\\(\\eta_v\\): 体積効率 (0.8~0.9程度)\n\n\n\n\n\n\n\nDefinition 2 臨界点(Critical Point)\n\nPH線図の，飽和液体線と飽和蒸気線の高圧・高温側の終点（接合点）を臨界点と呼ぶ\nこの点における圧力を臨界圧力，温度を臨界温度と言う\n臨界点以上では蒸発現象も液化現象もなく，液相と気相の区別はつかなくなって，相変化は存在しない\n\n\n冷凍サイクルでは冷媒ガスの液化（凝縮）の過程を必要とするので，冷媒としては臨界点（臨界温度）は 液化させるための冷却水または冷却空気の温度より著しく高いことが必要となります． Figure 1 の紫色線は臨界温度と同じ等温線を表しています．この温度よりも高い温度では冷媒を液化することはできません．\n\n\nCode\nimport pandas as pd\nref_list = ['R134a', 'R22', 'R410A', 'R717', 'R744']\n\nref_list = ['R134a', 'R22', 'R410A', 'R717', 'R744']\n\nrecords = []\nfor ref in ref_list:\n    T_c = PropsSI('Tcrit', ref)          # [K]\n    P_c = PropsSI('Pcrit', ref) / 1e6    # [MPa]\n    records.append({'Fluid': ref,\n                    'T_crit [K]': T_c,\n                    'T_crit [°C]': T_c - 273.15,\n                    'P_crit [MPa]': P_c})\n\ndf = pd.DataFrame(records)\ndf\n\n\n\n\n\n\n\n\n\n\n\nFluid\nT_crit [K]\nT_crit [°C]\nP_crit [MPa]\n\n\n\n\n0\nR134a\n374.2100\n101.0600\n4.059280\n\n\n1\nR22\n369.2950\n96.1450\n4.990000\n\n\n2\nR410A\n344.4940\n71.3440\n4.901200\n\n\n3\nR717\n405.5600\n132.4100\n11.363391\n\n\n4\nR744\n304.1282\n30.9782\n7.377300\n\n\n\n\n\n\n\nFigure 2: 冷媒の臨界温度と臨界圧力\n\n\n\n\n\n\n\n\nExercise 1 R410AのPH線図作図\n入力条件\n\n\n\n\nパラメータ\n値\n\n\n\n\n蒸発温度 \\(T_{\\text{evap}}\\)\n-15 ℃\n\n\n凝縮温度 \\(T_{\\text{cond}}\\)\n30 ℃\n\n\n過冷却度\n5 ℃\n\n\n過熱度\n5 ℃\n\n\n冷媒\nR410A\n\n\n\n\n\n\n\n\n\n\n\nNoteSolution\n\n\n\n\n\n\n\nCode\nimport CoolProp.CoolProp as CP\n\nfluid = \"R22\"\n\n# 温度設定（すべて [K] に変換）\nT_evap = -15 + 273.15  # 蒸発温度\nT_cond = 30 + 273.15  # 凝縮温度\ndT_subcool = 5  # 過冷却\ndT_superheat = 5  # 過熱\n\n# 飽和圧力（蒸発器側と凝縮器側）\nP_evap = CP.PropsSI(\n    \"P\", \"T\", T_evap, \"Q\", 1, fluid\n)  # 温度 T_evap で品質（乾き度）Q = 1 のとき(=飽和蒸気)の圧力 P\nP_cond = CP.PropsSI(\n    \"P\", \"T\", T_cond, \"Q\", 0, fluid\n)  # 温度 T_cond で品質（乾き度）Q = 0 のときの圧力 P\n\n# 状態1: 蒸発器出口（過熱蒸気）\nT1 = T_evap + dT_superheat\nh1 = CP.PropsSI(\"H\", \"T\", T1, \"P\", P_evap, fluid)\ns1 = CP.PropsSI(\"S\", \"T\", T1, \"P\", P_evap, fluid)\n\n# 状態2: 圧縮機出口（断熱圧縮）\nh2 = CP.PropsSI(\"H\", \"P\", P_cond, \"S\", s1, fluid)\nT2 = CP.PropsSI(\"T\", \"P\", P_cond, \"H\", h2, fluid)\n\n# ========= 等エントロピー線を生成 =========\n# 入口圧～出口圧まで対数刻みでサンプリング\nP_line = np.logspace(np.log10(P_evap), np.log10(P_cond), 200)  # [Pa]\nh_line = CP.PropsSI(\"H\", \"P\", P_line, \"S\", s1, fluid)  # [J/kg]\n\n# 状態3: 凝縮器出口（過冷却液）\nT3 = T_cond - dT_subcool\nh3 = CP.PropsSI(\"H\", \"T\", T3, \"P\", P_cond, fluid)\n\n# 状態4: 膨張弁出口（等エンタルピー膨張）\nh4 = h3\nT4 = CP.PropsSI(\"T\", \"P\", P_evap, \"H\", h4, fluid)\n\n# 冷凍能力（1 kgあたり）\nq_in = h1 - h4  # 蒸発器での吸熱\nw_in = h2 - h1  # 圧縮機の仕事\nq_out = h2 - h3  # 凝縮器での放熱\nCOP = q_in / w_in  # 成績係数\n\n# 結果表示\nprint(\"=== 冷凍サイクル各点の状態（単位: SI） ===\")\nprint(f\"状態1（過熱蒸気）: T={T1 - 273.15:.2f}°C, h={h1 / 1000:.2f} kJ/kg\")\nprint(f\"状態2（圧縮後）  : T={T2 - 273.15:.2f}°C, h={h2 / 1000:.2f} kJ/kg\")\nprint(f\"状態3（過冷却液）: T={T3 - 273.15:.2f}°C, h={h3 / 1000:.2f} kJ/kg\")\nprint(f\"状態4（膨張後）  : T={T4 - 273.15:.2f}°C, h={h4 / 1000:.2f} kJ/kg\")\n\nprint(\"\\n=== 性能指標 ===\")\nprint(f\"冷凍能力 q_in   : {q_in / 1000:.2f} kJ/kg\")\nprint(f\"圧縮機仕事 w_in : {w_in / 1000:.2f} kJ/kg\")\nprint(f\"COP (成績係数)  : {COP:.2f}\")\n\n# plot\nh_points = [h2 / 1e3, h3 / 1e3, h4 / 1e3, h1 / 1e3]\nP_points = [P_cond / 1e6, P_cond / 1e6, P_evap / 1e6, P_evap / 1e6]\n\nplt.figure(figsize=(8, 6))\nplt.plot(\n    h_points,\n    P_points,\n    marker=\"o\",\n    linestyle=\"-\",\n    color=\"blue\",\n    label=\"refrigeration cycle\",\n)\n\n# Add labels at each point\nfor i, (h, P) in enumerate(zip(h_points, P_points), start=1):\n    plt.text(\n        h + 1, P + 0.02, f\"{(i % 4) + 1}\", fontsize=12, color=\"black\"\n    )  # adjust offsets as needed\n\nplt.plot(h_line / 1000, P_line / 1e6, linestyle=\"-\", color=\"blue\")\nplt.xlabel(\"h [kJ/kg]\")\nplt.ylabel(\"P [MPa]\")\nplt.grid(True)\n\n# Saturation curve\nT_min = -20 + 273.15\nT_crit = 49 + 273.15  # [K]\nT_sat = np.linspace(T_min, T_crit - 1e-5, 200)\n\np_sat = PropsSI(\"P\", \"T\", T_sat, \"Q\", 0, fluid)\nh_liq = PropsSI(\"H\", \"T\", T_sat, \"Q\", 0, fluid) / 1000  # [kJ/kg]\nh_vap = PropsSI(\"H\", \"T\", T_sat, \"Q\", 1, fluid) / 1000  # [kJ/kg]\n\nplt.plot(h_liq, p_sat / pa_converter, label=\"Saturated Liquid\")\nplt.plot(h_vap, p_sat / pa_converter, label=\"Saturated Vapor\")\n\nplt.yscale(\"log\")\nplt.xlabel(\"Enthalpy [kJ/kg]\")\nplt.ylabel(\"Pressure [MPa]\")\nplt.title(f\"Pressure–Enthalpy (p-h) Diagram for {fluid}\")\nplt.legend()\nplt.grid(True, which=\"both\", ls=\":\")\nplt.tight_layout()\nplt.show()\n\n\n=== 冷凍サイクル各点の状態（単位: SI） ===\n状態1（過熱蒸気）: T=-10.00°C, h=402.57 kJ/kg\n状態2（圧縮後）  : T=58.13°C, h=438.30 kJ/kg\n状態3（過冷却液）: T=25.00°C, h=230.29 kJ/kg\n状態4（膨張後）  : T=-15.00°C, h=230.29 kJ/kg\n\n=== 性能指標 ===\n冷凍能力 q_in   : 172.28 kJ/kg\n圧縮機仕事 w_in : 35.74 kJ/kg\nCOP (成績係数)  : 4.82\n\n\n\n\n\n\n\n\n\n\n\n\n1→2: 断熱変化\n\n蒸発器を出た加熱状態の冷媒蒸気は，圧縮機に吸い込まれて等比エントロピーで可逆断熱圧縮され，高圧で加熱度の大きな加熱蒸気になって吐き出される\n\n2→3: 等圧変化\n\n圧縮機から吐き出された加熱ガスは，凝縮器での冷却作用により，等圧のもとで顕熱を放出して飽和蒸気になる\n凝縮行程が進むに連れ，凝縮の潜熱を放出して湿り蒸気になり，更に冷却されると乾き度がゼロの飽和液になる\nその後，顕熱を放出して過冷却液になる\n\n3→4: 等比エンタルピー変化\n\n膨張弁で絞り膨張される\n\n絞り膨張: 流体が弁部などの狭い通路を通過する際，流れの抵抗により圧力硬化する現象\n\n熱と仕事の出入りがないので比エンタルピーは変化せずに圧力が下がる\n飽和液線を超えると自身の熱エネルギーを蒸発の潜熱として消費し，湿り蒸気となって蒸発器に流入\n\n発生した蒸気をフラッシュ蒸気と呼ぶ\n\n膨張によって冷媒の比エンタルピーは変化しないが，比エントロピーは増大する\n\n4→1: 等圧変化\n\n冷媒は蒸発気に入り，等圧のもとで外部から熱を受け入れる\n冷媒液に潜熱が加えられ，乾き度が大きくなり，飽和蒸気となる\n更に顕熱が加えられ，加熱蒸気になり，圧縮機に吸い込まれる\n\n\n\n\n湿り蒸気領域における等温線は，単一成分冷媒では等圧線と並行ですが，非共沸混合冷媒では右下がりの勾配を持った線になります． 湿り蒸気が加熱（蒸発器内）または冷却（凝縮器内）に伴う相変化によって乾き度が変化すると，湿り蒸気中の飽和蒸気と飽和液のいずれも混合組成割合が 変わるため，等温のもとでは，飽和圧力が変化することによる．\n\n\nCode\nfluid = \"R407C\"  # 任意の冷媒に変更可\npa_converter = 10**6\n\n\ndef linear_interp_inf(x):\n    x = np.array(x)\n    mask = np.isfinite(x)  # finiteなインデックス\n    return np.interp(np.arange(len(x)), np.where(mask)[0], x[mask])\n\n\n# Saturation curve\nT_min = PropsSI(\"Ttriple\", fluid) + 1.0  # [K]\nT_crit = PropsSI(\"Tcrit\", fluid)  # [K]\nT_sat = np.linspace(T_min, T_crit - 1e-5, 200)\n\np_sat = PropsSI(\"P\", \"T\", T_sat, \"Q\", 0, fluid)\nh_liq = PropsSI(\"H\", \"T\", T_sat, \"Q\", 0, fluid) / 1000  # [kJ/kg]\nh_vap = PropsSI(\"H\", \"T\", T_sat, \"Q\", 1, fluid) / 1000  # [kJ/kg]\n\nplt.figure(figsize=(8, 6))\nplt.plot(h_liq, p_sat / pa_converter, label=\"Saturated Liquid\")\nplt.plot(h_vap, p_sat / pa_converter, label=\"Saturated Vapor\")\n\n# 適当な等温線（任意で）\nfor T_iso in np.linspace(T_crit - 123.5, T_crit + 60, 4):\n    p_iso = np.logspace(np.log10(p_sat.min()), np.log10(p_sat.max()), 150)\n    h_iso = PropsSI(\"H\", \"T\", T_iso, \"P\", p_iso, fluid) / 1000\n    h_iso = linear_interp_inf(h_iso)\n    plt.plot(\n        h_iso,\n        p_iso / pa_converter,\n        linestyle=\"-\",\n        label=f\"{T_iso - 273.15:.0f} °C Isotherm\",\n    )\n\nplt.yscale(\"log\")\nplt.xlabel(\"Enthalpy [kJ/kg]\")\nplt.ylabel(\"Pressure [MPa]\")\nplt.title(f\"Pressure–Enthalpy (p-h) Diagram for {fluid}\")\nplt.legend()\nplt.grid(True, which=\"both\", ls=\":\")\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\nFigure 3\n\n\n\n\n\n\nDefinition 3 温度勾配\nある一定の等圧線上の沸点と露点の温度が異なり，露点における温度のほうが沸点における温度よりも高くなっているとき，この等圧線上の沸点と露点との温度差を温度勾配と呼ぶ\n\n\nR404AやR410Aは0.2~0.4Kのオーダー\nR407Cは温度勾配が大きく4.5Kほど"
  },
  {
    "objectID": "posts/2025-06-14-pressure-enthalpy-chart/index.html#ph線図",
    "href": "posts/2025-06-14-pressure-enthalpy-chart/index.html#ph線図",
    "title": "PH線図: pressure-enthalpy chart",
    "section": "",
    "text": "PH線図（圧力－比エンタルピー線図）は，縦軸に圧力ｐ，横軸に比エンタルピーｈをとり， 実用上の便利さから縦軸は圧力の対数で目盛られています． 比エンタルピーは直接測定することは困難ですが，圧力と温度は測定することができるので，それらの値からPH線図をベースに比エンタルピーを計算し，冷媒の状態を把握します．\n\n\n\n\n\n\n\n\n\n用語\n意味\n図での位置\n\n\n\n\n飽和液線\n液体が蒸発を始める境界．この線の左側は「液体（サブクール液）」領域\n湿り蒸気領域の左端（青線）\n\n\n飽和蒸気線\n蒸気が凝縮を始める境界．この線の右側は「過熱蒸気（superheated vapor）」領域\n湿り蒸気領域の右端（オレンジ線）\n\n\n二相領域\n液体と蒸気が共存（沸騰 or 凝縮中）\n飽和液線と蒸気線の間\n\n\n\n\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom CoolProp.CoolProp import PropsSI  # ← インストール後に import\n\nfluid = \"R410A\"  # 任意の冷媒に変更可\npa_converter = 10**6\n\n\n# Saturation curve\nT_min = PropsSI(\"Ttriple\", fluid) + 1.0  # [K]\nT_crit = PropsSI(\"Tcrit\", fluid)  # [K]\nT_sat = np.linspace(T_min, T_crit - 1e-5, 200)\n\np_sat = PropsSI(\"P\", \"T\", T_sat, \"Q\", 0, fluid)\nh_liq = PropsSI(\"H\", \"T\", T_sat, \"Q\", 0, fluid) / 1000  # [kJ/kg]\nh_vap = PropsSI(\"H\", \"T\", T_sat, \"Q\", 1, fluid) / 1000  # [kJ/kg]\n\nplt.figure(figsize=(8, 6))\nplt.plot(h_liq, p_sat / pa_converter, label=\"Saturated Liquid\")\nplt.plot(h_vap, p_sat / pa_converter, label=\"Saturated Vapor\")\n\n# 適当な等温線（任意で）\nfor T_iso in np.linspace(T_crit - 123.5, T_crit + 60, 4):\n    p_iso = np.logspace(np.log10(p_sat.min()), np.log10(p_sat.max()), 150)\n    h_iso = PropsSI(\"H\", \"T\", T_iso, \"P\", p_iso, fluid) / 1000\n    plt.plot(\n        h_iso,\n        p_iso / pa_converter,\n        linestyle=\"--\",\n        label=f\"{T_iso - 273.15:.0f} °C Isotherm\",\n    )\n\nplt.yscale(\"log\")\nplt.xlabel(\"Enthalpy [kJ/kg]\")\nplt.ylabel(\"Pressure [MPa]\")\nplt.title(f\"Pressure–Enthalpy (p-h) Diagram for {fluid}\")\nplt.legend()\nplt.grid(True, which=\"both\", ls=\":\")\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\nFigure 1\n\n\n\n\n\n\n\n飽和蒸気と飽和液が共存している湿り蒸気状態は，温度と圧力の他に，湿り蒸気中の飽和蒸気の質量分率を指定しないと比エンタルピーの位置は定まりません．\n\nDefinition 1 乾き度\n\n湿り蒸気 1kg 中に飽和蒸気が x(kg) 含まれているとき，この湿り蒸気の乾き度は x であるという\n湿り度は，飽和液の質量分率 (1 - x) のことをいう\n\n\n\n\n\n\n\n\n\n\n\n状態\n説明\n乾き度 \\(x\\)\n\n\n\n\n過冷却液\n飽和液体よりも温度が低い状態（液体のみ）\n\\(x = 0\\)\n\n\n飽和液体\n蒸発開始直前の状態\n\\(x = 0\\)\n\n\n混合（液 + 蒸気）\n液体と蒸気が共存する状態（蒸発中），湿り蒸気\n\\(0 &lt; x &lt; 1\\)\n\n\n飽和蒸気\n蒸発終了直後の状態\n\\(x = 1\\)\n\n\n加熱蒸気\n飽和蒸気よりも高温の蒸気（完全に蒸気）\n\\(x = 1\\)\n\n\n\n\n\nCode\n# Define data arrays\nx_values = np.array([0.0, 1.0])\nkawaki_values = [0, 0.2, 1.0]\nh_vap_line = np.zeros_like(x_values)\nTC = -15\nT = TC + 273.15\n\nfor i, x in enumerate(x_values):\n    h_vap_line[i] = PropsSI(\"H\", \"T\", T, \"Q\", x, fluid) / 1000\np_sat_line = PropsSI(\"P\", \"T\", T, \"Q\", 0, fluid)\n\nplt.figure(figsize=(8, 6))\n\nfor i, kawaki in enumerate(kawaki_values):\n    plt.scatter(\n        (1 - kawaki) * h_vap_line[0] + kawaki * h_vap_line[1],\n        p_sat_line / pa_converter,\n        label=f\"h{i}\",\n    )\n\n# 飽和液～飽和蒸気を結ぶ -15 °C 等温線（破線）\nplt.plot([h_vap_line[0], h_vap_line[1]], [p_sat_line / pa_converter, p_sat_line / pa_converter],\n         linestyle='--', color='gray', label=f'{TC} °C Isotherm')\n\nplt.plot(h_liq, p_sat / pa_converter, label=\"Saturated Liquid\")\nplt.plot(h_vap, p_sat / pa_converter, label=\"Saturated Vapor\")\nplt.yscale(\"log\")\nplt.xlabel(\"Enthalpy [kJ/kg]\")\nplt.ylabel(\"Pressure [MPa]\")\nplt.legend()\nplt.grid(True, which=\"both\", ls=\":\")\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n\n\\(h_1\\) における乾き度の計算は以下\n\\[\nx = \\frac{h_1 - h_0}{h_2 - h_0}\n\\]\n\n\n\n\n\n\n\nNote熱伝達と粘性係数\n\n\n\n\n冷媒側熱伝達率はプラントル数に依存\nプラントル数は熱伝導に関する無次元の物性値であり，流体の動粘度と熱拡散係数の比です．\n\n\\[\nPr = \\frac{\\mu \\cdot C_p}{\\lambda}\n\\]\n\n\\(Pr\\): プラントル数\n\\(\\mu\\): 粘性係数 [kg/m･s]\n\\(C_p\\): 定圧比熱 [J/kg･K]\n\\(\\lambda\\): 熱伝導率 [W/m･K]\n\nそして粘性係数 \\(\\mu\\) はMcAdamsモデルを用いると\n\\[\n\\frac{1}{\\mu} = \\frac{x}{\\mu_v} + \\frac{1-x}{\\mu_l}\n\\]\n\n\\(x\\): 乾き度\n\\(v\\): ガス相\n\\(l\\): 液相\n\n\n\n\n\n\n加熱蒸気の比体積 \\(v_h\\) [m³/kg] は，加熱蒸気を理想気体と近似できる場合には理想気体の状態方程式より以下のように表すことができます\n\\[\n\\begin{align}\nv_h\n  &= \\frac{v_eT_h}{T_e}\\\\\n  &= v_e\\left(1 + \\frac{\\Delta_h}{T_e}\\right)\n\\end{align}\n\\]\n\n\\(v_e\\): 飽和蒸気線での比体積\n\\(T_h\\): 加熱蒸気の温度\n\\(\\Delta_h\\): 加熱度\n\n\n\n\n\n\n\nNote比体積と圧縮機と冷媒循環量\n\n\n\n系の冷媒循環量 \\(q_m\\) [kg/h] は熱交換量を決定する重要な要素です．そして，\\(q_m\\) は圧縮機の性能と運転条件に依存します． 容積型蒸気圧縮機は，単位時間あたり一定容積のガスを吸い込んで吐き出すものです．理論押しのけ量 \\(V_p\\) [m³/h] は\n\\[\nV_p = V_{st} \\times N_{comp} \\times 3600 \\times 10^{-6}\n\\]\n\n\\(V_{st}\\): ストロークボリューム [cm³]\n\\(N_{comp}\\): 回転 / 秒 = Hz\n\\(V_p\\): 理論ピストン押しのけ量 [m³/h]\n\nこれを質量に変換すると循環流量 \\(q_m\\) になります\n\\[\nq_m = V_p \\times \\frac{1}{v_g}\\times \\eta_v\n\\]\n\n\\(v_g\\): 吸入冷媒ガスの比容積\n\\(1/v_g\\): 密度\n\\(\\eta_v\\): 体積効率 (0.8~0.9程度)\n\n\n\n\n\n\n\nDefinition 2 臨界点(Critical Point)\n\nPH線図の，飽和液体線と飽和蒸気線の高圧・高温側の終点（接合点）を臨界点と呼ぶ\nこの点における圧力を臨界圧力，温度を臨界温度と言う\n臨界点以上では蒸発現象も液化現象もなく，液相と気相の区別はつかなくなって，相変化は存在しない\n\n\n冷凍サイクルでは冷媒ガスの液化（凝縮）の過程を必要とするので，冷媒としては臨界点（臨界温度）は 液化させるための冷却水または冷却空気の温度より著しく高いことが必要となります． Figure 1 の紫色線は臨界温度と同じ等温線を表しています．この温度よりも高い温度では冷媒を液化することはできません．\n\n\nCode\nimport pandas as pd\nref_list = ['R134a', 'R22', 'R410A', 'R717', 'R744']\n\nref_list = ['R134a', 'R22', 'R410A', 'R717', 'R744']\n\nrecords = []\nfor ref in ref_list:\n    T_c = PropsSI('Tcrit', ref)          # [K]\n    P_c = PropsSI('Pcrit', ref) / 1e6    # [MPa]\n    records.append({'Fluid': ref,\n                    'T_crit [K]': T_c,\n                    'T_crit [°C]': T_c - 273.15,\n                    'P_crit [MPa]': P_c})\n\ndf = pd.DataFrame(records)\ndf\n\n\n\n\n\n\n\n\n\n\n\nFluid\nT_crit [K]\nT_crit [°C]\nP_crit [MPa]\n\n\n\n\n0\nR134a\n374.2100\n101.0600\n4.059280\n\n\n1\nR22\n369.2950\n96.1450\n4.990000\n\n\n2\nR410A\n344.4940\n71.3440\n4.901200\n\n\n3\nR717\n405.5600\n132.4100\n11.363391\n\n\n4\nR744\n304.1282\n30.9782\n7.377300\n\n\n\n\n\n\n\nFigure 2: 冷媒の臨界温度と臨界圧力\n\n\n\n\n\n\n\n\nExercise 1 R410AのPH線図作図\n入力条件\n\n\n\n\nパラメータ\n値\n\n\n\n\n蒸発温度 \\(T_{\\text{evap}}\\)\n-15 ℃\n\n\n凝縮温度 \\(T_{\\text{cond}}\\)\n30 ℃\n\n\n過冷却度\n5 ℃\n\n\n過熱度\n5 ℃\n\n\n冷媒\nR410A\n\n\n\n\n\n\n\n\n\n\n\nNoteSolution\n\n\n\n\n\n\n\nCode\nimport CoolProp.CoolProp as CP\n\nfluid = \"R22\"\n\n# 温度設定（すべて [K] に変換）\nT_evap = -15 + 273.15  # 蒸発温度\nT_cond = 30 + 273.15  # 凝縮温度\ndT_subcool = 5  # 過冷却\ndT_superheat = 5  # 過熱\n\n# 飽和圧力（蒸発器側と凝縮器側）\nP_evap = CP.PropsSI(\n    \"P\", \"T\", T_evap, \"Q\", 1, fluid\n)  # 温度 T_evap で品質（乾き度）Q = 1 のとき(=飽和蒸気)の圧力 P\nP_cond = CP.PropsSI(\n    \"P\", \"T\", T_cond, \"Q\", 0, fluid\n)  # 温度 T_cond で品質（乾き度）Q = 0 のときの圧力 P\n\n# 状態1: 蒸発器出口（過熱蒸気）\nT1 = T_evap + dT_superheat\nh1 = CP.PropsSI(\"H\", \"T\", T1, \"P\", P_evap, fluid)\ns1 = CP.PropsSI(\"S\", \"T\", T1, \"P\", P_evap, fluid)\n\n# 状態2: 圧縮機出口（断熱圧縮）\nh2 = CP.PropsSI(\"H\", \"P\", P_cond, \"S\", s1, fluid)\nT2 = CP.PropsSI(\"T\", \"P\", P_cond, \"H\", h2, fluid)\n\n# ========= 等エントロピー線を生成 =========\n# 入口圧～出口圧まで対数刻みでサンプリング\nP_line = np.logspace(np.log10(P_evap), np.log10(P_cond), 200)  # [Pa]\nh_line = CP.PropsSI(\"H\", \"P\", P_line, \"S\", s1, fluid)  # [J/kg]\n\n# 状態3: 凝縮器出口（過冷却液）\nT3 = T_cond - dT_subcool\nh3 = CP.PropsSI(\"H\", \"T\", T3, \"P\", P_cond, fluid)\n\n# 状態4: 膨張弁出口（等エンタルピー膨張）\nh4 = h3\nT4 = CP.PropsSI(\"T\", \"P\", P_evap, \"H\", h4, fluid)\n\n# 冷凍能力（1 kgあたり）\nq_in = h1 - h4  # 蒸発器での吸熱\nw_in = h2 - h1  # 圧縮機の仕事\nq_out = h2 - h3  # 凝縮器での放熱\nCOP = q_in / w_in  # 成績係数\n\n# 結果表示\nprint(\"=== 冷凍サイクル各点の状態（単位: SI） ===\")\nprint(f\"状態1（過熱蒸気）: T={T1 - 273.15:.2f}°C, h={h1 / 1000:.2f} kJ/kg\")\nprint(f\"状態2（圧縮後）  : T={T2 - 273.15:.2f}°C, h={h2 / 1000:.2f} kJ/kg\")\nprint(f\"状態3（過冷却液）: T={T3 - 273.15:.2f}°C, h={h3 / 1000:.2f} kJ/kg\")\nprint(f\"状態4（膨張後）  : T={T4 - 273.15:.2f}°C, h={h4 / 1000:.2f} kJ/kg\")\n\nprint(\"\\n=== 性能指標 ===\")\nprint(f\"冷凍能力 q_in   : {q_in / 1000:.2f} kJ/kg\")\nprint(f\"圧縮機仕事 w_in : {w_in / 1000:.2f} kJ/kg\")\nprint(f\"COP (成績係数)  : {COP:.2f}\")\n\n# plot\nh_points = [h2 / 1e3, h3 / 1e3, h4 / 1e3, h1 / 1e3]\nP_points = [P_cond / 1e6, P_cond / 1e6, P_evap / 1e6, P_evap / 1e6]\n\nplt.figure(figsize=(8, 6))\nplt.plot(\n    h_points,\n    P_points,\n    marker=\"o\",\n    linestyle=\"-\",\n    color=\"blue\",\n    label=\"refrigeration cycle\",\n)\n\n# Add labels at each point\nfor i, (h, P) in enumerate(zip(h_points, P_points), start=1):\n    plt.text(\n        h + 1, P + 0.02, f\"{(i % 4) + 1}\", fontsize=12, color=\"black\"\n    )  # adjust offsets as needed\n\nplt.plot(h_line / 1000, P_line / 1e6, linestyle=\"-\", color=\"blue\")\nplt.xlabel(\"h [kJ/kg]\")\nplt.ylabel(\"P [MPa]\")\nplt.grid(True)\n\n# Saturation curve\nT_min = -20 + 273.15\nT_crit = 49 + 273.15  # [K]\nT_sat = np.linspace(T_min, T_crit - 1e-5, 200)\n\np_sat = PropsSI(\"P\", \"T\", T_sat, \"Q\", 0, fluid)\nh_liq = PropsSI(\"H\", \"T\", T_sat, \"Q\", 0, fluid) / 1000  # [kJ/kg]\nh_vap = PropsSI(\"H\", \"T\", T_sat, \"Q\", 1, fluid) / 1000  # [kJ/kg]\n\nplt.plot(h_liq, p_sat / pa_converter, label=\"Saturated Liquid\")\nplt.plot(h_vap, p_sat / pa_converter, label=\"Saturated Vapor\")\n\nplt.yscale(\"log\")\nplt.xlabel(\"Enthalpy [kJ/kg]\")\nplt.ylabel(\"Pressure [MPa]\")\nplt.title(f\"Pressure–Enthalpy (p-h) Diagram for {fluid}\")\nplt.legend()\nplt.grid(True, which=\"both\", ls=\":\")\nplt.tight_layout()\nplt.show()\n\n\n=== 冷凍サイクル各点の状態（単位: SI） ===\n状態1（過熱蒸気）: T=-10.00°C, h=402.57 kJ/kg\n状態2（圧縮後）  : T=58.13°C, h=438.30 kJ/kg\n状態3（過冷却液）: T=25.00°C, h=230.29 kJ/kg\n状態4（膨張後）  : T=-15.00°C, h=230.29 kJ/kg\n\n=== 性能指標 ===\n冷凍能力 q_in   : 172.28 kJ/kg\n圧縮機仕事 w_in : 35.74 kJ/kg\nCOP (成績係数)  : 4.82\n\n\n\n\n\n\n\n\n\n\n\n\n1→2: 断熱変化\n\n蒸発器を出た加熱状態の冷媒蒸気は，圧縮機に吸い込まれて等比エントロピーで可逆断熱圧縮され，高圧で加熱度の大きな加熱蒸気になって吐き出される\n\n2→3: 等圧変化\n\n圧縮機から吐き出された加熱ガスは，凝縮器での冷却作用により，等圧のもとで顕熱を放出して飽和蒸気になる\n凝縮行程が進むに連れ，凝縮の潜熱を放出して湿り蒸気になり，更に冷却されると乾き度がゼロの飽和液になる\nその後，顕熱を放出して過冷却液になる\n\n3→4: 等比エンタルピー変化\n\n膨張弁で絞り膨張される\n\n絞り膨張: 流体が弁部などの狭い通路を通過する際，流れの抵抗により圧力硬化する現象\n\n熱と仕事の出入りがないので比エンタルピーは変化せずに圧力が下がる\n飽和液線を超えると自身の熱エネルギーを蒸発の潜熱として消費し，湿り蒸気となって蒸発器に流入\n\n発生した蒸気をフラッシュ蒸気と呼ぶ\n\n膨張によって冷媒の比エンタルピーは変化しないが，比エントロピーは増大する\n\n4→1: 等圧変化\n\n冷媒は蒸発気に入り，等圧のもとで外部から熱を受け入れる\n冷媒液に潜熱が加えられ，乾き度が大きくなり，飽和蒸気となる\n更に顕熱が加えられ，加熱蒸気になり，圧縮機に吸い込まれる\n\n\n\n\n湿り蒸気領域における等温線は，単一成分冷媒では等圧線と並行ですが，非共沸混合冷媒では右下がりの勾配を持った線になります． 湿り蒸気が加熱（蒸発器内）または冷却（凝縮器内）に伴う相変化によって乾き度が変化すると，湿り蒸気中の飽和蒸気と飽和液のいずれも混合組成割合が 変わるため，等温のもとでは，飽和圧力が変化することによる．\n\n\nCode\nfluid = \"R407C\"  # 任意の冷媒に変更可\npa_converter = 10**6\n\n\ndef linear_interp_inf(x):\n    x = np.array(x)\n    mask = np.isfinite(x)  # finiteなインデックス\n    return np.interp(np.arange(len(x)), np.where(mask)[0], x[mask])\n\n\n# Saturation curve\nT_min = PropsSI(\"Ttriple\", fluid) + 1.0  # [K]\nT_crit = PropsSI(\"Tcrit\", fluid)  # [K]\nT_sat = np.linspace(T_min, T_crit - 1e-5, 200)\n\np_sat = PropsSI(\"P\", \"T\", T_sat, \"Q\", 0, fluid)\nh_liq = PropsSI(\"H\", \"T\", T_sat, \"Q\", 0, fluid) / 1000  # [kJ/kg]\nh_vap = PropsSI(\"H\", \"T\", T_sat, \"Q\", 1, fluid) / 1000  # [kJ/kg]\n\nplt.figure(figsize=(8, 6))\nplt.plot(h_liq, p_sat / pa_converter, label=\"Saturated Liquid\")\nplt.plot(h_vap, p_sat / pa_converter, label=\"Saturated Vapor\")\n\n# 適当な等温線（任意で）\nfor T_iso in np.linspace(T_crit - 123.5, T_crit + 60, 4):\n    p_iso = np.logspace(np.log10(p_sat.min()), np.log10(p_sat.max()), 150)\n    h_iso = PropsSI(\"H\", \"T\", T_iso, \"P\", p_iso, fluid) / 1000\n    h_iso = linear_interp_inf(h_iso)\n    plt.plot(\n        h_iso,\n        p_iso / pa_converter,\n        linestyle=\"-\",\n        label=f\"{T_iso - 273.15:.0f} °C Isotherm\",\n    )\n\nplt.yscale(\"log\")\nplt.xlabel(\"Enthalpy [kJ/kg]\")\nplt.ylabel(\"Pressure [MPa]\")\nplt.title(f\"Pressure–Enthalpy (p-h) Diagram for {fluid}\")\nplt.legend()\nplt.grid(True, which=\"both\", ls=\":\")\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\nFigure 3\n\n\n\n\n\n\nDefinition 3 温度勾配\nある一定の等圧線上の沸点と露点の温度が異なり，露点における温度のほうが沸点における温度よりも高くなっているとき，この等圧線上の沸点と露点との温度差を温度勾配と呼ぶ\n\n\nR404AやR410Aは0.2~0.4Kのオーダー\nR407Cは温度勾配が大きく4.5Kほど"
  },
  {
    "objectID": "posts/2025-06-14-pressure-enthalpy-chart/index.html#理解度チェック",
    "href": "posts/2025-06-14-pressure-enthalpy-chart/index.html#理解度チェック",
    "title": "PH線図: pressure-enthalpy chart",
    "section": "📘 理解度チェック",
    "text": "📘 理解度チェック\n\nExercise 2 臨界温度\n次の記述のうち正しいものはどれか？\n\n臨界点は，気体と液体の区別がなくなる状態点である．この臨界点は飽和圧力曲線の終点として表される．臨界点における温度および圧力を臨界温度および臨界圧力という．\n冷凍装置は，通常，凝縮温度を冷媒の臨界温度よりも高い温度で使用している\n\n\n\n\n\n\n\n\nNoteSolution\n\n\n\n\n\na\n\n\n\n\nExercise 3 圧縮機\n次の記述のうち正しいものはどれか？\n\n圧縮機の吸い込み蒸気の比体積を直接測定するのは困難である．そのため，吸い込み蒸気の圧力と温度を図って，それらの値からPH線図や熱力学性質表を用いて冷媒の比体積を求める\n比体積の単位は m³/kg であり，比体積が大きくなると冷媒蒸気の密度は小さくなる\n圧縮機吸込み圧力が低下すると，吸込み蒸気の比体積が大きくなるので，圧縮機駆動の軸動力は小さくなる\n\n\n\n\n\n\n\n\nNoteSolution\n\n\n\n\n\na, b, c\n\n\n\n\nExercise 4 膨張弁\n次の記述のうち正しいものはどれか？\n\n膨張弁は過冷却となった冷媒液を絞り膨張させることで，蒸発圧力まで冷媒の圧力を下げる\n膨張弁で蒸発圧力まで冷媒の圧力を下げる際，例b内は周囲との間で，熱と仕事の授受を行うことで冷媒自身の温度を下げている\n\n\n\n\n\n\n\n\nNoteSolution\n\n\n\n\n\na,"
  },
  {
    "objectID": "posts/2025-09-05-samba/index.html",
    "href": "posts/2025-09-05-samba/index.html",
    "title": "Sambaの設定とiPad連携",
    "section": "",
    "text": "Definition 1 Samba\n\nLinuxホストをMicrosoftネットワークに参加できるようにするソフトウェア\n\n\nSambaを使うことで，次のような機能が実現できます．\n\n\n\n\n\n\n\n\n\nカテゴリ\n機能\n説明\n\n\n\n\nファイル共有\nディレクトリ共有\nWindows から Linux/Unix のディレクトリにアクセス可能．読み取り専用／書き込み可の権限設定が可能・\n\n\n\nファイルアクセス制御\nユーザー・グループごとのアクセス権を設定可能。\n\n\nプリンタ共有\nプリンタ共有\nLinux/Unix に接続されたプリンタを Windows から利用可能．\n\n\n\n複数ユーザー対応\n複数ユーザーでの共有プリンタ環境を構築可能．\n\n\n\nプリンタドライバーの配布\nSamba サーバに Windows 用プリンタドライバーを置いておくと，クライアント側で共有プリンタに接続するだけで自動インストールできる\n\n\nADメンバーサーバー\nドメイン参加\nActive Directoryを構成するメンバーサーバーになることが可能\n\n\n\nドメインコントローラ\nSamba を AD 互換ドメインコントローラとして利用可能．ユーザー認証・グループ管理・ポリシー管理が可能．\n\n\n\nKerberos 認証対応\nシングルサインオン（SSO）で共有アクセスが可能\n\n\nバックアップ・サーバ\nファイルサーバ機能\nネットワーク経由でバックアップやファイル共有が可能．\n\n\n\n自動バックアップ\nrsync や cron と組み合わせて自動バックアップが可能．\n\n\nホームディレクトリ提供\nユーザーごとのホームディレクトリ\nWindows ユーザーごとに自動マウント可能．\n\n\nアクセスログ・監査\nログ取得\nどのユーザーがいつアクセスしたかのログを取得可能。監査やセキュリティ対策に活用可能。"
  },
  {
    "objectID": "posts/2025-09-05-samba/index.html#sambaでできること",
    "href": "posts/2025-09-05-samba/index.html#sambaでできること",
    "title": "Sambaの設定とiPad連携",
    "section": "",
    "text": "Definition 1 Samba\n\nLinuxホストをMicrosoftネットワークに参加できるようにするソフトウェア\n\n\nSambaを使うことで，次のような機能が実現できます．\n\n\n\n\n\n\n\n\n\nカテゴリ\n機能\n説明\n\n\n\n\nファイル共有\nディレクトリ共有\nWindows から Linux/Unix のディレクトリにアクセス可能．読み取り専用／書き込み可の権限設定が可能・\n\n\n\nファイルアクセス制御\nユーザー・グループごとのアクセス権を設定可能。\n\n\nプリンタ共有\nプリンタ共有\nLinux/Unix に接続されたプリンタを Windows から利用可能．\n\n\n\n複数ユーザー対応\n複数ユーザーでの共有プリンタ環境を構築可能．\n\n\n\nプリンタドライバーの配布\nSamba サーバに Windows 用プリンタドライバーを置いておくと，クライアント側で共有プリンタに接続するだけで自動インストールできる\n\n\nADメンバーサーバー\nドメイン参加\nActive Directoryを構成するメンバーサーバーになることが可能\n\n\n\nドメインコントローラ\nSamba を AD 互換ドメインコントローラとして利用可能．ユーザー認証・グループ管理・ポリシー管理が可能．\n\n\n\nKerberos 認証対応\nシングルサインオン（SSO）で共有アクセスが可能\n\n\nバックアップ・サーバ\nファイルサーバ機能\nネットワーク経由でバックアップやファイル共有が可能．\n\n\n\n自動バックアップ\nrsync や cron と組み合わせて自動バックアップが可能．\n\n\nホームディレクトリ提供\nユーザーごとのホームディレクトリ\nWindows ユーザーごとに自動マウント可能．\n\n\nアクセスログ・監査\nログ取得\nどのユーザーがいつアクセスしたかのログを取得可能。監査やセキュリティ対策に活用可能。"
  },
  {
    "objectID": "posts/2025-09-05-samba/index.html#sambaのインストール",
    "href": "posts/2025-09-05-samba/index.html#sambaのインストール",
    "title": "Sambaの設定とiPad連携",
    "section": "Sambaのインストール",
    "text": "Sambaのインストール\napt経由で samba パッケージをインストールします\n# install\n% sudo apt install -y samba\n\n# version check\n% samba --version\nVersion 4.19.5-Ubuntu\nsamba は，ファイルサーバー，プリントサーバー，ユーザー管理を担うsmbdデーモン，名前解決を担うnmbdデーモンから構成されます． ファイヤーウォールを使っている場合は，Sambaを利用できるように次のような設定をします\n% sudo ufw allow samba\nRule added\nRule added (v6)\ntailscaleを導入している場合は，tailscaleについてのファイヤーウォールを実施するだけでOKです．\n% sudo ufw allow in on tailscale0\n\n\n\n\n\n\nNoteSamba運用上の注意\n\n\n\n\nSamba サーバーは基本的に LAN 内での運用を前提(=企業や家庭内ネットワークなど，閉じたネットワークでの利用が基本)\nインターネットサーバー上での動作は推奨されない\nADが使えるとはいえ，Windows Serverで実現できるすべての機能が実装されているわけではない\n\n\n\n各デーモンに対応する systemctl サービス\n\n\n\n\n\n\n\n\n\n構成要素\n担当機能\nsystemctl サービス名\n\n\n\n\nsmbd\nファイル共有・プリント共有・ユーザー認証\nsmbd\n\n\nnmbd\n名前解決\nnmbd"
  },
  {
    "objectID": "posts/2025-09-05-samba/index.html#sambaの制御",
    "href": "posts/2025-09-05-samba/index.html#sambaの制御",
    "title": "Sambaの設定とiPad連携",
    "section": "Sambaの制御",
    "text": "Sambaの制御\n\n\n\n\n\n\n\n\n\nサービス / デーモン\n役割\nコマンド\n\n\n\n\nsmbd\nファイル共有・プリンタ共有・ユーザー認証\n起動: sudo systemctl start smbd\n\n\n\n\n停止: sudo systemctl stop smbd\n\n\n\n\n再起動: sudo systemctl restart smbd\n\n\n\n\n自動起動有効: sudo systemctl enable smbd\n\n\n\n\n自動起動無効: sudo systemctl disable smbd\n\n\n\n\n状態確認: sudo systemctl status smbd\n\n\nnmbd\n名前解決\n起動: sudo systemctl start nmbd\n\n\n\n\n停止: sudo systemctl stop nmbd\n\n\n\n\n再起動: sudo systemctl restart nmbd\n\n\n\n\n自動起動有効: sudo systemctl enable nmbd\n\n\n\n\n自動起動無効: sudo systemctl disable nmbd\n\n\n\n\n状態確認: sudo systemctl status nmbd\n\n\nsamba\nSamba AD DC サービス（AD ドメインコントローラ運用時）\n起動: sudo systemctl start samba\n\n\n\n\n停止: sudo systemctl stop samba\n\n\n\n\n再起動: sudo systemctl restart samba\n\n\n\n\n自動起動有効: sudo systemctl enable samba\n\n\n\n\n自動起動無効: sudo systemctl disable samba\n\n\n\n\n状態確認: sudo systemctl status samba"
  },
  {
    "objectID": "posts/2025-09-05-samba/index.html#sambaの設定",
    "href": "posts/2025-09-05-samba/index.html#sambaの設定",
    "title": "Sambaの設定とiPad連携",
    "section": "Sambaの設定",
    "text": "Sambaの設定\n\n\n\n\n\n\nNoteSamba設定の基本\n\n\n\n\nSambaの主な設定は /etc/samba/smb.conf に記述する\nsmb.conf は大きく分けて [Global Settings] と [Share Definitions] の２つから構成される\n[Global Settings]: Sambaサーバーの全般的な設定をする部分．この部分を変更した場合はSambaサーバーの再起動が必要\n[Share Definitions]: ファイル共有やプリンター共有を設定する部分\n\n\n\n/etc/samba/smb.conf を編集するときは sudo cp -a smb.conf smb.conf.default なり .bak 拡張子を用いてバックアップをしておくと安全です．\nsmb.conf Syntax\nparameter = value\n# commentout line begins with # or ;\nglobalの設定項目\n\n\n\n\n\n\n\n\n\n項目\n説明\n例\n\n\n\n\nworkgroup\nWindows ネットワーク上のワークグループ名を指定\nWORKGROUP\n\n\nserver string\nサーバーの説明文（ネットワークブラウザに表示される）\nSamba Server\n\n\nlog file\nログファイルの出力場所\n/var/log/samba/log.%m\n\n\nmax log size\nログファイルの最大サイズ (KB)\n1000\n\n\nserver role\nサーバーの役割．ファイルサーバーとして使う場合はstandalone server\nstandalone server / member server / active directory domain controller\n\n\npassdb backend\nユーザー認証DBの指定\ntdbsam / ldapsam\n\n\nunix password sync\nSambaユーザーアカウントのpassword変更をLinuxユーザーアカウントのpasswordにも反映\nyes / no\n\n\npasswd program\nSamba がパスワード変更要求を受けた際に，実行するコマンドを指定する\n/usr/bin/passwd %u\n\n\npasswd chat\npasswd program とやり取りする際の「対話プロンプトと応答パターン」を定義する\n*New*password* %n\\n *Retype*new*password* %n\\n *password*updated*successfully*\n\n\npam password change\n有効にすると，password変更にpasswd program に指定したコマンドではなくPAMを利用する\nyes / no\n\n\n\n\nShare Deinitionの設定項目\n\n\n\n\n\n\n\n\n\n項目\n説明\n例\n\n\n\n\npath\n実際に公開するディレクトリの絶対パス\n/srv/samba/public\n\n\ncomment\nネットワークブラウザに表示される説明文\nPublic Share\n\n\nbrowseable\nネットワークブラウザに表示するか\nyes / no\n\n\nread only\n読み取り専用にするか\nyes / no\n\n\nwritable\nread only の逆指定（同義語）\nyes\n\n\nguest ok\n認証なしでアクセスできるか\nyes / no\n\n\nvalid users\nアクセスを許可するユーザー/グループ\n%S とすればhome directoryのユーザーのみが自身のhome directoryにアクセスできる\n\n\ninvalid users\nアクセスを拒否するユーザー/グループ\n@nogroup user2\n\n\ncreate mask\n新規ファイル作成時のパーミッションマスク\n0644\n\n\ndirectory mask\n新規ディレクトリ作成時のパーミッションマスク\n0755\n\n\npublic\nguest ok の別名\nyes / no\n\n\nlocking\nファイルロックの使用有無\nyes\n\n\nprintable\nプリンタ共有として扱うか\nno（通常のフォルダ共有なら）\n\n\n\n\n構文チェック\ntestparm コマンドを用いることでconfigファイルの構文チェックをすることができます\n% testparm -s\nLoad smb config files from /etc/samba/smb.conf\nLoaded services file OK.\n...\n\n\n\n\n\n\n\n\n\nオプション\n説明\n例 / 補足\n\n\n\n\n-s\n短い形式で表示（冗長な情報を省略し、主要な設定のみを出力）\ntestparm -s\n\n\n-v\n詳細表示（全設定、コメントやデフォルト値も含む）\ntestparm -v"
  },
  {
    "objectID": "posts/2025-09-05-samba/index.html#共有の作成",
    "href": "posts/2025-09-05-samba/index.html#共有の作成",
    "title": "Sambaの設定とiPad連携",
    "section": "共有の作成",
    "text": "共有の作成\niPadからtailscale経由でアクセス可能な共有ディレクトリを指定したいと思います．\n[server-hdd]\ncomment = 2TB sized hdd\npath = /media/kirby/DATA/\nbrowsable = yes\nwritable = yes\nguest ok = no\nprintable = no\nvalid users = dedede kirby\nと指定すると server-hdd を共有名として path を公開することができます．設定が完了したら\n% sudo systemctl restart smbd\nを実施します．\niPadからのアクセス設定\nTailscaleをつないでいるならば自動的に名前解決してくれます．手順は以下です．\n\nTailscale管理画面から共有設定したサーバーの名前を調べる(例: dsserver)\nファイル から右上の３点マークの設定を開く\n「サーバーへ接続」を開き以下の書式で入力する\n\nsmb://dsserver/\nその後，Sambaユーザー名とSambaパスワード等が要求されますが，それは smb.conf の設定に合わせて入力してください．\nonly readable errorが出る場合\n原因としてストーレージのフォーマットにiOSが対応していないことが考えられます． iOSの標準ファイルシステムサポートは APFS / HFS+ / FAT32 / exFAT に限られ，NTFSは基本的には読み取り専用になってしまいます．\nマウントしてもread-onlyの場合は，ファイルシステムのフォーマットを確認してみてください． もし，NTFSであるならば中身を退避して，サーバー側でフォーマットを以下のコマンドで書き換えてしまいます\n$ sudo mkfs.exfat -n &lt;任意の名前&gt; /dev/sda1\nその後，サーバー側で再度以下のコマンドでmountを実施し，sambaの設定をすればOKです\nsudo mount -t exfat -o uid=1000,gid=1000,fmask=000,dmask=000 /dev/sda1 &lt;mount-point-path&gt;\n\n\n\n\n\n\nWarningexfatの問題点\n\n\n\n\nモバイルを含む複数のOSでreadable and writableで使用するならexFAT のほうが取り回しは効きます\n一方，ジャーナル機能やファイル圧縮，暗号化への対応はされていないので，セキュリティ面を重視するならば利用は控えたほうが良いです"
  },
  {
    "objectID": "posts/2025-09-05-samba/index.html#nautilusでsamba共有フォルダをmountする",
    "href": "posts/2025-09-05-samba/index.html#nautilusでsamba共有フォルダをmountする",
    "title": "Sambaの設定とiPad連携",
    "section": "NautilusでSamba共有フォルダをmountする",
    "text": "NautilusでSamba共有フォルダをmountする\n基本的にはiPadでの設定と同じ手順です\nsection\nTailscaleをつないでいるならば自動的に名前解決してくれます．手順は以下です．\n\nTailscale管理画面から共有設定したサーバーの名前を調べる(例: dsserver)\nNautilusを開く\n+ Other Locations をクリックし，以下の書式でconnection設定を行う\n\nsmb://dsserver/\nその後，Sambaユーザー名とSambaパスワード等が要求されますが，それは smb.conf の設定に合わせて入力する．\n\nVSCodeでフォルダの中身を編集する\n一度，Nautilus経由でSamba共有フォルダへのアクセス設定すると，GVfs が /run/user/&lt;userid&gt;/gvfs/ 以下に次のような仮想ディレクトリを作成します：\n/run/user/1000/gvfs/smb-share:server=&lt;server-name&gt;,share=&lt;share-folder-name&gt;/\nこれはFUSE(Filesystem in Userspace)経由のマウントなので，GVfsに非対応のコマンドラインツールでは直接編集できない場合があります． Samba共有フォルダを対象にCLI操作なり開発をしたい場合は ~/Desktop/ などの通常のマウントポイントにマウントするか シンボリックリンク（ln -s） で操作できるようにするという選択肢があります．\nGVfsのマウントはセッションごとに作られるため，シンボリックリンクでは動作が不安定になる可能性がありますが，一時的なそうなの場合は十分です．\nシンボリックリンクの作り方\nデスクトップの project フォルダをクリックすると Samba 共有へ飛ぶようするには以下のスクリプトを実行します：\nln -s /run/user/1000/gvfs/smb-share:server=fileserver,share=project ~/Desktop/project\ncifs mountの実施\nとあるPATH上に credential情報を格納したファイル(例: .cifs-credentials)を以下のように設定します\nusername=hoshino-kirby\npassword=pupupuland\n上記はSambaで設定したユーザー情報です．これを/etc/.cifs-credentials に格納した場合， 以下のコマンドでSamba共有フォルダを通常のマウントポイント(例: ~/Desktop/sandbox/)にマウントすることができます\n$ sudo mount -t cifs //&lt;server-global-ip&gt;/&lt;samba foldaname&gt;/&lt;path&gt; ~/Desktop/sandbox/ \\\n-o credentials=/etc/.cifs-credentials,iocharset=utf8,uid=&lt;uid&gt;,gid=&lt;gid&gt;,vers=3.0\n\n\n\n\n\n\nNoteRemarks\n\n\n\n\nuidとgidはクライアント側のvalueを入力します．確認したい場合は id コマンドを活用してください．\n-13 エラーコードを履く場合，sudo apt install cifs-utils を実行してから再度試してください"
  },
  {
    "objectID": "posts/2025-09-05-samba/index.html#appendix-microsoftネットワーク",
    "href": "posts/2025-09-05-samba/index.html#appendix-microsoftネットワーク",
    "title": "Sambaの設定とiPad連携",
    "section": "Appendix: Microsoftネットワーク",
    "text": "Appendix: Microsoftネットワーク\nMicrosoftネットワークは「ワークグループ」という基本単位でネットワークに参加するPCを論理的にまとめて管理しています． Windowsコンピューターでは，所属するワークグループ名を設定するだけで，そのワークグループへ参加することができます．\nワークグループの管理方式\nワークグループ自体は分散型管理が基本で，ユーザーアカウントやパスワードをそれぞれのコンピューターで管理します．もう一つの方法として， ドメインネットワークを利用したドメインコントローラーというサーバーによる集中管理する方法もあります．\n\n\n\n\n\n\n\n\n\n項目\nワークグループ（分散型）\nドメイン（中央管理）\n\n\n\n\n管理方式\n分散型\n集中管理型\n\n\nユーザー管理\n各PCごと\nドメインコントローラー(DC)で一元管理\n\n\n規模\n小規模\n中～大規模\n\n\n必要設備\nPCのみ\nDCサーバー必要\n\n\n\n\nドメインネットワークを利用する場合は以下の手順で認証が行われます\n\nユーザーのPCがシステム起動するとき「ドメインログイン」を行い，その認証情報がDCに送られる\nDCがユーザー名とパスワードを照合し，認証を行う\nDCによる認証をパスすると，ドメインネットワークへのアクセスが許可される\n\nドメインネットワークでは，一度認証をパスすれば，ドメイン内のサーバーへアクセスする際，個々に認証をする必要はありません．そのため，大規模なネットワークを運用する場合に便利な機能です．\n\n\n\n\n\n%%{init: {\"theme\":\"default\"}}%%\narchitecture-beta\n    group wg(cloud)[Workgroup]\n\n    service pc1(server)[PC1] in wg\n    service pc2(server)[PC2] in wg\n    service pc3(server)[PC3] in wg\n    service pc4(server)[PC4] in wg\n\n    pc1:B -- T:pc2\n    pc2:L -- R:pc3\n    pc1:R -- L:pc3\n    pc3:T -- B:pc4\n    pc4:R -- L:pc1\n    pc4:B -- T:pc2\n\n    group domain(cloud)[Domain]\n\n    service dc(database)[Domain Controller] in domain\n    service dpc1(server)[PC5] in domain\n    service dpc2(server)[PC6] in domain\n    service dpc3(server)[PC7] in domain\n\n    dpc1:B -- T:dc\n    dpc2:L -- R:dc\n    dpc3:T -- B:dc\n\n\n\n\n\n\nアクティブディレクトリ（Active Directory, AD）\n\nDefinition 2 アクティブディレクトリ\n\nユーザーやグループなどのリソースを一元管理するディレクトリサービス\nディレクトリアクセスプロトコルとしてLDAPを利用\nホスト名の名前解決にDNSを利用\n認証システムにKerberosを利用"
  },
  {
    "objectID": "posts/2025-07-07-statistics-and-math-001/index.html",
    "href": "posts/2025-07-07-statistics-and-math-001/index.html",
    "title": "平方完成と確率密度関数",
    "section": "",
    "text": "Theorem 1 平方完成\n\\(a\\neq 0, b\\neq 0\\) のとき，\n\\[\n\\begin{align}\n&a(x-A)^2 + b(x - B)^2 = (a+b)(x-C)^2 + \\frac{ab}{a+b}(A-B)^2\\\\\n&C= \\frac{aA + bB}{a+b}\n\\end{align}\n\\]\n\n\n\nExample 1 正規分布の足し合わせ\n\\(X\\sim N(\\mu_x, \\sigma_x^2), Y\\sim N(\\mu_y, \\sigma_y^2)\\) として互いに独立であるとき，\\(Z = X + Y\\) の分布を考えてみます．\n\\[\n\\begin{align}\nh(z)\n  = \\frac{1}{\\sqrt{2\\pi\\sigma_x^2\\sigma_y^2}}\\int\\exp\\left(-\\frac{(x-\\mu_x)^2}{2\\sigma_x^2}\\right)\\exp\\left(-\\frac{(z - x - \\mu_y)^2}{2\\sigma_y^2}\\right)dx\n\\end{align}\n\\]\nここについて，\\(w = x - \\mu_x\\) とすると\n\\[\n\\begin{align}\nh(z) = \\frac{1}{2\\pi\\sqrt{\\sigma_x^2\\sigma_y^2}}\\int\\exp\\left(-\\frac{w^2}{2\\sigma_x^2}\\right)\\exp\\left(-\\frac{(z - w - \\mu_x - \\mu_y)^2}{2\\sigma_y^2}\\right)dw\n\\end{align}\n\\]\nTheorem 1 を用いて \\(\\exp(\\cdot)\\) の中を整理すると\n\\[\n\\begin{align}\n&\\left(\\frac{1}{2\\sigma_x^2} + \\frac{1}{2\\sigma_y^2}\\right)\\left(w - \\frac{\\frac{1}{2\\sigma_y^2}(z -(\\mu_x + \\mu_y))}{\\frac{1}{2\\sigma_x^2} + \\frac{1}{2\\sigma_y^2}}\\right)^2 + \\left(\\frac{1}{2\\sigma_x^2}\\frac{1}{2\\sigma_y^2}\\right)\\left(\\left(\\frac{1}{2\\sigma_x^2} + \\frac{1}{2\\sigma_y^2}\\right)\\right)^{-1}((z -(\\mu_x + \\mu_y)))^2\\\\\n&=\\left(\\frac{\\sigma_x^2 + \\sigma_y^2}{2\\sigma_x^2\\sigma_y^2}\\right)\\left(w - \\frac{\\frac{1}{2\\sigma_y^2}(z -(\\mu_x + \\mu_y))}{\\frac{1}{2\\sigma_x^2} + \\frac{1}{2\\sigma_y^2}}\\right)^2 + \\frac{1}{2(\\sigma_x^2 + \\sigma_y^2)}((z -(\\mu_x + \\mu_y)))^2\n\\end{align}\n\\]\n次に\n\\[\n\\begin{align}\n\\int\\exp\\left(-\\left(\\frac{\\sigma_x^2 + \\sigma_y^2}{2\\sigma_x^2\\sigma_y^2}\\right)\\left(w - \\frac{\\frac{1}{2\\sigma_y^2}(z -(\\mu_x + \\mu_y))}{\\frac{1}{2\\sigma_x^2} + \\frac{1}{2\\sigma_y^2}}\\right)^2\\right)dw\n  = \\sqrt{\\frac{2\\pi\\sigma_x^2\\sigma_y^2}{\\sigma_x^2 + \\sigma_y^2}}\n\\end{align}\n\\]\nであるので\n\\[\n\\begin{align}\nh(z)\n  &= \\frac{1}{2\\pi\\sqrt{\\sigma_x^2\\sigma_y^2}}\\exp\\left(-\\frac{1}{2(\\sigma_x^2 + \\sigma_y^2)}((z -(\\mu_x + \\mu_y)))^2\\right)\\int\\exp\\left(-\\left(\\frac{\\sigma_x^2 + \\sigma_y^2}{2\\sigma_x^2\\sigma_y^2}\\right)\\left(w - \\frac{\\frac{1}{2\\sigma_y^2}(z -(\\mu_x + \\mu_y))}{\\frac{1}{2\\sigma_x^2} + \\frac{1}{2\\sigma_y^2}}\\right)^2\\right)dw\\\\\n  &= \\frac{1}{2\\pi\\sqrt{\\sigma_x^2\\sigma_y^2}}\\exp\\left(-\\frac{1}{2(\\sigma_x^2 + \\sigma_y^2)}((z -(\\mu_x + \\mu_y)))^2\\right) \\times  \\sqrt{\\frac{2\\pi\\sigma_x^2\\sigma_y^2}{\\sigma_x^2 + \\sigma_y^2}}\\\\\n  &= \\frac{1}{\\sqrt{2\\pi(\\sigma_x^2+\\sigma^2_y)}}\\exp\\left(-\\frac{1}{2(\\sigma_x^2 + \\sigma_y^2)}((z -(\\mu_x + \\mu_y)))^2\\right)\n\\end{align}\n\\]\nこれは \\(N(\\mu_x + \\mu_y, \\sigma^2_x + \\sigma^2_y)\\) の確率密度関数と一致するので\n\\[\nZ \\sim N(\\mu_x + \\mu_y, \\sigma^2_x + \\sigma^2_y)\n\\]"
  },
  {
    "objectID": "posts/2025-02-27-how-to-compute-tan75/index.html",
    "href": "posts/2025-02-27-how-to-compute-tan75/index.html",
    "title": "tangent 75°の図形的計算",
    "section": "",
    "text": "Exercise 1 \n\\(\\tan {75}^\\circ\\) を求めよ\n\n\n\n\n\n\n\n\n\nNote解1: 加法定理を用いる場合\n\n\n\n\n\n\\[\n\\begin{align}\n\\tan {45}^\\circ &= 1\\\\\n\\tan {30}^\\circ &= \\frac{\\sqrt{3}}{3}\n\\end{align}\n\\]\nより，加法定理を用いて\n\\[\n\\begin{align}\n\\tan {75}^\\circ\n    &= \\frac{\\tan{30}^\\circ + \\tan{45}^\\circ}{1 - \\tan{30}^\\circ\\tan{45}^\\circ}\\\\\n    &= \\frac{1 + \\frac{\\sqrt{3}}{3}}{1 - \\frac{\\sqrt{3}}{3}}\\\\\n    &= 2 + \\sqrt{3}\n\\end{align}\n\\]\n\n\n\n\n\n\n\n\n\n\nNote解2: 平面幾何的に求める場合\n\n\n\n\n\n\\(\\angle A = {30}^\\circ, \\angle B = {90}^\\circ, \\angle C = {60}^\\circ\\) の \\(\\triangle ABC\\) を考えたとき，\\(\\angle A\\) の斜辺 \\(AC\\) を用いて 直角二等辺三角形 \\(\\triangle ACD\\) をまず作成します．\nこの点 \\(D\\) を通るように \\(AB\\) と平行な線を引き，長方形 \\(AEFB\\) を以下のように作成します．\n\nCode\nimport shapely.plotting\nimport matplotlib.pyplot as plt\nfrom shapely.geometry import Polygon\nimport numpy as np\n\nA = (0, 0)\nB = (1, 0)\nC = (1, np.sin(np.radians(30)))\nD = (np.sqrt(2) * np.cos(np.radians(75)), np.sqrt(2) * np.sin(np.radians(75)))\nE = (0, np.sqrt(2) * np.sin(np.radians(75)))\nF = (1, np.sqrt(2) * np.sin(np.radians(75)))\n\npolygon1 = Polygon([A, B, C])\npolygon2 = Polygon([A, C, D])\npolygon3 = Polygon([A, E, D])\npolygon4 = Polygon([C, D, F])\n\nfig, ax = plt.subplots(figsize=(6, 6))\n\nshapely.plotting.plot_polygon(polygon1, ax=ax)\nshapely.plotting.plot_polygon(polygon2, alpha=0.5, facecolor='none', ax=ax)\nshapely.plotting.plot_polygon(polygon3, alpha=0.5, facecolor='red', ax=ax)\nshapely.plotting.plot_polygon(polygon4, ax=ax)\n\n# 軸の範囲を設定\nplt.xlim(-0.1, 1.45)\nplt.ylim(-0.1, 1.45)\n\n# add label\nplt.text(A[0], A[1] - 0.05, 'A')\nplt.text(B[0]+0.02, B[1] - 0.05, 'B')\nplt.text(C[0]+0.02, C[1], 'C')\nplt.text(D[0], D[1] + 0.02, 'D')\nplt.text(E[0], E[1] + 0.02, 'E')\nplt.text(F[0], F[1] + 0.02, 'F')\n\n# Add Angles\nax.text(A[0] + 0.06, A[1], f\"{30}°\", fontsize=10)\nax.text(A[0] + 0.06, A[1] + 0.1, f\"{45}°\", fontsize=10)\nax.text(B[0] - 0.09, B[1], f\"{90}°\", fontsize=10)\nax.text(C[0] - 0.1, C[1], f\"{90}°\", fontsize=10)\nax.text(C[0] - 0.1, C[1] + 0.14, f\"{30}°\", fontsize=10)\nax.text(C[0] - 0.1, C[1] - 0.1, f\"{60}°\", fontsize=10)\n\n# Add length\nax.text(0.5, -0.08, \"$\\sqrt{3}$\", fontsize=12, color=\"black\", horizontalalignment=\"center\")\nax.text(0.5, 0.3, \"2\", fontsize=12, color=\"black\", horizontalalignment=\"center\")\nax.text(0.5, 1.0, \"2\", fontsize=12, color=\"black\", horizontalalignment=\"center\")\nax.text(1.05, 0.2, \"1\", fontsize=12, color=\"black\", horizontalalignment=\"left\")\nax.text(1.05, 1.0, \"$\\sqrt{3}$\", fontsize=12, color=\"black\", horizontalalignment=\"left\")\nax.text((D[0] + F[0])/2, 1.37,  \"1\", fontsize=12, color=\"black\", horizontalalignment=\"center\")\nax.text((D[0] + E[0])/2, 1.37,  \"$\\sqrt{3} - 1$\", fontsize=12, color=\"black\", horizontalalignment=\"center\")\n\n\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 1\n\n\n\nこのとき， \\(\\triangle CFD  \\equiv \\triangle ABC\\) なので\n\n\\(AE = 1 + \\sqrt{3}\\)\n\\(DE = \\sqrt{3} - 1\\)\n\nであることがわかります．\\(\\triangle ACD\\) は直角二等辺三角形なので \\(\\angle ADC = {45}^\\circ\\)．従って，\n\\[\n\\angle ADE = {75}^\\circ\n\\]\nよって，\n\\[\n\\begin{align}\n\\tan{75}^\\circ\n    &= \\frac{1 + \\sqrt{3}}{\\sqrt{3} - 1} \\\\\n    &= \\frac{4 + 2\\sqrt{3}}{2}\\\\\n    &= 2 + \\sqrt{3}\n\\end{align}\n\\]"
  },
  {
    "objectID": "FAQ/faq.html",
    "href": "FAQ/faq.html",
    "title": "FAQ",
    "section": "",
    "text": "Noteなぜデータサイエンティストにとって，ネットワークやサーバーなどの基盤知識が必要なのか？\n\n\n\n\n\n自分で好きなように分析環境を整えられるようになる\nリソース不足時に，アルゴリズムの最適化のほか，スケールアップなどのインフラ計画まで踏み込んだ包括的な対応ができるようになる\nシステムトラブル時にどこに問題があるか，どのように対策すれば良いかが判断できるようになる\n\n\n\n\n\n\n\n\n\n\n\nNoteQuick setup for ad-hoc analysis\n\n\n\n\npytestやruffをこだわりなくクイックに用いたい場合は uvx(or uv tool run) を用いる\nPyproject.tomlで管理されていないディレクトリでもコマンド自体は利用可能"
  },
  {
    "objectID": "FAQ/faq.html#環境構築",
    "href": "FAQ/faq.html#環境構築",
    "title": "FAQ",
    "section": "",
    "text": "Noteなぜデータサイエンティストにとって，ネットワークやサーバーなどの基盤知識が必要なのか？\n\n\n\n\n\n自分で好きなように分析環境を整えられるようになる\nリソース不足時に，アルゴリズムの最適化のほか，スケールアップなどのインフラ計画まで踏み込んだ包括的な対応ができるようになる\nシステムトラブル時にどこに問題があるか，どのように対策すれば良いかが判断できるようになる\n\n\n\n\n\n\n\n\n\n\n\nNoteQuick setup for ad-hoc analysis\n\n\n\n\npytestやruffをこだわりなくクイックに用いたい場合は uvx(or uv tool run) を用いる\nPyproject.tomlで管理されていないディレクトリでもコマンド自体は利用可能"
  },
  {
    "objectID": "posts/2024-12-19-shortcuts/index.html",
    "href": "posts/2024-12-19-shortcuts/index.html",
    "title": "自分用ショートカットシート",
    "section": "",
    "text": "VSCodeの画面構成\n\n\n\nVSCode 画面構成例\n\n\n\n\n\n\n\n\n\n構成要素\n説明\n\n\n\n\nエディター\nファイル編集を行うエリア\n\n\nアクティビティバー\nサイドバーに表示する機能を切り替えるアイコン\n\n\nサイドバー\nファイルツリーやデバッグ時の変数などを表示するエリア\n\n\nパネル\n凛とエラーやコンソールログを表示するエリア\n\n\nステータスバー\nエディターで開いているファイルの情報などを端的に表示する\n\n\n\n\n\n\n\n\n\nNoteGeneral\n\n\n\n\n\n\n\n\n\n\n\n\n\ncommand\n動作\ncomment\n\n\n\n\nF11\nフルスクリーンモード(toggle)\n\n\n\nctrl + B\nサイドバー(EXPLOER)のToggle\n\n\n\nCtrl + K Z\n禅モード\n集中作業や投影のときに使用, toggle\n\n\nCtrl + super + R\nVSCodeのReload\nフリーズしたときなどに有効\n\n\nCtrl + super + Q\nVSCodeの終了\n\n\n\nCtrl + Shift + T\n直前閉じたtabを再び開く\n\n\n\nCtrl + W\n現在フォーカスしているEditor上のファイルを閉じる\n\n\n\nCtrl + Super + W\nEditorで開かれているファイルをすべて閉じる\nデフォルトはCtrl + K Ctrl + W\n\n\nCtrl + +/-/0\nEditor画面のzoom in/out/reset\n\n\n\nCtrl + =\nEditor fontのサイズ拡大\n\n\n\nCtrl + -\nEditor fontのサイズ縮小\n\n\n\nCtrl + 0\nEditor fontのサイズリセット\n\n\n\nCtrl + Shift +=\nVSCode Window zoom 拡大\n\n\n\nCtrl + Shift +-\nVSCode Window zoom 縮小\n\n\n\nCtrl + Shift +0\nVSCode Window zoom リセット\n\n\n\n\n\n\n\n\n\n\n\n\n\nNoteExplorer\n\n\n\n\n\n\n\n\n\n\n\n\n\ncommand\n動作\ncomment\n\n\n\n\nCtrl + shift + E\nExplorerへFocus toggle\n\n\n\n←/→\n選択したファイル/ディレクトリのfold/unfold\n\n\n\nCtrl + ←\nすべてのオブジェクトをworkspace rootまでfold\n\n\n\n\n\n\n\n\n\n\n\n\n\nNoteEditing\n\n\n\n\n\n\n\n\n\n\n\n\n\ncommand\n動作\ncomment\n\n\n\n\nAlt + ↑/↓\nラインの入れ替え\nlogic変更に伴う行の順番入れ替えに便利\n\n\nCtrl + ]\nインデントの追加\n\n\n\nCtrl + [\nインデントの削除\n\n\n\nCtrl + /\nラインのコメントアウト(Toggle)\n言語に合わせてサーソル行のコメントアウト切り替えができる\n\n\nCtrl + Shift + A\nブロックコメントアウト(Toggle)\n\n\n\nCtrl + F\n検索\nShift + Enterでprevious mathch, Enterでnext match\n\n\nCtrl + D\n検索・置換用の文字ブロックが選択される\nCtrl+H or Ctrl+F と組み合わせて使うと便利\n\n\nCtrl + H\n置換モード\n正規表現モード Alt + R, 置換範囲を選択行に限定 Alt + L, 一括変換 Ctrl + Alt + Enter と組み合わせると便利．２階連続押すと Replace にフォーカスされる．キャンセルは Esc\n\n\nCtrl + L\n現在の行全体を選択\nCtrl +Shift + Lと組み合わせると便利\n\n\nCtrl + W\n開いているファイルを閉じる\n\n\n\nCtrl + super + I\nサジェスト機能\n\n\n\nCtrl + U\n選択範囲の大文字変換\n\n\n\nCtrl + super + U\n選択範囲の小文字変換\n\n\n\nCtrl + Shift + ↑\n現在位置からライン先頭までの選択(selection)\n\n\n\nCtrl + Shift + ↓\n現在位置からライン末尾までの選択(selection)\n\n\n\nCtrl + Shift + ←\n現在位置から現在位置のword block先頭までの選択(selection)\n\n\n\nCtrl + Shift + →\n現在位置から現在位置のword block末尾までの選択(selection)\n\n\n\nF12\n定義参照\n\n\n\nsuper + F12\n定義をサイドに表示\n定義を見ながら修正するときに便利\n\n\n\n\n\n\n\n\n\n\n\n\nNoteEditing + formatting\n\n\n\n\n\n\n\n\n\n\n\n\n\ncommand\n動作\ncomment\n\n\n\n\nCtrl + Shift + I\nコード全体をformatting\neditorTextFocus && !editorHasDocumentFormattingProvider && !editorReadonly && !editor.hasSelection\n\n\nCtrl + Shift + I\n選択したコードをformatting\neditorHasDocumentSelectionFormattingProvider && editorTextFocus && !editorReadonly && editor.hasSelection\n\n\n\n\n\n\n\n\n\n\n\n\nNoteBracket Editing\n\n\n\n\n\n\n\n\n\n\n\n\n\ncommand\n動作\ncomment\n\n\n\n\nCtrl + Alt + \\\nブラケットへの移動\nデフォルトではCtrl + Shift + \\\n\n\nCtrl + Alt + backspace\nブラケットの削除\n\n\n\n\n\n\n\n\n\n\n\n\n\nNoteEditing + delete\n\n\n\n\n\n\n\n\n\n\n\n\n\ncommand\n動作\ncomment\n\n\n\n\nCtrl + Shift + K\nカーソル行の削除\n\n\n\nCtrl + backspace\nカーソルより左側の１単語削除\n\n\n\nCtrl + delete\nカーソルより右側の１単語削除\n\n\n\nCtrl + Super + backspace\nカーソルより左側のすべての単語削除\n\n\n\nCtrl + Super + delete\nカーソルより右側のすべての単語削除\n\n\n\n\n\n\n\n\n\n\n\n\n\nNoteEditing + Multicursor\n\n\n\n\n\n\n\n\n\n\n\n\n\ncommand\n動作\ncomment\n\n\n\n\nCtrl +Shift + L\n選択箇所にマッチする箇所全てにカーソルを展開\nキャンセルしたい場合はEsc\n\n\nAlt +Shift + ↑/↓\nマルチカーソルを上下に展開\nキャンセルしたい場合はEsc\n\n\n\n\n\n\n\n\n\n\n\n\nNoteEditing + 移動\n\n\n\n\n\n\n\n\n\n\n\n\n\ncommand\n動作\ncomment\n\n\n\n\nHome\n文頭まで移動\n\n\n\nEnd\n文末まで移動\n\n\n\nCtrl + Home\nファイル先頭まで移動\n\n\n\nCtrl + End\nファイル文末まで移動\n\n\n\nCtrl + G\n指定した行まで移動\n同僚から「xxx行目見て」って言われたときに便利\n\n\nCtrl + U\n直前までいたカーソル位置に戻る\nF12(定義参照)と組み合わせると便利\n\n\nCtrl + Shift + \\\n次の対応する括弧に移動\narrayやMathJax編集中に便利\n\n\nCtrl + Shift + pageup\n編集tab左移動\n\n\n\nCtrl + Shift + pagedown\n編集tab右移動\n\n\n\nCtrl + tab\n編集tabの選択移動． Ctrl + tab を押し続けて移動先を選択する\n\n\n\nCtrl + super + →\nActive Editorを右に移動する\n\n\n\nCtrl + super + ←\nActive Editorを左に移動する\n\n\n\n\n\n\n\n\n\n\n\n\n\nNote表示\n\n\n\n\n\n\n\n\n\n\n\n\n\ncommand\n動作\ncomment\n\n\n\n\nAlt + Z\noverflow textのwrap Toggle\n\n\n\nCtrl + Shift + ]\nブロックの展開\n\n\n\nCtrl + Shift + [\nブロックの折りたたみ\n\n\n\nCtrl + K Ctrl + 0\nすべて折りたたむ\n\n\n\nCtrl + K Ctrl + J\n折りたたみをすべて展開する\n\n\n\nCtrl + K Ctrl + 1~7\n指定したレベルに合わせて折りたたむ\n1が折りたたみレベル最上位\n\n\n\n\n\n\n\n\n\n\n\n\nNoteGit\n\n\n\n\n\n\n\n\n\n\n\n\n\ncommand\n動作\ncomment\n\n\n\n\nCtrl + Super + ‘H’\nOpen Changes\ngit管理下のファイルを対象にHEADとの変更点を表示\n\n\n\n\n\n\n\n\n\n\n\n\nNoteGitHub Copilot\n\n\n\n\n\n\n\n\n\n\n\n\n\ncommand\n動作\ncomment\n\n\n\n\nCtrl + i\nインラインGitHub Copilotの起動\nキャンセルはEsc\n\n\nCtrl + Alt + i\nGitHub Copilotの起動(Toggle)\n\n\n\nCtrl +Esc\nCopilotプロセスのキャンセル\n\n\n\n\n\n\n\n\n\n\n\n\n\nNoteCSV\n\n\n\n\n\n ▶  条件\n\nEdit CSVがinstall済み\n\n\n\n\n\n\n\n\n\ncommand\n動作\ncomment\n\n\n\n\nCtrl + Enter\n現在開かれているcsvファイルをtable ui形式で表示\nデータサイズが重たいものについては使用注意"
  },
  {
    "objectID": "posts/2024-12-19-shortcuts/index.html#vscode-shortcut-sheet",
    "href": "posts/2024-12-19-shortcuts/index.html#vscode-shortcut-sheet",
    "title": "自分用ショートカットシート",
    "section": "",
    "text": "VSCodeの画面構成\n\n\n\nVSCode 画面構成例\n\n\n\n\n\n\n\n\n\n構成要素\n説明\n\n\n\n\nエディター\nファイル編集を行うエリア\n\n\nアクティビティバー\nサイドバーに表示する機能を切り替えるアイコン\n\n\nサイドバー\nファイルツリーやデバッグ時の変数などを表示するエリア\n\n\nパネル\n凛とエラーやコンソールログを表示するエリア\n\n\nステータスバー\nエディターで開いているファイルの情報などを端的に表示する\n\n\n\n\n\n\n\n\n\nNoteGeneral\n\n\n\n\n\n\n\n\n\n\n\n\n\ncommand\n動作\ncomment\n\n\n\n\nF11\nフルスクリーンモード(toggle)\n\n\n\nctrl + B\nサイドバー(EXPLOER)のToggle\n\n\n\nCtrl + K Z\n禅モード\n集中作業や投影のときに使用, toggle\n\n\nCtrl + super + R\nVSCodeのReload\nフリーズしたときなどに有効\n\n\nCtrl + super + Q\nVSCodeの終了\n\n\n\nCtrl + Shift + T\n直前閉じたtabを再び開く\n\n\n\nCtrl + W\n現在フォーカスしているEditor上のファイルを閉じる\n\n\n\nCtrl + Super + W\nEditorで開かれているファイルをすべて閉じる\nデフォルトはCtrl + K Ctrl + W\n\n\nCtrl + +/-/0\nEditor画面のzoom in/out/reset\n\n\n\nCtrl + =\nEditor fontのサイズ拡大\n\n\n\nCtrl + -\nEditor fontのサイズ縮小\n\n\n\nCtrl + 0\nEditor fontのサイズリセット\n\n\n\nCtrl + Shift +=\nVSCode Window zoom 拡大\n\n\n\nCtrl + Shift +-\nVSCode Window zoom 縮小\n\n\n\nCtrl + Shift +0\nVSCode Window zoom リセット\n\n\n\n\n\n\n\n\n\n\n\n\n\nNoteExplorer\n\n\n\n\n\n\n\n\n\n\n\n\n\ncommand\n動作\ncomment\n\n\n\n\nCtrl + shift + E\nExplorerへFocus toggle\n\n\n\n←/→\n選択したファイル/ディレクトリのfold/unfold\n\n\n\nCtrl + ←\nすべてのオブジェクトをworkspace rootまでfold\n\n\n\n\n\n\n\n\n\n\n\n\n\nNoteEditing\n\n\n\n\n\n\n\n\n\n\n\n\n\ncommand\n動作\ncomment\n\n\n\n\nAlt + ↑/↓\nラインの入れ替え\nlogic変更に伴う行の順番入れ替えに便利\n\n\nCtrl + ]\nインデントの追加\n\n\n\nCtrl + [\nインデントの削除\n\n\n\nCtrl + /\nラインのコメントアウト(Toggle)\n言語に合わせてサーソル行のコメントアウト切り替えができる\n\n\nCtrl + Shift + A\nブロックコメントアウト(Toggle)\n\n\n\nCtrl + F\n検索\nShift + Enterでprevious mathch, Enterでnext match\n\n\nCtrl + D\n検索・置換用の文字ブロックが選択される\nCtrl+H or Ctrl+F と組み合わせて使うと便利\n\n\nCtrl + H\n置換モード\n正規表現モード Alt + R, 置換範囲を選択行に限定 Alt + L, 一括変換 Ctrl + Alt + Enter と組み合わせると便利．２階連続押すと Replace にフォーカスされる．キャンセルは Esc\n\n\nCtrl + L\n現在の行全体を選択\nCtrl +Shift + Lと組み合わせると便利\n\n\nCtrl + W\n開いているファイルを閉じる\n\n\n\nCtrl + super + I\nサジェスト機能\n\n\n\nCtrl + U\n選択範囲の大文字変換\n\n\n\nCtrl + super + U\n選択範囲の小文字変換\n\n\n\nCtrl + Shift + ↑\n現在位置からライン先頭までの選択(selection)\n\n\n\nCtrl + Shift + ↓\n現在位置からライン末尾までの選択(selection)\n\n\n\nCtrl + Shift + ←\n現在位置から現在位置のword block先頭までの選択(selection)\n\n\n\nCtrl + Shift + →\n現在位置から現在位置のword block末尾までの選択(selection)\n\n\n\nF12\n定義参照\n\n\n\nsuper + F12\n定義をサイドに表示\n定義を見ながら修正するときに便利\n\n\n\n\n\n\n\n\n\n\n\n\nNoteEditing + formatting\n\n\n\n\n\n\n\n\n\n\n\n\n\ncommand\n動作\ncomment\n\n\n\n\nCtrl + Shift + I\nコード全体をformatting\neditorTextFocus && !editorHasDocumentFormattingProvider && !editorReadonly && !editor.hasSelection\n\n\nCtrl + Shift + I\n選択したコードをformatting\neditorHasDocumentSelectionFormattingProvider && editorTextFocus && !editorReadonly && editor.hasSelection\n\n\n\n\n\n\n\n\n\n\n\n\nNoteBracket Editing\n\n\n\n\n\n\n\n\n\n\n\n\n\ncommand\n動作\ncomment\n\n\n\n\nCtrl + Alt + \\\nブラケットへの移動\nデフォルトではCtrl + Shift + \\\n\n\nCtrl + Alt + backspace\nブラケットの削除\n\n\n\n\n\n\n\n\n\n\n\n\n\nNoteEditing + delete\n\n\n\n\n\n\n\n\n\n\n\n\n\ncommand\n動作\ncomment\n\n\n\n\nCtrl + Shift + K\nカーソル行の削除\n\n\n\nCtrl + backspace\nカーソルより左側の１単語削除\n\n\n\nCtrl + delete\nカーソルより右側の１単語削除\n\n\n\nCtrl + Super + backspace\nカーソルより左側のすべての単語削除\n\n\n\nCtrl + Super + delete\nカーソルより右側のすべての単語削除\n\n\n\n\n\n\n\n\n\n\n\n\n\nNoteEditing + Multicursor\n\n\n\n\n\n\n\n\n\n\n\n\n\ncommand\n動作\ncomment\n\n\n\n\nCtrl +Shift + L\n選択箇所にマッチする箇所全てにカーソルを展開\nキャンセルしたい場合はEsc\n\n\nAlt +Shift + ↑/↓\nマルチカーソルを上下に展開\nキャンセルしたい場合はEsc\n\n\n\n\n\n\n\n\n\n\n\n\nNoteEditing + 移動\n\n\n\n\n\n\n\n\n\n\n\n\n\ncommand\n動作\ncomment\n\n\n\n\nHome\n文頭まで移動\n\n\n\nEnd\n文末まで移動\n\n\n\nCtrl + Home\nファイル先頭まで移動\n\n\n\nCtrl + End\nファイル文末まで移動\n\n\n\nCtrl + G\n指定した行まで移動\n同僚から「xxx行目見て」って言われたときに便利\n\n\nCtrl + U\n直前までいたカーソル位置に戻る\nF12(定義参照)と組み合わせると便利\n\n\nCtrl + Shift + \\\n次の対応する括弧に移動\narrayやMathJax編集中に便利\n\n\nCtrl + Shift + pageup\n編集tab左移動\n\n\n\nCtrl + Shift + pagedown\n編集tab右移動\n\n\n\nCtrl + tab\n編集tabの選択移動． Ctrl + tab を押し続けて移動先を選択する\n\n\n\nCtrl + super + →\nActive Editorを右に移動する\n\n\n\nCtrl + super + ←\nActive Editorを左に移動する\n\n\n\n\n\n\n\n\n\n\n\n\n\nNote表示\n\n\n\n\n\n\n\n\n\n\n\n\n\ncommand\n動作\ncomment\n\n\n\n\nAlt + Z\noverflow textのwrap Toggle\n\n\n\nCtrl + Shift + ]\nブロックの展開\n\n\n\nCtrl + Shift + [\nブロックの折りたたみ\n\n\n\nCtrl + K Ctrl + 0\nすべて折りたたむ\n\n\n\nCtrl + K Ctrl + J\n折りたたみをすべて展開する\n\n\n\nCtrl + K Ctrl + 1~7\n指定したレベルに合わせて折りたたむ\n1が折りたたみレベル最上位\n\n\n\n\n\n\n\n\n\n\n\n\nNoteGit\n\n\n\n\n\n\n\n\n\n\n\n\n\ncommand\n動作\ncomment\n\n\n\n\nCtrl + Super + ‘H’\nOpen Changes\ngit管理下のファイルを対象にHEADとの変更点を表示\n\n\n\n\n\n\n\n\n\n\n\n\nNoteGitHub Copilot\n\n\n\n\n\n\n\n\n\n\n\n\n\ncommand\n動作\ncomment\n\n\n\n\nCtrl + i\nインラインGitHub Copilotの起動\nキャンセルはEsc\n\n\nCtrl + Alt + i\nGitHub Copilotの起動(Toggle)\n\n\n\nCtrl +Esc\nCopilotプロセスのキャンセル\n\n\n\n\n\n\n\n\n\n\n\n\n\nNoteCSV\n\n\n\n\n\n ▶  条件\n\nEdit CSVがinstall済み\n\n\n\n\n\n\n\n\n\ncommand\n動作\ncomment\n\n\n\n\nCtrl + Enter\n現在開かれているcsvファイルをtable ui形式で表示\nデータサイズが重たいものについては使用注意"
  },
  {
    "objectID": "posts/2024-12-19-shortcuts/index.html#gnome-terminator-shortcut-sheet",
    "href": "posts/2024-12-19-shortcuts/index.html#gnome-terminator-shortcut-sheet",
    "title": "自分用ショートカットシート",
    "section": "Gnome Terminator Shortcut sheet",
    "text": "Gnome Terminator Shortcut sheet\n% terminator --version    \nterminator 2.1.1\n\nGeneral\n\n\n\n\n\n\n\n\ncommand\n動作\ncomment\n\n\n\n\nCtrl + Alt + T\n新規にgnome terminatorを起動\nUbuntu OS側で設定したショートカットコマンド\n\n\nSuper + B\nkey入力をgroupにbroadcast\ntab切り替え先にも適用される\n\n\nSuper + Shift + B\nBroadcast入力機能のoff\n\n\n\nShift + Ctrl + Q\nTerminal windowをクローズする\n右上の☓をクリックするのと同じ動き\n\n\nShift + Ctrl + F\nterminal上の出力結果の検索\nShift + tabと組み合わせて前方/後方検索可能\n\n\nCtrl` + `+`          |zoom in                      |                                                       |  |Ctrl+-|zoom out                      |                                                       |  |``Ctrl + 0\nzoom reset\n\n\n\n\n\n\nCursor\n\n\n\n\n\n\n\n\ncommand\n動作\ncomment\n\n\n\n\nCtrl + A\n行頭への移動\nhomeでも同じ挙動\n\n\nCtrl + E\n行末に移動\nEndでも同じ挙動\n\n\nCtrl + U\n現在位置から行頭まで削除\n\n\n\nCtrl + K\n現在位置から行末まで削除\n\n\n\nCtrl + W\nワード単位で行頭方向の文字列を削除\n\n\n\n\n\n\nTab\n\n\n\n\n\n\n\n\ncommand\n動作\ncomment\n\n\n\n\nCtrl + Shift + T\n新規tab作成\n\n\n\nCtrl + Super + T\ntabのrename\ntabが作成されているときのみ有効\n\n\nCtrl + pageup\nnext tabへの移動\n\n\n\nCtrl + pageup\nprevious tabへの移動\n\n\n\nCtrl + Shift + W\ntabをクローズ\n\n\n\n\n\n\nPane\n\n\n\n\n\n\n\n\ncommand\n動作\ncomment\n\n\n\n\nShift + Ctrl + E\ncolumn方向に分割\n\n\n\nShift + Ctrl + O\nrow方向に分割\n\n\n\nAlt + ←\n左のpaneへ移動\n-\n\n\nAlt + →\n右のpaneへ移動\n-\n\n\nAlt + ↑\n上のpaneへ移動\n-\n\n\nAlt + ↓\n下のpaneへ移動\n-"
  },
  {
    "objectID": "posts/2024-12-19-shortcuts/index.html#byobu-shortcut-sheet",
    "href": "posts/2024-12-19-shortcuts/index.html#byobu-shortcut-sheet",
    "title": "自分用ショートカットシート",
    "section": "Byobu Shortcut sheet",
    "text": "Byobu Shortcut sheet\n% byobu --version\nbyobu version 5.133\ntmux 3.2a\nデフォルトのショートカットは /usr/share/byobu/keybindings/ にて定義されています．\n\nGeneral\n\n\n\n\n\n\n\n\ncommand\n動作\ncomment\n\n\n\n\nF1\nbyobu-config を新しいウィンドウで開く\n設定メニュー表示\n\n\nF9\n設定メニューを開く（再掲）\nbyobu-config\n\n\nShift + F1\nヘルプを表示\n$BYOBU_PREFIX/share/doc/byobu/help.tmux.txt をページャで表示\n\n\nF5\ntmuxrc を再読み込み\nsource $BYOBU_PREFIX/share/byobu/profiles/tmuxrc\n\n\nAlt + F5\nUTF-8 モードの切り替え\ntoggle-utf8 スクリプト\n\n\nCtrl + F5\nソケット再接続コマンド送信\nbyobu-reconnect-sockets\n\n\nF6\nlogoutしてdetach（セッションから離脱）\n-\n\n\nShift + F6\nlogout せず detach\ntouch no-logout\n\n\nShift + F12\nFキー バインディング無効化\nf-keys.tmux.disable\n\n\nAlt + F12\nマウス操作有効化\nmouse.tmux.enable\n\n\nAlt + Pageup\n現在のwindowの実行履歴をスクロールバック確認\n\n\n\nAlt + Pagedown\n現在のwindowの実行履歴をスクロールフォワード確認\n\n\n\n\n\n\nセッション操作\n\n\n\n\n\n\n\n\ncommand\n動作\ncomment\n\n\n\n\nbyobu new-session\n新規に新しいセッションでbyobuを起動\n同時に複数箇所から同じセッションに入るとバグってしまう\n\n\nCtrl + Shift + F2\n新しいセッションを開始\n\n\n\nCtrl + F8\nセッション名を変更\n-\n\n\n\n\n\nWindow操作\n\n\n\n\n\n\n\n\ncommand\n動作\ncomment\n\n\n\n\nF2\n新しいウィンドウを作成\nカレントディレクトリで作成\n\n\nCtrl + F2\n水平方向に分割\ndisplay-panes → split-window -h\n\n\nShift + F2\n垂直方向に分割\ndisplay-panes → split-window -v\n\n\nF3\n前のウィンドウへ移動\n-\n\n\nF4\n次のウィンドウへ移動\n-\n\n\nAlt + ←\n前のウィンドウへ移動\n-\n\n\nAlt + →\n次のウィンドウへ移動\n-\n\n\nAlt + ↑\n前のクライアントに切り替え\n-\n\n\nAlt + ↓\n次のクライアントに切り替え\n-\n\n\nCtrl + Shift + F3\nウィンドウを1つ前と入れ替え\nswap-window\n\n\nCtrl + Shift + F4\nウィンドウを1つ後と入れ替え\nswap-window\n\n\nF8\nウィンドウ名を変更\n-\n\n\nShift + F11\nsplitされた画面の一つにフォーカスToggle\ncopyコマンドを実行するときに便利\n\n\n\n\n\nPane操作\n\n\n\n\n\n\n\n\ncommand\n動作\ncomment\n\n\n\n\nShift + F3\n前のペインを選択\ndisplay-panes + select-pane\n\n\nShift + F4\n次のペインを選択\ndisplay-panes + select-pane\n\n\nShift + ↑\n上ペインを選択\ndisplay-panes + select-pane\n\n\nShift + ↓\n下ペインを選択\ndisplay-panes + select-pane\n\n\nShift + ←\n左ペインを選択\ndisplay-panes + select-pane\n\n\nShift + →\n右ペインを選択\ndisplay-panes + select-pane\n\n\nCtrl + F3\nペインを上と入れ替え\nswap-pane\n\n\nCtrl + F4\nペインを下と入れ替え\nswap-pane\n\n\nAlt + Shift + ↑\nペインサイズ拡大（上）\nresize-pane\n\n\nAlt + Shift + ↓\nペインサイズ縮小（下）\nresize-pane\n\n\nAlt + Shift + ←\nペインサイズ縮小（左）\nresize-pane\n\n\nAlt + Shift + →\nペインサイズ拡大（右）\nresize-pane\n\n\nCtrl + F6\n現在のペインを kill\n-\n\n\nShift + F11\nペインを一時拡大\nresize-pane -Z\n\n\n\n\n\ncopy-mode操作\n\n\n\n\n\n\n\n\ncommand\n動作\ncomment\n\n\n\n\nF7\ncopy-mode（バッファ選択）\n-\n\n\nShift + F7\n画面全体をキャプチャし新ウィンドウで表示\nPRINTSCREEN\n\n\nAlt + PageDown\ncopy-mode + ページダウン\n-\n\n\nAlt + PageUp\ncopy-mode + ページアップ\n-\n\n\n\n\n\nマルチ操作\n\n\n\n\n\n\n\n\ncommand\n動作\ncomment\n\n\n\n\nShift + F9\n全ペインにコマンド送信\n-\n\n\nCtrl + F9\n全ウィンドウにコマンド送信\n-\n\n\nAlt + F9\npane 同期モード表示\nsynchronize-panes\n\n\n\n\n\n注意が必要な操作\n\n\n\n\n\n\n\n\ncommand\n動作\ncomment\n\n\n\n\nShift + F5\nステータス表示切り替え用スクリプト実行\ncycle-status\n\n\nCtrl + Shift + F5\nプロファイル選択画面を開く\nbyobu-select-profile\n\n\nAlt + F6\n他のクライアントを全て切断\nexcept current\n\n\nAlt + F11\n現在のペインを分離\nbreak-pane\n\n\nCtrl + F11\n直前ウィンドウからペインを join\njoin-pane -h\n\n\nAlt + Insert\nクリップボードから貼り付け\npaste-buffer\n\n\nCtrl + a\nbyobu-ctrl-a 実行\nprefix 操作用の互換対応"
  },
  {
    "objectID": "posts/2025-02-05-surveying/index.html",
    "href": "posts/2025-02-05-surveying/index.html",
    "title": "測量法における測量の分類",
    "section": "",
    "text": "測量の分類は，一般的には，\n\n測量の手法\n測量の目的\n\nによって分類され，具体的には，多角測量，水準測量，地形測量，写真測量，地図測量，GISなどがあります．一方，測量法に基づく測量の分類という観点だと，測量法では，測量を\n\n基本測量\n公共測量\n基本測量及び公共測量以外の測量\n\nの三種類に分類しています．\n\n\n\n測量法第4条 \n「基本測量」とは，すべての測量の基礎となる測量で，国土地理院の行うものをいう\n\n基本測量とは以下２つの特徴があります\n\n国土地理院が実施する測量\nすべての測量の基礎となる測量\n\n ▶  基本測量事業内容\n\n\n\n\n\n\n\n測量内容\n説明\n\n\n\n\n基準点測量\n各種測量に地球上の正確な位置と高さを与える国家基準点体系（三角点，水準点等）の整備と維持管理事業\n\n\n地殻変動観測\n準点測量を継続的に行うことにより，地殻の動きをとらえる測量事業\n\n\n地理情報の整備や２万５千分の１地形図等基本図の作成\nデジタル形式の基本図「電子国土基本図」の整備など\n\n\n\n ▶  測量標の保全\n\n測量法第22条 \n何人も，国土地理院の長の承諾を得ないで，基本測量の測量標を移転し，汚損し，その他その効用を害する行為をしてはならない．\n\n\n\n\n\n測量法第5条 \n「公共測量」とは，基本測量以外の測量で次に掲げるものをいい，建物に関する測量その他の局地的測量又は小縮尺図の調製その他の高度の精度を必要としない測量で政令で定めるものを除く．\n\nその測量の実施に要する費用の全部又は一部を国又は公共団体が負担し，又は補助して行う測量\n基本測量又は公共測量の測量成果を使用して次の事業のために実施する測量で国土交通大臣が指定したもの\n\n行政庁の許可，認可その他の処分を受けて行われる事業\nその実施に要する費用の全部又は一部について国又は公共団体の負担又は補助，貸付けその他の助成を受けて行われる事業\n\n\n\n公共測量となる測量は以下の条件すべてを満たす測量だけとなります\n\n測量経費: 測量の費用を国・公共団体が負担・補助して実施する測量\n測量の精度: 高精度な測量に限る．国土地理院が測量計画機関から提出された計画書を審査し必要な精度が得られる方法で行われているか判断\n使用する測量: 基本測量・公共測量成果を２点以上使用する測量１点以下の場合でも規模大の測量\n\n公共測量は日本で実施される測量の大部分を占めています．（source: 国土地理院）\n\n\n\n\n\npie title 測量種類別の事業費の割合\n         \"公共測量\" : 89\n         \"民間の測量\" : 20\n         \"基本測量\": 1\n\n\n\n\n\n\n\n ▶  公共測量の表示等\n\n測量法第37条 \n公共測量を実施する者は，当該測量において設置する測量標に，公共測量の測量標であること及び測量計画機関の名称を表示しなければならない．\n\n公共測量を実施する者は，関係市町村長に対して当該測量を実施するために必要な情報の提供を求めることができる．\n測量計画機関は，公共測量において永久標識を設置したときは，遅滞なく，その種類及び所在地その他国土交通省令で定める事項を国土地理院の長に通知しなければならない．\n測量計画機関は，自ら実施した公共測量の永久標識を移転し，撤去し，又は廃棄したときは，遅滞なく，その種類及び旧所在地その他国土交通省令で定める事項を国土地理院の長に通知しなければならない．\n\n\n測量法第37条2にて，公共測量を実施するにあたって，地元の事情に最も精通していると考えられる関係市町村長に情報の提供を求めることができると規定されています．都道府県知事ではなく関係市町村長であるところに注意が必要です．\n\n\n\n\n測量法第6条 \nこの法律において「基本測量及び公共測量以外の測量」とは，基本測量又は公共測量の測量成果を使用して実施する基本測量及び公共測量以外の測量（建物に関する測量その他の局地的測量又は小縮尺図の調製その他の高度の精度を必要としない測量で政令で定めるものを除く．）をいう．"
  },
  {
    "objectID": "posts/2025-02-05-surveying/index.html#測量法における測量の分類",
    "href": "posts/2025-02-05-surveying/index.html#測量法における測量の分類",
    "title": "測量法における測量の分類",
    "section": "",
    "text": "測量の分類は，一般的には，\n\n測量の手法\n測量の目的\n\nによって分類され，具体的には，多角測量，水準測量，地形測量，写真測量，地図測量，GISなどがあります．一方，測量法に基づく測量の分類という観点だと，測量法では，測量を\n\n基本測量\n公共測量\n基本測量及び公共測量以外の測量\n\nの三種類に分類しています．\n\n\n\n測量法第4条 \n「基本測量」とは，すべての測量の基礎となる測量で，国土地理院の行うものをいう\n\n基本測量とは以下２つの特徴があります\n\n国土地理院が実施する測量\nすべての測量の基礎となる測量\n\n ▶  基本測量事業内容\n\n\n\n\n\n\n\n測量内容\n説明\n\n\n\n\n基準点測量\n各種測量に地球上の正確な位置と高さを与える国家基準点体系（三角点，水準点等）の整備と維持管理事業\n\n\n地殻変動観測\n準点測量を継続的に行うことにより，地殻の動きをとらえる測量事業\n\n\n地理情報の整備や２万５千分の１地形図等基本図の作成\nデジタル形式の基本図「電子国土基本図」の整備など\n\n\n\n ▶  測量標の保全\n\n測量法第22条 \n何人も，国土地理院の長の承諾を得ないで，基本測量の測量標を移転し，汚損し，その他その効用を害する行為をしてはならない．\n\n\n\n\n\n測量法第5条 \n「公共測量」とは，基本測量以外の測量で次に掲げるものをいい，建物に関する測量その他の局地的測量又は小縮尺図の調製その他の高度の精度を必要としない測量で政令で定めるものを除く．\n\nその測量の実施に要する費用の全部又は一部を国又は公共団体が負担し，又は補助して行う測量\n基本測量又は公共測量の測量成果を使用して次の事業のために実施する測量で国土交通大臣が指定したもの\n\n行政庁の許可，認可その他の処分を受けて行われる事業\nその実施に要する費用の全部又は一部について国又は公共団体の負担又は補助，貸付けその他の助成を受けて行われる事業\n\n\n\n公共測量となる測量は以下の条件すべてを満たす測量だけとなります\n\n測量経費: 測量の費用を国・公共団体が負担・補助して実施する測量\n測量の精度: 高精度な測量に限る．国土地理院が測量計画機関から提出された計画書を審査し必要な精度が得られる方法で行われているか判断\n使用する測量: 基本測量・公共測量成果を２点以上使用する測量１点以下の場合でも規模大の測量\n\n公共測量は日本で実施される測量の大部分を占めています．（source: 国土地理院）\n\n\n\n\n\npie title 測量種類別の事業費の割合\n         \"公共測量\" : 89\n         \"民間の測量\" : 20\n         \"基本測量\": 1\n\n\n\n\n\n\n\n ▶  公共測量の表示等\n\n測量法第37条 \n公共測量を実施する者は，当該測量において設置する測量標に，公共測量の測量標であること及び測量計画機関の名称を表示しなければならない．\n\n公共測量を実施する者は，関係市町村長に対して当該測量を実施するために必要な情報の提供を求めることができる．\n測量計画機関は，公共測量において永久標識を設置したときは，遅滞なく，その種類及び所在地その他国土交通省令で定める事項を国土地理院の長に通知しなければならない．\n測量計画機関は，自ら実施した公共測量の永久標識を移転し，撤去し，又は廃棄したときは，遅滞なく，その種類及び旧所在地その他国土交通省令で定める事項を国土地理院の長に通知しなければならない．\n\n\n測量法第37条2にて，公共測量を実施するにあたって，地元の事情に最も精通していると考えられる関係市町村長に情報の提供を求めることができると規定されています．都道府県知事ではなく関係市町村長であるところに注意が必要です．\n\n\n\n\n測量法第6条 \nこの法律において「基本測量及び公共測量以外の測量」とは，基本測量又は公共測量の測量成果を使用して実施する基本測量及び公共測量以外の測量（建物に関する測量その他の局地的測量又は小縮尺図の調製その他の高度の精度を必要としない測量で政令で定めるものを除く．）をいう．"
  },
  {
    "objectID": "posts/2025-02-05-surveying/index.html#測量法と測量の基準",
    "href": "posts/2025-02-05-surveying/index.html#測量法と測量の基準",
    "title": "測量法における測量の分類",
    "section": "測量法と測量の基準",
    "text": "測量法と測量の基準\n\n測量法第11条1項 \n位置は，地理学的経緯度及び平均海面からの高さで表示する． ただし，場合により，直角座標及び平均海面からの高さ，極座標及び平均海面からの高さ又は地心直交座標で表示することができる\n\n測量の基準に関して，位置の表示は原則「位置は，地理学的経緯度及び平均海面からの高さで表示する」ということになっています．\n\n世界測地系\n\n測量法第11条第2項 \n前項第一号の地理学的経緯度は，世界測地系に従つて測定しなければならない．\n\n世界測地系は，概念としてはただ一つのものですが，国ごとに採用する時期や構築に当たっての詳細な手法及び実現精度が異なります．代表例として以下の世界測地系があります：\n\n\n\n\n\n\n\n世界測地系\n特徴\n\n\n\n\nITRF系（国際地球基準座標系）\n地球の重心が原点，X軸をグリニッジ子午線と赤道との交点の方向，Y軸を東経90度の方向，Z軸を北極の方向にとった３次元直交座標(=Z軸は地球の自転軸と一致している)\n\n\nWGS系\nアメリカのGPSに用いられている．高精度・継続性よりむしろリアルタイム性が重要視される軍事，航法，海図，ナビゲーションの分野に適した世界測地系とされている．ITRF系とほぼ同一\n\n\nPZ系\nロシアの測位システムに用いられている\n\n\n\n日本では，ITRF系GRS80楕円体を採用しています．\n\n\n\n\n\n\nTip🌍: GRS80楕円体\n\n\n\n地球の形状は，自転による遠心力のため扁平な回転楕円体ですが，この楕円体の超半径と扁平率を与えたものを準拠楕円体と呼びます．準拠楕円体の１つであるGRS80楕円体では以下のように定められます\n\n長半径: 6,378,137m\n扁平率: 1/298.257222101\n\n\n\n\n回転楕円体\n\n\n\n\n\n\nジオイド\n\nDef: ジオイド \n平均海面を仮想的に陸地へ延長した面を「ジオイド」と呼ぶ．日本では，日本経緯度原点に最も近い東京湾の平均海面を通る水準面がジオイドと一致するものと考え, 高さの基準としている．ジオイドは重力方向に対して直交しています．\n\n\n\nGeoid\n\n\n\n水は重力の影響を受けて，高いところから低いところへ流れますが，地面が平坦なところでも，重力が小さいところから大きいところへ水が流れます． 地球内部の質量分布の不均一などによって，重力分布は一様ではないため，東京湾平均海面を基準としたジオイドはゆるやかな凹凸をしています．\n日本の土地の高さ（標高）は，東京湾の平均海面を基準（標高０ｍ）として測られています．水が高いこところから低いところへ流れることを表したジオイドを用いて標高が計算されているので．標高の高さと水の流れる方向は対応しているといえます．\n ▶  標高とジオイド高と楕円体高\n\n\n\nジオイド高さと標高と楕円体高\n\n\n\nジオイド高: 衛星測位の高さの基準である楕円体面から「ジオイド」までの高さ，国土地理院が発表している\n楕円体高: GPSや準天頂衛星システム等のGNSS測量で得られる高さで，楕円体面から地表面までの高さ\n\n\\[\n\\text{標高} = \\text{楕円体高} - \\text{ジオイド高}\n\\]"
  },
  {
    "objectID": "posts/2025-07-09-set-operation/index.html",
    "href": "posts/2025-07-09-set-operation/index.html",
    "title": "集合列の和集合・直和・共通部分",
    "section": "",
    "text": "Definition 1 集合列\n集合 \\(\\Gamma\\) が \\(\\mathbb N\\) のとき，集合族 \\(\\{A_\\gamma\\}_{\\gamma\\in \\Gamma}\\) は\n\\[\n\\{A_1, A_2, \\cdots, A_n, \\cdots \\}\n\\]\nと表される．これを集合列という．\n\n集合列の和集合・直和・共通部分\n\\[\n\\begin{align}\n\\text{集合列の和集合:} \\ \\   & \\bigcup_{n=1}^\\infty A_n\\\\\n\\text{集合列の直和:} \\ \\    & \\bigsqcup_{n=1}^\\infty A_n\\\\\n\\text{集合列の共通部分:} \\ \\ & \\bigcap_{n=1}^\\infty A_n\n\\end{align}\n\\]\n\nDefinition 2 上極限集合\n\\[\n\\lim_{n\\to\\infty}\\sup A_n = \\bigcap_{n=1}^\\infty\\bigcup_{k=n}^\\infty A_k\n\\]\n\n\\(x\\in \\bigcap_{n=1}^\\infty\\bigcup_{k=n}^\\infty A_k\\) をまず考えます．これはすべての \\(n\\) に対して\n\\[\nx \\in \\bigcup_{k=n}^\\infty A_k\n\\]\nを意味します．一方，\\(x \\in \\bigcup_{k=n}^\\infty A_k\\) は \\(k\\geq n\\) を満たすある \\(k\\) に対して\n\\[\nx\\in A_k\n\\]\nこれらふたつをあわせると\n\\[\n\\bigcap_{n=1}^\\infty\\bigcup_{k=n}^\\infty A_k = \\{x | \\text{すべての n に対して，ある} k\\geq n \\text{が存在して} x \\in A_k\\}\n\\]\n上極限集合を無限に多くの \\(k\\) に対して \\(x\\in A_k\\) と解釈する\n\\(x\\in\\lim\\sup A_n\\) のとき，ある \\(k_1\\) に対して \\(x \\in A_{k_1}\\) となります．ここで\n\\[\n\\bigcap_{n=1}^\\infty\\bigcup_{k=n}^\\infty A_k = \\left(\\bigcap_{n=1}^{k_1}\\bigcup_{k=n}^{\\infty} A_k\\right) \\bigcap \\left(\\bigcap_{n&gt;k_1}^\\infty\\bigcup_{k=n}^\\infty\\right)\n\\]\nであることから，\\(k\\geq k_1 + 1\\) をみたすある \\(k_2\\) についても\n\\[\nx \\in A_{k_2}\n\\]\nとならなくてはいけません．これを繰り返していくと \\(k_1 &lt; k_2&lt; \\cdots &lt; k_n &lt; \\cdots\\) で\n\\[\nx \\in A_{k_1}, x \\in A_{k_2}, \\cdots, x \\in A_{k_n}, \\cdots\n\\]\nつまり，\\(x\\in\\lim\\sup A_n\\) であるならば，無限に多くの \\(k\\) に対して \\(x\\in A_k\\) ということになります．\n逆に，「無限に多くの \\(k\\) に対して \\(x\\in A_k\\)」であるならば，\n\\[\n\\text{任意の $n$ について $k\\geq n$ を満たす} \\ \\ x\\in A_{k} \\ \\ \\text{となるような $k$ が存在する}\n\\]\nであるので，\n\\[\n\\bigcap_{n=1}^\\infty\\bigcup_{k=n}^\\infty A_k = \\{x | \\text{すべての n に対して，ある} k\\geq n \\text{が存在して} x \\in A_k\\}\n\\]\nが成立します．\n\nDefinition 3 下極限集合\n\\[\n\\lim_{n\\to\\infty}\\inf A_n = \\bigcup_{n=1}^\\infty\\bigcap_{k=n}^\\infty A_k\n\\]\n\n下極限集合は，\n\\[\n\\lim_{n\\to\\infty}\\inf A_n = \\{x | \\text{ある $n$ が存在して，$k\\geq n$ となるようなすべての $k$ について $x \\in A_k$}\\}\n\\]\nと解釈できます\n\nExample 1 supとinfの関係\n\\(i \\in \\mathbb N\\) として，集合 \\(A_i\\) を以下のように定義します\n\\[\nA_i = \\left\\{(x, y) | t_i = 1 - \\frac{1}{i}, (x - t_i)^2 + y^2 &lt; 4\\right\\}\n\\]\nこのとき，\n\\[\n\\begin{align}\n\\lim_{n\\to\\infty} \\sup A_n &= \\text{青の境界を含まない開集合}\\\\\n\\lim_{n\\to\\infty} \\inf A_n &= \\text{黒斜線部のの境界を含まない開集合}\n\\end{align}\n\\]\nまた，\n\\[\n\\lim_{n\\to\\infty} \\inf A_n \\subseteq \\lim_{n\\to\\infty} \\sup A_n\n\\]\nであることがわかります．\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport matplotlib.patches as mpatches\n\nx = np.linspace(-2.5, 3, 1000)\ny = np.linspace(-3, 3, 1000)\nX, Y = np.meshgrid(x, y)\n\n# Intersection region\nregion1 = (X - 1)**2 + Y**2 &lt;= 4\nregion2 = X**2 + Y**2 &lt;= 4\nintersection_common = region1 & region2\n\n# Plot\nplt.figure(figsize=(8, 6))\nplt.contourf(X, Y, region1, levels=[0.5, 1], colors='#B4D7FF', alpha=0.6)\nplt.contour(X, Y, region2, levels=[0.5], colors='black')\nplt.contourf(X, Y, region1, levels=[0.5, 1], colors='none', hatches=['///'])\n\n# 凡例用パッチ作成\npatch_region_sup = mpatches.Patch(color='#B4D7FF', alpha=0.6, label='$\\lim\\sup A_n$')\npatch_region_inf = mpatches.Patch(facecolor='white', hatch='///', label='$\\lim\\inf A_n$', edgecolor='black')\n\nplt.legend(handles=[patch_region_sup, patch_region_inf])\n\nplt.xlabel('x')\nplt.ylabel('y')\nplt.axis('equal')\nplt.grid(True)\nplt.show()\n\n\n\n\n\n\n\n\nFigure 1"
  },
  {
    "objectID": "posts/2025-07-09-set-operation/index.html#上極限集合と下極限集合",
    "href": "posts/2025-07-09-set-operation/index.html#上極限集合と下極限集合",
    "title": "集合列の和集合・直和・共通部分",
    "section": "",
    "text": "Definition 1 集合列\n集合 \\(\\Gamma\\) が \\(\\mathbb N\\) のとき，集合族 \\(\\{A_\\gamma\\}_{\\gamma\\in \\Gamma}\\) は\n\\[\n\\{A_1, A_2, \\cdots, A_n, \\cdots \\}\n\\]\nと表される．これを集合列という．\n\n集合列の和集合・直和・共通部分\n\\[\n\\begin{align}\n\\text{集合列の和集合:} \\ \\   & \\bigcup_{n=1}^\\infty A_n\\\\\n\\text{集合列の直和:} \\ \\    & \\bigsqcup_{n=1}^\\infty A_n\\\\\n\\text{集合列の共通部分:} \\ \\ & \\bigcap_{n=1}^\\infty A_n\n\\end{align}\n\\]\n\nDefinition 2 上極限集合\n\\[\n\\lim_{n\\to\\infty}\\sup A_n = \\bigcap_{n=1}^\\infty\\bigcup_{k=n}^\\infty A_k\n\\]\n\n\\(x\\in \\bigcap_{n=1}^\\infty\\bigcup_{k=n}^\\infty A_k\\) をまず考えます．これはすべての \\(n\\) に対して\n\\[\nx \\in \\bigcup_{k=n}^\\infty A_k\n\\]\nを意味します．一方，\\(x \\in \\bigcup_{k=n}^\\infty A_k\\) は \\(k\\geq n\\) を満たすある \\(k\\) に対して\n\\[\nx\\in A_k\n\\]\nこれらふたつをあわせると\n\\[\n\\bigcap_{n=1}^\\infty\\bigcup_{k=n}^\\infty A_k = \\{x | \\text{すべての n に対して，ある} k\\geq n \\text{が存在して} x \\in A_k\\}\n\\]\n上極限集合を無限に多くの \\(k\\) に対して \\(x\\in A_k\\) と解釈する\n\\(x\\in\\lim\\sup A_n\\) のとき，ある \\(k_1\\) に対して \\(x \\in A_{k_1}\\) となります．ここで\n\\[\n\\bigcap_{n=1}^\\infty\\bigcup_{k=n}^\\infty A_k = \\left(\\bigcap_{n=1}^{k_1}\\bigcup_{k=n}^{\\infty} A_k\\right) \\bigcap \\left(\\bigcap_{n&gt;k_1}^\\infty\\bigcup_{k=n}^\\infty\\right)\n\\]\nであることから，\\(k\\geq k_1 + 1\\) をみたすある \\(k_2\\) についても\n\\[\nx \\in A_{k_2}\n\\]\nとならなくてはいけません．これを繰り返していくと \\(k_1 &lt; k_2&lt; \\cdots &lt; k_n &lt; \\cdots\\) で\n\\[\nx \\in A_{k_1}, x \\in A_{k_2}, \\cdots, x \\in A_{k_n}, \\cdots\n\\]\nつまり，\\(x\\in\\lim\\sup A_n\\) であるならば，無限に多くの \\(k\\) に対して \\(x\\in A_k\\) ということになります．\n逆に，「無限に多くの \\(k\\) に対して \\(x\\in A_k\\)」であるならば，\n\\[\n\\text{任意の $n$ について $k\\geq n$ を満たす} \\ \\ x\\in A_{k} \\ \\ \\text{となるような $k$ が存在する}\n\\]\nであるので，\n\\[\n\\bigcap_{n=1}^\\infty\\bigcup_{k=n}^\\infty A_k = \\{x | \\text{すべての n に対して，ある} k\\geq n \\text{が存在して} x \\in A_k\\}\n\\]\nが成立します．\n\nDefinition 3 下極限集合\n\\[\n\\lim_{n\\to\\infty}\\inf A_n = \\bigcup_{n=1}^\\infty\\bigcap_{k=n}^\\infty A_k\n\\]\n\n下極限集合は，\n\\[\n\\lim_{n\\to\\infty}\\inf A_n = \\{x | \\text{ある $n$ が存在して，$k\\geq n$ となるようなすべての $k$ について $x \\in A_k$}\\}\n\\]\nと解釈できます\n\nExample 1 supとinfの関係\n\\(i \\in \\mathbb N\\) として，集合 \\(A_i\\) を以下のように定義します\n\\[\nA_i = \\left\\{(x, y) | t_i = 1 - \\frac{1}{i}, (x - t_i)^2 + y^2 &lt; 4\\right\\}\n\\]\nこのとき，\n\\[\n\\begin{align}\n\\lim_{n\\to\\infty} \\sup A_n &= \\text{青の境界を含まない開集合}\\\\\n\\lim_{n\\to\\infty} \\inf A_n &= \\text{黒斜線部のの境界を含まない開集合}\n\\end{align}\n\\]\nまた，\n\\[\n\\lim_{n\\to\\infty} \\inf A_n \\subseteq \\lim_{n\\to\\infty} \\sup A_n\n\\]\nであることがわかります．\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport matplotlib.patches as mpatches\n\nx = np.linspace(-2.5, 3, 1000)\ny = np.linspace(-3, 3, 1000)\nX, Y = np.meshgrid(x, y)\n\n# Intersection region\nregion1 = (X - 1)**2 + Y**2 &lt;= 4\nregion2 = X**2 + Y**2 &lt;= 4\nintersection_common = region1 & region2\n\n# Plot\nplt.figure(figsize=(8, 6))\nplt.contourf(X, Y, region1, levels=[0.5, 1], colors='#B4D7FF', alpha=0.6)\nplt.contour(X, Y, region2, levels=[0.5], colors='black')\nplt.contourf(X, Y, region1, levels=[0.5, 1], colors='none', hatches=['///'])\n\n# 凡例用パッチ作成\npatch_region_sup = mpatches.Patch(color='#B4D7FF', alpha=0.6, label='$\\lim\\sup A_n$')\npatch_region_inf = mpatches.Patch(facecolor='white', hatch='///', label='$\\lim\\inf A_n$', edgecolor='black')\n\nplt.legend(handles=[patch_region_sup, patch_region_inf])\n\nplt.xlabel('x')\nplt.ylabel('y')\nplt.axis('equal')\nplt.grid(True)\nplt.show()\n\n\n\n\n\n\n\n\nFigure 1"
  },
  {
    "objectID": "posts/2025-07-09-set-operation/index.html#事象列の上極限集合と下極限集合",
    "href": "posts/2025-07-09-set-operation/index.html#事象列の上極限集合と下極限集合",
    "title": "集合列の和集合・直和・共通部分",
    "section": "事象列の上極限集合と下極限集合",
    "text": "事象列の上極限集合と下極限集合\n\\((\\Omega, \\mathcal{F}, P)\\) を確率空間とします．事象の列 \\(A_n \\in \\mathcal{F}\\) があったとして，\n\\[\n\\lim_{n\\to\\infty}\\sup A_n\n\\]\nを考えてみます．\n\\[\n\\omega \\in \\lim_{n\\to\\infty}\\sup A_n = \\bigcap_{k=1}^\\infty\\bigcup_{n=k}^\\infty A_n\n\\]\nとすれば，\\(\\omega\\) は どんなに大きな\\(k\\) をとってもそれ以降の \\(A_n\\) に必ず含まれることを意味しています．もし \\(\\omega\\) が有限個の \\(\\{A_{n_1}, \\cdots, A_{n_m}\\}\\) にのみ属するならば矛盾してしまうので，無限個の \\(A_n\\) に属していなくてはならないことになります．つまり，\n\n\\(\\mathbb P(\\lim\\sup A_n)\\) は「\\(\\omega \\in A_k\\) を満たすような事象が，たびたび，しかし何回でも起こる確率」と解釈できます\n\n次に，\n\\[\n\\lim_{n\\to\\infty}\\inf A_n\n\\]\nこれは，ある \\(n\\) 以降全ての \\(k\\geq n\\) で \\(\\omega \\in A_k\\) となっているので，\n\n「十分先では常に \\(A_k\\) が起こっているという事象」を意味します．\n\n\n\n\n\n\n\nNote上極限集合の別表記\n\n\n\n\\(\\mathbb P(\\lim\\sup A_n)\\) は「\\(\\omega \\in A_k\\) を満たすような事象が，たびたび，しかし何回でも起こる確率」と解釈できることから\n\\[\nP(A_k\\ , \\ \\text{i.o.})\n\\]\nと表記する場合もあります．i.o. は infinitely oftenの略です．"
  },
  {
    "objectID": "posts/2025-07-09-set-operation/index.html#references",
    "href": "posts/2025-07-09-set-operation/index.html#references",
    "title": "集合列の和集合・直和・共通部分",
    "section": "References",
    "text": "References\n\n統計学への確率論，その先へ: ゼロからの測度論的理解と漸近理論への架け橋"
  },
  {
    "objectID": "posts/2025-04-09-vector-outer-product/index.html",
    "href": "posts/2025-04-09-vector-outer-product/index.html",
    "title": "ベクトル空間における外積",
    "section": "",
    "text": "▶  Key Takeaways"
  },
  {
    "objectID": "posts/2025-04-09-vector-outer-product/index.html#ベクトルの外積",
    "href": "posts/2025-04-09-vector-outer-product/index.html#ベクトルの外積",
    "title": "ベクトル空間における外積",
    "section": "ベクトルの外積",
    "text": "ベクトルの外積\n\n\nDefinition 1 : 外積 \n３次元実数空間のベクトル\n\\[\n\\begin{align}\n\\pmb a = (a_1, a_2, a_3)\\\\\n\\pmb b = (b_1, b_2, b_3)\n\\end{align}\n\\]\nに対して，\n\\[\n\\left(\\begin{vmatrix}\na_2 & a_3\\\\\nb_2 & b_3\n\\end{vmatrix},\n- \\begin{vmatrix}\na_1 & a_3\\\\\nb_1 & b_3\n\\end{vmatrix},\n\\begin{vmatrix}\na_1 & a_2\\\\\nb_1 & b_2\n\\end{vmatrix}\n\\right)\n\\]\nを \\(\\pmb a\\) と \\(\\pmb b\\) の外積またはベクトル積 といい，\\(\\pmb a \\times \\pmb b\\) と表す．\n\n\n3次元実ベクトル空間 \\(\\mathbb R^3\\) の標準基低\n\\[\n\\pmb e_1 = (1, 0, 0), \\pmb e_2 = (0, 1, 0), \\pmb e_3 = (0, 0, 1)\n\\]\nを用いて表現すると\n\\[\n\\pmb a \\times \\pmb b = \\begin{vmatrix}\na_2 & a_3\\\\\nb_2 & b_3\n\\end{vmatrix}\\pmb e_1\n- \\begin{vmatrix}\na_1 & a_3\\\\\nb_1 & b_3\n\\end{vmatrix}\\pmb e_2 +\n\\begin{vmatrix}\na_1 & a_2\\\\\nb_1 & b_2\n\\end{vmatrix}\\pmb e_3\n\\]\nと表現することもできます．この式を直感的に理解するとすると\n\\[\n\\begin{vmatrix}\n\\pmb e_1& \\pmb e_2 & \\pmb e_3\\\\\na_1& a_2 & a_3\\\\\nb_1& b_2 & b_3\n\\end{vmatrix}\n\\]\nと対応すると考えることもできます．\n\n\n\n\n\n\nNoteProperty: 外積の性質\n\n\n\n外積について次の法則が成り立つ\n\\[\n\\begin{align}\n&\\pmb a \\times \\pmb b = -\\pmb b\\times \\pmb a\\\\\n&(\\lambda\\pmb a) \\times \\pmb b = \\pmb a \\times (\\lambda \\pmb b ) = \\lambda (\\pmb a \\times \\pmb b )\\\\\n&\\pmb a \\times (\\pmb b  + \\pmb c) = \\pmb a \\times \\pmb b + \\pmb a \\times \\pmb c\\\\\n&\\pmb a \\times \\pmb a = \\pmb 0\n\\end{align}\n\\]\n\n\n\n\n\n\n\n\n\nNoteProof\n\n\n\n\n\n ▶ \\(\\pmb a \\times \\pmb b = -\\pmb b \\times \\pmb a\\)\n\\[\n\\begin{align}\n\\pmb a \\times \\pmb b\n    &= \\begin{vmatrix}\na_2 & a_3\\\\\nb_2 & b_3\n\\end{vmatrix}\\pmb e_1\n- \\begin{vmatrix}\na_1 & a_3\\\\\nb_1 & b_3\n\\end{vmatrix}\\pmb e_2 +\n\\begin{vmatrix}\na_1 & a_2\\\\\nb_1 & b_2\n\\end{vmatrix}\\pmb e_3\\\\\n&= -\\begin{vmatrix}\nb_2 & b_3\\\\\na_2 & a_3\n\\end{vmatrix}\\pmb e_1\n+ \\begin{vmatrix}\nb_1 & b_3\\\\\na_1 & a_3\n\\end{vmatrix}\\pmb e_2 -\n\\begin{vmatrix}\nb_1 & b_2\\\\\na_1 & a_2\n\\end{vmatrix}\\pmb e_3\\\\\n&= (-1)\\left(\n\\begin{vmatrix}\nb_2 & b_3\\\\\na_2 & a_3\n\\end{vmatrix}\\pmb e_1\n- \\begin{vmatrix}\nb_1 & b_3\\\\\na_1 & a_3\n\\end{vmatrix}\\pmb e_2 +\n\\begin{vmatrix}\nb_1 & b_2\\\\\na_1 & a_2\n\\end{vmatrix}\\pmb e_3\\right)\\\\\n&= - \\pmb b \\times \\pmb a\n\\end{align}\n\\]\n ▶  \\((\\lambda\\pmb a) \\times \\pmb b = \\pmb a \\times (\\lambda \\pmb b ) = \\lambda (\\pmb a \\times \\pmb b )\\)\n\\(\\eqref{#eq-determinant-linear}\\) より\n\\[\n\\begin{align}\n(\\lambda\\pmb a) \\times \\pmb b\n    &= \\begin{vmatrix}\n\\lambda a_2 & \\lambda a_3\\\\\nb_2 & b_3\n\\end{vmatrix}\\pmb e_1\n- \\begin{vmatrix}\n\\lambda a_1 & \\lambda a_3\\\\\nb_1 & b_3\n\\end{vmatrix}\\pmb e_2 +\n\\begin{vmatrix}\n\\lambda a_1 & \\lambda a_2\\\\\nb_1 & b_2\n\\end{vmatrix}\\pmb e_3\\\\\n&= \\lambda\\begin{vmatrix}\na_2 & a_3\\\\\nb_2 & b_3\n\\end{vmatrix}\\pmb e_1\n- \\lambda\\begin{vmatrix}\na_1 & a_3\\\\\nb_1 & b_3\n\\end{vmatrix}\\pmb e_2 +\n\\lambda\\begin{vmatrix}\na_1 & a_2\\\\\nb_1 & b_2\n\\end{vmatrix}\\pmb e_3\\\\\n&= \\lambda (\\pmb a\\times \\pmb b )\n\\end{align}\n\\]\n同様に\n\\[\n\\begin{align}\n\\pmb a\\times (\\lambda\\pmb b)  \n    &= \\begin{vmatrix}\na_2 & a_3\\\\\n\\lambda b_2 & \\lambda b_3\n\\end{vmatrix}\\pmb e_1\n- \\begin{vmatrix}\na_1 & a_3\\\\\n\\lambda b_1 & \\lambda b_3\n\\end{vmatrix}\\pmb e_2 +\n\\begin{vmatrix}\na_1 & a_2\\\\\n\\lambda b_1 & \\lambda b_2\n\\end{vmatrix}\\pmb e_3\\\\\n&= \\lambda\\begin{vmatrix}\na_2 & a_3\\\\\nb_2 & b_3\n\\end{vmatrix}\\pmb e_1\n- \\lambda\\begin{vmatrix}\na_1 & a_3\\\\\nb_1 & b_3\n\\end{vmatrix}\\pmb e_2 +\n\\lambda\\begin{vmatrix}\na_1 & a_2\\\\\nb_1 & b_2\n\\end{vmatrix}\\pmb e_3\\\\\n&= \\lambda (\\pmb a\\times \\pmb b )\n\\end{align}\n\\]\n ▶  \\(\\pmb a \\times (\\pmb b  + \\pmb c) = \\pmb a \\times \\pmb b + \\pmb a \\times \\pmb c\\)\n\\[\n\\begin{align}\n&\\pmb a\\times (\\pmb b + \\pmb c)\\\\\n    &=\n        \\begin{vmatrix}\n        a_2 & a_3\\\\\n        b_2 + c_2 &  b_3 + c_3\n        \\end{vmatrix}\\pmb e_1\n        - \\begin{vmatrix}\n        a_1 & a_3\\\\\n         b_1 + c_1 &  b_3 + c_3\n        \\end{vmatrix}\\pmb e_2 +\n        \\begin{vmatrix}\n        a_1 & a_2\\\\\n         b_1 + c_1 &  b_2 + c_2\n        \\end{vmatrix}\\pmb e_3\\\\\n    &=\n        \\left(\n            \\begin{vmatrix}\n            a_2 & a_3\\\\\n            b_2&  b_3\n            \\end{vmatrix}\n            +\n            \\begin{vmatrix}\n            a_2 & a_3\\\\\n            c_2&  c_3\n            \\end{vmatrix}\n        \\right)\\pmb e_1\n        - \\left(\n            \\begin{vmatrix}\n            a_1 & a_3\\\\\n            b_1&  b_3\n            \\end{vmatrix}\n            +\n            \\begin{vmatrix}\n            a_1 & a_3\\\\\n            c_1&  c_3\n            \\end{vmatrix}\n        \\right)\\pmb e_2 +\n        \\left(\n            \\begin{vmatrix}\n            a_1 & a_2\\\\\n            b_1&  b_2\n            \\end{vmatrix}\n            +\n            \\begin{vmatrix}\n            a_1 & a_2\\\\\n            c_1&  c_2\n            \\end{vmatrix}\n        \\right)\\pmb e_3\\\\\n    &= \\left(\n            \\begin{vmatrix}\n            a_2 & a_3\\\\\n            b_2&  b_3\n            \\end{vmatrix}\n        \\pmb e_1\n        -\n            \\begin{vmatrix}\n            a_1 & a_3\\\\\n            b_1&  b_3\n            \\end{vmatrix}\n            \\pmb e_2 +\n            \\begin{vmatrix}\n            a_1 & a_2\\\\\n            b_1&  b_2\n            \\end{vmatrix}\n       \\pmb e_3\\right)+\n       \\left(\n            \\begin{vmatrix}\n            a_2 & a_3\\\\\n            c_2&  c_3\n            \\end{vmatrix}\n        \\pmb e_1\n        -\n            \\begin{vmatrix}\n            a_1 & a_3\\\\\n            c_1&  c_3\n            \\end{vmatrix}\n            \\pmb e_2 +\n            \\begin{vmatrix}\n            a_1 & a_2\\\\\n            c_1&  c_2\n            \\end{vmatrix}\n       \\pmb e_3\\right)\\\\\n    &= \\pmb a \\times \\pmb b + \\pmb a \\times \\pmb c\n\\end{align}\n\\]\n ▶  \\(\\pmb a\\times \\pmb a = \\pmb 0\\)\n\\[\n\\begin{align}\n\\pmb a \\times \\pmb a\n    &= \\begin{vmatrix}\na_2 & a_3\\\\\na_2 & a_3\n\\end{vmatrix}\\pmb e_1\n- \\begin{vmatrix}\na_1 & a_3\\\\\na_1 & a_3\n\\end{vmatrix}\\pmb e_2 +\n\\begin{vmatrix}\na_1 & a_2\\\\\na_1 & a_2\n\\end{vmatrix}\\pmb e_3\\\\\n&= 0\\pmb e_1 - 0\\pmb e_2 + 0\\pmb e_3\\\\\n&= \\pmb 0\n\\end{align}\n\\]\n\n\n\n\nExample 1 \n\\(\\mathbb R^3\\) の標準基底 \\(\\pmb e_1, \\pmb e_2, \\pmb e_3\\) に関して\n\\[\n\\begin{align}\n\\pmb e_1 \\times \\pmb e_2 &= \\left(\\begin{vmatrix}\n0 & 0\\\\\n1 & 0\n\\end{vmatrix}, -\\begin{vmatrix}\n1  & 0\\\\\n0  & 0\n\\end{vmatrix}, \\begin{vmatrix}\n1 & 0 \\\\\n0 & 1\n\\end{vmatrix} \\right)\\\\\n&= \\pmb e_3\n\\end{align}\n\\]\n\\[\n\\begin{align}\n\\pmb e_2 \\times \\pmb e_3 &= \\left(\\begin{vmatrix}\n1 & 0\\\\\n0 & 1\n\\end{vmatrix}, -\\begin{vmatrix}\n0  & 0\\\\\n0  & 1\n\\end{vmatrix}, \\begin{vmatrix}\n0 & 1 \\\\\n0 & 0\n\\end{vmatrix} \\right)\\\\\n&= \\pmb e_1\n\\end{align}\n\\]\n\\[\n\\begin{align}\n\\pmb e_3 \\times \\pmb e_1 &= \\left(\\begin{vmatrix}\n0 & 1\\\\\n0 & 0\n\\end{vmatrix}, -\\begin{vmatrix}\n0  & 1\\\\\n1  & 0\n\\end{vmatrix}, \\begin{vmatrix}\n0 & 0 \\\\\n1 & 0\n\\end{vmatrix} \\right)\\\\\n&= \\pmb e_2\n\\end{align}\n\\]\n\n\n ▶  内積と外積を組み合わせた性質\n\n\nTheorem 1 \n３つのベクトル \\(\\pmb a = (a_1, a_2, a_3), \\pmb b = (b_1, b_2, b_3), \\pmb c = (c_1, c_2, c_3)\\) について，\n\\[\n(\\pmb a\\times \\pmb b, \\pmb c) = (\\pmb a, \\pmb b \\times \\pmb c) = \\begin{vmatrix}\na_1 & a_2 & a_3\\\\\nb_1 & b_2 & b_3\\\\\nc_1 & c_2 & c_3\n\\end{vmatrix}\n\\]\n\n\n\n\n\n\n\n\n\nNoteProof\n\n\n\n\n\n\\[\n\\begin{align}\n(\\pmb a\\times \\pmb b, \\pmb c)\n    &=\n        \\left(\\begin{vmatrix}\n        a_2 & a_3\\\\\n        b_2 & b_3\n        \\end{vmatrix}\\pmb e_1\n        - \\begin{vmatrix}\n        a_1 & a_3\\\\\n        b_1 & b_3\n        \\end{vmatrix}\\pmb e_2 +\n        \\begin{vmatrix}\n        a_1 & a_2\\\\\n        b_1 & b_2\n        \\end{vmatrix}\\pmb e_3, \\pmb c\\right)\\\\\n    &=\n    \\begin{vmatrix}\n        a_2 & a_3\\\\\n        b_2 & b_3\n        \\end{vmatrix}c_1\n        - \\begin{vmatrix}\n        a_1 & a_3\\\\\n        b_1 & b_3\n        \\end{vmatrix}c_2 +\n        \\begin{vmatrix}\n        a_1 & a_2\\\\\n        b_1 & b_2\n        \\end{vmatrix}c_3\\\\\n    &=\n    \\begin{vmatrix}\na_1 & a_2 & a_3\\\\\nb_1 & b_2 & b_3\\\\\nc_1 & c_2 & c_3\n\\end{vmatrix}\n\\end{align}\n\\]\n同様に\n\\[\n\\begin{align}\n(\\pmb a, \\pmb b \\times \\pmb c)\n&= (\\pmb b \\times \\pmb c, \\pmb a)\\\\\n    &=\n        \\left(\\begin{vmatrix}\n        b_2 & b_3\\\\\n        c_2 & c_3\n        \\end{vmatrix}\\pmb e_1\n        - \\begin{vmatrix}\n        b_1 & b_3\\\\\n        c_1 & c_3\n        \\end{vmatrix}\\pmb e_2 +\n        \\begin{vmatrix}\n        b_1 & b_2\\\\\n        c_1 & c_2\n        \\end{vmatrix}\\pmb e_3, \\pmb a\\right)\\\\\n    &=\n        \\begin{vmatrix}\n        b_2 & b_3\\\\\n        c_2 & c_3\n        \\end{vmatrix}a_1\n        - \\begin{vmatrix}\n        b_1 & b_3\\\\\n        c_1 & c_3\n        \\end{vmatrix}a_2 +\n        \\begin{vmatrix}\n        b_1 & b_2\\\\\n        c_1 & c_2\n        \\end{vmatrix} a_3\\\\\n    &=\n    \\begin{vmatrix}\na_1 & a_2 & a_3\\\\\nb_1 & b_2 & b_3\\\\\nc_1 & c_2 & c_3\n\\end{vmatrix}\n\\end{align}\n\\]"
  },
  {
    "objectID": "posts/2025-04-09-vector-outer-product/index.html#外積の幾何学的性質",
    "href": "posts/2025-04-09-vector-outer-product/index.html#外積の幾何学的性質",
    "title": "ベクトル空間における外積",
    "section": "外積の幾何学的性質",
    "text": "外積の幾何学的性質\n\n\nTheorem 2 \n３次元実ベクトル \\(\\pmb a, \\pmb b\\) の外積の大きさは\n\\[\n||\\pmb a\\times \\pmb b|| = ||\\pmb a||\\,||\\pmb b||\\sin \\theta\n\\]\nここで， \\(\\theta\\) は \\(\\pmb a, \\pmb b\\) のなす角であるとする\n\n\n\n\n\n\n\n\nNoteProof\n\n\n\n\n\n\\[\n\\begin{align}\n||\\pmb a\\times \\pmb b|| = ((a_2b_3 - a_3b_2), -(a_1b_3 - a_3b_1), (a_1b_2 - a_2b_1))\n\\end{align}\n\\]\nであるので\n\\[\n\\begin{align}\n||\\pmb a\\times \\pmb b||^2\n    =& a_2^2b_3^2 + a_3^2b_2^2 + a_1^2b_3^2 + a_3^2b_1^2 + a_1^2b_2^2 + a_2^2b_1^2\\\\\n     & - 2(a_2a_3b_2b_3 + a_1a_3b_1b_3+ a_1a_2b_1b_2)\n\\end{align}\n\\]\n続いて\n\\[\n\\cos\\theta = \\frac{(\\pmb a, \\pmb b)}{||\\pmb a||\\,||\\pmb b||}\\quad \\text{s.t. } (0\\leq \\theta \\leq \\pi)\n\\]\nであることから\n\\[\n\\begin{align}\n||\\pmb a||^2\\,||\\pmb b||^2\\sin^2\\theta\n    =& ||\\pmb a||^2\\,||\\pmb b||^2 (1 - \\cos^2\\theta)\\\\\n    =& ||\\pmb a||^2\\,||\\pmb b||^2 - (\\pmb a, \\pmb b)^2\\\\\n    =& (a_1^2 + a_2^2 + a_3^2)(b_1^2 + b_2^2 + b_3^2) - (a_1b_1 + a_2b_2 + a_3b_3)^2\\\\\n    =& a_2^2b_3^2 + a_3^2b_2^2 + a_1^2b_3^2 + a_3^2b_1^2 + a_1^2b_2^2 + a_2^2b_1^2\\\\\n     & - 2(a_2a_3b_2b_3 + a_1a_3b_1b_3+ a_1a_2b_1b_2)\n\\end{align}\n\\]\n従って，\n\\[\n||\\pmb a\\times \\pmb b||^2 = ||\\pmb a||^2\\,||\\pmb b||^2\\sin^2\\theta\n\\]\nこのとき，ノルムは0より大きく，\\(0\\leq \\theta \\leq \\pi\\) では \\(\\sin^2\\theta \\geq 0\\) であるので\n\\[\n||\\pmb a\\times \\pmb b|| = ||\\pmb a||\\,||\\pmb b||\\sin \\theta\n\\]\n\n\n\n ▶  Key Takeaways\n\n上記の定理は２つの３次現実ベクトルの外積のノルムは，２つの３次現実ベクトルが成す平行四辺形の面積と等しいことを意味している\n外積を \\(\\displaystyle\\frac{1}{2}\\) 倍すると，２つの３次現実ベクトルが成す三角形の面積となります．\n\n\nExample 2 \n\\[\n\\begin{align}\n\\pmb a &= (3, 4)\\\\\n\\pmb b &= (5, 2)\n\\end{align}\n\\]\nと二次元ベクトルが与えられているとします．この２つのベクトルがなす三角形の面積は外積を応用すると以下のように計算できるはずです\n\\[\n\\begin{align}\n\\triangle ABO\n    &= \\frac{1}{2}\\sqrt{(0, 0, 3\\times 2 - (4 \\times 5))(0, 0, 3\\times 2 - (4 \\times 5))^T}\\\\\n    &=  7\n\\end{align}\n\\]\n\n上では二次元ベクトル \\((x, y)\\) を \\((x, y, 0)\\) とみなして計算しています\nただし，これは外積の説明というよりかは \\(2\\) 次正方行列の行列式がなぜ面積と対応するのかのほうが適切かも\n\n実際に Pythonで計算してみると\n\nCode\nimport matplotlib.pyplot as plt\nimport numpy as np\n# Define the two vectors\nvector1 = np.array([3, 4])  # Vector 1 (x, y)\nvector2 = np.array([5, 2])  # Vector 2 (x, y)\n\n# Define the origin\norigin = [0, 0]\n\n# Create the plot\nfig, ax = plt.subplots(figsize=(6, 6))\n\n# Plot the vectors\nax.quiver(*origin, vector1[0], vector1[1], angles='xy', scale_units='xy', scale=1, color='r', label='Vector 1')\nax.quiver(*origin, vector2[0], vector2[1], angles='xy', scale_units='xy', scale=1, color='b', label='Vector 2')\n\n# Plot the triangle\ntriangle_x = [0, vector1[0], vector2[0], 0]\ntriangle_y = [0, vector1[1], vector2[1], 0]\nax.fill(triangle_x, triangle_y, color='lightblue', alpha=0.5, label='Triangle')\n\n# Set plot limits\nax.set_xlim(-1, max(vector1[0], vector2[0]) + 1)\nax.set_ylim(-1, max(vector1[1], vector2[1]) + 1)\n\n# Add grid, labels, and legend\nax.grid()\nax.set_aspect('equal')\nax.set_xlabel('X-axis')\nax.set_ylabel('Y-axis')\nax.legend()\n\n# Add title\nax.set_title('2D Vectors and Triangle')\n\n# Show the plot\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 1\n\n\n\n\n\nCode\n## compute area\nfrom shapely import Polygon\ncoords = (origin, vector1, vector2)\npolygon = Polygon(coords)\n\nprint(f\"Area of triangle: {polygon.area}\")\n\n\nArea of triangle: 7.0\n\n\n\n\n\n外積の直交性\n\n\nTheorem 3 \n２つの２次元実ベクトル \\(\\pmb a, \\pmb b\\) について\n\\[\n(\\pmb a\\times \\pmb b, \\pmb a) = (\\pmb a\\times \\pmb b, \\pmb b) = 0\n\\]\nつまり，\n\\[\n\\begin{align}\n\\pmb a\\times \\pmb b \\perp \\pmb a\\\\\n\\pmb a\\times \\pmb b \\perp \\pmb a\n\\end{align}\n\\]\n\n\n\n\n\n\n\n\nNoteProof\n\n\n\n\n\n\\[\n\\begin{align}\n(\\pmb a\\times \\pmb b, \\pmb a)\n    &=  \\begin{vmatrix}\n    a_1 & a_2 & a_3\\\\\n    a_1 & a_2 & a_3\\\\\n    b_1 & b_2 & b_3\n    \\end{vmatrix} = 0\n\\end{align}\n\\]\n同様に\n\\[\n\\begin{align}\n(\\pmb a\\times \\pmb b, \\pmb b)\n    &=  \\begin{vmatrix}\n    b_1 & b_2 & b_3\\\\\n    a_1 & a_2 & a_3\\\\\n    b_1 & b_2 & b_3\n    \\end{vmatrix} = 0\n\\end{align}\n\\]\nなお途中の式変形は行列式の性質「\\(|A| = 0 \\Leftrightarrow \\text{各行ベクトルが一次従属}\\)」を用いている．\n\n\n\n ▶  Key Takeaways\n\n\\(\\pmb a\\times \\pmb b\\) のベクトルの方向は，\\(\\pmb a\\) から \\(\\pmb b\\) へ回転するときの右ねじが進む方向に対応すると言われる\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.mplot3d import Axes3D\n\n# Define the vectors\na = np.array([3, 1, 0])  # Vector b\nb = np.array([1, 2, 0])  # Vector a\n\n# Compute the outer product (cross product)\nouter_product = np.cross(a, b)\n\n# Create a 3D plot\nfig = plt.figure(figsize=(8, 8))\nax = fig.add_subplot(111, projection='3d')\n\n# Plot vector a\nax.quiver(0, 0, 0, a[0], a[1], a[2], color='r', label='Vector a', arrow_length_ratio=0.1)\n\n# Plot vector b\nax.quiver(0, 0, 0, b[0], b[1], b[2], color='b', label='Vector b', arrow_length_ratio=0.1)\n\n# Plot the outer product vector\nax.quiver(0, 0, 0, outer_product[0], outer_product[1], outer_product[2], color='g', label='a × b', arrow_length_ratio=0.1)\n\n# Plot the square\nparallelogram_x = [0, a[0], a[0] + b[0], b[0], 0]\nparallelogram_y = [0, a[1], a[1] + b[1], b[1], 0]\nparallelogram_z = [0, a[2], a[2] + b[2], b[2], 0]\nax.plot_trisurf(parallelogram_x, parallelogram_y, parallelogram_z, color='lightblue', alpha=0.5, label='||a × b||')\n\n\n\n\n# Set plot limits\nmax_range = max(np.linalg.norm(a), np.linalg.norm(b), np.linalg.norm(outer_product)) + 1\nax.set_xlim([-1, 6])\nax.set_ylim([-1, 6])\nax.set_zlim([-1, 6])\n\n# Add labels and legend\nax.set_xlabel('X-axis')\nax.set_ylabel('Y-axis')\nax.set_zlabel('Z-axis')\nax.legend()\n\n# Add title\nax.set_title('3D Vectors and Their Outer Product')\n\n# Tilt the plot\nax.view_init(elev=30, azim=-60) \n\n# Show the plot\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 2"
  },
  {
    "objectID": "posts/2025-04-09-vector-outer-product/index.html#appendix",
    "href": "posts/2025-04-09-vector-outer-product/index.html#appendix",
    "title": "ベクトル空間における外積",
    "section": "Appendix",
    "text": "Appendix\n\n\nLemma 1 \n第 \\(i\\) 行が，２つの行ベクトルの和である行列の行列式は，他の行は同じで第 \\(i\\) 行は各々のベクトルをとった行列の行列式となる．すなわち，\n\\[\n\\left|\n\\begin{array}{ccc}\na_{11} & \\cdots & a_{1n} \\\\\n\\vdots &        & \\vdots \\\\\nb_{i1} + c_{i1} & \\cdots & b_{in} + c_{in} \\\\\n\\vdots &        & \\vdots \\\\\na_{n1} & \\cdots & a_{nn}\n\\end{array}\n\\right|\n=\n\\left|\n\\begin{array}{ccc}\na_{11} & \\cdots & a_{1n} \\\\\n\\vdots &        & \\vdots \\\\\nb_{i1} & \\cdots & b_{in}\\\\\n\\vdots &        & \\vdots \\\\\na_{n1} & \\cdots & a_{nn}\n\\end{array}\n\\right|\n+\n\\left|\n\\begin{array}{ccc}\na_{11} & \\cdots & a_{1n} \\\\\n\\vdots &        & \\vdots \\\\\nc_{i1} & \\cdots & c_{in} \\\\\n\\vdots &        & \\vdots \\\\\na_{n1} & \\cdots & a_{nn}\n\\end{array}\n\\right|\n\\]\n\n\nLemma 1 より以下もわかります\n\\[\n\\left|\n\\begin{array}{ccc}\na_{11} & \\cdots & a_{1n} \\\\\n\\vdots &        & \\vdots \\\\\n\\lambda a_{i1} & \\cdots & \\lambda a_{in} \\\\\n\\vdots &        & \\vdots \\\\\na_{n1} & \\cdots & a_{nn}\n\\end{array}\n\\right|\n= \\lambda\n\\left|\n\\begin{array}{ccc}\na_{11} & \\cdots & a_{1n} \\\\\n\\vdots &        & \\vdots \\\\\na_{i1} & \\cdots & a_{in} \\\\\n\\vdots &        & \\vdots \\\\\na_{n1} & \\cdots & a_{nn}\n\\end{array}\n\\right|\\label{#eq-determinant-linear}\n\\]\n\n余因子と行列式\n\n\nDefinition 2 : 余因子(cofactor) \n\\(n\\) 次の正方行列 \\(A = (a_{ij})\\) から，その第 \\(i\\) 行と第 \\(j\\) 列を取り除いて得られる \\((n-1)\\) 次の正方行列を \\(A_{ij}\\) と表記するとします． このとき \\(a_{ij}\\) の余因子 \\(\\tilde{a}_{ij}\\) は以下のように定義される\n\\[\n\\tilde{a}_{ij} = (-1)^{i+j}|A_{ij}|\n\\]\nまたは\n\\[\n\\tilde{a}_{ij} = (-1)^{i+j}\n\\left|\n\\begin{array}{cccccc}\na_{11} & \\cdots & a_{1(j-1)} & a_{1(j+1)} & \\cdots & a_{1n} \\\\\n\\vdots &        & \\vdots     & \\vdots     &        & \\vdots \\\\\na_{(i-1)1} & \\cdots & \\cdots & \\cdots & \\cdots & a_{(i-1)n} \\\\\na_{(i+1)1} & \\cdots & \\cdots & \\cdots & \\cdots & a_{(i+1)n} \\\\\n\\vdots &        & \\vdots     & \\vdots     &        & \\vdots \\\\\na_{n1} & \\cdots & a_{n(j-1)} & a_{n(j+1)} & \\cdots & a_{nn}\n\\end{array}\n\\right|\n\\]\n\n\n\nExample 3 \n\\[r\nA = \\left(\\begin{array}{ccc}\n1 & 2 & 0\\\\\n3 & 5 & -1\\\\\n4 & 6 & 7\n\\end{array}\\right)\n\\]\nについて，\\(\\tilde{a}_{11}, \\tilde{a}_{12}, \\tilde{a}_{13}\\) はそれぞれ以下のように計算されます\n\\[\n\\begin{align}\n\\tilde{a}_{11} &= (-1)^2 \\left(\\begin{vmatrix}5 & -1\\\\6&7\\end{vmatrix}\\right) = 41\\\\\n\\tilde{a}_{12} &= (-1)^3 \\left(\\begin{vmatrix}3 & -1\\\\4&7\\end{vmatrix}\\right) = -25\\\\\n\\tilde{a}_{13} &= (-1)^4 \\left(\\begin{vmatrix}3 & 5\\\\4&6\\end{vmatrix}\\right) = -2\n\\end{align}\n\\]\n\n\n\n\nTheorem 4 : 行列式の展開 \n\\[\na_{i1}\\tilde a_{i1} + a_{i2}\\tilde a_{i2} + \\cdots + a_{in}\\tilde a_{in} = |A|\n\\]\n\n\n\n\n\n\n\n\n\nNoteProof\n\n\n\n\n\n与えられた行列 \\(A = (a_{ij})\\) の第 \\(i\\) 行は\n\\[\n(a_{i1}, \\cdots, a_{in}) = (a_{i1}, 0, \\cdots, 0) + (0, a_{i2}, \\cdots, 0) \\cdots + (0, \\cdots, 0, a_{in})\n\\]\nと線型結合で表せるので，Lemma 1 より\n\\[\n|A|\n=\n\\left|\n\\begin{array}{cccc}\na_{11} &\\cdots & \\cdots & a_{1n} \\\\\n\\vdots & &       & \\vdots \\\\\na_{11} & 0 & \\cdots & 0 \\\\\n\\vdots &      &  & \\vdots \\\\\na_{n1} &\\cdots &\\cdots & a_{nn}\n\\end{array}\n\\right|\n+\n\\left|\n\\begin{array}{cccc}\na_{11} &\\cdots & \\cdots & a_{1n} \\\\\n\\vdots & &       & \\vdots \\\\\n0 & a_{12} & 0 \\cdots & 0 \\\\\n\\vdots &      &  & \\vdots \\\\\na_{n1} &\\cdots &\\cdots & a_{nn}\n\\end{array}\n\\right|\n+ \\cdots +\n\\left|\n\\begin{array}{cccc}\na_{11} &\\cdots & \\cdots & a_{1n} \\\\\n\\vdots & &       & \\vdots \\\\\n0 & \\cdots& \\cdots 0 & a_{in} \\\\\n\\vdots &      &  & \\vdots \\\\\na_{n1} &\\cdots &\\cdots & a_{nn}\n\\end{array}\n\\right|\\label{#eq-additive}\n\\]\nRHSの第 \\(j\\) 番目の行列式の計算を考える．このとき，行を１つ交換するたびに行列式は \\(-1\\) 倍されることから\n\\[\n\\left|\n\\begin{array}{ccccc}\na_{11} &\\cdots &\\cdots& \\cdots & a_{1n} \\\\\n\\vdots & &   &    & \\vdots \\\\\n0 & \\cdots  &a_{ij} & \\cdots & 0 \\\\\n\\vdots &   &   &  & \\vdots \\\\\na_{n1} &\\cdots &\\cdots &\\cdots & a_{nn}\n\\end{array}\n\\right|\n=\n(-1)^{i-1}\n\\left|\n\\begin{array}{ccccc}\n0 & \\cdots  &a_{ij} & \\cdots & 0 \\\\\na_{11} &\\cdots &\\cdots& \\cdots & a_{1n} \\\\\n\\vdots & &   &    & \\vdots \\\\\n\\vdots &   &   &  & \\vdots \\\\\na_{n1} &\\cdots &\\cdots &\\cdots & a_{nn}\n\\end{array}\n\\right|\n\\]\n列を１つ交換するたびに行列式は \\(-1\\) 倍されることから\n\\[\n\\left|\n\\begin{array}{ccccc}\n0 & \\cdots  &a_{ij} & \\cdots & 0 \\\\\na_{11} &\\cdots &\\cdots& \\cdots & a_{1n} \\\\\n\\vdots & &   &    & \\vdots \\\\\n\\vdots &   &   &  & \\vdots \\\\\na_{n1} &\\cdots &\\cdots &\\cdots & a_{nn}\n\\end{array}\n\\right|\n=\n(-1)^{j-1}\n\\left|\n\\begin{array}{ccccc}\na_{ij} &0 & \\cdots & \\cdots & 0 \\\\\na_{1j} &a_{11} &\\cdots & \\cdots & a_{1n} \\\\\n\\vdots &\\vdots & &       & \\vdots \\\\\n\\vdots &\\vdots &   &     & \\vdots \\\\\na_{nj} &a_{n1} &\\cdots  &\\cdots & a_{nn}\n\\end{array}\n\\right|\n\\]\n従って，\n\\[\n\\begin{align}\n\\left|\n\\begin{array}{ccccc}\na_{11} &\\cdots &\\cdots& \\cdots & a_{1n} \\\\\n\\vdots & &   &    & \\vdots \\\\\n0 & \\cdots  &a_{ij} & \\cdots & 0 \\\\\n\\vdots &   &   &  & \\vdots \\\\\na_{n1} &\\cdots &\\cdots &\\cdots & a_{nn}\n\\end{array}\n\\right|\n&= (-1)^{i+j-2}\na_{ij}\n\\left|\n\\begin{array}{cccc}\na_{11} &\\cdots & \\cdots & a_{1n} \\\\\n\\vdots & &       & \\vdots \\\\\n\\vdots &   &     & \\vdots \\\\\na_{n1} &\\cdots  &\\cdots & a_{nn}\n\\end{array}\n\\right|\\\\\n&= (-1)^{i+j-2} a_{ij}|A_{ij}|\\\\\n&= a_{ij}(-1)^{i+j-2}|A_{ij}|\\\\\n&= a_{ij}\\tilde a_{ij}\n\\end{align}\n\\]\n\\(\\eqref{#eq-additive}\\) より\n\\[\n|A| = \\sum_{j=1}^na_{ij}\\tilde a_{ij}\n\\]"
  },
  {
    "objectID": "posts/2025-07-30-POSIX-File-end-with-newline/index.html",
    "href": "posts/2025-07-30-POSIX-File-end-with-newline/index.html",
    "title": "なぜテキストファイルは改行で終わるべきなのか？",
    "section": "",
    "text": "Definition 1 3.195 Incomplete Line\n\nA sequence of one or more non-&lt;newline&gt; characters at the end of the file.\n\n\n\nDefinition 2 3.206 Line\n\nA sequence of zero or more non-&lt;newline&gt; characters plus a terminating &lt;newline&gt; character.\nLineとは，1つ以上の &lt;newline&gt; 文字以外の文字と，行末の &lt;newline&gt; 文字によって成り立つ\n\n\n多くのUNIX系のツールは Definition 2 に基づいており，改行文字で終わらない「行」は Definition 1 のように「行」とはみなされません．\nEditorと改行\n\n\n\n\n\n\n\nエディタ\n末尾の改行の挙動\n\n\n\n\nVS Code\n設定次第で自動追加 (files.insertFinalNewline)\n\n\nVim\nデフォルトで改行追加（:set nofixeol で抑制可）\n\n\nEmacs\nデフォルトで改行追加（require-final-newline 変数）\n\n\n\n\n\ncat でファイルを結合する場合，改行で終わるファイル (a.txt と c.txt) と改行で終わらないファイル (b.txt) では，結合時の挙動が異なります．\nまず，改行ありと改行なしの.txtファイルを生成します\n改行ありファイルの生成\n\nBashZsh\n\n\n#!/bin/bash\n\nwords=(foo bar baz)\nfiles=(a b c)\n\nfor i in \"${!words[@]}\"; do\n  echo \"${words[i]}\" &gt; \"${files[i]}.txt\"\ndone\n\n\n#!/bin/zsh\n\nwords=(foo bar baz)\nfiles=(a b c)\n\nfor i in {1..${#words[@]}}; do\n  echo \"${words[i]}\" &gt; \"${files[i]}.txt\"\ndone\n\n\n\n改行なしファイルの生成\n\nBashZsh\n\n\n#!/bin/bash\n\nwords=(foo bar baz)\nfiles=(a b c)\n\nfor i in \"${!words[@]}\"; do\n  printf \"%s\" \"${words[i]}\" &gt; \"${files[i]}_without_newline.txt\"\ndone\n\n\n#!/bin/zsh\n\nwords=(foo bar baz)\nfiles=(a b c)\n\nfor i in {1..${#words[@]}}; do\n  printf \"%s\" \"${words[i]}\" &gt; \"${files[i]}_without_newline.txt\"\ndone\n\n\n\nつぎに catコマンドで結合をしてみます．\ncat コマンドで結合\n\n改行ありファイル改行なしファイル\n\n\n% cat {a,b,c}.txt\nfoo\nbar\nbaz\n\n\n% cat {a,b,c}_without_newline.txt      \nfoobarbaz% \n\n\n\n\n\n\n\nDefinition 3 wc コマンドマニュアル\n\nA line is defined as a string of characters delimited by a &lt;newline&gt; character.\n\n\nwcコマンドは &lt;newline&gt; の数で行数を数えています．実際に\n## 改行なし\n$ echo -n \"Line not ending in a new line\" | wc -l\n0\n\n## 改行あり\n$ echo \"Line ending with a new line\" | wc -l\n1\n\nExample 1 結合ファイルとwcコマンド\n\n改行ありファイル改行なしファイル\n\n\n% cat {a,b,c}.txt | wc -l\n3\n\n\n% cat {a,b,c}_without_newline.txt | wc -l\n0"
  },
  {
    "objectID": "posts/2025-07-30-POSIX-File-end-with-newline/index.html#posix標準の考え方",
    "href": "posts/2025-07-30-POSIX-File-end-with-newline/index.html#posix標準の考え方",
    "title": "なぜテキストファイルは改行で終わるべきなのか？",
    "section": "",
    "text": "Definition 1 3.195 Incomplete Line\n\nA sequence of one or more non-&lt;newline&gt; characters at the end of the file.\n\n\n\nDefinition 2 3.206 Line\n\nA sequence of zero or more non-&lt;newline&gt; characters plus a terminating &lt;newline&gt; character.\nLineとは，1つ以上の &lt;newline&gt; 文字以外の文字と，行末の &lt;newline&gt; 文字によって成り立つ\n\n\n多くのUNIX系のツールは Definition 2 に基づいており，改行文字で終わらない「行」は Definition 1 のように「行」とはみなされません．\nEditorと改行\n\n\n\n\n\n\n\nエディタ\n末尾の改行の挙動\n\n\n\n\nVS Code\n設定次第で自動追加 (files.insertFinalNewline)\n\n\nVim\nデフォルトで改行追加（:set nofixeol で抑制可）\n\n\nEmacs\nデフォルトで改行追加（require-final-newline 変数）\n\n\n\n\n\ncat でファイルを結合する場合，改行で終わるファイル (a.txt と c.txt) と改行で終わらないファイル (b.txt) では，結合時の挙動が異なります．\nまず，改行ありと改行なしの.txtファイルを生成します\n改行ありファイルの生成\n\nBashZsh\n\n\n#!/bin/bash\n\nwords=(foo bar baz)\nfiles=(a b c)\n\nfor i in \"${!words[@]}\"; do\n  echo \"${words[i]}\" &gt; \"${files[i]}.txt\"\ndone\n\n\n#!/bin/zsh\n\nwords=(foo bar baz)\nfiles=(a b c)\n\nfor i in {1..${#words[@]}}; do\n  echo \"${words[i]}\" &gt; \"${files[i]}.txt\"\ndone\n\n\n\n改行なしファイルの生成\n\nBashZsh\n\n\n#!/bin/bash\n\nwords=(foo bar baz)\nfiles=(a b c)\n\nfor i in \"${!words[@]}\"; do\n  printf \"%s\" \"${words[i]}\" &gt; \"${files[i]}_without_newline.txt\"\ndone\n\n\n#!/bin/zsh\n\nwords=(foo bar baz)\nfiles=(a b c)\n\nfor i in {1..${#words[@]}}; do\n  printf \"%s\" \"${words[i]}\" &gt; \"${files[i]}_without_newline.txt\"\ndone\n\n\n\nつぎに catコマンドで結合をしてみます．\ncat コマンドで結合\n\n改行ありファイル改行なしファイル\n\n\n% cat {a,b,c}.txt\nfoo\nbar\nbaz\n\n\n% cat {a,b,c}_without_newline.txt      \nfoobarbaz% \n\n\n\n\n\n\n\nDefinition 3 wc コマンドマニュアル\n\nA line is defined as a string of characters delimited by a &lt;newline&gt; character.\n\n\nwcコマンドは &lt;newline&gt; の数で行数を数えています．実際に\n## 改行なし\n$ echo -n \"Line not ending in a new line\" | wc -l\n0\n\n## 改行あり\n$ echo \"Line ending with a new line\" | wc -l\n1\n\nExample 1 結合ファイルとwcコマンド\n\n改行ありファイル改行なしファイル\n\n\n% cat {a,b,c}.txt | wc -l\n3\n\n\n% cat {a,b,c}_without_newline.txt | wc -l\n0"
  },
  {
    "objectID": "posts/2025-07-30-POSIX-File-end-with-newline/index.html#git-trackingテキストファイルを対象に改行有無判定スクリプト",
    "href": "posts/2025-07-30-POSIX-File-end-with-newline/index.html#git-trackingテキストファイルを対象に改行有無判定スクリプト",
    "title": "なぜテキストファイルは改行で終わるべきなのか？",
    "section": "git trackingテキストファイルを対象に改行有無判定スクリプト",
    "text": "git trackingテキストファイルを対象に改行有無判定スクリプト\n\n\n\n\n\n\nNoteスクリプト全体\n\n\n\n以下のシェルスクリプトは，バイナリファイルを除外した上で，ファイル末尾の改行の有無をチェックするスクリプトです\ngit ls-files -z | while IFS= read -r -d '' file; do\n  file --mime \"${file}\" | grep -q -e \"charset=binary\" -e \"image/svg+xml\" ||\n  tail -c1 \"${file}\" | read -r _ ||\n  echo \"Missing newline: ${file}\"\ndone\n\n\nアルゴリズム\n\\begin{algorithm}\n\\caption{Checking Files for Missing Trailing Newlines}\n\\begin{algorithmic}\n\\State file\\_list \\(\\leftarrow\\) Get all Git-tracked files with NUL delimiter\n\\ForAll{file in file\\_list}\n    \\State mime\\_info \\(\\leftarrow\\) \\texttt{file --mime file}\n    \\If{mime\\_info contains \"charset=binary\" OR \"image/svg+xml\"}\n        \\State \\textbf{continue (skip binary/SVG files)}\n    \\Else\n        \\State last\\_byte \\(\\leftarrow\\) Get final byte of file\n        \\If{last\\_byte is not newline character}\n            \\State Output \"Missing newline: file\"\n        \\EndIf\n    \\EndIf\n\\EndFor\n\\end{algorithmic}\n\\end{algorithm}\n\n\n各コマンド\n\n\n\n\n\n\n\nコマンド\n説明\n\n\n\n\ngit ls-files -z\nGitで管理されているファイルを一覧表示-zオプションで区切り文字としてNUL文字を使用（ファイル名に特殊文字が含まれる場合の安全な処理のため）\n\n\nwhile IFS= read -r -d '' file\nNUL文字を区切りとしてファイルを順次処理IFS=で空白文字の保持-rでバックスラッシュの解釈を防止-d ''：read でヌル文字区切りに対応\n\n\nfile --mime \"${file}\" | grep -q -e \"charset=binary\" -e \"image/svg+xml\" ||\nバイナリファイルとSVGファイルをスキップテキストファイルのみを処理||は「このコマンドが失敗した場合に次のコマンドを実行」を意味\n\n\ntail -c1 \"${file}\" | read -r _ ||\nファイルの最後の1バイトをチェックreadは改行があれば0，なければ1を返す\n\n\necho \"Missing newline: ${file}\"\n改行のないファイルを報告\n\n\n\n\nExample 2 カレントディレクトリ以下のファイルに対しての改行判定スクリプト\n#!/bin/bash\nfind . -maxdepth 1 -type f -print0 | while IFS= read -r -d '' file; do \n  file --mime \"${file}\" | grep -q -e \"charset=binary\" -e \"image/svg+xml\" ||\n  tail -c1 \"${file}\" | read -r _ ||\n  echo \"Missing newline: ${file}\"\ndone\n\n-print0: 各ファイル名の末尾に NUL文字 (\\0) を付けて出力\n\n\n\n\n改行なしと判定されたファイルに対して&lt;newline&gt;を付与する\n\n\n\n\n\n\nNoteシェルスクリプト\n\n\n\nfind . -maxdepth 1 -type f -print0 | while IFS= read -r -d '' file; do\n  # バイナリファイルやSVGはスキップ\n  file --mime \"$file\" | grep -q -e \"charset=binary\" -e \"image/svg+xml\" && continue\n\n  # 最後の1バイトを確認（改行がないなら）\n  if ! tail -c1 \"$file\" | read -r _; then\n      echo &gt;&gt; \"$file\"; echo \"✓ Newline added to: $file\"\n  fi\ndone\n\n\n\necho &gt;&gt; \"$file\" で&lt;newline&gt;を行末に追加"
  },
  {
    "objectID": "posts/2025-07-30-POSIX-File-end-with-newline/index.html#改行忘れの対策",
    "href": "posts/2025-07-30-POSIX-File-end-with-newline/index.html#改行忘れの対策",
    "title": "なぜテキストファイルは改行で終わるべきなのか？",
    "section": "改行忘れの対策",
    "text": "改行忘れの対策\n\n.editorconfigの用いた改行設定\nEditorConfigとは?\n\nコードスタイル（インデントや改行コードなど）を統一するための設定ファイルの仕組み\n異なるエディタ・OS間でのコードスタイルを統一させたいときに便利なツール\n\nEditorConfigによる改行設定例\n\n\n\n\n\n\n\n\n\nプロパティ名\n内容\n例\n\n\n\n\nindent_style\nインデントの種類（space または tab）\nindent_style = space\n\n\nindent_size\nインデントの幅\nindent_size = 4\n\n\nend_of_line\n改行コード（lf/crlf/cr）\nend_of_line = lf\n\n\ncharset\n文字コード\ncharset = utf-8\n\n\ntrim_trailing_whitespace\n行末の空白を削除するか\ntrim_trailing_whitespace = true\n\n\ninsert_final_newline\n最終行の末尾に改行を追加するか\ninsert_final_newline = true\n\n\n\n\n# .editorconfig\n\n# このファイルが設定のルートであることを示す\nroot = true\n\n# すべてのファイルに適用\n[*]\nindent_style = space\nindent_size = 4\nend_of_line = lf\ncharset = utf-8\ntrim_trailing_whitespace = true\ninsert_final_newline = true\n\n\nVSCodeでの改行設定\nsettings.jsonで以下の項目を追加します\n{\n  // Editor Settings\n  \"files.insertFinalNewline\": true,\n  \"notebook.insertFinalNewline\": true\n}\n\n\n\n\n\n\n\n\n設定キー\n意味\n\n\n\n\n\"files.insertFinalNewline\": true\nファイル保存時に、末尾に改行を自動で追加します（通常の .txt, .js, .py などすべて対象）\n\n\n\"notebook.insertFinalNewline\": true\nJupyter Notebook（.ipynb）などのノートブック形式のファイルにおいて、セル内のソースに末尾改行を追加する設定（拡張機能依存）"
  },
  {
    "objectID": "posts/2025-07-30-POSIX-File-end-with-newline/index.html#appendix-改行コードの種類",
    "href": "posts/2025-07-30-POSIX-File-end-with-newline/index.html#appendix-改行コードの種類",
    "title": "なぜテキストファイルは改行で終わるべきなのか？",
    "section": "Appendix: 改行コードの種類",
    "text": "Appendix: 改行コードの種類\n\n\n\n\n\n\n\n\n\n\n\n\n改行コード\n記号\n名称\n主なOS\nバイナリ表現\n説明\n\n\n\n\nLF\n\\n\nLine Feed（行送り）\nLinux / macOS（Unix系）\n0x0A\n行末で「次の行の先頭」に移動\n\n\nCRLF\n\\r\\n\nCarriage Return + Line Feed\nWindows\n0x0D 0x0A\n行頭に戻りつつ次の行へ（古いタイプライタ由来）\n\n\nCR\n\\r\nCarriage Return（復帰）\n古いMac OS（〜OS9）\n0x0D\n行頭に戻るだけ（現在はほぼ使われない）\n\n\n\n\n歴史的背景\nタイプライターの動きと対応させると改行には３つの考え方がありました\n\nLF は紙を上に移動させ (水平方向の位置は変わらない)\nCR は「キャリッジ」を戻して，次の入力文字が紙の左端の同じ行に表示\nCR+LF は両方を実行し，新しい行の入力準備"
  },
  {
    "objectID": "posts/2025-07-30-POSIX-File-end-with-newline/index.html#references",
    "href": "posts/2025-07-30-POSIX-File-end-with-newline/index.html#references",
    "title": "なぜテキストファイルは改行で終わるべきなのか？",
    "section": "References",
    "text": "References\n\nPOSIX standard\nEditorConfig"
  },
  {
    "objectID": "posts/2025-02-03-continuous-function/index.html",
    "href": "posts/2025-02-03-continuous-function/index.html",
    "title": "関数の連続性",
    "section": "",
    "text": "変数 \\(x\\) が限りなく \\(a\\) に近づくとき，\\(f(x)\\) も \\(f(a)\\) に近づくならば，\\(f(x)\\) は \\(x=a\\) において連続である，といいます．つまり，\n\\[\nx\\to a \\text{ ならば } f(x) \\to f(a)\n\\]\n\nDef: \\(\\epsilon\\)-\\(\\delta\\) 論法的連続性 \n任意の \\(\\epsilon &gt;0\\) に対して，ある \\(\\delta &gt; 0\\) が存在して，\n\\[\n\\vert x - a \\vert &lt; \\delta \\Rightarrow \\vert f(x) - f(a)\\vert &lt; \\epsilon\n\\]\nを満たすとき，\\(x=a\\) において \\(f(x)\\) は連続であるという．\n\n\nExample 1 \n\\(f(x) = \\sqrt{x}\\) について，\\(a &gt; 0\\) で連続であることを以下示します．\n\\[\n\\begin{align}\n\\vert \\sqrt{x} - \\sqrt{a} \\vert\n    &= \\left\\vert\\frac{(\\sqrt{x} - \\sqrt{a})(\\sqrt{x} + \\sqrt{a})}{\\sqrt{x}+\\sqrt{a}}\\right\\vert\\\\\n    &= \\left\\vert\\frac{x - a}{\\sqrt{x}+\\sqrt{a}}\\right\\vert\\\\\n    &\\leq \\left\\vert\\frac{x - a}{\\sqrt{a}}\\right\\vert\n\\end{align}\n\\]\nここで，\\(\\vert x - a\\vert &lt; \\delta(\\epsilon) = \\epsilon\\sqrt{a}\\) と定めると\n\\[\n\\vert x - a\\vert &lt; \\delta(\\epsilon) \\Rightarrow \\vert \\sqrt{x} - \\sqrt{a}\\vert &lt; \\epsilon\n\\]\n\n\n\nExample 2 : 三角関数の連続性 \n\\(x = a + h\\) とおくと，和積の公式を用いて\n\\[\n\\begin{align}\n\\vert \\sin(x) - \\sin(a) \\vert\n    &= 2\\left\\vert \\cos\\frac{x+a}{2}\\sin\\frac{x-a}{2} \\right\\vert\\\\\n    &= 2\\left\\vert \\cos\\left(a + \\frac{h}{2}\\right)\\sin\\frac{h}{2} \\right\\vert\\\\\n    &\\leq 2\\left\\vert\\frac{h}{2}\\right\\vert \\cdot 1\\\\\n    &=\\vert h \\vert\n\\end{align}\n\\]\n\\(\\cos x = \\sin\\left(x + \\frac{\\pi}{2}\\right)\\) であるので，\\(\\sin x\\) が連続であるならば, \\(\\cos x\\) も連続．\n\n\n\n\nTheorem 1  : 連続関数の定数倍\n\\(f(x)\\) は \\(x=a\\) で連続であるとします．このとき，定数 \\(c\\) を用いた \\(cf(x)\\) も \\(x=a\\) にて連続となります．\n\n\n\n\n\n\n\n\n\nNoteProof\n\n\n\n\n\n仮定より\n\\[\n\\forall \\eta &gt; 0, \\exists \\delta(\\eta) &gt; 0, \\vert x - a\\vert &lt; \\delta(\\eta)\\Rightarrow\\vert f(x) - f(a)\\vert &lt; \\eta\n\\]\nこのとき，任意の \\(\\epsilon &gt; 0\\) に対して，\n\\[\n\\eta = \\frac{\\epsilon}{\\vert c \\vert} &gt;0\n\\]\nと対応させると，\n\\[\n\\forall \\epsilon &gt; 0, \\exists \\delta(\\epsilon) &gt; 0, \\vert x - a\\vert &lt; \\delta(\\epsilon)\\Rightarrow\\vert f(x) - f(a)\\vert &lt; \\frac{\\epsilon}{\\vert c \\vert }\n\\]\nつまり，\n\\[\n\\forall \\epsilon &gt; 0, \\exists \\delta(\\epsilon) &gt; 0, \\vert x - a\\vert &lt; \\delta(\\epsilon)\\Rightarrow \\vert c\\vert\\vert f(x) - f(a)\\vert &lt; \\epsilon\n\\]\nこれを変形すると\n\\[\n\\forall \\epsilon &gt; 0, \\exists \\delta(\\epsilon) &gt; 0, \\vert x - a\\vert &lt; \\delta(\\epsilon)\\Rightarrow \\vert cf(x) - cf(a)\\vert &lt; \\epsilon\n\\]\n\n\n\n\n\nTheorem 2 : 連続関数の和\n\n\\(f(x), g(x)\\) は \\(x=a\\) で連続であるとします．このとき，\\(f(x) + g(x)\\) も \\(x=a\\) にて連続となります．\n\n\n\n\n\n\n\n\n\nNoteProof\n\n\n\n\n\n仮定より\n\\[\n\\begin{align}\n\\vert x - a \\vert &lt; \\delta&\\Rightarrow \\vert f(x) - f(a)\\vert &lt; \\epsilon/2\\\\\n\\vert x - a \\vert &lt; \\eta&\\Rightarrow \\vert g(x) - g(a)\\vert &lt; \\epsilon/2\n\\end{align}\n\\]\nここで，\\(M = \\min(\\delta, \\eta)\\) とすると，\n\\[\n\\begin{align}\n\\vert x - a \\vert &lt; M&\\Rightarrow \\vert f(x) - f(a)\\vert &lt; \\epsilon/2\\\\\n\\vert x - a \\vert &lt; M&\\Rightarrow \\vert g(x) - g(a)\\vert &lt; \\epsilon/2\n\\end{align}\n\\]\nまた\n\\[\n\\begin{align}\n\\vert(f(x) - g(x)) - (f(a) + g(a))\n    &= \\vert(f(x) - f(a)) + (g(x) + g(a))\\vert\\\\\n    &\\leq \\vert(f(x) - f(a))\\vert + \\vert (g(x) + g(a))\\vert\n\\end{align}\n\\]\n従って，\\(\\vert x - a \\vert &lt; M\\) であるならば\n\\[\n\\begin{align}\n\\vert (g(x) + f(x)) - (g(a) + f(a))\\vert \\leq \\vert(f(x) - f(a))\\vert + \\vert (g(x) + g(a))\\vert &lt; \\epsilon\n\\end{align}\n\\]\n\n\n\n\n\nTheorem 3  : 連続関数の線型結合\n\\(f(x), g(x)\\) は \\(x=a\\) で連続であるとします．このとき，定数 \\(c_1, c_2\\)に対して \\(c_1f(x) + c_2g(x)\\) も \\(x=a\\) にて連続となります．\n\n\n\n\n\n\n\n\n\nNoteProof\n\n\n\n\n\n\\[\n\\begin{align}\n\\vert x - a \\vert &lt; \\delta&\\Rightarrow \\vert f(x) - f(a)\\vert &lt; \\frac{\\epsilon}{2\\vert c_1\\vert}\\\\\n\\vert x - a \\vert &lt; \\eta&\\Rightarrow \\vert g(x) - g(a)\\vert &lt; \\frac{\\epsilon}{2\\vert c_2\\vert}\n\\end{align}\n\\]\nとして，\\(M = \\min(\\delta, \\eta)\\) とすれば，上記と同様に連続性を示すことができます．\n\n\n\n\n\nTheorem 4  : 連続関数の積\n\\(f(x), g(x)\\) は \\(x=a\\) で連続であるとします．このとき，\\(f(x)g(x)\\) も \\(x=a\\) にて連続となります．\n\n\n\n\n\n\n\n\n\nNoteProof\n\n\n\n\n\n\\[\n\\vert x - a \\vert &lt; \\delta(1) \\Rightarrow \\vert f(x) - f(a)\\vert &lt; 1\n\\]\nとすると，\n\\[\n\\vert x - a \\vert &lt; \\delta(1) \\Rightarrow \\vert f(x) \\vert &lt; 1 + \\vert f(a) \\vert\n\\]\n\\(\\delta, \\eta\\) を以下のように定め，\n\\[\n\\begin{align}\n\\vert x - a \\vert &lt; \\delta &\\Rightarrow \\vert f(x) - f(a)\\vert &lt; \\frac{\\epsilon}{2(1 + \\vert f(a) \\vert + \\vert g(a) \\vert)}\\\\\n\\vert x - a \\vert &lt; \\eta &\\Rightarrow \\vert g(x) - g(a)\\vert &lt; \\frac{\\epsilon}{2(1 + \\vert f(a) \\vert + \\vert g(a) \\vert)}\n\\end{align}\n\\]\n\\[\n\\delta(\\epsilon) = \\min (\\delta(1), \\delta, \\eta)\n\\]\nとすると，\n\\[\n\\begin{align}\n\\vert x - a \\vert &lt; \\delta(\\epsilon)\n    \\Rightarrow &\\vert f(x)g(x) - f(a)g(a)\\vert\\\\[5pt]\n    &= \\vert f(x)(g(x) - g(a)) + g(a)(f(x) - f(a))\\vert\\\\[5pt]\n    &\\leq \\vert f(x)\\vert \\vert(g(x) - g(a))\\vert + \\vert g(a)\\vert\\vert(f(x) - f(a))\\vert\\\\[5pt]\n    &&lt; (1 + \\vert f(a) \\vert)\\frac{\\epsilon}{2(1 + \\vert f(a) \\vert + \\vert g(a) \\vert)} + \\vert g(a)\\vert \\frac{\\epsilon}{2(1 + \\vert f(a) \\vert + \\vert g(a) \\vert)}\\\\\n    &= \\epsilon\n\\end{align}\n\\]\nよって，連続性が示された．\n\n\n\n\n\nTheorem 5  連続関数の逆数 \n\\(f(x)\\) は \\(x=a\\) で連続であるとします．このとき，\\(f(a)\\neq 0\\) であるならば \\(1/f(x)\\) も \\(x=a\\) にて連続となります．\n\n\n\n\n\n\n\n\n\nNoteProof\n\n\n\n\n\n連続性の仮定より\n\\[\n\\vert x - a \\vert &lt; \\delta(\\vert f(a)/2\\vert) \\Rightarrow \\vert f(x) - f(a)\\vert &lt; \\frac{\\vert f(a)\\vert}{2}\n\\]\nとすると，\n\\[\n\\vert x - a \\vert &lt; \\delta(\\vert f(a)/2\\vert) \\Rightarrow \\frac{\\vert f(a)\\vert}{2} &lt; \\vert f(x)\\vert\n\\]\nこのとき，\n\\[\n\\begin{align}\n\\left\\vert \\frac{1}{f(x)} - \\frac{1}{f(a)} \\right\\vert\n    &= \\left\\vert \\frac{f(x) - f(a)}{f(x)f(a)} \\right\\vert\\\\\n    &&lt; \\left\\vert \\frac{f(x) - f(a)}{(f(a))^2 / 2} \\right\\vert\n\\end{align}\n\\]\n従って，\\(\\vert x - a \\vert &lt; \\eta \\Rightarrow \\vert f(x) - f(a)\\vert &lt; \\displaystyle\\frac{\\epsilon\\vert (f(a))^2\\vert}{2}\\) となるような \\(\\eta\\) を用いて，\n\\[\n\\delta(\\epsilon) = \\min(\\delta(\\vert f(a)/2\\vert), \\eta)\n\\]\nとすれば\n\\[\n\\vert x - a \\vert &lt; \\delta(\\epsilon) \\Rightarrow \\left\\vert \\frac{1}{f(x)} - \\frac{1}{f(a)} \\right\\vert &lt; \\epsilon\n\\]\n\n\n\n\n\n点 \\(a\\) における極限を考えるとき，\n\n\\(x\\) が増大しつつ \\(a\\) に（左側から）近づく, \\(\\lim_{x\\to a-0}\\)\n\\(x\\) が減少しつつ \\(a\\) に（右側から）近づく, \\(\\lim_{x\\to a+0}\\)\n\nそれぞれの場合を分けて取り扱うことがあります．\n\nExample 3 \n\\(f(x) = \\tan x\\) について，\\(x = \\pi/2\\) における極限を考えてみます．\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport sympy as sy\n\nx = sy.Symbol('x')\nf = sy.tan(x)\n\nx_vals = np.linspace(-np.pi/2+1e-6, np.pi, 400)\ny_vals = np.tan(x_vals)\n\nplt.figure(figsize=(8, 6))\nplt.plot(x_vals, y_vals, label=r'$f(x) = \\tan(x)$')\nplt.ylim(-10, 10)\nplt.xticks([-np.pi/2, 0, np.pi/2, np.pi], [r'$-\\frac{\\pi}{2}$', '0', r'$\\frac{\\pi}{2}$', r'$\\pi$'])\nplt.axvline(np.pi/2, color='r', linestyle='--', label=r'$x = \\frac{\\pi}{2}$')\nplt.axhline(0, color='black',linewidth=0.5)\nplt.axvline(0, color='black',linewidth=0.5)\nplt.title(r'Plot of $f(x) = \\tan(x)$ around $x = \\frac{\\pi}{2}$')\nplt.xlabel('x')\nplt.ylabel('f(x)')\nplt.legend()\nplt.grid(True)\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 1\n\n\n\n上記の図のように，\n\\[\n\\begin{align}\n\\lim_{x\\to \\pi/2+0} \\tan x &= -\\infty\\\\\n\\lim_{x\\to \\pi/2-0} \\tan x &= \\infty\n\\end{align}\n\\]\n実際に，sympy で確認してみると\n\n# DO NOT USE np.pi\nprint(f\"左極限: {sy.limit(sy.tan(x), x, sy.pi/2, '-')}\")\nprint(f\"右極限: {sy.limit(sy.tan(x), x, sy.pi/2, '+')}\")\n\n左極限: oo\n右極限: -oo\n\n\n\n\n ▶  右連続と左連続\n\\[\n\\begin{align}\nf(a) &= \\alpha\\\\[5pt]\n\\lim_{x\\to a-0} f(x) &= \\alpha\\\\\n\\lim_{x\\to a+0} f(x) &= \\beta \\neq \\alpha\n\\end{align}\n\\]\nのとき，\\(f(x)\\) は \\(x = a\\) において左連続といいます．\n\\(f(x)\\) が閉区間 \\([a, b]\\) において定義されているとき，\n\n\\(x=a\\) においては右連続\n\\(x=b\\) においては左連続\n\nであることを意味します．開区間 \\((a, b)\\) において定義されているとき，\\(f(a+0)\\) が確定ならば，それを \\(f(a)\\) として定義域を \\([a, b)\\) 区間に拡張すると \\(f(x)\\) は \\(x=a\\) において右連続になります．\n一方，\\((0, \\infty)\\) 区間で定義された関数 \\(\\displaystyle f(x) = \\frac{1}{x}\\) は開区間では連続ですが，\\(x = 0\\) のときは定義されません．このとき，\\(f(0) = 0\\) として定義域を \\([0, \\infty)\\) に拡張すると，\\(x=0\\) で連続な関数にはなりませんし，\\(f(0)\\) をどんな値にしたとしても，\\(x=0\\) の近傍において, \\(f(x)\\) はいくらでも大きくなってしまうので，連続な関数にはなりません．\n\n📘 REMARKS \n\n開区間 \\((a, b)\\) で定義された連続な関数が，開区間 \\([a, b]\\) の連続な関数に拡張できるとは限らない\n\n\n\nExample 4  : 右連続関数と累積分布関数 \n離散確率変数 \\(X\\sim\\operatorname{Bin}(5, 1/3)\\) を考えます．離散確率変数の累積分布関数 \\(F(x)\\) は\n\\[\nF(x) = \\operatorname{P}(X \\leq x) = \\sum_{y\\leq x}p(y) \\qquad p(y): \\text{確率関数}\n\\]\nと定義されるので，\\(F(x)\\) は右側連続となります．実際に\n\nCode\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom scipy.stats import binom\n\nn, p = 5, 1 / 3\nx = np.arange(0, 6)\ncdf = binom.cdf(x, n, p)\n\nfig, ax = plt.subplots(1, 1)\nax.hlines(cdf, x, x + 1, color=\"gray\")\nax.step(x, cdf, where=\"post\", color=\"gray\", linestyle=\"dotted\")\nax.plot(x, cdf, \"o\", color=\"gray\")\nax.scatter(x[:-1] + 1, cdf[:-1], marker=\"$\\u25EF$\", alpha=0.5, color=\"gray\")\nax.set_xlabel(\"x\")\nax.set_ylabel(\"F(x)\")\nax.set_title(\"CDF of Binomial Distribution (n=5, p=1/3)\")\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 2\n\n\n\nこのとき，確率関数は\n\\[\np(x) = F(x) - \\lim_{x_n\\to x-0}F(x_n)\n\\]\nとすることで計算することが出来ます．一方，\\(F(x) = \\operatorname{P}(X &lt; x)\\) と定義すると左連続となります．\n\n\n\n\n\n\\[\nf(x) = \\frac{\\sin x}{x}\n\\]\nを考えます．この関数は \\(x - 0\\) で定義されていないですが\n\\[\n\\begin{align}\nf(x) = \\left\\{\\begin{array}{c}\n\\frac{\\sin x}{x} & (x\\neq 0)\\\\\n1 & (x = 0)\n\\end{array}\\right.\n\\end{align}\n\\]\nと \\(x = 0\\) で連続かつ微分可能になるように拡張することが出来ます．この拡張された関数を特にsinc関数と呼びます．\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Define the sinc function\ndef sinc(x):\n    return np.sinc(x / np.pi)\n\ndef inverse_x(x):\n    return 1/x\n\n# Generate x values\nx_vals = np.linspace(-10*np.pi, 10*np.pi, 400)\ny_vals = sinc(x_vals)\n\n# Plot the sinc function\nplt.figure(figsize=(8, 6))\nplt.plot(x_vals, y_vals, label=r'$f(x) = \\frac{\\sin(x)}{x}$')\nplt.plot(x_vals, inverse_x(x_vals), label=r'$f(x) = \\frac{1}{x}$')\nplt.xticks(np.arange(-10*np.pi, 11*np.pi, np.pi), \n           [r'$-10\\pi$', r'$-9\\pi$', r'$-8\\pi$', r'$-7\\pi$', r'$-6\\pi$', r'$-5\\pi$', r'$-4\\pi$', r'$-3\\pi$', r'$-2\\pi$', r'$-\\pi$', '0', r'$\\pi$', r'$2\\pi$', r'$3\\pi$', r'$4\\pi$', r'$5\\pi$', r'$6\\pi$', r'$7\\pi$', r'$8\\pi$', r'$9\\pi$', r'$10\\pi$'])\nplt.axhline(0, color='black',linewidth=0.5)\nplt.axvline(0, color='black',linewidth=0.5)\nplt.title(r'Plot of $f(x) = \\frac{\\sin(x)}{x}$')\nplt.xlabel('x')\nplt.ylabel('f(x)')\nplt.ylim(-1.1, 1.1)\nplt.legend()\nplt.grid(True)\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 3\n\n\n\n ▶  \\(x = 0\\)における連続性の証明\n\n\n\n\n\n\n\nNoteProof\n\n\n\n\n\n偶関数の性質\n\\[\n\\frac{\\sin x}{x} = \\frac{\\sin -x}{-x}\n\\]\nより \\(0 &lt; x \\to +0\\) の場合を考えます．xy座標上に \\(O = (0, 0)，A = (1, 0)，B = (\\cos x, \\sin x)，C = (1, \\tan x)\\) という点をとったとき，\n\\[\n\\text{三角形}OAB \\subset \\text{扇形}OAB \\subset \\text{三角形}OAC\n\\]\nつまり\n\\[\n\\text{三角形}OAB\\text{の面積} \\leq \\text{扇形}OAB\\text{の面積} \\leq  \\text{三角形}OAC\n\\]\n従って，\n\\[\n\\begin{align}\n\\frac{\\sin x}{2} \\leq \\frac{x}{2} &lt; \\frac{\\tan x}{2}\n\\end{align}\n\\]\n両辺 を \\(\\sin ⁡x\\) で割って逆数をとると\n\\[\n\\begin{align}\n\\cos x \\leq \\frac{x\\sin x}{x} &lt; 1\n\\end{align}\n\\]\nここで，\\(x\\to +0\\) とすると，\\(\\cos x \\to 1\\) となり，はさみうちの原理より\n\\[\n\\lim_{x\\to+0}\\frac{\\sin x}{x} = 1\n\\]\n\n\n\n ▶  \\(x = 0\\)における微分可能性の証明\n\n\n\n\n\n\n\nNoteProof\n\n\n\n\n\n\\[\n\\begin{align}\n\\cos x \\leq \\frac{x\\sin x}{x} &lt; 1\n\\end{align}\n\\]\nが \\(-\\frac{\\pi}{2} \\leq x \\leq \\frac{\\pi}{2}\\) で成り立つので\n\\[\n0=\\lim_{x\\to0}\\frac{\\cos(x)-1}{x}\\le\\lim_{x\\to0}\\frac{\\frac{\\sin(x)}x-1}{x-0}\\le0\n\\]\n\\[\n\\begin{align}\n\\lim_{x\\to0}\\frac{1-\\cos(x)}x\n&=\\lim_{x\\to0}\\frac1x\\frac{\\sin^2(x)}{1+\\cos(x)}\\\\\n&=\\lim_{x\\to0}\\frac{\\sin(x)}x\\lim_{x\\to0}\\frac{\\sin(x)}{1+\\cos(x)}\\\\[6pt]\n&=1\\cdot0 = 0\n\\end{align}\n\\]\n従って，はさみうちの原理より \\(f^\\prime(0) = 0\\)"
  },
  {
    "objectID": "posts/2025-02-03-continuous-function/index.html#連続関数",
    "href": "posts/2025-02-03-continuous-function/index.html#連続関数",
    "title": "関数の連続性",
    "section": "",
    "text": "変数 \\(x\\) が限りなく \\(a\\) に近づくとき，\\(f(x)\\) も \\(f(a)\\) に近づくならば，\\(f(x)\\) は \\(x=a\\) において連続である，といいます．つまり，\n\\[\nx\\to a \\text{ ならば } f(x) \\to f(a)\n\\]\n\nDef: \\(\\epsilon\\)-\\(\\delta\\) 論法的連続性 \n任意の \\(\\epsilon &gt;0\\) に対して，ある \\(\\delta &gt; 0\\) が存在して，\n\\[\n\\vert x - a \\vert &lt; \\delta \\Rightarrow \\vert f(x) - f(a)\\vert &lt; \\epsilon\n\\]\nを満たすとき，\\(x=a\\) において \\(f(x)\\) は連続であるという．\n\n\nExample 1 \n\\(f(x) = \\sqrt{x}\\) について，\\(a &gt; 0\\) で連続であることを以下示します．\n\\[\n\\begin{align}\n\\vert \\sqrt{x} - \\sqrt{a} \\vert\n    &= \\left\\vert\\frac{(\\sqrt{x} - \\sqrt{a})(\\sqrt{x} + \\sqrt{a})}{\\sqrt{x}+\\sqrt{a}}\\right\\vert\\\\\n    &= \\left\\vert\\frac{x - a}{\\sqrt{x}+\\sqrt{a}}\\right\\vert\\\\\n    &\\leq \\left\\vert\\frac{x - a}{\\sqrt{a}}\\right\\vert\n\\end{align}\n\\]\nここで，\\(\\vert x - a\\vert &lt; \\delta(\\epsilon) = \\epsilon\\sqrt{a}\\) と定めると\n\\[\n\\vert x - a\\vert &lt; \\delta(\\epsilon) \\Rightarrow \\vert \\sqrt{x} - \\sqrt{a}\\vert &lt; \\epsilon\n\\]\n\n\n\nExample 2 : 三角関数の連続性 \n\\(x = a + h\\) とおくと，和積の公式を用いて\n\\[\n\\begin{align}\n\\vert \\sin(x) - \\sin(a) \\vert\n    &= 2\\left\\vert \\cos\\frac{x+a}{2}\\sin\\frac{x-a}{2} \\right\\vert\\\\\n    &= 2\\left\\vert \\cos\\left(a + \\frac{h}{2}\\right)\\sin\\frac{h}{2} \\right\\vert\\\\\n    &\\leq 2\\left\\vert\\frac{h}{2}\\right\\vert \\cdot 1\\\\\n    &=\\vert h \\vert\n\\end{align}\n\\]\n\\(\\cos x = \\sin\\left(x + \\frac{\\pi}{2}\\right)\\) であるので，\\(\\sin x\\) が連続であるならば, \\(\\cos x\\) も連続．\n\n\n\n\nTheorem 1  : 連続関数の定数倍\n\\(f(x)\\) は \\(x=a\\) で連続であるとします．このとき，定数 \\(c\\) を用いた \\(cf(x)\\) も \\(x=a\\) にて連続となります．\n\n\n\n\n\n\n\n\n\nNoteProof\n\n\n\n\n\n仮定より\n\\[\n\\forall \\eta &gt; 0, \\exists \\delta(\\eta) &gt; 0, \\vert x - a\\vert &lt; \\delta(\\eta)\\Rightarrow\\vert f(x) - f(a)\\vert &lt; \\eta\n\\]\nこのとき，任意の \\(\\epsilon &gt; 0\\) に対して，\n\\[\n\\eta = \\frac{\\epsilon}{\\vert c \\vert} &gt;0\n\\]\nと対応させると，\n\\[\n\\forall \\epsilon &gt; 0, \\exists \\delta(\\epsilon) &gt; 0, \\vert x - a\\vert &lt; \\delta(\\epsilon)\\Rightarrow\\vert f(x) - f(a)\\vert &lt; \\frac{\\epsilon}{\\vert c \\vert }\n\\]\nつまり，\n\\[\n\\forall \\epsilon &gt; 0, \\exists \\delta(\\epsilon) &gt; 0, \\vert x - a\\vert &lt; \\delta(\\epsilon)\\Rightarrow \\vert c\\vert\\vert f(x) - f(a)\\vert &lt; \\epsilon\n\\]\nこれを変形すると\n\\[\n\\forall \\epsilon &gt; 0, \\exists \\delta(\\epsilon) &gt; 0, \\vert x - a\\vert &lt; \\delta(\\epsilon)\\Rightarrow \\vert cf(x) - cf(a)\\vert &lt; \\epsilon\n\\]\n\n\n\n\n\nTheorem 2 : 連続関数の和\n\n\\(f(x), g(x)\\) は \\(x=a\\) で連続であるとします．このとき，\\(f(x) + g(x)\\) も \\(x=a\\) にて連続となります．\n\n\n\n\n\n\n\n\n\nNoteProof\n\n\n\n\n\n仮定より\n\\[\n\\begin{align}\n\\vert x - a \\vert &lt; \\delta&\\Rightarrow \\vert f(x) - f(a)\\vert &lt; \\epsilon/2\\\\\n\\vert x - a \\vert &lt; \\eta&\\Rightarrow \\vert g(x) - g(a)\\vert &lt; \\epsilon/2\n\\end{align}\n\\]\nここで，\\(M = \\min(\\delta, \\eta)\\) とすると，\n\\[\n\\begin{align}\n\\vert x - a \\vert &lt; M&\\Rightarrow \\vert f(x) - f(a)\\vert &lt; \\epsilon/2\\\\\n\\vert x - a \\vert &lt; M&\\Rightarrow \\vert g(x) - g(a)\\vert &lt; \\epsilon/2\n\\end{align}\n\\]\nまた\n\\[\n\\begin{align}\n\\vert(f(x) - g(x)) - (f(a) + g(a))\n    &= \\vert(f(x) - f(a)) + (g(x) + g(a))\\vert\\\\\n    &\\leq \\vert(f(x) - f(a))\\vert + \\vert (g(x) + g(a))\\vert\n\\end{align}\n\\]\n従って，\\(\\vert x - a \\vert &lt; M\\) であるならば\n\\[\n\\begin{align}\n\\vert (g(x) + f(x)) - (g(a) + f(a))\\vert \\leq \\vert(f(x) - f(a))\\vert + \\vert (g(x) + g(a))\\vert &lt; \\epsilon\n\\end{align}\n\\]\n\n\n\n\n\nTheorem 3  : 連続関数の線型結合\n\\(f(x), g(x)\\) は \\(x=a\\) で連続であるとします．このとき，定数 \\(c_1, c_2\\)に対して \\(c_1f(x) + c_2g(x)\\) も \\(x=a\\) にて連続となります．\n\n\n\n\n\n\n\n\n\nNoteProof\n\n\n\n\n\n\\[\n\\begin{align}\n\\vert x - a \\vert &lt; \\delta&\\Rightarrow \\vert f(x) - f(a)\\vert &lt; \\frac{\\epsilon}{2\\vert c_1\\vert}\\\\\n\\vert x - a \\vert &lt; \\eta&\\Rightarrow \\vert g(x) - g(a)\\vert &lt; \\frac{\\epsilon}{2\\vert c_2\\vert}\n\\end{align}\n\\]\nとして，\\(M = \\min(\\delta, \\eta)\\) とすれば，上記と同様に連続性を示すことができます．\n\n\n\n\n\nTheorem 4  : 連続関数の積\n\\(f(x), g(x)\\) は \\(x=a\\) で連続であるとします．このとき，\\(f(x)g(x)\\) も \\(x=a\\) にて連続となります．\n\n\n\n\n\n\n\n\n\nNoteProof\n\n\n\n\n\n\\[\n\\vert x - a \\vert &lt; \\delta(1) \\Rightarrow \\vert f(x) - f(a)\\vert &lt; 1\n\\]\nとすると，\n\\[\n\\vert x - a \\vert &lt; \\delta(1) \\Rightarrow \\vert f(x) \\vert &lt; 1 + \\vert f(a) \\vert\n\\]\n\\(\\delta, \\eta\\) を以下のように定め，\n\\[\n\\begin{align}\n\\vert x - a \\vert &lt; \\delta &\\Rightarrow \\vert f(x) - f(a)\\vert &lt; \\frac{\\epsilon}{2(1 + \\vert f(a) \\vert + \\vert g(a) \\vert)}\\\\\n\\vert x - a \\vert &lt; \\eta &\\Rightarrow \\vert g(x) - g(a)\\vert &lt; \\frac{\\epsilon}{2(1 + \\vert f(a) \\vert + \\vert g(a) \\vert)}\n\\end{align}\n\\]\n\\[\n\\delta(\\epsilon) = \\min (\\delta(1), \\delta, \\eta)\n\\]\nとすると，\n\\[\n\\begin{align}\n\\vert x - a \\vert &lt; \\delta(\\epsilon)\n    \\Rightarrow &\\vert f(x)g(x) - f(a)g(a)\\vert\\\\[5pt]\n    &= \\vert f(x)(g(x) - g(a)) + g(a)(f(x) - f(a))\\vert\\\\[5pt]\n    &\\leq \\vert f(x)\\vert \\vert(g(x) - g(a))\\vert + \\vert g(a)\\vert\\vert(f(x) - f(a))\\vert\\\\[5pt]\n    &&lt; (1 + \\vert f(a) \\vert)\\frac{\\epsilon}{2(1 + \\vert f(a) \\vert + \\vert g(a) \\vert)} + \\vert g(a)\\vert \\frac{\\epsilon}{2(1 + \\vert f(a) \\vert + \\vert g(a) \\vert)}\\\\\n    &= \\epsilon\n\\end{align}\n\\]\nよって，連続性が示された．\n\n\n\n\n\nTheorem 5  連続関数の逆数 \n\\(f(x)\\) は \\(x=a\\) で連続であるとします．このとき，\\(f(a)\\neq 0\\) であるならば \\(1/f(x)\\) も \\(x=a\\) にて連続となります．\n\n\n\n\n\n\n\n\n\nNoteProof\n\n\n\n\n\n連続性の仮定より\n\\[\n\\vert x - a \\vert &lt; \\delta(\\vert f(a)/2\\vert) \\Rightarrow \\vert f(x) - f(a)\\vert &lt; \\frac{\\vert f(a)\\vert}{2}\n\\]\nとすると，\n\\[\n\\vert x - a \\vert &lt; \\delta(\\vert f(a)/2\\vert) \\Rightarrow \\frac{\\vert f(a)\\vert}{2} &lt; \\vert f(x)\\vert\n\\]\nこのとき，\n\\[\n\\begin{align}\n\\left\\vert \\frac{1}{f(x)} - \\frac{1}{f(a)} \\right\\vert\n    &= \\left\\vert \\frac{f(x) - f(a)}{f(x)f(a)} \\right\\vert\\\\\n    &&lt; \\left\\vert \\frac{f(x) - f(a)}{(f(a))^2 / 2} \\right\\vert\n\\end{align}\n\\]\n従って，\\(\\vert x - a \\vert &lt; \\eta \\Rightarrow \\vert f(x) - f(a)\\vert &lt; \\displaystyle\\frac{\\epsilon\\vert (f(a))^2\\vert}{2}\\) となるような \\(\\eta\\) を用いて，\n\\[\n\\delta(\\epsilon) = \\min(\\delta(\\vert f(a)/2\\vert), \\eta)\n\\]\nとすれば\n\\[\n\\vert x - a \\vert &lt; \\delta(\\epsilon) \\Rightarrow \\left\\vert \\frac{1}{f(x)} - \\frac{1}{f(a)} \\right\\vert &lt; \\epsilon\n\\]\n\n\n\n\n\n点 \\(a\\) における極限を考えるとき，\n\n\\(x\\) が増大しつつ \\(a\\) に（左側から）近づく, \\(\\lim_{x\\to a-0}\\)\n\\(x\\) が減少しつつ \\(a\\) に（右側から）近づく, \\(\\lim_{x\\to a+0}\\)\n\nそれぞれの場合を分けて取り扱うことがあります．\n\nExample 3 \n\\(f(x) = \\tan x\\) について，\\(x = \\pi/2\\) における極限を考えてみます．\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport sympy as sy\n\nx = sy.Symbol('x')\nf = sy.tan(x)\n\nx_vals = np.linspace(-np.pi/2+1e-6, np.pi, 400)\ny_vals = np.tan(x_vals)\n\nplt.figure(figsize=(8, 6))\nplt.plot(x_vals, y_vals, label=r'$f(x) = \\tan(x)$')\nplt.ylim(-10, 10)\nplt.xticks([-np.pi/2, 0, np.pi/2, np.pi], [r'$-\\frac{\\pi}{2}$', '0', r'$\\frac{\\pi}{2}$', r'$\\pi$'])\nplt.axvline(np.pi/2, color='r', linestyle='--', label=r'$x = \\frac{\\pi}{2}$')\nplt.axhline(0, color='black',linewidth=0.5)\nplt.axvline(0, color='black',linewidth=0.5)\nplt.title(r'Plot of $f(x) = \\tan(x)$ around $x = \\frac{\\pi}{2}$')\nplt.xlabel('x')\nplt.ylabel('f(x)')\nplt.legend()\nplt.grid(True)\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 1\n\n\n\n上記の図のように，\n\\[\n\\begin{align}\n\\lim_{x\\to \\pi/2+0} \\tan x &= -\\infty\\\\\n\\lim_{x\\to \\pi/2-0} \\tan x &= \\infty\n\\end{align}\n\\]\n実際に，sympy で確認してみると\n\n# DO NOT USE np.pi\nprint(f\"左極限: {sy.limit(sy.tan(x), x, sy.pi/2, '-')}\")\nprint(f\"右極限: {sy.limit(sy.tan(x), x, sy.pi/2, '+')}\")\n\n左極限: oo\n右極限: -oo\n\n\n\n\n ▶  右連続と左連続\n\\[\n\\begin{align}\nf(a) &= \\alpha\\\\[5pt]\n\\lim_{x\\to a-0} f(x) &= \\alpha\\\\\n\\lim_{x\\to a+0} f(x) &= \\beta \\neq \\alpha\n\\end{align}\n\\]\nのとき，\\(f(x)\\) は \\(x = a\\) において左連続といいます．\n\\(f(x)\\) が閉区間 \\([a, b]\\) において定義されているとき，\n\n\\(x=a\\) においては右連続\n\\(x=b\\) においては左連続\n\nであることを意味します．開区間 \\((a, b)\\) において定義されているとき，\\(f(a+0)\\) が確定ならば，それを \\(f(a)\\) として定義域を \\([a, b)\\) 区間に拡張すると \\(f(x)\\) は \\(x=a\\) において右連続になります．\n一方，\\((0, \\infty)\\) 区間で定義された関数 \\(\\displaystyle f(x) = \\frac{1}{x}\\) は開区間では連続ですが，\\(x = 0\\) のときは定義されません．このとき，\\(f(0) = 0\\) として定義域を \\([0, \\infty)\\) に拡張すると，\\(x=0\\) で連続な関数にはなりませんし，\\(f(0)\\) をどんな値にしたとしても，\\(x=0\\) の近傍において, \\(f(x)\\) はいくらでも大きくなってしまうので，連続な関数にはなりません．\n\n📘 REMARKS \n\n開区間 \\((a, b)\\) で定義された連続な関数が，開区間 \\([a, b]\\) の連続な関数に拡張できるとは限らない\n\n\n\nExample 4  : 右連続関数と累積分布関数 \n離散確率変数 \\(X\\sim\\operatorname{Bin}(5, 1/3)\\) を考えます．離散確率変数の累積分布関数 \\(F(x)\\) は\n\\[\nF(x) = \\operatorname{P}(X \\leq x) = \\sum_{y\\leq x}p(y) \\qquad p(y): \\text{確率関数}\n\\]\nと定義されるので，\\(F(x)\\) は右側連続となります．実際に\n\nCode\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom scipy.stats import binom\n\nn, p = 5, 1 / 3\nx = np.arange(0, 6)\ncdf = binom.cdf(x, n, p)\n\nfig, ax = plt.subplots(1, 1)\nax.hlines(cdf, x, x + 1, color=\"gray\")\nax.step(x, cdf, where=\"post\", color=\"gray\", linestyle=\"dotted\")\nax.plot(x, cdf, \"o\", color=\"gray\")\nax.scatter(x[:-1] + 1, cdf[:-1], marker=\"$\\u25EF$\", alpha=0.5, color=\"gray\")\nax.set_xlabel(\"x\")\nax.set_ylabel(\"F(x)\")\nax.set_title(\"CDF of Binomial Distribution (n=5, p=1/3)\")\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 2\n\n\n\nこのとき，確率関数は\n\\[\np(x) = F(x) - \\lim_{x_n\\to x-0}F(x_n)\n\\]\nとすることで計算することが出来ます．一方，\\(F(x) = \\operatorname{P}(X &lt; x)\\) と定義すると左連続となります．\n\n\n\n\n\n\\[\nf(x) = \\frac{\\sin x}{x}\n\\]\nを考えます．この関数は \\(x - 0\\) で定義されていないですが\n\\[\n\\begin{align}\nf(x) = \\left\\{\\begin{array}{c}\n\\frac{\\sin x}{x} & (x\\neq 0)\\\\\n1 & (x = 0)\n\\end{array}\\right.\n\\end{align}\n\\]\nと \\(x = 0\\) で連続かつ微分可能になるように拡張することが出来ます．この拡張された関数を特にsinc関数と呼びます．\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Define the sinc function\ndef sinc(x):\n    return np.sinc(x / np.pi)\n\ndef inverse_x(x):\n    return 1/x\n\n# Generate x values\nx_vals = np.linspace(-10*np.pi, 10*np.pi, 400)\ny_vals = sinc(x_vals)\n\n# Plot the sinc function\nplt.figure(figsize=(8, 6))\nplt.plot(x_vals, y_vals, label=r'$f(x) = \\frac{\\sin(x)}{x}$')\nplt.plot(x_vals, inverse_x(x_vals), label=r'$f(x) = \\frac{1}{x}$')\nplt.xticks(np.arange(-10*np.pi, 11*np.pi, np.pi), \n           [r'$-10\\pi$', r'$-9\\pi$', r'$-8\\pi$', r'$-7\\pi$', r'$-6\\pi$', r'$-5\\pi$', r'$-4\\pi$', r'$-3\\pi$', r'$-2\\pi$', r'$-\\pi$', '0', r'$\\pi$', r'$2\\pi$', r'$3\\pi$', r'$4\\pi$', r'$5\\pi$', r'$6\\pi$', r'$7\\pi$', r'$8\\pi$', r'$9\\pi$', r'$10\\pi$'])\nplt.axhline(0, color='black',linewidth=0.5)\nplt.axvline(0, color='black',linewidth=0.5)\nplt.title(r'Plot of $f(x) = \\frac{\\sin(x)}{x}$')\nplt.xlabel('x')\nplt.ylabel('f(x)')\nplt.ylim(-1.1, 1.1)\nplt.legend()\nplt.grid(True)\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 3\n\n\n\n ▶  \\(x = 0\\)における連続性の証明\n\n\n\n\n\n\n\nNoteProof\n\n\n\n\n\n偶関数の性質\n\\[\n\\frac{\\sin x}{x} = \\frac{\\sin -x}{-x}\n\\]\nより \\(0 &lt; x \\to +0\\) の場合を考えます．xy座標上に \\(O = (0, 0)，A = (1, 0)，B = (\\cos x, \\sin x)，C = (1, \\tan x)\\) という点をとったとき，\n\\[\n\\text{三角形}OAB \\subset \\text{扇形}OAB \\subset \\text{三角形}OAC\n\\]\nつまり\n\\[\n\\text{三角形}OAB\\text{の面積} \\leq \\text{扇形}OAB\\text{の面積} \\leq  \\text{三角形}OAC\n\\]\n従って，\n\\[\n\\begin{align}\n\\frac{\\sin x}{2} \\leq \\frac{x}{2} &lt; \\frac{\\tan x}{2}\n\\end{align}\n\\]\n両辺 を \\(\\sin ⁡x\\) で割って逆数をとると\n\\[\n\\begin{align}\n\\cos x \\leq \\frac{x\\sin x}{x} &lt; 1\n\\end{align}\n\\]\nここで，\\(x\\to +0\\) とすると，\\(\\cos x \\to 1\\) となり，はさみうちの原理より\n\\[\n\\lim_{x\\to+0}\\frac{\\sin x}{x} = 1\n\\]\n\n\n\n ▶  \\(x = 0\\)における微分可能性の証明\n\n\n\n\n\n\n\nNoteProof\n\n\n\n\n\n\\[\n\\begin{align}\n\\cos x \\leq \\frac{x\\sin x}{x} &lt; 1\n\\end{align}\n\\]\nが \\(-\\frac{\\pi}{2} \\leq x \\leq \\frac{\\pi}{2}\\) で成り立つので\n\\[\n0=\\lim_{x\\to0}\\frac{\\cos(x)-1}{x}\\le\\lim_{x\\to0}\\frac{\\frac{\\sin(x)}x-1}{x-0}\\le0\n\\]\n\\[\n\\begin{align}\n\\lim_{x\\to0}\\frac{1-\\cos(x)}x\n&=\\lim_{x\\to0}\\frac1x\\frac{\\sin^2(x)}{1+\\cos(x)}\\\\\n&=\\lim_{x\\to0}\\frac{\\sin(x)}x\\lim_{x\\to0}\\frac{\\sin(x)}{1+\\cos(x)}\\\\[6pt]\n&=1\\cdot0 = 0\n\\end{align}\n\\]\n従って，はさみうちの原理より \\(f^\\prime(0) = 0\\)"
  },
  {
    "objectID": "posts/2025-07-20-decorator-checking-running-time/index.html",
    "href": "posts/2025-07-20-decorator-checking-running-time/index.html",
    "title": "実行時間計測デコレーター",
    "section": "",
    "text": "Definition 1 デコレーター\n\nデコレータとは，関数の前後に追加処理（ロギング・計測・バリデーションなど）を組み込む仕組み\n\n\n\n\nCode\nfrom time import time, sleep\n\ndef running_time(func):\n    \"\"\"\n    関数の実行時間（秒）を有効桁小数点３桁で表示して、元の関数の戻り値を返すデコレータ\n    \"\"\"\n    def wrapper(*args, **kwargs):\n        start = time()\n        result = func(*args, **kwargs)\n        end = time()\n        elapsed = end - start\n        print(f\"Execution time: {elapsed:.3f} seconds\")\n        return result\n    return wrapper\n\n\n\nExample 1 カントールの対関数の逆関数と実行時間計算\n\n\nCode\nimport numpy as np\n\n@running_time\ndef compute_contor_inverse(J: int):\n    \"\"\"Compute the inverse of the Cantor pairing function.\n    \n    The Cantor pairing function maps pairs of natural numbers to single natural numbers.\n    This function computes the inverse mapping, taking a natural number and returning the \n    original pair of numbers.\n    \n    Args:\n        J (int): A natural number that was produced by the Cantor pairing function.\n            Must be non-negative.\n    \n    Returns:\n        tuple[int, int]: A pair (x, y) of numbers such that their Cantor pairing \n        would produce J. The first element x represents the first number in the original \n        pair, and y represents the second number.\n    \"\"\"\n\n    t = int((np.sqrt(1 + 8 * J) - 1) // 2)\n    x = (t ** 3 + 3 * t) // 2 - J\n    y = J - (t ** 2 + t) // 2\n\n    return x, y\n\n\noutput = compute_contor_inverse(100)\nprint(output)\n\n\nExecution time: 0.000 seconds\n(1018, 9)"
  },
  {
    "objectID": "posts/2025-07-20-decorator-checking-running-time/index.html#実行時間を秒単位で表示するデコレータ",
    "href": "posts/2025-07-20-decorator-checking-running-time/index.html#実行時間を秒単位で表示するデコレータ",
    "title": "実行時間計測デコレーター",
    "section": "",
    "text": "Definition 1 デコレーター\n\nデコレータとは，関数の前後に追加処理（ロギング・計測・バリデーションなど）を組み込む仕組み\n\n\n\n\nCode\nfrom time import time, sleep\n\ndef running_time(func):\n    \"\"\"\n    関数の実行時間（秒）を有効桁小数点３桁で表示して、元の関数の戻り値を返すデコレータ\n    \"\"\"\n    def wrapper(*args, **kwargs):\n        start = time()\n        result = func(*args, **kwargs)\n        end = time()\n        elapsed = end - start\n        print(f\"Execution time: {elapsed:.3f} seconds\")\n        return result\n    return wrapper\n\n\n\nExample 1 カントールの対関数の逆関数と実行時間計算\n\n\nCode\nimport numpy as np\n\n@running_time\ndef compute_contor_inverse(J: int):\n    \"\"\"Compute the inverse of the Cantor pairing function.\n    \n    The Cantor pairing function maps pairs of natural numbers to single natural numbers.\n    This function computes the inverse mapping, taking a natural number and returning the \n    original pair of numbers.\n    \n    Args:\n        J (int): A natural number that was produced by the Cantor pairing function.\n            Must be non-negative.\n    \n    Returns:\n        tuple[int, int]: A pair (x, y) of numbers such that their Cantor pairing \n        would produce J. The first element x represents the first number in the original \n        pair, and y represents the second number.\n    \"\"\"\n\n    t = int((np.sqrt(1 + 8 * J) - 1) // 2)\n    x = (t ** 3 + 3 * t) // 2 - J\n    y = J - (t ** 2 + t) // 2\n\n    return x, y\n\n\noutput = compute_contor_inverse(100)\nprint(output)\n\n\nExecution time: 0.000 seconds\n(1018, 9)"
  },
  {
    "objectID": "posts/2025-07-20-decorator-checking-running-time/index.html#デコレーター自身に引数を読み込ませる場合",
    "href": "posts/2025-07-20-decorator-checking-running-time/index.html#デコレーター自身に引数を読み込ませる場合",
    "title": "実行時間計測デコレーター",
    "section": "デコレーター自身に引数を読み込ませる場合",
    "text": "デコレーター自身に引数を読み込ませる場合\n上記の running_time で小数点桁数を３桁固定としていましたが，これを引数に応じて変化させる場合を考えます．\n\n\nCode\nfrom time import time, sleep\n\n\ndef running_time_with_input(decimal: int = 3):\n    def decorator(func):\n        \"\"\"\n        関数の実行時間（秒）を有効桁小数点３桁で表示して、元の関数の戻り値を返すデコレータ\n        \"\"\"\n\n        def wrapper(*args, **kwargs):\n            start = time()\n            result = func(*args, **kwargs)\n            end = time()\n            elapsed = end - start\n            print(f\"Execution time: {elapsed:.{decimal}f} seconds\")\n            return result\n\n        return wrapper\n\n    return decorator\n\n\n実行例\n\n\nCode\n@running_time_with_input(decimal=10)\ndef do_task():\n    sleep(1.2345)\n\ndo_task()\n# =&gt; Execution time: 1.23 seconds\n\n\nExecution time: 1.2346069813 seconds"
  },
  {
    "objectID": "posts/2025-07-20-decorator-checking-running-time/index.html#appendix-args-と-kwargs",
    "href": "posts/2025-07-20-decorator-checking-running-time/index.html#appendix-args-と-kwargs",
    "title": "実行時間計測デコレーター",
    "section": "Appendix: *args と **kwargs",
    "text": "Appendix: *args と **kwargs\n\n\n\n\n\n\n\n\n\n書き方\n意味\n例\n\n\n\n\n*args\nタプルとして位置引数を全部受け取る\nfunc(1, 2, 3) → args = (1, 2, 3)\n\n\n**kwargs\n辞書としてキーワード引数を全部受け取る\nfunc(a=10, b=20) → kwargs = {'a': 10, 'b': 20}\n\n\n\n\n動作確認\n\n\nCode\ndef example(*args, **kwargs):\n    print(\"args:\", args)\n    print(\"kwargs:\", kwargs)\n\nexample(1, 2, 3, a=10, b=20)\n\n\nargs: (1, 2, 3)\nkwargs: {'a': 10, 'b': 20}"
  },
  {
    "objectID": "posts/2025-02-07-wget-vs-curl/index.html",
    "href": "posts/2025-02-07-wget-vs-curl/index.html",
    "title": "wget vs curl",
    "section": "",
    "text": "Key Takeaways\nwget と curl はどちらもコマンドラインで使える HTTP クライアントですが，シチュエーションに応じて以下のような使い分けがあります"
  },
  {
    "objectID": "posts/2025-02-07-wget-vs-curl/index.html#wget-コマンド",
    "href": "posts/2025-02-07-wget-vs-curl/index.html#wget-コマンド",
    "title": "wget vs curl",
    "section": "wget コマンド",
    "text": "wget コマンド\n\nDefinition 1 wgetコマンド\n\nwget コマンドは，WEBサーバーからコンテンツを取得するためのコマンド\nGUIを使わずにインターネットからファイルをダウンロードする際に使用される\n\n\noptions\n\n\n\n\n\n\n\n\n\nオプション\nSyntax 例\n動作\n\n\n\n\n-r (recursive)\nwget -r http://example.com\n再帰的ダウンロード\n\n\n-A (accept)\nwget -r -A pdf,jpg http://example.com\nダウンロード対象ファイルのホワイトリストを指定．指定された拡張子やキーワードを含むファイルのみをダウンロード対象．カンマ区切りで複数指定可能．\n\n\n-R (reject)\nwget -r -R gif,zip http://example.com\nダウンロード対象外ファイルのブラックリストを指定．指定された拡張子や文字列を含むファイルはダウンロードしない．こちらもカンマ区切りで複数指定可能．\n\n\n-O\nwget -O wp.zip http://example.com\nダウンロード対象ファイルの名前を指定\n\n\n-P\nwget -P /home/jay/Downloads http://example.com\nダウンロード先のディレクトリを指定\n\n\n-c\nwget -c https://example.com/largefile.zip\nダウンロードを途中から再開するオプション\n\n\n\n\nwget -cの注意点\n\nwget -cは不安定なネットワーク環境下での大容量ファイルのダウンロードのときに推奨\nサーバー側がRange リクエスト（部分的なダウンロード）に対応していない場合は無効"
  },
  {
    "objectID": "posts/2025-02-07-wget-vs-curl/index.html#curl-コマンド",
    "href": "posts/2025-02-07-wget-vs-curl/index.html#curl-コマンド",
    "title": "wget vs curl",
    "section": "curl コマンド",
    "text": "curl コマンド\n\nDefinition 2 curlコマンド\n\nさまざまなプロトコルに対応したデータを転送するためのコマンド\n\n\noptions\n\n\n\n\n\n\n\n\n\nオプション\nSyntax 例\n動作説明\n\n\n\n\n-X\ncurl -X POST https://example.com/api\nHTTPメソッドを明示的に指定（例: POST, PUT）\n\n\n-x\ncurl -x http://proxy.example.com:8080 URL\n指定したプロキシサーバーを経由してリクエストを送る\n\n\n-d\ncurl -d \"key1=value1&key2=value2\" URL\nHTTP POST リクエストのボディにデータを送信（デフォルトで Content-Type: application/x-www-form-urlencoded）\n\n\n-s\ncurl -s https://example.com\n進行状況やエラーメッセージなどの出力を抑制（“silent mode”）\n\n\n-o\ncurl -o myfile.html https://example.com\n出力内容を指定したファイル名で保存\n\n\n-O\ncurl -O https://example.com/index.html\nURL から取得したファイル名そのままで保存\n\n\n-L\ncurl -L https://example.com\nリダイレクトを自動で追跡\n\n\n\n\n\nExample 1 よく使う構文\n\n\n\n\n\n\n\n構文例\n説明\n\n\n\n\ncurl https://example.com\n指定したURLからデータを取得\n\n\ncurl -o file.html https://example.com\nファイルに保存してダウンロード\n\n\ncurl -I https://example.com\nHTTPヘッダーだけ取得\n\n\ncurl -X POST -d \"a=1&b=2\" https://api.example.com\nPOSTリクエスト送信\n\n\ncurl -H \"Authorization: Bearer TOKEN\" https://api.example.com\n認証付きリクエスト送信"
  },
  {
    "objectID": "posts/2025-02-07-wget-vs-curl/index.html#比較まとめ表",
    "href": "posts/2025-02-07-wget-vs-curl/index.html#比較まとめ表",
    "title": "wget vs curl",
    "section": "比較まとめ表",
    "text": "比較まとめ表\n\n\n\n\n\n\n\n\n\n項目\nwget\ncurl\n\n\n\n\n主な用途\nファイルのダウンロード\nデータの送受信（API など）\n\n\nサポートプロトコル\nHTTP, HTTPS, FTP など\nHTTP, HTTPS, FTP, SFTP, SCP, LDAP など\n\n\n再帰ダウンロード\n◯（Webサイトごとダウンロード可能）\n✕（スクリプトで再現は可能）\n\n\nアップロード\n✕（不可）\n〇(可能)\n\n\nレジューム（中断再開）\n◯（-c オプション）\n◯（-C - オプションなど）\n\n\nデフォルト出力\nファイル保存\n標準出力（ターミナルに出る）\n\n\nPOST リクエスト\n△（あまり使われない）\n◯（API テストなどに最適）"
  },
  {
    "objectID": "posts/2025-04-10-scatter-plot-with-D3/index.html",
    "href": "posts/2025-04-10-scatter-plot-with-D3/index.html",
    "title": "D3を用いた散布図生成",
    "section": "",
    "text": "Note可視化方針\n\n\n\n ▶  Question\n\n日常活動について，活動に対して感じる有意義さと活動を通して得られる幸福感はどのように相関しているのか？\n\n ▶  Data\n\n\n\n\n\n\n\nDataset\n2022 American Time Use Survey\n\n\nPATH\n./act_means.tsv\n\n\nAbout\n洗濯や調理などの日常活動に従事するときに感じる幸福度と有意義さをスコア化して，その平均を活動ごとに表したもの\n\n\n\n ▶  可視化コンポーネント: normal\n\nscatter_plot_default.html: HTML sturecture\nscatterplot_style.css: CSS for styling\nscatterplot_default.js: JS for scatterplot\n\n ▶  可視化コンポーネント: bubble version\n\nscatter_plot_with_bubble.html: HTML sturecture\nscatterplot_with_bubble.js: JS for bubbleplot"
  },
  {
    "objectID": "posts/2025-04-10-scatter-plot-with-D3/index.html#問題設定と可視化",
    "href": "posts/2025-04-10-scatter-plot-with-D3/index.html#問題設定と可視化",
    "title": "D3を用いた散布図生成",
    "section": "",
    "text": "Note可視化方針\n\n\n\n ▶  Question\n\n日常活動について，活動に対して感じる有意義さと活動を通して得られる幸福感はどのように相関しているのか？\n\n ▶  Data\n\n\n\n\n\n\n\nDataset\n2022 American Time Use Survey\n\n\nPATH\n./act_means.tsv\n\n\nAbout\n洗濯や調理などの日常活動に従事するときに感じる幸福度と有意義さをスコア化して，その平均を活動ごとに表したもの\n\n\n\n ▶  可視化コンポーネント: normal\n\nscatter_plot_default.html: HTML sturecture\nscatterplot_style.css: CSS for styling\nscatterplot_default.js: JS for scatterplot\n\n ▶  可視化コンポーネント: bubble version\n\nscatter_plot_with_bubble.html: HTML sturecture\nscatterplot_with_bubble.js: JS for bubbleplot"
  },
  {
    "objectID": "posts/2025-04-10-scatter-plot-with-D3/index.html#scatter-plot-with-d3",
    "href": "posts/2025-04-10-scatter-plot-with-D3/index.html#scatter-plot-with-d3",
    "title": "D3を用いた散布図生成",
    "section": "scatter plot with D3",
    "text": "scatter plot with D3\nMeaningfullness vs Hapiness について２つのplotを以下では提示しています． 左右のFigureは同じデータを使っているにも関わらず印象が異なります．\n\n\n\n\n\n\nNote解釈\n\n\n\n\nScatter Plot: Meaningfullness と Hapiness の間にはハッキリとした相関関係は見られない\nBubble Plot: 活動別従事者割合(relwt)をweightとして，それをbubble sizeに当てはめた場合，meaningfullnessとHapinessの間には正の相関があると推察できる\n\n\n\nscatter plotでは各点が等しく重要であるという印象を読み手に与えますが，aggregateデータではcount sizeがindexごとによって異なるケースでは 「各点が等しく重要」というのはミスリーディングかもしれません．このような場合，各indexのcount sizeという第３の情報をバブルの面積に比例させることで表すというBubble plotの利用が考えられます．\nただし，バブルの導入により各点が重なって読みづらくなってしまうというトレードオフもあるので，opacityの調整や，そもそも使用しないなどの意思決定をケースバイケースで実施していくことが必要です．\n\n\n ▶  Scatter Plot\n\n\n\n\n\n\n ▶  Bubble Plot\n\n\n\n\n\n\n\n\n\n\n\n\n\nImportantBubble Plotのコツ\n\n\n\n\nバブルの大きさは通常「面積」で表現するべき\nd3.scaleSqrt() を使ってバブルの半径をsqrtスケーリングすると，面積をデータに比例させることができます\nバブル同士が重なってしまうと個別の値が読み取りにくくなるので，透過度(opacity)の調整やBorder colorの導入の検討が必要\n\n\n\n\nアンチパターン: 透過度の重要性\nscatter plot, bubble plotにおいて，透過度（opacity）の調整は，データの密度や重なりを視覚的に正確に伝えるという効果を持つ重要な視覚的テクニックです．\n\n\n\n\n\n\nNote可視化シーン別透過度調整の効果\n\n\n\n\nscatter plot: 重なりが多いところが自然と濃くなるため，「どこに多くのデータが集中しているか」が明確になる\nbubble plot: 先に描いた点や小さい円が完全に見えなくなることを防ぐ\n\n\n\n以下では透過度を全く調整せずに可視化した場合を示しています．\n\n\n ▶  Scatter Plot\n\nすべての点が同じ濃さのため，data point密度の「濃度差が表現されない」\nバブルのサイズや色も一定なので視覚的には「一様」に見えてしまい、分布の濃淡や偏り、異常検知が難しくなる\n\n\n\n\n\n\n\n ▶  Bubble Plot\n\n小さなバブルが大きなバブルの下に隠れて見えなくなる\n密集したエリアがごちゃごちゃして読みづらくなる\nどのバブルがどの値か判別しにくくなるため，面積情報のメリットが薄れる"
  },
  {
    "objectID": "posts/2025-08-25-columnar-storage/index.html",
    "href": "posts/2025-08-25-columnar-storage/index.html",
    "title": "Columnar Storageの特徴",
    "section": "",
    "text": "Definition 1 Columnar Storage\n\n1つのレコードをcolumn valuesグループ毎に分割し，それぞれを異なるストレージ領域に格納する技術\n従来のデータベースは通常，レコード全体を1つのストレージ領域に格納する\nファイルフォーマットまで着目すると，column-based formatの例としてParquetがある\n\n\n\n\nColumnar storage image\n\n\n\nColumnar Storageの特徴\n\n\n\n\n\n\nNote1: 通信量の最小化\n\n\n\n\nクエリ実行時に，必要な列の値だけがスキャンされ，転送される\nSELECT title FROM fooは，title 列の値だけにアクセスする\nSELECT * FROM foo だと結局ずべてのストーレージ領域に対してアクセスしてしまい，columnar-storageのメリットが活かせなくなる\n\n\n\n\n\n\n\n\n\nNote2: 高い圧縮率\n\n\n\n\n従来のrow-based storageはおおよそ 1:3 の圧縮に対して，Column storageは 1:10 の圧縮率を達成できるとされる(see here)\nColumnには似通った値が並ぶため傾向があるため（特に列のcardinalityが低い場合），row-based storageよりも高い圧縮率を得やすい\n\n\n\n\n\n\n\n\n\nImportant3: 更新処理の非効率性\n\n\n\n\n既存レコードの更新に弱く，1つのレコードを更新する場合でも列ごとに分割して保存されているため，複数のストレージ領域へアクセスする必要がある\nrow-based storageだとrowが１つのストレージ領域へ保存されるので，更新時のアクセスは１つのストレージ領域で済む\n\n\n\n\nExample 1 columnar storage vs row-based storage\nSNO  PRICE CITY    SNAME\n---  ------ ----    -----\nS1       20 London  Smith\nS2       10 Paris   Jones\nS3       30 Paris   Blake\nS4       20 London  Clark\nS5       30 Athens  Adams\nというような FOO テーブルを考えます．シンプルなColumnar storageの場合，以下のように;で区切られたグループ毎にストーレージ領域に保存します\nS1S2S3S4S5;2010302030;LondonParisParisLondonAthens;SmithJonesBlakeClarkAdams \n一方，row-based storageの場合\nS120LondonSmith;S210ParisJones;S330ParisBlake;S420LondonClark;S530AthensAdams\nそれぞれのstorageパターンに対して\nSELECT CITY, SUM(PRICE) \nFROM FOO \nGROUP BY CITY;\nというクエリを実行すると\n\nRow-based storage: 全列(=不要列（SNO, SNAME）もI/O)を毎回読み込んでから，PRICE と CITY を抽出して集計\nColumnar storage: 必要な列だけ読み込む．集計系クエリで圧倒的に速い\n\n\n\n\nExample 2 row-based storageの方が効率が良い場合\n次のようなSELECT文ではrow-based storageの方が効率的な可能性があります\nSELECT *\nFROM SomeTable\nWHERE col_1 = 'A';\ncol_a = 'A' の条件によってレコード数を大きく絞り込めたとしても，columnar storageの場合は結局 SELECT * によってすべての列にアクセスする必要があります． col_1 がインデックスを持つ場合だと，インデックス探索で col_1 = 'A' の行位置を即座に特定してから必要なストーレージ領域のみ読み込めば良いので，効率的なスキャンが期待できます．"
  },
  {
    "objectID": "posts/2025-08-25-columnar-storage/index.html#columnar-storageの特徴",
    "href": "posts/2025-08-25-columnar-storage/index.html#columnar-storageの特徴",
    "title": "Columnar Storageの特徴",
    "section": "",
    "text": "Definition 1 Columnar Storage\n\n1つのレコードをcolumn valuesグループ毎に分割し，それぞれを異なるストレージ領域に格納する技術\n従来のデータベースは通常，レコード全体を1つのストレージ領域に格納する\nファイルフォーマットまで着目すると，column-based formatの例としてParquetがある\n\n\n\n\nColumnar storage image\n\n\n\nColumnar Storageの特徴\n\n\n\n\n\n\nNote1: 通信量の最小化\n\n\n\n\nクエリ実行時に，必要な列の値だけがスキャンされ，転送される\nSELECT title FROM fooは，title 列の値だけにアクセスする\nSELECT * FROM foo だと結局ずべてのストーレージ領域に対してアクセスしてしまい，columnar-storageのメリットが活かせなくなる\n\n\n\n\n\n\n\n\n\nNote2: 高い圧縮率\n\n\n\n\n従来のrow-based storageはおおよそ 1:3 の圧縮に対して，Column storageは 1:10 の圧縮率を達成できるとされる(see here)\nColumnには似通った値が並ぶため傾向があるため（特に列のcardinalityが低い場合），row-based storageよりも高い圧縮率を得やすい\n\n\n\n\n\n\n\n\n\nImportant3: 更新処理の非効率性\n\n\n\n\n既存レコードの更新に弱く，1つのレコードを更新する場合でも列ごとに分割して保存されているため，複数のストレージ領域へアクセスする必要がある\nrow-based storageだとrowが１つのストレージ領域へ保存されるので，更新時のアクセスは１つのストレージ領域で済む\n\n\n\n\nExample 1 columnar storage vs row-based storage\nSNO  PRICE CITY    SNAME\n---  ------ ----    -----\nS1       20 London  Smith\nS2       10 Paris   Jones\nS3       30 Paris   Blake\nS4       20 London  Clark\nS5       30 Athens  Adams\nというような FOO テーブルを考えます．シンプルなColumnar storageの場合，以下のように;で区切られたグループ毎にストーレージ領域に保存します\nS1S2S3S4S5;2010302030;LondonParisParisLondonAthens;SmithJonesBlakeClarkAdams \n一方，row-based storageの場合\nS120LondonSmith;S210ParisJones;S330ParisBlake;S420LondonClark;S530AthensAdams\nそれぞれのstorageパターンに対して\nSELECT CITY, SUM(PRICE) \nFROM FOO \nGROUP BY CITY;\nというクエリを実行すると\n\nRow-based storage: 全列(=不要列（SNO, SNAME）もI/O)を毎回読み込んでから，PRICE と CITY を抽出して集計\nColumnar storage: 必要な列だけ読み込む．集計系クエリで圧倒的に速い\n\n\n\n\nExample 2 row-based storageの方が効率が良い場合\n次のようなSELECT文ではrow-based storageの方が効率的な可能性があります\nSELECT *\nFROM SomeTable\nWHERE col_1 = 'A';\ncol_a = 'A' の条件によってレコード数を大きく絞り込めたとしても，columnar storageの場合は結局 SELECT * によってすべての列にアクセスする必要があります． col_1 がインデックスを持つ場合だと，インデックス探索で col_1 = 'A' の行位置を即座に特定してから必要なストーレージ領域のみ読み込めば良いので，効率的なスキャンが期待できます．"
  },
  {
    "objectID": "posts/2025-08-25-columnar-storage/index.html#columnar-storageとlimit句",
    "href": "posts/2025-08-25-columnar-storage/index.html#columnar-storageとlimit句",
    "title": "Columnar Storageの特徴",
    "section": "Columnar storageとLIMIT句",
    "text": "Columnar storageとLIMIT句\nSELECT * FROM table LIMIT 10;\nと実行するとColumnar storage型のBigQueryでもPostgreSQLでも，返す行は最大 10 行と結果の行数を制限するという意味では同じです． ただし，クエリ実行計画まで着目するとその挙動に差異があります．\nBigQueryの場合\n\nLIMITはクエリで返す行数を制限する句\nLIMITは「処理するデータ量」を制限するものではなく，最終的に返す行数を制御するだけ\nそのため，SELECT * に LIMIT を付けても，テーブル全体が読み取られるため課金対象の量を減らすことはできない\n結果件数だけ制御するだけで，処理量や課金は減らない\n\nPostgreSQLの場合\n\nPostgresは，row-basedデータベースで基本的に必要な行だけ返す\nLIMITを付けると，クエリプランナーは「どのくらい行を読むか」を考慮するため，実際の処理コストは下がることが多い\n結果件数だけでなく，実行計画にも効いて実際の処理量削減につながる余地がある"
  },
  {
    "objectID": "posts/2025-08-25-columnar-storage/index.html#rerferences",
    "href": "posts/2025-08-25-columnar-storage/index.html#rerferences",
    "title": "Columnar Storageの特徴",
    "section": "Rerferences",
    "text": "Rerferences\n\nColumn-Oriented Database Systems, Stavros Harizopoulos, Daniel Abadi, Peter Boncz, VLDB 2009 Tutorial\nBigQuery &gt; Documentation &gt; クエリ計算を最適化する"
  },
  {
    "objectID": "posts/2025-09-02-thesis-statement/index.html",
    "href": "posts/2025-09-02-thesis-statement/index.html",
    "title": "Thesis Statementの書き方",
    "section": "",
    "text": "Definition 1 論文ステートメント(Thesis Statement)\n\n分析プロジェクトにおいて，ベースとなる主張(Argument)/立場(Position)を簡潔に示したもの\n単なる事実の記述ではなく，反論可能（arguable / contestable）な主張であること\n\n\nThesis Statement と 研究計画書 の違い\n\n\n\n\n\n\n\n\n\n項目\nThesis Statement\n研究計画書 (Research Proposal)\n\n\n\n\n目的\n分析プロジェクトにおける 中心的な主張を提示\n研究を実施するための 背景・目的・方法・意義を説明\n\n\n長さ\n1〜2文\n数ページ〜十数ページ\n\n\n位置づけ\n論文本文の冒頭に配置し，論理展開の「背骨」になる\nプロジェクトの開始前に提出される「実行計画書」\n\n\n内容\n- テーマに対する立場（position）- 主張の根拠の方向性（x, y, z）\n- 研究背景・問題設定- 先行研究レビュー- 研究課題・仮説- 方法・データ- 期待される成果・貢献- 研究スケジュール\n\n\n性質\n宣言的（「私はこう主張する」）\n計画的（「私はこう研究する予定だ」）\n\n\n\n\n\n\n\n読者に対して「論文が何を主張するか」「なぜ重要か」を示す\n論文や研究が何にフォーカスしているのかを示す\n主張を証明するにあたって，研究がどのようなロジック・構成となるのかを示す"
  },
  {
    "objectID": "posts/2025-09-02-thesis-statement/index.html#thesis-statementとは",
    "href": "posts/2025-09-02-thesis-statement/index.html#thesis-statementとは",
    "title": "Thesis Statementの書き方",
    "section": "",
    "text": "Definition 1 論文ステートメント(Thesis Statement)\n\n分析プロジェクトにおいて，ベースとなる主張(Argument)/立場(Position)を簡潔に示したもの\n単なる事実の記述ではなく，反論可能（arguable / contestable）な主張であること\n\n\nThesis Statement と 研究計画書 の違い\n\n\n\n\n\n\n\n\n\n項目\nThesis Statement\n研究計画書 (Research Proposal)\n\n\n\n\n目的\n分析プロジェクトにおける 中心的な主張を提示\n研究を実施するための 背景・目的・方法・意義を説明\n\n\n長さ\n1〜2文\n数ページ〜十数ページ\n\n\n位置づけ\n論文本文の冒頭に配置し，論理展開の「背骨」になる\nプロジェクトの開始前に提出される「実行計画書」\n\n\n内容\n- テーマに対する立場（position）- 主張の根拠の方向性（x, y, z）\n- 研究背景・問題設定- 先行研究レビュー- 研究課題・仮説- 方法・データ- 期待される成果・貢献- 研究スケジュール\n\n\n性質\n宣言的（「私はこう主張する」）\n計画的（「私はこう研究する予定だ」）\n\n\n\n\n\n\n\n読者に対して「論文が何を主張するか」「なぜ重要か」を示す\n論文や研究が何にフォーカスしているのかを示す\n主張を証明するにあたって，研究がどのようなロジック・構成となるのかを示す"
  },
  {
    "objectID": "posts/2025-09-02-thesis-statement/index.html#thesis-statementの書き方",
    "href": "posts/2025-09-02-thesis-statement/index.html#thesis-statementの書き方",
    "title": "Thesis Statementの書き方",
    "section": "Thesis Statementの書き方",
    "text": "Thesis Statementの書き方\n\n\n\n\n\n\nNote(1) Research Questionから始める\n\n\n\n\nまず，自分が明らかにしたい問い（Research Question）を定める\nRQは「Yes/No」で答えられる形，あるいは「AとBの関係はどうか？」という形式が望ましい\nなぜ定義したResearch Questionが重要なのか？どのような貢献があるのか？を記述する\n\n\n\n\nExample 1 Research Question例\n\n例（経済学）: Does an increase in minimum wage reduce employment in the service sector?\n例（ML）: Can Physics-Informed ML outperform black-box ML under small sample regimes?\n\n\n\n\n\n\n\n\n\nNote(2) 立場（Position）を明確にする\n\n\n\n\nその問いに対して自分はどの立場を取るのかを一文で表現する\n「私の仮説は〜である」よりも，「〜である」と断定的に書く方がThesis Statementらしい\n形式や文字数よりも 主張の明確さと論理的整合性が重要\n\n\n\n\nExample 2 記述とポジショニングの違い\n\n\n\n\n\n\n\n\n❌ Not a thesis（事実や説明だけ）\n✅ Possible thesis（主張・立場がある）\n\n\n\n\n空は青い．\n空が青く見えるのは，大気上層における光と化学的相互作用の複雑な影響によるものである．\n\n\nハリー・ポッターはJ.K.ローリングによって書かれた本である．\n『ハリー・ポッター』は，マグルと魔法界の関係性を通じて偏見の理解に影響を与え，一世代の価値観を形成した本である．\n\n\nテリー・フォックスはカナダ史において重要な人物である．\nテリー・フォックスは，他のどのカナダ人よりも医学研究に大きな影響を与えてきた．\n\n\n\n\n\n\n\n\n\n\n\n\nNote(3) 主張の根拠の方向性を示す\n\n\n\n\n「なぜその主張を支持できるのか」の論拠を簡潔に述べる\nどのようなロジックを用いる予定なのか，読者にイメージを与える\n\n\n\n\n\n\n\n\n\nNote(4) Statementの記述タイミング\n\n\n\n\nThesis Statement は柔軟で分析や思考の過程に合わせて発展させるもの\n執筆中に修正しても構わない，むしろ推奨される\n\n\n\n\nThesis Statement チェックリスト\n\n1. Arguable（論争可能か） : 主張が単なる事実ではなく、読者が賛否を考えられる内容か\n2. Specific（具体性） : 主張が抽象的すぎず、論文内で十分に証明可能な焦点を持っている\n3. Constructs / Variables（構成要素の明確化） : 研究対象や変数、概念が明確に示されているか\n4. Relationship / Claim（関係・主張の明確化） : 構成要素間の関係や立場が具体的に述べられているか\n5. Scope（論文の範囲に適合しているか） : 論文の長さ・範囲内で十分に議論・証明可能か\n6. Significance / “So what?”（意義が示されているか） : なぜこの主張が重要なのか、読者が関心を持つ理由が示されている\n7. Roadmap（論文の展開を予告しているか） : サブポイントや分析の方向性が簡単に示されているか\n8. Clarity / Precision（明確さと正確さ） : キーワード・動詞・文の構造が明確で理解しやすいか\n9. Tentative / Flexible（暫定的に作成しているか） : 初稿で完璧でなくてもよい。執筆中に修正可能か\n10. Length（長さの適切さ） : 1〜2文、または複雑な場合は段落で表現可能か"
  },
  {
    "objectID": "posts/2025-09-02-thesis-statement/index.html#references",
    "href": "posts/2025-09-02-thesis-statement/index.html#references",
    "title": "Thesis Statementの書き方",
    "section": "References",
    "text": "References\n\nSimon Fraser University &gt; Writing thesis statements"
  },
  {
    "objectID": "posts/2025-08-17-clam-antivirus/index.html",
    "href": "posts/2025-08-17-clam-antivirus/index.html",
    "title": "clam antivirusの導入",
    "section": "",
    "text": "Linux系でも利用できるウイルス対策ソフトウェアとして ClamAV があります．ウイルス定義データベースに登録してあるパターンに従ってウイルスをスキャンしてくれます． ClamAV の利用形態は以下の２つが存在します．\n\nclamscam: ユーザーが実行可能なコマンド，adhoc用途\nclamav-daemon.service: systemctlで管理可能なclamscan daemon service, ただし常時動いている関係でメモリを多く消費する\n\n今回は，前者のインストールと設定について紹介します．\n\n\n\n\n\n\nNoteFalse Positive Risk\n\n\n\nClamAVはトロイの木馬やMirai, BASHLITEといったLinuxワームを検出してくれますが，Slack snap versionのケース のようにFalse Positive Reportを上げる可能性もあります．"
  },
  {
    "objectID": "posts/2025-08-17-clam-antivirus/index.html#clam-antivirusの導入",
    "href": "posts/2025-08-17-clam-antivirus/index.html#clam-antivirusの導入",
    "title": "clam antivirusの導入",
    "section": "",
    "text": "Linux系でも利用できるウイルス対策ソフトウェアとして ClamAV があります．ウイルス定義データベースに登録してあるパターンに従ってウイルスをスキャンしてくれます． ClamAV の利用形態は以下の２つが存在します．\n\nclamscam: ユーザーが実行可能なコマンド，adhoc用途\nclamav-daemon.service: systemctlで管理可能なclamscan daemon service, ただし常時動いている関係でメモリを多く消費する\n\n今回は，前者のインストールと設定について紹介します．\n\n\n\n\n\n\nNoteFalse Positive Risk\n\n\n\nClamAVはトロイの木馬やMirai, BASHLITEといったLinuxワームを検出してくれますが，Slack snap versionのケース のようにFalse Positive Reportを上げる可能性もあります．"
  },
  {
    "objectID": "posts/2025-08-17-clam-antivirus/index.html#clamavのインストール",
    "href": "posts/2025-08-17-clam-antivirus/index.html#clamavのインストール",
    "title": "clam antivirusの導入",
    "section": "clamavのインストール",
    "text": "clamavのインストール\n% sudo apt install clamav\n\n% clamscan --version\nClamAV 1.4.3/27737/Tue Aug 19 17:27:27 2025"
  },
  {
    "objectID": "posts/2025-08-17-clam-antivirus/index.html#clamav-freshclamの設定",
    "href": "posts/2025-08-17-clam-antivirus/index.html#clamav-freshclamの設定",
    "title": "clam antivirusの導入",
    "section": "clamav-freshclamの設定",
    "text": "clamav-freshclamの設定\nClamAVがウイルス検知に利用するウイルス定義データベースの更新方法は\n\nfreshclamコマンド\nsystemctl serviceとしてのclamav-freshclam\n\nの２つの方法があります．基本的には後者の方法で運用しますが，インストール直後に念の為手動で freshclam コマンドを実行しておきます．\n% sudo freshclam\nERROR: Failed to lock the log file /var/log/clamav/freshclam.log: Resource temporarily unavailable\nERROR: Problem with internal logger (UpdateLogFile = /var/log/clamav/freshclam.log).\nERROR: initialize: libfreshclam init failed.\nERROR: Initialization error!\nインストール直後に実行すると上記のようなエラーが発生します．clamav-freshclam.service がenabledだと sudo freshclam の手動実行ができなくなってしまうためです． なので一時的にstopして更新します．\n# service statusの確認\n% sudo systemctl status clamav-freshclam\n● clamav-freshclam.service - ClamAV virus database updater\n     Loaded: loaded (/usr/lib/systemd/system/clamav-freshclam.service; disabled; preset: enabled)\n     Active: active (running) since Wed 2025-08-20 12:05:21 JST; 44s ago\n       Docs: man:freshclam(1)\n             man:freshclam.conf(5)\n             https://docs.clamav.net/\n   Main PID: 43196 (freshclam)\n      Tasks: 1 (limit: 75871)\n     Memory: 235.9M (peak: 849.9M)\n        CPU: 7.825s\n     CGroup: /system.slice/clamav-freshclam.service\n             └─43196 /usr/bin/freshclam -d --foreground=true\n\n# serviceのstop\n% sudo systemctl stop clamav-freshclam.service\n\n# 手動更新\n% sudo freshclam\nClamAV update process started at Wed Aug 20 12:07:24 2025\nWed Aug 20 12:07:24 2025 -&gt; daily.cvd database is up-to-date (version: 27737, sigs: 2076445, f-level: 90, builder: raynman)\nWed Aug 20 12:07:24 2025 -&gt; main.cvd database is up-to-date (version: 62, sigs: 6647427, f-level: 90, builder: sigmgr)\nWed Aug 20 12:07:24 2025 -&gt; bytecode.cvd database is up-to-date (version: 336, sigs: 83, f-level: 90, builder: nrandolp)\nウイルス情報データベースのディレクトリは，デフォルトなら/var/lib/clamavになっているはずです． 次に，clamav-freshclam をenableして，restartしておきます\n# enable設定\n% sudo systemctl enable clamav-freshclam\nSynchronizing state of clamav-freshclam.service with SysV service script with /usr/lib/systemd/systemd-sysv-install.\nExecuting: /usr/lib/systemd/systemd-sysv-install enable clamav-freshclam\nCreated symlink /etc/systemd/system/multi-user.target.wants/clamav-freshclam.service → /usr/lib/systemd/system/clamav-freshclam.service.\n\n# restart設定\n% sudo systemctl restart clamav-freshclam\n\n# status確認\n% sudo systemctl status clamav-freshclam\n● clamav-freshclam.service - ClamAV virus database updater\n     Loaded: loaded (/usr/lib/systemd/system/clamav-freshclam.service; enabled; preset: enabled)\n     Active: active (running) since Wed 2025-08-20 12:07:40 JST; 2s ago\n       Docs: man:freshclam(1)\n             man:freshclam.conf(5)\n             https://docs.clamav.net/\n   Main PID: 48177 (freshclam)\n      Tasks: 1 (limit: 75871)\n     Memory: 2.4M (peak: 3.2M)\n        CPU: 6ms\n     CGroup: /system.slice/clamav-freshclam.service\n             └─48177 /usr/bin/freshclam -d --foreground=true"
  },
  {
    "objectID": "posts/2025-08-17-clam-antivirus/index.html#freshclamの設定ファイルの編集",
    "href": "posts/2025-08-17-clam-antivirus/index.html#freshclamの設定ファイルの編集",
    "title": "clam antivirusの導入",
    "section": "freshclamの設定ファイルの編集",
    "text": "freshclamの設定ファイルの編集\nfreshclamの設定ファイルは/etc/clamav/freshclam.confにあります．\n\n\n\n\n項目\n説明\n\n\n\n\nChecks\nデータベース更新頻度\n\n\nDatabaseOwner\nデータベースファイルの所有者ユーザー\n\n\nDatabaseDirectory\nデータベースディレクトリ\n\n\nUpdateLogFile\n更新のログの出力先\n\n\nLogTime\nログにタイムスタンプを付与\n\n\nNotifyClamd\nclamd デーモンに更新通知を送る\n\n\nForeground\nデーモンをフォアグラウンドで実行するか\n\n\n\n\n編集する場合は vim とかで直接編集しちゃいます．\nsudo vim /etc/clamav/freshclam.conf\n設定変更後はサービスの再起動をしときます\n% sudo systemctl restart clamav-freshclam"
  },
  {
    "objectID": "posts/2025-08-17-clam-antivirus/index.html#clamscanコマンドの使い方",
    "href": "posts/2025-08-17-clam-antivirus/index.html#clamscanコマンドの使い方",
    "title": "clam antivirusの導入",
    "section": "clamscanコマンドの使い方",
    "text": "clamscanコマンドの使い方\nデーモンを起動していないと，clamscanコマンドはシングルスレッド(--multiscanオプションが利用できない)の動作となるので， 基本的にはスキャンするターゲットをしっかり事前に決めて検査することが良いと思います．\n実行例\n% sudo clamscan -i --max-filesize=100M -r ~/Downloads\n\n----------- SCAN SUMMARY -----------\nKnown viruses: 8708210\nEngine version: 1.4.3\nScanned directories: 1\nScanned files: 20\nInfected files: 0\nData scanned: 114.28 MB\nData read: 32.92 MB (ratio 3.47:1)\nTime: 14.845 sec (0 m 14 s)\nStart Date: 2025:08:20 12:24:37\nEnd Date:   2025:08:20 12:24:52\noptions\n\n\n\n\n\n\n\n\n\nオプション\n説明\n推奨 / 補足\n\n\n\n\n-r, --recursive\nディレクトリを再帰的にスキャン\nディレクトリ全体をスキャンする場合は必須\n\n\n-i, --infected\n感染ファイルのみ表示\nレポートを簡潔にしたい場合に便利\n\n\n-l &lt;ファイル&gt;\nスキャンログを指定ファイルに出力\n例：-l /var/log/clamav/scan.log\n\n\n--bell\n感染ファイル検出時にベル音を鳴らす\nターミナルで確認しやすい\n\n\n--remove\n感染ファイルを自動削除\nFalse Positive Riskがあるので基本的には使用しない\n\n\n--max-filesize=&lt;SIZE&gt;\nスキャンする最大ファイルサイズを指定\n大きなファイルを除外して高速化\n\n\n--max-scansize=&lt;SIZE&gt;\nスキャンする最大アーカイブサイズを指定\n大規模アーカイブの処理制限\n\n\n--quiet\n通常メッセージを抑制\n感染ファイルのみ出力したい場合\n\n\n--no-summary\nスキャン終了時のサマリ表示を抑制\n自動スクリプトでの利用時に便利\n\n\n\n\n強引にマルチスレッドでスキャン\n\nホームディレクトリ直下のファイルを対象に ClamAV で並列スキャン\nlogファイルは実行時間のタイムスタンプ付きファイル\n--quietで非感染ファイルは表示しない\n-iで感染ファイルのみ表示\n\nfind ~/ -mindepth 1 -maxdepth 1 -type f \\\n  | xargs -P 8 -I {} bash -c 'sudo clamscan --quiet -i --no-summary {}' &gt;&gt; ~/Documents/clamav_log/clamscam_$(date +%Y%m%d_%H%M%S).log 2&gt;&1"
  },
  {
    "objectID": "posts/2025-08-17-clam-antivirus/index.html#references",
    "href": "posts/2025-08-17-clam-antivirus/index.html#references",
    "title": "clam antivirusの導入",
    "section": "References",
    "text": "References\n\nClamAV Documentation\nSlack snap versionのケース"
  },
  {
    "objectID": "posts/2025-01-30-differential-equations/index.html",
    "href": "posts/2025-01-30-differential-equations/index.html",
    "title": "微分方程式を用いたToy models",
    "section": "",
    "text": "Exercise 1 : マルサスの人口論 \n時刻 \\(t\\) におけるとある国の人口が \\(N(t) &gt; 0\\) で表されるとする．マルサスは時刻 \\(t\\) から \\(t+\\Delta t\\) の人口増分 \\(\\Delta N = N(t+\\Delta) - N(t)\\) は\n\\[\n\\Delta N = k N(t)\\Delta t \\qquad (k: \\text{constant})\n\\]\nのように \\(N, \\Delta t\\) に比例するとした．ここから以下のように式変形を行い\n\\[\n\\frac{\\Delta N}{\\Delta t} = k N(t)\n\\]\n\\(\\Delta t\\to 0\\) として次のような微分方程式を得たとします\n\\[\n\\frac{dN(t)}{dt} = kN(t) \\label{eq-de-01}\n\\]\n\\((t, N(t))\\) が \\((0, 1.00 \\times 10^8), (1, 1.25 \\times 10^8)\\) と与えられているとき，\\(t = 2\\) の人口 \\(N(2)\\) を推定せよ．\n\n\n\n\n\n\n\n\n\nNoteSolution\n\n\n\n\n\n微分方程式 \\(\\eqref{eq-de-01}\\) を以下のように変形し積分すると\n\\[\n\\begin{align}\n&\\frac{dN(t)}{dt} = kN(t) \\\\\n&\\Rightarrow \\int \\frac{1}{N(t)}\\frac{dN(t)}{dt} dt= \\int k dt \\\\\n&\\Rightarrow \\log \\vert N(t) \\vert = kt + C\\\\[5pt]\n&\\Rightarrow \\log N(t) = kt + C\n\\end{align}\n\\]\n従って，\n\\[\nN(t) = \\exp(C + kt) = \\tilde C\\exp(kt)\n\\]\n\\(t = 0\\) のときの \\(N(0) = N_0\\) とすると，\\(\\tilde C = N_0\\) でなければならないので\n\\[\nN(t) = N_0\\exp(kt) \\label{eq-malthus-solution}\n\\]\n\\((t, N(t))\\) が \\((0, 1.00 \\times 10^8), (1, 1.25 \\times 10^8)\\) と与えられているので，\n\\[\nN_0 = 1.00 \\times 10^8\n\\]\n次に\n\\[\n\\begin{align}\n&N(1) = 1.00 \\times 10^8 \\exp(k)\\\\[5pt]\n&\\Rightarrow \\exp(k) = 1.25\n\\end{align}\n\\]\n従って，\n\\[\nN(2) = (1.25)^2 \\times 10^8 \\approx 1.56 \\times 10^8\n\\]\n\n\n\n ▶  Python Simulation\nscipy.integrateパッケージのodeintを用いれば微分方程式を解くことができます．\n\nCode\nimport numpy as np\nfrom scipy.integrate import odeint\nimport matplotlib.pyplot as plt\n\n# malthusian growth func\ndef malthusian_model(y, t, k=np.log(1.25)):\n    dydt = k * y\n    return dydt\n\n# init\nN_0 = 1.0\n\n# data point\ndata = (0, 1), (1, 1.25)\n\n# time\nt = np.linspace(0, 5, 21)\n\n# solve\nn = odeint(malthusian_model, N_0, t)\n\n# plot\nplt.plot(t, n)\nplt.scatter(*zip(*data), color='red', label='observed data points')\nplt.legend()\nplt.xlabel(\"t\")\nplt.ylabel(\"$N(t)$\")\nplt.title(\"Malthusian gwrowth simulation\")\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 1\n\n\n\nFigure 1 をみると \\(N(t)\\) は指数関数的に増加していることが読み取れます．これは \\(k\\) の符号に依存しています．\n\n\\(k &gt; 0\\): 指数関数的増加\n\\(k = 0\\): 変化なし\n\\(k &lt; 0\\): 指数関数的減衰\n\nとなります．図示すると以下のようになります\n\nCode\nimport statsmodels.api as sm\n\n# params\nk_args = (-0.2, 0, 0.2)\n\n# solve\nfor k in k_args:\n    n = odeint(malthusian_model, N_0, t, args=(k,))\n    plt.plot(t, n, label=f\"k={k}\")\n\nplt.legend()\nplt.xlabel(\"t\")\nplt.ylabel(\"$N(t)$\")\nplt.title(\"Malthusian growth simulation with different $k$\")\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 2\n\n\n\n\n\n\n\n\n\nTip🍵 マルサスモデルの限界\n\n\n\nマルサスモデルは，\\(k &gt; 0\\) のとき人口が指数関数的に増加すると予測しています．実際には，食料や石油といった資源は有限であるので人口増加を抑制する要因があるため，現実でマルサスモデル的増加をすることは到底起こりえません．\n\n\n\n\n\n\\(N(t)\\) は 4期間ごとに観測される(=観測されるtは\\((0, 1, 2, 4)\\))\n観測される \\(N(t)\\) にはノイズが乗ってしまっている: \\(\\epsilon_t \\sim N(0, 0.1)\\)\n\nという状況ののもと，\\((N_0, k)\\) を推定し，\\(t&gt;4\\) の範囲の人口について予測することはできるのか？という問題を考えてみます．\n\\(\\eqref{eq-malthus-solution}\\) について対数を取ると\n\\[\n\\log N(t) = \\log(N_0) + kt\n\\]\nとなります．つまり，対数変換した変数についての線形モデルとして推定量を考えることができます．観測ノイズ \\(\\epsilon_t\\) を踏まえると，観測される人口を \\(\\tilde N(t)\\) とすると\n\\[\n\\begin{align}\n&\\tilde N(t) = N_0\\exp(kt) + \\epsilon_t\\\\\n&\\Rightarrow\\log \\tilde N(t) = \\log (N_0\\exp(kt) + \\epsilon_t)\n\\end{align}\n\\]\nとなってしまいますが，近似式として\n\\[\n\\log\\tilde N(t) = \\alpha + \\beta t + e_i\n\\]\nで推定するとします．\\(\\epsilon_i\\)がhomogeneousとしても\\(e_i\\)がhomogeneousとは限らないのでheteroskedasticity residual erroを想定して推定します．\n\nCode\nimport statsmodels.api as sm\n\nnp.random.seed(42)\n\n# observation step\nSTEP = 4\n\n# DGP\nactual_n = n.flatten()\nobserved_n = actual_n[::STEP][:-1] + +np.random.normal(0, 0.1, len(actual_n[::STEP][:-1]))\nobserved_t = t[::STEP][:-1]\nX = sm.add_constant(observed_t)\n\n# fit\nmodel = sm.OLS(np.log(observed_n), X).fit(cov_type=\"HC0\")\nestimated_n_0, estimated_k = model.params\n\n# simulation\nsimulated_n = odeint(malthusian_model, np.exp(estimated_n_0), t, args=(estimated_k,))\n\n# plot\nplt.plot(t, simulated_n, label=\"simulated\")\nplt.scatter(observed_t, observed_n, color=\"gray\", alpha=0.8, marker='x', label=\"actual data points\")\nplt.scatter(t, actual_n, color=\"red\", alpha=0.8, label=\"actual data points\")\nplt.legend()\nplt.xlabel(\"t\")\nplt.ylabel(\"$N(t)$\")\nplt.title(\"Malthusian growth prediction\")\nplt.axvspan(4.25, t[-1], color='gray', alpha=0.3)\nplt.text(4.65, 2.0, \"Prediction\\nPeriod\", ha='center', va='center', fontsize=11, color='black')\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 3"
  },
  {
    "objectID": "posts/2025-01-30-differential-equations/index.html#マルサスモデル",
    "href": "posts/2025-01-30-differential-equations/index.html#マルサスモデル",
    "title": "微分方程式を用いたToy models",
    "section": "",
    "text": "Exercise 1 : マルサスの人口論 \n時刻 \\(t\\) におけるとある国の人口が \\(N(t) &gt; 0\\) で表されるとする．マルサスは時刻 \\(t\\) から \\(t+\\Delta t\\) の人口増分 \\(\\Delta N = N(t+\\Delta) - N(t)\\) は\n\\[\n\\Delta N = k N(t)\\Delta t \\qquad (k: \\text{constant})\n\\]\nのように \\(N, \\Delta t\\) に比例するとした．ここから以下のように式変形を行い\n\\[\n\\frac{\\Delta N}{\\Delta t} = k N(t)\n\\]\n\\(\\Delta t\\to 0\\) として次のような微分方程式を得たとします\n\\[\n\\frac{dN(t)}{dt} = kN(t) \\label{eq-de-01}\n\\]\n\\((t, N(t))\\) が \\((0, 1.00 \\times 10^8), (1, 1.25 \\times 10^8)\\) と与えられているとき，\\(t = 2\\) の人口 \\(N(2)\\) を推定せよ．\n\n\n\n\n\n\n\n\n\nNoteSolution\n\n\n\n\n\n微分方程式 \\(\\eqref{eq-de-01}\\) を以下のように変形し積分すると\n\\[\n\\begin{align}\n&\\frac{dN(t)}{dt} = kN(t) \\\\\n&\\Rightarrow \\int \\frac{1}{N(t)}\\frac{dN(t)}{dt} dt= \\int k dt \\\\\n&\\Rightarrow \\log \\vert N(t) \\vert = kt + C\\\\[5pt]\n&\\Rightarrow \\log N(t) = kt + C\n\\end{align}\n\\]\n従って，\n\\[\nN(t) = \\exp(C + kt) = \\tilde C\\exp(kt)\n\\]\n\\(t = 0\\) のときの \\(N(0) = N_0\\) とすると，\\(\\tilde C = N_0\\) でなければならないので\n\\[\nN(t) = N_0\\exp(kt) \\label{eq-malthus-solution}\n\\]\n\\((t, N(t))\\) が \\((0, 1.00 \\times 10^8), (1, 1.25 \\times 10^8)\\) と与えられているので，\n\\[\nN_0 = 1.00 \\times 10^8\n\\]\n次に\n\\[\n\\begin{align}\n&N(1) = 1.00 \\times 10^8 \\exp(k)\\\\[5pt]\n&\\Rightarrow \\exp(k) = 1.25\n\\end{align}\n\\]\n従って，\n\\[\nN(2) = (1.25)^2 \\times 10^8 \\approx 1.56 \\times 10^8\n\\]\n\n\n\n ▶  Python Simulation\nscipy.integrateパッケージのodeintを用いれば微分方程式を解くことができます．\n\nCode\nimport numpy as np\nfrom scipy.integrate import odeint\nimport matplotlib.pyplot as plt\n\n# malthusian growth func\ndef malthusian_model(y, t, k=np.log(1.25)):\n    dydt = k * y\n    return dydt\n\n# init\nN_0 = 1.0\n\n# data point\ndata = (0, 1), (1, 1.25)\n\n# time\nt = np.linspace(0, 5, 21)\n\n# solve\nn = odeint(malthusian_model, N_0, t)\n\n# plot\nplt.plot(t, n)\nplt.scatter(*zip(*data), color='red', label='observed data points')\nplt.legend()\nplt.xlabel(\"t\")\nplt.ylabel(\"$N(t)$\")\nplt.title(\"Malthusian gwrowth simulation\")\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 1\n\n\n\nFigure 1 をみると \\(N(t)\\) は指数関数的に増加していることが読み取れます．これは \\(k\\) の符号に依存しています．\n\n\\(k &gt; 0\\): 指数関数的増加\n\\(k = 0\\): 変化なし\n\\(k &lt; 0\\): 指数関数的減衰\n\nとなります．図示すると以下のようになります\n\nCode\nimport statsmodels.api as sm\n\n# params\nk_args = (-0.2, 0, 0.2)\n\n# solve\nfor k in k_args:\n    n = odeint(malthusian_model, N_0, t, args=(k,))\n    plt.plot(t, n, label=f\"k={k}\")\n\nplt.legend()\nplt.xlabel(\"t\")\nplt.ylabel(\"$N(t)$\")\nplt.title(\"Malthusian growth simulation with different $k$\")\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 2\n\n\n\n\n\n\n\n\n\nTip🍵 マルサスモデルの限界\n\n\n\nマルサスモデルは，\\(k &gt; 0\\) のとき人口が指数関数的に増加すると予測しています．実際には，食料や石油といった資源は有限であるので人口増加を抑制する要因があるため，現実でマルサスモデル的増加をすることは到底起こりえません．\n\n\n\n\n\n\\(N(t)\\) は 4期間ごとに観測される(=観測されるtは\\((0, 1, 2, 4)\\))\n観測される \\(N(t)\\) にはノイズが乗ってしまっている: \\(\\epsilon_t \\sim N(0, 0.1)\\)\n\nという状況ののもと，\\((N_0, k)\\) を推定し，\\(t&gt;4\\) の範囲の人口について予測することはできるのか？という問題を考えてみます．\n\\(\\eqref{eq-malthus-solution}\\) について対数を取ると\n\\[\n\\log N(t) = \\log(N_0) + kt\n\\]\nとなります．つまり，対数変換した変数についての線形モデルとして推定量を考えることができます．観測ノイズ \\(\\epsilon_t\\) を踏まえると，観測される人口を \\(\\tilde N(t)\\) とすると\n\\[\n\\begin{align}\n&\\tilde N(t) = N_0\\exp(kt) + \\epsilon_t\\\\\n&\\Rightarrow\\log \\tilde N(t) = \\log (N_0\\exp(kt) + \\epsilon_t)\n\\end{align}\n\\]\nとなってしまいますが，近似式として\n\\[\n\\log\\tilde N(t) = \\alpha + \\beta t + e_i\n\\]\nで推定するとします．\\(\\epsilon_i\\)がhomogeneousとしても\\(e_i\\)がhomogeneousとは限らないのでheteroskedasticity residual erroを想定して推定します．\n\nCode\nimport statsmodels.api as sm\n\nnp.random.seed(42)\n\n# observation step\nSTEP = 4\n\n# DGP\nactual_n = n.flatten()\nobserved_n = actual_n[::STEP][:-1] + +np.random.normal(0, 0.1, len(actual_n[::STEP][:-1]))\nobserved_t = t[::STEP][:-1]\nX = sm.add_constant(observed_t)\n\n# fit\nmodel = sm.OLS(np.log(observed_n), X).fit(cov_type=\"HC0\")\nestimated_n_0, estimated_k = model.params\n\n# simulation\nsimulated_n = odeint(malthusian_model, np.exp(estimated_n_0), t, args=(estimated_k,))\n\n# plot\nplt.plot(t, simulated_n, label=\"simulated\")\nplt.scatter(observed_t, observed_n, color=\"gray\", alpha=0.8, marker='x', label=\"actual data points\")\nplt.scatter(t, actual_n, color=\"red\", alpha=0.8, label=\"actual data points\")\nplt.legend()\nplt.xlabel(\"t\")\nplt.ylabel(\"$N(t)$\")\nplt.title(\"Malthusian growth prediction\")\nplt.axvspan(4.25, t[-1], color='gray', alpha=0.3)\nplt.text(4.65, 2.0, \"Prediction\\nPeriod\", ha='center', va='center', fontsize=11, color='black')\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 3"
  },
  {
    "objectID": "posts/2025-01-30-differential-equations/index.html#ヴェアフルストの人口論",
    "href": "posts/2025-01-30-differential-equations/index.html#ヴェアフルストの人口論",
    "title": "微分方程式を用いたToy models",
    "section": "ヴェアフルストの人口論",
    "text": "ヴェアフルストの人口論\n人口過密の要因を考慮に入れてマルサスモデルを修正したのがヴェアフルストモデルです．\n ▶  仮定の設定\n\n人口の上限 \\(N_\\infty\\) が存在する\n現在の人口を \\(N(t)\\) としたとき，人口増加 \\(\\Delta N(t)\\) は \\(N(t)\\) と \\(\\displaystyle 1 - \\frac{N(t)}{N_\\infty}\\) と時間区間 \\(\\Delta\\) に比例する\n\n ▶  問題の定式化\n比例定数を \\(k\\) としたとき\n\\[\n\\Delta N(t) = kN(t)\\left(1 - \\frac{N(t)}{N_\\infty}\\right)\\Delta t\n\\]\n\\(\\Delta t\\to 0\\) と極限をとると\n\\[\n\\frac{dN(t)}{dt} = kN(t)\\left(1 - \\frac{N(t)}{N_\\infty}\\right)\\label{eq-logistic-model}\n\\]\n人口変化は上記のような一階上微分方程式で表せるという形で定式化できました．\n ▶  モデルを解く\n\\(\\eqref{eq-logistic-model}\\) を変形すると\n\\[\n\\frac{N_\\infty}{N_\\infty - N(t)}\\frac{dN(t)}{N(t)dt} = k\n\\]\n両辺を \\(t\\) について積分すると\n\\[\n\\begin{align}\n& \\int\\frac{N_\\infty}{N_\\infty - N(t)}\\frac{dN(t)}{N(t)dt} dt= \\int k dt\\\\\n&\\Rightarrow \\int\\left(\\frac{1}{N(t)}+\\frac{1}{N_\\infty - N(t)}\\right)dN(t) = \\int k dt\\\\\n&\\Rightarrow \\log N(t) - \\log(N_\\infty - N(t)) = kt + C\\\\\n&\\Rightarrow \\log \\frac{N(t)}{N_\\infty - N(t)} = kt + C\n\\end{align}\n\\]\nこのとき，\\(N(0) = N_0\\) と初期条件が与えられたとすると\n\\[\n\\exp(C) = \\frac{N_0}{N_\\infty - N_0}\n\\]\nよって，\n\\[\n\\frac{N(t)}{N_\\infty - N(t)} = \\frac{N_0}{N_\\infty - N_0}\\exp(kt)\n\\]\nこれを \\(N(t)\\) についてとくと，\n\\[\nN(t) = \\frac{N_\\infty}{1 + [(N_\\infty/N_0 - 1)]\\exp(-kt)}\n\\]\nまたは\n\\[\n\\frac{1}{N(t)} = \\frac{1}{N_\\infty} + \\left(\\frac{1}{N_0} - \\frac{1}{N_\\infty}\\right)\\exp(-kt)\n\\]\n ▶  解釈\n\\(t\\to\\infty\\) のとき，\\(\\lim_{t\\to\\infty}\\exp(-kt) = 0\\) より\n\\[\n\\lim_{t\\to\\infty}N(t) = N_\\infty\n\\]\nとなることがわかります．初期値に応じて \\(N_\\infty\\) へ到達する経路は異なります．仮に \\(N_\\infty = 12, k=0.2\\) として，初期値が \\((1, 3, 6, 9, 12, 15)\\) と異なる水準で与えられたとします．\n\n\nCode\nfrom scipy.integrate import solve_ivp\n\n\n# Define logistic growth model\ndef logistic_growth(t, N, k=0.2, M=12):\n    dydt = k * N * (1 - N / M)\n    return dydt\n\n# Set up the grid for the direction field\nt_vals = np.linspace(0, 30, 20)  # Time values\nP_vals = np.linspace(0, 16, 20)  # Population values\nT, P = np.meshgrid(t_vals, P_vals)\n\n# Compute direction field (dP/dt values)\ndP_dt = logistic_growth(None, P)\n\n# Normalize arrows for visualization\nnorm = np.sqrt(1**2 + dP_dt**2)\nU = 1 / norm  # Time step is 1 (arbitrary)\nV = dP_dt / norm  # Scale arrows properly\n\n# Plot the direction field\nplt.figure(figsize=(8, 5))\nplt.quiver(T, P, U, V, color=\"gray\", alpha=0.7) # [T, P]: arrow location, [U, V]: arrow direction\n\n# Solve the ODE for different initial conditions\ninitial_conditions = [1, 3, 6, 9, 12, 15,]\nt_span = (0, 30)\nt_eval = np.linspace(0, 30, 100)\n\nfor P0 in initial_conditions:\n    sol = solve_ivp(logistic_growth, t_span, [P0], t_eval=t_eval)\n    if sol.success:\n        plt.plot(sol.t, sol.y[0], linewidth=2, label=f\"P(0)={P0}\")\n    else:\n        raise ValueError(\"computation failed\")\n\n# Labels and title\nplt.xlabel(\"t\")\nplt.ylabel(\"P(t)\")\nplt.title(\"Logistic Growth Model\")\nplt.legend()\nplt.grid()\n\n# Show the plot\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\\(0&lt; N_0 &lt; N_\\infty\\): はじめの増加は指数関数的だが，ある程度の水準から増加の度合いは減衰していく\n\\(N_0 = N_\\infty\\): 変化なし\n\\(N_0 &gt; N_\\infty\\): \\(N_\\infty\\)に近づく方向で減少していく．減衰の度合いは減衰していく\n\\(N_0 = 0\\): これも一つの均衡だが，ちょっとしたショックがあるだけで \\(N_\\infty\\) を目指すPathに乗ってしまう(= unstable equilibrium)\n\n ▶  Validation\nヴェアフルストモデルが人口動態を表した良いモデルなのか，1820-1930のアメリカの人口データを用いて検証してみます．\n\n\nCode\nimport pandas as pd\n\n# Historical population data (year, population in millions)\ndata = {\n    \"year\": [1820, 1830, 1840, 1850, 1860, 1870, 1880, 1890, 1900, 1910, 1920, 1930, 2000],\n    \"us_population_million\": [9.6, 12.9, 17.1, 23.2, 31.4, 38.6, 50.2, 62.9, 76.0, 92.0, 106.5, 123.2, 282.2]\n}\n\n# Create DataFrame\ndf = pd.DataFrame(data)\n\n# Display table\ndf\n\n\n\n\n\n\n\n\n\nyear\nus_population_million\n\n\n\n\n0\n1820\n9.6\n\n\n1\n1830\n12.9\n\n\n2\n1840\n17.1\n\n\n3\n1850\n23.2\n\n\n4\n1860\n31.4\n\n\n5\n1870\n38.6\n\n\n6\n1880\n50.2\n\n\n7\n1890\n62.9\n\n\n8\n1900\n76.0\n\n\n9\n1910\n92.0\n\n\n10\n1920\n106.5\n\n\n11\n1930\n123.2\n\n\n12\n2000\n282.2\n\n\n\n\n\n\n\nパラメーターを \\(N_0 = 3.9, k = 0.3134, N_\\infty = 197\\) と選ぶと\n\nCode\nt_index = np.linspace(0, (df.shape[0] + 10), 100)\nsol = solve_ivp(logistic_growth, [0, t_index[-1]], [3.9], t_eval=t_index, args=(0.3134, 197))\nplt.plot(1790 + sol.t*10, sol.y[0], linewidth=2, label=f\"prediction\")\nplt.scatter(\n    df.year,\n    df.us_population_million,\n    color=\"gray\",\n    alpha=0.8,\n    marker=\"x\",\n    label=\"actual data points\",\n)\nplt.xlabel('year')\nplt.ylabel('population(million)')\nplt.legend()\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 4: Model prediction vs actual USA population\n\n\n\nこのように, 1800-1930年のアメリカ人口動態を上手く説明するモデルとなっていることがわかります．一方，モデルの上限は \\(197\\times 10^6\\) であるが，2000年の人口は \\(282.2\\times 10^6\\) となっており，長期における人口動態を説明できるものにはなっていないことも読み取れます．\n\\(N_\\infty\\) の仮定が間違っていたと解釈することが一つ考えられますが，人口変化を支配する法則は技術変化や政治といった要因に影響を受けるため，常に同じ支配法則に基づいていると仮定することが間違っているとも解釈することが出来ます．"
  },
  {
    "objectID": "posts/2025-04-08-probability-matrix-exercise/index.html",
    "href": "posts/2025-04-08-probability-matrix-exercise/index.html",
    "title": "確率行列と固有値",
    "section": "",
    "text": "Exercise 1 \n\\(n\\) 次非負実行列 \\(A = (a_{ij})\\) が\n\\[\n\\sum_{j=1}^n a_{ij} = 1\n\\]\nを満たすとき，\\(A\\) を確率行列と呼ぶ． このとき，以下が成立することを示せ\n\\[\nA\\pmb f = \\pmb f\n\\]\nただし，\\(\\pmb f = (1, \\cdots 1)^T\\)， つまり \\(\\pmb f\\) はすべての成分が1であるような \\(n\\)項列ベクトルであるとする．\n\n\n\n\n\n\n\n\n\nNoteProof\n\n\n\n\n\n\\(A\\pmb f\\) は \\(n\\) 項列ベクトルとなるので，その第 \\(i\\) 項成分を \\(b_i\\) とすると\n\\[\n\\begin{align}\nb_i\n    &= \\sum_{j=1}^n a_{ij}f_j\\\\\n    &= \\sum_{j=1}^n a_{ij} \\quad (\\because f_j = 1)\\\\\n    &= 1\n\\end{align}\n\\]\n従って，\n\\[\nA\\pmb f = (1, \\cdots, 1)^T = \\pmb f\n\\]\n\n\n\n\n\nExercise 2 \n\\(A, B\\) が \\(n\\) 次確率行列であるとき，\\(AB\\) も確率行列であることを示せ\n\n\n\n\n\n\n\n\n\nNoteProof\n\n\n\n\n\n\\(AB = (c_{ij})\\) とするとき，\n\\[\n\\begin{align}\nc_{ij} = \\sum_{k=1}^n a_{ik}b_{kj}\n\\end{align}\n\\]\nとなります．このとき\n\\[\n\\begin{align}\n\\sum_{j=1}^n c_{ij}\n    &= \\sum_{j=1}^n\\sum_{k=1}^n a_{ik}b_{kj}\\\\\n    &= \\sum_{k=1}^n\\sum_{j=1}^n a_{ik}b_{kj}\\\\\n    &= \\sum_{k=1}^n a_{ik}(\\sum_{j=1}^n b_{kj})\\\\\n    &= \\sum_{k=1}^n a_{ik} \\quad (\\because \\sum_{j=1}^n b_{kj} = 1)\\\\\n    &= 1\n\\end{align}\n\\]\n従って，\\(A, B\\) が \\(n\\) 次確率行列であるとき，\\(AB\\) も確率行列である．\n\n\n\n\n\nExercise 3 \n\\(A\\) が確率行列のとき，複素数 \\(\\lambda\\) に対して \\(A\\pmb x = \\lambda \\pmb x\\) となるような列ベクトル \\(\\pmb x \\neq \\pmb 0\\) が存在すれば\n\\[\n|\\lambda| \\leq 1\n\\]\nとなることを示せ．\n\n\n\n\n\n\n\n\n\nNoteProof\n\n\n\n\n\n\\(\\pmb x\\) の成分のうち絶対値が最大となるような成分を \\(|x_p|\\) とすると\n\\[\n\\begin{align}\n\\lambda x_p = \\sum_{i=1}^n a_{pi} x_i\n\\end{align}\n\\]\nここで，両辺について絶対値を取ると\n\\[\n\\begin{align}\n|\\lambda x_p | &= |\\lambda|\\,|x_p|\\\\\n\\left|\\sum_{i=1}^n a_{pi} x_i\\right|\n    & \\leq \\sum_{i=1}^n a_{pi} |x_i| \\quad (\\because\\text{三角不等式})\\\\\n    & \\leq  \\sum_{i=1}^n a_{pi} |x_p|\\\\\n    &= |x_p| \\quad(\\because \\sum_{i=1}^n a_{pi} = 1)\n\\end{align}\n\\]\n従って，\n\\[\n|\\lambda|\\,|x_p| \\leq |x_p| \\Rightarrow |\\lambda|\\leq 1\n\\]"
  },
  {
    "objectID": "posts/2025-04-08-probability-matrix-exercise/index.html#problem",
    "href": "posts/2025-04-08-probability-matrix-exercise/index.html#problem",
    "title": "確率行列と固有値",
    "section": "",
    "text": "Exercise 1 \n\\(n\\) 次非負実行列 \\(A = (a_{ij})\\) が\n\\[\n\\sum_{j=1}^n a_{ij} = 1\n\\]\nを満たすとき，\\(A\\) を確率行列と呼ぶ． このとき，以下が成立することを示せ\n\\[\nA\\pmb f = \\pmb f\n\\]\nただし，\\(\\pmb f = (1, \\cdots 1)^T\\)， つまり \\(\\pmb f\\) はすべての成分が1であるような \\(n\\)項列ベクトルであるとする．\n\n\n\n\n\n\n\n\n\nNoteProof\n\n\n\n\n\n\\(A\\pmb f\\) は \\(n\\) 項列ベクトルとなるので，その第 \\(i\\) 項成分を \\(b_i\\) とすると\n\\[\n\\begin{align}\nb_i\n    &= \\sum_{j=1}^n a_{ij}f_j\\\\\n    &= \\sum_{j=1}^n a_{ij} \\quad (\\because f_j = 1)\\\\\n    &= 1\n\\end{align}\n\\]\n従って，\n\\[\nA\\pmb f = (1, \\cdots, 1)^T = \\pmb f\n\\]\n\n\n\n\n\nExercise 2 \n\\(A, B\\) が \\(n\\) 次確率行列であるとき，\\(AB\\) も確率行列であることを示せ\n\n\n\n\n\n\n\n\n\nNoteProof\n\n\n\n\n\n\\(AB = (c_{ij})\\) とするとき，\n\\[\n\\begin{align}\nc_{ij} = \\sum_{k=1}^n a_{ik}b_{kj}\n\\end{align}\n\\]\nとなります．このとき\n\\[\n\\begin{align}\n\\sum_{j=1}^n c_{ij}\n    &= \\sum_{j=1}^n\\sum_{k=1}^n a_{ik}b_{kj}\\\\\n    &= \\sum_{k=1}^n\\sum_{j=1}^n a_{ik}b_{kj}\\\\\n    &= \\sum_{k=1}^n a_{ik}(\\sum_{j=1}^n b_{kj})\\\\\n    &= \\sum_{k=1}^n a_{ik} \\quad (\\because \\sum_{j=1}^n b_{kj} = 1)\\\\\n    &= 1\n\\end{align}\n\\]\n従って，\\(A, B\\) が \\(n\\) 次確率行列であるとき，\\(AB\\) も確率行列である．\n\n\n\n\n\nExercise 3 \n\\(A\\) が確率行列のとき，複素数 \\(\\lambda\\) に対して \\(A\\pmb x = \\lambda \\pmb x\\) となるような列ベクトル \\(\\pmb x \\neq \\pmb 0\\) が存在すれば\n\\[\n|\\lambda| \\leq 1\n\\]\nとなることを示せ．\n\n\n\n\n\n\n\n\n\nNoteProof\n\n\n\n\n\n\\(\\pmb x\\) の成分のうち絶対値が最大となるような成分を \\(|x_p|\\) とすると\n\\[\n\\begin{align}\n\\lambda x_p = \\sum_{i=1}^n a_{pi} x_i\n\\end{align}\n\\]\nここで，両辺について絶対値を取ると\n\\[\n\\begin{align}\n|\\lambda x_p | &= |\\lambda|\\,|x_p|\\\\\n\\left|\\sum_{i=1}^n a_{pi} x_i\\right|\n    & \\leq \\sum_{i=1}^n a_{pi} |x_i| \\quad (\\because\\text{三角不等式})\\\\\n    & \\leq  \\sum_{i=1}^n a_{pi} |x_p|\\\\\n    &= |x_p| \\quad(\\because \\sum_{i=1}^n a_{pi} = 1)\n\\end{align}\n\\]\n従って，\n\\[\n|\\lambda|\\,|x_p| \\leq |x_p| \\Rightarrow |\\lambda|\\leq 1\n\\]"
  },
  {
    "objectID": "posts/2025-04-08-probability-matrix-exercise/index.html#appendix",
    "href": "posts/2025-04-08-probability-matrix-exercise/index.html#appendix",
    "title": "確率行列と固有値",
    "section": "Appendix",
    "text": "Appendix\n\n\nTheorem 1 : 転置行列の固有値 \n任意の \\(n\\) 次正方行列 \\(A\\) に対して，\\(A\\) の固有値と \\(A^T\\) の固有値は等しい\n\n\n\n\n\n\n\n\n\nNoteProof\n\n\n\n\n\n\\(A\\) の固有値を \\(\\lambda\\) とすると，\\(\\lambda\\) は次の固有方程式の解と対応します．\n\\[\n|\\lambda \\pmb I - A| = 0\n\\]\n行列式は転置不変性，つまり\n\\[\n|\\lambda \\pmb I - A| = |(\\lambda \\pmb I - A)^T|\n\\]\nという性質を持つので\n\\[\n\\begin{align}\n|(\\lambda \\pmb I - A)^T|\n    &= |(\\lambda \\pmb I^T - A^T)|\\\\\n    &= |(\\lambda \\pmb I - A^T)|\\\\\n    &= 0\n\\end{align}\n\\]\n従って，\\(\\lambda\\) は \\(A^T\\) の固有方程式の解となることがわかるので，\\(A\\) の固有値と \\(A^T\\) の固有値は等しいことがわかる．"
  },
  {
    "objectID": "posts/2025-02-14-shogi-getting-started/index.html",
    "href": "posts/2025-02-14-shogi-getting-started/index.html",
    "title": "本日の詰将棋: Quiz 1~5",
    "section": "",
    "text": "Figure 1\n\n\n\n\n📘 KeyPoints \n\n初手に５二銀と捨てて，馬の利きを確保するのがポイント"
  },
  {
    "objectID": "posts/2025-02-14-shogi-getting-started/index.html#quiz-1-馬の利き",
    "href": "posts/2025-02-14-shogi-getting-started/index.html#quiz-1-馬の利き",
    "title": "本日の詰将棋: Quiz 1~5",
    "section": "",
    "text": "Figure 1\n\n\n\n\n📘 KeyPoints \n\n初手に５二銀と捨てて，馬の利きを確保するのがポイント"
  },
  {
    "objectID": "posts/2025-02-14-shogi-getting-started/index.html#quiz-2-角よりも銀",
    "href": "posts/2025-02-14-shogi-getting-started/index.html#quiz-2-角よりも銀",
    "title": "本日の詰将棋: Quiz 1~5",
    "section": "Quiz 2: 角よりも銀",
    "text": "Quiz 2: 角よりも銀"
  },
  {
    "objectID": "posts/2025-02-14-shogi-getting-started/index.html#quiz-3-金頭桂",
    "href": "posts/2025-02-14-shogi-getting-started/index.html#quiz-3-金頭桂",
    "title": "本日の詰将棋: Quiz 1~5",
    "section": "Quiz 3: 金頭桂",
    "text": "Quiz 3: 金頭桂\n\n\n\n\n\n\nFigure 2\n\n\n\n\n📘 KeyPoints \n\n竜を切ってからの金頭桂"
  },
  {
    "objectID": "posts/2025-02-14-shogi-getting-started/index.html#quiz-4",
    "href": "posts/2025-02-14-shogi-getting-started/index.html#quiz-4",
    "title": "本日の詰将棋: Quiz 1~5",
    "section": "Quiz 4",
    "text": "Quiz 4\n\n\n\n\n\n\n\n\n\n\n\n派生：５三に歩が存在する場合\n相手玉の逃げ道が少なくなるので，一手早く積ませることが出来ます\n\n\n\n\n\n\nFigure 3"
  },
  {
    "objectID": "posts/2025-02-14-shogi-getting-started/index.html#quiz5-飛車を切る",
    "href": "posts/2025-02-14-shogi-getting-started/index.html#quiz5-飛車を切る",
    "title": "本日の詰将棋: Quiz 1~5",
    "section": "Quiz5: 飛車を切る",
    "text": "Quiz5: 飛車を切る\n\n\n\n\n\n\n\n\n\n\n\n📘 KeyPoints \n\n馬の利きを通すためあえて竜を切る\n金２枚の代わりに斜めのコマ一つ（金一 & 角 or 銀一）の場合でも詰むことができる"
  },
  {
    "objectID": "posts/2025-06-13-heat-and-work/index.html",
    "href": "posts/2025-06-13-heat-and-work/index.html",
    "title": "エントロピーとエンタルピー",
    "section": "",
    "text": "熱は，冷媒などの物質が保有しているエネルギーの１つの形態\n仕事もエネルギーの一つの形態\n\nそのため，熱と仕事は相互に変換することが可能です．\n\n\n仕事⇒発熱\n\n\n\n仕事による摩擦熱の発生\n\n\n\n発熱⇒仕事\n\n\n\n\n加熱時の気体の膨張による仕事\n\n\n\n\n\n流体（特に気体）を加熱すると，体積膨張を通して外部に対して仕事をするようになります． 右上図が示すようにシリンダとピストンに閉じ込められた空間内の気体（閉鎖系）に熱を加えると，\n\n気体は温度が上昇（=内部エネルギーの増加）\n気体は膨張することによって，ピストンを押し下げ，外部に対して仕事する\n\nという状態の変化が生じます．シリンダ内の1kgあたりの気体について考えると\n\\[\nq_{12} = u_2 - u_1 + w_{12} \\label{first-law}\n\\]\n\n\\(q_{12}\\): 気体に加えられた熱量 [kJ/kg]\n\\(u_i\\): 状態 \\(i\\) の内部エネルギーの変化\n\\(w_{12}\\): 状態変化に伴って発生する外部になす仕事\n状態1: 変化前の状態\n状態2: 変化後の状態\n\n\\(\\eqref{first-law}\\) を閉鎖系の熱力学第一法則（エネルギー保存則）といいます．これを微小な変化に対して表すと\n\\[\ndq = du + dw \\label{first-law-2}\n\\]\n\n\n\nシリンダは閉鎖系\nシリンダは断熱素材でできている(断熱変化)\nシリンダとピストンの間の摩擦および気体の流動摩擦は発生しない\nピストンに作用する圧力は空間内の圧力に等しい\n\nと仮定します．系が外部にする仕事は，系が膨張することを通して行われます．またピストンの観点からみると\n\\[\n\\text{仕事 [J]} = \\text{力 [N]}\\times\\text{移動距離 [m]}\n\\]\nです．ピストンの断面積にかかる力は \\(\\text{圧力}\\times \\text{断面積}\\) で表せるので\n\\[\ndw = pAdx = pdv \\label{absolute-work}\n\\]\n\n\\(A\\): ピストンの断面積 [\\(\\text{m}^2\\)]\n\\(p\\): シリンダ内圧力 [kPa]\n\\(x\\): 気体膨張に伴うピストン上昇距離 [m]\n\\(v\\): 気体の比体積 [\\(\\text{m}^3\\)/kg]\n\n\\(\\eqref{absolute-work}\\) より気体がなす仕事 \\(w_{12}\\) は\n\\[\nw_{12} = \\int^2_1 p dv\n\\]\nと計算できます．\n\n\nCode\nimport matplotlib.pyplot as plt\nimport numpy as np\n\ndef plot_pv_diagram():\n    # 理想気体の比熱比 (γ) を設定\n    # 断熱変化は PV^γ = const で表される\n    gamma = 1.4  # 単原子分子理想気体の場合 5/3 = 1.67, 二原子分子理想気体の場合 7/5 = 1.4\n\n    # 点 A の状態量\n    PA = 4.0  # P軸のスケールに合わせて適当な値に調整\n    VA = 1.0  # V軸のスケールに合わせて適当な値に調整\n    TA = PA * VA # PV = nRT なので，T は PV に比例すると考えられる\n\n    # 点 B の状態量 (断熱変化による)\n    # PB * VB^gamma = PA * VA^gamma\n    # ここでは，VB を仮定して PB を計算する\n    VB = 5.0 # VAより大きい値で，グラフに収まるように適当に設定\n    PB = PA * (VA / VB)**gamma\n\n    # 等温変化の計算 (PV = const)\n    # T = TA の等温線\n    V_iso_TA = np.linspace(0.5, 7.0, 100) # 広めの範囲でプロット\n    V_iso_TB = np.linspace(0.5, 7.0, 100) # 広めの範囲でプロット\n    P_iso_TA = (PA * VA) / V_iso_TA\n    P_iso_TB = (PA * VB) / V_iso_TB\n\n    # T = TB の等温線\n    # TB = PB * VB\n    P_iso_TB = (PB * VB) / V_iso_TA # 同じV範囲で計算\n\n    # 断熱変化の計算 (PV^gamma = const)\n    V_adiabatic = np.linspace(VA, VB, 100) # AからBまでの範囲\n    P_adiabatic = PA * (VA / V_adiabatic)**gamma\n\n    # Matplotlibでプロット\n    plt.figure(figsize=(8, 6))\n\n    # 断熱変化の曲線 (AからB)\n    plt.plot(V_adiabatic, P_adiabatic, color='blue', linewidth=2, label='断熱変化')\n    plt.plot([VA, VA], [0, PA], 'k:', linewidth=0.8) # 垂直な点線\n    plt.plot([0, VA], [PA, PA], 'k:', linewidth=0.8) # 水平な点線\n    plt.plot([VB, VB], [0, PB], 'k:', linewidth=0.8) # 垂直な点線\n    plt.plot([0, VB], [PB, PB], 'k:', linewidth=0.8) # 水平な点線\n\n    # 等温変化の曲線\n    plt.plot(V_iso_TA, P_iso_TA, 'k--', linewidth=0.8, label='等温変化')\n    plt.text(V_iso_TA[-1] * 0.9, P_iso_TA[-1] * 1.1, f'T = TA', fontsize=10, ha='right', va='bottom',\n             bbox=dict(boxstyle=\"round,pad=0.3\", fc=\"white\", ec=\"gray\", lw=0.5))\n\n    plt.plot(V_iso_TB, P_iso_TB, 'k--', linewidth=0.8)\n    plt.text(V_iso_TB[20] * 0.8, P_iso_TB[20] * 0.8, f'T = TB', fontsize=10, ha='left', va='top',\n             bbox=dict(boxstyle=\"round,pad=0.3\", fc=\"white\", ec=\"gray\", lw=0.5))\n\n\n    # 点 A と 点 B のプロット\n    plt.plot(VA, PA, 'ko', markersize=6)\n    plt.text(VA * 0.95, PA * 1.05, 'A', fontsize=12, ha='right')\n\n    plt.plot(VB, PB, 'ko', markersize=6)\n    plt.text(VB * 1.02, PB * 0.9, 'B', fontsize=12, ha='left')\n\n    # 軸ラベルとタイトル\n    plt.xlabel('v')\n    plt.ylabel('p')\n    plt.title('PV plot')\n\n    # 軸の範囲を設定\n    plt.xlim(0, 7.5)\n    plt.ylim(0, 5.0)\n\n    # 凡例\n    # plt.legend() # 等温変化と断熱変化の凡例は曲線上に直接記述した方が見やすいかも\n\n    # グリッド\n    plt.grid(True, linestyle=':', alpha=0.6)\n\n    # 軸の目盛りとラベル\n    plt.xticks([VA, VB], [f'$v_1$', f'$v_2$'])\n    plt.yticks([PB, PA], [f'$p_2$', f'$p_1$'])\n\n    plt.tight_layout()\n    plt.show()\n\n# 関数を呼び出してグラフを表示\nplot_pv_diagram()\n\n\n\n\n\n\n\n\nFigure 1\n\n\n\n\n\n圧力一定のもとで熱を加える\n圧力一定のもとで熱を加える場合，\\(\\eqref{first-law-2}\\) は定圧比熱 \\(c_p\\) [kJ/kg･K] を用いると\n\\[\n\\begin{align}\ndq\n  &= c_pdT\\\\\n  &= du + pdv\n\\end{align}\n\\]\n容積一定のもとで熱を加える\nふたや壁が動かなくて外に膨張できない状況で気体を加熱すると，\\(dv = dw = 0\\) とみなせるので，定容比熱 \\(c_v\\) [kJ/kg･K] を用いると\n\\[\ndq = c_vdT = du\n\\]\n断熱圧縮時の内部エネルギー増大\n\\(\\eqref{first-law}\\) において，状態1から状態2 へ変化するとき熱の授受のない断熱圧縮を考えます．このとき，\n\\[\ndq = 0\n\\]\nであり，圧縮仮定で気体の定容比熱が変わらないとすると\n\n\nCode\nimport matplotlib.pyplot as plt\nimport numpy as np\n\ndef plot_pv_diagram():\n    # 理想気体の比熱比 (γ) を設定\n    # 断熱変化は PV^γ = const で表される\n    gamma = 1.4  # 単原子分子理想気体の場合 5/3 = 1.67, 二原子分子理想気体の場合 7/5 = 1.4\n\n    # 点 A の状態量\n    PA = 4.0  # P軸のスケールに合わせて適当な値に調整\n    VA = 1.0  # V軸のスケールに合わせて適当な値に調整\n    TA = PA * VA # PV = nRT なので，T は PV に比例すると考えられる\n\n    # 点 B の状態量 (断熱変化による)\n    # PB * VB^gamma = PA * VA^gamma\n    # ここでは，VB を仮定して PB を計算する\n    VB = 5.0 # VAより大きい値で，グラフに収まるように適当に設定\n    PB = PA * (VA / VB)**gamma\n\n    # 等温変化の計算 (PV = const)\n    # T = TA の等温線\n    V_iso_TA = np.linspace(0.5, 7.0, 100) # 広めの範囲でプロット\n    V_iso_TB = np.linspace(0.5, 7.0, 100) # 広めの範囲でプロット\n    P_iso_TA = (PA * VA) / V_iso_TA\n    P_iso_TB = (PA * VB) / V_iso_TB\n\n    # T = TB の等温線\n    # TB = PB * VB\n    P_iso_TB = (PB * VB) / V_iso_TA # 同じV範囲で計算\n\n    # 断熱変化の計算 (PV^gamma = const)\n    V_adiabatic = np.linspace(VA, VB, 100) # AからBまでの範囲\n    P_adiabatic = PA * (VA / V_adiabatic)**gamma\n\n    # Matplotlibでプロット\n    plt.figure(figsize=(8, 6))\n\n    # 断熱変化の曲線 (AからB)\n    plt.plot(V_adiabatic, P_adiabatic, color='blue', linewidth=2, label='断熱変化')\n    plt.plot([VA, VA], [0, PA], 'k:', linewidth=0.8) # 垂直な点線\n    plt.plot([0, VA], [PA, PA], 'k:', linewidth=0.8) # 水平な点線\n    plt.plot([VB, VB], [0, PB], 'k:', linewidth=0.8) # 垂直な点線\n    plt.plot([0, VB], [PB, PB], 'k:', linewidth=0.8) # 水平な点線\n\n    # 等温変化の曲線\n    plt.plot(V_iso_TA, P_iso_TA, 'k--', linewidth=0.8, label='等温変化')\n    plt.text(V_iso_TA[-1] * 0.9, P_iso_TA[-1] * 1.1, f'T = TA', fontsize=10, ha='right', va='bottom',\n             bbox=dict(boxstyle=\"round,pad=0.3\", fc=\"white\", ec=\"gray\", lw=0.5))\n\n    plt.plot(V_iso_TB, P_iso_TB, 'k--', linewidth=0.8)\n    plt.text(V_iso_TB[20] * 0.8, P_iso_TB[20] * 0.8, f'T = TB', fontsize=10, ha='left', va='top',\n             bbox=dict(boxstyle=\"round,pad=0.3\", fc=\"white\", ec=\"gray\", lw=0.5))\n\n\n    # 点 A と 点 B のプロット\n    plt.plot(VA, PA, 'ko', markersize=6)\n    plt.text(VA * 0.95, PA * 1.05, 'A', fontsize=12, ha='right')\n\n    plt.plot(VB, PB, 'ko', markersize=6)\n    plt.text(VB * 1.02, PB * 0.9, 'B', fontsize=12, ha='left')\n\n    # 軸ラベルとタイトル\n    plt.xlabel('v')\n    plt.ylabel('p')\n    plt.title('PV plot')\n\n    # 軸の範囲を設定\n    plt.xlim(0, 7.5)\n    plt.ylim(0, 5.0)\n\n    # 凡例\n    # plt.legend() # 等温変化と断熱変化の凡例は曲線上に直接記述した方が見やすいかも\n\n    # グリッド\n    plt.grid(True, linestyle=':', alpha=0.6)\n\n    # 軸の目盛りとラベル\n    plt.xticks([VA, VB], [f'$v_2$', f'$v_1$'])\n    plt.yticks([PB, PA], [f'$p_1$', f'$p_2$'])\n\n    plt.tight_layout()\n    plt.show()\n\n# 関数を呼び出してグラフを表示\nplot_pv_diagram()\n\n\n\n\n\n\n\n\nFigure 2\n\n\n\n\n\n\\[\n\\begin{align}\nc_vdT &= -p dv\\\\\n\\int_{\\text{state 1}}^{\\text{state 2}}c_vdT\n  &= u_2 - u_1\\\\\n  &= -\\int_{v1}^{v2}p dv\n\\end{align}\n\\]\n圧縮の場合 \\(\\int_{v1}^{v2}p dv\\) は負となります．これは外部から仕事がなされることを意味します．熱力学第一法則法則より，外部からの仕事は比内部エネルギー \\(u\\) の増加に使われることになります．"
  },
  {
    "objectID": "posts/2025-06-13-heat-and-work/index.html#熱と仕事の基礎事項",
    "href": "posts/2025-06-13-heat-and-work/index.html#熱と仕事の基礎事項",
    "title": "エントロピーとエンタルピー",
    "section": "",
    "text": "熱は，冷媒などの物質が保有しているエネルギーの１つの形態\n仕事もエネルギーの一つの形態\n\nそのため，熱と仕事は相互に変換することが可能です．\n\n\n仕事⇒発熱\n\n\n\n仕事による摩擦熱の発生\n\n\n\n発熱⇒仕事\n\n\n\n\n加熱時の気体の膨張による仕事\n\n\n\n\n\n流体（特に気体）を加熱すると，体積膨張を通して外部に対して仕事をするようになります． 右上図が示すようにシリンダとピストンに閉じ込められた空間内の気体（閉鎖系）に熱を加えると，\n\n気体は温度が上昇（=内部エネルギーの増加）\n気体は膨張することによって，ピストンを押し下げ，外部に対して仕事する\n\nという状態の変化が生じます．シリンダ内の1kgあたりの気体について考えると\n\\[\nq_{12} = u_2 - u_1 + w_{12} \\label{first-law}\n\\]\n\n\\(q_{12}\\): 気体に加えられた熱量 [kJ/kg]\n\\(u_i\\): 状態 \\(i\\) の内部エネルギーの変化\n\\(w_{12}\\): 状態変化に伴って発生する外部になす仕事\n状態1: 変化前の状態\n状態2: 変化後の状態\n\n\\(\\eqref{first-law}\\) を閉鎖系の熱力学第一法則（エネルギー保存則）といいます．これを微小な変化に対して表すと\n\\[\ndq = du + dw \\label{first-law-2}\n\\]\n\n\n\nシリンダは閉鎖系\nシリンダは断熱素材でできている(断熱変化)\nシリンダとピストンの間の摩擦および気体の流動摩擦は発生しない\nピストンに作用する圧力は空間内の圧力に等しい\n\nと仮定します．系が外部にする仕事は，系が膨張することを通して行われます．またピストンの観点からみると\n\\[\n\\text{仕事 [J]} = \\text{力 [N]}\\times\\text{移動距離 [m]}\n\\]\nです．ピストンの断面積にかかる力は \\(\\text{圧力}\\times \\text{断面積}\\) で表せるので\n\\[\ndw = pAdx = pdv \\label{absolute-work}\n\\]\n\n\\(A\\): ピストンの断面積 [\\(\\text{m}^2\\)]\n\\(p\\): シリンダ内圧力 [kPa]\n\\(x\\): 気体膨張に伴うピストン上昇距離 [m]\n\\(v\\): 気体の比体積 [\\(\\text{m}^3\\)/kg]\n\n\\(\\eqref{absolute-work}\\) より気体がなす仕事 \\(w_{12}\\) は\n\\[\nw_{12} = \\int^2_1 p dv\n\\]\nと計算できます．\n\n\nCode\nimport matplotlib.pyplot as plt\nimport numpy as np\n\ndef plot_pv_diagram():\n    # 理想気体の比熱比 (γ) を設定\n    # 断熱変化は PV^γ = const で表される\n    gamma = 1.4  # 単原子分子理想気体の場合 5/3 = 1.67, 二原子分子理想気体の場合 7/5 = 1.4\n\n    # 点 A の状態量\n    PA = 4.0  # P軸のスケールに合わせて適当な値に調整\n    VA = 1.0  # V軸のスケールに合わせて適当な値に調整\n    TA = PA * VA # PV = nRT なので，T は PV に比例すると考えられる\n\n    # 点 B の状態量 (断熱変化による)\n    # PB * VB^gamma = PA * VA^gamma\n    # ここでは，VB を仮定して PB を計算する\n    VB = 5.0 # VAより大きい値で，グラフに収まるように適当に設定\n    PB = PA * (VA / VB)**gamma\n\n    # 等温変化の計算 (PV = const)\n    # T = TA の等温線\n    V_iso_TA = np.linspace(0.5, 7.0, 100) # 広めの範囲でプロット\n    V_iso_TB = np.linspace(0.5, 7.0, 100) # 広めの範囲でプロット\n    P_iso_TA = (PA * VA) / V_iso_TA\n    P_iso_TB = (PA * VB) / V_iso_TB\n\n    # T = TB の等温線\n    # TB = PB * VB\n    P_iso_TB = (PB * VB) / V_iso_TA # 同じV範囲で計算\n\n    # 断熱変化の計算 (PV^gamma = const)\n    V_adiabatic = np.linspace(VA, VB, 100) # AからBまでの範囲\n    P_adiabatic = PA * (VA / V_adiabatic)**gamma\n\n    # Matplotlibでプロット\n    plt.figure(figsize=(8, 6))\n\n    # 断熱変化の曲線 (AからB)\n    plt.plot(V_adiabatic, P_adiabatic, color='blue', linewidth=2, label='断熱変化')\n    plt.plot([VA, VA], [0, PA], 'k:', linewidth=0.8) # 垂直な点線\n    plt.plot([0, VA], [PA, PA], 'k:', linewidth=0.8) # 水平な点線\n    plt.plot([VB, VB], [0, PB], 'k:', linewidth=0.8) # 垂直な点線\n    plt.plot([0, VB], [PB, PB], 'k:', linewidth=0.8) # 水平な点線\n\n    # 等温変化の曲線\n    plt.plot(V_iso_TA, P_iso_TA, 'k--', linewidth=0.8, label='等温変化')\n    plt.text(V_iso_TA[-1] * 0.9, P_iso_TA[-1] * 1.1, f'T = TA', fontsize=10, ha='right', va='bottom',\n             bbox=dict(boxstyle=\"round,pad=0.3\", fc=\"white\", ec=\"gray\", lw=0.5))\n\n    plt.plot(V_iso_TB, P_iso_TB, 'k--', linewidth=0.8)\n    plt.text(V_iso_TB[20] * 0.8, P_iso_TB[20] * 0.8, f'T = TB', fontsize=10, ha='left', va='top',\n             bbox=dict(boxstyle=\"round,pad=0.3\", fc=\"white\", ec=\"gray\", lw=0.5))\n\n\n    # 点 A と 点 B のプロット\n    plt.plot(VA, PA, 'ko', markersize=6)\n    plt.text(VA * 0.95, PA * 1.05, 'A', fontsize=12, ha='right')\n\n    plt.plot(VB, PB, 'ko', markersize=6)\n    plt.text(VB * 1.02, PB * 0.9, 'B', fontsize=12, ha='left')\n\n    # 軸ラベルとタイトル\n    plt.xlabel('v')\n    plt.ylabel('p')\n    plt.title('PV plot')\n\n    # 軸の範囲を設定\n    plt.xlim(0, 7.5)\n    plt.ylim(0, 5.0)\n\n    # 凡例\n    # plt.legend() # 等温変化と断熱変化の凡例は曲線上に直接記述した方が見やすいかも\n\n    # グリッド\n    plt.grid(True, linestyle=':', alpha=0.6)\n\n    # 軸の目盛りとラベル\n    plt.xticks([VA, VB], [f'$v_1$', f'$v_2$'])\n    plt.yticks([PB, PA], [f'$p_2$', f'$p_1$'])\n\n    plt.tight_layout()\n    plt.show()\n\n# 関数を呼び出してグラフを表示\nplot_pv_diagram()\n\n\n\n\n\n\n\n\nFigure 1\n\n\n\n\n\n圧力一定のもとで熱を加える\n圧力一定のもとで熱を加える場合，\\(\\eqref{first-law-2}\\) は定圧比熱 \\(c_p\\) [kJ/kg･K] を用いると\n\\[\n\\begin{align}\ndq\n  &= c_pdT\\\\\n  &= du + pdv\n\\end{align}\n\\]\n容積一定のもとで熱を加える\nふたや壁が動かなくて外に膨張できない状況で気体を加熱すると，\\(dv = dw = 0\\) とみなせるので，定容比熱 \\(c_v\\) [kJ/kg･K] を用いると\n\\[\ndq = c_vdT = du\n\\]\n断熱圧縮時の内部エネルギー増大\n\\(\\eqref{first-law}\\) において，状態1から状態2 へ変化するとき熱の授受のない断熱圧縮を考えます．このとき，\n\\[\ndq = 0\n\\]\nであり，圧縮仮定で気体の定容比熱が変わらないとすると\n\n\nCode\nimport matplotlib.pyplot as plt\nimport numpy as np\n\ndef plot_pv_diagram():\n    # 理想気体の比熱比 (γ) を設定\n    # 断熱変化は PV^γ = const で表される\n    gamma = 1.4  # 単原子分子理想気体の場合 5/3 = 1.67, 二原子分子理想気体の場合 7/5 = 1.4\n\n    # 点 A の状態量\n    PA = 4.0  # P軸のスケールに合わせて適当な値に調整\n    VA = 1.0  # V軸のスケールに合わせて適当な値に調整\n    TA = PA * VA # PV = nRT なので，T は PV に比例すると考えられる\n\n    # 点 B の状態量 (断熱変化による)\n    # PB * VB^gamma = PA * VA^gamma\n    # ここでは，VB を仮定して PB を計算する\n    VB = 5.0 # VAより大きい値で，グラフに収まるように適当に設定\n    PB = PA * (VA / VB)**gamma\n\n    # 等温変化の計算 (PV = const)\n    # T = TA の等温線\n    V_iso_TA = np.linspace(0.5, 7.0, 100) # 広めの範囲でプロット\n    V_iso_TB = np.linspace(0.5, 7.0, 100) # 広めの範囲でプロット\n    P_iso_TA = (PA * VA) / V_iso_TA\n    P_iso_TB = (PA * VB) / V_iso_TB\n\n    # T = TB の等温線\n    # TB = PB * VB\n    P_iso_TB = (PB * VB) / V_iso_TA # 同じV範囲で計算\n\n    # 断熱変化の計算 (PV^gamma = const)\n    V_adiabatic = np.linspace(VA, VB, 100) # AからBまでの範囲\n    P_adiabatic = PA * (VA / V_adiabatic)**gamma\n\n    # Matplotlibでプロット\n    plt.figure(figsize=(8, 6))\n\n    # 断熱変化の曲線 (AからB)\n    plt.plot(V_adiabatic, P_adiabatic, color='blue', linewidth=2, label='断熱変化')\n    plt.plot([VA, VA], [0, PA], 'k:', linewidth=0.8) # 垂直な点線\n    plt.plot([0, VA], [PA, PA], 'k:', linewidth=0.8) # 水平な点線\n    plt.plot([VB, VB], [0, PB], 'k:', linewidth=0.8) # 垂直な点線\n    plt.plot([0, VB], [PB, PB], 'k:', linewidth=0.8) # 水平な点線\n\n    # 等温変化の曲線\n    plt.plot(V_iso_TA, P_iso_TA, 'k--', linewidth=0.8, label='等温変化')\n    plt.text(V_iso_TA[-1] * 0.9, P_iso_TA[-1] * 1.1, f'T = TA', fontsize=10, ha='right', va='bottom',\n             bbox=dict(boxstyle=\"round,pad=0.3\", fc=\"white\", ec=\"gray\", lw=0.5))\n\n    plt.plot(V_iso_TB, P_iso_TB, 'k--', linewidth=0.8)\n    plt.text(V_iso_TB[20] * 0.8, P_iso_TB[20] * 0.8, f'T = TB', fontsize=10, ha='left', va='top',\n             bbox=dict(boxstyle=\"round,pad=0.3\", fc=\"white\", ec=\"gray\", lw=0.5))\n\n\n    # 点 A と 点 B のプロット\n    plt.plot(VA, PA, 'ko', markersize=6)\n    plt.text(VA * 0.95, PA * 1.05, 'A', fontsize=12, ha='right')\n\n    plt.plot(VB, PB, 'ko', markersize=6)\n    plt.text(VB * 1.02, PB * 0.9, 'B', fontsize=12, ha='left')\n\n    # 軸ラベルとタイトル\n    plt.xlabel('v')\n    plt.ylabel('p')\n    plt.title('PV plot')\n\n    # 軸の範囲を設定\n    plt.xlim(0, 7.5)\n    plt.ylim(0, 5.0)\n\n    # 凡例\n    # plt.legend() # 等温変化と断熱変化の凡例は曲線上に直接記述した方が見やすいかも\n\n    # グリッド\n    plt.grid(True, linestyle=':', alpha=0.6)\n\n    # 軸の目盛りとラベル\n    plt.xticks([VA, VB], [f'$v_2$', f'$v_1$'])\n    plt.yticks([PB, PA], [f'$p_1$', f'$p_2$'])\n\n    plt.tight_layout()\n    plt.show()\n\n# 関数を呼び出してグラフを表示\nplot_pv_diagram()\n\n\n\n\n\n\n\n\nFigure 2\n\n\n\n\n\n\\[\n\\begin{align}\nc_vdT &= -p dv\\\\\n\\int_{\\text{state 1}}^{\\text{state 2}}c_vdT\n  &= u_2 - u_1\\\\\n  &= -\\int_{v1}^{v2}p dv\n\\end{align}\n\\]\n圧縮の場合 \\(\\int_{v1}^{v2}p dv\\) は負となります．これは外部から仕事がなされることを意味します．熱力学第一法則法則より，外部からの仕事は比内部エネルギー \\(u\\) の増加に使われることになります．"
  },
  {
    "objectID": "posts/2025-06-13-heat-and-work/index.html#エンタルピー",
    "href": "posts/2025-06-13-heat-and-work/index.html#エンタルピー",
    "title": "エントロピーとエンタルピー",
    "section": "エンタルピー",
    "text": "エンタルピー\n\nDefinition 1 エンタルピー\n流動過程にある気体/流体が保有する状態量としてのエネルギーは，運動エネルギーや位置エネルギーが無視できる場合には，エンタルピー \\(H\\) [kJ] で表される． 質量 1kg あたりのエンタルピーを比エンタルピー \\(h\\) [kJ/kg] という．\n比エンタルピー \\(h\\) は比内部エネルギー \\(u\\), 流動仕事 \\(pv\\) との和で以下のように表せる：\n\\[\nh = u + pv\n\\]\n\n全微分の公式を用いると比エンタルピーの変化は\n\\[\ndh = du + pdv + vdp\n\\]\nここで \\(\\eqref{first-law-2}\\) を用いて再整理すると\n\\[\ndh = dq + vdp\n\\]\nしたがって，状態1から状態2へ変化する場合\n\\[\n\\begin{align}\nh_2 - h_1\n  &= q_{12} + \\int^2_1vdp \\label{enthalpy-diff}\n\\end{align}\n\\]\n流動系において，運動エネルギーや位置エネルギーが無視できる場合には\n\\[\nq_{12} - l_{12} = h_2 - h_1\n\\]\nこの \\(l_{12}\\) を工業仕事 といい，流動過程において流体と外部の間で実際に授受される仕事です．\n\\(\\eqref{enthalpy-diff}\\) より\n\\[\nl_{12} = -\\int^2_1vdp\n\\]\n圧縮の場合，RHSは負の値になります．\n断熱圧縮の場合\n断熱圧縮の場合，外から受け取る熱量はないので \\(dq = 0\\) つまり，\n\\[\nh_2 - h_1 = \\int^2_1 vdp\n\\]\nこのとき，\\(h_2 - h_1\\) は下のp-v線図上で 1-2-3-4-1 で囲まれた面積で表されます．\n\n\nCode\nimport matplotlib.pyplot as plt\nimport numpy as np\n\ndef plot_pv_diagram():\n    # 理想気体の比熱比 (γ) を設定\n    # 断熱変化は PV^γ = const で表される\n    gamma = 1.4  # 単原子分子理想気体の場合 5/3 = 1.67, 二原子分子理想気体の場合 7/5 = 1.4\n\n    # 点 A の状態量\n    PA = 4.0  # P軸のスケールに合わせて適当な値に調整\n    VA = 1.0  # V軸のスケールに合わせて適当な値に調整\n    TA = PA * VA # PV = nRT なので，T は PV に比例すると考えられる\n\n    # 点 B の状態量 (断熱変化による)\n    # PB * VB^gamma = PA * VA^gamma\n    # ここでは，VB を仮定して PB を計算する\n    VB = 5.0 # VAより大きい値で，グラフに収まるように適当に設定\n    PB = PA * (VA / VB)**gamma\n\n    # 等温変化の計算 (PV = const)\n    # T = TA の等温線\n    V_iso_TA = np.linspace(0.5, 7.0, 100) # 広めの範囲でプロット\n    V_iso_TB = np.linspace(0.5, 7.0, 100) # 広めの範囲でプロット\n    P_iso_TA = (PA * VA) / V_iso_TA\n    P_iso_TB = (PA * VB) / V_iso_TB\n\n    # T = TB の等温線\n    # TB = PB * VB\n    P_iso_TB = (PB * VB) / V_iso_TA # 同じV範囲で計算\n\n    # 断熱変化の計算 (PV^gamma = const)\n    V_adiabatic = np.linspace(VA, VB, 100) # AからBまでの範囲\n    P_adiabatic = PA * (VA / V_adiabatic)**gamma\n\n    # Matplotlibでプロット\n    plt.figure(figsize=(8, 6))\n\n    # 断熱変化の曲線 (AからB)\n    plt.plot(V_adiabatic, P_adiabatic, color='blue', linewidth=2, label='断熱変化')\n    plt.plot([VA, VA], [0, PA], 'k:', linewidth=0.8) # 垂直な点線\n    plt.plot([0, VA], [PA, PA], 'k:', linewidth=0.8) # 水平な点線\n    plt.plot([VB, VB], [0, PB], 'k:', linewidth=0.8) # 垂直な点線\n    plt.plot([0, VB], [PB, PB], 'k:', linewidth=0.8) # 水平な点線\n\n\n    # 点 A と 点 B のプロット\n    plt.plot(VA, PA, 'ko', markersize=6)\n    plt.text(VA * 0.95, PA * 1.05, '2', fontsize=12, ha='right')\n    plt.text(0, -0.25, '0', fontsize=12, ha='center')\n\n    plt.plot(VB, PB, 'ko', markersize=6)\n    plt.text(VB * 1.02, PB * 0.9, '1', fontsize=12, ha='left')\n\n    # 軸ラベルとタイトル\n    plt.xlabel('v')\n    plt.ylabel('p')\n    plt.title('Enthalpy increase during adiabatic compression')\n\n    # 軸の範囲を設定\n    plt.xlim(0, 7.5)\n    plt.ylim(0, 5.0)\n\n    # 凡例\n    # plt.legend() # 等温変化と断熱変化の凡例は曲線上に直接記述した方が見やすいかも\n\n    # グリッド\n    plt.grid(True, linestyle=':', alpha=0.6)\n\n    # 軸の目盛りとラベル\n    plt.xticks([VA, VB], [f'2\\'', f'1\\''], fontsize=12)\n    plt.yticks([PB, PA], [f'4', f'3'], fontsize=12)\n\n    plt.tight_layout()\n    plt.show()\n\n# 関数を呼び出してグラフを表示\nplot_pv_diagram()\n\n\n\n\n\n\n\n\nFigure 3: Adiabatic compression process shown on a PV diagram\n\n\n\n\n\n\n工業仕事\n\n\n\n\n\n\n\n\n\n\n左図のような流動系の往復圧縮機での圧縮を考えます．プロセスは\n\n上死点から下死点までピストンが下がったとき，Figure 3 の状態1に相当する空気をを吸い込みます（\\(p_1v_1\\) の外部から流入する仕事）\nその後，ピストンを２の地点まで動かして断熱圧縮 = 状態1→状態2へ断熱圧縮\nピストンが2から上死点の間は吐出し弁が開き，気体を流出させることで \\(p_2v_2\\) の仕事を流出\n\n\n\n\n流体の吐出しによる外部への仕事\n吐出し弁から流体を流出させることで外部になす仕事は Figure 3 の 2'-2-3-0 の面積に相当するので\n\\[\n\\text{流体の吐出しによる外部への仕事} = p_2v_2\n\\]\n流体の吸込みによる外部からの仕事\nピストンの下降の家庭で吸込み弁からシリンダ内に流入する気体が，シリンダ内の期待に対してする仕事は Figure 3 の 1'-1-4-0 の面積に相当するので\n\\[\n\\text{流体の吸込みによる外部からの仕事} = p_1v_1\n\\]\n流体圧縮に要する絶対仕事\nシリンダ内の気体の圧縮に必要な仕事は Figure 3 の 1'-1-2-2' の面積に相当するので\n\\[\n\\text{流体圧縮に要する絶対仕事} = \\int_1^2 pdv\n\\]\n断熱の流動系が外部になす仕事\n断熱の流動系が外部になす仕事は，絶対仕事 \\(w_{12}\\) より流動仕事を引けば良いので\n\\[\n\\begin{align}\nw_{12} - (p_2v_2 - p_1v_1)\n  &= - \\int^2_1vdp\\\\\n  &= l_{12}\n\\end{align}\n\\]\n圧縮の場合は，仕事が入ってくるので右辺の値は負の値になります．断熱圧縮では加わった仕事に相当するだけ圧縮気体の比エンタルピーは増大することになります．\n\\(\\eqref{enthalpy-diff}\\) と照らし合わせると，熱交換がある場合の圧縮では，出入りした熱量 \\(q_{12}\\) に相当するだけd比エンタルピーが増減することがわかります．"
  },
  {
    "objectID": "posts/2025-06-13-heat-and-work/index.html#エントロピー",
    "href": "posts/2025-06-13-heat-and-work/index.html#エントロピー",
    "title": "エントロピーとエンタルピー",
    "section": "エントロピー",
    "text": "エントロピー\n\nDefinition 2 エントロピー\nエントロピーとは，ある変化が可逆変化とどの程度違うかを示す状態量のこと．単位質量の流体にある絶対温度 \\(T(K)\\) で熱量 \\(dq\\) が加えられた場合， \\(dq/T\\) を比エントロピー増加量 \\(ds\\) [J/kg･K] で表現される．\n\n可逆変化かつ断熱 → \\(ds = 0\\)\n不可逆変化では \\(ds &gt; 0\\)\n\n\n可逆断熱変化とエントロピー変化\n可逆断熱変化では \\(dq = 0\\) となるので定義より\n\\[\nds = 0\n\\]\nしたがって，可逆断熱変化は等比エントロピー変化であることがわかります．\n\n\n\n\n\n\nTip冷凍サイクルにおける断熱膨張\n\n\n\n断熱圧縮のコンプレッサーを冷媒で駆動すると原理的には断熱膨張エンジンになります． 理想の圧縮工程では，冷媒とシリンダとの間に熱の出入りの無い断熱圧縮をし，エントロピー変化もゼロです（=可逆変化）．ただし，断熱変化は必ずしも可逆変化ではありません．\n例えば，膨張弁は断熱変化ですが可逆変化ではありません．「熱力学の第二法則より物質は高圧から低圧に流れ，逆には流れない」のが直感的説明です． また，凝縮，蒸発の行程は全て不可逆変化で，エントロピーは増加します。\n\n\n等圧変化とエントロピー変化\n等圧変化を考えると，\n\\[\ndq = c_p dT\n\\]\nより\n\\[\nds = c_p \\frac{dT}{T}\n\\]\nしたがって，熱交換器のような等圧変化において，絶対温度 \\(T_1\\) の流体が熱量を受けて \\(T_2\\) となった場合，定圧比熱 \\(c_p\\) が一定であれば，エントロピー変化量 \\(s_2 - s_1\\) は\n\\[\n\\begin{align}\ns_2 - s_1\n  &= \\int^2_1 ds \\\\\n  &= c_p \\int^2_1\\frac{dT}{T}\\\\\n  &= c_p\\log\\left(\\frac{T_2}{T_1}\\right)\n\\end{align}\n\\]\nとなり，Ts線図を使用すると温度上昇曲線は指数曲線となります．また定義より\n\\[\ndq = Tds\n\\]\nなので，状態1から状態2への変化に要する熱量 \\(q_{12}\\) は\n\\[\nq_{12} = \\int^2_1 T ds\n\\]\nと積分に対応 = Ts線図の\\(s_1\\), \\(s_2\\)区間の曲線面積に対応して理解することができます．\n\n可逆過程（＝平衡状態の空間）の熱力学\n可逆変化においては \\(dq = Tds\\) が成立します．また，熱力学第一法則より\n\\[\ndu = dq - pdv\n\\]\nであるので，可逆過程における流体の内部エネルギーの微小変化は\n\\[\ndu = Tds - pdv\n\\]\nとなります．これらを整理すると\n\\[\n\\begin{align}\n\\left(\\frac{\\partial u}{\\partial s}\\right)_v &= T\\\\\n\\left(\\frac{\\partial u}{\\partial v}\\right)_s &= -p\\\\\n\\left(\\frac{\\partial s}{\\partial u}\\right)_v &= \\frac{1}{T}\\\\\n\\left(\\frac{\\partial s}{\\partial v}\\right)_u &= \\frac{p}{T}\n\\end{align}\n\\]\n\n\nMaxwellの関係式: エントロピー変化と全微分\n\\(s = s(T, v)\\) とみると，熱力学第一法則から\n\\[\n\\begin{align}\nds\n  &= \\frac{dq}{T}\\\\\n  &= \\frac{1}{T}(du + pdv)\\\\\n  &= \\frac{1}{T}\\left[\\left(\\frac{\\partial u}{\\partial T}\\right)_vdT + \\left(\\frac{\\partial u}{\\partial v}\\right)_Tdv + pdv\\right]\\\\\n  &= \\frac{1}{T}\\left(\\frac{\\partial u}{\\partial T}\\right)_vdT + \\frac{1}{T}\\left[\\left(\\frac{\\partial u}{\\partial v}\\right)_T + p\\right]dv\n\\end{align}\n\\]\n全微分を整理すると\n\\[\n\\frac{\\partial}{\\partial v}\\left[\\frac{1}{T}\\left(\\frac{\\partial u}{\\partial T}\\right)_v\\right] = \\frac{\\partial}{\\partial T}\\left[\\frac{1}{T}\\left(\\left(\\frac{\\partial u}{\\partial v}\\right)_T + p\\right)\\right]\n\\]\nつまり\n\\[\n\\begin{align}\n\\text{RHS}&=\\frac{1}{T}\\frac{\\partial^2u}{\\partial v\\partial T}\\\\\n\\text{LHS}&=-\\frac{1}{T^2}\\left[\\left(\\frac{\\partial u}{\\partial v}\\right)_T + p\\right] + \\frac{1}{T}\\frac{\\partial^2 u}{\\partial T \\partial v} + \\frac{1}{T}\\left(\\frac{\\partial P}{\\partial T}\\right)_v\n\\end{align}\n\\]\nこれらを整理すると次の関係式が導出できます\n\\[\n\\begin{align}\n\\left(\\frac{\\partial u}{\\partial v}\\right)_T\n  &= T\\left(\\frac{\\partial p}{\\partial T}\\right)_v - p\\\\\n  &= T^2\\frac{\\partial}{\\partial T}\\left(\\frac{p}{T}\\right)\n\\end{align}\n\\]\n単原子理想気体では \\(u = u(T)\\) であるので\n\\[\n\\frac{\\partial}{\\partial T}\\left(\\frac{p}{T}\\right) = 0 \\label{eq-ideal}\n\\]\nまた，\\(\\eqref{eq-ideal}\\) が成立するということは \\(p/T\\) が \\(v\\) のみの関数であることを意味するので\n\\[\np = f(v)T\n\\]\nと成ることがわかります．"
  },
  {
    "objectID": "posts/2025-06-13-heat-and-work/index.html#理解度チェック",
    "href": "posts/2025-06-13-heat-and-work/index.html#理解度チェック",
    "title": "エントロピーとエンタルピー",
    "section": "📘 理解度チェック",
    "text": "📘 理解度チェック\n\nExercise 1 熱力学エネルギー\n熱力学エネルギーを簡潔に説明せよ\n\n\n\n\n\n\n\nNoteSolution\n\n\n\n\n\n物体を構成する原子や分子の，熱運動による運動エネルギーと位置エネルギーの総和を，その熱力学エネルギーという\n\n\n\n\nExercise 2 熱力学第一法則\n次の記述のうち正しいものはどれか？\n\n一定容積（定積）で熱を加えると，体積が変わらないため外部に対して仕事をしない．そのため，その熱量はすべて内部エネルギーの変化に等しい，\n\n\n\n\n\n\n\n\nNoteSolution\n\n\n\n\n\na,\n\n\n\n\nExercise 3 熱力学第二法則\n次の記述のうち正しいものはどれか？\n\n熱は高温の物体から低温の物体にしか移動しない．このように，自然には逆向きの変化が発生しないことを不可逆変化という\n\n\n\n\n\n\n\n\nNoteSolution\n\n\n\n\n\na,\n\n\n\n\nExercise 4 エントロピーの基礎\n熱量とエンタルピーの違いを説明せよ\n\n\n\n\n\n\n\nNoteSolution\n\n\n\n\n\n\n熱量とはある物質から外部へ放出した（または外部から取込んだ）熱エネルギーのこと（外部エネルギー）\nエンタルピーはある物質が持っているエネルギー（熱＋圧力Energy）のこと\n\nある物質のエンタルピーが変化すると，その分だけ外部と熱や動力を出し入れします．水１kgの温度が１℃下がるのは，4.186kJの熱量で冷却されたからですが，4.186kJの熱量は外部エネルギーとなります．冷却の結果として１℃当り4.186kJ/kgだけ比エンタルピー（or内部エネルギー）が低いと表現する場合は状態量としての記述になります．\n\n\n\n\nExercise 5 冷凍サイクルと熱力学性質\n次の記述のうち正しいものはどれか？\n\n冷媒の熱力学性質を表にした飽和表から，飽和液及び飽和蒸気の比体積，比エンタルピー，比エントロピーなどを読み取ることができる．そして，飽和蒸気の比エンタルピーと飽和液の比エンタルピーの差が蒸発潜熱となる．\n圧縮機の圧力比が大きいほど，圧縮前後の比エンタルピー差は大きくなる．その結果，単位冷媒循環量あたりの理論断熱圧縮動力も大きくなる\n\n\n\n\n\n\n\n\nNoteSolution\n\n\n\n\n\na, b\n\n\n\n\nExercise 6 エントロピー\n閉じた系内の物質について\n\\[\n\\begin{align}\nT &= \\frac{u}{c}\\\\\np &= \\frac{RT}{v}\n\\end{align}\n\\]\nが成立するとします．\\(c\\) は定数，\\(R\\) は気体定数．基準状態のエントロピーを \\(s_0 = s(u_0, v_0)\\) として，ここから \\(s(u, v)\\) の状態までのエントロピー変化を \\(s(u, v) - s_0\\) とする．\\(s(u, v)\\) を求めよ\n\n\n\n\n\n\n\nNoteSolution\n\n\n\n\n\n熱力学第一法則より\n\\[\n\\begin{align}\nds\n  &= \\frac{dq}{T}\\\\\n  &= \\frac{1}{T}(du + pdv)\\\\\n  &= \\frac{c}{u}du + \\frac{R}{v}dv\n\\end{align}\n\\]\nこれを積分すれば \\(s = s(u, v)\\) が得られるので\n\\[\ns(u, v) = c\\log(u) + R\\log(v) + \\text{constant}\n\\]\n\\(s_0 = s(u_0, v_0)\\) であるので\n\\[\ns = c\\log(u/u_0) + R\\log(v/v_0) + s_0\n\\]"
  },
  {
    "objectID": "posts/2025-06-13-heat-and-work/index.html#appendix-圧力の公式",
    "href": "posts/2025-06-13-heat-and-work/index.html#appendix-圧力の公式",
    "title": "エントロピーとエンタルピー",
    "section": "Appendix: 圧力の公式",
    "text": "Appendix: 圧力の公式\n圧力とは \\(1\\text{m}^2\\) あたりに働く力のことをいいます．力との関係は以下のように表せます\n\\[\n\\text{圧力[Pa]} = \\frac{\\text{加えた力[N]}}{\\text{その力が加わっている面積}[\\text{m}^2]}\n\\]\n圧力の組立単位は \\(\\text{N}/\\text{m}^2\\) となりますが，通常は \\(1 \\text{N}/\\text{m}^2 = 1\\text{Pa}\\) としてPaを用いて表します．"
  },
  {
    "objectID": "posts/2025-07-31-how-to-write-pseudocode-in-quarto/index.html",
    "href": "posts/2025-07-31-how-to-write-pseudocode-in-quarto/index.html",
    "title": "Quarto Projectへのpseudocode extensions導入",
    "section": "",
    "text": "Quarto PropjectのHTMLレンダリングでPseudocodeを利用可能にする\n\n\n\n\nQuarto がインストール済み\nQuarto プロジェクト（blogやbook）を作成済み"
  },
  {
    "objectID": "posts/2025-07-31-how-to-write-pseudocode-in-quarto/index.html#ゴール",
    "href": "posts/2025-07-31-how-to-write-pseudocode-in-quarto/index.html#ゴール",
    "title": "Quarto Projectへのpseudocode extensions導入",
    "section": "",
    "text": "Quarto PropjectのHTMLレンダリングでPseudocodeを利用可能にする\n\n\n\n\nQuarto がインストール済み\nQuarto プロジェクト（blogやbook）を作成済み"
  },
  {
    "objectID": "posts/2025-07-31-how-to-write-pseudocode-in-quarto/index.html#拡張機能のインストール",
    "href": "posts/2025-07-31-how-to-write-pseudocode-in-quarto/index.html#拡張機能のインストール",
    "title": "Quarto Projectへのpseudocode extensions導入",
    "section": "✅ 拡張機能のインストール",
    "text": "✅ 拡張機能のインストール\nQuarto Pseudocode ExtensionをQuarto Projectにquartoコマンドでインストールします:\nquarto add leovan/quarto-pseudocode\n/_extensions\n└── leovan\n    └── pseudocode\n        ├── _extension.yml\n        ├── pseudocode.lua\n        ├── pseudocode.min.css\n        └── pseudocode.min.js\n\n\n\n\n\n\nNoteREMARKS\n\n\n\n\nProject単位でのインストールとなります"
  },
  {
    "objectID": "posts/2025-07-31-how-to-write-pseudocode-in-quarto/index.html#拡張機能利用のための設定",
    "href": "posts/2025-07-31-how-to-write-pseudocode-in-quarto/index.html#拡張機能利用のための設定",
    "title": "Quarto Projectへのpseudocode extensions導入",
    "section": "🔨 拡張機能利用のための設定",
    "text": "🔨 拡張機能利用のための設定\n_quarto.yml に対して filters項目を以下のように追加します:\n\n\n_quarto.yml\n\nproject:\n  type: website\n  output-dir: _site\n\nfilters:\n  - pseudocode\n\n\nMath Setup\n\n\n_quarto.yml\n\nformat:\n  html:\n    include-in-header:\n      - include/mathjax.html\n\n上記のinclude/mathjax.htmlに対して以下のようなLinesを設定します\n\n\ninclude/mathjax.html\n\n&lt;script&gt;\n    MathJax = {\n        tex: {\n            inlineMath: [['$','$'], ['\\\\(','\\\\)']],\n            displayMath: [['$$','$$'], ['\\\\[','\\\\]']],\n            processEscapes: true,\n            processEnvironments: true,\n            tags: 'all',\n        }\n    }\n&lt;/script&gt;\n&lt;script src=\"https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-chtml-full.js\"\n        integrity=\"sha256-kbAFUDxdHwlYv01zraGjvjNZayxKtdoiJ38bDTFJtaQ=\"\n        crossorigin=\"anonymous\"&gt;\n&lt;/script&gt;\n\nMathJax Options\n\n\n\n\n\n\n\n\nKeys\n内容\n\n\n\n\ninlineMath\nインライン数式 のマーカー指定．例：$a^2 + b^2 = c^2$ または \\(...\\)\n\n\ndisplayMath\nディスプレイ数式（中央寄せで大きく表示） のマーカー指定．例：$$E = mc^2$$ または \\[...\\]\n\n\nprocessEscapes\nバックスラッシュを エスケープとして解釈するか．true にすると \\\\( を \\( として扱えるようになる\n\n\nprocessEnvironments\n\\begin{...} ... \\end{...} 形式の LaTeX 環境 を使えるようにする\n\n\ntags: 'all'\n式番号を付ける場所の指定．'all' は display 数式すべて に番号を振る（\\begin{equation} でなくても）\n\n\n\n\nMathJax本体の読み込み設定\n\n\n\n\n\n\n\n\n属性\n説明\n\n\n\n\nsrc\nCDN 上の MathJax v3 スクリプト．tex-chtml-full.js は LaTeX入力 + HTML/CSS出力 対応の完全版\n\n\nintegrity\nSubresource Integrity（SRI） チェック用ハッシュ（改ざん防止）\n\n\ncrossorigin=\"anonymous\"\nSRI を有効にするための指定\n\n\n\n\n\n\nAlgorithm表記設定\nPseudocodeの参照または参照時の表示を設定する場合，_quarto.ymlに以下のように記載します\n\n\n_quarto.yml\n\nformat:\n  html:\n    pseudocode:\n      caption-prefix: \"アルゴリズム\"    # DefaultはAlgorithm\n      reference-prefix: \"アルゴリズム\"  # DefaultはAlgorithm\n\n\n\n\n\n\n\n\n\n\n\nオプション名\n意味\nデフォルト\n解説\n\n\n\n\ncaption-prefix\nキャプションの前に付ける語句\n\"Algorithm\"\n例：Algorithm 1: Euclidean のような見出しに使われる\n\n\nreference-prefix\n@ref(fig:xxx) のような参照時の接頭辞\n\"Algorithm\"\n参照時に Algorithm 1 のように表示されます\n\n\ncaption-number\n番号付けの有無\ntrue\nfalse にすると Algorithm: xxx のように番号なしになる"
  },
  {
    "objectID": "posts/2025-07-31-how-to-write-pseudocode-in-quarto/index.html#pseudocode-blockの記述方法",
    "href": "posts/2025-07-31-how-to-write-pseudocode-in-quarto/index.html#pseudocode-blockの記述方法",
    "title": "Quarto Projectへのpseudocode extensions導入",
    "section": "📘 Pseudocode Blockの記述方法",
    "text": "📘 Pseudocode Blockの記述方法\npseudocodeコードブロックの中にPseudocodeを以下のように記述すると， 以下のような出力になります．\n```pseudocode\n#| html-indent-size: \"1.2em\"\n#| html-comment-delimiter: \"//\"\n#| html-line-number: true\n#| html-line-number-punc: \":\"\n#| html-no-end: false\n#| pdf-placement: \"htb!\"\n#| pdf-line-number: true\n\n\\begin{algorithm}\n\\caption{Quicksort}\n\\begin{algorithmic}\n\\Procedure{Quicksort}{$A, p, r$}\n  \\If{$p &lt; r$}\n    \\State $q = $ \\Call{Partition}{$A, p, r$}\n    \\State \\Call{Quicksort}{$A, p, q - 1$}\n    \\State \\Call{Quicksort}{$A, q + 1, r$}\n  \\EndIf\n\\EndProcedure\n\\Procedure{Partition}{$A, p, r$}\n  \\State $x = A[r]$\n  \\State $i = p - 1$\n  \\For{$j = p$ \\To $r - 1$}\n    \\If{$A[j] &lt; x$}\n      \\State $i = i + 1$\n      \\State exchange\n      $A[i]$ with     $A[j]$\n    \\EndIf\n    \\State exchange $A[i]$ with $A[r]$\n  \\EndFor\n\\EndProcedure\n\\end{algorithmic}\n\\end{algorithm}\n```\n\n\n\n\\begin{algorithm} \\caption{Quicksort} \\begin{algorithmic} \\Procedure{Quicksort}{$A, p, r$} \\If{$p &lt; r$} \\State $q = $ \\Call{Partition}{$A, p, r$} \\State \\Call{Quicksort}{$A, p, q - 1$} \\State \\Call{Quicksort}{$A, q + 1, r$} \\EndIf \\EndProcedure \\Procedure{Partition}{$A, p, r$} \\State $x = A[r]$ \\State $i = p - 1$ \\For{$j = p$ \\To $r - 1$} \\If{$A[j] &lt; x$} \\State $i = i + 1$ \\State exchange $A[i]$ with $A[j]$ \\EndIf \\State exchange $A[i]$ with $A[r]$ \\EndFor \\EndProcedure \\end{algorithmic} \\end{algorithm}"
  },
  {
    "objectID": "posts/2025-07-31-how-to-write-pseudocode-in-quarto/index.html#quarto-pseudocode-の仕様",
    "href": "posts/2025-07-31-how-to-write-pseudocode-in-quarto/index.html#quarto-pseudocode-の仕様",
    "title": "Quarto Projectへのpseudocode extensions導入",
    "section": "quarto-pseudocode の仕様",
    "text": "quarto-pseudocode の仕様\nSyntax\n\nキーワードには大文字と小文字の形式(UpperCamelCase) (例: \\Procedure, \\If, \\EndIf) を使用\n数式は標準の LaTeX 数式構文をサポート\n\nBlock Parameters\nコメント形式のパラメーターを以下のように記載することができます．\n#| html-indent-size: \"1.2em\"\n#| html-comment-delimiter: \"//\"\n#| html-line-number: true\n#| html-line-number-punc: \":\"\n#| html-no-end: false\n#| pdf-placement: \"htb!\"\n#| pdf-line-number: true\n\n\\begin{algorithm}\n\\caption{My Algorithm}\n\\begin{algorithmic}\n...\n\\end{algorithmic}\n\\end{algorithm}\n\n\n\n\n\n\n\n\n\nパラメーター\nデフォルト\n形式\n説明\n\n\n\n\nlabel\n\nall\nクロス参照用のラベル (alg- で始まる必要があります)\n\n\nhtml-indent-size\n“1.2em”\nHTML\nネストされたブロックのインデント サイズ\n\n\nhtml-comment-delimiter\n“//”\nHTML\nコメント デリミタ文字\n\n\nhtml-line-number\ntrue\nHTML\n行番号を表示\n\n\nhtml-line-number-punc\n“:”\nHTML\n行番号の句読点\n\n\nhtml-no-end\nfalse\nHTML\n末尾のキーワードを非表示\n\n\npdf-placement\n“H”\nPDF\nフロート配置 (htbp!)\n\n\npdf-line-number\ntrue\nPDF\n行番号を表示\n\n\n\nCSS styleの設定\n設定用CSSファイルに以下のような記述をすることでfontやcontainerの設定ができます\n.pseudocode-container {\n  border: 1px solid #ddd;\n  border-radius: 5px;\n  padding: 10px;\n  margin: 20px 0;\n}\n\n.ps-algorithm {\n  font-family: 'Courier New', monospace;\n}"
  },
  {
    "objectID": "posts/2025-07-31-how-to-write-pseudocode-in-quarto/index.html#appendix-uppercamelcase",
    "href": "posts/2025-07-31-how-to-write-pseudocode-in-quarto/index.html#appendix-uppercamelcase",
    "title": "Quarto Projectへのpseudocode extensions導入",
    "section": "Appendix: UpperCamelCase",
    "text": "Appendix: UpperCamelCase\n\n\n\n\n\n\n\n\n\n名称\n例\n説明\n\n\n\n\nALL UPPERCASE\nPROJECT, TYPE, EXTENSIONS\n全部大文字\n\n\nUpperCamelCase\nProject, Type, Extensions\n各単語の先頭が大文字（キャメルケース）\n\n\nlowerCamelCase\nproject, projectType, extensionList\n1語目は小文字で始め，2語目以降の先頭を大文字\n\n\nsnake_case\nproject_type, extension_list\n単語をアンダースコア _ でつなぐ"
  },
  {
    "objectID": "posts/2025-07-31-how-to-write-pseudocode-in-quarto/index.html#references",
    "href": "posts/2025-07-31-how-to-write-pseudocode-in-quarto/index.html#references",
    "title": "Quarto Projectへのpseudocode extensions導入",
    "section": "References",
    "text": "References\n\nQuarto Pseudocode Extension"
  },
  {
    "objectID": "posts/2025-07-19-Ubuntu-Nautilus-and-ssh/index.html",
    "href": "posts/2025-07-19-Ubuntu-Nautilus-and-ssh/index.html",
    "title": "NautilusからSSH先のファイルを操作する",
    "section": "",
    "text": "手順\n\nNautilusをClient側で開く\nサイドバー下部の「その他の場所」をクリック\n「サーバーへ接続」に以下を入力：\n\nssh://&lt;ユーザー名&gt;@&lt;ホスト名またはIPアドレス&gt;\n\n入力箇所\nNautilusのbottom sectionにある「Connect to Server」のEnter server address ... の部分で接続設定をします．.ssh/configで\nHost pupupuserver\n  HostName 192.168.1.100\n  User kirby\n  LocalForward 8787 localhost:8787\nとHost設定を行っていれば\nssh://pupupuserver\nと入力してもOKです．\n\n\n\nnautilus\n\n\n\n\n\n\n\n\nNotesshfsを用いたmount\n\n\n\nmkdir ./remote\nsshfs pupupuserver:/home/kirby ./remote\nとすれば，ローカルのフォルダに直接ssh接続先ディレクトリをマウントすることができます．個人の方針として，\n\nアクセスしたいディレクトリが明確に定まっている状況\n分析プロジェクトとかでVSCode経由でSサーバーディレクトリを操作したいとき\n\nという状況のときに使用しています．"
  },
  {
    "objectID": "posts/2025-07-19-Ubuntu-Nautilus-and-ssh/index.html#ssh先のファイルをnautilusで操作する",
    "href": "posts/2025-07-19-Ubuntu-Nautilus-and-ssh/index.html#ssh先のファイルをnautilusで操作する",
    "title": "NautilusからSSH先のファイルを操作する",
    "section": "",
    "text": "手順\n\nNautilusをClient側で開く\nサイドバー下部の「その他の場所」をクリック\n「サーバーへ接続」に以下を入力：\n\nssh://&lt;ユーザー名&gt;@&lt;ホスト名またはIPアドレス&gt;\n\n入力箇所\nNautilusのbottom sectionにある「Connect to Server」のEnter server address ... の部分で接続設定をします．.ssh/configで\nHost pupupuserver\n  HostName 192.168.1.100\n  User kirby\n  LocalForward 8787 localhost:8787\nとHost設定を行っていれば\nssh://pupupuserver\nと入力してもOKです．\n\n\n\nnautilus\n\n\n\n\n\n\n\n\nNotesshfsを用いたmount\n\n\n\nmkdir ./remote\nsshfs pupupuserver:/home/kirby ./remote\nとすれば，ローカルのフォルダに直接ssh接続先ディレクトリをマウントすることができます．個人の方針として，\n\nアクセスしたいディレクトリが明確に定まっている状況\n分析プロジェクトとかでVSCode経由でSサーバーディレクトリを操作したいとき\n\nという状況のときに使用しています．"
  },
  {
    "objectID": "posts/2025-07-19-Ubuntu-Nautilus-and-ssh/index.html#多段ssh踏み台サーバ経由の場合",
    "href": "posts/2025-07-19-Ubuntu-Nautilus-and-ssh/index.html#多段ssh踏み台サーバ経由の場合",
    "title": "NautilusからSSH先のファイルを操作する",
    "section": "多段SSH（踏み台サーバ経由）の場合",
    "text": "多段SSH（踏み台サーバ経由）の場合\n踏み台設定は以下のような状況を考えます\nHost jumpserver\n  HostName jump.example.com\n  User kirby\n  LocalForward 8787 localhost:8787\n\nHost targetserver\n  HostName 192.168.1.110\n  User kirby\n  LocalForward 8787 localhost:8787\n\n手順: SSHトンネルを張ってlocalhostに接続\n\nSSHトンネルを貼る\n\nssh -N -L 2222:192.168.1.110:22 kirby@jump.example.com\n\nサイドバー下部の「その他の場所」をクリック\n「サーバーへ接続」に以下を入力：\n\nssh://kirby@localhost:2222"
  },
  {
    "objectID": "posts/2025-04-29-shellscript-tips/index.html",
    "href": "posts/2025-04-29-shellscript-tips/index.html",
    "title": "シェルコマンドTips",
    "section": "",
    "text": "Note直前のコマンドの引数呼び出し\n\n\n\n\n\n\n\n\nコマンド\n動作\nショートカット\n\n\n\n\n!^\n直前のコマンドの最初の引数\n\n\n\n!$\n直前のコマンドの最後の引数\nesc + . または Alt + .\n\n\n!:N\n直前のコマンドのN番目の引数\n\n\n\n!*\n直前のコマンドのすべての引数\n\n\n\n\nAlt + . の特徴\n\nAltを押しながら.を連続で入力すると，一回目は直前，二回目は２回前の最後の引数をsuggestしてくれます．\nesc+ .もセットで押せば同じような挙動となりますが，入力しづらいので Alt + . の方が好みです"
  },
  {
    "objectID": "posts/2025-04-29-shellscript-tips/index.html#シェルスクリプト便利コマンドリスト",
    "href": "posts/2025-04-29-shellscript-tips/index.html#シェルスクリプト便利コマンドリスト",
    "title": "シェルコマンドTips",
    "section": "",
    "text": "Note直前のコマンドの引数呼び出し\n\n\n\n\n\n\n\n\nコマンド\n動作\nショートカット\n\n\n\n\n!^\n直前のコマンドの最初の引数\n\n\n\n!$\n直前のコマンドの最後の引数\nesc + . または Alt + .\n\n\n!:N\n直前のコマンドのN番目の引数\n\n\n\n!*\n直前のコマンドのすべての引数\n\n\n\n\nAlt + . の特徴\n\nAltを押しながら.を連続で入力すると，一回目は直前，二回目は２回前の最後の引数をsuggestしてくれます．\nesc+ .もセットで押せば同じような挙動となりますが，入力しづらいので Alt + . の方が好みです"
  },
  {
    "objectID": "posts/2025-04-29-shellscript-tips/index.html#zsh-terminal用ショートカットリスト",
    "href": "posts/2025-04-29-shellscript-tips/index.html#zsh-terminal用ショートカットリスト",
    "title": "シェルコマンドTips",
    "section": "Zsh Terminal用ショートカットリスト",
    "text": "Zsh Terminal用ショートカットリスト\n\n\n\n\n\n\nNoteCursor moving\n\n\n\n\n\n\n\n\n\n\n\n\n\nショートカット\nkeybind setting\n動作\n\n\n\n\nctrl + ←\nbindkey '^[[1;5C' backward-word\ncursor backward by one word\n\n\nalt + B\ndefault\ncursor backward by one word\n\n\nctrl + →\nbindkey '^[[1;5D' forward-word\ncursor forward by one word\n\n\nalt + F\ndefault\ncursor forward by one word\n\n\nctrl + A\ndefault\nライン先頭へ移動\n\n\nhome\ndefault\nライン先頭へ移動\n\n\nctrl + E\ndefault\nライン末尾へ移動\n\n\nend\ndefault\nライン末尾へ移動\n\n\n\n\n\n\n\n\n\n\n\n\nNoteSearch\n\n\n\n\n\n\n\n\n\n\n\n\n\nショートカット\nkeybind setting\n動作\n\n\n\n\nctrl + R\ndefault\nReverse search in history\n\n\nctrl + S\ndefault\nForward search in history\n\n\n\n\n\n\n\n\n\n\n\n\nNoteEditing\n\n\n\n\n\n\n\n\n\n\n\n\n\nショートカット\nkeybind setting\n動作\n\n\n\n\nctrl + K\ndefault\nカーソル位置から後ろのwordsをすべて削除\n\n\nctrl + U\ndefault\nライン全消し\n\n\nctrl + Y\ndefault\n削除した文字列をペースト\n\n\nctrl + W\ndefault\nカーソル位置からword block先頭までを削除\n\n\n\n\n\n\n\n\n\n\n\n\nNoteGit\n\n\n\n\n\n\n\n\n\n\n\n\n\nショートカット\nkeybind setting\n動作\n\n\n\n\nctrl + G then ctrl + A\nbindkey \"^G^A\" _git_add\ngit add -u\n\n\nctrl + G then ctrl + home\n\"^G^[[1;5H\" _git_cd\ncd \"$(git root)\"\n\n\nctrl + G then ctrl + S\nbindkey \"^G^S\" _git_status\ngit status -sb\n\n\n\ngit status -sbコマンド\ngit status と git status -sbの違いは出力形式にあります\n\n\ngit status\n\n現在のブランチ、ステージ済み・未ステージの変更、未追跡ファイルなどを詳細に表示\n\n% git status\nOn branch main\nYour branch is up to date with 'origin/main'.\n\nChanges not staged for commit:\n  modified:   file.txt\n\ngit status -sb\n\n短くスクリプト向けの要約を表示\n\n-s で各ファイルの状態を2文字コードで表示（例: Mは変更）\n-b で現在のブランチと追跡情報を先頭に追加\n\n\n% git status -sb\n## main...origin/main\n M file.txt"
  },
  {
    "objectID": "posts/2025-04-29-shellscript-tips/index.html#appendix-1-ansi-escape-sequence",
    "href": "posts/2025-04-29-shellscript-tips/index.html#appendix-1-ansi-escape-sequence",
    "title": "シェルコマンドTips",
    "section": "Appendix-1: ANSI escape sequence",
    "text": "Appendix-1: ANSI escape sequence\n\n\n\n\n\n\n\n\n\nシンボル\n対応コマンド\n説明\n\n\n\n\n^[[\nESC + [\n\n\n\n1;5\nmodifier (5 = Ctrl)\n\n\n\n^A\nCtrl+A\n\n\n\n^G\nCtrl+G\nASCII 7, BEL, bell character\n\n\n^S\nCtrl+S\nASCII 19, XOFF, used for terminal flow control to pause output\n\n\nC\nCursor Right\n\n\n\nD\nCursor Left\n\n\n\nH\nHome key"
  },
  {
    "objectID": "posts/2025-04-29-shellscript-tips/index.html#appendix-2-custom-keybind-setup",
    "href": "posts/2025-04-29-shellscript-tips/index.html#appendix-2-custom-keybind-setup",
    "title": "シェルコマンドTips",
    "section": "Appendix-2: custom keybind setup",
    "text": "Appendix-2: custom keybind setup\n以下のファイルを .zshrc に読み込ませています\n\n\ncustom_keybind.sh\n\n#!/bin/zsh\n#---------------------------------------------------\n# cursor moving command\n#---------------------------------------------------\nbindkey '^[[1;5D' backward-word\nbindkey '^[[1;5C' forward-word\n\n\n#---------------------------------------------------\n# git-related command\n#---------------------------------------------------\nfunction _git_cd() {\n    echo \"cd $(git root)\"\n    cd \"$(git root)\"\n    zle accept-line\n}\nzle -N  _git_cd\n\nfunction _git_status() {\n    echo \"git status -sb\" \n    git status -sb\n    zle accept-line\n    #zle reset-prompt\n}\nzle -N  _git_status  # _git_status関数をgit_status widgetとして登録\n\nfunction _git_add() {\n    echo \"git add -u\" # promptにgit add -uを表示\n    git add -u\n    zle accept-line\n    \n}\nzle -N _git_add  # _git_status関数をgit_status widgetとして登録\n\nfunction _git_commit_amend() {\n    echo \"git commit --amend --no-edit\" # promptにgit commit --amend --no-editを表示\n    git commit --amend --no-edit\n    zle accept-line\n    \n}\nzle -N _git_commit_amend  # _git_commit_amend関数をgit_status widgetとして登録\n\nfunction _git_pull() {\n    echo \"git pull\" # promptにgit add -uを表示\n    git pull\n    zle accept-line\n    \n}\nzle -N _git_pull  # _git_status関数をgit_status widgetとして登録\n\nfunction _git_push() {\n    echo \"git push\" # promptにgit add -uを表示\n    git push\n    zle accept-line\n    \n}\nzle -N _git_push  # _git_status関数をgit_status widgetとして登録\n\n#---------------------------------------------------\n# vscode-related command\n#---------------------------------------------------\nfunction _vscode_cd() {\n    echo \"code-cd\" # promptにgit add -uを表示\n    code-cd\n    zle accept-line\n    \n}\nzle -N _vscode_cd  # _git_status関数をgit_status widgetとして登録\n\n\n#---------------------------------------------------\n# bindkey setup\n#---------------------------------------------------\n# git\nbindkey \"^G^A\" _git_add\nbindkey \"^G^[[1;5H\" _git_cd       # Ctrl + g + Home\nbindkey \"^G^M\" _git_commit_amend\nbindkey \"^G^P\" _git_push\nbindkey \"^G^l\" _git_pull\nbindkey \"^G^S\" _git_status\n\n# vscode related\nbindkey \"^V^[[1;5H\" _vscode_cd       # Ctrl + v + Home"
  },
  {
    "objectID": "posts/2025-02-02-taylor-expansion-and-polynomial/index.html",
    "href": "posts/2025-02-02-taylor-expansion-and-polynomial/index.html",
    "title": "有限個の多項式のテイラー展開",
    "section": "",
    "text": "\\(y = f(x)\\) の導関数を \\(f^\\prime(x)\\) とするとき，第二階の導関数を \\(f^{\\prime\\prime}(x)\\) と表記し，第 \\(n\\) 階の導関数を \\(f^{(n)}(x)\\) と表記します． 一点 \\(x\\) において\n\\[\n\\begin{gather}\nf^{\\prime\\prime}(x) = \\frac{d}{dx}\\left(\\frac{dy}{dx}\\right) = \\frac{d^2y}{dx^2}\\\\\nf^{(n)}(x) = \\frac{d^ny}{dx^n}\n\\end{gather}\n\\]\nとなります．\n ▶  記号の差異: \\(d^2y\\) vs \\(dx^2\\)\n\\(d^2y = d(dy)\\)，\\(dx^2 = (dx)^2\\) の意味で，この意味の差異を表現するため記号でも表記が異なっています．微分記号を用いて\n\\[\ndy = f^\\prime(x)dx\n\\]\nと書くとき，両辺の微分を取れば，\n\\[\n\\begin{align}\nd(dy) &= \\frac{d(f^{\\prime}(x))}{dx}(dx)^2 + f^\\prime(x)\\frac{d(dx)}{dx}dx\\\\\n      &= f^{\\prime\\prime}(x)(dx)^2 + f^\\prime(x)d(dx) \\label{eq-second-diff}\n\\end{align}\n\\]\n\\(x\\) が独立変数であるならば \\(dx\\) は \\(x\\) の水準関係なく自由に取れるので，\\(\\frac{d(dx)}{dx} = 0\\)．従って，\n\\[\nd^2y = f^{\\prime\\prime}(x)dx^2\n\\]\nとなります．もし，\\(x = \\varphi(t)\\) であるならば，\\(d^2x = \\varphi^{\\prime\\prime}(t)dt^2\\) となるので\n\\[\n\\frac{d}{dt^2}f(\\varphi(t)) = f^{\\prime\\prime}(\\varphi(t))(\\varphi^\\prime(t))^2 + f^\\prime(\\varphi(t))\\varphi^{\\prime\\prime}(t)\n\\]\n\n\n\n\nTheorem 1 : ライプニッツの公式(Leibniz rule) \n\\(u, v\\) が \\(x\\) の関数であるとき，\n\\[\n\\begin{align}\n\\frac{d^n(uv)}{dx^n}\n    &= u^{(n)}v + \\left(\\begin{array}{c}n\\\\1\\end{array}\\right)u^{(n-1)}v^{\\prime} + \\left(\\begin{array}{c}n\\\\2\\end{array}\\right)u^{(n-2)}v^{\\prime\\prime}+\\cdots+ \\left(\\begin{array}{c}n\\\\n-1\\end{array}\\right)u^{\\prime}v^{(n-1)} +uv^{(n)}\\\\\n    &= \\sum_{k=0}^n \\left(\\begin{array}{c}n\\\\ k\\end{array}\\right)u^{(n-k)}v^{(k)}\n\\end{align}\n\\]\n\n\n\n\n\n\n\n\n\nNoteProof\n\n\n\n\n\n\\(n=1\\) のときは，積の微分公式より\n\\[\n\\frac{d(uv)}{dx^n} = \\frac{du}{dx}v + \\frac{dv}{dx}u\n\\]\n\\(n\\geq 2\\) については，帰納法を用いて示す．\\(n=t\\) のときライプニッツの公式が成立すると仮定する．\nこのとき，\n\\[\n\\begin{align}\n\\frac{d^{(t+1)}(uv)}{dx^{t+1}}\n    &= \\frac{d}{dt}\\left(\\frac{d^{(t)}(uv)}{dx^{t}}\\right)\\\\\n    &= \\frac{d}{dt}\\left(\\sum_{k=0}^t \\left(\\begin{array}{c}t\\\\ k\\end{array}\\right)u^{(t-k)}v^{(k)}\\right)\\\\\n    &= \\sum_{k=0}^t \\left(\\begin{array}{c}t\\\\ k\\end{array}\\right)[u^{(t-k+1)}v^{(k)} + u^{(t-k)}v^{(k+1)}]\\\\\n    &= \\sum_{k=0}^t \\left(\\begin{array}{c}t\\\\ k\\end{array}\\right)u^{(t-k+1)}v^{(k)} + \\sum_{k=0}^t \\left(\\begin{array}{c}t\\\\ k\\end{array}\\right)u^{(t-k)}v^{(k+1)}\\\\\n    &= \\left\\{u^{(t+1)}v + \\sum_{k=1}^t \\left(\\begin{array}{c}t\\\\ k\\end{array}\\right)u^{(t-k+1)}v^{(k)}\\right\\}+ \\left\\{uv^{(t+1)} + \\sum_{k=0}^{t-1} \\left(\\begin{array}{c}t\\\\ k\\end{array}\\right)u^{(t-k)}v^{(k+1)}\\right\\}\\\\\n    &= \\left\\{u^{(t+1)}v + \\sum_{k=1}^t \\left(\\begin{array}{c}t\\\\ k\\end{array}\\right)u^{(t-k+1)}v^{(k)}\\right\\}+ \\left\\{uv^{(t+1)} + \\sum_{j=1}^{t} \\left(\\begin{array}{c}t\\\\ j-1\\end{array}\\right)u^{(t-j+1)}v^{j}\\right\\}\\\\\n    &= u^{(t+1)}v + uv^{(t+1)} + \\sum_{k=1}^t \\left\\{\\left(\\begin{array}{c}t\\\\ k\\end{array}\\right) + \\left(\\begin{array}{c}t\\\\ k-1\\end{array}\\right)\\right\\}u^{(t-k+1)}v^{(k)}\\\\\n    &= u^{(t+1)}v + uv^{(t+1)} + \\sum_{k=1}^t \\left(\\begin{array}{c}t+1\\\\ k\\end{array}\\right)u^{(t+1-k)}v^{(k)}\\\\\n    &= \\sum_{k=0}^{t+1} \\left(\\begin{array}{c}t+1\\\\ k\\end{array}\\right)u^{(t+1-k)}v^{(k)}\n\\end{align}\n\\]\nとなり，\\(n = t + 1\\) の場合のライプニッツの公式の成立が確かめられた．\n\n\n\n\nExample 1 \n\\(y = x^2\\sin(x)\\) について \\(n\\) 階導関数を求めめたいとします．\n\\[\n(\\sin x)^{(k)} = \\sin\\left(x + \\frac{\\pi}{2}k\\right)\n\\]\nであるので\n\\(n=1\\) のときは\n\\[\ny^\\prime = x^2\\sin\\left(x + \\frac{\\pi}{2}\\right) + 2x\\sin(x)\n\\]\n\\(n\\geq 2\\) のときは，\\(x^2\\) が2回微分可能であることを考慮してライプニッツルールを利用すると\n\\[\n\\begin{align}\n\\frac{d^n}{dx^{n}}(x^2\\sin x)\n    &= x^2(\\sin(x))^{(n)} + 2nx(\\sin(x))^{(n-1)} + n(n-1)(\\sin(x))^{(n-2)}\\\\\n    &= x^2\\sin\\left(x + \\frac{\\pi}{2}n\\right) + 2nx\\sin\\left(x + \\frac{\\pi}{2}(n-1)\\right) + n(n-1)\\sin\\left(x + \\frac{\\pi}{2}(n-2)\\right)   \n\\end{align}\n\\]\n\n\n\nExample 2 \n\\[\n\\begin{align}\n(x\\sin x)^{(n)} = x\\sin\\left(x + \\frac{\\pi}{2}n\\right) + n \\sin\\left(x + \\frac{\\pi}{2}(n-1)\\right)\\\\\n(x\\cos x)^{(n)} = x\\cos\\left(x + \\frac{\\pi}{2}n\\right) + n \\cos\\left(x + \\frac{\\pi}{2}(n-1)\\right)\\\\\n(x^2\\exp(x))^{(n)} = x^2\\exp(x) + 2nx\\exp(x) + n(n-1)\\exp(x)\n\\end{align}\n\\]"
  },
  {
    "objectID": "posts/2025-02-02-taylor-expansion-and-polynomial/index.html#高階微分法とライプニッツの公式",
    "href": "posts/2025-02-02-taylor-expansion-and-polynomial/index.html#高階微分法とライプニッツの公式",
    "title": "有限個の多項式のテイラー展開",
    "section": "",
    "text": "\\(y = f(x)\\) の導関数を \\(f^\\prime(x)\\) とするとき，第二階の導関数を \\(f^{\\prime\\prime}(x)\\) と表記し，第 \\(n\\) 階の導関数を \\(f^{(n)}(x)\\) と表記します． 一点 \\(x\\) において\n\\[\n\\begin{gather}\nf^{\\prime\\prime}(x) = \\frac{d}{dx}\\left(\\frac{dy}{dx}\\right) = \\frac{d^2y}{dx^2}\\\\\nf^{(n)}(x) = \\frac{d^ny}{dx^n}\n\\end{gather}\n\\]\nとなります．\n ▶  記号の差異: \\(d^2y\\) vs \\(dx^2\\)\n\\(d^2y = d(dy)\\)，\\(dx^2 = (dx)^2\\) の意味で，この意味の差異を表現するため記号でも表記が異なっています．微分記号を用いて\n\\[\ndy = f^\\prime(x)dx\n\\]\nと書くとき，両辺の微分を取れば，\n\\[\n\\begin{align}\nd(dy) &= \\frac{d(f^{\\prime}(x))}{dx}(dx)^2 + f^\\prime(x)\\frac{d(dx)}{dx}dx\\\\\n      &= f^{\\prime\\prime}(x)(dx)^2 + f^\\prime(x)d(dx) \\label{eq-second-diff}\n\\end{align}\n\\]\n\\(x\\) が独立変数であるならば \\(dx\\) は \\(x\\) の水準関係なく自由に取れるので，\\(\\frac{d(dx)}{dx} = 0\\)．従って，\n\\[\nd^2y = f^{\\prime\\prime}(x)dx^2\n\\]\nとなります．もし，\\(x = \\varphi(t)\\) であるならば，\\(d^2x = \\varphi^{\\prime\\prime}(t)dt^2\\) となるので\n\\[\n\\frac{d}{dt^2}f(\\varphi(t)) = f^{\\prime\\prime}(\\varphi(t))(\\varphi^\\prime(t))^2 + f^\\prime(\\varphi(t))\\varphi^{\\prime\\prime}(t)\n\\]\n\n\n\n\nTheorem 1 : ライプニッツの公式(Leibniz rule) \n\\(u, v\\) が \\(x\\) の関数であるとき，\n\\[\n\\begin{align}\n\\frac{d^n(uv)}{dx^n}\n    &= u^{(n)}v + \\left(\\begin{array}{c}n\\\\1\\end{array}\\right)u^{(n-1)}v^{\\prime} + \\left(\\begin{array}{c}n\\\\2\\end{array}\\right)u^{(n-2)}v^{\\prime\\prime}+\\cdots+ \\left(\\begin{array}{c}n\\\\n-1\\end{array}\\right)u^{\\prime}v^{(n-1)} +uv^{(n)}\\\\\n    &= \\sum_{k=0}^n \\left(\\begin{array}{c}n\\\\ k\\end{array}\\right)u^{(n-k)}v^{(k)}\n\\end{align}\n\\]\n\n\n\n\n\n\n\n\n\nNoteProof\n\n\n\n\n\n\\(n=1\\) のときは，積の微分公式より\n\\[\n\\frac{d(uv)}{dx^n} = \\frac{du}{dx}v + \\frac{dv}{dx}u\n\\]\n\\(n\\geq 2\\) については，帰納法を用いて示す．\\(n=t\\) のときライプニッツの公式が成立すると仮定する．\nこのとき，\n\\[\n\\begin{align}\n\\frac{d^{(t+1)}(uv)}{dx^{t+1}}\n    &= \\frac{d}{dt}\\left(\\frac{d^{(t)}(uv)}{dx^{t}}\\right)\\\\\n    &= \\frac{d}{dt}\\left(\\sum_{k=0}^t \\left(\\begin{array}{c}t\\\\ k\\end{array}\\right)u^{(t-k)}v^{(k)}\\right)\\\\\n    &= \\sum_{k=0}^t \\left(\\begin{array}{c}t\\\\ k\\end{array}\\right)[u^{(t-k+1)}v^{(k)} + u^{(t-k)}v^{(k+1)}]\\\\\n    &= \\sum_{k=0}^t \\left(\\begin{array}{c}t\\\\ k\\end{array}\\right)u^{(t-k+1)}v^{(k)} + \\sum_{k=0}^t \\left(\\begin{array}{c}t\\\\ k\\end{array}\\right)u^{(t-k)}v^{(k+1)}\\\\\n    &= \\left\\{u^{(t+1)}v + \\sum_{k=1}^t \\left(\\begin{array}{c}t\\\\ k\\end{array}\\right)u^{(t-k+1)}v^{(k)}\\right\\}+ \\left\\{uv^{(t+1)} + \\sum_{k=0}^{t-1} \\left(\\begin{array}{c}t\\\\ k\\end{array}\\right)u^{(t-k)}v^{(k+1)}\\right\\}\\\\\n    &= \\left\\{u^{(t+1)}v + \\sum_{k=1}^t \\left(\\begin{array}{c}t\\\\ k\\end{array}\\right)u^{(t-k+1)}v^{(k)}\\right\\}+ \\left\\{uv^{(t+1)} + \\sum_{j=1}^{t} \\left(\\begin{array}{c}t\\\\ j-1\\end{array}\\right)u^{(t-j+1)}v^{j}\\right\\}\\\\\n    &= u^{(t+1)}v + uv^{(t+1)} + \\sum_{k=1}^t \\left\\{\\left(\\begin{array}{c}t\\\\ k\\end{array}\\right) + \\left(\\begin{array}{c}t\\\\ k-1\\end{array}\\right)\\right\\}u^{(t-k+1)}v^{(k)}\\\\\n    &= u^{(t+1)}v + uv^{(t+1)} + \\sum_{k=1}^t \\left(\\begin{array}{c}t+1\\\\ k\\end{array}\\right)u^{(t+1-k)}v^{(k)}\\\\\n    &= \\sum_{k=0}^{t+1} \\left(\\begin{array}{c}t+1\\\\ k\\end{array}\\right)u^{(t+1-k)}v^{(k)}\n\\end{align}\n\\]\nとなり，\\(n = t + 1\\) の場合のライプニッツの公式の成立が確かめられた．\n\n\n\n\nExample 1 \n\\(y = x^2\\sin(x)\\) について \\(n\\) 階導関数を求めめたいとします．\n\\[\n(\\sin x)^{(k)} = \\sin\\left(x + \\frac{\\pi}{2}k\\right)\n\\]\nであるので\n\\(n=1\\) のときは\n\\[\ny^\\prime = x^2\\sin\\left(x + \\frac{\\pi}{2}\\right) + 2x\\sin(x)\n\\]\n\\(n\\geq 2\\) のときは，\\(x^2\\) が2回微分可能であることを考慮してライプニッツルールを利用すると\n\\[\n\\begin{align}\n\\frac{d^n}{dx^{n}}(x^2\\sin x)\n    &= x^2(\\sin(x))^{(n)} + 2nx(\\sin(x))^{(n-1)} + n(n-1)(\\sin(x))^{(n-2)}\\\\\n    &= x^2\\sin\\left(x + \\frac{\\pi}{2}n\\right) + 2nx\\sin\\left(x + \\frac{\\pi}{2}(n-1)\\right) + n(n-1)\\sin\\left(x + \\frac{\\pi}{2}(n-2)\\right)   \n\\end{align}\n\\]\n\n\n\nExample 2 \n\\[\n\\begin{align}\n(x\\sin x)^{(n)} = x\\sin\\left(x + \\frac{\\pi}{2}n\\right) + n \\sin\\left(x + \\frac{\\pi}{2}(n-1)\\right)\\\\\n(x\\cos x)^{(n)} = x\\cos\\left(x + \\frac{\\pi}{2}n\\right) + n \\cos\\left(x + \\frac{\\pi}{2}(n-1)\\right)\\\\\n(x^2\\exp(x))^{(n)} = x^2\\exp(x) + 2nx\\exp(x) + n(n-1)\\exp(x)\n\\end{align}\n\\]"
  },
  {
    "objectID": "posts/2025-02-02-taylor-expansion-and-polynomial/index.html#有限個の多項式のテイラー展開",
    "href": "posts/2025-02-02-taylor-expansion-and-polynomial/index.html#有限個の多項式のテイラー展開",
    "title": "有限個の多項式のテイラー展開",
    "section": "有限個の多項式のテイラー展開",
    "text": "有限個の多項式のテイラー展開\n\\(n\\) 次式の \\(f(x)\\) を考えます．このとき，定義域の任意の点 \\(a\\) を用いて，以下のように表すとします\n\\[\nf(x) = a_0 + a_1(x-a) + a_2(x-a)^2 + \\cdots + a_n(x-a)^n\n\\]\n\\(x = a\\) のとき，\\(f(a) = a_0\\)．両辺を \\(k\\) 回微分すると\n\\[\nf^{(k)}(x) = a_kk! + a_{k+1}\\frac{(k+1)!}{1!}(x-a) + a_{k+2}\\frac{(k+2)!}{2!}(x-a)^2 + \\cdots + a_{n}\\frac{n!}{(n-k)!}(x-a)^{n-k}\n\\]\nこのとき，\\(f^{(k)}(a) = a_kk!\\) であるので，\\(a_k = \\frac{f^{(k)}(a)}{k!}\\) を得る．従って，\\(n\\) 次式の \\(f(x)\\) は\n\\[\nf(x) = f(a) + \\frac{f^{\\prime}(a)}{1!}(x-a) + \\frac{f^{(2)}(a)}{2!}(x-a)^2 + \\cdots + \\frac{f^{(n)}(a)}{n!}(x-a)^n\\label{eq-poly}\n\\]\nと表すことが出来ます．\n\nExample 3 \n\\(f(x) = x^n\\) を\n\\[\nf(x) = a_0 + a_1(x-1) + a_2(x-1)^2 + \\cdots + a_n(x-1)^n\n\\]\nで表したいとします．このとき，\\(\\eqref{eq-poly}\\) より\n\\[\n\\begin{align}\nx^n\n    &= 1 + \\frac{n}{1!}(x-1)+ \\frac{n(n-1)}{2!}(x-1)^2 + \\cdots + \\frac{n!}{n!}(x-1)^n\\\\\n    &= \\sum_{k=0}^n \\left(\\begin{array}{c}n\\\\ k\\end{array}\\right)(x-1)^k\n\\end{align}\n\\]\nと表せます．これを更に式変形すると\n\\[\n\\begin{align}\n\\sum_{k=0}^n \\left(\\begin{array}{c}n\\\\ k\\end{array}\\right)(x-1)^k\n    &= \\sum_{k=0}^n \\left(\\begin{array}{c}n\\\\ k\\end{array}\\right)(x-1)^k 1^{n-k}\\\\\n    &= (x - 1 + 1)^n\\\\\n    &= x^n\n\\end{align}\n\\]\nよって \\(x^n\\) の \\(x = 1\\) まわりでのテイラー展開は \\((x - 1 + 1)^n\\) の二項展開と関係づけて理解することが出来ます．\n\n\n\n\nTheorem 2 \n\\(n\\) 次式の \\(f(x)\\) について，\\(x=a\\) が \\(k\\) 重解であるための必要十分条件は\n\\[\n\\begin{gather}\nf(a) = f^\\prime(a) = \\cdots = f^{(k-1)}(a) = 0\\\\\nf^{(k)}(a) \\neq 0\n\\end{gather}\n\\]\n\n\n\n\n\n\n\n\n\nNoteProof\n\n\n\n\n\n\\(x=a\\) が \\(k\\) 重解であるということは，\\(f(x) = (x-a)^kg(x), g(a)\\neq 0\\) と同値であることに留意して以下示します．\n ▶  十分性\n\\(\\eqref{eq-poly}\\) より\n\\[\n\\begin{align}\nf(x)\n    &=\\frac{f^{(k)}(a)}{k!}(x-a)^k + \\frac{f^{(k+1)}(a)}{(k+1)!}(x-a)^{k+1} + \\cdots +\\frac{f^{(n)}(a)}{n!}(x-a)^n\\\\\n    &= (x-a)^k\\left\\{\\frac{f^{(k)}(a)}{k!} + \\frac{f^{(k+1)}(a)}{(k+1)!}(x-a)^{1} + \\cdots + \\frac{f^{(n)}(a)}{n!}(x-a)^{n-k}\\right\\}\\\\\n    &= (x-a)^kg(x)\n\\end{align}\n\\]\nこのとき，\\(f^{(k)}(a) \\neq 0\\) より \\(g(a)\\neq 0\\). 以上より，十分性は示せた．\n ▶  必要性\n\\(f(x) = (x-a)^kg(x), g(a)\\neq 0\\) のとき，\\(f(a) = 0\\) は自明． この式を \\(m\\) 回微分するとライプニッツルールより\n\\[\n\\begin{aligned}\nf^{(m)}(x) =& (x-a)^kg^{(m)}(x) + \\left(\\begin{array}{c}m\\\\ 1\\end{array}\\right)k(x-a)^{k-1}g^{(m-1)}(x) \\\\\n            &+ \\cdots + \\left(\\begin{array}{c}m\\\\ m\\end{array}\\right)k(k-1)\\cdots(k-m+1)(x-a)^{k-m}g(x)\n\\end{aligned}\n\\]\n\\(m &lt; k\\) であるならば，\\(f^{(m)}(a) = 0\\)，また \\(m = k\\) であるならば\n\\[\nf^{(k)}(a) = k!g(a) \\neq 0\n\\]\n従って，必要性も示された．\n\n\n\n\nExample 4 \n\\[\nf(x) = x^4 + ax^2 + bx + c = 0\n\\]\nが \\(x=1\\) を３重解に持つようにするようにパラメータを定めたいとします．\n\\[\n\\begin{align}\nf(1) &= 1 + a + b + c = 0\\\\\nf^\\prime(1) &= 4 + 2a + b = 0\\\\\nf^{\\prime\\prime}(1) &= 12 + 2a = 0\\\\\nf^{(3)}(1) &= 24 \\neq 0\\\\\n\\end{align}\n\\]\nこれを解くと，\\((a, b, c) = (-6, 8, -3)\\)．これを用いて整理すると\n\\[\nf(x) = (x-1)^3(x+3)\n\\]\nとなります．\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\n\ndef func_x(x, a, b, c):\n    return x**4 + a*x**2 + b*x + c\n\nx_domain = np.linspace(-4, 4, 100)\n\nplt.plot(x_domain, func_x(x_domain, *(-6, 8, -3)), label='$f(x) = x^4 - 6x^2 + 8x - 3$')\nplt.plot(x_domain, func_x(x_domain, *(-8, 12, -5)), label='$f(x) = (x-1)^2(x^2+2x-5)$')\nplt.xlabel('X')\nplt.ylabel('y')\nplt.axhline(0, color='gray', linestyle='--', linewidth=0.7)\nplt.legend()\nplt.xlim(-4, 4)\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 1"
  },
  {
    "objectID": "posts/2025-06-11-heatpump-lecture-01/index.html",
    "href": "posts/2025-06-11-heatpump-lecture-01/index.html",
    "title": "冷凍サイクルとヒートポンプの基礎",
    "section": "",
    "text": "Key Takeaways"
  },
  {
    "objectID": "posts/2025-06-11-heatpump-lecture-01/index.html#ものを冷やす仕組み",
    "href": "posts/2025-06-11-heatpump-lecture-01/index.html#ものを冷やす仕組み",
    "title": "冷凍サイクルとヒートポンプの基礎",
    "section": "ものを冷やす仕組み",
    "text": "ものを冷やす仕組み\n熱は常に「高温から低温へ移動(=熱力学第二法則)」します．この性質を利用して，冷却は次のように行われます：\n\n対象物よりも温度の低いものを接触させて熱を移動させる = 熱伝導ベース\n蒸発や断熱膨張などの物理現象を利用して，周囲から熱を奪う = 相変化ベース\n\nものを冷やすのは熱伝導ベースと相変化ベースの２つがありますが，冷却効率は大きく異なります．\n\n\n\n\n\n\n\n\n項目\n顕熱冷却\n蒸発冷却\n\n\n\n\n熱の種類\n顕熱（温度変化）\n潜熱（状態変化）\n\n\n冷却効率（J/g）\n例：1gの水を用いて10℃分熱を吸収する → 約42 J/g吸収\n水1gの蒸発 → 約2260 J/g吸収\n\n\nエネルギー吸収\n小さい（比熱×温度差に依存）\n大きい（潜熱は比熱の数十倍）\n\n\n使用例\n冷水で冷やす，金属板で放熱など\n汗の蒸発，気化式冷却，打ち水\n\n\n\n同じ質量の水を使っても，蒸発させた方がはるかに多くの熱エネルギーを奪えるため，冷却効率が高いという特徴が有ります．\n\n\n\n\n\n\nNote顕熱と比熱と潜熱\n\n\n\n\n1kgの冷水が \\(4.1916\\) kJ の熱を取り入れると，1Kだけ温度が上昇する．\n水を20℃→30℃に温めるときに使う熱は「顕熱」\n物質1kgの温度を1K上げるのに必要な熱量は「比熱」\n物質が状態変化（固体⇄液体⇄気体）するときに温度を変えずに出入りする熱は「潜熱」\n\n熱運動の激しさを変化させるのではなく，分子間の結合をほどくために使われる熱\n融解熱や蒸発熱\n\n\n\n\n\nExample 1 顕熱\n比熱 \\(c\\) [kJ/kg・K]， 質量 m[kg]，温度 \\(t_1\\) [K] の物質が熱を吸収して \\(t_2\\) になったとき，吸収した熱量 \\(Q\\) [kJ] は\n\\[\nQ = m\\cdot c(t_2 - t_1)\n\\]\nと計算できます．\n\n\n\nExample 2 水1gの潜熱\n水は極性分子で，水素結合が強いため，蒸発に多くのエネルギーが必要という特徴が有ります．\n\n\nCode\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\ndf = pd.read_csv('./input.csv')\ntemp = df['temp']\nenthalpy = df['enthalpy'] * 1000\n# pa = df['Pa']\n\nplt.figure(figsize=(8, 6))\nplt.plot(temp, enthalpy)\n\n# 軸ラベルとタイトル\nplt.xlabel('evaporation temperature(℃)')\nplt.ylabel('latent heat(J)')\nplt.title('evaporation temperature vs latent heat plot')\n\nplt.grid(True, linestyle=':', alpha=0.6)\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNote熱力学における圧力と温度\n\n\n\nマクロの状態変数\n\n熱力学とは，「非道にたくさんの分子からなる集団を１つの系と見て，これをマクロ的または統計的に調べる学問」\n空気などの気体を体積 \\(V\\) のある容器に入れたとき，夥しい気体分子が容器の中でそれぞれ動いている(ミクロ的視点)\nこの気体のマクロ的状態を表す量として圧力 \\(p\\) と絶対温度 \\(T\\) がある\n\nミクロとマクロの関係\n\n圧力 \\(p\\): ものすごい数の気体分子が単位時間・単位面積当たり，容器の壁面に衝突して与えられる力積(\\(\\text{力} \\times \\text{時間}\\))の平均的な送料\n温度 \\(T\\): 気体分子の不規則な運動の平均的な激しさの度合い\n\n絶対零度\n\nすべての分子が不規則な運動をやめて静止している状態\n\n\n\n\n0℃以下の低温までものを冷やしたいとき → 冷媒の登場\n熱を取り除きたいときは，蒸発潜熱を利用した冷却が効率が良いとわかりましたが，常圧のもとでは水は 100℃で沸騰，蒸発となります(標準沸点が100℃)．一方，絶対圧 0.6108 kPa のような低圧にすれば 0℃で水は沸騰→蒸発しますが，\n\nものを0℃まで冷やしたい場合は，この圧力を保つことが必要 → 高性能な真空ポンプが必要\n0℃以下まで冷やしたいとしても，0℃で水は凍ってしまうので，0℃以下の低温を得ることはできない(熱力学第二法則)\n\n0℃以下の低温を得るには，あまり高真空にすることなく，低い温度で沸騰・蒸発し，しかも蒸発潜熱の大きい物質を媒体として選ば良いとなります． このような熱を取り去る媒体を冷媒といいます．\n\nDefinition 1 (冷媒) \n冷媒（refrigerant）とは，蒸発・凝縮などの相変化を通じて熱を運ぶ物質であり，主に冷凍機やエアコン，ヒートポンプで使われます． 蒸気圧圧縮冷凍装置で用いられる冷媒として，アンモニアやフルオロカーボン(R 134 a, R410 aなど)がある．\n\n冷媒に求められる性質\n\n毒性及び燃焼性が低く，安全性に優れること\n地球環境や周囲環境を破壊しないこと\n化学的に安定であること\n適切な沸点を持つこと\n経済性および入手性に優れること\n単位面積あたりの冷凍能力が大きいこと（蒸発潜熱が大きい冷媒を使っていても，熱伝導率が悪かったり，流速が遅いと単位面積あたりの冷凍能力は小さい可能性がある）\n理論成績係数が高いこと\n圧縮機吐出しガス温度が冷凍機油の使用温度範囲内であること\n伝熱特性に優れること\n\n\n\n冷媒の種類\n蒸気圧縮冷凍装置が出現した初期は，メチルエーテル，エチルエーテル，アンモニア，二酸化硫黄，メチルクロライドなどが冷媒として使用されていましたが，燃焼性や毒性という問題が有りました．\n1928年にアメリカで無毒の不燃性のフルオロカーボン冷媒(R12)が発明され，産業用/家庭用の冷蔵庫や冷凍空調装置が普及するようになりました．冷媒は基本的にはフルオロカーボンとその他（自然冷媒）に分類されるほど普及しています．フルオロカーボンは，炭化水素の水素を一部フッ素に置き換えた化合物です．分子構造の特徴によりCFC，HCFC，HFC，HFO等のグループに分けられます．\nフルオロカーボン冷媒の種類\n\n\n\n\n\n\n\n\n\n冷媒種類\n冷媒番号\n説明\n\n\n\n\nCFC冷媒\nR11, R12\n塩素を含むクロロフルオロカーボン冷媒．モントリオール議定書での規制対象．1995年末の段階で日本では全廃されている\n\n\nHCFC冷媒\nR22, R123\n塩素を少量だけ含むハイドロクロロフルオロカーボン冷媒．2020年に日本では全廃\n\n\nHFC冷媒\nR32, R125, R134a，R410A\n塩素を含まないハイドロフルオロカーボン冷媒．HFC冷媒は，HCFC冷媒と比べると誘電率が大きく，その電気絶縁性がやや劣る（圧縮機からの漏れ電流には注意を要する）\n\n\n\n\nフルオロカーボン冷媒とアンモニア冷媒の比較\n\n冷凍効果という点ではアンモニアが圧倒的に優れる\nフルオロカーボン冷媒は冷凍効果は低めだが，安全性や取り扱いやすさから広く使われている\n\n\n\n\n\n\n\n\n\n\n比較項目\nアンモニア（NH₃）\nフルオロカーボン（HFC）\n\n\n\n\n冷凍効果（潜熱）\n◎ 非常に高い\n△ 中程度\n\n\n熱伝導率\n◎ 高い\n△ 低い\n\n\n冷媒量\n◎ 少量で済む\n△ 多く必要\n\n\n圧力\n○ 中〜高圧\n○ 中圧（使いやすい）\n\n\n安全性\n× 毒性・可燃性あり\n◎ 無毒・非可燃（だがGWP高）\n\n\n環境性\n◎ ODP/GWP＝0\n△ GWP高いものが多い\n\n\n用途\n産業用冷凍（冷凍倉庫など）\n家庭・車・業務用エアコンなど\n\n\n\n\n\n\n\n\n\n\nTip塩素とオゾン層破壊\n\n\n\n塩素を含むフルオロカーボン冷媒が大気中に放出されると，太陽からの強い紫外線によって分解され塩素 Cl を放出します． これがオゾン \\(\\text{O}_3\\) と以下のような化学反応を行って，オゾンを分解・破壊してしまいます\n\\[\n\\begin{align}\n\\text{Cl} + \\text{O}_3 &\\to \\text{CIO} + \\text{O}_2\\\\\n\\text{ClO} + \\text{O} &\\to \\text{CI} + \\text{O}_2 \\text{(再びオゾンを破壊してしまうClを生成)}\n\\end{align}\n\\]\n\nCIO: 一酸化塩素，常温常圧で気体であり，非常に不安定\n\n\n\n冷媒の番号\n冷媒番号はアシュレイ番号ともよばれ，冷媒の記号は先頭に「R」をつけて，2～4桁の数字を用いて表します．表記方法はASHRAE規格34及びISO817によって以下のように定められています\n\n\n\n\n\n\n\n\n項目\n説明\n\n\n\n\nR\n冷媒（Refrigerant）の頭文字\n\n\n千の位\n不飽和炭化水素に対する不飽和炭素結合の数（二重結合・三重結合など）\n\n\n百の位\n炭素原子の数 − 1\n\n\n十の位\n水素原子の数 ＋ 1\n\n\n一の位\nフッ素原子の数\n\n\n添え字\n構造異性体（同じ組成式だが結合の構造が異なる）または混合物の組成を区別するための記号\n\n\n\n\n\nプロパン冷媒(R290): \\(\\text{C}_3\\text{H}_8\\)\nR32: \\(\\text{C}\\text{H}_2\\text{F}_2\\)\n\nただし，すべてがこのルールに則っているわけではなく，400番台は非共沸混合冷媒，500番台は共沸混合冷媒を示します．これらの場合，番号の下２桁はASHRAE規格で認定された冷媒番号の取得順となります．\n600番台は有機化合物，700番台は無機化合物を示します．そのため，二酸化炭素やアンモニアなどの無機化合物には700番台が与えられます．例として，Nブタン冷媒R600，アンモニアR717，二酸化炭素R744です．\n\n\n\n\n\n\nTip共沸混合冷媒と非共沸混合冷媒\n\n\n\nフルオロカーボン冷媒の「単一成分冷媒」をいくつか混ぜ合わせた「混合冷媒」があり，混合冷媒は「非共沸点混合冷媒」と「共沸混合冷媒」に分けられます．非共沸混合冷媒は沸点の異なる冷媒同士を混ぜ合わせた冷媒のことです．\n\n相変化のとき温度勾配が生じる\n露点（凝縮始め）と沸点（凝縮終わり）が一致しない\n\nという特徴が有ります．一方，温度勾配を生じないのが「共沸混合冷媒」(R507A)です．温度勾配の小さい「非共沸混合冷媒」は「共沸混合冷媒」に近い凝縮蒸発特性があるので「疑似共沸混合冷媒」(R410A と R404A)とも呼ばれたりします．\n\n\n\n\nフルオロカーボン冷媒の取り扱い\n\nフルオロカーボンは安定した冷媒で，毒性は低く，可燃性もないが酸欠の危険がある\n大気中で空気より重く，濡れると床面付近に滞留しやすい\n冷媒設備の全冷媒充填量(kg)を，冷媒を内蔵している機器を設置した最小室内陽席(m³)で除した値が，限界濃度以下であること\n圧力容器や配管の修理の際に，内部に残留ガスがないことを確かめること\n裸火や高温の物体に触れると，分解してフッ化水素やホスゲンなどの毒性の強いガスを生成する\nフルオロカーボン冷媒が濡れて滞留している室内に燃焼危惧があると不完全燃焼となり，一酸化炭素中毒のおそれがある\n\n\n\n\n\n\n\nTip限界濃度\n\n\n\n\n限界濃度とは，この濃度において湿疹や重大な障害を受けることなく，緊急の処置をとった上で，自らも避難できる程度の濃度\n\n\n\n\n\n蒸発器・凝縮器・圧縮機・膨張弁\n\n\n\n\n\n冷凍装置において，冷媒の蒸発潜熱を利用して物を冷却するには，冷媒と物とを直接接触させずに，冷却館内や容器内で冷媒を沸騰・蒸発させ．その壁（例: 配管壁）を介して冷却します．このような冷却管や容器で構成されたものを蒸発器といいます．\n熱吸収した冷媒蒸気を蒸発器から取り除かなれば，一定の蒸発温度を維持することができなくなってしまいます．そのため発生した冷媒蒸気を蒸発器から常に取り除かなければなりません．熱吸収した冷媒蒸気を捨て去ってもいいですが，経済的ではないのでどうにか再利用する方法を模索する必要が有ります．\n冷媒が沸騰・蒸発する温度（飽和温度）は圧力が下がるに伴って低下，逆に圧力上がると飽和温度も上昇します．この性質を活用し，蒸発器内で発生した蒸気に対して圧力を加える + 周囲（例: 外気温）から得られる外気や水で冷却（=潜熱を開放）して再び液化します．このように冷媒は装置内を蒸発，圧力上昇，液化，膨張，再蒸発といった状態変化を繰り返しながら循環し，目的の冷凍作用を行います． この過程のことを冷凍サイクルと呼びます．\n📘 REMARKS\n\n\n\n\n\n\n\n\n構成要素\n説明\n\n\n\n\n蒸発器\n低圧の液体冷媒が熱を吸収して蒸発し，周囲から熱を奪うことで冷却を行う熱器\n\n\n圧縮機\n蒸気が凝縮する圧力まで高めるために用いられる機器．空調機のの消費電力の約８割を占める\n\n\n凝縮器\n高圧・高温の冷媒蒸気を冷却し，凝縮させる伝熱管や容器で構成された機器\n\n\n膨張弁\n圧力が高い凝縮器と圧力が低い蒸発器を結び通路の弁．凝縮した高圧の冷媒液を，低圧の蒸発器で蒸発した量だけ弁を調整して補給することで，蒸発器内を一定の低い圧力に保つ\n\n\n\n\n\n\n\n\n\n\n\n\nph線図における点\n冷媒状態\n\n\n\n\n1\n蒸発器をでて圧縮機に吸入される冷媒ガスは乾燥飽和蒸気より少し過熱された過熱蒸気（低圧）\n\n\n2\n圧縮機から吐出され，凝縮器に入る冷媒蒸気はかなり温度の高い過熱蒸気（高圧）\n\n\n5\n凝縮器で飽和液が少し過冷却され，膨張弁に入る過冷却液（高圧）\n\n\n6\n膨張弁を通って減圧され，蒸発器に入る湿り蒸気（低圧）\n\n\n\n\n\n\n\n\n\n\n\n\nTip潜熱とウォームコア\n\n\n\n気体から液体に戻るとき，潜熱が開放されて周囲を温めます．身の回りの例として，台風の中心には強い上昇気流があり，それによって空気に含まれている水蒸気が上空に運ばれてと飽和し，そこで凝結（雲の状態へ）します．このとき潜熱を放出するので，台風中心の上空の空気は，その周りの平均気温よりも高くなっています．\n\n\n\n台風の温度偏差の鉛直断面図\n\n\n上の図はx軸が台風の中心からの距離，y軸が高度及び気圧を指しています．等高線みたいな線は気候学的な高度別平均気温との差（温度偏差）をplotしています．"
  },
  {
    "objectID": "posts/2025-06-11-heatpump-lecture-01/index.html#蒸発器と凝縮器におけるエンタルピー変化",
    "href": "posts/2025-06-11-heatpump-lecture-01/index.html#蒸発器と凝縮器におけるエンタルピー変化",
    "title": "冷凍サイクルとヒートポンプの基礎",
    "section": "蒸発器と凝縮器におけるエンタルピー変化",
    "text": "蒸発器と凝縮器におけるエンタルピー変化\n理論冷凍サイクルにおいて，冷媒の蒸発及び凝縮は圧力一定のもとで行われます．比エンタルピー変化が\n\\[\ndh = dq + vdp\n\\]\nであるので，圧力一定であるので \\(dp=0\\) であることから\n\\[\ndh = dq\n\\]\nつまり，授受した熱量に相当する分だけ比エンタルピーが変化することがわかります．"
  },
  {
    "objectID": "posts/2025-06-11-heatpump-lecture-01/index.html#冷凍装置の効率係数",
    "href": "posts/2025-06-11-heatpump-lecture-01/index.html#冷凍装置の効率係数",
    "title": "冷凍サイクルとヒートポンプの基礎",
    "section": "冷凍装置の効率係数",
    "text": "冷凍装置の効率係数\n圧縮機の仕事量\n圧縮機に流出入する冷媒1kgが保有するエネルギーは，運動エネルギーや位置エネルギーが十分小さく無視できるとすると以下のように表せます\n\\[\n\\underbrace{h}_{\\text{比エンタルピー}} = \\underbrace{u}_{\\text{内部エネルギー}} + \\underbrace{p\\nu}_{\\text{冷媒流動の仕事}}\n\\]\n\n\\(h\\): 流動する冷媒の保有エネルギー [kJ/kg]\n\\(u\\): 物体を構成している膨大な数の分子・原子のもつエネルギーの総和として，物体内に蓄えられているエネルギー\n\n熱エネルギーと分子・原子などの平均配置を決める相互作用エネルギー\n\n\\(p\\): 圧力\n\\(\\nu\\): 比体積(冷媒蒸気1kgの体積) [\\(m^3\\)/kg]\n\nしたがって，以下のように変数を整理すると\n\n\\(q_m\\) [kg/s] : 圧縮機に単位時間に流出入する冷媒流量\n\\(h_1\\): 圧縮機入口の冷媒の比エンタルピー\n\\(h_2\\): 圧縮機出口の冷媒の比エンタルピー\n\n圧縮機によって冷媒に加えられる単位時間あたりの圧縮仕事 \\(P\\) [kW] は以下のように表すことができます\n\\[\nP = q_m(h_2 - h_1)\n\\]\n蒸発器の熱交換量\n蒸発器においては，冷媒は熱を組み上げ，その量だけ保有エネルギーが増大します．冷媒 1kg あたりが組み上げる熱量(冷凍効果)[kJ/kg]を \\(r\\) とすると\n\n\\(h_1\\): 蒸発器出口の冷媒の比エンタルピー\n\\(h_6\\): 入口の比エンタルピー\n\nを用いて，\n\\[\nr = h_1 - h_6\n\\]\nまた，単位時間あたりの交換熱量 \\(\\Phi_o\\) は\n\\[\n\\Phi_o = q_m(h_6 - h_1)\n\\]\nつまり，冷凍装置の冷凍能力は，蒸発器出入り口における冷媒の比エンタルピー差に冷媒循環量を乗じて求められることになります．\n凝縮器の熱交換量\n凝縮器では冷媒は熱放出し，その単位時間あたりの放出熱量 \\(\\Phi_k\\) [kW] を凝縮負荷と呼びます．\n\n\\(h_2\\): 凝縮器入口の冷媒比エンタルピー\n\\(h_5\\): 凝縮器出口の冷媒比エンタルピー\n\nより\n\\[\n\\Phi_k = q_m(h_2 - h_5)\n\\]\n\n\n\n\n\n\nTip膨張弁\n\n\n\n膨張弁では基本的に外部と熱交換を行いません．高圧・高温の液冷媒を断熱膨張を通して低圧・低温の液冷媒に変えるのが主な機能です． 冷媒液が圧力降下するときに，液の一部が自己蒸発する際の潜熱によって，冷媒自身の温度が下がります．\n\n\n\n熱力学第一法則(エネルギー保存則)\n単位時間あたりに冷凍装置に入るすべてのエネルギーは，単位時間あたりに装置から出るすべてのエネルギーと等しくなければなりません．ここから次の式が成立します:\n\\[\n\\Phi_k = \\Phi_o + P\n\\]\n\n\n\n蒸気圧圧縮式冷凍装置の熱収支\n\n\n\nDefinition 2 (冷凍サイクルの成績係数) \n冷凍作用を行うのに必要なエネルギー \\(P\\) と冷凍能力 \\(\\Phi_o\\) の比を冷凍サイクルの成績係数(\\(COP_c\\))といい\n\\[\nCOP_c = \\frac{\\Phi_o}{P}\n\\]\nこの値は同じ冷凍装置であっても，運転条件によって変わります．\n\n冷凍サイクルの成績係数が大きいほど小さい動力で大きな冷凍能力が得られると解釈できます．\n\n\n\n\n\n\nTip実際の機器における圧縮機仕事\n\n\n\n実際の圧縮機では，\n\n吸い込み弁と吐出し便の流れの抵抗\n吸い込み蒸気とシリンダ壁との間の熱交換\n蒸発器直後の連絡配管圧力損失\n機械的摩擦損失動力\n\nといった要因により理論断熱圧縮動力以上の圧縮動力を必要とします．つまり\n\\[\nP = P_c + P_m\n\\]\n\n\\(P\\): 実際の圧縮機の駆動に必要な動力\n\\(P_c\\): 蒸気の圧縮に用いられる圧縮動力\n\\(P_m\\): 機械的摩擦損失動力の和\n\n一般に機械効率 \\(\\displaystyle \\frac{P_c}{P}\\) は0.8~0.9 とされます．\n\n\n\n\nヒートポンプ\n\nDefinition 3 (ヒートポンプ) \n冷媒を凝縮するために凝縮器で熱量 \\(\\Phi_k\\) を放熱しているが，これを暖房やその他の加熱源として利用する装置をヒートポンプ装置と呼び，そのサイクルをヒートポンプサイクルという．\n\n「冷媒の流れ方向自体は同じだが，吸熱と放熱の役割が冷凍機と逆になる．つまり，蒸発器で吸収した熱を暖房として利用するのがヒートポンプである」点に注意してください．\nヒートポンプサイクルの成績係数 \\(COP_h\\) は\n\\[\n\\begin{align}\nCOP_h\n  &= \\frac{\\Phi_k}{P}\\\\\n  &= \\frac{\\Phi_o + P}{P}\\\\\n  &= COP_c + 1\n\\end{align}\n\\]\nこの式より，ヒートポンプサイクルの成績係数は，同じ温度条件の冷凍サイクルの成績係数よりも１だけかならず大きい値になることがわかります．\n\n\n製品としての能力\n実際のエアコンなどの空調機器の「能力」は，単に冷媒回路が移動する熱量（冷却や加熱）だけでなく，室内ファンなどの補助的な消費電力の影響も加味して評価されることがあります\n\\[\n\\begin{align}\n\\text{冷房能力} &= \\Phi_0 - \\text{室内ファン消費電力}\\\\\n\\text{暖房能力} &= \\Phi_k + \\text{室内ファン消費電力}\n\\end{align}\n\\]"
  },
  {
    "objectID": "posts/2025-06-11-heatpump-lecture-01/index.html#理解度チェック問題",
    "href": "posts/2025-06-11-heatpump-lecture-01/index.html#理解度チェック問題",
    "title": "冷凍サイクルとヒートポンプの基礎",
    "section": "📘 理解度チェック問題",
    "text": "📘 理解度チェック問題\n\nExercise 1 \n容器に入った20℃の水8kgに，0℃の氷3.0kgを入れて放置した．容器は断熱されており，熱容量は無視できるとして，平衡状態の容器内の温度と容器内の氷の質量を求めよ．水の比熱を4.19kJ/(kg·K)，氷の融解潜熱を334kJ/kgとする．\n\n\n\n\n\n\n\nNoteSolution\n\n\n\n\n\n条件\n\n\n\n項目\n値\n\n\n\n\n水の質量\n\\(8.0 \\, \\text{kg}\\)\n\n\n水の初温\n\\(20^\\circ\\text{C}\\)\n\n\n氷の質量\n\\(3.0 \\, \\text{kg}\\)\n\n\n氷の初温\n\\(0^\\circ\\text{C}\\)\n\n\n水の比熱\n\\(4.19 \\, \\text{kJ/(kg·K)}\\)\n\n\n氷の融解熱\n\\(334 \\, \\text{kJ/kg}\\)\n\n\n\n水を0℃まで冷やすのに必要な熱量の計算\n\\[\n\\begin{align}\nQ_{water}\n  &= (20 - 0) \\text{K} \\times 4.19 \\text{kJ/kg·K} \\times 8 \\text{kg}\\\\\n  &= 670.4\\text{kJ}\n\\end{align}\n\\]\n氷が全て溶けるのに必要な熱量\n\\[\n\\begin{align}\nQ_{ice}\n  &= 334\\text{kJ/kg} \\times 3.0\\text{kg}\\\\\n  &= 1002\\text{kJ}\n\\end{align}\n\\]\nthen, \\(Q_{ice} &gt; Q_{water}\\) のため，氷がすべて溶け切ることはないことがわかります．\nどれくらいの氷が残るのか？\n水を0℃まで冷やすのに使用される氷の質量は\n\\[\n\\frac{Q_{water}}{\\text{氷の融解熱}} = \\frac{670.4\\text{kJ}}{334\\text{kJ/kg}} \\approx 2.007\\text{kg}\n\\]\nしたがって，平衡状態の容器内の温度と容器内の氷の質量は温度＝0℃，氷の質量＝0.993kgとなる．\n\n\n\n\nExercise 2 \n次の記述の内，正しいものを選べ\n\n冷凍装置では，蒸発器で取り入れた熱と凝縮器で放出する熱量は等しい\n蒸気圧縮冷凍装置の冷却能力は，圧縮機に加えるエネルギーに等しい\n吸収冷凍装置の駆動源は熱であり，これを再生器に加えることにより低温を得る\n蒸気圧縮ヒートポンプでは，装置内を循環する冷媒の流れ方向が冷凍サイクルのそれと逆方向になる\n蒸気圧縮ヒートポンプの成績係数は，同じ温度条件での冷凍サイクルの成績係数より１だけ大きい．\n冷凍サイクルの成績係数は，蒸発温度や凝縮温度には関係しない\nヒートポンプの成績係数の値は常に1より大きい\n冷凍装置における冷凍能力は，各機器への熱の出入り前後の比エンタルピーがわかれば計算できる\n吸収冷凍機では，圧縮機を使用せずに，吸収器・発生器(再生器)・溶液ポンプなどを用いて冷媒を循環させ，冷熱を得る\n蒸発温度と凝縮温度などの運転条件が同じでも，理論冷凍サイクルCOPに比べ，実際の装置におけるCOPは小さくなる\n理論ヒートポンプサイクルでは，圧縮機で理論断熱圧縮動力を消費して，この圧縮動力に相当する熱と，蒸発器で取り入れた熱が冷媒に加わって凝縮負荷となり，凝縮器から放出される熱を利用する\n\n\n\n\n\n\n\n\nNoteSolution\n\n\n\n\n\nc, e, g, i, j, k\n\n\n\n\nExercise 3 凝縮器について\n次の記述の内，正しいものを選べ\n\n理論凝縮負荷は冷凍能力に理論断熱圧縮動力を加えて求めることができる\n\n\n\n\n\n\n\n\nNoteSolution\n\n\n\n\n\na,\n\n\n\n\nExercise 4 圧縮機について\n次の記述の内，正しいものを選べ\n\n二段圧縮冷凍装置は，一般に，低段圧縮機から出た冷媒ガスを一度冷却しているので，高段圧縮機の吐出しガスの温度が高くならないこと，また，圧縮機の損失を減らすことができ，圧縮機効率の低下を防ぐことができる．\n理論断熱圧縮動力が同じ場合，圧縮機の全断熱効率が大きくなると，実際の圧縮機の駆動軸動力は小さくなる\n圧縮機から吐出され，凝縮器に入る冷媒蒸気はかなり温度の高い過熱蒸気（高圧）\n蒸発器をでて圧縮機に吸入される冷媒ガスは乾燥飽和蒸気より少し過熱された過熱蒸気（低圧）\n\n\n\n\n\n\n\n\nNoteSolution\n\n\n\n\n\na, b, c, d\n\n\n\n\nExercise 5 \n次の記述のうち，冷媒について正しいものを選べ\n\n冷媒の蒸発潜熱は冷媒の種類関係なく一定である\n同じ温度のもとでは，標準沸点の低い冷媒ほど圧力は高くなる\n蒸気圧縮冷凍装置では，冷媒の蒸発の潜熱を利用して冷却作用を行う\nR 404A は共沸混合冷媒である\n一般に，HFC冷媒は，HCFC冷媒と比べると誘電率が大きく，その電気絶縁性がやや劣る\n一般に，アンモニア冷媒液は冷凍機油より比重が小さく，フルオロカーボン冷媒液は冷凍機油よりも比重が大きい\nフルオロカーボンの冷凍効果はアンモニアに比べ著しく大きいので，冷媒として広く用いられている\nアンモニアの標準沸点はR22の標準沸点より高い\nR134a冷媒は，塩素原子を含む\n装置から漏洩した冷媒ガスは，フルオロカーボンの場合には床面近くに，アンモニアは天井近くに滞留しやすい\n非共沸混合冷媒では，液と蒸気が共存する二相域において，液の組成と蒸気の組成は異なる\n\n\n\n\n\n\n\n\nNoteSolution\n\n\n\n\n\nb, c, e, f, h, j, k\n\n\n\n\nExercise 6 \n冷凍能力 4.5 kWの冷凍装置があり，圧縮機の消費動力は 1.5 kWである．この装置の凝縮器で放出される熱量 [kW] はいくらか．また，この装置の冷凍サイクル成績係数はいくらか？\n\n\n\n\n\n\n\nNoteSolution\n\n\n\n\n\n凝縮器で放出される熱量(凝縮負荷) \\(\\Phi_k\\) は\n\\[\n\\Phi_k = 4.5 \\text{kW}  + 1.5 \\text{kW}= 6 \\text{kW}\n\\]\n成績係数 \\(COP_c\\) は\n\\[\nCOP_c = \\frac{4.5 \\text{kW}}{1.5 \\text{kW}} = 3\n\\]"
  },
  {
    "objectID": "posts/2025-06-11-heatpump-lecture-01/index.html#appendix",
    "href": "posts/2025-06-11-heatpump-lecture-01/index.html#appendix",
    "title": "冷凍サイクルとヒートポンプの基礎",
    "section": "Appendix",
    "text": "Appendix\n\n数値目安\n\n\nCode\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\n\n# read data\ndf = pd.read_csv(\"./r134_property.csv\")\nenthalpy = df['steam_enthalpy'] - df['liquid_enthalpy']\n\n# plot temperature and pressure(mPa)\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(14, 6))\n\n# Set plot background color\nfig.patch.set_facecolor('#EFF5F5')\nfig.suptitle('R-134a Temperature vs Vapor Pressure', fontsize=16) # Overall title\n\nax1.plot(\n    df[\"temperature\"],    # X-axis: Vapor Pressure\n    df[\"Mpa\"],  # Y-axis: Temperature\n    color='black',\n    linestyle='solid', # Equivalent to 'dot' dash in Plotly\n    # marker='o',    # Add markers\n    markersize=4,  # Adjust marker size as desired\n    label='R-134a Vapor Pressure' # Optional: Add a label for legend\n)\n\nax2.plot(\n    df[\"temperature\"],    # X-axis: Vapor Pressure\n    enthalpy,  # Y-axis: kj/kg\n    color='black',\n    linestyle='solid', # Equivalent to 'dot' dash in Plotly\n    # marker='o',    # Add markers\n    markersize=4,  # Adjust marker size as desired\n    label='R-134a Vapor Pressure' # Optional: Add a label for legend\n)\n\n# Set axis 1 titles\nax1.set_title(\"R-134a Temperature vs. Vapor Pressure\")\nax1.set_xlabel(\"Temperature (°C)\")\nax1.set_ylabel(\"Vapor Pressure (Mpa)\")\nax1.grid(True, which='both', color='#DDEEEF', linestyle='-', linewidth=0.5)\nax1.set_axisbelow(True)\n\n# Set axis 2 titles\n# ax2.set_yscale('log')\nax2.grid(True, which='both', color='#DDEEEF', linestyle='-', linewidth=0.5)\nax2.set_axisbelow(True)\nax2.set_xlabel(\"Temperature (°C)\")\nax2.set_ylabel(\"latent heat(kJ/kg)\") # Indicate log scale in label\nax2.set_title(\"Temperature vs Latent heat\")\n\n\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n内部エネルギーとは？\n\nDefinition 4 内部エネルギー\n物体の内部の分子運動による運動エネルギーと，分子間力によるポテンシャルエネルギーを，内部エネルギーと呼ぶ\n\n内部エネルギーは，物体内部の分子の運動エネルギーと分子間力によるポテンシャルエネルギーから構成されます．運動エネルギーを \\(E_k\\), ポテンシャルエネルギーを \\(E_p\\) とすると\n\\[\n\\begin{align}\nU\n  &= \\sum_N(\\text{分子の}E_k) + \\sum_N(\\text{分子間力による}E_p)\\\\\n  &= \\sum_N\\left(\\frac{1}{2}mv^2 + \\epsilon\\right) + \\sum_N(\\text{分子間力による}E_p)\\\\\n  &= \\sum_N\\left(\\frac{1}{2}m\\overline{v}^2 + \\epsilon\\right) + \\sum_N(\\text{分子間力による}E_p)\n\\end{align}\n\\]\n\n\\(\\displaystyle\\frac{1}{2}m\\overline{v}^2\\) は分子1個の並進運動（分子が回転しない運動）の平均運動エネルギー\n\\(\\epsilon\\): 内部運動の運動エネルギー，H₂などの二原子分子やH₂O多原子分子の回転運動，または分子間距離の伸縮による振動運動"
  },
  {
    "objectID": "posts/2025-06-11-heatpump-lecture-01/index.html#references",
    "href": "posts/2025-06-11-heatpump-lecture-01/index.html#references",
    "title": "冷凍サイクルとヒートポンプの基礎",
    "section": "References",
    "text": "References\n\nうるるとさらら Rシリーズカタログ\n熱力学第1法則と第2法則\n高校生から味わう理論物理入門 &gt; 気体の内部エネルギーの意味と公式，求め方"
  },
  {
    "objectID": "posts/2025-07-06-big-op-little-op/index.html",
    "href": "posts/2025-07-06-big-op-little-op/index.html",
    "title": "統計学におけるBig OpとLittle Op",
    "section": "",
    "text": "Definition 1 無限小\n独立変数のある一定の変動に伴って0に収束する変数を無限性という．\n\\[\n\\lim_{x\\to a}f(x) = 0\n\\]\nのとき，\\(f(x)\\) は \\(x\\to a\\) のとき無限小である．\n\n\nExample 1 無限小\n\\[\n\\begin{align}\n\\sin x & \\ \\ \\text{ as } \\ \\ x\\to 0\\\\\n\\sqrt{1-x^2} & \\ \\ \\text{ as } \\ \\ x\\to 1-0\\\\\n\\exp(-x) & \\ \\ \\text{ as } \\ \\ x\\to \\infty\\\\\n\\sqrt{(x-a)^2 + (y-b)^2} & \\ \\ \\text{ as } \\ \\ x\\to a, y\\to b\n\\end{align}\n\\]\n\n\n\n\nDefinition 2 高位・同位の無限小\n\\(\\lim_{x\\to a}f(x) = 0, \\lim_{x\\to a}g(x) = 0\\) とする\n高位の無限小\n\\[\n\\lim_{x\\to a} \\frac{f(x)}{g(x)} = 0\n\\]\nが成り立つとき，\\(f(x)\\) は \\(g(x)\\) より高位の無限小であるという．定義より \\(f(x)\\) は \\(g(x)\\) より速くゼロに近づくことになります．このとき次のように表します\n\\[\nf(x) =  \\omicron(g(x))\n\\]\n同位の無限小\n\\[\n\\lim_{x\\to a} \\frac{f(x)}{g(x)} = \\alpha(\\neq 0)\n\\]\nが成り立つとき，\\(f(x)\\) は \\(g(x)\\) と同位の無限小であるという．\nラージ・オーダー\n\\(|f(x)/g(x)|\\) が \\(a\\) を含むある開集合で有界のとき，次のように表す\n\\[\nf(x) = \\mathcal{O}(g(x))\n\\]\n\\(f(x) = \\omicron(g(x))\\) ならば \\(f(x) = \\mathcal{O}(g(x))\\) です．\n\n\nExample 2 ランダウの記号\n\\[\n\\begin{align}\n\\lim_{x\\to 0}\\frac{x^2}{x} = 0 &\\Longrightarrow x^2 = \\omicron(x) \\ \\ (x \\to 0)\\\\\n\\lim_{x\\to 0}\\frac{x^2 + x^3 + x^4}{x} = 0 &\\Longrightarrow x^2 + x^3 + x^4 = \\omicron(x) \\ \\ (x \\to 0)\\\\\n\\lim_{x\\to 0}\\frac{x + x^2}{x} = 1 &\\Longrightarrow x + x^2 = \\mathcal{O}(x) \\ \\ (x \\to 0)\\\\\n\\lim_{x\\to \\infty}\\frac{\\exp(-x)}{1/x} = 0 &\\Longrightarrow \\exp(-x) = \\omicron(1/x) \\ \\ (x \\to \\infty)\\\\\n\\lim_{x\\to \\infty}\\frac{\\exp(-x)}{1/x^k} = 0 &\\Longrightarrow \\exp(-x) = \\omicron(1/x^k) \\ \\ (x \\to \\infty)\\\\\n\\lim_{x\\to \\infty}\\frac{1 - \\exp(x)}{x} = 1 &\\Longrightarrow 1 - \\exp(x) = \\mathcal{O}(x) \\ \\ (x \\to 0)\n\\end{align}\n\\]\n\n\nExample 3 \\[\nf(x) = \\frac{\\exp(x) - (1 + x)}{x^2}\n\\]\nについて考えてみます．\\(x=0\\) のときは \\(f(x)\\) はそのまま評価できませんが，ロピタルの定理を用いると\n\\[\n\\lim_{x\\to 0}\\frac{\\exp(x) - (1 + x)}{x^2} = \\frac{1}{2}\n\\]\nつまり，\\(\\exp(x) - (1 + x) = \\mathcal{O}(x^2) \\ \\ (x\\to 0)\\) ということになります．Plotlyで確認したのが以下：\n\n\nCode\nimport numpy as np\nimport plotly.graph_objects as go\n\n# Define x values, avoiding x=0 to prevent division by zero\nx = np.linspace(-2, 2, 1000)\nx = x[x != 0]  # remove x=0\n\n# Define the function\ny = (np.exp(x) - (1 + x)) / x**2\n\n# Create the plot\nfig = go.Figure()\n\nfig.add_trace(\n    go.Scatter(\n        x=x, y=y, mode=\"lines\", name=\"(exp(x) - (1 + x)) / x²\", line=dict(color=\"blue\")\n    )\n)\n\n# Optionally add the limit as x -&gt; 0\nfig.add_trace(\n    go.Scatter(\n        x=[0],\n        y=[0.5],  # limit is 0.5\n        mode=\"markers\",\n        name=\"Limit at x=0\",\n        marker=dict(size=8, color=\"red\", symbol=\"circle\"),\n    )\n)\n\n# Customize layout\nfig.update_layout(\n    title=\"Plot of (exp(x) - (1 + x)) / x²\",\n    xaxis_title=\"x\",\n    yaxis_title=\"f(x)\",\n    template=\"plotly_white\",\n    showlegend=True,\n    width=800,\n    height=500,  # &lt;-- Set figure size here\n)\n\nfig.show()\n\n\n                            \n                                            \n\n\n\n\nTheorem 1 正弦関数とラージオーダー\n\\[\nn\\sin(n) = \\mathcal{O}(n) \\, \\ (n\\to\\infty)\n\\]\n\n\n\n\n\n\n\nNoteProof\n\n\n\n\n\n\\(\\sin(n) \\leq 1 \\, \\ \\forall n\\) より \\(n\\sin(n) \\leq n \\, \\ \\forall n\\)．\nつまり，\n\\[\n\\lim_{n\\to \\infty} \\left|\\frac{n\\sin(n)}{n}\\right| \\leq 1\n\\]\n従って，\\(n\\sin(n) = \\mathcal{O}(n) \\, \\ (n\\to\\infty)\\)\n\n\n\n\n\n\n\nDefinition 3  \n\n\\(N = 1, 2, 3, \\cdots\\) として，数列 \\(\\{a_N\\}\\) について \\(N^{-\\lambda}a_N\\) が有界のとき，\\(\\{a_N\\}\\) は \\(\\mathcal{O}(N^\\lambda)\\) であると表記する\n数列 \\(\\{a_N\\}\\) について \\(N^{-\\lambda}a_N \\to 0\\)のとき，\\(\\{a_N\\}\\) は \\(\\omicron(N^\\lambda)\\) であると表記する\n\n\n\n定義より \\(\\lim_{N\\to\\infty} a_N = 0\\) であるならば, \\(a_N = \\omicron(1)\\)\n\\(a_n = \\log(N)\\) であるならば，任意の \\(\\lambda  &gt; 0\\) について \\(a_N = \\omicron(N^\\lambda)\\)\n\\(a_n = 10 +\\sqrt{N}\\) であるならば，\\(a_N = \\mathcal{O}(N^{1/2})\\)\n\\(a_n = 10 +\\sqrt{N}\\) であるならば，任意の \\(\\lambda  &gt; 0\\) について \\(a_N = \\omicron(N^{1/2+\\lambda})\\)"
  },
  {
    "objectID": "posts/2025-07-06-big-op-little-op/index.html#無限小の比較",
    "href": "posts/2025-07-06-big-op-little-op/index.html#無限小の比較",
    "title": "統計学におけるBig OpとLittle Op",
    "section": "",
    "text": "Definition 1 無限小\n独立変数のある一定の変動に伴って0に収束する変数を無限性という．\n\\[\n\\lim_{x\\to a}f(x) = 0\n\\]\nのとき，\\(f(x)\\) は \\(x\\to a\\) のとき無限小である．\n\n\nExample 1 無限小\n\\[\n\\begin{align}\n\\sin x & \\ \\ \\text{ as } \\ \\ x\\to 0\\\\\n\\sqrt{1-x^2} & \\ \\ \\text{ as } \\ \\ x\\to 1-0\\\\\n\\exp(-x) & \\ \\ \\text{ as } \\ \\ x\\to \\infty\\\\\n\\sqrt{(x-a)^2 + (y-b)^2} & \\ \\ \\text{ as } \\ \\ x\\to a, y\\to b\n\\end{align}\n\\]\n\n\n\n\nDefinition 2 高位・同位の無限小\n\\(\\lim_{x\\to a}f(x) = 0, \\lim_{x\\to a}g(x) = 0\\) とする\n高位の無限小\n\\[\n\\lim_{x\\to a} \\frac{f(x)}{g(x)} = 0\n\\]\nが成り立つとき，\\(f(x)\\) は \\(g(x)\\) より高位の無限小であるという．定義より \\(f(x)\\) は \\(g(x)\\) より速くゼロに近づくことになります．このとき次のように表します\n\\[\nf(x) =  \\omicron(g(x))\n\\]\n同位の無限小\n\\[\n\\lim_{x\\to a} \\frac{f(x)}{g(x)} = \\alpha(\\neq 0)\n\\]\nが成り立つとき，\\(f(x)\\) は \\(g(x)\\) と同位の無限小であるという．\nラージ・オーダー\n\\(|f(x)/g(x)|\\) が \\(a\\) を含むある開集合で有界のとき，次のように表す\n\\[\nf(x) = \\mathcal{O}(g(x))\n\\]\n\\(f(x) = \\omicron(g(x))\\) ならば \\(f(x) = \\mathcal{O}(g(x))\\) です．\n\n\nExample 2 ランダウの記号\n\\[\n\\begin{align}\n\\lim_{x\\to 0}\\frac{x^2}{x} = 0 &\\Longrightarrow x^2 = \\omicron(x) \\ \\ (x \\to 0)\\\\\n\\lim_{x\\to 0}\\frac{x^2 + x^3 + x^4}{x} = 0 &\\Longrightarrow x^2 + x^3 + x^4 = \\omicron(x) \\ \\ (x \\to 0)\\\\\n\\lim_{x\\to 0}\\frac{x + x^2}{x} = 1 &\\Longrightarrow x + x^2 = \\mathcal{O}(x) \\ \\ (x \\to 0)\\\\\n\\lim_{x\\to \\infty}\\frac{\\exp(-x)}{1/x} = 0 &\\Longrightarrow \\exp(-x) = \\omicron(1/x) \\ \\ (x \\to \\infty)\\\\\n\\lim_{x\\to \\infty}\\frac{\\exp(-x)}{1/x^k} = 0 &\\Longrightarrow \\exp(-x) = \\omicron(1/x^k) \\ \\ (x \\to \\infty)\\\\\n\\lim_{x\\to \\infty}\\frac{1 - \\exp(x)}{x} = 1 &\\Longrightarrow 1 - \\exp(x) = \\mathcal{O}(x) \\ \\ (x \\to 0)\n\\end{align}\n\\]\n\n\nExample 3 \\[\nf(x) = \\frac{\\exp(x) - (1 + x)}{x^2}\n\\]\nについて考えてみます．\\(x=0\\) のときは \\(f(x)\\) はそのまま評価できませんが，ロピタルの定理を用いると\n\\[\n\\lim_{x\\to 0}\\frac{\\exp(x) - (1 + x)}{x^2} = \\frac{1}{2}\n\\]\nつまり，\\(\\exp(x) - (1 + x) = \\mathcal{O}(x^2) \\ \\ (x\\to 0)\\) ということになります．Plotlyで確認したのが以下：\n\n\nCode\nimport numpy as np\nimport plotly.graph_objects as go\n\n# Define x values, avoiding x=0 to prevent division by zero\nx = np.linspace(-2, 2, 1000)\nx = x[x != 0]  # remove x=0\n\n# Define the function\ny = (np.exp(x) - (1 + x)) / x**2\n\n# Create the plot\nfig = go.Figure()\n\nfig.add_trace(\n    go.Scatter(\n        x=x, y=y, mode=\"lines\", name=\"(exp(x) - (1 + x)) / x²\", line=dict(color=\"blue\")\n    )\n)\n\n# Optionally add the limit as x -&gt; 0\nfig.add_trace(\n    go.Scatter(\n        x=[0],\n        y=[0.5],  # limit is 0.5\n        mode=\"markers\",\n        name=\"Limit at x=0\",\n        marker=dict(size=8, color=\"red\", symbol=\"circle\"),\n    )\n)\n\n# Customize layout\nfig.update_layout(\n    title=\"Plot of (exp(x) - (1 + x)) / x²\",\n    xaxis_title=\"x\",\n    yaxis_title=\"f(x)\",\n    template=\"plotly_white\",\n    showlegend=True,\n    width=800,\n    height=500,  # &lt;-- Set figure size here\n)\n\nfig.show()\n\n\n                            \n                                            \n\n\n\n\nTheorem 1 正弦関数とラージオーダー\n\\[\nn\\sin(n) = \\mathcal{O}(n) \\, \\ (n\\to\\infty)\n\\]\n\n\n\n\n\n\n\nNoteProof\n\n\n\n\n\n\\(\\sin(n) \\leq 1 \\, \\ \\forall n\\) より \\(n\\sin(n) \\leq n \\, \\ \\forall n\\)．\nつまり，\n\\[\n\\lim_{n\\to \\infty} \\left|\\frac{n\\sin(n)}{n}\\right| \\leq 1\n\\]\n従って，\\(n\\sin(n) = \\mathcal{O}(n) \\, \\ (n\\to\\infty)\\)\n\n\n\n\n\n\n\nDefinition 3  \n\n\\(N = 1, 2, 3, \\cdots\\) として，数列 \\(\\{a_N\\}\\) について \\(N^{-\\lambda}a_N\\) が有界のとき，\\(\\{a_N\\}\\) は \\(\\mathcal{O}(N^\\lambda)\\) であると表記する\n数列 \\(\\{a_N\\}\\) について \\(N^{-\\lambda}a_N \\to 0\\)のとき，\\(\\{a_N\\}\\) は \\(\\omicron(N^\\lambda)\\) であると表記する\n\n\n\n定義より \\(\\lim_{N\\to\\infty} a_N = 0\\) であるならば, \\(a_N = \\omicron(1)\\)\n\\(a_n = \\log(N)\\) であるならば，任意の \\(\\lambda  &gt; 0\\) について \\(a_N = \\omicron(N^\\lambda)\\)\n\\(a_n = 10 +\\sqrt{N}\\) であるならば，\\(a_N = \\mathcal{O}(N^{1/2})\\)\n\\(a_n = 10 +\\sqrt{N}\\) であるならば，任意の \\(\\lambda  &gt; 0\\) について \\(a_N = \\omicron(N^{1/2+\\lambda})\\)"
  },
  {
    "objectID": "posts/2025-07-06-big-op-little-op/index.html#big-opとlittle-op",
    "href": "posts/2025-07-06-big-op-little-op/index.html#big-opとlittle-op",
    "title": "統計学におけるBig OpとLittle Op",
    "section": "Big OpとLittle Op",
    "text": "Big OpとLittle Op\nBig OpとLittle Opは，ある確率変数が（ある上限やゼロに）どのように収束するかの表記表現です．\n\nDefinition 4 probability limitとLittle Op\n確率変数列 \\(\\{x_N\\}\\) が定数 \\(a\\) に確率収束するとは, 任意の \\(\\epsilon &gt;0\\) に対して\n\\[\nP[|x_N - a|&gt;\\epsilon] \\to 0 \\  \\ \\text{as } \\  \\ N \\to \\infty\n\\]\nが成立することである．これを以下のように表記する\n\\[\n\\begin{align}\nx_N & \\overset{p}{\\to}a\\\\\n\\mathrm{plim}\\,\\ x_N &= a\n\\end{align}\n\\]\nとくに，\\(a = 0\\) のとき，\n\\[\nx_n = \\omicron_p(1)\n\\]\nと表記する．\n\n確率収束は次のようにリフレーズすることができます:\n\\[\n\\forall \\epsilon &gt;0, \\forall \\delta &gt;0 , \\exists n_0 \\in \\mathbb N [n\\geq n_0 \\Rightarrow P(|X_n - \\alpha| &gt; \\epsilon) &lt; \\delta]\n\\]\n\n\\(\\epsilon\\): accuracy level\n\\(\\delta\\): confidence level\n任意に与えられたaccuracyとconfidenceの水準に対して，\\(n\\) が十分大きければ \\(X_n\\) は指定した精度と信頼度の範囲内で \\(\\alpha\\) に等しくなる\n確率収束は \\(N\\) が十分大きければ \\(X_N\\) は \\(\\alpha\\) 近傍にほぼ確実に存在すると解釈できる\n\n\nExample 4 \n\\(X_1, \\cdots, X_n, \\cdots\\) を互いに独立な確率変数として，それらの確率関数を\n\\[\nX_n = \\left\\{\\begin{array}{c}\n0 & \\text{with probability} \\ \\ 1 - \\frac{1}{n}\\\\\nn & \\text{with probability} \\ \\ \\frac{1}{n}\n\\end{array}\\right.\n\\]\nとします．このとき，\n\\[\nP[|X_n| &gt; \\epsilon] = P[X_n &gt; \\epsilon] = \\frac{1}{n} \\to 0 \\  \\ (n\\to \\infty)\n\\]\nであるので，\\(X_n\\) は0に確率収束 \\(X_n = \\omicron_p(1)\\) することがわかります．\n\n\n確率収束と二乗収束\n確率変数 \\(X_n\\) が二乗収束するとします．つまり，\n\\[\n\\lim_{n\\to N}\\mathbb E[(X_n - X)^2] = 0\n\\]\n\\(X_n\\) が確率収束するならば，確率収束の定義とマルコフ不等式より\n\\[\n\\begin{align}\nP[|X_n - X| &gt; \\epsilon]\n  &= P[(X_n - X)^2 &gt; \\epsilon^2]\\\\\n  &\\leq \\frac{E[(X_n - X)^2]}{\\epsilon^2}\n\\end{align}\n\\]\n従って，\\(X_n\\overset{m.s.}{\\to} X \\Longrightarrow X_n\\overset{p}{\\to} X\\) が成立します． 一方，逆は成立しません．\nExample 4 は確率収束の例でしたが，\n\\[\n\\begin{align}\nE[(X_n)^2] = \\frac{1}{n}n^2 = n \\to\\infty \\text{ as } \\ \\ n\\to\\infty\n\\end{align}\n\\]\n\n\n\n\n\n\nNote統計学における収束の関係性\n\n\n\n\n\n\n\n\ngraph LR\n  A[Almost Sure Convergence] --&gt; B[Convergence in Probability]\n  B --&gt; C[Convergence in Distribution]\n  D[Lᵖ Convergence] --&gt; B\n\n\n\n\n\n\n\n\n\nDefinition 5 Big Op\n確率変数列 \\(\\{x_N\\}\\) が bounded in probability であるとは，任意の \\(\\epsilon &gt;0\\) について，\n\\[\n\\exists b_\\epsilon &gt; 0, N_\\epsilon \\Longrightarrow P(|x_N| \\geq b_\\epsilon) &lt; \\epsilon \\, \\ \\forall N\\geq N_{\\epsilon}\n\\]\nが成立することである．これを \\(x_N = \\mathcal{O}_p(1)\\) と表記する．\n\nスモールオーダーとラージオーダーとOp\n\\(C_N\\) を非確率変数数列とします．このとき，\n\\[\n\\begin{align}\nC_N = \\mathcal{O}_p(1) \\  \\ & \\text{if and only if} \\  \\ C_N = \\mathcal{O}(1)\\\\\nC_N = \\omicron_p(1) \\  \\ & \\text{if and only if} \\  \\ C_N = \\omicron(1)\n\\end{align}\n\\]\n\nTheorem 2 Probability limit and Big Op\n\\(x_N \\overset{p}{\\to} a\\) が成立するならば \\(x_N = \\mathcal{O}_p(1)\\)\n\n\n\n\n\n\n\nNoteProof\n\n\n\n\n\n\\(x_N \\overset{p}{\\to} a\\) より\n\\[\n\\forall \\epsilon, \\delta &gt; 0, \\exists N_\\epsilon, N \\geq N_\\epsilon\\Rightarrow P(|x_N - \\alpha| &gt; \\delta) &lt; \\epsilon\n\\]\n次に \\(|X_n|\\) について考えると\n\\[\n\\begin{align}\n&|X_n| = |X_n - \\alpha + \\alpha| \\leq |X_n - \\alpha| + |\\alpha| \\because{三角不等式}\\\\\n&\\Rightarrow |X_n| - |\\alpha| \\leq |X_n - \\alpha|\n\\end{align}\n\\]\n従って，\\(\\forall \\epsilon, \\delta &gt; 0, \\exists N_\\epsilon, N \\geq N_\\epsilon\\) について\n\\[\n\\begin{align}\n&P(|x_N - \\alpha| &gt; \\delta) &lt; \\epsilon\\\\\n&\\Rightarrow P(|X_n| - |\\alpha| &gt; \\delta) &lt; \\epsilon\\\\\n&\\Rightarrow P(|X_n| &gt; |\\alpha| + \\delta) &lt; \\epsilon\n\\end{align}\n\\]\n任意の \\(\\delta &gt; 0\\) について成立するので，\\(b_\\epsilon = |\\alpha| + 1\\) とすれば \\(X_n=\\mathcal{O}_p(1)\\) が成立する．\n\n\n\n\nDefinition 6 確率収束オーダー\n\n確率変数列 \\(X_N\\) と非確率変数列 \\(a_N &gt;0\\) について \\(X_N/a_N = \\omicron_p(1)\\) であるとき，\\(X_n = \\omicron_p(a_N)\\) であるという\n確率変数列 \\(X_N\\) と非確率変数列 \\(a_N &gt;0\\) について \\(X_N/a_N = \\mathcal{O}_p(1)\\) であるとき，\\(X_n = \\mathcal{O}_p(a_N)\\) であるという\n\n\nDefinition 6 より，確率変数列 \\(x_n = \\omicron_p(N^\\delta)\\), \\(\\delta \\in\\mathbb R\\) とき，\n\\[\n\\begin{align}\nN^{-\\delta}x_n \\overset{p}{\\to}0\n\\end{align}\n\\]\nとなります．\n\n\n\n\n\n\nNote\n\n\n\nTheorem 2 を用いると，\\(X_N = \\omicron_p(a_n)\\) が成立するならば \\(\\mathcal{O}_p(a_n)\\) が成立します．\n\n\n\nExample 5 \n\\(z\\) を確率変数としたとき，\\(x_N \\equiv \\sqrt{N}z\\) とていぎします．このとき，以下が成立します\n\\[\n\\begin{align}\nx_n &= \\mathcal{O}_p(N^{1/2})\\\\\nx_n &= \\omicron_p(N^{\\delta}) \\  \\ \\forall \\delta &gt; \\frac{1}{2}\n\\end{align}\n\\]\n\n\n\n\n\n\n\nNoteProperty\n\n\n\n\\[\n\\begin{align}\n\\omicron_p(1) + \\omicron_p(1) &= \\omicron_p(1) \\because{\\text{Continuous Mapping Theorem}}\\\\\n\\mathcal{O}_p(1) + \\omicron_p(1) &= \\mathcal{O}_p(1)\\\\\n\\mathcal{O}_p(1)\\omicron_p(1) &=\\omicron_p(1)\\\\\nR_n\\times\\omicron_p(1) &= \\omicron_p(R_n)\n\\end{align}\n\\]\n\n\n\nExample 6 sum of \\(\\omicron_p(1)\\) not necessarily equals \\(\\omicron_p(1)\\)\n\\(X_{ni} = \\frac{1}{n}\\) という確率変数を考えます．\n定義より\n\\[\n\\operatorname{plim} X_{ni} = 0\n\\]\nつまり，\\(X_{ni} = \\omicron_p(1)\\) です．ここで\n\\[\nY_n = \\frac{1}{n}\\sum_{i=1}^nX_{ni}\n\\]\nを考えます．このとき，\n\\[\n\\begin{align}\nY_n\n  &= \\frac{1}{n}\\sum_{i=1}^nX_{ni}\\\\\n  &= \\frac{n(n+1)}{2n^{2}}\\\\\n  &\\to \\frac{1}{2}\n\\end{align}\n\\]\n従って，\\(Y_n \\neq \\omicron_p(1)\\) となります．\n\n\n上記の Example 6 の関連として \\(n\\) 応じて大きくなる \\(M(N)\\) 個(例として \\(M(N) = \\frac{N}{2}\\))の \\(X_{ni}\\) の合計でも考えることができます．\\(X_{ni} = 1\\) を考えると， \\(X_{ni} = \\mathcal{O}_p(1)\\) は自明ですが\n\\[\n\\sum_{i=1}^{M(N)}X_{ni} = \\sum_{i=1}^{M(N)}1 = M(N)\\to \\infty\n\\]\nまた，\\(X_{ni} = 1/n\\) を考えると，\\(X_{ni} = \\omicron_p(1)\\) は自明ですが\n\\[\n\\sum_{i=1}^{M(N)}X_{ni} = \\sum_{i=1}^{M(N)}\\frac{1}{N} = \\frac{M(N)}{N}\n\\]\nとなり，\\(M(N) = \\frac{N}{2}\\) であるならば \\(\\frac{1}{2}\\) に収束してしまい，\\(\\sum_{i=1}^{M(N)}X_{ni}\\neq \\omicron_p(1)\\) となってしまいます．\n\n収束レート\n\n\n\n\n\n\n\n\n\n表記\nゼロへの収束速度\n説明\n\n\n\n\n\\(\\mathcal{O}_p(1)\\)\n遅い\n確率的に有界だが、ゼロに収束とは限らない\n\n\n\\(\\mathcal{O}_p(1/\\log(n))\\)\nちょっと速い\nゼロに \\(\\log(n)\\) の速さで近づく\n\n\n\\(\\mathcal{O}_p(1/\\sqrt(n))\\)\nもうちょっと速い\nゼロに \\(\\sqrt(n)\\) の速さで近づく\n\n\n\\(\\mathcal{O}_p(1/n)\\)\n速い\nゼロに \\(n\\) の速さで近づく\n\n\n\\(\\mathcal{O}_p(1/n^2)\\)\nもっと速い\n\\(n^2\\) の速さでゼロに近づく\n\n\n\n\n２つのレートを考えます\n\\[\n\\begin{align}\nR^{(1)} &= \\frac{1}{n^{1/2}}\\\\\nR^{(2)} &= \\frac{1}{n^{1/3}}\n\\end{align}\n\\]\nそして，ある確率変数 \\(Y_n = \\omicron_p(1)\\) とします．ここで，次のように変数を定義します\n\\[\n\\begin{align}\nX_n^{(1)} &= \\frac{1}{n^{1/2}}Y_n = \\omicron_p(R^{(1)})\\\\\nX_n^{(2)} &= \\frac{1}{n^{1/3}}Y_n = \\omicron_p(R^{(2)})\n\\end{align}\n\\]\nこのとき，\\(n\\to\\infty\\) における各 \\(Y_n\\) の値を所与とすると，\\(X_n^{(2)}\\) の方が \\(X_n^{(1)}\\) よりも大きくなります． つまり，\\(X_n^{(1)}\\) の方が確率的にゼロへ速く収束します．\n\n\n\n\n\n\nNote次元の呪い\n\n\n\n\\(d\\) 次元確率ベクトル \\(\\pmb{X}_i\\) の密度関数 \\(f(\\pmb{x})\\) を多変量カーネル推定量を用いて推定する場合を考えます．\n\\[\n\\hat{f}(\\pmb{x}) \\frac{1}{|\\pmb{H}|}\\sum_{i=1}^nK(\\pmb{H}^{-1}(\\pmb{X}_i - \\pmb{x}))\n\\]\n多変量カーネルのAMISE(Asymptotic Mean Integrated Squared Error)は\n\\[\n\\operatorname{AMISE}(\\hat{f}(\\pmb{x})) = \\omicron_p(n^{-4/(d+4)})\n\\]\nとなりますが，\n\n\\(d=1\\) のときは \\(n^{-4/5}\\) の速さで0に収束\n\\(d=2\\) のときは \\(n^{-2/3}\\) の速さで0に収束\n\\(d=3\\) のときは \\(n^{-4/7}\\) の速さで0に収束\n\nと \\(d\\) が大きくなるについて遅くなります．これを次元の呪い(curse of dimensionality)と呼びます．\n\n\n\nExample 7 \n\\(X_n \\sim N(0, n)\\) という確率変数を考えます．変数変換を行うと\n\\[\n\\frac{X_n}{\\sqrt{n}}\\sim N(0, 1)\n\\]\n標準正規分布の性質より \\(Z\\sim N(0, 1)\\) のとき，任意の \\(\\epsilon &gt; 0\\) について \\(P(|Z| &gt; M) &lt; \\epsilon\\) を満たすような \\(M\\) が存在するので\n\\[\nX_n = \\mathcal{O}_p(\\sqrt{n})\n\\]\n上記より \\(X_n\\) はBig OpとLittle Opの関係より \\(X_n = \\omicron_p(n)\\) であることはわかりますが，ちゃんと確認してみたいと思います．\n\\[\n\\begin{align}\n\\frac{X_n}{n}\\sim N\\left(0, \\frac{1}{n}\\right)\n\\end{align}\n\\]\n\\(\\alpha \\sim N\\left(0, \\frac{1}{n}\\right)\\) とすると，\n\\[\n\\begin{align}\nP(|\\alpha| &gt; \\epsilon)\n  &= P(\\frac{1}{\\sqrt{n}}|Z| &gt; \\epsilon)\\\\\n  &=  P(|Z| &gt; \\sqrt{n}\\epsilon)\\\\\n  &\\overset{p}{\\to}0\n\\end{align}\n\\]\n従って，\\(X_n = \\omicron_p(n)\\) が示せました．\n\n\n\nrate of convergence: mean vs median\n正規分布に従う確率変数 \\(X_i \\sim N(\\theta, \\sigma^2)\\) について考えます．\n\n\\(\\overline{X}_N\\): sample mean\n\\(\\hat M_N\\): sample median, \\(\\hat M_N = \\operatorname{Med}(X_1, \\cdots, X_N)\\)\n\nとすると，それぞれの漸近分布は\n\\[\n\\begin{align}\n\\overline{X}_N &\\sim N\\left(\\theta, \\frac{\\sigma^2}{N}\\right)\\\\\n\\hat M_N &\\sim N\\left(\\theta, \\frac{\\pi\\sigma^2}{2N}\\right)\n\\end{align}\n\\]\n収束スピードイメージの確認\n\nsample meanのほうがsample medianと比べてより効率的と一見見える（分散が小さい）\n\\(\\theta\\) を中心に分布している = unbiased\n\\(n\\) が大きくなるにつれて，\\(x = \\theta\\) のprobability densityが大きくなっている = consistency\n\n\n\nCode\nimport numpy as np\nimport pandas as pd\nimport plotly.express as px\n\n\n# サンプル平均・中央値を1000回計算\ndef rep_sample(N, reps=1000):\n    data = {\"N\": [], \"Estimator\": [], \"estimate\": []}\n    for _ in range(reps):\n        sample = np.random.normal(loc=0, scale=1, size=N)\n        data[\"N\"].append(N)\n        data[\"Estimator\"].append(\"Mean\")\n        data[\"estimate\"].append(np.mean(sample))\n        data[\"N\"].append(N)\n        data[\"Estimator\"].append(\"Median\")\n        data[\"estimate\"].append(np.median(sample))\n    return pd.DataFrame(data)\n\n\n# サンプルサイズのリスト\nnp.random.seed(89)\nNs = [5] + list(range(50, 251, 50))\ndf_all = pd.concat([rep_sample(N) for N in Ns], ignore_index=True)\n\n# Plotlyでヒストグラム描画（facet by N）\nfig = px.histogram(\n    df_all,\n    x=\"estimate\",\n    color=\"Estimator\",\n    facet_col=\"N\",\n    facet_col_wrap=2,\n    histnorm=\"probability density\",  # Rと同様の密度\n    opacity=0.6,\n    nbins=50,\n    labels={\"estimate\": \"Value\", \"N\": \"Sample Size\"},\n)\n\n# オーバーレイ + サイズ変更\nfig.update_layout(\n    barmode=\"overlay\",  # オーバーレイ表示\n    bargap=0.1,\n    width=1000,  # ← 横幅（px）\n    height=800,  # ← 高さ（px）\n    legend=dict(orientation=\"h\", y=-0.1),\n    title=dict(\n        text=\"Sampling Distributions of Mean vs Median by Sample Size (Overlayed)\",\n        y=0.95,  # ← タイトルをより上に配置\n        x=0.5,  # 中央に配置（オプション）\n        xanchor=\"center\",\n        yanchor=\"bottom\",\n    ),\n)\n\nfig.update_layout(\n    margin=dict(t=100),  # 上側余白を増やす\n    title_font_size=20\n)\n\n# ラベルの整形（例: \"N=50\" → \"N = 50\"）\nfig.for_each_annotation(lambda a: a.update(text=a.text.replace(\"N=\", \"N = \")))\n\nfig.show()\n\n\n                            \n                                            \n\n\nOp表記を用いた収束レートの確認\nOp表記を用いてsample meanとsample medianの収束レートを確認してみます．まず，以下のような変換を実施します\n\\[\n\\begin{aligned}\n\\psi_\\text{Mean} &= \\hat{\\theta} - \\theta \\\\\n&= \\mathcal{N}(\\theta, \\frac{\\sigma^2}{N}) - \\mathcal{N}(\\theta,0) \\\\\n&= \\mathcal{N}(0,\\frac{\\sigma^2}{N})\\\\\n&= \\frac{1}{\\sqrt{N}}\\mathcal{N}(0,\\sigma^2)\n\\end{aligned}\n\\]\n\\[\n\\begin{aligned}\n\\psi_\\text{Med.} &= \\mathcal{N}(\\theta, \\frac{\\pi\\sigma^2}{2N}) - \\mathcal{N}(\\theta,0)  \\\\\n& = \\mathcal{N}(0, \\frac{\\pi\\sigma^2}{2N})\\\\\n&= \\frac{\\sqrt{\\pi}}{\\sqrt{2N}}\\mathcal{N}(0,\\sigma^2)\n\\end{aligned}\n\\]\n従って，\n\\[\n\\begin{align}\n\\psi_\\text{Mean} = \\mathcal{O}_p\\left(\\frac{1}{\\sqrt{N}}\\right).\\\\\n\\psi_\\text{Med.} = \\mathcal{O}_p\\left(\\frac{\\pi}{\\sqrt{2N}}\\right).\n\\end{align}\n\\]\n\\(\\frac{1}{\\sqrt{N}} &lt; \\frac{\\pi}{\\sqrt{2N}}\\) であるので，sample medianのほうが収束レートが遅いことがわかります．\n\n\nCode\nimport numpy as np\nimport pandas as pd\nimport plotly.express as px\n\n# Nの範囲を定義（0.01 から 100、ステップ 0.01）\nN = np.arange(0.01, 100.01, 0.01)\n\n# 平均と中央値の収束速度\nmean_convergence = 1 / np.sqrt(N)\nmedian_convergence = np.sqrt(np.pi) / np.sqrt(2 * N)\n\n# データフレームに変換して tidy 形式に変換\ndf = pd.DataFrame({\n    \"N\": N,\n    \"Mean\": mean_convergence,\n    \"Median\": median_convergence\n})\ndf_melted = df.melt(id_vars=\"N\", var_name=\"Estimator\", value_name=\"Rate\")\n\n# Plotly で線グラフ描画\nfig = px.line(df_melted, x=\"N\", y=\"Rate\", color=\"Estimator\",\n              title=\"Asymptotic Convergence Rate: Mean vs Median\",\n              labels={\"Rate\": \"Convergence Rate\", \"N\": \"Sample Size\"})\n\nfig.update_layout(\n    yaxis=dict(range=[0, 1]),\n    legend=dict(orientation=\"h\", y=-0.2)\n)\n\nfig.show()"
  },
  {
    "objectID": "posts/2025-07-06-big-op-little-op/index.html#appendix-連続確率分布における中央値の漸近分布",
    "href": "posts/2025-07-06-big-op-little-op/index.html#appendix-連続確率分布における中央値の漸近分布",
    "title": "統計学におけるBig OpとLittle Op",
    "section": "Appendix: 連続確率分布における中央値の漸近分布",
    "text": "Appendix: 連続確率分布における中央値の漸近分布\n連続確率分布に従う \\(\\{X_1, \\cdots, X_n\\} \\overset{\\mathrm{iid}}{\\sim} F\\) を考えます．\n\nCDF: \\(F_X(x) = P(X_i \\leq x)\\)\ninverse CDF: \\(F^{-1}_X(t)\\)\npdf: \\(f_X(x) = F^\\prime_X(x)\\)\nBernoulli r.v.: \\(Z_i(x) \\equiv I\\{X_i \\leq x\\}\\)\n\n\\(Z_i\\) についてはBernoulli r.v. であるので\n\\[\n\\begin{gather}\n\\mathbb E(Z_i(x)) =  \\mathbb E\\left(I\\{X_i\\le x\\}\\right) = P(X_i\\le x)=F_X(x)\\\\\n\\operatorname{Var}(Z_i(x)) = F_X(x)[1-F_X(x)]\n\\end{gather}\n\\]\n次に \\(Z_i((x))\\) のsample meanの変数として \\(Y_n(x)\\) を以下のように定義します\n\\[\nY_n(x) = \\frac{1}{n}\\sum_{i=1}^nZ_i(x) = \\hat F_n(x)\n\\]\n\n\\(\\hat F_n(x)\\): 経験分布関数\n\nこのとき，\n\\[\n\\begin{align}\n\\mathbb E[Y_n(x)] &= F_X(x)\\\\\n\\operatorname{Var}(Y_n(x)) &= \\frac{1}{n}F_X(x)[1-F_X(x)]\n\\end{align}\n\\]\nここで，CLTを用いると\n\\[\n\\begin{align}\n\\sqrt n\\Big(Y_n(x) - F_X(x)\\Big)\n  &= \\sqrt n\\Big(\\hat F_X(x) - F_X(x)\\Big)\\\\\n  &\\overset{d}{\\rightarrow} N\\left(0,F_X(x)[1-F_X(x)]\\right)\n\\end{align}\n\\]\n\\(F^{-1}_X(\\cdot)\\) という変数変換とDelta methodを組み合わせると\n\\[\n\\sqrt n\\Big(F^{-1}_X(\\hat F_n(x)) - F^{-1}_X(F_X(x))\\Big) \\overset{d}{\\rightarrow} N\\left(0,\\frac {F_X(x)[1-F_X(x)]}{\\left[f_x\\left(F^{-1}_X(F_X(x))\\right)\\right]^2} \\right)\n\\]\ntrue median \\(x = m\\) で評価すると\n\\[\n\\sqrt n\\Big(F^{-1}_X(\\hat F_n(m)) - m\\Big) \\overset{d}{\\rightarrow} N\\left(0,\\frac {1}{\\left[2f_x(m)\\right]^2} \\right)\n\\]\n\\(F^{-1}_X(\\hat F_n(m))\\) は sample median \\(\\hat m\\) に収束するので\n\\[\n\\sqrt n\\Big(\\hat m - m\\Big)\\overset{d}{\\rightarrow} N\\left(0,\\frac {1}{\\left[2f_x(m)\\right]^2} \\right)\n\\]\n正規分布 \\(X_i\\sim N(0, \\sigma^2)\\) の場合を考えると\n\\[\n\\sqrt n\\Big(\\hat m - m\\Big)\\overset{d}{\\rightarrow} N\\left(0,\\frac {\\pi\\sigma^2}{2} \\right)\n\\]"
  },
  {
    "objectID": "posts/2025-07-06-big-op-little-op/index.html#references",
    "href": "posts/2025-07-06-big-op-little-op/index.html#references",
    "title": "統計学におけるBig OpとLittle Op",
    "section": "References",
    "text": "References\n\nEconometric Analysis of Cross Section and Panel Data, 2010 &gt; Ch3. Basic Asymptotitc Theory p37\nIntroduction to Probability, Dimitri P. Bertsekas and John N. Tsitsiklis\nMa, Y., Genton, M. G., & Parzen, E. (2011). Asymptotic properties of sample quantiles of discrete distributions. Annals of the Institute of Statistical Mathematics, 63(2), 227-243.\nStatistics for Regression Monkeys &gt; マルコフ不等式"
  },
  {
    "objectID": "posts/2025-05-23-what-to-write-in-wiki/index.html",
    "href": "posts/2025-05-23-what-to-write-in-wiki/index.html",
    "title": "wikiにどのような情報をどのように残すか？",
    "section": "",
    "text": "NoteKey Takeaways\n\n\n\n\n\n\nWiki は，みんなが自由に編集できる Web サイト\n書かないよりかは書く！\n慣れてきたら，ストック情報を意識して何をWikiに記載すべきか判断する\nメタデータ（タイトル，作成者，更新日，タグ，関連資料など）を活用することで，情報の検索性・管理性・再利用性が向上する"
  },
  {
    "objectID": "posts/2025-05-23-what-to-write-in-wiki/index.html#projectと情報共有の課題",
    "href": "posts/2025-05-23-what-to-write-in-wiki/index.html#projectと情報共有の課題",
    "title": "wikiにどのような情報をどのように残すか？",
    "section": "1. Projectと情報共有の課題",
    "text": "1. Projectと情報共有の課題\n仕事の中で情報共有の課題はしばしば発生します．その発生の仕方は以下の２つが代表例としてあります．\n課題1：必要な情報が共有されていない\n\n\n\n\n\n\n\n\n事象\n問題分類\n\n\n\n\n退職・異動時に「前任者しか知らないこと」が多く，後任が混乱\n属人化問題\n\n\n同じ業務でも人によってやり方がバラバラ（手順の標準化がされていない）\nナレッジの一元化できてない問題\n\n\n毎回「この件ってどうやるんでしたっけ？」という質問が発生する\n非効率なコミュニケーション\n\n\n\n\n\n課題2：必要な情報を見つけるのが難しい\n\n\n\n\n\n\n\n\n事象\n問題分類\n\n\n\n\n手順書は共有フォルダ，仕様はメール，背景はSlack…とバラバラ\n情報の散逸問題\n\n\n検索しても古いバージョンや関係ない資料が出てきて混乱\n情報の最新化・正確性問題"
  },
  {
    "objectID": "posts/2025-05-23-what-to-write-in-wiki/index.html#projectにおけるwiki",
    "href": "posts/2025-05-23-what-to-write-in-wiki/index.html#projectにおけるwiki",
    "title": "wikiにどのような情報をどのように残すか？",
    "section": "2. ProjectにおけるWiki",
    "text": "2. ProjectにおけるWiki\n\nDefinition 1 Wiki \nプロジェクトやチームの知識・ノウハウ・手順・ルールなどを，誰でも編集・追加できる形で蓄積・共有するためのドキュメントシステムのことをWikiと呼ぶ．\n\nWikiは，単なるメモやドキュメントの集積ではなく，以下のような効果を持ったプロジェクトの「知識のインフラ」として機能します．\n\nナレッジの一元化\n属人化の防止\nコミュニケーションの効率化\n\n\n\nナレッジの一元化\n\n\nナレッジの一元化とは，プロジェクトやチームに関する情報・ノウハウ・手順・ルールなどを，分散せずに一箇所（Wikiなど）に集約して管理することを指します．これにより，以下のようなメリットがあります。\n\n情報の散逸防止\n\n口頭や個人メモ，チャットログなどに分散しがちな情報を，Wikiにまとめることで「どこに何が書いてあるか分からない」「必要な情報が見つからない」といった事態を防げます\n\n情報の最新化・正確性の維持\n\n仕様変更や新しい知見が得られた際，Wikiを更新するだけで全員が最新情報を参照でき，古い情報によるミスや認識ズレを防止できます\n\n\n\n\n属人化の防止\n\n\n属人化とは，特定の業務やノウハウが一部の人だけに依存し，その人がいないと作業が進まない・問題が解決できない状態を指します．Wikiは以下の観点からこの属人化を防ぐための有効なツールです．\n\n情報の共有・可視化\n\n業務手順やトラブル対応，設定方法などをWikiに記録することで，誰でも同じ情報にアクセスできるようになります\nこれにより，担当者が不在でも他のメンバーが対応可能となり，業務の停滞を防げます\n\nノウハウの蓄積と継承\n\n経験者が持つ暗黙知やコツを明文化してWikiに残すことで，後任者や新メンバーへのスムーズな引き継ぎが可能になります\n\nチーム全体のスキル底上げ\n\n皆がWikiを活用・更新することで，チーム全体の知識レベルが向上し，特定の人に依存しない強い組織づくりにつながります\n\n\n\n\nコミュニケーションの効率化\n\n\nコミュニケーションの非効率とは，情報が構造化されていないことや，一元管理されていないによって発生する無駄な時間のことです．例として以下のようなものがあります\n\n\n\n\n\n\n\n\n課題・現象\nコスト分類\n\n\n\n\n毎回同じ質問が繰り返される\n説明コスト\n\n\n情報が人によってバラバラで食い違う\n認識齟齬コスト\n\n\n確認・共有・引き継ぎに時間がかかる\n説明コスト・情報探索コスト\n\n\nメールやチャットを遡らないと情報が見つからない\n情報探索コスト\n\n\n\n\nWikiを活用することで上記のような「説明コスト」「認識齟齬コスト」「情報探索コスト」を以下のような機序で削減することができます\n\n説明コストの削減\n\nよくある質問や手順，ルールなどをWikiにまとめておくことで，同じ内容を何度も口頭やチャットで説明する必要がなくなります\n新メンバーや他部署からの問い合わせにも「Wikiを参照してください」と非同期コミュニケーションの案内でき，対応コストを大幅に削減できます\n仕様や方針，過去の議論の経緯などをWikiに記録しておくことで，議論のたびに一から説明したり，過去の経緯を探す手間が省けます\n\n認識齟齬コストの低減\n\nWikiに記載された内容は誰でも同じものを参照できるため，伝言ゲームによる情報のズレや誤解を防げます\n\n情報探索コストの低減\n\n業務に必要な情報（手順・FAQ・ルール・用語解説など）を構造的に蓄積・整理することで，情報の「どこにあるか」「最新版はどれか」を探す時間を減らすことができます"
  },
  {
    "objectID": "posts/2025-05-23-what-to-write-in-wiki/index.html#wikiに書くべき情報",
    "href": "posts/2025-05-23-what-to-write-in-wiki/index.html#wikiに書くべき情報",
    "title": "wikiにどのような情報をどのように残すか？",
    "section": "3. Wikiに書くべき情報",
    "text": "3. Wikiに書くべき情報\nWikiには情報を多く残せば残すほど基本的に良いですが，「フロー」と「ストック」という観点で情報を事前に整理することがより良いwikiへと繋がります．Wikiはストック型の情報を蓄積する場所であるので，「これはストック化すべき情報だ」と事前に分類・判断して整理する必要があります．\n\n\nフロー情報\n\n\n\n時系列に流れていく情報\n生まれた直後は価値が高く，時間やプロジェクト進行の経過と共に価値が下がっていく\n例: Slackやメールでのやり取り，日報・会議メモなど\n\n\nストック情報\n\n\n\n長期的に価値があり，何度も参照される情報\n例: マニュアルや設計書，仕様書など\n\n\n「フローとストックの区別」と良いWiki\n\n\n「フローとストックの区別」の視点を持つことで，以下のようなメリットがあります：\n\nWikiがごみ箱化せず，構造的に整理される\n情報の探しやすさが向上\n\n具体的な運用例\n\n\n\n\n\n\n\n\n\n情報の種類\n最初は\nその後\n\n\n\n\n新しいやり方の試行錯誤\nSlackで議論（フロー）\n成功したら手順をWikiに整理（ストック）\n\n\n問い合わせへの回答\nチャットで返す（フロー）\nよくある質問ならFAQとしてまとめる（ストック）\n\n\nプロジェクトの背景や目的\n議事録で共有（フロー）\n重要事項はWikiのプロジェクトページに追記（ストック）"
  },
  {
    "objectID": "posts/2025-05-23-what-to-write-in-wiki/index.html#coding-projectでwikiに書くべき情報",
    "href": "posts/2025-05-23-what-to-write-in-wiki/index.html#coding-projectでwikiに書くべき情報",
    "title": "wikiにどのような情報をどのように残すか？",
    "section": "4. Coding ProjectでWikiに書くべき情報",
    "text": "4. Coding ProjectでWikiに書くべき情報\n\nGoal: 開発メンバー全員が迷わず効率よく開発・運用できる\n\n\n\nWikiを書く目的は情報伝達の課題を解決するため\nCoding Projectにおいて情報伝達課題の解決はプロジェクトの生産性・品質・持続性を大きく左右する\n\n\n\n\n\n\n\n\n\nWikiに書く内容\nどの「迷い」や「非効率」を減らすか\n\n\n\n\n環境構築手順\n「動かない」「セットアップ方法がわからない」\n\n\n技術スタック・設計方針\n「なぜこの技術を使ってるの？」「全体像が見えない」\n\n\nコーディングルール・ブランチ戦略\n「このファイル名でいい？」「この書き方でOK？」\n\n\nデプロイ手順・運用ルール\n「本番反映って誰がどうやってるの？」\n\n\nFAQ・トラブル対応\n「よくあるエラーが出た，どうすればいい？」"
  },
  {
    "objectID": "posts/2025-05-23-what-to-write-in-wiki/index.html#metadata-fieldの活用",
    "href": "posts/2025-05-23-what-to-write-in-wiki/index.html#metadata-fieldの活用",
    "title": "wikiにどのような情報をどのように残すか？",
    "section": "5. metadata fieldの活用",
    "text": "5. metadata fieldの活用\nmetadata fieldを明確に設定することで，情報の管理性・検索性・再利用性が大きく向上します．\nmetadata field活用の効果\n\n\n\n\n目的\nメタデータが果たす役割\n\n\n\n\n検索性向上\nタグ・対象環境・チームでフィルタリング可能\n\n\n責任の明確化\n作成者/責任者がわかることで内容の信用度が上がる\n\n\n鮮度の判断\n更新日で「使える情報か？」を判断できる\n\n\nナレッジの繋がり\n関連リンクでページ間の文脈を可視化できる\n\n\n\n\n\nmetadata field項目例\n\n\n\n\n\n\n\n\n\nフィールド名\n内容\n記入例・補足\n\n\n\n\nタイトル / name\nページの内容をひと目で表すタイトル\n環境構築手順（ローカル） / バックエンド設計方針\n\n\n作成者 / author\n初期作成者，または責任者\nr.nak（Slack名やGitHubアカウントで統一）\n\n\n最終更新日 / last_updated\n内容が最後に更新された日時\n2025-05-23（日付のみ or タイムスタンプ）\n\n\n関連タグ / tags\n分類や検索性向上のためのタグ群\n#backend, #setup, #api, #infra\n\n\n対象環境 / environment\n適用される環境やバージョン範囲\nlocal, staging, v2.3.1〜\n\n\n関連資料 / related_docs\n他ページや外部リンクへの参照\n[デプロイ手順](../deployment.md) / URL可\n\n\n更新履歴 / changelog\n主な更新内容と日付\n2025-05-23: Docker対応を追加2025-03-01: 初版作成\n\n\n\n\n\nmetadata field実装例\n\nMarkdown with yamlConfluence\n\n\n---\ntitle: \"ローカル環境構築ガイド\"\nauthor: \"r.nak\"\nlast_updated: \"2025-05-23\"\ntags: [\"setup\", \"backend\", \"docker\"]\nenvironment: \"local\"\nteam: \"backend\"\nis_obsolete: false\nrelated_docs:\n  - \"../deployment.md\"\n  - \"https://example.com/db-guide\"\nchangelog:\n  - \"2025-05-23: Docker対応を追加\"\n  - \"2025-03-01: 初版作成\"\n---\n\n\n\nページの冒頭に「テーブル形式」でメタ情報を記述\nテーブルを「ページプロパティマクロ」で囲む\n他ページから「ページプロパティレポートマクロ」で一覧化が可能"
  },
  {
    "objectID": "posts/2025-05-23-what-to-write-in-wiki/index.html#wiki運用tips",
    "href": "posts/2025-05-23-what-to-write-in-wiki/index.html#wiki運用tips",
    "title": "wikiにどのような情報をどのように残すか？",
    "section": "5. Wiki運用Tips",
    "text": "5. Wiki運用Tips\nWikiは「作って終わり」ではなく，「育てて使い続ける」ことで真価を発揮します．一方，更新を怠り最新情報が反映されていなかったり，信頼性が低い内容が記載されていたりなど実運用ではトラブルが発生します．\n\nトラブル1：情報が乱立・重複してどれが正しいか分からない\n\n\n\n\n\n\n\n\n\n\n原因・目的\n対策内容\n効果・備考\n\n\n\n\n情報の分類が曖昧・乱立しやすい\nタグを事前定義（例：setup, troubleshooting, design, infra, FAQ）\nページの役割や内容を明確化し，重複や検索漏れを防ぐ\n\n\nページの乱立・重複・古い情報の放置\n定期的な「重複・類似ページ見直し会」（ミニレビュー）\n定期的な棚卸しで情報の鮮度・整理を維持し，正しい情報を残す\n\n\n古い情報や非推奨手順が残りやすい\nis_obsolete: true フラグで非推奨情報を明示\n利用者が「どれが最新・有効か」を一目で判断できるようにする\n\n\n\n\n\n\nトラブル2：情報の更新漏れで古い手順が誤用される\n\n\n\n\n\n\n\n\n\n\n原因・目的\n対策内容\n効果・備考\n\n\n\n\n情報の鮮度が分からず古い手順が誤用される\n「更新日」フィールドを必須化\nページごとに最新更新日が明示され，利用者が情報の新旧を判断しやすくなる\n\n\n実運用の変更がWikiに反映されないまま放置される\nPRや障害対応のチェックリストに「Wiki更新」を追加\n運用変更や障害対応のたびにWiki更新を強制し，情報の陳腐化・誤用を防ぐ\n\n\n\n\n\n\nトラブル3：誰が書いたのか分からず，内容の信頼性が低い\n\n\n\n\n\n\n\n\n\n\n原因・目的\n対策内容\n効果・備考\n\n\n\n\nページの責任者が不明で内容の信頼性や更新責任が曖昧になる\nすべてのページに「Author（責任者）」を必須項目として設定\n責任者が明確になり，内容の信頼性・更新体制が向上する\n\n\n担当者不在で情報が放置される\n作成者が異動・退職したページの担当を再割当\n継続的な管理・更新体制を維持できる\n\n\n責任者不明ページの放置・情報の陳腐化\n「責任者が不明なページ一覧」を抽出し，棚卸しリストに追加\n定期的な棚卸しで責任者を再割当し，情報の鮮度と信頼性を保つ\n\n\n\n\n\nトラブル4：一部の人しかWikiを更新しない\n\n\n\n\n\n\n\n\n\n\n原因・目的\n対策内容\n効果・備考\n\n\n\n\n書き方が分からず記載が進まない・属人化\nテンプレートを整備し，書く敷居を下げる\n誰でも迷わず記載でき，情報の質と量が安定する\n\n\n重要な情報が口頭やチャットで流れてしまう\nSlackやMTGで「この話Wikiに書いておこう」と声かけする文化作り\n情報のストック化が進み，ナレッジの蓄積・共有が促進される\n\n\n\n\n\n\nトラブル5：作っても使われない\n\n\n\n\n\n\n\n\n\n\n原因・目的\n対策内容\n効果・備考\n\n\n\n\n重要情報が分散し見つけづらい\nオンボーディング資料，障害手順書，開発ルールなど，必ず参照する情報をWikiに集約\n必要な情報が一箇所で見つかり，迷いなく参照できる\n\n\n質問・回答がチャットで流れてしまう\nSlackで「この質問，Wikiにありましたよ」文化をつくる\n情報のストック化が進み，同じ質問の繰り返しを防ぐ\n\n\nWikiの構造が複雑・不親切\n初心者でもどこから見ればいいか分かる構造をつくる\n迷わず必要な情報にたどり着ける，オンボーディングも円滑\n\n\n利用者視点の改善が進まない\nユーザーを巻き込むUI改善アンケートやフィードバック導線\n実際の利用者の声を反映し，使いやすいWiki運用が実現できる"
  },
  {
    "objectID": "posts/2025-05-23-what-to-write-in-wiki/index.html#references",
    "href": "posts/2025-05-23-what-to-write-in-wiki/index.html#references",
    "title": "wikiにどのような情報をどのように残すか？",
    "section": "References",
    "text": "References\n\nサル先生のWiki入門"
  },
  {
    "objectID": "posts/2025-06-03-goal-setting-template/index.html",
    "href": "posts/2025-06-03-goal-setting-template/index.html",
    "title": "目標設定例および設定ガイドライン",
    "section": "",
    "text": "項目\n内容記入例\n\n\n\n\n目標① 事業数値目標\nグローバル事業利益目標（◯◯億円）・店舗売上目標（△△△億円）達成\n\n\n達成水準\n確定した目標に対する達成率で評価する．\n\n\n\n\n評価基準設定例\n\n\n\n\n\n\n\n\n\n評価レベル\n達成率条件\n説明\n\n\n\n\n評価 1\n達成率 110%以上\n高業績を達成し，好転を活かした成果\n\n\n評価 2\n達成率 105%以上\n目標を超えた成果\n\n\n評価 3\n達成率 100%以上\n目標通りの達成\n\n\n評価 4\n達成率 90%以上（※Break-even基準）\n損益分岐点レベル（最低限の達成）\n\n\n評価 5\n達成率 90%未満（※赤字の可能性あり）\n赤字リスクあり，持続可能性のない成果水準と判断\n\n\n\n\n\n\n\n\n\n\n\n\nNoteTip 1: 評価1,2は「簡単には達成できない目標」として設計する\n\n\n\n\n評価1,2は，単なる目標達成ではなく，「チームの工夫」「機会の最大活用」などによって初めて達成できる水準に設計するべき\nストレッチ目標（Stretch Goal）として取り扱う\n\n\n\n\n\n\n\n\n\nNoteTip 2: 評価は目標達成率で行う\n\n\n\n\n金額そのものではなく，確定目標に対する比率で評価\n柔軟性を持たせ，実態に応じて評価可能にする\n絶対金額で設定してしまうと，期中修正が難しくなる\n\n\n\n\n\n\n\n\n\nNoteTip 3: 達成水準の考え方を言語化する\n\n\n\n\n「なぜその評価レベルを○○％に設定したのか」という背景や理由を明示すること\n例：評価4（90%）を損益分岐点とした場合、「事業として利益を維持できる最低ラインであるため」といった説明を添える\n評価1・2の高い目標水準に対しては，「在庫過剰の状況を逆手に取り，特別販促で売上を押し上げた場合の想定水準」など，チャレンジの意味づけを言語化する\n\n\n\n\n\n\n\n\n\nNoteTip 4: 状況に応じて目標は期中に修正する\n\n\n\n\n目標は，期初に設定したまま固定する必要はない\n個人の生産性評価が目的なので，経済状況の悪化（例：パンデミック，為替変動）や，業績改善の兆し（例：売上回復、販促効果）に応じて、**目標を途中で引き上げ・引き下げること\n目標修正時には，関係者の合意と透明性のある記録が重要\n\n\n\n\n\n\n\n\n\nNoteTip 5: 数値の根拠 or いつの数値を利用したのか記載する\n\n\n\n\n目標に用いた金額・数値については，どのタイミングの、どの資料に基づいた数値かを明示する\n例：「2025年4月3日時点売上予算に基づく」などと記載しておくことで，評価時に「前提条件の認識違い」による混乱を防ぐ。\n複数の候補値が存在する場合もあるので，「なぜこの数値を基準としたか」の選定理由も言及することが推奨"
  },
  {
    "objectID": "posts/2025-06-03-goal-setting-template/index.html#目標設定例",
    "href": "posts/2025-06-03-goal-setting-template/index.html#目標設定例",
    "title": "目標設定例および設定ガイドライン",
    "section": "",
    "text": "項目\n内容記入例\n\n\n\n\n目標① 事業数値目標\nグローバル事業利益目標（◯◯億円）・店舗売上目標（△△△億円）達成\n\n\n達成水準\n確定した目標に対する達成率で評価する．\n\n\n\n\n評価基準設定例\n\n\n\n\n\n\n\n\n\n評価レベル\n達成率条件\n説明\n\n\n\n\n評価 1\n達成率 110%以上\n高業績を達成し，好転を活かした成果\n\n\n評価 2\n達成率 105%以上\n目標を超えた成果\n\n\n評価 3\n達成率 100%以上\n目標通りの達成\n\n\n評価 4\n達成率 90%以上（※Break-even基準）\n損益分岐点レベル（最低限の達成）\n\n\n評価 5\n達成率 90%未満（※赤字の可能性あり）\n赤字リスクあり，持続可能性のない成果水準と判断\n\n\n\n\n\n\n\n\n\n\n\n\nNoteTip 1: 評価1,2は「簡単には達成できない目標」として設計する\n\n\n\n\n評価1,2は，単なる目標達成ではなく，「チームの工夫」「機会の最大活用」などによって初めて達成できる水準に設計するべき\nストレッチ目標（Stretch Goal）として取り扱う\n\n\n\n\n\n\n\n\n\nNoteTip 2: 評価は目標達成率で行う\n\n\n\n\n金額そのものではなく，確定目標に対する比率で評価\n柔軟性を持たせ，実態に応じて評価可能にする\n絶対金額で設定してしまうと，期中修正が難しくなる\n\n\n\n\n\n\n\n\n\nNoteTip 3: 達成水準の考え方を言語化する\n\n\n\n\n「なぜその評価レベルを○○％に設定したのか」という背景や理由を明示すること\n例：評価4（90%）を損益分岐点とした場合、「事業として利益を維持できる最低ラインであるため」といった説明を添える\n評価1・2の高い目標水準に対しては，「在庫過剰の状況を逆手に取り，特別販促で売上を押し上げた場合の想定水準」など，チャレンジの意味づけを言語化する\n\n\n\n\n\n\n\n\n\nNoteTip 4: 状況に応じて目標は期中に修正する\n\n\n\n\n目標は，期初に設定したまま固定する必要はない\n個人の生産性評価が目的なので，経済状況の悪化（例：パンデミック，為替変動）や，業績改善の兆し（例：売上回復、販促効果）に応じて、**目標を途中で引き上げ・引き下げること\n目標修正時には，関係者の合意と透明性のある記録が重要\n\n\n\n\n\n\n\n\n\nNoteTip 5: 数値の根拠 or いつの数値を利用したのか記載する\n\n\n\n\n目標に用いた金額・数値については，どのタイミングの、どの資料に基づいた数値かを明示する\n例：「2025年4月3日時点売上予算に基づく」などと記載しておくことで，評価時に「前提条件の認識違い」による混乱を防ぐ。\n複数の候補値が存在する場合もあるので，「なぜこの数値を基準としたか」の選定理由も言及することが推奨"
  },
  {
    "objectID": "posts/2025-04-24-reciprocating-engine/index.html",
    "href": "posts/2025-04-24-reciprocating-engine/index.html",
    "title": "レシプロエンジンの仕組み",
    "section": "",
    "text": "レシプロエンジンは，ピストンが「吸気」「圧縮」「燃焼・膨張」「排気」という４行程（ピストンは２往復）で１サイクルの作用を完了するエンジンのことです． レシプロガソリンエンジンの場合，ガソリンを燃料とする混合気を燃焼させ，ピストンを往復させます．\n\n\n\n4 cycle engine\n\n\n吸気行程\n\nピストンが上死点から下死点に向かって下降し，シリンダー内が負圧になる\n負圧になることで吸気バルブが開き，燃料と空気の混合気が吸い込まれてくる(排気バルブは閉じられたまま)\n下死点までさがると吸気バルブが閉じる\n\n圧縮行程\n\nシリンダー内にある混合気をピストンが押上げ，圧縮していく（断熱圧縮）\n混合気中の燃料は完全に気化する\n\n燃焼・膨張行程\n\n点火プラグが点火\n圧縮された混合気が燃焼し，高温高圧のガスとなる\nガスが膨張しながらピストンを下死点まで押し下げる\nクランクシャフトが回転し動力が発生する\n\n排気行程\n\n排気バルブが開く\n下死点にあるピストンが再び上死点まで上昇し，燃焼ガスを排気バルブから外に放出\n1サイクルが完了→吸気行程へ"
  },
  {
    "objectID": "posts/2025-04-24-reciprocating-engine/index.html#レシプロエンジンの４行程",
    "href": "posts/2025-04-24-reciprocating-engine/index.html#レシプロエンジンの４行程",
    "title": "レシプロエンジンの仕組み",
    "section": "",
    "text": "レシプロエンジンは，ピストンが「吸気」「圧縮」「燃焼・膨張」「排気」という４行程（ピストンは２往復）で１サイクルの作用を完了するエンジンのことです． レシプロガソリンエンジンの場合，ガソリンを燃料とする混合気を燃焼させ，ピストンを往復させます．\n\n\n\n4 cycle engine\n\n\n吸気行程\n\nピストンが上死点から下死点に向かって下降し，シリンダー内が負圧になる\n負圧になることで吸気バルブが開き，燃料と空気の混合気が吸い込まれてくる(排気バルブは閉じられたまま)\n下死点までさがると吸気バルブが閉じる\n\n圧縮行程\n\nシリンダー内にある混合気をピストンが押上げ，圧縮していく（断熱圧縮）\n混合気中の燃料は完全に気化する\n\n燃焼・膨張行程\n\n点火プラグが点火\n圧縮された混合気が燃焼し，高温高圧のガスとなる\nガスが膨張しながらピストンを下死点まで押し下げる\nクランクシャフトが回転し動力が発生する\n\n排気行程\n\n排気バルブが開く\n下死点にあるピストンが再び上死点まで上昇し，燃焼ガスを排気バルブから外に放出\n1サイクルが完了→吸気行程へ"
  },
  {
    "objectID": "posts/2021-01-16-apt-personal-package-archive/index.html",
    "href": "posts/2021-01-16-apt-personal-package-archive/index.html",
    "title": "追加されたPersonal Package Archive(PPA)の管理",
    "section": "",
    "text": "この記事はRyo’s Tech Blog &gt; add-apt-repository ppaとはなにか？からの修正版です．"
  },
  {
    "objectID": "posts/2021-01-16-apt-personal-package-archive/index.html#personal-package-archiveppaとはなにか",
    "href": "posts/2021-01-16-apt-personal-package-archive/index.html#personal-package-archiveppaとはなにか",
    "title": "追加されたPersonal Package Archive(PPA)の管理",
    "section": "Personal Package Archive(PPA)とはなにか？",
    "text": "Personal Package Archive(PPA)とはなにか？\n\nDefinition 1 PPA\n\nPPAはPersonal Package Archiveの略称でlaunchpad.netに用意された個人用リポジトリ\nPPAを用いることで，開発者は自由にプログラム配布用のレポジトリを作成することができる.\nユーザーは sources.list へ repositoryの情報を加えるだけ(多くの場合 add-apt-repository コマンドを用いる)で，aptコマンド経由でプログラムが利用可能\n\n\nつまるところ，PPAs（Personal Package Archives）は，標準的なソフトウェア配布チャンネルに含まれないソフトウェアや更新プログラムのために使用されます． 公式のUbuntuリポジトリでは多くのパッケージが提供されていますが，提供されているバージョンが最新バージョンとは限りません．\n\n最新のソフトウェアを使用したい\n最先端の機能にアクセスしたい\n\nというときに，add-apt-repository コマンドを用いて PPA を登録し，packageへアクセスします． PPAを登録すると，apt upgradeでアップグレードの対象となるため，システム全体で一括してアップグレードをかけることができる便利さがあります．\nUbuntu公式レポジトリポリシー\n\nUbuntuの公式リポジトリは，「一度リリースしたら，できる限り同じバージョンのまま不具合修正とセキュリティ対応を行う」という保守方針を取っています\n基本的には，動作安定性の確保から「one release, one package」という関係になっているので，機能追加された最新版packageは新しいpackageとしてリリースされる必要があります\n機能追加のたびに新しいpackageを作る必要があるのでUbuntu公式レポジトリでは多くのpackageが少し古いバージョンになっています\n\n\n\n\n\n\nsequenceDiagram\n    participant Dev as 開発者（ソフトウェア提供者）\n    participant PPA as PPAインフラ（Launchpad）\n    participant User as エンドユーザー\n    participant Ubuntu as Ubuntu公式リポジトリ\n\n    Dev-&gt;&gt;PPA: ソースパッケージのアップロード\n    PPA-&gt;&gt;PPA: 自動でバイナリをビルド\n    PPA--&gt;&gt;User: パッケージの提供（apt経由で）\n    \n    Note right of User: 公式と同じUIで&lt;br/&gt;インストール・アップデート可能\n\n    Dev--&gt;&gt;Ubuntu: 品質の高いPPAを公式提案\n    Ubuntu-&gt;&gt;Ubuntu: 検証・品質チェック and 公式リポジトリに統合\n    Ubuntu--&gt;&gt;User: 公式レポジトリーからの提供\n\n    Note right of Ubuntu: 開発者が作成したPPAを&lt;br/&gt;ベースに採用できる\n\n\n\n\n\n\n\nPPAの追加\nBasic Syntax\nsudo add-apt-repository ppa:&lt;ppa-name&gt;\n追加されたリポジトリの情報は，/etc/apt/sources.list.d ディレクトリ以下に.listファイルとして格納されます．.listファイルの内容例としては\ndeb http://ppa.launchpad.net/c2d4u.team/c2d4u4.0+/ubuntu jammy main\n# deb-src http://ppa.launchpad.net/c2d4u.team/c2d4u4.0+/ubuntu jammy main\n\n\n\n\n\n\n\n\n項目\n内容\n\n\n\n\ndeb\nバイナリパッケージ（.deb）を取得する行\n\n\nhttp://ppa.launchpad.net/...\nPPA の URL（Launchpad にホスト）\n\n\njammy\n対象の Ubuntu バージョン\n\n\nmain\nセクション名（PPAでは基本的に main）\n\n\n# deb-src ...\nソースコード用（多くの場合コメントアウト）\n\n\n\n\n\nExample 1 R setup\nR や CRAN パッケージを最新版をdeb packageとして提供するレポジトリとして，c2d4u.team/c2d4u4.0+ があります．追加コマンドは以下\n# PPAの追加\n% sudo add-apt-repository ppa:c2d4u.team/c2d4u4.0+\n\n# パッケージリスト更新\n% sudo apt update\n\n# R本体をインストール\n% sudo apt install r-base\nまた，/etc/apt/sources.list.d ディレクトリ以下について確認してみると\n% ls /etc/apt/sources.list.d | grep \"c2d4u\"\nc2d4u_team-ubuntu-c2d4u4_0_-jammy.list\n\n\n\n\n可能な限りPPA経由のパッケージインストールは避ける\n\n\n\n\n\n\nWarningPPA利用の注意点\n\n\n\n\nPPAは公式リポジトリのようなチェックは行われないので，品質や信頼性のリスクは追加したユーザー責任\nPPAと公式の両方にパッケージがある場合，PPAに存在するパッケージのバージョンが公式リポジトリのバージョンより高かったら，アップグレード時にPPA版のバージョンに更新されてしまう\n\n\n\nPPAと公式の両方にパッケージがある場合は，どちらも優先度は等しく，どちらが最新バージョンかどうかで利用バージョンが決定されます．PPAが更新された結果，apt updateで意図せずversionが更新されてしまって，依存関係問題から今まで動いていたのにある日突然ソフトが動かなくなったという自体に陥るリスクがあります.\nPPA利用にあたってのチェック項目\n\n\n\n\n\n\n\n\n\nチェック項目\n内容\n推奨される確認方法\n\n\n\n\nPPA作成者の信頼性\nPPAを作成・管理している人物が信頼できるかどうか？\nPPA説明ページや Launchpad のプロフィールを見る\n\n\nPPAが公式に近いかどうか\nCranやLibreOfficeのような公式PPAと、個人が作成したPPAは信頼性が異なる\n公式Webサイトで紹介されているかを確認\n\n\n利用者数\nそのPPAを使用しているユーザーの数と評判\nPPA Stats やLaunchpadコメントなど\n\n\nメンテナンス・更新頻度\nPPAが最近も更新されているか（古いと依存関係の不整合で危険）\nPPAページの「Last updated」や apt policy で確認\n\n\n対応Ubuntuバージョン\n自分のUbuntuバージョンに対応しているか\nPPA内の dists/ ディレクトリ一覧または .list ファイル\n\n\nパッケージの品質\nパッケージが正しくビルドされ、他と競合しないか\n導入前に apt install --simulate で動作確認"
  },
  {
    "objectID": "posts/2021-01-16-apt-personal-package-archive/index.html#ppaの管理",
    "href": "posts/2021-01-16-apt-personal-package-archive/index.html#ppaの管理",
    "title": "追加されたPersonal Package Archive(PPA)の管理",
    "section": "PPAの管理",
    "text": "PPAの管理\n追加されたPPAの確認\n% grep -r ^deb /etc/apt/sources.list.d/ | grep --color ppa\nPPA経由で追加されたpackageの確認\n# インストール済みのパッケージのうち Origin が ppa のもの\n% aptitude search '?narrow(?installed, ~Oppa)'\n\n\n\n\n\n\n\n\n要素\n意味\n\n\n\n\n?narrow(A, B)\n集合 A の中から条件 B を満たすものをさらに絞り込む\n\n\n?installed\n現在インストールされているパッケージだけを対象にする\n\n\n~O&lt;value&gt;\nパッケージの「由来（Origin）」にマッチする（APTのリポジトリ情報）\n\n\n~Oppa\nOrigin が ppa を含むパッケージ（PPA由来のもの）\n\n\n\n\nパッケージの詳細情報取得\napt-cache policy &lt;package-name&gt; でpakcage 情報の詳細を取得できます． *** となっているものが現在インストールされているバージョンとなります．\n% apt-cache policy r-cran-zip                 \nr-cran-zip:\n  Installed: 2.3.0-1cran1.2204.0\n  Candidate: 2.3.0-1cran1.2204.0\n  Version table:\n *** 2.3.0-1cran1.2204.0 500\n        500 https://ppa.launchpadcontent.net/c2d4u.team/c2d4u4.0+/ubuntu jammy/main amd64 Packages\n        100 /var/lib/dpkg/status\n     2.2.0-2 500\n        500 http://jp.archive.ubuntu.com/ubuntu jammy/universe amd64 Packages\n\nPPAの削除\nadd-apt-repository –remove\n## Delete\n% sudo add-apt-repository --remove ppa:PPA_Name/ppa\n\n## Check whether the ppa is actually deleted\n% ls /etc/apt/sources.list.d\n\n/etc/apt/sources.list.d からレポジトリ登録情報を格納した .listファイルが削除されます\n/etc/apt/sources.list.d ディレクトリで直接ファイルを削除するのと実質的に同じ\nあくまでレポジトリ登録を削除するだけ = 追加されたpackage自体は残る\n\nppa-purge\n% sudo ppa-purge ppa:ppa-owner/ppa-name\n\nppa-purgeコマンドはレポジトリ登録の削除と同時に，PPAからインストールしたパッケージを「可能な限り」現在有効なリポジトリにあるパッケージに置き変えてくれるコマンド\nsudo apt-get install ppa-purge が事前に必要\nあくまで置き換えるコマンドなので削除したい場合は sudo apt autoremove コマンドのほうが良いかもしれません"
  },
  {
    "objectID": "posts/2021-01-16-apt-personal-package-archive/index.html#references",
    "href": "posts/2021-01-16-apt-personal-package-archive/index.html#references",
    "title": "追加されたPersonal Package Archive(PPA)の管理",
    "section": "References",
    "text": "References\n\nRyo’s Tech Blog &gt; add-apt-repository ppaとはなにか？\nAsk Ubuntu &gt; Are PPAs safe to add to my system and what are some “red flags” to watch out for?"
  },
  {
    "objectID": "posts/2025-03-03-triangle-inequality/index.html",
    "href": "posts/2025-03-03-triangle-inequality/index.html",
    "title": "いろいろな三角不等式",
    "section": "",
    "text": "Theorem 1 : シュワルツの不等式 \n任意の２つのベクトル \\(\\pmb{a}, \\pmb{b}\\) に対して，\n\\[\n\\vert (\\pmb{a}, \\pmb{b})\\vert \\leq ||\\pmb{a}||\\,||\\pmb{b}||\n\\]\n等号が成り立つのは \\(\\pmb a = k\\pmb b\\) または, \\(\\pmb b = k^\\prime\\pmb a\\) が成り立つ場合に限る(\\(k,k^\\prime \\in \\mathbf R\\))．\n\n\n\n\n\n\n\n\n\nNoteProof\n\n\n\n\n\n ▶  \\(\\pmb b = \\pmb 0\\) のとき\n\\(\\pmb b = \\pmb 0\\) のときは等号が成り立つことは自明．\n ▶  \\(\\pmb b \\neq \\pmb 0\\) のとき\n\\(\\displaystyle k = \\frac{(\\pmb a, \\pmb b)}{||\\pmb b||^2}\\) とおくと，\n\\[\n\\begin{align}\n||\\pmb a - k\\pmb b||^2\n    &= ||\\pmb a||^2 - 2k(\\pmb a, \\pmb b) + k^2 ||\\pmb b||^2\\\\\n    &= ||\\pmb a||^2 - 2\\frac{(\\pmb a, \\pmb b)^2}{||\\pmb b||^2} + \\frac{(\\pmb a, \\pmb b)^2}{||\\pmb b||^2}\\\\\n    &= ||\\pmb a||^2 - \\frac{(\\pmb a, \\pmb b)^2}{||\\pmb b||^2}\n\\end{align}\n\\]\nここで，\\(||\\pmb a - k\\pmb b||^2 \\geq 0\\) であるので\n\\[\n||\\pmb a||^2 \\geq \\frac{(\\pmb a, \\pmb b)^2}{||\\pmb b||^2}\n\\]\nこれを整理すると\n\\[\n||\\pmb a||^2||\\pmb b||^2 \\geq (\\pmb a, \\pmb b)^2 \\Rightarrow ||\\pmb a||\\,||\\pmb b|| \\geq |(\\pmb a, \\pmb b)|\n\\]\n等号成立が成立するとき \\(||\\pmb a - k\\pmb b||^2 = 0\\) であるので，\\(\\pmb a = k\\pmb b\\) が必要条件であることがわかります．\n ▶  \\(\\pmb a = k\\pmb b\\) の十分条件性 \n\\[\n\\begin{align}\n||\\pmb a||\\,||\\pmb b||\n    &= |k|||\\pmb b||\\,||\\pmb b||\\\\\n    &= |k|||\\pmb b||^2\n\\end{align}\n\\]\nまた\n\\[\n\\begin{align}\n|(\\pmb a, \\pmb b)|\n    &= |k|(\\pmb b, \\pmb b)\\\\\n    &= |k|||\\pmb b||^2\n\\end{align}\n\\]\nしたがって，\\(|\\pmb a||\\,||\\pmb b|| = |(\\pmb a, \\pmb b)|\\) が成り立つことがわかります．\n\n\n\n\n\nTheorem 2 : シュワルツの不等式と三角不等式 \n任意の２つのベクトル \\(\\pmb{a}, \\pmb{b}\\) に対して，\n\\[\n||\\pmb{a} + \\pmb{b}|| \\leq ||\\pmb{a}||\\, ||\\pmb{b}||\n\\]\n等号が成り立つのは \\(\\pmb a = k\\pmb b, k\\geq 0\\) または, \\(\\pmb b = k^\\prime\\pmb a, k^\\prime\\geq 0\\) が成り立つ場合に限る．\n\n\n\n\n\n\n\n\n\nNoteProof\n\n\n\n\n\nシュワルツの不等式を用いると\n\\[\n\\begin{align}\n||\\pmb{a} + \\pmb{b}||^2\n    &= ||\\pmb{a}||^2 + 2(\\pmb{a},\\pmb{b}) + ||\\pmb{b}||^2\\\\\n    &\\leq ||\\pmb{a}||^2 + 2||\\pmb{a}||\\,||\\pmb{b}|| + ||\\pmb{b}||^2\\\\\n    &= (||\\pmb{a}|| + ||\\pmb{b}||)^2\n\\end{align}\n\\]\nしたがって，\n\\[\n||\\pmb{a} + \\pmb{b}|| \\leq ||\\pmb{a}||\\, ||\\pmb{b}||\n\\]\n等号成立はシュワルツの不等式の等号が成立し，かつ\n\\[\n(\\pmb{a},\\pmb{b}) \\geq 0\n\\]\nが成立するときとなるので， \\(\\pmb a = k\\pmb b, k\\geq 0\\) または, \\(\\pmb b = k^\\prime\\pmb a, k^\\prime\\geq 0\\) が成り立つ場合に限ることがわかる．"
  },
  {
    "objectID": "posts/2025-03-03-triangle-inequality/index.html#シュワルツの不等式と三角不等式",
    "href": "posts/2025-03-03-triangle-inequality/index.html#シュワルツの不等式と三角不等式",
    "title": "いろいろな三角不等式",
    "section": "",
    "text": "Theorem 1 : シュワルツの不等式 \n任意の２つのベクトル \\(\\pmb{a}, \\pmb{b}\\) に対して，\n\\[\n\\vert (\\pmb{a}, \\pmb{b})\\vert \\leq ||\\pmb{a}||\\,||\\pmb{b}||\n\\]\n等号が成り立つのは \\(\\pmb a = k\\pmb b\\) または, \\(\\pmb b = k^\\prime\\pmb a\\) が成り立つ場合に限る(\\(k,k^\\prime \\in \\mathbf R\\))．\n\n\n\n\n\n\n\n\n\nNoteProof\n\n\n\n\n\n ▶  \\(\\pmb b = \\pmb 0\\) のとき\n\\(\\pmb b = \\pmb 0\\) のときは等号が成り立つことは自明．\n ▶  \\(\\pmb b \\neq \\pmb 0\\) のとき\n\\(\\displaystyle k = \\frac{(\\pmb a, \\pmb b)}{||\\pmb b||^2}\\) とおくと，\n\\[\n\\begin{align}\n||\\pmb a - k\\pmb b||^2\n    &= ||\\pmb a||^2 - 2k(\\pmb a, \\pmb b) + k^2 ||\\pmb b||^2\\\\\n    &= ||\\pmb a||^2 - 2\\frac{(\\pmb a, \\pmb b)^2}{||\\pmb b||^2} + \\frac{(\\pmb a, \\pmb b)^2}{||\\pmb b||^2}\\\\\n    &= ||\\pmb a||^2 - \\frac{(\\pmb a, \\pmb b)^2}{||\\pmb b||^2}\n\\end{align}\n\\]\nここで，\\(||\\pmb a - k\\pmb b||^2 \\geq 0\\) であるので\n\\[\n||\\pmb a||^2 \\geq \\frac{(\\pmb a, \\pmb b)^2}{||\\pmb b||^2}\n\\]\nこれを整理すると\n\\[\n||\\pmb a||^2||\\pmb b||^2 \\geq (\\pmb a, \\pmb b)^2 \\Rightarrow ||\\pmb a||\\,||\\pmb b|| \\geq |(\\pmb a, \\pmb b)|\n\\]\n等号成立が成立するとき \\(||\\pmb a - k\\pmb b||^2 = 0\\) であるので，\\(\\pmb a = k\\pmb b\\) が必要条件であることがわかります．\n ▶  \\(\\pmb a = k\\pmb b\\) の十分条件性 \n\\[\n\\begin{align}\n||\\pmb a||\\,||\\pmb b||\n    &= |k|||\\pmb b||\\,||\\pmb b||\\\\\n    &= |k|||\\pmb b||^2\n\\end{align}\n\\]\nまた\n\\[\n\\begin{align}\n|(\\pmb a, \\pmb b)|\n    &= |k|(\\pmb b, \\pmb b)\\\\\n    &= |k|||\\pmb b||^2\n\\end{align}\n\\]\nしたがって，\\(|\\pmb a||\\,||\\pmb b|| = |(\\pmb a, \\pmb b)|\\) が成り立つことがわかります．\n\n\n\n\n\nTheorem 2 : シュワルツの不等式と三角不等式 \n任意の２つのベクトル \\(\\pmb{a}, \\pmb{b}\\) に対して，\n\\[\n||\\pmb{a} + \\pmb{b}|| \\leq ||\\pmb{a}||\\, ||\\pmb{b}||\n\\]\n等号が成り立つのは \\(\\pmb a = k\\pmb b, k\\geq 0\\) または, \\(\\pmb b = k^\\prime\\pmb a, k^\\prime\\geq 0\\) が成り立つ場合に限る．\n\n\n\n\n\n\n\n\n\nNoteProof\n\n\n\n\n\nシュワルツの不等式を用いると\n\\[\n\\begin{align}\n||\\pmb{a} + \\pmb{b}||^2\n    &= ||\\pmb{a}||^2 + 2(\\pmb{a},\\pmb{b}) + ||\\pmb{b}||^2\\\\\n    &\\leq ||\\pmb{a}||^2 + 2||\\pmb{a}||\\,||\\pmb{b}|| + ||\\pmb{b}||^2\\\\\n    &= (||\\pmb{a}|| + ||\\pmb{b}||)^2\n\\end{align}\n\\]\nしたがって，\n\\[\n||\\pmb{a} + \\pmb{b}|| \\leq ||\\pmb{a}||\\, ||\\pmb{b}||\n\\]\n等号成立はシュワルツの不等式の等号が成立し，かつ\n\\[\n(\\pmb{a},\\pmb{b}) \\geq 0\n\\]\nが成立するときとなるので， \\(\\pmb a = k\\pmb b, k\\geq 0\\) または, \\(\\pmb b = k^\\prime\\pmb a, k^\\prime\\geq 0\\) が成り立つ場合に限ることがわかる．"
  },
  {
    "objectID": "posts/2025-03-03-triangle-inequality/index.html#複素数と三角不等式",
    "href": "posts/2025-03-03-triangle-inequality/index.html#複素数と三角不等式",
    "title": "いろいろな三角不等式",
    "section": "複素数と三角不等式",
    "text": "複素数と三角不等式\n\n\nTheorem 3 \n複素平面上に2点 \\(z = a_1 + b_1i, w = a_2 + b_2i\\) をとったとき，次の不等式が成立する\n\\[\n\\begin{gather}\n\\vert z + w \\vert \\leq \\vert z\\vert + \\vert w \\vert\\\\\n\\vert z\\vert - \\vert w \\vert \\leq \\vert z - w \\vert\n\\end{gather}\n\\]\nこれを三角不等式と呼ぶ．\n\n\n\n\n\n\n\n\n\nNoteProof 1\n\n\n\n\n\n注意: この証明は平面空間における三角不等式を前提にしているのでトートロジー疑惑が有ります\n\n\nCode\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Define the complex numbers\nalpha1 = 3 + 4j\nalpha2 = 5 + 2j\nalpha3 = alpha1 + alpha2\nalpha4 = alpha1 - alpha2\n\n# Extract the real and imaginary parts\na1_real, a1_imag = alpha1.real, alpha1.imag\na2_real, a2_imag = alpha2.real, alpha2.imag\na3_real, a3_imag = alpha3.real, alpha3.imag\na4_real, a4_imag = alpha4.real, alpha4.imag\n\n# Create the plot\nfig, ax = plt.subplots()\n\n# Plot the vectors\nax.quiver(0, 0, a1_real, a1_imag, angles=\"xy\", scale_units=\"xy\", scale=1, color=\"k\")\nax.quiver(0, 0, a2_real, a2_imag, angles=\"xy\", scale_units=\"xy\", scale=1, color=\"k\")\nax.quiver(\n    a1_real,\n    a1_imag,\n    a2_real,\n    a2_imag,\n    angles=\"xy\",\n    scale_units=\"xy\",\n    linewidth=1,\n    scale=1,\n    edgecolor=\"gray\",\n    color=\"gray\",\n)\nax.quiver(0, 0, a3_real, a3_imag, angles=\"xy\", scale_units=\"xy\", scale=1, color=\"k\")\nax.quiver(0, 0, a4_real, a4_imag, angles=\"xy\", scale_units=\"xy\", scale=1, color=\"k\")\nax.quiver(\n    a1_real,\n    a1_imag,\n    -a2_real,\n    -a2_imag,\n    angles=\"xy\",\n    scale_units=\"xy\",\n    linewidth=1,\n    scale=1,\n    edgecolor=\"gray\",\n    color=\"gray\",\n)\n\n\n# add point\nax.text(a1_real, a1_imag * 1.1, \"$z$\")\nax.text(a2_real, a2_imag, \"$w$\")\nax.text(a3_real, a3_imag, \"$z+w$\")\nax.text(a4_real, a4_imag + 0.5, \"$z-w$\")\n\n\n# Set the plot limits\nax.set_xlim(a4_real - 1, max(a1_real, a3_real) + 3)\nax.set_ylim(-1, max(a1_imag, a3_imag) + 3)\n\n# Add grid, labels, and legend\nax.grid()\nax.set_aspect(\"equal\")\nax.set_xlabel(\"Real Part\")\nax.set_ylabel(\"Imaginary Part\")\n\n# Add title\nax.set_title(\"Complex Number Vectors\")\n\n# Show the plot\nplt.show()\n\n\n\n\n\n\n\n\n\n原点と \\(z, z+w\\) を頂点とする三角形を考えます．このときそれぞれの辺の長さは \\(\\vert z\\vert, \\vert w\\vert, \\vert z + w\\vert\\) となります．\n三角形の二辺の和は他の１辺の長さより長いので\n\\[\n\\vert z + w \\vert \\leq \\vert z\\vert + \\vert w \\vert\n\\]\nが成立する．\n同様に\\(z, z-w\\) を頂点とする三角形についても\n\\[\n\\vert z \\vert \\leq \\vert z + w \\vert + \\vert w \\vert\n\\]\nが成り立つので，これを整理すると\n\\[\n\\vert z\\vert - \\vert w \\vert \\leq \\vert z - w \\vert\n\\]\n\n\n\n\n\n\n\n\n\n\nNoteProof 2\n\n\n\n\n\n複素数の絶対値と共役複素数の関係より\n\\[\n\\begin{align}\n\\vert  z + w \\vert^2\n    &= (z + w)(\\bar z + \\bar w)\\\\\n    &= z\\bar z + w\\bar w + w\\bar z + z\\bar w\\\\\n    &= \\vert z\\vert^2 + \\vert w\\vert^2 + w \\overline z + z \\overline w\\\\\n    &= \\vert z\\vert^2 + \\vert w\\vert^2 + w \\overline z + \\overline{\\overline z w}\\\\\n    &= \\vert z\\vert^2 + \\vert w\\vert^2 + 2\\operatorname{Re}w \\overline z\\\\\n    &\\leq \\vert z\\vert^2 + \\vert w\\vert^2 + 2\\vert w \\overline z\\vert\\\\\n    &= \\vert z\\vert^2 + \\vert w\\vert^2 + 2\\vert w\\vert \\vert\\overline z\\vert\\\\\n    &= \\vert z\\vert^2 + \\vert w\\vert^2 + 2\\vert w\\vert \\vert z\\vert\\\\\n    &= (\\vert z \\vert + \\vert w \\vert)^2\n\\end{align}\n\\]\nしたがって，\n\\[\n\\vert  z + w \\vert \\leq \\vert z \\vert + \\vert w \\vert\n\\]\n\n\n\n\n\nTheorem 4 \n\\(\\mathbb C^n\\) の任意のベクトル \\(\\pmb a, \\pmb b\\) に対し，次が成立する\n\\[\n||\\pmb a + \\pmb b|| \\leq ||\\pmb a|| + ||\\pmb b||\n\\]\n\n\n\n\n\n\n\n\n\nNoteProof\n\n\n\n\n\n\\[\n\\begin{align}\n||\\pmb a + \\pmb b||^2\n    &= (\\pmb a + \\pmb b, \\pmb a + \\pmb b)\\\\\n    &= ||\\pmb a||^2 + ||\\pmb b||^2 + (\\pmb a, \\pmb b) + (\\pmb b, \\pmb a)\n\\end{align}\n\\]\nここでシュワルツの不等式より\n\\[\n\\begin{align}\n|(\\pmb a, \\pmb b)| &\\leq ||\\pmb a||\\,||\\pmb b||\\\\\n|(\\pmb b, \\pmb a)| &\\leq ||\\pmb b||\\,||\\pmb a|| = ||\\pmb a||\\,||\\pmb b||\n\\end{align}\n\\]\n従って，\n\\[\n\\begin{align}\n||\\pmb a||^2 + ||\\pmb b||^2 + (\\pmb a, \\pmb b) + (\\pmb b, \\pmb a)\n    &\\leq ||\\pmb a||^2 + ||\\pmb b||^2  + 2 ||\\pmb a||\\,||\\pmb b||\\\\\n    &= (||\\pmb a|| + ||\\pmb b||)^2\n\\end{align}\n\\]\nよって，\n\\[\n\\begin{gather}\n||\\pmb a + \\pmb b||^2 \\leq (||\\pmb a|| + ||\\pmb b||)^2\\\\\n\\Rightarrow ||\\pmb a + \\pmb b|| \\leq ||\\pmb a|| + ||\\pmb b||\n\\end{gather}\n\\]"
  },
  {
    "objectID": "posts/2025-01-29-set-and-topology-series/index.html",
    "href": "posts/2025-01-29-set-and-topology-series/index.html",
    "title": "フーリエ級数と積分理論再考",
    "section": "",
    "text": "フーリエが熱伝導方程式の解をどのように求めたのか？\nどのような流れで積分の定義の再考につながったのか？\n\nを紹介します．"
  },
  {
    "objectID": "posts/2025-01-29-set-and-topology-series/index.html#このノートのスコープ",
    "href": "posts/2025-01-29-set-and-topology-series/index.html#このノートのスコープ",
    "title": "フーリエ級数と積分理論再考",
    "section": "",
    "text": "フーリエが熱伝導方程式の解をどのように求めたのか？\nどのような流れで積分の定義の再考につながったのか？\n\nを紹介します．"
  },
  {
    "objectID": "posts/2025-01-29-set-and-topology-series/index.html#熱伝導方程式",
    "href": "posts/2025-01-29-set-and-topology-series/index.html#熱伝導方程式",
    "title": "フーリエ級数と積分理論再考",
    "section": "熱伝導方程式",
    "text": "熱伝導方程式\n物体内に温度勾配が存在すると，高温部から低温部へ熱伝導（Heat conduction）により熱エネルギーが伝わります．\n\n\n\n\n\n\nFigure 1: 長さ\\(\\pi\\)の密度が一様な棒\n\n\n\nFigure 1 のような細長い密度が一定の棒が与えられたとします．\n\n左端を 0 として，ある点の位置を左端からの距離 \\(x\\) で表す\nある点 \\(x\\) における時刻 \\(t\\) での温度を \\(T(x, t)\\) で表す\n単位断面積を単位時間に通過する熱エネルギーを \\(q(x, t)\\) とする(=熱流密度)\n\nフーリエの法則より，熱流密度 \\(q(x, t)\\) は温度勾配 \\(\\displaystyle{\\frac{\\partial T(x, t)}{\\partial x}}\\) に比例するので\n\\[\nq(x, t) = -\\lambda \\frac{\\partial T(x, t)}{\\partial x} \\label{eq-fourier-law}\n\\]\n\n\\(\\lambda  &gt; 0\\): 熱伝導率，RHSに符号マイナスがついているのは，高温から低音へ熱が流れることを表してる\n熱伝導率: 物質によって定まる物性値, 熱伝導率が大きいと熱エネルギーがよく伝わり，熱伝導率が小さいと熱エネルギーを伝えにくい\n\n\\(\\eqref{eq-fourier-law}\\) で表される熱の流入から，比熱 \\(c &gt; 0\\), 密度 \\(\\rho  &gt; 0\\) を用いると温度変化 \\(\\Delta T(x, t)\\) は熱の流入と流出２要素から以下のように表されます\n\\[\n\\begin{align}\n\\Delta T(x, t) &= \\frac{1}{c\\rho\\Delta x}(q(x, t) - q(x + \\Delta x, t))\\Delta t\\\\\n\\Rightarrow \\frac{\\Delta T(x, t)}{\\Delta t} &= \\frac{1}{c\\rho\\Delta x}(q(x, t) - q(x + \\Delta x, t))\n\\end{align}\n\\]\nここで，\\(\\Delta t\\to 0, \\Delta x\\to 0\\) とすると\n\\[\n\\frac{\\partial T(x, t)}{\\partial t} = -\\frac{1}{c\\rho}\\frac{\\partial q(x, t)}{\\partial x} \\label{eq-heat-balance}\n\\]\n\\(\\eqref{eq-fourier-law}\\), \\(\\eqref{eq-heat-balance}\\) より\n\\[\n\\begin{align}\n\\frac{\\partial T(x, t)}{\\partial t}\n    &= -\\frac{1}{c\\rho}\\frac{\\partial}{\\partial x}\\left(-\\lambda \\frac{\\partial T(x, t)}{\\partial x} \\right)\\\\\n    &= \\frac{\\lambda}{c\\rho}\\frac{\\partial^2 T(x, t)}{\\partial x^2} \\label{eq-hce}\n\\end{align}\n\\tag{1}\\]\nこれを熱伝導方程式と呼びます．\\(\\displaystyle\\frac{\\lambda}{c\\rho}\\) は温度伝導率（温度拡散率）と呼ばれます．\n\n\n\n\n\n\nTip🍵 Green Tea Break: 比熱\n\n\n\n\n比熱とは 1kg の物質の温度を 1K （＝1℃）上げるのに必要な熱量のこと\n「温まりやすさ」 「冷めにくさ」 を表す物理量と理解できる\n\n例えば，水1kgの場合，1K 上げるのに必要な熱量は4186J"
  },
  {
    "objectID": "posts/2025-01-29-set-and-topology-series/index.html#熱伝導方程式とフーリエ級数",
    "href": "posts/2025-01-29-set-and-topology-series/index.html#熱伝導方程式とフーリエ級数",
    "title": "フーリエ級数と積分理論再考",
    "section": "熱伝導方程式とフーリエ級数",
    "text": "熱伝導方程式とフーリエ級数\n\n方程式: 熱伝導方程式\n境界条件: 棒の両端の温度を 0 に保つ\n初期条件: 初期状態(\\(t=0\\))における位置 \\(x\\) の温度が \\(f(x)\\) で与えられている\n\nという設定の下，温度 \\(T\\) の時間変化を求める問題を考えます．\n ▶  境界条件\n\\[\nT(0, t) = T(\\pi, t) = 0 \\qquad (t\\geq 0) \\label{eq-boundary}\n\\]\n ▶  初期条件\n\\[\nT(x, 0) = f(x) \\qquad (0 \\leq x \\leq \\pi) \\label{eq-init}\n\\]\n\n ▶  重ね合わせの原理\n熱伝導方程式は次のような性質があります\n\n\\(T_1, T_2\\) が \\(\\eqref{eq-hce}\\), \\(\\eqref{eq-boundary}\\) を満たすとき，\\(T_1 + T_2\\) も\\(\\eqref{eq-hce}\\), \\(\\eqref{eq-boundary}\\) を満たす\n\\(T\\) が \\(\\eqref{eq-hce}\\), \\(\\eqref{eq-boundary}\\) を満たすとき，その任意の定数倍 \\(kT\\) も\\(\\eqref{eq-hce}\\), \\(\\eqref{eq-boundary}\\) を満たす\n\nこれを重ね合わせの原理と呼びます．\n\n温度 \\(T\\) の時間変化を求める問題を解くにあたって，フーリエは重ね合わせの原理を活用して\n\n\\(\\eqref{eq-hce}\\), \\(\\eqref{eq-boundary}\\) を満たす関数の条件のうち，なるべく簡単な形のものを求める\n得られた簡単な形の関数を足し合わせることで，初期条件 \\(\\eqref{eq-init}\\) を満たす関数を作る\n\nという二段構えで解くことを考えました．簡単な形の関数としてフーリエが考えたのは変数分離型の関数です．\n\n変数分離\n変数分離型関数とは，位置 \\(x\\) 飲みの関数 \\(v(x)\\) と時刻 \\(t\\) のみの関数 \\(w(t)\\) の積\n\\[\nT(x, t) = v(x)w(t)\n\\]\nの形で表させる関数のことです．変数分離型を仮定すると熱伝導方程式は常微分方程式を用いて以下のように表せます\n\\[\n\\begin{align}\n\\frac{c\\rho}{\\lambda}\\frac{w^\\prime(t)}{w(t)} = \\frac{v^{\\prime\\prime}(x)}{v(x)}\n\\end{align}\n\\]\nLHSは\\(t\\)のみの関数，RHSは\\(x\\)飲みの関数であるので，方程式が恒等的に成り立つためには，両辺は定数でなければなりません．定数を \\(k\\) と表すと\n\\[\n\\begin{align}\nw^\\prime(t) &= k Aw(t)\\\\\nv^{\\prime\\prime}(t) &= k v(x)\n\\end{align}\n\\]\nなお \\(A = \\displaystyle\\frac{\\lambda}{c\\rho}\\) としています．\n ▶  \\(w(t)\\) について解く\n\\[\n\\begin{align}\n\\frac{dw(t)}{w(t)} &= k A dt\\\\\n\\int \\frac{dw(t)}{w(t)}dt &= \\int k A dt \\label{eq-cond}\\\\\n\\log(\\vert w(t)\\vert) &= k A t + C \\qquad (C\\text{: constant})\\\\\nw(t) &= \\alpha \\exp(k At)\\qquad (\\alpha = \\exp(C))\n\\end{align}\n\\]\n従って，\n\\[\n\\begin{align}\nw(t) = \\left\\{\\begin{array}{c}\n\\alpha\\exp(kAt) & (k \\neq 0)\\\\\n\\alpha & (k = 0)\n\\end{array}\\right.\n\\end{align}\n\\]\n ▶  \\(v(x)\\) について解く\n2次線形微分方程式において，\\(p, q\\) が定数のとき\n\\[\ny^{\\prime\\prime} + py^{\\prime} + q = 0\n\\]\nの一般解は特定方程式 \\(a^2 + pa + q =0\\) の解によって以下のように定まります\ncase 1: ２つの実数解 \\(\\hat a_1, \\hat a_2\\) を持つ場合\n\\[\ny = A\\exp(\\hat a_1 x) + B\\exp(\\hat a_2 x)\n\\]\ncase 2: ２つの虚数解 \\(\\hat a \\pm \\hat b i\\) を持つ場合\n\\[\ny = \\exp(\\hat a x)(A\\cos(\\hat b x) + B \\sin(\\hat b x))\n\\]\ncase 3: 重解 \\(\\hat a\\) を持つ場合\n\\[\ny = (Ax + B)\\exp(\\hat a x)\n\\]\n以上より，\n\\[\n\\begin{align}\nv(x) = \\left\\{\\begin{array}{c}\n\\beta \\exp(\\sqrt{k}x) + \\gamma \\exp(-\\sqrt{k}x) & \\text{if } k &gt; 0\\\\\n\\beta x + \\gamma & \\text{if } k = 0 \\\\\n\\beta\\cos(\\sqrt{\\vert k\\vert}x) + \\gamma\\sin(\\sqrt{\\vert k\\vert}x) & \\text{if } k &lt;0\n\\end{array}\\right.\n\\end{align}\n\\]\n境界条件および初期条件を満たすように係数 \\(\\alpha, \\beta, \\gamma\\) を定めれば，解が求まることになります．\n\n\nフーリエ級数の登場\n ▶  \\(k &gt; 0\\) のケース\n\\(\\eqref{eq-cond}\\) より，時間の経過とともに温度が無限大に大きくなることはないので \\(k&gt; 0\\) はありえないことが直感的に分かりますが，\\(k&gt; 0\\) と仮定したとき 境界条件を満たす \\(\\alpha, \\beta, \\gamma\\) が存在しないことを確認します．\n\\[\n\\begin{align}\nw(t) &= \\alpha\\exp(kAt) \\\\\nv(x) &= \\beta \\exp(\\sqrt{k}x) + \\gamma \\exp(-\\sqrt{k}x)\n\\end{align}\n\\]\n境界条件より\n\\[\n\\begin{align}\nv(0) &= \\beta + \\gamma = 0\\\\\nv(\\pi) &= \\beta\\exp(\\sqrt{k}\\pi) + \\gamma\\exp(-\\sqrt{k}\\pi) = 0\n\\end{align}\n\\]\nここから\n\\[\n\\beta(\\exp(\\sqrt{k}\\pi) - \\exp(-\\sqrt{k}\\pi)) = 0\n\\]\n従って，\n\\[\n\\begin{align}\n&\\beta = \\gamma = 0\\\\\n\\Rightarrow& v(x) =  0\n\\end{align}\n\\]\nこれは \\(f(x) = 0 \\ \\ \\forall x \\in [0, \\pi]\\) 以外の場合は初期条件を満たすことがない．\n ▶  \\(k = 0\\) のケース\n\\[\n\\begin{align}\nw(t) &= \\alpha\\\\\nv(x) &= \\beta x + \\gamma\n\\end{align}\n\\]\n境界条件を満たすためには \\(\\beta = \\gamma = 0\\) が必要になるが，\\(f(x) = 0 \\ \\ \\forall x \\in [0, \\pi]\\) 以外の場合は初期条件を満たすことがない．\n ▶  \\(k &lt; 0\\) のケース\n\\[\n\\begin{align}\nw(t) &= \\alpha\\exp(kAt) \\\\\nv(x) &= \\beta\\cos(\\sqrt{\\vert k\\vert}x) + \\gamma\\sin(\\sqrt{\\vert k\\vert}x)\n\\end{align}\n\\]\n境界条件より\n\\[\n\\begin{align}\n\\beta &= 0\\\\\n\\gamma\\sin(\\sqrt{\\vert k\\vert}\\pi) &= 0\n\\end{align}\n\\]\n\\(\\gamma= 0\\) だと初期条件を満たすことができないので，\\(\\gamma \\neq 0\\). このとき，\\(\\sqrt{\\vert k\\vert} \\in \\mathbb Z\\) が解の必要条件となることが分かる． ここで，\\(k = -n^2\\) と書き直すと\n\\[\n\\begin{align}\nT(x, t) = \\alpha\\exp(-n^2At) \\cdot \\gamma\\sin(n\\pi) \\label{eq-sol-candidate}\n\\end{align}\n\\]\nが境界条件を満たす変数分離型の解となるとこが分かります．重ね合わせの原理より \\(\\eqref{eq-sol-candidate}\\) の定数倍も境界条件と熱伝導方程式を満たす関数となります．\n重ね合わせの原理より \\(1 \\leq n \\leq N\\) の範囲で\n\\[\n\\sum_{n=1}^N a_n \\alpha\\exp(-n^2At) \\cdot \\gamma\\sin(n\\pi)\n\\]\nも境界条件と熱伝導方程式を満たす関数となります．ここでフーリエは次のような主張をしました：\n\n\\[\n\\sum_{n=1}^\\infty a_n \\alpha\\exp(-n^2At) \\cdot \\gamma\\sin(n\\pi)\n\\]\nも境界条件と熱伝導方程式を満たす関数となりえる\n\nここから初期条件を満たす関数を求めたいので, \\(t=0\\) とすると\n\\[\nf(x) = \\sum_{n=1}^\\infty b_n \\sin(n\\pi)\n\\]\nが成り立つように \\(\\{b_n\\}_{n=1}^\\infty\\) を定めれば良いとなります．このとき，正弦関数の積の積分公式\n\\[\n\\begin{align}\n\\int^{\\pi}_0\\sin nx \\sin mx dx =\\begin{cases}\n\\displaystyle 0 & (m\\neq n)\\\\[4pt]\n\\displaystyle \\frac{\\pi}{2} & (m = n)\n\\end{cases}\n\\end{align}\n\\]\n従って，\n\\[\n\\begin{align}\n\\int^{\\pi}_0f(x)\\sin mx\\ dx\n& = \\int^\\pi_0 \\sum_{n=1}^\\infty b_n \\sin(n\\pi) \\sin(m\\pi) dx\\\\\n&= \\sum_{n=1}^\\infty \\int^\\pi_0b_n \\sin(n\\pi) \\sin(m\\pi) dx\\\\\n&= \\frac{\\pi}{2}b_m\n\\end{align}\n\\]\nとなり，\n\\[\nb_n = \\frac{2}{\\pi}\\int^{\\pi}_0f(x)\\sin nx \\ dx\n\\]\nこのように求めた級数関数が変数分離型を仮定したときの熱伝導方程式の解となりうるとフーリエは主張しました． これがフーリエ級数の誕生です.\n\n\nフーリエ級数の問題点と積分理論再考へ\nフーリエ級数が登場初期には以下のような批判にさらされました:\n\nフーリエ級数が収束する保証はどこにあるのか？\n\\(0\\)から\\(\\pi\\)までの特定の一個の\\(x\\)について\\(f(x)\\)の値を変更しても積分の値には影響しないので異なる関数が同じフーリエ級数で表現されてしまうのではないか？\n無限級数の項別積分(無限和と積分の順序交換)ができる保証はどこにあるのか？\n\n無限和と積分の順序交換の批判とは，仮に熱分布関数\\(T(x, t)\\)がフーリエ級数の形式で表せることができたとしても\n\\[\n\\begin{align*}\n&\\int^\\pi_{-\\pi}\\sum_{k=1}^\\infty (a_k \\cos kx + b_k \\sin kx)\\cos nx\\ dx \\\\\n&=\\sum_{k=1}^\\infty \\left(a_k \\int^\\pi_{-\\pi}\\cos kx \\cos nx\\ dx + b_k \\int^\\pi_{-\\pi}\\sin kx \\cos nx\\ dx\\right)\n\\end{align*}\n\\]\nができる保証がないというものです. これはフーリエ級数のそれ自体の問題というよりかは\n\nどんな関数が積分可能か？\nどのようなときに項別積分ができるのか？\n\nという積分の定義・理論の問題です．フーリエの時代では積分の理論が十分なものではなく，微分の逆として積分が捉えられており，上記の問題に答えることができませんでした． 以上が，熱の変化という自然科学現象の解明のため提案されたフーリエ級数が数学理論，特に積分理論の再整備の必要性を促した流れとなります．"
  },
  {
    "objectID": "posts/2025-01-29-set-and-topology-series/index.html#appendix-正弦関数の積の積分公式の証明",
    "href": "posts/2025-01-29-set-and-topology-series/index.html#appendix-正弦関数の積の積分公式の証明",
    "title": "フーリエ級数と積分理論再考",
    "section": "Appendix: 正弦関数の積の積分公式の証明",
    "text": "Appendix: 正弦関数の積の積分公式の証明\n\n\nExercise 1 \n\\(n,k\\)をそれぞれ自然数としたとき\n\\[\n\\begin{align}\n\\int^{\\pi}_0\\sin nx \\sin kx dx =\\begin{cases}\n\\displaystyle 0 & (k\\neq n)\\\\[4pt]\n\\displaystyle \\frac{\\pi}{2} & (k = n)\n\\end{cases}\n\\end{align}\n\\]\n\n\n\n\n\n\n\n\n\nNoteProof\n\n\n\n\n\n積和の公式より\n\\[\n\\sin \\alpha\\sin \\beta=-\\frac{1}{2} \\left\\{\\cos(\\alpha+\\beta)-\\cos(\\alpha-\\beta)\\right\\}\n\\]\nこの積和の公式を用いると\n\\[\n\\begin{align}\n&\\int^{\\pi}_0\\sin nx \\sin kx\\ dx \\\\\n&= -\\frac{1}{2}\\int^{\\pi}_0 \\left\\{\\cos(n+k)x-\\cos(n-k)x\\right\\} dx \\\\\n&= -\\frac{1}{2}\\left\\{\\int^{\\pi}_0\\cos(n+k)x\\ dx- \\int^{\\pi}_0\\cos(n-k)x\\ dx\\right\\}\n\\end{align}\n\\]\nつぎに以下のケースを考えます\n\n\\(n=k\\)のとき\n\\(n\\neq k\\)のとき\n\n\n\\(n=k\\)のとき\n\n\\[\n-\\frac{1}{2}\\left\\{\\int^{\\pi}_0\\cos(n+k)x\\ dx- \\int^{\\pi}_0\\cos(n-k)x\\ dx\\right\\}\n\\]\nの第二項は\\(\\pi\\)となる一方, 第一項は\n\\[\n\\begin{align}\n\\int^{\\pi}_0\\cos(n+k)x dx &= -\\left[\\sin(n+k)x\\right]^{\\pi}_0\\\\\n&= 0\n\\end{align}\n\\]\n従って,\n\\[\n-\\frac{1}{2}\\left\\{\\int^{\\pi}_0\\cos(n+k)x\\ dx- \\int^{\\pi}_0\\cos(n-k)x\\ dx\\right\\} = \\frac{\\pi}{2}\n\\]\n\n\\(n\\neq k\\)のとき\n\n\\[\n\\begin{align}\n\\int^{\\pi}_0\\cos(n-k)x\\ dx &= -\\left[\\sin(n-k)x\\right]^{\\pi}_0 = 0\\\\[3pt]\n\\int^{\\pi}_0\\cos(n+k)x\\ dx &= -\\left[\\sin(n+k)x\\right]^{\\pi}_0 = 0\n\\end{align}\n\\]\nより\n\\[\n-\\frac{1}{2}\\left\\{\\int^{\\pi}_0\\cos(n+k)x\\ dx- \\int^{\\pi}_0\\cos(n-k)x\\ dx\\right\\} = 0\n\\]"
  },
  {
    "objectID": "posts/2025-06-24-awk-preprocess-with-calculation/index.html",
    "href": "posts/2025-06-24-awk-preprocess-with-calculation/index.html",
    "title": "CSVファイルの特定のカラムをawkで計算変換する",
    "section": "",
    "text": "CSV ファイル内の第2列の値を線形変換を通して別の単位に変換すること"
  },
  {
    "objectID": "posts/2025-06-24-awk-preprocess-with-calculation/index.html#goal",
    "href": "posts/2025-06-24-awk-preprocess-with-calculation/index.html#goal",
    "title": "CSVファイルの特定のカラムをawkで計算変換する",
    "section": "",
    "text": "CSV ファイル内の第2列の値を線形変換を通して別の単位に変換すること"
  },
  {
    "objectID": "posts/2025-06-24-awk-preprocess-with-calculation/index.html#full-command",
    "href": "posts/2025-06-24-awk-preprocess-with-calculation/index.html#full-command",
    "title": "CSVファイルの特定のカラムをawkで計算変換する",
    "section": "Full Command",
    "text": "Full Command\nワンライナースタイル\nawk -F',' 'BEGIN{OFS=\",\"; a = 0;  b = 101325 / 760} NR==1 {print $0} NR&gt;1 {if ($2 ~ /^[0-9.]+$/) {$2 = sprintf(\"%.3f\", a * $2 + b)} print $0}' input.csv\n改行有りスタイル\nawk -F',' '\nBEGIN {\n    OFS = \",\";\n    a = 2.5;          # 傾き（倍率）\n    b = 10;           # 切片（加算値）\n}\nNR == 1 {\n    print $0;         # ヘッダーはそのまま\n}\nNR &gt; 1 {\n    if ($2 ~ /^[0-9.]+$/) {\n        $2 = sprintf(\"%.3f\", a * $2 + b);  # 線形変換\n    }\n    print $0;\n}\n' input.csv\n\n改行有りスタイルでは line seperator ; は使用しなくても大丈夫です"
  },
  {
    "objectID": "posts/2025-06-24-awk-preprocess-with-calculation/index.html#explanation",
    "href": "posts/2025-06-24-awk-preprocess-with-calculation/index.html#explanation",
    "title": "CSVファイルの特定のカラムをawkで計算変換する",
    "section": "🔍 Explanation",
    "text": "🔍 Explanation\n\n\n\n\n\n\n\n\n構成要素\n内容\n\n\n\n\nawk\nAWK インタープリタを起動\n\n\n-F','\n入力のフィールド区切り文字をカンマに設定します．これにより、AWK が入力を CSV ファイルとして扱います\n\n\n'BEGIN{}\nBEGIN ブロックは、データ処理の前に一度だけ実行．{} 内部で処理を設定\n\n\nOFS=\",\";\nOFS=\",\" で出力の区切り文字をカンマに設定，CSV 形式で出力されるようにする\n\n\na = 0\na は 変数変換のための切片係数\n\n\nb = 101325 / 760\nb は 変数変換のための傾き係数\n\n\nNR==1 {print $0}\n最初の行（NR==1）の場合は，行全体（$0）をそのまま出力．これによりヘッダー行が変更されずに保持\n\n\nNR&gt;1 { ... }\n2行目以降の処理を指定\n\n\nif ($2 ~ /^[0-9.]+$/)\n第2列（圧力）が数値（正の小数や整数）であるかを確認．数値以外の場合はスキップ\n\n\n$2 = sprintf(\"%.3f\", $2 * conversion)\n第2列を変換係数で掛け算し，小数第3位で丸めて文字列に整形\n\n\nprint $0 (最後)\n変換後の行を出力\n\n\n\n\n\nExample 1  \n\n\n\n\n\n\n\n\n\n変換内容\na\nb\n説明\n\n\n\n\nmmHg → Pa\n133.322\n0\nmmHg → Paの圧力変換\n\n\n華氏 (°F) → 摂氏 (°C)\n5/9\n-32×5/9\n温度変換\n\n\nセンサー電圧 → 実測値\n任意\n任意\n校正式に応じて設定\n\n\n線形スケーリング (例: 0~1)\n任意\n任意\n最小-最大正規化などに応用可能"
  },
  {
    "objectID": "posts/2025-06-24-awk-preprocess-with-calculation/index.html#カスタムシェルスクリプト-linear_convert",
    "href": "posts/2025-06-24-awk-preprocess-with-calculation/index.html#カスタムシェルスクリプト-linear_convert",
    "title": "CSVファイルの特定のカラムをawkで計算変換する",
    "section": "📜 カスタムシェルスクリプト linear_convert",
    "text": "📜 カスタムシェルスクリプト linear_convert\n\n\nCSVファイルの指定列を線形変換し出力するスクリプト\n線形変換の式は以下\n\n\\[\ny = a\\times x + b\n\\]\n\n対象列の値が数値でない場合は、指定した文字列に置換するか，もしくは元の値を保持\n対象列は1から始まる番号で指定\n\n\n仕様\n\n入力CSVはカンマ区切りである必要があり\n\nDefintion\n#!/bin/bash\n: '\nlinear_convert - CSVファイルの指定列を線形変換し出力するスクリプト\n\nUsage:\n  ./linear_convert &lt;a: slope&gt; &lt;b: intercept&gt; &lt;column_num&gt; &lt;precision&gt; &lt;input_csv_file&gt; [na_replacement|keep]\n\nArguments:\n  a               傾き（線形変換の倍率）\n  b               切片（線形変換の加算値）\n  column_num      変換対象の列番号（1始まり）\n  precision       出力する小数点以下の桁数\n  input_csv_file  入力CSVファイルのパス\n  na_replacement  欠損値・非数値の置換文字列または\"keep\"（省略時は\"keep\"）\n\nDescription:\n  指定したCSVファイルの指定列の値に対して、線形変換 y = a * x + b を適用します。\n  欠損値や数値でない値は、指定した文字列に置換するか、\"keep\"指定であればそのまま保持します。\n\nExample:\n  # 第3列を y=2.5*x + 10 に変換し、小数点2桁で出力。欠損値はそのまま保持。\n  ./linear_convert.sh 2.5 10 3 2 input.csv\n\n  # 欠損値を\"Missing\"に置換する場合\n  ./linear_convert.sh 2.5 10 3 2 input.csv Missing\n'\n\n# --- 引数チェック ---\nif [ \"$#\" -lt 5 ] || [ \"$#\" -gt 6 ]; then\n  echo \"Usage: $0 &lt;a: slope&gt; &lt;b: intercept&gt; &lt;column_num&gt; &lt;precision&gt; &lt;input_csv_file&gt; [na_replacement|keep]\"\n  echo \"Example: $0 2.5 10 3 2 input.csv Missing\"\n  echo \"na_replacement options: NA, Missing, 0, or keep (default: keep)\"\n  exit 1\nfi\n\n# --- 引数を変数に代入 ---\na=\"$1\"\nb=\"$2\"\ncol=\"$3\"\nprecision=\"$4\"\ninput_file=\"$5\"\nna_replacement=\"${6:-keep}\"   # 6番目の引数がなければ keep をデフォルトに\n\nawk -F',' -v a=\"$a\" -v b=\"$b\" -v col=\"$col\" -v prec=\"$precision\" -v na=\"$na_replacement\" '\nBEGIN {\n    OFS = \",\";\n    format = \"%.\" prec \"f\";\n}\nNR == 1 {\n    print $0;\n}\nNR &gt; 1 {\n    val = $col;\n    if (val ~ /^[0-9.]+$/) {\n        $col = sprintf(format, a * val + b);\n    } else {\n        if (na == \"keep\") {\n            $col = val;   # 欠損・非数値はそのまま保持\n        } else {\n            $col = na;    # na_replacement で置換\n        }\n    }\n    print $0;\n}\n' \"$input_file\"\nUsage\nlinear_convert &lt;a: slope&gt; &lt;b: intercept&gt; &lt;column_num&gt; &lt;precision&gt; &lt;input_csv_file&gt; [na_replacement|keep]\nInputs\n\n\n\n\n\n\n\n引数名\n説明\n\n\n\n\na\n線形変換の傾き（倍率）\n\n\nb\n線形変換の切片（加算値）\n\n\ncolumn_num\n変換対象の列番号（1始まり）\n\n\nprecision\n出力する小数点以下の桁数\n\n\ninput_csv_file\n入力CSVファイルのパス\n\n\nna_replacement\n欠損値・非数値の置換文字列 または \"keep\"（省略時は \"keep\"）\n\n\n\n\nExample 2 第3列に対し y = 2.5 * x + 10 の変換を適用し，小数点以下2桁で表示\n./linear_convert 2.5 10 3 2 input.csv\n\n\n\nExample 3 欠損値を “Missing” に置換する場合\n./linear_convert 2.5 10 3 2 input.csv Missing\n\n\n\nExample 4 欠損値を 0 に置換する場合\n./linear_convert 2.5 10 3 2 input.csv 0"
  },
  {
    "objectID": "posts/2025-06-15-polytropic/index.html",
    "href": "posts/2025-06-15-polytropic/index.html",
    "title": "断熱圧縮とポリトロープ変化",
    "section": "",
    "text": "理論冷凍サイクルでは可逆断熱圧縮（平衡状態を維持しながらの断熱圧縮）として扱われますが，実際には圧縮機において圧縮中の冷媒上記には熱の出入りがあります． また，圧縮機頭部を冷却し，圧縮中に加熱した冷媒ガスから積極的に熱を除去することもあり，これらの圧縮をポリトロープ圧縮と呼びます．\n\n\n\n\\(c_p\\): 定圧比熱 [kJ/(kg\\(\\cdot\\)K)]\n\\(c_p\\): 定容比熱 [kJ/(kg\\(\\cdot\\)K)]\n\nとして理想気体の \\(c_v, c_p\\) の関係をまず考えてみます．理想気体の状態方程式より\n\\[\npv = RT\n\\]\nこれは状態式なので全微分すると\n\\[\npdv + vdp = Rdt\n\\]\nこれを用いて比エンタルピ変化を考えると\n\\[\n\\begin{align}\ndh\n  &= du + pdv + vdp\\\\\n  &= du + RdT\n\\end{align}\n\\]\n理想気体を仮定しているので\n\\[\n\\begin{align}\ndu &= c_vdT\\\\\ndh &= c_pdT\n\\end{align}\n\\]\n従って，\n\\[\nc_pdT = c_vdT + RdT\n\\]\n両辺をdTで除して整理すると\n\\[\nc_p - c_v = R\n\\]\nここで比熱比 \\(\\kappa\\) を次のように定義する\n\\[\n\\frac{c_p}{c_v} = \\kappa\n\\]\n整理すると\n\\[\n\\begin{align}\nc_p &= \\frac{\\kappa R}{\\kappa - 1}\\\\\nc_v &= \\frac{R}{\\kappa - 1}\n\\end{align}\n\\]\nポワソン公式の導出\n断熱圧縮では \\(dq = 0\\) であるので，理想気体では\n\\[\n\\begin{align}\n&c_vdT + pdv = 0\\\\\n&\\Rightarrow dT = -\\frac{pdv}{c_v}\n\\end{align}\n\\]\n理想気体の状態方程式を微分すると\n\\[\npdv + vdp = RdT\n\\]\nこれらを \\(dT\\) を消去する形で整理すると\n\\[\n\\begin{gather}\n\\frac{R + c_v}{c_v}pdv + vdp = 0\\\\\n\\Rightarrow \\frac{c_p}{c_v}pdv + vdp = 0\\\\\n\\Rightarrow \\kappa \\frac{dv}{v} = -\\frac{dp}{p}\n\\end{gather}\n\\]\nこれを積分すると\n\\[\npv^\\kappa = C \\label{eq-poisson}\n\\]\nこの断熱圧縮時の理想気体の可逆断熱圧縮時の圧力 \\(p\\) と比体積 \\(v\\) と \\(\\kappa\\) の関係をポアソンの公式と呼びます．\n温度と圧力で表したポアソンの公式\n\\(\\eqref{eq-poisson}\\) を理想気体の状態方程式を用いて変形すると\n\\[\n\\begin{align}\npv^\\kappa = p\\left(\\frac{RT}{p}\\right)^\\kappa = C\n\\end{align}\n\\]\n従って\n\\[\n\\frac{p^{(\\kappa-1)/\\kappa}}{T} = \\text{const}\n\\]\nとポアソンの公式を露わことができます．\n同様に \\(T\\) と \\(v\\) についてならば\n\\[\nTv^{\\kappa-1}= \\text{const}\n\\]\n断熱圧縮と状態変化\n圧縮機で断熱圧縮をした結果 \\(p_1 \\to p_2\\) まで変化したとします．このときの温度変化はポワソン公式より\n\\[\n\\frac{T_2}{T_1} = \\left(\\frac{p_2}{p_1}\\right)^{(\\kappa-1)/\\kappa} \\label{eq-compress-ratio}\n\\]\nつまり\n\n圧力比が大きいほど温度比も大きくなる\n比熱比が大きいほど温度比も大きくなる\n\n\n\n\n\n\n\nNote\n\n\n\n\n実際の圧縮機での冷媒蒸気の圧縮では圧縮機の機械的な摩擦による熱が冷媒に加わり，吐出しガス温度はより高くなる\nこの温度が高すぎると冷凍機油を劣化させ，圧縮機寿命に影響を及ぼしてしまう\n鉱油の冷凍機油の劣化温度は一般に120~130℃以上\n\n\n\n\nExample 1 CoolPropを用いた圧縮機吐出しガス温度の計算\n蒸発温度が -20℃，凝縮温度が 30℃，圧縮機吸い込み蒸気の加熱度が 5K のとき，圧縮機吸込み蒸気を凝縮圧力まで断熱圧縮した後の吐出しガス温度 \\(Td\\) をもとめてみます． 冷媒はR410Aとして，比熱比 \\(\\kappa = 1.28\\) で一定とする．\n圧縮機吸い込み温度 \\(T\\) は，\n\\[\nT = 273.15 + (-20) + 5 = 258.15\n\\]\n低い圧センサを \\(P_l\\), 高圧センサを \\(P_h\\) とすると \\(\\eqref{eq-compress-ratio}\\) より\n\\[\nTd = 258.15 \\times \\left(\\frac{P_h}{P_l}\\right)^{(\\kappa-1)/\\kappa}\n\\]\nよってまず，圧力比を取得します\n\n\nCode\nfrom CoolProp.CoolProp import PropsSI\n\nTe = 273.15 - 20   # 蒸発温度\nTc = 273.15 + 30\nfluid = 'R410A'  # 冷媒名\n\n# 飽和圧力（単位：Pa）を取得\nP_l = PropsSI('P', 'T', Te, 'Q', 0, fluid)\nP_h = PropsSI('P', 'T', Tc, 'Q', 0, fluid)\nP_ratio = P_h/P_l\n\nprint(f\"低圧圧力 = {P_l/1000000:.4f} MPa\")\nprint(f\"高圧圧力 = {P_h/1000000:.4f} MPa\")\nprint(f\"圧力比 = {P_ratio:.4f}\")\n\n\n低圧圧力 = 0.4007 MPa\n高圧圧力 = 1.8891 MPa\n圧力比 = 4.7148\n\n\n圧力比がわかったので実際に計算してみると\n\n\nCode\nTe = 273.15 + (-20) + 5 \nkappa = 1.28\n\nTd = Te * (P_ratio) ** ((kappa - 1)/kappa)\nprint(f\"圧縮機吹出しガス温度 = {Td:4f} K = {Td - 273.15:4f} ℃\")\n\n\n圧縮機吹出しガス温度 = 362.403188 K = 89.253188 ℃\n\n\n次に圧縮前後の比エンタルピ差を求めてみます．\n\\[\ndh = dq + vdp\n\\]\nであるので断熱圧縮時は \\(dq = 0\\) つまり\n\\[\n\\begin{align}\nh_2 - h_1\n  &= \\int^2_1 vdp\\\\\n  &= \\int^2_1 \\left(\\frac{C}{p}\\right)^{1/\\kappa}dp\\\\\n  &= \\frac{\\kappa}{\\kappa - 1}(p_2v_2 - p_1v_1) \\label{eq-compress-work}\n\\end{align}\n\\]"
  },
  {
    "objectID": "posts/2025-06-15-polytropic/index.html#圧縮機における断熱圧縮",
    "href": "posts/2025-06-15-polytropic/index.html#圧縮機における断熱圧縮",
    "title": "断熱圧縮とポリトロープ変化",
    "section": "",
    "text": "理論冷凍サイクルでは可逆断熱圧縮（平衡状態を維持しながらの断熱圧縮）として扱われますが，実際には圧縮機において圧縮中の冷媒上記には熱の出入りがあります． また，圧縮機頭部を冷却し，圧縮中に加熱した冷媒ガスから積極的に熱を除去することもあり，これらの圧縮をポリトロープ圧縮と呼びます．\n\n\n\n\\(c_p\\): 定圧比熱 [kJ/(kg\\(\\cdot\\)K)]\n\\(c_p\\): 定容比熱 [kJ/(kg\\(\\cdot\\)K)]\n\nとして理想気体の \\(c_v, c_p\\) の関係をまず考えてみます．理想気体の状態方程式より\n\\[\npv = RT\n\\]\nこれは状態式なので全微分すると\n\\[\npdv + vdp = Rdt\n\\]\nこれを用いて比エンタルピ変化を考えると\n\\[\n\\begin{align}\ndh\n  &= du + pdv + vdp\\\\\n  &= du + RdT\n\\end{align}\n\\]\n理想気体を仮定しているので\n\\[\n\\begin{align}\ndu &= c_vdT\\\\\ndh &= c_pdT\n\\end{align}\n\\]\n従って，\n\\[\nc_pdT = c_vdT + RdT\n\\]\n両辺をdTで除して整理すると\n\\[\nc_p - c_v = R\n\\]\nここで比熱比 \\(\\kappa\\) を次のように定義する\n\\[\n\\frac{c_p}{c_v} = \\kappa\n\\]\n整理すると\n\\[\n\\begin{align}\nc_p &= \\frac{\\kappa R}{\\kappa - 1}\\\\\nc_v &= \\frac{R}{\\kappa - 1}\n\\end{align}\n\\]\nポワソン公式の導出\n断熱圧縮では \\(dq = 0\\) であるので，理想気体では\n\\[\n\\begin{align}\n&c_vdT + pdv = 0\\\\\n&\\Rightarrow dT = -\\frac{pdv}{c_v}\n\\end{align}\n\\]\n理想気体の状態方程式を微分すると\n\\[\npdv + vdp = RdT\n\\]\nこれらを \\(dT\\) を消去する形で整理すると\n\\[\n\\begin{gather}\n\\frac{R + c_v}{c_v}pdv + vdp = 0\\\\\n\\Rightarrow \\frac{c_p}{c_v}pdv + vdp = 0\\\\\n\\Rightarrow \\kappa \\frac{dv}{v} = -\\frac{dp}{p}\n\\end{gather}\n\\]\nこれを積分すると\n\\[\npv^\\kappa = C \\label{eq-poisson}\n\\]\nこの断熱圧縮時の理想気体の可逆断熱圧縮時の圧力 \\(p\\) と比体積 \\(v\\) と \\(\\kappa\\) の関係をポアソンの公式と呼びます．\n温度と圧力で表したポアソンの公式\n\\(\\eqref{eq-poisson}\\) を理想気体の状態方程式を用いて変形すると\n\\[\n\\begin{align}\npv^\\kappa = p\\left(\\frac{RT}{p}\\right)^\\kappa = C\n\\end{align}\n\\]\n従って\n\\[\n\\frac{p^{(\\kappa-1)/\\kappa}}{T} = \\text{const}\n\\]\nとポアソンの公式を露わことができます．\n同様に \\(T\\) と \\(v\\) についてならば\n\\[\nTv^{\\kappa-1}= \\text{const}\n\\]\n断熱圧縮と状態変化\n圧縮機で断熱圧縮をした結果 \\(p_1 \\to p_2\\) まで変化したとします．このときの温度変化はポワソン公式より\n\\[\n\\frac{T_2}{T_1} = \\left(\\frac{p_2}{p_1}\\right)^{(\\kappa-1)/\\kappa} \\label{eq-compress-ratio}\n\\]\nつまり\n\n圧力比が大きいほど温度比も大きくなる\n比熱比が大きいほど温度比も大きくなる\n\n\n\n\n\n\n\nNote\n\n\n\n\n実際の圧縮機での冷媒蒸気の圧縮では圧縮機の機械的な摩擦による熱が冷媒に加わり，吐出しガス温度はより高くなる\nこの温度が高すぎると冷凍機油を劣化させ，圧縮機寿命に影響を及ぼしてしまう\n鉱油の冷凍機油の劣化温度は一般に120~130℃以上\n\n\n\n\nExample 1 CoolPropを用いた圧縮機吐出しガス温度の計算\n蒸発温度が -20℃，凝縮温度が 30℃，圧縮機吸い込み蒸気の加熱度が 5K のとき，圧縮機吸込み蒸気を凝縮圧力まで断熱圧縮した後の吐出しガス温度 \\(Td\\) をもとめてみます． 冷媒はR410Aとして，比熱比 \\(\\kappa = 1.28\\) で一定とする．\n圧縮機吸い込み温度 \\(T\\) は，\n\\[\nT = 273.15 + (-20) + 5 = 258.15\n\\]\n低い圧センサを \\(P_l\\), 高圧センサを \\(P_h\\) とすると \\(\\eqref{eq-compress-ratio}\\) より\n\\[\nTd = 258.15 \\times \\left(\\frac{P_h}{P_l}\\right)^{(\\kappa-1)/\\kappa}\n\\]\nよってまず，圧力比を取得します\n\n\nCode\nfrom CoolProp.CoolProp import PropsSI\n\nTe = 273.15 - 20   # 蒸発温度\nTc = 273.15 + 30\nfluid = 'R410A'  # 冷媒名\n\n# 飽和圧力（単位：Pa）を取得\nP_l = PropsSI('P', 'T', Te, 'Q', 0, fluid)\nP_h = PropsSI('P', 'T', Tc, 'Q', 0, fluid)\nP_ratio = P_h/P_l\n\nprint(f\"低圧圧力 = {P_l/1000000:.4f} MPa\")\nprint(f\"高圧圧力 = {P_h/1000000:.4f} MPa\")\nprint(f\"圧力比 = {P_ratio:.4f}\")\n\n\n低圧圧力 = 0.4007 MPa\n高圧圧力 = 1.8891 MPa\n圧力比 = 4.7148\n\n\n圧力比がわかったので実際に計算してみると\n\n\nCode\nTe = 273.15 + (-20) + 5 \nkappa = 1.28\n\nTd = Te * (P_ratio) ** ((kappa - 1)/kappa)\nprint(f\"圧縮機吹出しガス温度 = {Td:4f} K = {Td - 273.15:4f} ℃\")\n\n\n圧縮機吹出しガス温度 = 362.403188 K = 89.253188 ℃\n\n\n次に圧縮前後の比エンタルピ差を求めてみます．\n\\[\ndh = dq + vdp\n\\]\nであるので断熱圧縮時は \\(dq = 0\\) つまり\n\\[\n\\begin{align}\nh_2 - h_1\n  &= \\int^2_1 vdp\\\\\n  &= \\int^2_1 \\left(\\frac{C}{p}\\right)^{1/\\kappa}dp\\\\\n  &= \\frac{\\kappa}{\\kappa - 1}(p_2v_2 - p_1v_1) \\label{eq-compress-work}\n\\end{align}\n\\]"
  },
  {
    "objectID": "posts/2025-06-15-polytropic/index.html#ポリトロープ変化",
    "href": "posts/2025-06-15-polytropic/index.html#ポリトロープ変化",
    "title": "断熱圧縮とポリトロープ変化",
    "section": "ポリトロープ変化",
    "text": "ポリトロープ変化\n圧縮機での実際の圧縮では，\n\n吸い込み蒸気がシリンダ壁などで加熱\n圧縮ガスの熱が圧縮機壁を通って外部に放熱\n\nという現象が発生し，可逆断熱圧縮とはなりません．可逆断熱圧縮とならなくても圧力 \\(p\\) と比容積 \\(v\\) が以下のような指数関係で結ばれるような変化とみなせる，つまり\n\\[\npv^n = C\n\\]\nであるとき，これはポリトロープ変化(ポリトロープ圧縮)と呼びます．\n\nDefinition 1 ポリトロープ変化\n理想気体と見なせる気体について，圧力 \\(p\\) と比容積 \\(v\\) が以下のような指数関係で結ばれるような変化をポリトロープ変化という\n\\[\npv^n = C\n\\]\n\n\\(C\\): constant\n\\(n\\): ポリトロープ指数\n\n温度と圧力の能動的な同時操作を行えば，変化経路としては，どのような向きの経路でも取ることができると仮定される（=可逆的変化）\n\nポリトロープ変化と変化の種類\n\n\n\n\n\n\n\n\n\nポリトロープ指数\n対応状況\n変化\n\n\n\n\n\\(n=0\\)\n\\(p=C\\)\n等圧変化\n\n\n\\(n=1\\)\n\\(pv=C\\)\n等温変化\n\n\n\\(n=\\infty\\)\n\\(v=C\\)\n等積変化\n\n\n\\(n=\\kappa\\)\n\\(pv^\\kappa=C\\)\n断熱変化\n\n\n\n\n\nExample 2 \\(1 &lt; n &lt; \\kappa\\) のポリトロープ圧縮\n等温変化，断熱変化，ポリトロープ変化それぞれの場合のPV plotは以下のようになります．\n\n\nCode\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\ndef plot_pv_diagram():\n    # 理想気体の比熱比 (γ) を設定\n    # 断熱変化は PV^γ = const で表される\n    kappa = (\n        1.4  # 単原子分子理想気体の場合 5/3 = 1.67, 二原子分子理想気体の場合 7/5 = 1.4\n    )\n    poly = 1.2\n\n    # 点 1 の状態量\n    P1 = 2.0  # P軸のスケールに合わせて適当な値に調整\n    V1 = 1.0  # V軸のスケールに合わせて適当な値に調整\n    TA = P1 * V1  # PV = nRT なので、T は PV に比例すると考えられる\n\n    # 点 2 の状態量\n    P2 = np.linspace(P1, 7.0, 1000)\n    V2_adiabatic = V1 * (P1 / P2) ** (1 / kappa)\n    V2_poly = V1 * (P1 / P2) ** (1 / poly)\n    V2_iso = V1 * (P1 / P2)\n\n    # Matplotlibでプロット\n    plt.figure(figsize=(8, 6))\n\n    # 断熱変化の曲線 (AからB)\n    plt.plot(V2_adiabatic, P2, linewidth=2, label=\"adiabatic\")\n    plt.plot(V2_poly, P2, linewidth=2, label=\"polytropic\")\n    plt.plot(V2_iso, P2, linewidth=2, label=\"iso\")\n\n    # text labelの付与\n    plt.text(V2_poly[0], P2[0] + 0.1, '1', fontsize=12, ha='right')\n    plt.text(V2_poly[-1], P2[-1] * 1.01, '2\\'', fontsize=12, ha='right')\n\n\n    # 軸ラベルとタイトル\n    plt.xlabel(\"v\")\n    plt.ylabel(\"p\")\n    plt.title(\"PV plot\")\n    plt.legend()\n\n    # 軸の範囲を設定\n    plt.xlim(0, 1.2)\n    plt.ylim(0, 7.5)\n\n    # 凡例\n    # plt.legend() # 等温変化と断熱変化の凡例は曲線上に直接記述した方が見やすいかも\n\n    # グリッド\n    plt.grid(True, linestyle=\":\", alpha=0.6)\n\n    # 軸の目盛りとラベル\n    plt.yticks([P1, P2[-1]], [f\"P1\", f\"P2\"])\n\n    plt.tight_layout()\n    plt.show()\n\n\n# 関数を呼び出してグラフを表示\nplot_pv_diagram()\n\n\n\n\n\n\n\n\n\n冷媒を状態1から状態2’までポリトロープ圧縮した場合，圧縮の際に外部に熱が放出される場合の比エンタルピー変化は\n\\[\nh_2 - h_1 = q_{12} + \\int^2_1 vdp\n\\]\n断熱圧縮の場合は，\\(q_{12} = 0\\) であるから断熱圧縮仕事 \\(-l_{12}\\) は\n\\[\n-l_{12} = h_2 - h_1\n\\]\nポリトロープ圧縮仕事 \\(-l_{12'}\\) は\n\\[\n\\begin{align}\n-l_{12'}\n  &= -l_{12} + q_{12}\\\\\n  &= h_2 -h_1 + q_{12}\\\\\n  &= h_{2'} - h_1\n\\end{align}\n\\]\n\\(\\eqref{eq-compress-work}\\) より\n\\[\n\\begin{align}\n-l_{12} &= \\frac{\\kappa}{\\kappa - 1}(p_2v_2 - p_1v_1)\\\\\n-l_{1'2} &= \\frac{n}{n - 1}(p_{2'}v_{2'} - p_1v_1)\n\\end{align}\n\\]\n\n\n\n\n\n\nNote\n\n\n\n\n比熱比 \\(\\kappa\\), ポリトロープ指数 \\(n\\), 状態1と2の圧力 \\(p_1, p_2\\) がわかれば，圧縮後の比体積 \\(v_2, v_{2'}\\) がわかる\nPH線図では変化後の座標を等比体積線と圧力の交点として図示することができる\n\n\n\n\n\n\nExample 3 放熱量の計算\nR410A用の圧縮機で\n\n吸い込み蒸気の圧力 \\(p_1 = 0.40\\) MPa\n吸い込み蒸気の比体積が \\(v_1 = 0.07\\) m³/kg\n吐出し蒸気の圧力 \\(p_2 = 1.88\\) MPa\n比熱比 \\(\\kappa = 1.3\\)\n\nとします．ポリトロープ指数 \\(n=1.2\\) のポリトロープ圧縮仕事に成るためには，断熱圧縮仕事からどれくらいの熱量が放熱される必要があるか考えてみます．\n断熱圧縮後の比体積 \\(v_2\\) と断熱圧縮仕事 \\(-l_{12}\\) は\n\\[\n\\begin{align}\nv_2 &= v_1\\left(\\frac{p_1}{p_2}\\right)^{1/\\kappa}\\\\\n-l_{12} &= \\frac{\\kappa}{\\kappa-1}(p_2v_2 - p_1v_1)\n\\end{align}\n\\]\nポリトロープ圧縮後の比体積 \\(v_{2'}\\) と圧縮仕事 \\(-l_{12'}\\) は\n\\[\n\\begin{align}\nv_{2'} &= v_1\\left(\\frac{p_1}{p_{2'}}\\right)^{1/n}\\\\\n-l_{12'} &= \\frac{n}{n-1}(p_{2'}v_{2'} - p_1v_1)\n\\end{align}\n\\]\n熱量 \\(dq\\) は\n\\[\ndq = -l_{12'}  - (-l_{12})\n\\]\nこれをPythonで実装すると\n\n\nCode\ndef calculate_heat_released(p1_MPa, v1, p2_MPa, kappa, n):\n    \"\"\"\n    ポリトロープ圧縮過程で放出される熱量 dq [kJ/kg] を計算する\n    \n    Parameters:\n        p1_MPa (float): 吸い込み圧力 [MPa]\n        v1 (float): 吸い込み比体積 [m^3/kg]\n        p2_MPa (float): 吐出し圧力 [MPa]\n        kappa (float): 断熱比（比熱比）[-]\n        n (float): ポリトロープ指数 [-]\n    \n    Returns:\n        dq (float): 放熱量 [kJ/kg]\n        l12 (float): 断熱圧縮仕事 [kJ/kg]\n        l12p (float): ポリトロープ圧縮仕事 [kJ/kg]\n    \"\"\"\n    # 単位変換 MPa → Pa\n    p1 = p1_MPa * 1e6\n    p2 = p2_MPa * 1e6\n\n    # 断熱圧縮後の比体積 v2\n    v2 = v1 * (p1 / p2)**(1 / kappa)\n\n    # 断熱圧縮仕事 [J/kg → kJ/kg]\n    l12 = (kappa / (kappa - 1)) * (p2 * v2 - p1 * v1) / 1000\n\n    # ポリトロープ圧縮後の比体積 v2'\n    v2p = v1 * (p1 / p2)**(1 / n)\n\n    # ポリトロープ圧縮仕事 [J/kg → kJ/kg]\n    l12p = (n / (n - 1)) * (p2 * v2p - p1 * v1) / 1000\n\n    # 放熱量（断熱仕事との差）\n    dq = l12p - l12\n\n    return dq, l12, l12p\n\ndq, l12, l12p = calculate_heat_released(\n    p1_MPa=0.40,\n    v1=0.07,\n    p2_MPa=1.88,\n    kappa=1.3,\n    n=1.2\n)\n\nprint(f\"断熱圧縮仕事      : {-l12:.2f} kJ/kg\")\nprint(f\"ポリトロープ圧縮仕事: {-l12p:.2f} kJ/kg\")\nprint(f\"放出される熱量     : {dq:.2f} kJ/kg\")\n\n\n断熱圧縮仕事      : -52.08 kJ/kg\nポリトロープ圧縮仕事: -49.43 kJ/kg\n放出される熱量     : -2.65 kJ/kg"
  },
  {
    "objectID": "posts/2025-06-15-polytropic/index.html#理解度チェック",
    "href": "posts/2025-06-15-polytropic/index.html#理解度チェック",
    "title": "断熱圧縮とポリトロープ変化",
    "section": "📘 理解度チェック",
    "text": "📘 理解度チェック\n\nExercise 1 \n\\(10\\) kg の理想気体が \\(pv^{1.3} = C\\) に従って，圧力 \\(0.1\\) MPa, 温度 300K の初期状態から圧縮され，圧力 \\(2.7\\) MPa になったとする．このとき，\n\n圧縮後の気体の温度を求めよ \n\n\n\n\n\n\n\n\nNoteSolution\n\n\n\n\n\n圧縮後の気体の温度を求めよ\n理想気体の状態方程式より\n\\[\n\\frac{p_1v_1}{T_1} = \\frac{p_2v_2}{T_2}\n\\]\n\n\\(p_i\\): 状態 \\(i\\) の圧力\n\\(T_i\\): 状態 \\(i\\) の温度(K)\n\\(v_i\\): 状態 \\(i\\) の比容積\n\nこれを問題文に当てはめると\n\\[\n\\begin{align}\n& \\frac{0.1\\text{MPa}\\times v_1}{300} = \\frac{2.7\\text{MPa}\\times v_2}{T_2}\\\\\n&\\Rightarrow T_2 = \\frac{2.7}{0.1} \\times 300 \\times \\underbrace{\\frac{v_2}{v_1}}_{\\text{比容積比率}}\n\\end{align}\n\\]\n比容積比率はポリトロープ変化 \\(pv^{1.3} = C\\) より\n\\[\n\\frac{p_1}{p_2} = \\left(\\frac{v_2}{v_1}\\right)^{1.3}\n\\]\nしたがって，\n\\[\n\\frac{v_2}{v_1} = \\left(\\frac{1}{27}\\right)^{\\frac{1}{1.3}}\n\\]\nよってこれを計算すると\n\n\nCode\nimport numpy as np\n\nvolume_ratio = 27 ** (-10/13)\np_ratio = 27\nbase_temp = 300\n\nres_temp = volume_ratio * p_ratio * base_temp\nprint(f\"{res_temp:.2f}K\")\n\n\n641.85K"
  },
  {
    "objectID": "posts/2025-06-15-polytropic/index.html#appendix-coolprop",
    "href": "posts/2025-06-15-polytropic/index.html#appendix-coolprop",
    "title": "断熱圧縮とポリトロープ変化",
    "section": "Appendix: CoolProp",
    "text": "Appendix: CoolProp\n\n冷媒の飽和圧力（saturation pressure）の取得\nSyntax\n\n\nCode\nfrom CoolProp.CoolProp import PropsSI\n\nT = 273.15 + 5   # 飽和温度 [K]（例：5℃）\nfluid = 'R410A'  # 冷媒名\n\n# 飽和圧力（単位：Pa）を取得\nP_sat = PropsSI('P', 'T', T, 'Q', 0, fluid)\n\nprint(f\"飽和圧力 = {P_sat/1000000:.2f} MPa\")\n\n\n飽和圧力 = 0.94 MPa\n\n\n入力仕様\n\n\n\n\n引数\n内容\n\n\n\n\n'P'\n求めたいプロパティ（圧力）\n\n\n'T', T\n与える温度（[K]）\n\n\n'Q', 0\n品質（0: 飽和液体、1: 飽和蒸気）\n\n\nfluid\n冷媒名（例：‘R410A’, ‘R134a’）\n\n\n\n\n単一冷媒, 共沸冷媒では’Q’, 0 または ‘Q’, 1 のどちらでも、飽和温度においては同じ飽和圧力を返します\nR407Cのような温度勾配の大きい非共沸冷媒では異なる飽和圧力を返します"
  },
  {
    "objectID": "posts/2025-06-15-polytropic/index.html#references",
    "href": "posts/2025-06-15-polytropic/index.html#references",
    "title": "断熱圧縮とポリトロープ変化",
    "section": "References",
    "text": "References\n\n日本機械学会誌 &gt; 2020/3 閉じた系と開いた系の第一法則\nエントロピーとエンタルピー &gt; 工業仕事"
  },
  {
    "objectID": "posts/2025-05-19-roo-code-setup/index.html",
    "href": "posts/2025-05-19-roo-code-setup/index.html",
    "title": "Roo Code環境構築",
    "section": "",
    "text": "項目\n説明\n\n\n\n\nOS\nUbuntu 22.04 LTS\n\n\nセットアップ対象\nRoo Code 3.17\n\n\n主な使用方法\nVSCode + Roo Code"
  },
  {
    "objectID": "posts/2025-05-19-roo-code-setup/index.html#この記事のスコープ",
    "href": "posts/2025-05-19-roo-code-setup/index.html#この記事のスコープ",
    "title": "Roo Code環境構築",
    "section": "",
    "text": "項目\n説明\n\n\n\n\nOS\nUbuntu 22.04 LTS\n\n\nセットアップ対象\nRoo Code 3.17\n\n\n主な使用方法\nVSCode + Roo Code"
  },
  {
    "objectID": "posts/2025-05-19-roo-code-setup/index.html#roo-codeとは",
    "href": "posts/2025-05-19-roo-code-setup/index.html#roo-codeとは",
    "title": "Roo Code環境構築",
    "section": "Roo Codeとは？",
    "text": "Roo Codeとは？\nRoo Codeとは？\n\nRoo Codeとは，VSCode上で動作するコーディングAIアシスタント\nAIを活用してコマンドラインやAPI操作を支援するインターフェースやエージェントであり，ユーザーが設定したLLMサービス自体は外部APIプロバイダーに依拠している\n\n\n\n\n\n\nsequenceDiagram\n    participant User as User\n    participant RooCode as Roo Code (AI Assistant)\n    participant Claude as Claude API\n\n    User-&gt;&gt;RooCode: 「preprocess.pyのunit test&lt;br&gt;をpytestで記載して」\n    RooCode-&gt;&gt;Claude: Calls Claude API\n    Claude-&gt;&gt;RooCode: API Response \n    RooCode-&gt;&gt;User: 「pytestを用いたunit test例はこちらです．&lt;br&gt;pytestコマンドを実行いたしましょうか？」\n\n\n\n\n\n\nRoo Codeでなにができるのか？\n\nモード切替機能を活用することで，コード作成，設計，デバッグなど，タスクに応じたアシストが可能\nVSCode上でCLIコマンドの実行が可能\n\nRoo Code vs GitHub Copilot\n\nRoo Code: より包括的なタスク管理とプロジェクト全体の理解を重視\nGitHub Copilot: リアルタイムのコード補完に特化\n\n\n\n\n\n\n\n\n\n\n特徴\nRoo Code\nGitHub Copilot\n\n\n\n\nタスクの範囲\nコード生成，デバッグ，設計，質問応答など対応可能\n主にコード補完や生成に特化\n\n\nツール連携\nファイル操作，検索，CLIコマンド実行など，VS Code内での高度な操作が可能\n基本的にコード補完に限定\n\n\nモード切り替え\nコード作成，設計，デバッグなど，目的に応じたモード及びカスタマイズが可能\nAsk, Edit, Agentモード切り替えが可能"
  },
  {
    "objectID": "posts/2025-05-19-roo-code-setup/index.html#install-roo-code",
    "href": "posts/2025-05-19-roo-code-setup/index.html#install-roo-code",
    "title": "Roo Code環境構築",
    "section": "Install Roo Code",
    "text": "Install Roo Code\nInstall Roo Code with VSCode\n\n拡張機能からRoo Codeをインストール\nサイドバーのRoo Codeアイコンをクリックし，API keyの設定"
  },
  {
    "objectID": "posts/2025-05-19-roo-code-setup/index.html#getting-startted",
    "href": "posts/2025-05-19-roo-code-setup/index.html#getting-startted",
    "title": "Roo Code環境構築",
    "section": "Getting Startted",
    "text": "Getting Startted\n参照ファイルの追加\n\n@&lt;file-path&gt; or 参照したいファイルをRoo Code message boxまでドラッグして，Shift を押しながら読み込ませる"
  },
  {
    "objectID": "posts/2025-05-19-roo-code-setup/index.html#customization",
    "href": "posts/2025-05-19-roo-code-setup/index.html#customization",
    "title": "Roo Code環境構築",
    "section": "Customization",
    "text": "Customization\n\nMode Customization\n\nPromptアイコンをクリックすることで，Roo Codeの「モード」は以下の機能でカスタマイズすることができます\n設定ファイル: ~/.config/Code/User/globalStorage/rooveterinaryinc.roo-cline/settings/custom_modes.json\n\n\n\n\n\n\n\n\n\n項目\n説明\n\n\n\n\nSlug\nMode unique identifier\n\n\nRole Definition\nモードの目的や専門性を定義例: 「文章の作成，編集，校正に特化したモード。技術文書やクリエイティブな文章の作成をサポートします」\n\n\nTool Groups\nread: ファイルの読み取りや指示の取得edit: ファイルの編集や新規作成command: ファイル管理やコンテンツ処理のためのコマンド実行\n\n\nWhen to Use\nこのモードを選択すべき状況を明確化．Orchestrateモードのときに役に立つ\n\n\nCustom Instructions\nモードの動作に関する追加指示を設定\n\n\n\n\n設定例\n{\n  \"customModes\": [\n    {\n      \"slug\": \"writer-mode\",\n      \"name\": \"📘 Writer Mode\",\n      \"roleDefinition\": \"You are Roo, a technical documentation expert specializing in creating clear, comprehensive documentation for software projects. Your expertise includes:\\nWriting clear, concise technical documentation\\nCreating and maintaining README files, API documentation, and user guides\\nFollowing documentation best practices and style guides\\nUnderstanding code to accurately document its functionality\\nOrganizing documentation in a logical, easily navigable structure\",\n      \"whenToUse\": \"Use this mode for tasks focused on content creation, editing, and refinement. Ideal for writing technical documentation, creative writing, or improving existing text\",\n      \"groups\": [\n        \"read\",\n        \"edit\"\n      ],\n      \"source\": \"global\",\n      \"customInstructions\": \"Focus on creating documentation that is clear, concise, and follows a consistent style. Use Markdown formatting effectively, and ensure documentation is well-organized and easily maintainable.\"\n    }\n  ]\n}\n\n\n\n\n\nMode別API configuration\n\n\n\n\nmode別API Configuration設定\n\nPromptアイコンをクリックすると，API Configuration という項目が確認できます\nAPI Configurationを設定することで，mode毎にどのAPIを使用するのかを設定することができます\n\ncustom_modes.json経由での設定は確認できず\n\n\n左の例では，Writer Modeについて，preprocessという名前のAPIをアサインしています．\n\n\n\n\n.rooignoreの設定\n\n.rooignore ファイルは，Roo ツールやフレームワークで無視するファイルやディレクトリを指定するために使用されます\n基本的な構文は.gitignoreと同じ\n.rooignore ファイルはプロジェクトのルートディレクトリに配置する必要があります\n\n\n\n# 一時ファイルを無視\n*.tmp\n\n# ログファイルを無視\nlogs/\n\n# 特定のファイルを除外\n!keep_this_file.txt\n\n\n.rooignore設定挙動\n.rooignore設定により無視されたファイルについて，操作はブロックされます：\n\nread_file: 無視されたファイルを読み取らない\nwrite_to_file: 無視されたファイルへの書き込みや新規作成を行わない\napply_diff: 無視されたファイルに対して差分を適用しない\nlist_code_definition_names: 無視されたファイルを解析の対象にしない\n\n\n\n\n\nShortcut settings\n\n\n\n\n\n\n\n\nショートカット\n機能説明\n\n\n\n\nctrl+meta+i\nRoo Codeパネルの表示/非表示(Toggle)\n\n\n/\nモード切替メニューの表示\n\n\nctrl + .\nモード切替Toggle\n\n\nalt + insert\ninput modeへ切り替え\n\n\nalt + enter\nAccept Roo Code suggestion\n\n\n\n\nVSCode設定Tips\n{\n    {\n    \"key\": \"ctrl+enter\",\n    \"command\": \"roo.acceptInput\",\n    \"when\": \"rooViewFocused\"\n  },\n}\n\nkey: キーボードショートカットを指\ncommand: \"roo.acceptInput\": Roo CodeのsuggestionをAcceptするコマンド\n\"when\": \"rooViewFocused\": Roo Codeビューがフォーカスされているときのみ\n\nVSCode shortcuts設定例\n\n\nkeybindings.json\n\n  {\n    \"key\": \"ctrl+enter\",\n    \"command\": \"-github.copilot.generate\",\n    \"when\": \"editorTextFocus && github.copilot.activated && !commentEditorFocused && !inInteractiveInput && !interactiveEditorFocused\"\n  },\n  {\n    \"key\": \"ctrl+meta+i\",\n    \"command\": \"workbench.view.extension.roo-cline-ActivityBar\",\n    \"when\": \"!auxiliaryBarVisible && (terminalFocus || editorTextFocus)\"\n  },\n  {\n    \"key\": \"ctrl+meta+i\",\n    \"command\": \"workbench.action.toggleAuxiliaryBar\",\n    \"when\": \"auxiliaryBarVisible\"\n  },\n  {\n    \"key\": \"ctrl+alt+i\",\n    \"command\": \"-workbench.panel.chat\",\n    \"when\": \"workbench.panel.chat.view.copilot.active\"\n  },\n  {\n    \"key\": \"ctrl+alt+b\",\n    \"command\": \"-workbench.action.toggleAuxiliaryBar\"\n  },\n  {\n    \"key\": \"alt+insert\",\n    \"command\": \"roo-cline.focusInput\",\n    \"when\": \"auxiliaryBarVisible\"\n  },\n  {\n    \"key\": \"alt+enter\",\n    \"command\": \"roo.acceptInput\",\n     \"when\": \"auxiliaryBarVisible\"\n  },"
  },
  {
    "objectID": "posts/2025-05-19-roo-code-setup/index.html#appendix-request-strategies",
    "href": "posts/2025-05-19-roo-code-setup/index.html#appendix-request-strategies",
    "title": "Roo Code環境構築",
    "section": "Appendix: Request Strategies",
    "text": "Appendix: Request Strategies\n\n\n\n\n\n\n\n\nStrategy\n実装例\n\n\n\n\nBe specific\nFix the codeではなくFix the bug in calculateTotal のように具体的に記述する\n\n\nProvide context\nファイルやコードの参照には @ Context Mentions を使用する\n\n\nBreak down tasks\n複雑なタスクは小さく管理しやすいステップに分割して提出する\n\n\nInclude exmaples\n特定のフォーマットやスタイルが必要な場合，サンプルコードを提供する\n\n\nFocus on related tasks\n一度に1つの焦点を絞ったリクエストを提出する\n\n\nAvoid Excessive jargon\n明確で分かりやすい言葉を使う，専門用語の使用は意味の明瞭化の範囲内で使用する"
  },
  {
    "objectID": "posts/2025-05-19-roo-code-setup/index.html#references",
    "href": "posts/2025-05-19-roo-code-setup/index.html#references",
    "title": "Roo Code環境構築",
    "section": "References",
    "text": "References\n\nRoo Code Docs"
  },
  {
    "objectID": "posts/2025-07-17-mlflow-setup/index.html",
    "href": "posts/2025-07-17-mlflow-setup/index.html",
    "title": "モデル管理プラットフォームMLflowの設定",
    "section": "",
    "text": "Noteセキュリティを保ちつつローカルからリモート操作\n\n\n\n\nクライアント視点では，自分の localhost:5000 にアクセスしている体感\n実際には ssh -L によってサーバの MLflow にトンネル転送されている\n\n\n\n\n\n\n\n\n\n\n\nsequenceDiagram\n    participant ClientPC as クライアントPC&lt;br&gt;(Python)\n    participant SSH as SSHトンネル&lt;br&gt;(ポートフォワーディング)\n    participant MLflowServer as Docker上のMLflow Server&lt;br&gt;(mlflow server 起動中)\n\n    ClientPC --&gt;&gt; SSH: HTTPリクエスト&lt;br&gt;(localhost:5000 → SSHトンネル)\n    SSH --&gt;&gt; MLflowServer: HTTPリクエスト&lt;br&gt;(サーバlocalhost:5000)\n    MLflowServer --&gt;&gt; SSH: HTTPレスポンス\n    SSH --&gt;&gt; ClientPC: HTTPレスポンス\n\n\n\n\n\n\n\n\nFigure 1\n\n\n\nスコープについて\n\nArtifact StoreやBackend Storeはサーバーのストーレージ領域を使用することにします"
  },
  {
    "objectID": "posts/2025-07-17-mlflow-setup/index.html#mlflowサーバーアクセスイメージ",
    "href": "posts/2025-07-17-mlflow-setup/index.html#mlflowサーバーアクセスイメージ",
    "title": "モデル管理プラットフォームMLflowの設定",
    "section": "",
    "text": "Noteセキュリティを保ちつつローカルからリモート操作\n\n\n\n\nクライアント視点では，自分の localhost:5000 にアクセスしている体感\n実際には ssh -L によってサーバの MLflow にトンネル転送されている\n\n\n\n\n\n\n\n\n\n\n\nsequenceDiagram\n    participant ClientPC as クライアントPC&lt;br&gt;(Python)\n    participant SSH as SSHトンネル&lt;br&gt;(ポートフォワーディング)\n    participant MLflowServer as Docker上のMLflow Server&lt;br&gt;(mlflow server 起動中)\n\n    ClientPC --&gt;&gt; SSH: HTTPリクエスト&lt;br&gt;(localhost:5000 → SSHトンネル)\n    SSH --&gt;&gt; MLflowServer: HTTPリクエスト&lt;br&gt;(サーバlocalhost:5000)\n    MLflowServer --&gt;&gt; SSH: HTTPレスポンス\n    SSH --&gt;&gt; ClientPC: HTTPレスポンス\n\n\n\n\n\n\n\n\nFigure 1\n\n\n\nスコープについて\n\nArtifact StoreやBackend Storeはサーバーのストーレージ領域を使用することにします"
  },
  {
    "objectID": "posts/2025-07-17-mlflow-setup/index.html#mlflowサーバーの保存領域",
    "href": "posts/2025-07-17-mlflow-setup/index.html#mlflowサーバーの保存領域",
    "title": "モデル管理プラットフォームMLflowの設定",
    "section": "MLflowサーバーの保存領域",
    "text": "MLflowサーバーの保存領域\nログやメタデータ，ファイル成果物を保存・管理する保存領域として，Artifact store と Backend storeの２種類があります．\n\n\n\n\n\n\n\n\ngraph TB\n    A[MLflow Tracking&lt;br&gt;mlflow server] --&gt; B[Backend Store&lt;br&gt;メタデータ保存]\n    A --&gt; C[Artifact Store&lt;br&gt;成果物ファイル保存]\n\n\n\n\n\n\n\n\nFigure 2\n\n\n\n\n\n\n\n\n\n\n\n保存領域\n役割\n\n\n\n\nArtifact Store\n実験で生成された Artifacts = 成果物（モデル，画像，ログファイルなど） を保存する領域\n\n\nBackend Store\nモデルや実験やRunのメタデータ(パラメータ，Metricsなどを含む)を格納する領域\n\n\n\n\n\nArtifact Store\n\n\n保存オブジェクト例\n基本的には以下のような大容量になりがちなものを保存します\n\n学習済みモデル(model.pkl)\n学習に出力した画像やプロット(ts-plot.png)\n学習時に利用したデータ(train.parquet)\n\n\nサポートされる保存先\n\nローカルディレクトリ(例: /mlflow/mlruns)\nAmazon S3(例: s3://&lt;bucket&gt;/&lt;path&gt;)\nGoogle Cloud Storage(例: gs://&lt;bucket&gt;/&lt;path&gt;)\nAzure Blob Storage\nFTP/SFTP ServerやNFS共有ディレクトリなど\n\n\n\n\n\nBackend Store\n\n\n保存オブジェクト例\n\nModel ID\nRun ID\nStart & end time\nParameters\nMetrics\nSource file name\n\n\nサポートされる保存先\n\nデフォルトではローカルの ./mlruns ディレクトリに保存\nconfigureでデータベースを指定可能"
  },
  {
    "objectID": "posts/2025-07-17-mlflow-setup/index.html#mlflowサーバー構築手順",
    "href": "posts/2025-07-17-mlflow-setup/index.html#mlflowサーバー構築手順",
    "title": "モデル管理プラットフォームMLflowの設定",
    "section": "MLflowサーバー構築手順",
    "text": "MLflowサーバー構築手順\n\nサーバー側での公式MLflow Docker Imageのインストール\n\n最新版MLflowイメージのPull\ndocker pull ghcr.io/mlflow/mlflow:latest\n\nMLflowイメージversionの確認\ndocker run --rm ghcr.io/mlflow/mlflow:latest mlflow --version\n\nMLflowイメージの削除\ndocker rmi ghcr.io/mlflow/mlflow:latest\n\n\nDockerベースのMLflow環境の構築\n基本手順としては\n\nArtifact Storeの作成と指定(./mlruns)\nBackend Storeの作成と指定(./mlflow.db)\n\nを行います．Dockerベースで行うため，Permissionの指定には注意します．\n# MLflowのデータを保存したい任意のディレクトリに移動\ncd &lt;target-directory&gt;\n\n# tracking dataを保存するために使用する空のSQLiteデータベースファイルを作成\ntouch ./mlflow.db\n\n# Artifact（モデル，プロットなど）を保存するためのディレクトリを作成\nmkdir -p ./mlruns\n\n# MLflowデータベースファイルに読み書き権限を設定．Dockerコンテナ内でMLflowが正しく動作するために必要\nchmod 666 ./mlflow.db\n\n# MLflowの実行（run）ディレクトリに読み書き実行権限を設定．MLflowがArtifactを作成&保存可能にするため必要。\nchmod 777 ./mlruns\n\n# MLflowサーバーをDockerコンテナとして起動．--host 0.0.0.0以下はMLflowサーバーに任意のIPアドレスからポート5000でアクセス可能にするため\ndocker run -d --name mlflow-server -p 5000:5000 \\\n  -v $(pwd)/mlruns:/mlflow/mlruns \\ \n  -v $(pwd)/mlflow.db:/mlflow/mlflow.db \\ \n  ghcr.io/mlflow/mlflow:latest mlflow server \\ \n  --backend-store-uri sqlite:///mlflow/mlflow.db \\ \n  --default-artifact-root /mlflow/mlruns \\ \n  --host 0.0.0.0 --port 5000\nMLflowコンテナの停止と削除\n# 現在実行中のコンテナ mlflow-server を 停止 \ndocker stop mlflow-server \n\n# 停止された mlflow-server コンテナを 削除 \ndocker rm mlflow-server\n\n\n\n\n\n\nNote\n\n\n\n\nコンテナを削除しても，mlruns/ や mlflow.db がマウントされていれば中のデータは保持されます\n\n\n\n\n\nDocker compose fileの作成\n\nコンテナの構成・起動・管理を簡潔・再現可能にしたい\n毎回 docker runの長いスクリプトを実施したくない\n\n以上の理由から，docker-compose.ymlベースでコンテナの起動を実施します．\ndocker-compose.ymlの実装\nservices:\n  mlflow-server:\n    image: ghcr.io/mlflow/mlflow:latest\n    container_name: mlflow-server\n    ports:\n      - \"5000:5000\"\n    volumes:\n      - ./mlruns:/mlflow/mlruns\n      - ./mlflow.db:/mlflow/mlflow.db\n    command: &gt;\n      mlflow server\n      --backend-store-uri sqlite:///mlflow/mlflow.db\n      --default-artifact-root /mlflow/mlruns\n      --host 0.0.0.0\n      --port 5000\nservicesセクション\nservices:\n  mlflow-server:\n\nCompose で起動するサービスの名前を mlflow-server と指定\nあくまでコンテナ名ではなく，docker composeで管理するサービス名\n\ncontainer_nameの指定\ncontainer_name: mlflow-server\n\n起動したコンテナの名前を明示的に mlflow-server に指定\n\nポートの指定\nports:\n  - \"5000:5000\"\n\nhost-port:container-portの順番で指定\nホストのポート5000 を，コンテナのポート5000 にマッピング\nhttp://localhost:5000 でブラウザからアクセスできるようになる\n\nVolumesの指定\nvolumes:\n  - ./mlruns:/mlflow/mlruns\n  - ./mlflow.db:/mlflow/mlflow.db\n\nartifact（成果物）保存先: ./mlruns:/mlflow/mlruns\nbackend store保存先: ./mlflow.db:/mlflow/mlflow.db\n\ncommand\n\nmlflow server: MLflow Tracking Server を起動\n--backend-store-uri sqlite:///mlflow/mlflow.db: SQLite を使用\n--host 0.0.0.0: 外部アクセスを許可\n\n実行方法\n# カレントディレクトリに mlflow.db が無いなら作成しておく\ntouch mlflow.db\nchmod 666 mlflow.db  # SQLiteが読み書きできるように\n\n# コンテナ作成\ndocker compose up -d\n\n# コンテナ起動\ndocker compose start\n\n# 停止\ndocker compose stop\n\n# 削除\ndocker compose down\n\n# 稼動状況の確認\ndocker ps -f name=mlflow-server\n\n\n\n\n\n\nNoteその他の設定例\n\n\n\n本記事では紹介しませんが，さらなる設定として以下のような方針が考えられます\n\nPostgreSQL や MySQL に backend-store を切り替える\nS3 や MinIO に artifact-store を変更\nsystemd 経由で自動起動"
  },
  {
    "objectID": "posts/2025-07-17-mlflow-setup/index.html#ssh経由でのmlflowへのアクセス",
    "href": "posts/2025-07-17-mlflow-setup/index.html#ssh経由でのmlflowへのアクセス",
    "title": "モデル管理プラットフォームMLflowの設定",
    "section": "ssh経由でのMLFlowへのアクセス",
    "text": "ssh経由でのMLFlowへのアクセス\nブラウザでlocalhostアクセスするためには，SSH接続時に自動的にポートフォワーディング（ローカルフォワード） する設定が必要です．これは\nssh -L 5000:localhost:5000 user@remote\nというコマンドでも実現可能ですが，.ssh/config に以下のように記載したほうが楽に成ると判断しています．\nHost mlflowserver\n    Hostname mlserver-desktop\n    User hoshinokirby\n    ForwardAgent yes\n    RequestTTY yes \n    LocalForward 5000 localhost:5000\nこの設定のよって，ssh user@remote だけで，自動的にポートフォワーディングしてくれます．\n\nBackgroundでSSH接続\n\nbackground接続\nMLflowサーバーの ~/mlflow-playground にdocker-compose.yml があり，それを立ち上がっている状況で，backgroundでssh接続したい場合は以下のコマンドを実行します．\nssh mlflowserver -fN\n\n-fN オプション\n\n\n\n\n\n\n\n\nオプション\n動作\n\n\n\n\n-f\nSSH接続後，すぐにバックグラウンドに回る（foreground → background）\n\n\n-N\nリモートでコマンドを実行せず、シェルも起動しない（トンネル用途向け）\n\n\n-T\n疑似ターミナル（tty）を割り当てない．対話的操作が不要な非対話型コマンドの実行時に使用\n\n\n\n\n接続状況の確認\nssh コマンドがバックグラウンドでまだ動いているか確認したい場合，現在動作中の ssh 関連プロセスを表示することで確かめます．\nps aux | grep \"ssh -fN -L 5000:localhost:5000\" | grep -v grep\n\n\n\n\n\n\n\n\nコマンド部分\n意味\n\n\n\n\nps aux\n全ユーザー（a）、端末に関係なく（x）、詳細情報（u）付きで すべてのプロセスを一覧表示\n\n\ngrep \"ssh\"\nその中から 「ssh」を含む行だけを抽出\n\n\ngrep -v grep\nさらにそこから grep ssh 自体の行を除外（-vは「除外」を意味）\n\n\n\n\n該当プロセスをkillしたい場合は\n# ssh processをkill\nkill [PID]\n\n# 強制kill\nkill -9 [PID]\nとなります．または，pkillを用いて\npkill -f \"ssh mlflowserver -fT\"\n\n\n\n\n\n\n\n\n部分\n意味\n\n\n\n\npkill\n条件に合うプロセスに**終了シグナル（デフォルトは SIGTERM）**を送る\n\n\n-f\nプロセス名だけでなくコマンドライン全体を検索対象にする\n\n\n\"ssh mlflowserver -fT\"\n条件：ssh mlflowserver -fT を含むコマンドを実行しているプロセス"
  },
  {
    "objectID": "posts/2025-07-29-update-quarto/index.html",
    "href": "posts/2025-07-29-update-quarto/index.html",
    "title": "Quarto Version更新用スクリプト",
    "section": "",
    "text": "現在インストールされているQuarto Versionを削除し，GitHubから対応する .deb ファイルをダウンロードして，指定したバージョンをインストールします\n実行前に，公式のQuartoダウンロードページで利用可能なQuarto Versionを確認してください\n実行の結果，/opt/quarto にQuartoがインストールされます\n\n\n\n\nDebian/Ubuntu-based Linux OS\ncurl, dpkg, gdebi-core, sudo\nインターネット接続環境\n管理者権限 27(sudo)"
  },
  {
    "objectID": "posts/2025-07-29-update-quarto/index.html#quarto-version-updateスクリプト",
    "href": "posts/2025-07-29-update-quarto/index.html#quarto-version-updateスクリプト",
    "title": "Quarto Version更新用スクリプト",
    "section": "",
    "text": "現在インストールされているQuarto Versionを削除し，GitHubから対応する .deb ファイルをダウンロードして，指定したバージョンをインストールします\n実行前に，公式のQuartoダウンロードページで利用可能なQuarto Versionを確認してください\n実行の結果，/opt/quarto にQuartoがインストールされます\n\n\n\n\nDebian/Ubuntu-based Linux OS\ncurl, dpkg, gdebi-core, sudo\nインターネット接続環境\n管理者権限 27(sudo)"
  },
  {
    "objectID": "posts/2025-07-29-update-quarto/index.html#メインスクリプト",
    "href": "posts/2025-07-29-update-quarto/index.html#メインスクリプト",
    "title": "Quarto Version更新用スクリプト",
    "section": "🔨 メインスクリプト",
    "text": "🔨 メインスクリプト\n#!/bin/bash\n# Note: please check https://quarto.org/docs/download/ before running this script\n\nset -euo pipefail\n\n# check for updates\nif ! command -v quarto &&gt; /dev/null; then\n    echo \"Quarto is not installed. Please install it first.\"\n    exit 1\nelse\n    echo \"Quarto version: $(quarto --version)\"\nfi\n\n# prompt for confirmation\nread -p \"Do you want to update Quarto? (y/n): \" confirm\nif [[ ! \"$confirm\" =~ ^[Yy]$ ]]; then\n    echo \"Update cancelled.\"\n    exit 0\nfi\n\n# Ask user for version\nread -p \"Enter the Quarto version you want to install (e.g., 1.7.32): \" QUARTO_VERSION\n\n# Confirm version input is non-empty\nif [[ -z \"$QUARTO_VERSION\" ]]; then\n    echo \"No version specified. Aborting.\"\n    exit 1\nfi\n\n# Define download URL and file name\nDEB_URL=\"https://github.com/quarto-dev/quarto-cli/releases/download/v${QUARTO_VERSION}/quarto-${QUARTO_VERSION}-linux-amd64.deb\"\nDEB_FILE=\"quarto-${QUARTO_VERSION}-linux-amd64.deb\"\n\n# Remove existing version\nif command -v quarto &&gt; /dev/null; then\n    echo \"Removing existing Quarto installation...\"\n    sudo dpkg -r quarto || echo \"Quarto was not fully removed, continuing...\"\nfi\n\n# Download and install the specified version\necho \"Downloading Quarto version ${QUARTO_VERSION}...\"\ncurl -L -o \"$DEB_FILE\" \"$DEB_URL\"\n\necho \"Installing Quarto...\"\nsudo gdebi \"$DEB_FILE\" || { echo \"Installation failed.\"; exit 1; }\n\necho \"Quarto updated successfully to version ${QUARTO_VERSION}.\"\n\n# Verify installation\nif command -v quarto &&gt; /dev/null; then\n    echo \"Quarto version: $(quarto --version)\"\n    quarto check\nelse\n    echo \"Quarto installation failed. Please check the logs.\"\n    exit 1\nfi\n\n\n# Clean up\nrm -f \"$DEB_FILE\"\necho \"Temporary files cleaned up.\"\n\nExample 1 実行例\n$ ./quarto-update.sh\nQuarto version: 1.4.550\nDo you want to update Quarto? (y/n): y\nEnter the Quarto version you want to install (e.g., 1.7.32): 1.7.32\nRemoving existing Quarto installation...\nDownloading Quarto version 1.7.32...\nInstalling Quarto...\nQuarto updated successfully to version 1.7.32.\nQuarto version: 1.7.32\n\n\n\n🔍 スクリプト解説\n初期設定部分\nset -euo pipefail\n\n\n\n\noption\n説明\n\n\n\n\n-e\nエラーが発生した時点でスクリプトを終了\n\n\n-u\n未定義の変数を使用した際にエラーを発生\n\n\n-o pipefail\nパイプラインの途中でエラーが発生した場合に検知\n\n\n\n\nユーザー確認と入力\nread -p \"Do you want to update Quarto? (y/n): \" confirm\nif [[ ! \"$confirm\" =~ ^[Yy]$ ]]; then\n    echo \"Update cancelled.\"\n    exit 0\nfi\n\nread -p \"Enter the Quarto version you want to install (e.g., 1.7.32): \" QUARTO_VERSION\n\nif [[ -z \"$QUARTO_VERSION\" ]]; then\n    echo \"No version specified. Aborting.\"\n    exit 1\nfi\n\nアップデートの実行確認をユーザーに求める\nインストールしたいQuartoのバージョンを入力させる\nバージョン番号が未入力の場合は，exit 1\n\nダウンロードとインストールの準備\nDEB_URL=\"https://github.com/quarto-dev/quarto-cli/releases/download/v${QUARTO_VERSION}/quarto-${QUARTO_VERSION}-linux-amd64.deb\"\nDEB_FILE=\"quarto-${QUARTO_VERSION}-linux-amd64.deb\"\n\nGitHubからダウンロードするdebパッケージのURLを構築\nローカルに保存するファイル名を設定\n\n既存のQuartoの削除\nif command -v quarto &&gt; /dev/null; then\n    echo \"Removing existing Quarto installation...\"\n    sudo dpkg -r quarto || echo \"Quarto was not fully removed, continuing...\"\nfi\n\n既存のQuartoインストールを検出して削除\n削除に失敗してもスクリプトは継続\n\n新バージョンのインストール\necho \"Downloading Quarto version ${QUARTO_VERSION}...\"\ncurl -L -o \"$DEB_FILE\" \"$DEB_URL\"\n\necho \"Installing Quarto...\"\nsudo gdebi \"$DEB_FILE\" || { echo \"Installation failed.\"; exit 1; }\n\ngdebi コマンドでインストールを実行\ndpkg -iでも良いが，gdebiは必要な依存関係を自動で解決してくれます\n\nインストール確認\nif command -v quarto &&gt; /dev/null; then\n    echo \"Quarto version: $(quarto --version)\"\n    quarto check\nelse\n    echo \"Quarto installation failed. Please check the logs.\"\n    exit 1\nfi\n\nインストールが成功したか確認\n新しいバージョンを表示\nquarto checkでシステム要件を確認\n\ncommand -v quarto &&gt; /dev/null コマンド\ncommand -v &lt;command-name&gt;\nシェルの組み込みコマンドで指定されたコマンドのパスを探索してくれます\n\n\n\n\n項目\n説明\n\n\n\n\ncommand\nシェルの組み込みコマンドで，指定されたコマンドのパスを探索\n\n\n-v\nコマンドのフルパスを表示\n\n\nquarto\nここでは検索対象のコマンド名\n\n\n&&gt;\n標準出力(stdout)と標準エラー出力(stderr)の両方をリダイレクト\n\n\n/dev/null\n全ての出力を破棄する特殊なデバイスファイル\n\n\n\n\n&&gt; /dev/null を設定することによって，\n\nコマンドが見つかった場合: パスの出力は/dev/nullに捨てた上で，exit 0（終了コード0）\nコマンドが見つからない場合: エラーメッセージは/dev/nullに捨てられるが，exit 1（終了コード1） 扱い\n\n不要な .deb ファイルの削除\nrm -f \"$DEB_FILE\"\necho \"Temporary files cleaned up.\"\n\nダウンロードした.debパッケージを削除"
  },
  {
    "objectID": "posts/2025-08-27-bias-variance-tradeoff/index.html",
    "href": "posts/2025-08-27-bias-variance-tradeoff/index.html",
    "title": "Bias-Variance Tradeoff",
    "section": "",
    "text": "何かしらのパラメータ \\(\\theta\\) の推定量の性質を考えるとき，基本的には推定誤差\n\\[\n\\hat\\theta - \\theta\n\\]\nの分布についてまず考えます．この評価手法の１例としてRMSEが挙げられます．\n\\[\n\\operatorname{RMSE} = \\sqrt{\\mathbb E_{\\pmb\\theta}[(\\hat\\theta - \\theta)^2]}\n\\]\nRMSEの単位は \\(\\theta\\) の単位と同じなので，誤差のスケールを直感的に理解しやすいというメリットがあります．ただし，推定量の性質を考えるときはMSEのほうが取り回しが良いときが多いのでMSEの次に考えます．\n\nDefinition 1 MSE\n\n\\[\n\\begin{align}\n\\operatorname{MSE}\n  &= \\mathbb E_{\\pmb\\theta}[(\\hat\\theta - \\theta)^2] \\\\\n  &= \\mathbb E_{\\pmb\\theta}[(\\hat\\theta - \\mathbb E_{\\pmb\\theta}[\\hat\\theta] + \\mathbb E_{\\pmb\\theta}[\\hat\\theta] - \\theta)^2] \\\\\n  &= \\mathbb E_{\\pmb\\theta}[(\\hat\\theta - \\mathbb E_{\\pmb\\theta}[\\hat\\theta])^2] + \\mathbb E_{\\pmb\\theta}[(\\mathbb E_{\\pmb\\theta}[\\hat\\theta] - \\theta)^2] + 2\\mathbb E_{\\pmb\\theta}[(\\hat\\theta - \\mathbb E_{\\pmb\\theta}[\\hat\\theta])(\\mathbb E_{\\pmb\\theta}[\\hat\\theta] - \\theta)] \\\\\n  &= \\mathbb E_{\\pmb\\theta}[(\\hat\\theta - \\mathbb E_{\\pmb\\theta}[\\hat\\theta])^2] + (\\mathbb E_{\\pmb\\theta}[\\hat\\theta] - \\theta)^2 \\\\\n  &= \\operatorname{Variance} + \\operatorname{Bias}^2\n\\end{align}\n\\]\n\n\n上記の定義よりMSEは以下のように分解されます\n\\[\n\\operatorname{MSE} = \\operatorname{Variance} + \\operatorname{Bias}^2\n\\]\n\nExample 1 \n\\(\\{X_1, \\cdots, X_n\\}\\) がなにかしらの分布 \\(D(\\mu, \\sigma)\\) からのi.i.dサンプルだとします．なお，\\(\\mu\\neq 0\\), \\(\\mathbb E[X_i^4] &lt; \\infty\\) とします．\n\\(\\sigma^2\\) の推定量の候補として\n\\[\n\\sigma^2 = \\mathbb E[X^2] - \\mathbb E[X]^2\n\\]\nであるので，\n\\[\n\\begin{align}\n\\overline{X^2} &= \\frac{1}{n}\\sum_{i=1}^n X_i^2\\\\\n\\overline{X} &= \\frac{1}{n}\\sum_{i=1}^n X_i\\\\\n\\hat\\sigma^2 &= \\overline{X^2} - \\overline{X}^2\n\\end{align}\n\\]\nこのとき，\n\\[\n\\begin{align}\n\\mathbb E[(\\overline{X})^2]\n  &= \\operatorname{Var}(\\overline{X}) + (\\mathbb E[\\overline{X}])^2\\\\\n  &= \\frac{1}{n}\\sigma^2 + \\mu^2\n\\end{align}\n\\]\n\\[\n\\begin{align}\n\\mathbb E[\\overline{X^2}]\n  &= \\frac{1}{n}\\sum_{i=1}^n\\mathbb E[X_i^2]\\\\\n  &= \\sigma^2 + \\mu^2\n\\end{align}\n\\]\n従って，\\(\\hat\\sigma^2\\) のBiasは\n\\[\n\\begin{align}\n\\mathbb E[\\hat\\sigma^2] - \\sigma^2\n  &= \\mathbb E[\\overline{X^2}] - \\mathbb E[(\\overline{X})^2] - \\sigma^2\\\\\n  &= \\sigma^2 + \\mu^2 - \\frac{1}{n}\\sigma^2 - \\mu^2 \\sigma^2\\\\\n  &= - \\frac{1}{n}\\sigma^2\n\\end{align}\n\\]\n一方，\\(\\hat\\sigma^2\\) のVarianceは，Delta methodを用いた漸近近似により\n\\[\n\\begin{align}\n\\operatorname{Var}(\\hat\\sigma^2)\n  &= \\operatorname{Var}(\\overline{X^2}) + \\operatorname{Var}(\\overline{X}^2)\\\\\n  &\\approx  \\frac{1}{n}\\operatorname{Var}(X_i^2) + (2\\mu)^2\\frac{\\sigma^2}{n}\\\\\n  &= \\mathcal{O}(n^{-1})\n\\end{align}\n\\]\n\nRemark 1. \nLarge Samplesの場合は，\n\n\\(\\operatorname{Variance}\\) は \\(1/n\\) の速さで小さくなる\n\\(\\operatorname{Bias}^2\\) は \\(1/n^2\\) の速さで小さくなる\n\n以上より \\(\\operatorname{MSE}\\) を最小化したい場合はvarianceの方を小さくするのが有効であることがわかる．\n\n\n\n\nExample 2 MSEの比較\n\\[\n\\begin{align}\n\\{X_1, \\cdots, X_n\\} \\overset{\\mathrm{iid}}{\\sim} N(\\mu, \\sigma^2) \\label{eq-exm}\n\\end{align}\n\\]\nとしたとき，\\(\\sigma^2\\) のunbiased estimatorとして\n\\[\nS^2 = \\frac{1}{n-1}\\sum_{i=1}^n (X_i - \\overline{X})^2 \\label{eq-exm-2}\n\\]\nが考えられます．このとき，かんたんな計算により Example 1 の推定量との関係として\n\\[\nS^2 = \\frac{n}{n-1}\\hat\\sigma^2\n\\]\n\\(\\eqref{eq-exm}\\) と \\(\\eqref{eq-exm-2}\\) より\n\\[\n(n-1)\\frac{S^2}{\\sigma^2} \\sim \\operatorname{\\chi^2}(n-1)\n\\]\n従って，\n\\[\n\\operatorname{Var}(S^2)=\\frac{2}{n-1}\\sigma^4\n\\]\n\\(\\operatorname{MSE}(S^2)\\) と \\(\\operatorname{MSE}(\\hat\\sigma^2)\\) を比較すると，\n\\[\n\\begin{align}\n\\operatorname{MSE}(\\hat\\sigma^2)\n  &= \\mathbb E[(\\hat\\sigma^2 - \\sigma^2)^2]\\\\\n  &= \\frac{2(n-1)}{n^2}\\sigma^4 + \\frac{1}{n^2}\\sigma^4\\\\\n  &= \\frac{2n-1}{n^2}\\sigma^4\\\\\n  &&lt; \\frac{2}{n-1}\\sigma^4\\\\\n  &= \\operatorname{Var}(S^2)\\\\\n  &= \\operatorname{MSE}(S^2)\n\\end{align}\n\\]"
  },
  {
    "objectID": "posts/2025-08-27-bias-variance-tradeoff/index.html#統計的推測とbias-variance-tradeoff",
    "href": "posts/2025-08-27-bias-variance-tradeoff/index.html#統計的推測とbias-variance-tradeoff",
    "title": "Bias-Variance Tradeoff",
    "section": "",
    "text": "何かしらのパラメータ \\(\\theta\\) の推定量の性質を考えるとき，基本的には推定誤差\n\\[\n\\hat\\theta - \\theta\n\\]\nの分布についてまず考えます．この評価手法の１例としてRMSEが挙げられます．\n\\[\n\\operatorname{RMSE} = \\sqrt{\\mathbb E_{\\pmb\\theta}[(\\hat\\theta - \\theta)^2]}\n\\]\nRMSEの単位は \\(\\theta\\) の単位と同じなので，誤差のスケールを直感的に理解しやすいというメリットがあります．ただし，推定量の性質を考えるときはMSEのほうが取り回しが良いときが多いのでMSEの次に考えます．\n\nDefinition 1 MSE\n\n\\[\n\\begin{align}\n\\operatorname{MSE}\n  &= \\mathbb E_{\\pmb\\theta}[(\\hat\\theta - \\theta)^2] \\\\\n  &= \\mathbb E_{\\pmb\\theta}[(\\hat\\theta - \\mathbb E_{\\pmb\\theta}[\\hat\\theta] + \\mathbb E_{\\pmb\\theta}[\\hat\\theta] - \\theta)^2] \\\\\n  &= \\mathbb E_{\\pmb\\theta}[(\\hat\\theta - \\mathbb E_{\\pmb\\theta}[\\hat\\theta])^2] + \\mathbb E_{\\pmb\\theta}[(\\mathbb E_{\\pmb\\theta}[\\hat\\theta] - \\theta)^2] + 2\\mathbb E_{\\pmb\\theta}[(\\hat\\theta - \\mathbb E_{\\pmb\\theta}[\\hat\\theta])(\\mathbb E_{\\pmb\\theta}[\\hat\\theta] - \\theta)] \\\\\n  &= \\mathbb E_{\\pmb\\theta}[(\\hat\\theta - \\mathbb E_{\\pmb\\theta}[\\hat\\theta])^2] + (\\mathbb E_{\\pmb\\theta}[\\hat\\theta] - \\theta)^2 \\\\\n  &= \\operatorname{Variance} + \\operatorname{Bias}^2\n\\end{align}\n\\]\n\n\n上記の定義よりMSEは以下のように分解されます\n\\[\n\\operatorname{MSE} = \\operatorname{Variance} + \\operatorname{Bias}^2\n\\]\n\nExample 1 \n\\(\\{X_1, \\cdots, X_n\\}\\) がなにかしらの分布 \\(D(\\mu, \\sigma)\\) からのi.i.dサンプルだとします．なお，\\(\\mu\\neq 0\\), \\(\\mathbb E[X_i^4] &lt; \\infty\\) とします．\n\\(\\sigma^2\\) の推定量の候補として\n\\[\n\\sigma^2 = \\mathbb E[X^2] - \\mathbb E[X]^2\n\\]\nであるので，\n\\[\n\\begin{align}\n\\overline{X^2} &= \\frac{1}{n}\\sum_{i=1}^n X_i^2\\\\\n\\overline{X} &= \\frac{1}{n}\\sum_{i=1}^n X_i\\\\\n\\hat\\sigma^2 &= \\overline{X^2} - \\overline{X}^2\n\\end{align}\n\\]\nこのとき，\n\\[\n\\begin{align}\n\\mathbb E[(\\overline{X})^2]\n  &= \\operatorname{Var}(\\overline{X}) + (\\mathbb E[\\overline{X}])^2\\\\\n  &= \\frac{1}{n}\\sigma^2 + \\mu^2\n\\end{align}\n\\]\n\\[\n\\begin{align}\n\\mathbb E[\\overline{X^2}]\n  &= \\frac{1}{n}\\sum_{i=1}^n\\mathbb E[X_i^2]\\\\\n  &= \\sigma^2 + \\mu^2\n\\end{align}\n\\]\n従って，\\(\\hat\\sigma^2\\) のBiasは\n\\[\n\\begin{align}\n\\mathbb E[\\hat\\sigma^2] - \\sigma^2\n  &= \\mathbb E[\\overline{X^2}] - \\mathbb E[(\\overline{X})^2] - \\sigma^2\\\\\n  &= \\sigma^2 + \\mu^2 - \\frac{1}{n}\\sigma^2 - \\mu^2 \\sigma^2\\\\\n  &= - \\frac{1}{n}\\sigma^2\n\\end{align}\n\\]\n一方，\\(\\hat\\sigma^2\\) のVarianceは，Delta methodを用いた漸近近似により\n\\[\n\\begin{align}\n\\operatorname{Var}(\\hat\\sigma^2)\n  &= \\operatorname{Var}(\\overline{X^2}) + \\operatorname{Var}(\\overline{X}^2)\\\\\n  &\\approx  \\frac{1}{n}\\operatorname{Var}(X_i^2) + (2\\mu)^2\\frac{\\sigma^2}{n}\\\\\n  &= \\mathcal{O}(n^{-1})\n\\end{align}\n\\]\n\nRemark 1. \nLarge Samplesの場合は，\n\n\\(\\operatorname{Variance}\\) は \\(1/n\\) の速さで小さくなる\n\\(\\operatorname{Bias}^2\\) は \\(1/n^2\\) の速さで小さくなる\n\n以上より \\(\\operatorname{MSE}\\) を最小化したい場合はvarianceの方を小さくするのが有効であることがわかる．\n\n\n\n\nExample 2 MSEの比較\n\\[\n\\begin{align}\n\\{X_1, \\cdots, X_n\\} \\overset{\\mathrm{iid}}{\\sim} N(\\mu, \\sigma^2) \\label{eq-exm}\n\\end{align}\n\\]\nとしたとき，\\(\\sigma^2\\) のunbiased estimatorとして\n\\[\nS^2 = \\frac{1}{n-1}\\sum_{i=1}^n (X_i - \\overline{X})^2 \\label{eq-exm-2}\n\\]\nが考えられます．このとき，かんたんな計算により Example 1 の推定量との関係として\n\\[\nS^2 = \\frac{n}{n-1}\\hat\\sigma^2\n\\]\n\\(\\eqref{eq-exm}\\) と \\(\\eqref{eq-exm-2}\\) より\n\\[\n(n-1)\\frac{S^2}{\\sigma^2} \\sim \\operatorname{\\chi^2}(n-1)\n\\]\n従って，\n\\[\n\\operatorname{Var}(S^2)=\\frac{2}{n-1}\\sigma^4\n\\]\n\\(\\operatorname{MSE}(S^2)\\) と \\(\\operatorname{MSE}(\\hat\\sigma^2)\\) を比較すると，\n\\[\n\\begin{align}\n\\operatorname{MSE}(\\hat\\sigma^2)\n  &= \\mathbb E[(\\hat\\sigma^2 - \\sigma^2)^2]\\\\\n  &= \\frac{2(n-1)}{n^2}\\sigma^4 + \\frac{1}{n^2}\\sigma^4\\\\\n  &= \\frac{2n-1}{n^2}\\sigma^4\\\\\n  &&lt; \\frac{2}{n-1}\\sigma^4\\\\\n  &= \\operatorname{Var}(S^2)\\\\\n  &= \\operatorname{MSE}(S^2)\n\\end{align}\n\\]"
  },
  {
    "objectID": "posts/2025-08-27-bias-variance-tradeoff/index.html#cef-decomposition-property",
    "href": "posts/2025-08-27-bias-variance-tradeoff/index.html#cef-decomposition-property",
    "title": "Bias-Variance Tradeoff",
    "section": "CEF Decomposition Property",
    "text": "CEF Decomposition Property\n\nTheorem 1 CEF Decomposition Property\n\\[\nY_i = \\mathbb E[Y_i|X_i] + \\epsilon_i\n\\]\n\n\n\\(\\mathbb E[\\epsilon_i | X_i] = 0\\): \\(\\epsilon_i\\) is mean independent of \\(X_i\\)\n\\(\\epsilon_i\\) is uncorrelated with any function of \\(X_i\\)\n\n\n\n\n\n\n\n\n\nNoteProof (i)\n\n\n\n\n\n\\[\n\\begin{align}\n\\mathbb E[\\epsilon_i | X_i]\n  &= \\mathbb E[Y_i - \\mathbb E[Y_i|X_i]|X_i]\\\\[3pt]\n  &= \\mathbb E[Y_i|X_i] - \\mathbb E[Y_i|X_i]\\\\[3pt]\n  &= 0\n\\end{align}\n\\]\n\n\n\n\n\n\n\n\n\nNoteProof (ii)\n\n\n\n\n\n\\(b(X_i)\\) を \\(X_i\\) についての任意の関数とするとき\n\\[\n\\begin{align}\n\\mathbb E[b(X_i)\\epsilon]\n  &= \\mathbb E[\\mathbb E[b(X_i)\\epsilon | X_i]]\\\\\n  &= \\mathbb E[b(X_i)\\mathbb E[\\epsilon | X_i]]\\\\\n  &= 0\n\\end{align}\n\\]\n従って，\\(X_i\\) についての任意の関数と \\(\\epsilon_i\\) は無相関(uncorrelated, orthogonal)であることがわかる．\n\n\n\n\nTheorem 2 CEFとMSE\n\\(m(X_i)\\) を \\(X_i\\) の関数とするとき，\n\\[\n\\mathbb E[Y_i | X_i]\n  = \\underset{m(X_i)}{\\arg\\min}\\mathbb E[(Y_i - m(X_i))^2]\n\\]\nつまり，\\(\\mathbb E[Y_i | X_i]\\) は \\(X_i\\) で条件づけた \\(Y_i\\) の予測関数についてのMinimum Mean Squared Error(MMSE) である．\n\n\n\n\n\n\n\nNoteProof\n\n\n\n\n\n\n\\[\n\\begin{align}\n(Y_i - m(X_i))^2\n  &= (Y_i - \\mathbb E[Y_i | X_i] + \\mathbb E[Y_i | X_i] - m(X_i))^2\\\\\n  &= (Y_i - \\mathbb E[Y_i | X_i])^2 + 2(Y_i - \\mathbb E[Y_i | X_i])(\\mathbb E[Y_i | X_i] - m(X_i))^2 + (\\mathbb E[Y_i | X_i] - m(X_i))^2\\\\\n  &= \\epsilon^2 + 2\\epsilon(\\mathbb E[Y_i | X_i] - m(X_i)) + (\\mathbb E[Y_i | X_i] - m(X_i))^2\n\\end{align}\n\\]\n\n期待値を取ると\n\n\\[\n\\mathbb E[(Y_i - m(X_i))^2] = \\mathbb E[\\epsilon_i^2] + \\mathbb E[(\\mathbb E[Y_i | X_i] - m(X_i))^2]\n\\]\n\n従って，\n\\[\nE[Y_i | X_i] = m(X_i)\n\\]\nのときMSEの意味で \\(E[Y_i | X_i]\\) が最小化関数であることがわかる．"
  },
  {
    "objectID": "posts/2025-06-12-moles-and-gas-volume/index.html",
    "href": "posts/2025-06-12-moles-and-gas-volume/index.html",
    "title": "物質量と気体の体積",
    "section": "",
    "text": "物質の量を表すときには，質量や体積を用いることが多いです．しかし，物質が化学変化するときには，物質を構成する原子，分子，イオンなどの粒子の結合の組み合わせが変化 します．そのため，化学で物質の量を表すときには，その中に含まれる粒子の「個数」で考えると便利になります．この粒子の個数に着目して表した物質の量を「物質量」といい，モル (mol) という単位で 表します．\n\nDefinition 1 (アボガドロ定数) \n原子や分子 1 mol あたりの粒子の数を示す次元をもつ物理量で\n\\[\nN_A = 6.0 \\times 10^{23} \\text{/mol}\n\\]\n\n質量数 12 の炭素原子 \\(\\,^{12}\\text{C}\\) は \\(1.99 \\times 10^{-23}\\) g という決まった質量を持ちますがこのときの炭素原子の数は\n\\[\n\\frac{12\\text{g}}{1.99 \\times 10^{-23}} \\approx 6.0 \\times 10^{23}\n\\]\n計算でき，これをアボガドロ数といいます．アボガドロ数に \\(\\text{mol}^{-1}\\) の単位をつけたのがアボガドロ定数です．物質 \\(1\\) molあたりの質量を モル質量 [g/mol] と呼びます．\n\nExample 1 (実験でアボガドロ定数を求める) \n１円玉は1gのアルミニウムからできています．室温でのアルミニウム密度は2.7\\(\\text{g/cm}^3\\)なので体積は\n\\[\n\\text{1円玉体積} = \\frac{1\\text{g}}{2.7\\text{g/cm}^3} = 1/2.7\\text{cm}^3\n\\]\n金属の固体では，金属の原子が規則正しく配列して金属結晶をつくっていて，結晶中の規則的な粒子の配列を結晶格子といいますその中に現れる最小の繰り返し単位を「単位格子」といい，アルミニウムは 面心立方格子の構造で，1 辺の長さが \\(4.04 × 10^{-8}\\) cm の立方体（単位格子）中に原子が正味４個分，含まれています．\n以上より\n\\[\nN_A = \\frac{\\text{1円玉体積[cm]}^3}{\\text{単位格子体積[cm]}^3} \\times 4 \\times \\frac{\\text{アルミニウムモル質量[g/mol]}}{\\text{1円玉質量[g]}}\n\\]\nとなるはずなので\n\n\nCode\nimport numpy as np\n\ncoin_volumn = np.float64(1 / 2.7)\ngrid_length = np.float64(4.04 * 10 ** (-8))\nal_mol_mass = np.float64(27)\n\nnumber_of_molecules = coin_volumn / (grid_length ** 3) * 4 * al_mol_mass\n\nprint(f\"{{{number_of_molecules:.2e}}}\")\n\n\n{6.07e+23}\n\n\nよってアボガドロ定数が計算できました．\n\n\n\nDefinition 2 (アボガドロの法則) \n同温・同圧で同体積の気体の中には，気体の種類によらず，同数の分子が含まれる．\n\n実測によると [0℃, \\(1.013 \\times 10^5\\) Pa] において，多くの気体 \\(1\\) mol の体積は 22.4 Lになります． この物質 1 molあたりの体積をモル体積と呼び，標準気圧での気体のモル体積は 22.4L/mol になります．\n気体の物質量はこの関係式を用いると以下のように求めることができます\n\\[\n\\text{気体の物質量[mol]} = \\frac{\\text{標準状態での気体の体積[L]}}{22.4 \\text{L/mol}}\n\\]\n\nExample 2 (二酸化炭素の体積を求める) \n二酸化炭素の個体である「ドライアイス」が11g与えられているとき，これを [0℃, \\(1.013 \\times 10^5\\) Pa] のもとで気化させたときの二酸化炭素の体積を求めてみます．\nまず二酸化炭素 \\(\\text{CO}_2\\) は \\(44 \\text{g/mol} = 12 + 2\\times 16\\) とします．\n\n\n\n\n元素名\n元素記号\n原子番号\n原子量\n\n\n\n\n炭素\nC\n6\n12.0107\n\n\n酸素\nO\n8\n15.9994\n\n\n\n\n11.0gのドライアイスの物質量は\n\\[\n\\frac{11.0\\text{g}}{44 \\text{g/mol}} = 0.25\\text{mol}\n\\]\nアボガドロの法則より， [0℃, \\(1.013 \\times 10^5\\) Pa] において，気体 \\(1\\) mol の体積は 22.4 Lになるので，気化した二酸化炭素の体積は\n\\[\n22.4\\text{L/mol} \\times 0.25\\text{mol} = 5.6 \\text{L}\n\\]\nと推定することができます．室温（約23℃）でドライアイスを昇華させたとき，1 mol の二酸化炭素が占める体積は 22.4 L にはなりません．直感的イメージとして， ボイル・シャルルの法則より同じ気体のもとでは温度と体積は比例するので，もうすこし大きい体積となります．\n\n\n\nExample 3 (一般気体定数) \n1 molの気体は，アボガドロの法則より，気体の種類関係なく同温・同圧で同体積の気体の中に同数の分子が含まれます．ボイル=シャルルの法則という理想気体の性質に関する経験法則，及び \\(0 \\,^\\circ\\text{C}\\), 1気圧(\\(1.013\\times 10^5\\) [Pa]) の標準状態では22.4Lの体積の中に含まれることから気体定数を以下のように計算できます\n\\[\n\\begin{align}\nR_0\n  &= \\frac{pv}{T}\\\\\n  &= \\frac{1.013 \\times 10^5 \\times 22.4}{273 \\times 10^3}\\\\\n  &= 8.31 \\text{[J/mol}\\cdot\\text{K]}\n\\end{align}\n\\]\nこれを \\(n\\) モルの理想気体に当てはめると\n\\[\npv = nR_0T\n\\]\nという理想気体の状態方程式を得ます．\n\n\n\n密度は単位体積あたりの質量を表した物理量で，固体・液体の密度は [g/cm3]，気体の密度は体積１ L あたりの質量 [g/L] の単位で表します． つまり，気体 1L あたりの質量を「気体の密度」になります．\n\n\n\n\n\n\nNoteシャボン玉でガス缶の中身を調べる\n\n\n\n\n水素 \\(\\text{H}_2\\), 酸素 \\(\\text{O}_2\\), 二酸化炭素 \\(\\text{CO}_2\\) がそれぞれ充填された３つのガス缶がある\nどの缶にどの気体が入っているのかわからない\n\nこのとき，どの缶にどの気体が入っているか知りたいとします．調べる一つの方法として，各気体で同じ大きさくらいに膨らませたシャボン玉をつくり密度を比較する方法が有ります． 標準状態における気体の密度は\n\\[\n\\frac{\\text{分子量[g]}}{22.4\\text{L/mol}}\n\\]\nで計算できるので，\n\\[\n\\begin{align}\n\\text{H}_2\\text{の密度} &= \\frac{2.0}{22.4} \\approx 0.089\\text{g/L}\\\\\n\\text{O}_2\\text{の密度} &= \\frac{32}{22.4} \\approx 1.4\\text{g/L}\\\\\n\\text{CO}_2\\text{の密度} &= \\frac{44}{22.4} \\approx 2.0\\text{g/L}\n\\end{align}\n\\]\n密度が重いほど，同じ環境下では下降速度は速くなることから．同程度の大きさのシャボン玉で下降するとき速さを比較すれば，どの缶にどんな気体が入っているのか推測することができます．\nなお，空気の平均分子量は，空気の組成を \\(\\text{N}_2 : \\text{O}_2 = 4:1\\) とすると\n\\[\n\\text{空気の平均分子量} = 28 \\times 0.8 + 32 \\times 0.2 = 28.8 \\text{g/mol}\n\\]\nとなることから，各期待の密度を計算するまでもなく，水素が入ったシャボン玉は上昇し，酸素が入ったシャボン玉は比較的ゆっくり下降，二酸化炭素が入ったシャボン玉は酸素のシャボン玉より速く下降するとわかります．\n\n\n\n\n\n気体の内部エネルギーを，温度 \\(T\\) と体積 \\(V\\) を独立変数として，\\(U = U(T, V)\\) と表すと\n\\[\n\\operatorname{grad} U \\equiv \\left(\\left(\\frac{\\partial U}{\\partial T}\\right)_V, \\left(\\frac{\\partial U}{\\partial V}\\right)_T\\right)\n\\]\nこれをもちいて整理すると\n\\[\ndU = \\left(\\frac{\\partial U}{\\partial T}\\right)_VdT + \\left(\\frac{\\partial U}{\\partial V}\\right)_TdV\n\\]\n熱力学第一法則より 気体が外部になす微小仕事 \\(dW = PdV\\) より\n\\[\ndQ =  \\left(\\frac{\\partial U}{\\partial T}\\right)_VdT + \\left[ \\left(\\frac{\\partial U}{\\partial V}\\right)_T + P\\right]dV \\label{temp-vol-eq}\n\\]\n\n\n体積一定の容器に入れた気体に熱を加える場合を考えます．\\(\\eqref{temp-vol-eq}\\) で \\(dV = 0\\) とおけるので\n\\[\ndQ =  \\left(\\frac{\\partial U}{\\partial T}\\right)_VdT\n\\]\nここから体積一定のもとで，気体の温度を単位温度上げるのに必要な熱量は\n\\[\n\\frac{dQ}{dT} = \\left(\\frac{\\partial U}{\\partial T}\\right)_V\n\\]\nこれをモル数 \\(n\\) で割ると定積モル比熱になります．\n\nDefinition 3 定積モル比熱\n定積モル比熱 \\(C_v\\) [J/mol･K] は以下のように定義される\n\\[\nC_v = \\frac{1}{n} \\left(\\frac{\\partial Q}{\\partial T}\\right)_V = \\frac{1}{n} \\left(\\frac{\\partial U}{\\partial T}\\right)_V\n\\]\n\n圧力一定の条件下で1モルあたりの物質の温度を 1 K 上げるのに必要な熱量を考えます．これは定圧モル比熱 \\(C_p\\) と呼び，\n\\[\nC_p = C_v + \\left[ \\left(\\frac{\\partial U}{\\partial V}\\right)_T + P\\right]\\frac{1}{n}\\left(\\frac{\\partial V}{\\partial T}\\right)_P\n\\]\nマイヤーの関係式\n単原子分子理想気体では状態方程式\n\\[\n\\frac{PV}{T} = nR\n\\]\nが成立するので\n\\[\n\\left(\\frac{\\partial V}{\\partial T}\\right)_P = n\\frac{R}{P}\n\\]\nまた，内部エネルギーも\n\\[\nU = \\frac{3}{2}nRT\n\\]\nであるので \\(\\displaystyle  \\left(\\frac{\\partial U}{\\partial V}\\right)_T  = 0\\) より\n\\[\nC_p = C_v + R\n\\]\nというマイヤーの関係式が得られます．\n\n\n\n\n\nExercise 1 センター2016物理追試第５問「ぶら下がるシリンダーと熱力学第１法則」\n\n\nシリンダーが (a) の状態で静止しているとき，\\(P\\) を \\(P_0, M, g, S\\) の関数として表せ\nシリンダー内の気体を温めると，シリンダーはゆっくり下降し，(b) の状態で静止した．このとき，体積の変化 \\(\\Delta V\\) と 内部エネルギー \\(\\Delta U\\) は \\(\\Delta T\\) の関数としてどのように表せるか？\n\n\n\n\n\n\n\n\nNoteSolution\n\n\n\n\n\n1. シリンダーが (a) の状態で静止しているとき，\\(P\\) を \\(P_0, M, g, S\\) の関数として表せ\n下向きの力の一つとして\n\\[\n\\text{質量} \\times \\text{加速度} = \\text{力}\n\\]\nよって, \\(Mg\\) という力が下向きに働いています． また，シリンダー内部の圧力 \\(P\\) も下向きの力として働くので\n\\[\n\\text{下向きの力} = S\\times P + Mg\n\\]\n上向きの力として，\\(P_0\\times S\\) があり，初期状態では静止している = 上向きと下向きの力が均衡しているので\n\\[\nS\\times P + Mg = S\\times P_0\n\\]\nしたがって，\n\\[\nP = P_0 = \\frac{Mg}{S}\n\\]\n2. シリンダー内の気体を温めると，シリンダーはゆっくり下降し，(b) の状態で静止した．このとき，体積の変化 \\(\\Delta V\\) と 内部エネルギー \\(\\Delta U\\) は \\(\\Delta T\\) の関数としてどのように表せるか？\n単原子分子理想気体では内部エネルギーは\n\\[\nU = \\frac{3}{2}RT\n\\]\nしたがって\n\\[\n\\Delta U = \\frac{3}{2}R\\Delta T\n\\]\nまた，状態変化後も圧力は \\(P\\) で同じなので，理想気体の状態方程式より\n\\[\n\\frac{V}{T} = \\frac{V + \\Delta V}{T + \\Delta T}\n\\]\nしたがって，\n\\[\n\\Delta V = \\frac{V}{T}\\Delta T\n\\]\n\n\n\n\nExercise 2 運動エネルギーと温度と圧力\n密閉された炉に一箇所小さな孔が空いている．\n\n孔の厚さは0\n炉外の空気は温度が0℃で圧力は100kPa\n炉内の空気は温度調整して57℃で一定\n空気は理想気体とする\n\n十分時間が経った後は圧力が一定になるとして，この定常的な状態での炉内の圧力を求めよ．\nただし，分子の自乗平均速度は平均速度の自乗と一致するとする．\n\n\n\n\n\n\n\nNoteSolution\n\n\n\n\n\n炉内を1，炉外を2とすると，平衡状態では炉外へ出る分子と炉外から入る分子の数が等しいはずなので，\n\\[\nAv_1N_1t = Av_2N_2t\n\\]\n\n\\(v_i\\) 分子の平均速度\n\\(A\\): 孔の断面積\n\\(N_i\\): 個数密度\n\\(t\\): 単位時間\n\n理想気体においては\n\\[\n\\frac{3}{2}k_BT = \\frac{1}{2}m\\overline{v^2}\n\\]\nと温度は自乗平均速度に比例する．また理想気体の状態方程式より，個数密度は圧力 \\(P\\) に比例し，温度 \\(T\\) に反比例するので\n\\[\n\\begin{align}\n\\frac{v_1}{v_2} &= \\sqrt{\\frac{T_1}{T_2}}\\\\\n\\frac{N_1}{N_2} &= \\frac{P_1}{P_2}\\frac{T_2}{T_1}\n\\end{align}\n\\]\nしたがって，\n\\[\n\\begin{align}\np_1\n  &= p_2\\sqrt{\\frac{T_1}{T_2}}\\\\\n  &= 100\\text{kPa} \\times \\sqrt{\\frac{330.15}{273.15}}\\\\\n  &\\approx 110\\text{kPa}\n\\end{align}\n\\]"
  },
  {
    "objectID": "posts/2025-06-12-moles-and-gas-volume/index.html#物質量",
    "href": "posts/2025-06-12-moles-and-gas-volume/index.html#物質量",
    "title": "物質量と気体の体積",
    "section": "",
    "text": "物質の量を表すときには，質量や体積を用いることが多いです．しかし，物質が化学変化するときには，物質を構成する原子，分子，イオンなどの粒子の結合の組み合わせが変化 します．そのため，化学で物質の量を表すときには，その中に含まれる粒子の「個数」で考えると便利になります．この粒子の個数に着目して表した物質の量を「物質量」といい，モル (mol) という単位で 表します．\n\nDefinition 1 (アボガドロ定数) \n原子や分子 1 mol あたりの粒子の数を示す次元をもつ物理量で\n\\[\nN_A = 6.0 \\times 10^{23} \\text{/mol}\n\\]\n\n質量数 12 の炭素原子 \\(\\,^{12}\\text{C}\\) は \\(1.99 \\times 10^{-23}\\) g という決まった質量を持ちますがこのときの炭素原子の数は\n\\[\n\\frac{12\\text{g}}{1.99 \\times 10^{-23}} \\approx 6.0 \\times 10^{23}\n\\]\n計算でき，これをアボガドロ数といいます．アボガドロ数に \\(\\text{mol}^{-1}\\) の単位をつけたのがアボガドロ定数です．物質 \\(1\\) molあたりの質量を モル質量 [g/mol] と呼びます．\n\nExample 1 (実験でアボガドロ定数を求める) \n１円玉は1gのアルミニウムからできています．室温でのアルミニウム密度は2.7\\(\\text{g/cm}^3\\)なので体積は\n\\[\n\\text{1円玉体積} = \\frac{1\\text{g}}{2.7\\text{g/cm}^3} = 1/2.7\\text{cm}^3\n\\]\n金属の固体では，金属の原子が規則正しく配列して金属結晶をつくっていて，結晶中の規則的な粒子の配列を結晶格子といいますその中に現れる最小の繰り返し単位を「単位格子」といい，アルミニウムは 面心立方格子の構造で，1 辺の長さが \\(4.04 × 10^{-8}\\) cm の立方体（単位格子）中に原子が正味４個分，含まれています．\n以上より\n\\[\nN_A = \\frac{\\text{1円玉体積[cm]}^3}{\\text{単位格子体積[cm]}^3} \\times 4 \\times \\frac{\\text{アルミニウムモル質量[g/mol]}}{\\text{1円玉質量[g]}}\n\\]\nとなるはずなので\n\n\nCode\nimport numpy as np\n\ncoin_volumn = np.float64(1 / 2.7)\ngrid_length = np.float64(4.04 * 10 ** (-8))\nal_mol_mass = np.float64(27)\n\nnumber_of_molecules = coin_volumn / (grid_length ** 3) * 4 * al_mol_mass\n\nprint(f\"{{{number_of_molecules:.2e}}}\")\n\n\n{6.07e+23}\n\n\nよってアボガドロ定数が計算できました．\n\n\n\nDefinition 2 (アボガドロの法則) \n同温・同圧で同体積の気体の中には，気体の種類によらず，同数の分子が含まれる．\n\n実測によると [0℃, \\(1.013 \\times 10^5\\) Pa] において，多くの気体 \\(1\\) mol の体積は 22.4 Lになります． この物質 1 molあたりの体積をモル体積と呼び，標準気圧での気体のモル体積は 22.4L/mol になります．\n気体の物質量はこの関係式を用いると以下のように求めることができます\n\\[\n\\text{気体の物質量[mol]} = \\frac{\\text{標準状態での気体の体積[L]}}{22.4 \\text{L/mol}}\n\\]\n\nExample 2 (二酸化炭素の体積を求める) \n二酸化炭素の個体である「ドライアイス」が11g与えられているとき，これを [0℃, \\(1.013 \\times 10^5\\) Pa] のもとで気化させたときの二酸化炭素の体積を求めてみます．\nまず二酸化炭素 \\(\\text{CO}_2\\) は \\(44 \\text{g/mol} = 12 + 2\\times 16\\) とします．\n\n\n\n\n元素名\n元素記号\n原子番号\n原子量\n\n\n\n\n炭素\nC\n6\n12.0107\n\n\n酸素\nO\n8\n15.9994\n\n\n\n\n11.0gのドライアイスの物質量は\n\\[\n\\frac{11.0\\text{g}}{44 \\text{g/mol}} = 0.25\\text{mol}\n\\]\nアボガドロの法則より， [0℃, \\(1.013 \\times 10^5\\) Pa] において，気体 \\(1\\) mol の体積は 22.4 Lになるので，気化した二酸化炭素の体積は\n\\[\n22.4\\text{L/mol} \\times 0.25\\text{mol} = 5.6 \\text{L}\n\\]\nと推定することができます．室温（約23℃）でドライアイスを昇華させたとき，1 mol の二酸化炭素が占める体積は 22.4 L にはなりません．直感的イメージとして， ボイル・シャルルの法則より同じ気体のもとでは温度と体積は比例するので，もうすこし大きい体積となります．\n\n\n\nExample 3 (一般気体定数) \n1 molの気体は，アボガドロの法則より，気体の種類関係なく同温・同圧で同体積の気体の中に同数の分子が含まれます．ボイル=シャルルの法則という理想気体の性質に関する経験法則，及び \\(0 \\,^\\circ\\text{C}\\), 1気圧(\\(1.013\\times 10^5\\) [Pa]) の標準状態では22.4Lの体積の中に含まれることから気体定数を以下のように計算できます\n\\[\n\\begin{align}\nR_0\n  &= \\frac{pv}{T}\\\\\n  &= \\frac{1.013 \\times 10^5 \\times 22.4}{273 \\times 10^3}\\\\\n  &= 8.31 \\text{[J/mol}\\cdot\\text{K]}\n\\end{align}\n\\]\nこれを \\(n\\) モルの理想気体に当てはめると\n\\[\npv = nR_0T\n\\]\nという理想気体の状態方程式を得ます．\n\n\n\n密度は単位体積あたりの質量を表した物理量で，固体・液体の密度は [g/cm3]，気体の密度は体積１ L あたりの質量 [g/L] の単位で表します． つまり，気体 1L あたりの質量を「気体の密度」になります．\n\n\n\n\n\n\nNoteシャボン玉でガス缶の中身を調べる\n\n\n\n\n水素 \\(\\text{H}_2\\), 酸素 \\(\\text{O}_2\\), 二酸化炭素 \\(\\text{CO}_2\\) がそれぞれ充填された３つのガス缶がある\nどの缶にどの気体が入っているのかわからない\n\nこのとき，どの缶にどの気体が入っているか知りたいとします．調べる一つの方法として，各気体で同じ大きさくらいに膨らませたシャボン玉をつくり密度を比較する方法が有ります． 標準状態における気体の密度は\n\\[\n\\frac{\\text{分子量[g]}}{22.4\\text{L/mol}}\n\\]\nで計算できるので，\n\\[\n\\begin{align}\n\\text{H}_2\\text{の密度} &= \\frac{2.0}{22.4} \\approx 0.089\\text{g/L}\\\\\n\\text{O}_2\\text{の密度} &= \\frac{32}{22.4} \\approx 1.4\\text{g/L}\\\\\n\\text{CO}_2\\text{の密度} &= \\frac{44}{22.4} \\approx 2.0\\text{g/L}\n\\end{align}\n\\]\n密度が重いほど，同じ環境下では下降速度は速くなることから．同程度の大きさのシャボン玉で下降するとき速さを比較すれば，どの缶にどんな気体が入っているのか推測することができます．\nなお，空気の平均分子量は，空気の組成を \\(\\text{N}_2 : \\text{O}_2 = 4:1\\) とすると\n\\[\n\\text{空気の平均分子量} = 28 \\times 0.8 + 32 \\times 0.2 = 28.8 \\text{g/mol}\n\\]\nとなることから，各期待の密度を計算するまでもなく，水素が入ったシャボン玉は上昇し，酸素が入ったシャボン玉は比較的ゆっくり下降，二酸化炭素が入ったシャボン玉は酸素のシャボン玉より速く下降するとわかります．\n\n\n\n\n\n気体の内部エネルギーを，温度 \\(T\\) と体積 \\(V\\) を独立変数として，\\(U = U(T, V)\\) と表すと\n\\[\n\\operatorname{grad} U \\equiv \\left(\\left(\\frac{\\partial U}{\\partial T}\\right)_V, \\left(\\frac{\\partial U}{\\partial V}\\right)_T\\right)\n\\]\nこれをもちいて整理すると\n\\[\ndU = \\left(\\frac{\\partial U}{\\partial T}\\right)_VdT + \\left(\\frac{\\partial U}{\\partial V}\\right)_TdV\n\\]\n熱力学第一法則より 気体が外部になす微小仕事 \\(dW = PdV\\) より\n\\[\ndQ =  \\left(\\frac{\\partial U}{\\partial T}\\right)_VdT + \\left[ \\left(\\frac{\\partial U}{\\partial V}\\right)_T + P\\right]dV \\label{temp-vol-eq}\n\\]\n\n\n体積一定の容器に入れた気体に熱を加える場合を考えます．\\(\\eqref{temp-vol-eq}\\) で \\(dV = 0\\) とおけるので\n\\[\ndQ =  \\left(\\frac{\\partial U}{\\partial T}\\right)_VdT\n\\]\nここから体積一定のもとで，気体の温度を単位温度上げるのに必要な熱量は\n\\[\n\\frac{dQ}{dT} = \\left(\\frac{\\partial U}{\\partial T}\\right)_V\n\\]\nこれをモル数 \\(n\\) で割ると定積モル比熱になります．\n\nDefinition 3 定積モル比熱\n定積モル比熱 \\(C_v\\) [J/mol･K] は以下のように定義される\n\\[\nC_v = \\frac{1}{n} \\left(\\frac{\\partial Q}{\\partial T}\\right)_V = \\frac{1}{n} \\left(\\frac{\\partial U}{\\partial T}\\right)_V\n\\]\n\n圧力一定の条件下で1モルあたりの物質の温度を 1 K 上げるのに必要な熱量を考えます．これは定圧モル比熱 \\(C_p\\) と呼び，\n\\[\nC_p = C_v + \\left[ \\left(\\frac{\\partial U}{\\partial V}\\right)_T + P\\right]\\frac{1}{n}\\left(\\frac{\\partial V}{\\partial T}\\right)_P\n\\]\nマイヤーの関係式\n単原子分子理想気体では状態方程式\n\\[\n\\frac{PV}{T} = nR\n\\]\nが成立するので\n\\[\n\\left(\\frac{\\partial V}{\\partial T}\\right)_P = n\\frac{R}{P}\n\\]\nまた，内部エネルギーも\n\\[\nU = \\frac{3}{2}nRT\n\\]\nであるので \\(\\displaystyle  \\left(\\frac{\\partial U}{\\partial V}\\right)_T  = 0\\) より\n\\[\nC_p = C_v + R\n\\]\nというマイヤーの関係式が得られます．\n\n\n\n\n\nExercise 1 センター2016物理追試第５問「ぶら下がるシリンダーと熱力学第１法則」\n\n\nシリンダーが (a) の状態で静止しているとき，\\(P\\) を \\(P_0, M, g, S\\) の関数として表せ\nシリンダー内の気体を温めると，シリンダーはゆっくり下降し，(b) の状態で静止した．このとき，体積の変化 \\(\\Delta V\\) と 内部エネルギー \\(\\Delta U\\) は \\(\\Delta T\\) の関数としてどのように表せるか？\n\n\n\n\n\n\n\n\nNoteSolution\n\n\n\n\n\n1. シリンダーが (a) の状態で静止しているとき，\\(P\\) を \\(P_0, M, g, S\\) の関数として表せ\n下向きの力の一つとして\n\\[\n\\text{質量} \\times \\text{加速度} = \\text{力}\n\\]\nよって, \\(Mg\\) という力が下向きに働いています． また，シリンダー内部の圧力 \\(P\\) も下向きの力として働くので\n\\[\n\\text{下向きの力} = S\\times P + Mg\n\\]\n上向きの力として，\\(P_0\\times S\\) があり，初期状態では静止している = 上向きと下向きの力が均衡しているので\n\\[\nS\\times P + Mg = S\\times P_0\n\\]\nしたがって，\n\\[\nP = P_0 = \\frac{Mg}{S}\n\\]\n2. シリンダー内の気体を温めると，シリンダーはゆっくり下降し，(b) の状態で静止した．このとき，体積の変化 \\(\\Delta V\\) と 内部エネルギー \\(\\Delta U\\) は \\(\\Delta T\\) の関数としてどのように表せるか？\n単原子分子理想気体では内部エネルギーは\n\\[\nU = \\frac{3}{2}RT\n\\]\nしたがって\n\\[\n\\Delta U = \\frac{3}{2}R\\Delta T\n\\]\nまた，状態変化後も圧力は \\(P\\) で同じなので，理想気体の状態方程式より\n\\[\n\\frac{V}{T} = \\frac{V + \\Delta V}{T + \\Delta T}\n\\]\nしたがって，\n\\[\n\\Delta V = \\frac{V}{T}\\Delta T\n\\]\n\n\n\n\nExercise 2 運動エネルギーと温度と圧力\n密閉された炉に一箇所小さな孔が空いている．\n\n孔の厚さは0\n炉外の空気は温度が0℃で圧力は100kPa\n炉内の空気は温度調整して57℃で一定\n空気は理想気体とする\n\n十分時間が経った後は圧力が一定になるとして，この定常的な状態での炉内の圧力を求めよ．\nただし，分子の自乗平均速度は平均速度の自乗と一致するとする．\n\n\n\n\n\n\n\nNoteSolution\n\n\n\n\n\n炉内を1，炉外を2とすると，平衡状態では炉外へ出る分子と炉外から入る分子の数が等しいはずなので，\n\\[\nAv_1N_1t = Av_2N_2t\n\\]\n\n\\(v_i\\) 分子の平均速度\n\\(A\\): 孔の断面積\n\\(N_i\\): 個数密度\n\\(t\\): 単位時間\n\n理想気体においては\n\\[\n\\frac{3}{2}k_BT = \\frac{1}{2}m\\overline{v^2}\n\\]\nと温度は自乗平均速度に比例する．また理想気体の状態方程式より，個数密度は圧力 \\(P\\) に比例し，温度 \\(T\\) に反比例するので\n\\[\n\\begin{align}\n\\frac{v_1}{v_2} &= \\sqrt{\\frac{T_1}{T_2}}\\\\\n\\frac{N_1}{N_2} &= \\frac{P_1}{P_2}\\frac{T_2}{T_1}\n\\end{align}\n\\]\nしたがって，\n\\[\n\\begin{align}\np_1\n  &= p_2\\sqrt{\\frac{T_1}{T_2}}\\\\\n  &= 100\\text{kPa} \\times \\sqrt{\\frac{330.15}{273.15}}\\\\\n  &\\approx 110\\text{kPa}\n\\end{align}\n\\]"
  },
  {
    "objectID": "posts/2025-06-12-moles-and-gas-volume/index.html#気体の内部エネルギーとモル比熱",
    "href": "posts/2025-06-12-moles-and-gas-volume/index.html#気体の内部エネルギーとモル比熱",
    "title": "物質量と気体の体積",
    "section": "",
    "text": "気体の内部エネルギーを，温度 \\(T\\) と体積 \\(V\\) を独立変数として，\\(U = U(T, V)\\) と表すと\n\\[\n\\operatorname{grad} U \\equiv \\left(\\left(\\frac{\\partial U}{\\partial T}\\right)_V, \\left(\\frac{\\partial U}{\\partial V}\\right)_T\\right)\n\\]\nこれをもちいて整理すると\n\\[\ndU = \\left(\\frac{\\partial U}{\\partial T}\\right)_VdT + \\left(\\frac{\\partial U}{\\partial V}\\right)_TdV\n\\]\n熱力学第一法則より 気体が外部になす微小仕事 \\(dW = PdV\\) より\n\\[\ndQ =  \\left(\\frac{\\partial U}{\\partial T}\\right)_VdT + \\left[ \\left(\\frac{\\partial U}{\\partial V}\\right)_T + P\\right]dV \\label{temp-vol-eq}\n\\]\n\n\n体積一定の容器に入れた気体に熱を加える場合を考えます．\\(\\eqref{temp-vol-eq}\\) で \\(dV = 0\\) とおけるので\n\\[\ndQ =  \\left(\\frac{\\partial U}{\\partial T}\\right)_VdT\n\\]\nここから体積一定のもとで，気体の温度を単位温度上げるのに必要な熱量は\n\\[\n\\frac{dQ}{dT} = \\left(\\frac{\\partial U}{\\partial T}\\right)_V\n\\]\nこれをモル数 \\(n\\) で割ると定積モル比熱になります．\n\nDefinition 3 定積モル比熱\n定積モル比熱 \\(C_v\\) [J/mol･K] は以下のように定義される\n\\[\nC_v = \\frac{1}{n} \\left(\\frac{\\partial Q}{\\partial T}\\right)_V = \\frac{1}{n} \\left(\\frac{\\partial U}{\\partial T}\\right)_V\n\\]\n\n圧力一定の条件下で1モルあたりの物質の温度を 1 K 上げるのに必要な熱量を考えます．これは定圧モル比熱 \\(C_p\\) と呼び，\n\\[\nC_p = C_v + \\left[ \\left(\\frac{\\partial U}{\\partial V}\\right)_T + P\\right]\\frac{1}{n}\\left(\\frac{\\partial V}{\\partial T}\\right)_P\n\\]\nマイヤーの関係式\n単原子分子理想気体では状態方程式\n\\[\n\\frac{PV}{T} = nR\n\\]\nが成立するので\n\\[\n\\left(\\frac{\\partial V}{\\partial T}\\right)_P = n\\frac{R}{P}\n\\]\nまた，内部エネルギーも\n\\[\nU = \\frac{3}{2}nRT\n\\]\nであるので \\(\\displaystyle  \\left(\\frac{\\partial U}{\\partial V}\\right)_T  = 0\\) より\n\\[\nC_p = C_v + R\n\\]\nというマイヤーの関係式が得られます．"
  },
  {
    "objectID": "posts/2025-06-12-moles-and-gas-volume/index.html#理解度チェック",
    "href": "posts/2025-06-12-moles-and-gas-volume/index.html#理解度チェック",
    "title": "物質量と気体の体積",
    "section": "",
    "text": "Exercise 1 センター2016物理追試第５問「ぶら下がるシリンダーと熱力学第１法則」\n\n\nシリンダーが (a) の状態で静止しているとき，\\(P\\) を \\(P_0, M, g, S\\) の関数として表せ\nシリンダー内の気体を温めると，シリンダーはゆっくり下降し，(b) の状態で静止した．このとき，体積の変化 \\(\\Delta V\\) と 内部エネルギー \\(\\Delta U\\) は \\(\\Delta T\\) の関数としてどのように表せるか？\n\n\n\n\n\n\n\n\nNoteSolution\n\n\n\n\n\n1. シリンダーが (a) の状態で静止しているとき，\\(P\\) を \\(P_0, M, g, S\\) の関数として表せ\n下向きの力の一つとして\n\\[\n\\text{質量} \\times \\text{加速度} = \\text{力}\n\\]\nよって, \\(Mg\\) という力が下向きに働いています． また，シリンダー内部の圧力 \\(P\\) も下向きの力として働くので\n\\[\n\\text{下向きの力} = S\\times P + Mg\n\\]\n上向きの力として，\\(P_0\\times S\\) があり，初期状態では静止している = 上向きと下向きの力が均衡しているので\n\\[\nS\\times P + Mg = S\\times P_0\n\\]\nしたがって，\n\\[\nP = P_0 = \\frac{Mg}{S}\n\\]\n2. シリンダー内の気体を温めると，シリンダーはゆっくり下降し，(b) の状態で静止した．このとき，体積の変化 \\(\\Delta V\\) と 内部エネルギー \\(\\Delta U\\) は \\(\\Delta T\\) の関数としてどのように表せるか？\n単原子分子理想気体では内部エネルギーは\n\\[\nU = \\frac{3}{2}RT\n\\]\nしたがって\n\\[\n\\Delta U = \\frac{3}{2}R\\Delta T\n\\]\nまた，状態変化後も圧力は \\(P\\) で同じなので，理想気体の状態方程式より\n\\[\n\\frac{V}{T} = \\frac{V + \\Delta V}{T + \\Delta T}\n\\]\nしたがって，\n\\[\n\\Delta V = \\frac{V}{T}\\Delta T\n\\]\n\n\n\n\nExercise 2 運動エネルギーと温度と圧力\n密閉された炉に一箇所小さな孔が空いている．\n\n孔の厚さは0\n炉外の空気は温度が0℃で圧力は100kPa\n炉内の空気は温度調整して57℃で一定\n空気は理想気体とする\n\n十分時間が経った後は圧力が一定になるとして，この定常的な状態での炉内の圧力を求めよ．\nただし，分子の自乗平均速度は平均速度の自乗と一致するとする．\n\n\n\n\n\n\n\nNoteSolution\n\n\n\n\n\n炉内を1，炉外を2とすると，平衡状態では炉外へ出る分子と炉外から入る分子の数が等しいはずなので，\n\\[\nAv_1N_1t = Av_2N_2t\n\\]\n\n\\(v_i\\) 分子の平均速度\n\\(A\\): 孔の断面積\n\\(N_i\\): 個数密度\n\\(t\\): 単位時間\n\n理想気体においては\n\\[\n\\frac{3}{2}k_BT = \\frac{1}{2}m\\overline{v^2}\n\\]\nと温度は自乗平均速度に比例する．また理想気体の状態方程式より，個数密度は圧力 \\(P\\) に比例し，温度 \\(T\\) に反比例するので\n\\[\n\\begin{align}\n\\frac{v_1}{v_2} &= \\sqrt{\\frac{T_1}{T_2}}\\\\\n\\frac{N_1}{N_2} &= \\frac{P_1}{P_2}\\frac{T_2}{T_1}\n\\end{align}\n\\]\nしたがって，\n\\[\n\\begin{align}\np_1\n  &= p_2\\sqrt{\\frac{T_1}{T_2}}\\\\\n  &= 100\\text{kPa} \\times \\sqrt{\\frac{330.15}{273.15}}\\\\\n  &\\approx 110\\text{kPa}\n\\end{align}\n\\]"
  },
  {
    "objectID": "posts/2025-04-30-css-unit/index.html",
    "href": "posts/2025-04-30-css-unit/index.html",
    "title": "CSSで使う単位",
    "section": "",
    "text": "NoteCSSで使用する単位一覧\n\n\n\n\n\n\n\n ▶  相対単位\n\n\n\n\n\n\n\n\npx\nモニターの画素(ピクセル)を1とする単位\n\n\n%\n%で割合を指定\n\n\nem\n親要素の大文字Mのフォントサイズを1とする単位\n\n\nex\n親要素の小文字xフォントサイズを1とする単位\n\n\nrem\nルート要素の大文字のフォントサイズを1とする単位\n\n\n\n\n\n ▶  絶対単位\n\n\n\n\n\n\n\n\npt\n1/72インチを1とする単位\n\n\npc\n12ptを1とする単位\n\n\nmm\nミリメートル基準\n\n\ncm\nセンチメートル基準\n\n\nin\nインチを1とする単位\n▶  emの使いどころ\nユーザー環境によってフォントのサイズが変わってしまうWebデザインにおいて，\nといったその時々のフォントサイズに応じたサイズ指定を試みたい場合に，親要素の文字の大きさを単位とするemが役に立ちます．"
  },
  {
    "objectID": "posts/2025-04-30-css-unit/index.html#emとremの違い",
    "href": "posts/2025-04-30-css-unit/index.html#emとremの違い",
    "title": "CSSで使う単位",
    "section": "emとremの違い",
    "text": "emとremの違い\nemもremも相対単位となりますが，remは常に最上位のルート要素のフォントサイズを規準に計算されるという特徴があります．活用例として，remは要素が入れ子になるような場合に，意図せずサイズが変更されるようなリスクを低減することができます．\n\n\n\n\n\n\n\nNotehtml code example\n\n\n\n\n\n&lt;style&gt;\n  html {\n    font-size: 16px; /* 1rem = 16px */\n  }\n\n  li.em-example {\n    font-size: 1.5em; /* 1.5 × 20px = 30px */\n    color: steelblue;\n  }\n\n  li.rem-example {\n    font-size: 1.5rem; /* 1.5 × 16px = 24px */\n    color: darkorange;\n  }\n&lt;/style&gt;\n\n&lt;ul&gt;\n    &lt;li class=\"em-example\"&gt;This text uses &lt;code&gt;1.5em&lt;/code&gt; font size&lt;/li&gt;\n    &lt;li class=\"em-example\"&gt;This text uses &lt;code&gt;1.5em&lt;/code&gt; font size\n        &lt;ul&gt;\n            &lt;li class=\"em-example\"&gt;This text uses &lt;code&gt;1.5em&lt;/code&gt; (relative to &lt;code&gt;&lt;ul&gt;&lt;/code&gt; font size)&lt;/li&gt;\n    &lt;/li&gt;\n&lt;/ul&gt;\n\n\n&lt;ul&gt;\n    &lt;li class=\"rem-example\"&gt;This text uses &lt;code&gt;1.5rem&lt;/code&gt; font size&lt;/li&gt;\n    &lt;li class=\"rem-example\"&gt;This text uses &lt;code&gt;1.5rem&lt;/code&gt; font size\n        &lt;ul&gt;\n            &lt;li class=\"rem-example\"&gt;This text uses &lt;code&gt;1.5rem&lt;/code&gt; (relative to &lt;code&gt;&lt;ul&gt;&lt;/code&gt; font size)&lt;/li&gt;\n        &lt;/ul&gt;\n    &lt;/li&gt;\n&lt;/ul&gt;\n\n\n\n ▶  emの挙動\n\n\n\n    This text uses 1.5em font size\n    This text uses 1.5em font size\n        \n            This text uses 1.5em (relative to &lt;ul&gt; font size)\n    \n  \n\n ▶  remの挙動\n\n\n\n    This text uses 1.5rem font size\n    This text uses 1.5rem font size\n        \n            This text uses 1.5rem (relative to &lt;ul&gt; font size)\n        \n    \n  \n\n\n\n\n\n\nNotekey takeaways\n\n\n\n\nemでは入れ子構造となってる&lt;li&gt;セクションについて，直前のフォントサイズ 1.5emにたいして更に 1.5em でフォントサイズを計算している\nremでは入れ子構造となってる&lt;li&gt;セクションでも，ルート要素フォントサイズ16pxを参照して, 1.5remを計算している"
  },
  {
    "objectID": "posts/2025-08-02-PYTHONSTARTUP/index.html",
    "href": "posts/2025-08-02-PYTHONSTARTUP/index.html",
    "title": "環境変数 PYTHONSTARTUP の目的",
    "section": "",
    "text": "Definition 1 PYTHONSTARTUP\n\nPYTHONSTARTUP はインタラクティブモードのPythonを起動する直前に読み込むPythonスクリプトのPATHを示す環境変数\nインタラクティブモードPythonのための設定なので，通常は .zshrc / .bashrc で定義\n\n\n設定内容例\n\nインタラクティブモードのコマンド履歴格納ファイル .python_history のPATH設定\n起動時に .python_history に書き込むラインの設定(例: 起動時刻を履歴ファイルに書き込む)\n起動時に自動的に読み込むモジュールの設定(例: 常に import numpy as np を実行する)"
  },
  {
    "objectID": "posts/2025-08-02-PYTHONSTARTUP/index.html#シェル環境変数としての-pythonstartup",
    "href": "posts/2025-08-02-PYTHONSTARTUP/index.html#シェル環境変数としての-pythonstartup",
    "title": "環境変数 PYTHONSTARTUP の目的",
    "section": "",
    "text": "Definition 1 PYTHONSTARTUP\n\nPYTHONSTARTUP はインタラクティブモードのPythonを起動する直前に読み込むPythonスクリプトのPATHを示す環境変数\nインタラクティブモードPythonのための設定なので，通常は .zshrc / .bashrc で定義\n\n\n設定内容例\n\nインタラクティブモードのコマンド履歴格納ファイル .python_history のPATH設定\n起動時に .python_history に書き込むラインの設定(例: 起動時刻を履歴ファイルに書き込む)\n起動時に自動的に読み込むモジュールの設定(例: 常に import numpy as np を実行する)"
  },
  {
    "objectID": "posts/2025-08-02-PYTHONSTARTUP/index.html#個人用設定",
    "href": "posts/2025-08-02-PYTHONSTARTUP/index.html#個人用設定",
    "title": "環境変数 PYTHONSTARTUP の目的",
    "section": "個人用設定",
    "text": "個人用設定\n方針\n\nセッション開始から終了までのコマンド履歴を格納する履歴ファイルの設定\nセッション開始時にタイムスタンプ付きのヘッダーを履歴ファイルに追加\nデフォルトで最大 10,000 行の履歴を履歴ファイルに保存\n\n実装コード\n\n\n\n\n\n\n\n\nモジュール\n機能\n\n\n\n\nimport atexit\nプログラム終了時に特定の処理（ここでは履歴保存）を自動実行するためのモジュール\n\n\nimport readline\nPython の インタラクティブシェルで履歴や補完を扱うライブラリ\n\n\nimport os\nファイルパス操作やディレクトリ作成など，OS 関連の処理に使用\n\n\n\n\n#!/usr/bin/env python3\n\nimport atexit\nimport readline\nimport os\nfrom datetime import datetime\n\n# ==== create session header ====\ndate = datetime.now()\nsession_header = date.strftime(\"### Python session started on %Y-%m-%d %H:%M:%S ###\")\n\n# ==== save history file as ~/.cache/.python_history ====\nhistdir = os.path.expanduser(\"~/.cache/python\")\nos.makedirs(histdir, exist_ok=True)\nhistfile = os.path.join(histdir, \".python_history\")\n\n# ==== append session header to history file ====\nwith open(histfile, \"a\") as f:\n    f.write(f\"\\n{session_header}\\n\")\n\n\ntry:\n    readline.read_history_file(histfile)\n    readline.set_history_length(10000)\nexcept FileNotFoundError:\n    pass\n\n# ==== register history saving function ====\natexit.register(readline.write_history_file, histfile)\nシェル設定\n~/.zshrc または ~/.bashrcに PYTHONSTARTUP を追加:\nexport PYTHONSTARTUP=$HOME/.config/python/pythonstartup.py\n\nコードの説明\n履歴ファイルの保存場所設定\n# ==== save history file as ~/.cache/.python_history ====\nhistdir = os.path.expanduser(\"~/.cache/python\")\nos.makedirs(histdir, exist_ok=True)\nhistfile = os.path.join(histdir, \".python_history\")\n~ はPythonのファイル操作では~という文字として認識してしまい，/home/&lt;username&gt; と解釈してくれません． os.path.expanduser を用いることで，クロスプラットフォーム対応ができる形で意図したPATH展開をしてくれます\nセッションヘッダーを履歴ファイルに追記\n# ==== append session header to history file ====\nwith open(histfile, \"a\") as f:\n    f.write(f\"\\n{session_header}\\n\")\n\n\n\n\n\n\n\n\n\nモード\n説明\n影響\n\n\n\n\n\"w\"\n書き込みモード．ファイルを 開いた時点で既存の内容を削除\n履歴ファイルが完全に上書きされる．以前のコマンドもセッションヘッダーも消える\n\n\n\"a\"\n追記モード．既存の内容は残して末尾に書き込む\n以前の履歴は保持される．新しいセッションヘッダーも追加される\n\n\n\n\n履歴ファイルを読み込む\ntry:\n    readline.read_history_file(histfile)\n    readline.set_history_length(10000)\nexcept FileNotFoundError:\n    pass\n\n\n\n\n\n\n\n\nコード\n説明\n\n\n\n\nreadline.read_history_file(histfile)\n既存の履歴ファイルを読み込むことで，前回までのコマンドが ↑↓キーで呼び出せるようになる．\n\n\nreadline.set_history_length(10000)\n履歴の最大行数を 10,000行 に設定．古い履歴から順に削除される．\n\n\ntry ... except FileNotFoundError\n履歴ファイルが存在しない場合でもエラーを出さず，スクリプトを継続できるようにする．\n\n\n\n\nPython 終了時に履歴を保存\n# ==== register history saving function ====\natexit.register(readline.write_history_file, histfile)\n\n\n\n\n\n\n\n\nコード\n説明\n\n\n\n\natexit.register(...)\nPython が終了するときに自動で指定関数を呼び出す\n\n\nreadline.write_history_file(histfile)\n履セッション中に入力したコマンドを 履歴ファイルに書く．"
  },
  {
    "objectID": "posts/2025-01-10-list-up-users/index.html",
    "href": "posts/2025-01-10-list-up-users/index.html",
    "title": "Linuxシステム上のユーザー一覧を条件に応じて表示する",
    "section": "",
    "text": "🎯 スクリプトの目的\n/etc/passwd ファイルを読み取り，以下のユーザーを表示する:\n\nすべてのユーザー\nシステムユーザー（UID &lt; 1000）\nhumanユーザー（UID &gt;= 1000）\n\nデフォルトでは humanユーザー を表示させる．\n\n\n\n#!/bin/bash\n\nprint_help() {\n    echo \"Usage: $0 [-a|-s|-h]\"\n    echo \"Options:\"\n    echo \"  -a    Show all users\"\n    echo \"  -s    Show only system users\"\n    echo \"  -h    Show only human users\"\n    echo \"  -?    Show this help message\"\n    exit 1\n}\n\n# Default to human users if no option is provided\nMODE=\"human\"\n\nwhile getopts \"ash?\" opt; do\n    case $opt in\n        a) MODE=\"all\";;\n        s) MODE=\"system\";;\n        h) MODE=\"human\";;\n        ?) print_help;;\n    esac\ndone\n\n# Print header\nprintf \"%-20s %-6s %-6s\\n\" \"Username\" \"UID\" \"GID\"\n\ncase $MODE in\n    \"all\")\n        awk -F: '{ printf \"%-20s %-6s %-6s\\n\", $1, $3, $4 }' /etc/passwd\n        ;;\n    \"system\")\n        awk -F: '$3 &lt; 1000 { printf \"%-20s %-6s %-6s\\n\", $1, $3, $4 }' /etc/passwd\n        ;;\n    \"human\")\n        awk -F: '$3 &gt;= 1000 && $3 &lt; 65534 { printf \"%-20s %-6s %-6s\\n\", $1, $3, $4 }' /etc/passwd\n        ;;\nesac\n\n\n\nオプションの処理\nwhile getopts \"ash?\" opt; do\n    case $opt in\n        a) MODE=\"all\";;\n        s) MODE=\"system\";;\n        h) MODE=\"human\";;\n        ?) print_help;;\n    esac\ndone\n\ngetopts を使って、コマンドラインオプションに応じて処理分岐\nMODE という変数に条件を記録し，optionに応じた処理は後段で実装\n\n\n\n\noption\n処理内容\n\n\n\n\n-a\n全ユーザー表示\n\n\n-s\nシステムユーザーのみ表示（UID &lt; 1000）\n\n\n-h\nhumanユーザーのみ表示\n\n\n-?\nヘルプを表示，status codeは exit 1\n\n\n\nヘッダー出力\nprintf \"%-20s %-6s %-6s\\n\" \"Username\" \"UID\" \"GID\"\n\n整形されたカラム見出しを出力\n%-20sは文字列(s)を左寄せで20文字分の幅で表示\n\n\n\n\n\n書式指定子\n意味\n\n\n\n\n%-20s\n左寄せで20文字幅の文字列（Username列）\n\n\n%-6s\n左寄せで6文字幅の文字列（UID列）\n\n\n%-6s\n左寄せで6文字幅の文字列（GID列）\n\n\n\n\nユーサー一覧の取得\ncase $MODE in\n    \"all\")\n        awk -F: '{ printf \"%-20s %-6s %-6s\\n\", $1, $3, $4 }' /etc/passwd\n        ;;\n    \"system\")\n        awk -F: '$3 &lt; 1000 { printf \"%-20s %-6s %-6s\\n\", $1, $3, $4 }' /etc/passwd\n        ;;\n    \"human\")\n        awk -F: '$3 &gt;= 1000 && $3 &lt; 65534 { printf \"%-20s %-6s %-6s\\n\", $1, $3, $4 }' /etc/passwd\n        ;;\nesac\n\n\n\n\n\n\n\n\ncommand\n動作説明\n\n\n\n\nawk -F:\n:区切りで /etc/passwd を分割\n\n\n'$3 &gt;= 1000 && $3 &lt; 65534 { printf ...}'\nUID が 1000以上65534未満を対象にフィルター\n\n\n$1\n/etc/passwdにおけるusernameカラム\n\n\n$3\n/etc/passwdにおけるUIDカラム\n\n\n$4\n/etc/passwdにおけるGIDカラム"
  },
  {
    "objectID": "posts/2025-01-10-list-up-users/index.html#シェルスクリプト-ls-users",
    "href": "posts/2025-01-10-list-up-users/index.html#シェルスクリプト-ls-users",
    "title": "Linuxシステム上のユーザー一覧を条件に応じて表示する",
    "section": "",
    "text": "🎯 スクリプトの目的\n/etc/passwd ファイルを読み取り，以下のユーザーを表示する:\n\nすべてのユーザー\nシステムユーザー（UID &lt; 1000）\nhumanユーザー（UID &gt;= 1000）\n\nデフォルトでは humanユーザー を表示させる．\n\n\n\n#!/bin/bash\n\nprint_help() {\n    echo \"Usage: $0 [-a|-s|-h]\"\n    echo \"Options:\"\n    echo \"  -a    Show all users\"\n    echo \"  -s    Show only system users\"\n    echo \"  -h    Show only human users\"\n    echo \"  -?    Show this help message\"\n    exit 1\n}\n\n# Default to human users if no option is provided\nMODE=\"human\"\n\nwhile getopts \"ash?\" opt; do\n    case $opt in\n        a) MODE=\"all\";;\n        s) MODE=\"system\";;\n        h) MODE=\"human\";;\n        ?) print_help;;\n    esac\ndone\n\n# Print header\nprintf \"%-20s %-6s %-6s\\n\" \"Username\" \"UID\" \"GID\"\n\ncase $MODE in\n    \"all\")\n        awk -F: '{ printf \"%-20s %-6s %-6s\\n\", $1, $3, $4 }' /etc/passwd\n        ;;\n    \"system\")\n        awk -F: '$3 &lt; 1000 { printf \"%-20s %-6s %-6s\\n\", $1, $3, $4 }' /etc/passwd\n        ;;\n    \"human\")\n        awk -F: '$3 &gt;= 1000 && $3 &lt; 65534 { printf \"%-20s %-6s %-6s\\n\", $1, $3, $4 }' /etc/passwd\n        ;;\nesac\n\n\n\nオプションの処理\nwhile getopts \"ash?\" opt; do\n    case $opt in\n        a) MODE=\"all\";;\n        s) MODE=\"system\";;\n        h) MODE=\"human\";;\n        ?) print_help;;\n    esac\ndone\n\ngetopts を使って、コマンドラインオプションに応じて処理分岐\nMODE という変数に条件を記録し，optionに応じた処理は後段で実装\n\n\n\n\noption\n処理内容\n\n\n\n\n-a\n全ユーザー表示\n\n\n-s\nシステムユーザーのみ表示（UID &lt; 1000）\n\n\n-h\nhumanユーザーのみ表示\n\n\n-?\nヘルプを表示，status codeは exit 1\n\n\n\nヘッダー出力\nprintf \"%-20s %-6s %-6s\\n\" \"Username\" \"UID\" \"GID\"\n\n整形されたカラム見出しを出力\n%-20sは文字列(s)を左寄せで20文字分の幅で表示\n\n\n\n\n\n書式指定子\n意味\n\n\n\n\n%-20s\n左寄せで20文字幅の文字列（Username列）\n\n\n%-6s\n左寄せで6文字幅の文字列（UID列）\n\n\n%-6s\n左寄せで6文字幅の文字列（GID列）\n\n\n\n\nユーサー一覧の取得\ncase $MODE in\n    \"all\")\n        awk -F: '{ printf \"%-20s %-6s %-6s\\n\", $1, $3, $4 }' /etc/passwd\n        ;;\n    \"system\")\n        awk -F: '$3 &lt; 1000 { printf \"%-20s %-6s %-6s\\n\", $1, $3, $4 }' /etc/passwd\n        ;;\n    \"human\")\n        awk -F: '$3 &gt;= 1000 && $3 &lt; 65534 { printf \"%-20s %-6s %-6s\\n\", $1, $3, $4 }' /etc/passwd\n        ;;\nesac\n\n\n\n\n\n\n\n\ncommand\n動作説明\n\n\n\n\nawk -F:\n:区切りで /etc/passwd を分割\n\n\n'$3 &gt;= 1000 && $3 &lt; 65534 { printf ...}'\nUID が 1000以上65534未満を対象にフィルター\n\n\n$1\n/etc/passwdにおけるusernameカラム\n\n\n$3\n/etc/passwdにおけるUIDカラム\n\n\n$4\n/etc/passwdにおけるGIDカラム"
  },
  {
    "objectID": "posts/2025-01-10-list-up-users/index.html#etcpasswdファイル",
    "href": "posts/2025-01-10-list-up-users/index.html#etcpasswdファイル",
    "title": "Linuxシステム上のユーザー一覧を条件に応じて表示する",
    "section": "/etc/passwdファイル",
    "text": "/etc/passwdファイル\n\nDefinition 1 /etc/passwdファイル\n\nLinux においてユーザーアカウント情報を管理するためのテキストファイル\n\n\n基本フォーマット\nユーザー名:パスワード:UID:GID:コメント:ホームディレクトリ:ログインシェル\n実際に確認してみると\n% cat /etc/passwd\nkirby:x:1001:1001:Hoshino Kirby:/home/kirby:/bin/bash\n第２フィールドは多くの場合 x という表記になっています．実際のハッシュは /etc/shadow に保存されています．"
  },
  {
    "objectID": "posts/2025-01-10-list-up-users/index.html#linuxにおけるuserとgroup",
    "href": "posts/2025-01-10-list-up-users/index.html#linuxにおけるuserとgroup",
    "title": "Linuxシステム上のユーザー一覧を条件に応じて表示する",
    "section": "LinuxにおけるUserとGroup",
    "text": "LinuxにおけるUserとGroup\nLinuxにおけるuser区分\n\n\n\n\n\n\n\n\nユーザー区分\n説明\n\n\n\n\nスーパーユーザー\nシステム唯一の特権ユーザー，すべてのアクセス制御を無視することができる． ユーザー名:root, UID:0 と決まっている\n\n\nシステムユーザー\n各種サーバープログラムやシステムプログラムの実行に利用されるユーザー． UIDは主に1~99の範囲で割り当てられる\n\n\n一般ユーザー\nシステムの一般利用者 ユーザーIDは1000以降が割り当てられる（初めてのユーザーなら1000）\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\n\nroot以外のuid1000未満のアカウントはデーモンやディレクトリの所有者として利用するシステムアカウントとして用意されている\n100未満のUIDについてシステムによって静的に割り当てられるべきであり，アプリケーションによって作成されるべきではない範囲\n100 から 499 は，システム管理者やインストール後のスクリプトが useradd を使用して動的に割り当てるために予約された領域\n\n\n\nnobodyとは誰か？\n\nDefinition 2 nobodyユーザー\n\nnobodyに対して，一般的にはUID 65534が割り当てられている\n65535は16bit符号なし整数で表すことのできる一番大きな数字(FFFFFF)\nNFS(Network File System)サーバーがクライアントから提供されたUIDやGIDを信頼できない場合，またはroot-squashオプションが使用されている場合に使用される\n基本的にはNFS用に用意されたユーザー\n\n\n注意点として，ネットワークを通じてコンピューター間でファイルを共有するNFS用のユーザーであってその他の目的で使用されることは想定されていません．「nobodyを信頼できないプログラムの実行や信頼できないデータの処理に使用すること」は推奨されません．「あくまで，サービスには専用のユーザーアカウントを持たせるべき」というルールを忘れないようにしましょう．"
  },
  {
    "objectID": "posts/2024-12-17-firefox-proxy-access/index.html",
    "href": "posts/2024-12-17-firefox-proxy-access/index.html",
    "title": "Firefoxを用いたsocks5 proxyブラウザアクセス設定",
    "section": "",
    "text": "アクセス元のglobal IPが制限されたサイト(例: 社内用gitlabサーバー)へアクセスする場合，\n\n許可されたglobal IPに属するプライベートIPネットワークに接続している端末からアクセス\n別端末から上記の端末へssh接続し，プロキシサーバー的に使用をする\n\nという2つの方法が考えられます．後者の方法をFirefoxを用いて設定する方法を紹介します．\n ▶  なぜFirefoxなのか？\n\nGoogle chromeでもproxy設定は可能ですが，OS側の設定を変更してしまう\nFirefoxはブラウザレベルでproxyの設定が可能"
  },
  {
    "objectID": "posts/2024-12-17-firefox-proxy-access/index.html#what-we-want-to-do",
    "href": "posts/2024-12-17-firefox-proxy-access/index.html#what-we-want-to-do",
    "title": "Firefoxを用いたsocks5 proxyブラウザアクセス設定",
    "section": "",
    "text": "アクセス元のglobal IPが制限されたサイト(例: 社内用gitlabサーバー)へアクセスする場合，\n\n許可されたglobal IPに属するプライベートIPネットワークに接続している端末からアクセス\n別端末から上記の端末へssh接続し，プロキシサーバー的に使用をする\n\nという2つの方法が考えられます．後者の方法をFirefoxを用いて設定する方法を紹介します．\n ▶  なぜFirefoxなのか？\n\nGoogle chromeでもproxy設定は可能ですが，OS側の設定を変更してしまう\nFirefoxはブラウザレベルでproxyの設定が可能"
  },
  {
    "objectID": "posts/2024-12-17-firefox-proxy-access/index.html#firefoxにおけるsocks5-proxy設定",
    "href": "posts/2024-12-17-firefox-proxy-access/index.html#firefoxにおけるsocks5-proxy設定",
    "title": "Firefoxを用いたsocks5 proxyブラウザアクセス設定",
    "section": "Firefoxにおけるsocks5 proxy設定",
    "text": "Firefoxにおけるsocks5 proxy設定\n\nFirefoxを開いて、右上のメニューボタン（三本線）をクリック\nメニューから「設定」を選択\nネットワーク設定を開く\n「手動でプロキシ設定をする」オプションを選択\n「SOCKS v5」を選択し，SOCKSホストを127.0.0.1，ポートを1080で設定\n変更を保存\n\n\n\n\nfirefox-proxy-setting\n\n\n\nHow to use\nLinux, Windows, MacOS問わず\nssh &lt;username&gt;@&lt;proxy-server&gt; -D 1080\nとまず，ssh接続を確立します．-D オプションはダイナミックポートフォワーディング (Dynamic Port Forwarding)の設定です． 上記を実行するとローカルの 1080番ポート にSOCKS5プロキシが立ち上がります．\nFirefoxで SOCKS5プロキシ 127.0.0.1:1080と設定すると，\n\n\n\n\n\nsequenceDiagram\n    participant Client as クライアント\n    participant LocalSOCKS as localhost:1080 (SOCKSプロキシ)\n    participant SSHTunnel as SSHトンネル\n    participant RemoteServer as リモートサーバー\n    participant ExternalServer as 外部サーバー\n\n    %% 1. クライアントがSOCKSプロキシに接続\n    Client-&gt;&gt;LocalSOCKS: データ送信 (接続要求, 宛先IP/ポート)\n\n    %% 2. SOCKSプロキシがSSHトンネル経由でリモートサーバーに転送\n    LocalSOCKS-&gt;&gt;SSHTunnel: データ転送 (暗号化)\n\n    %% 3. SSHトンネルがリモートサーバーに転送\n    SSHTunnel-&gt;&gt;RemoteServer: データ中継 (トンネル経由)\n\n    %% 4. リモートサーバーが外部サーバーに接続\n    RemoteServer-&gt;&gt;ExternalServer: 外部サーバー接続要求 (TCP/UDP)\n    ExternalServer--&gt;&gt;RemoteServer: 接続応答\n\n    %% 5. 応答をクライアントに返送\n    RemoteServer--&gt;&gt;SSHTunnel: 応答データ\n    SSHTunnel--&gt;&gt;LocalSOCKS: 暗号化データ戻し\n    LocalSOCKS--&gt;&gt;Client: レスポンス転送\n\n\n\n\n\n\n\nという順序で通信されるようになります．"
  },
  {
    "objectID": "posts/2024-12-17-firefox-proxy-access/index.html#appendix-プロキシサーバーの仕組み",
    "href": "posts/2024-12-17-firefox-proxy-access/index.html#appendix-プロキシサーバーの仕組み",
    "title": "Firefoxを用いたsocks5 proxyブラウザアクセス設定",
    "section": "Appendix: プロキシサーバーの仕組み",
    "text": "Appendix: プロキシサーバーの仕組み\nクライアントの依頼に応じて，外部のサーバーにサービスを要求し，その結果をクライアントに提供するサーバーをプロキシサーバーといいます． SOCKS5は，プロキシサーバーを利用してサーバーとクライアント間のパケットをルーティングするインターネットプロトコルのことを指します．\nSOCKS5プロキシサーバーのメリットとして，安全性，匿名性，利便性の3つがあります．\n ▶  安全性\n\nSOCKS5は，ユーザー名とパスワードによる認証機能をサポートしているため，外部の不正アクセスや認証されていないクライアントからの利用を防ぐことができる\nSSHトンネルと組み合わせることで，安全にSOCKS5プロキシサーバー経由の通信を暗号化することができる = リモートアクセス時のデータ転送が保護され，悪意のあるネットワーク環境でも安全に通信可能\nプロキシサーバーを中間地点として使用することで，DDoS攻撃などの直接的な大量トラフィック攻撃を遮断することが可能\n\n ▶  匿名性\n\nネットワーク全体のトラフィックがプロキシサーバー経由で処理されるため，外部から見えるIPアドレスが プロキシのIPになる = SOCKS5プロキシを介することで，クライアントのIPアドレス/端末名を隠すことができる\n一括でアクセス元をプロキシのIPに集約し，クライアントIPを隠蔽することでセキュリティとプライバシー保護が可能になるという活用方法がある\n\nSOCKS5プロキシは，クライアントから送信されたデータをそのまま中継しますが，データ送信時のヘッダ情報（IPアドレスなど）をカプセル化します． そのため，外部サーバーはデータの中身だけを認識し，送信元（クライアント）に関する情報は知ることができないという仕組みになっています．\n ▶  利便性\n\nSOCKS5はプロトコル非依存であり，TCPとUDPの両方の通信をサポートしている = FTP, SMTP, P2P, VoIP, DNSリクエスト, オンラインゲームなど多様なアプリケーションで利用可能\n\n\n\n\n\n\nsequenceDiagram\n    participant Client as クライアント\n    participant SOCKS5ProxyServer as SOCKS5プロキシサーバー\n    participant ExternalServer as 外部サーバー\n\n    %% 1. 接続要求とハンドシェイク\n    Client-&gt;&gt;SOCKS5ProxyServer: 接続要求 (Handshake: バージョン, 認証方式)\n    SOCKS5ProxyServer--&gt;&gt;Client: 認証方式応答 (成功/失敗)\n\n    %% 2. 外部サーバーへの接続要求\n    Client-&gt;&gt;SOCKS5ProxyServer: 外部サーバー接続要求 (宛先IP, ポート)\n    note right of Client: クライアントのIPアドレスは隠蔽される\n    SOCKS5ProxyServer-&gt;&gt;ExternalServer: 接続確立要求 (プロキシのIPを使用)\n\n    %% 3. 接続確立確認\n    ExternalServer--&gt;&gt;SOCKS5ProxyServer: 接続成功応答\n    SOCKS5ProxyServer--&gt;&gt;Client: 接続確立成功通知\n\n    %% 4. データ転送 (カプセル化)\n    Client-&gt;&gt;SOCKS5ProxyServer: データ送信 (カプセル化されたパケット)\n    note over SOCKS5ProxyServer: データをそのまま中継 (IPアドレス非公開)\n    SOCKS5ProxyServer-&gt;&gt;ExternalServer: データ転送 (TCP/UDP)\n    ExternalServer--&gt;&gt;SOCKS5ProxyServer: レスポンスデータ\n    SOCKS5ProxyServer--&gt;&gt;Client: レスポンス転送\n\n    %% 5. 通信終了\n    Client-&gt;&gt;SOCKS5ProxyServer: 通信終了リクエスト\n    SOCKS5ProxyServer-&gt;&gt;ExternalServer: 接続切断\n    SOCKS5ProxyServer--&gt;&gt;Client: 通信終了通知\n\n\n\n\n\n\n\nSOCKS5プロキシはキャッシュを行わない\nHTTPプロキシは一般的に，ウェブコンテンツ（画像、HTML、動画など）をキャッシュすることで，再アクセス時にデータ転送を高速化します． 一方，SOCKS5プロキシはキャッシュを行なわないという違いがあります．\n\nSOCKS5はデータ転送のトンネルを作る役割を果たすため，通信内容のデータを確認・保存することがない\nあくまで「データを中継する」プロトコルであり，内容に依存しないため，キャッシュ機能は持たない\n\nSOCKS5はキャッシュ機能を持たないことで，シンプルかつ高速な通信環境を提供してくれるものと理解していればOKだとおもいます． キャッシュはリアルタイム通信に不要ですし，また，キャッシュ管理の手間やストレージコストが不要というメリットもあります．"
  },
  {
    "objectID": "posts/2025-07-18-getting-started-with-google-cloud-storage/index.html",
    "href": "posts/2025-07-18-getting-started-with-google-cloud-storage/index.html",
    "title": "bq commandを用いたPatitioned BigQuery External Tableの作成",
    "section": "",
    "text": "以下の形式でparquet fileがGoogle Cloud Storageでgs://regression-monkey-data/pupupuland_store_pos/以下に保存されているとします．\npupupuland_store_pos\n├── partition_dt=2023-09-23\n│   └── part-0.parquet\n├── partition_dt=2023-09-24\n│   └── part-0.parquet\n└── partition_dt=2023-09-25\n    └── part-0.parquet"
  },
  {
    "objectID": "posts/2025-07-18-getting-started-with-google-cloud-storage/index.html#google-cloud-storageでの保存形式",
    "href": "posts/2025-07-18-getting-started-with-google-cloud-storage/index.html#google-cloud-storageでの保存形式",
    "title": "bq commandを用いたPatitioned BigQuery External Tableの作成",
    "section": "",
    "text": "以下の形式でparquet fileがGoogle Cloud Storageでgs://regression-monkey-data/pupupuland_store_pos/以下に保存されているとします．\npupupuland_store_pos\n├── partition_dt=2023-09-23\n│   └── part-0.parquet\n├── partition_dt=2023-09-24\n│   └── part-0.parquet\n└── partition_dt=2023-09-25\n    └── part-0.parquet"
  },
  {
    "objectID": "posts/2025-07-18-getting-started-with-google-cloud-storage/index.html#bq-command",
    "href": "posts/2025-07-18-getting-started-with-google-cloud-storage/index.html#bq-command",
    "title": "bq commandを用いたPatitioned BigQuery External Tableの作成",
    "section": "bq command",
    "text": "bq command\npartitiopn_dtをpartition columnとしたtableの作成\nbq_upload() {\n  local project_id='regression-monkey-data'\n  local dataset_id='pupupuland'\n  local table_name='pupupuland_store_pos'\n  local upload_target=\"${project_id}:${dataset_id}.${table_name}\"\n\n  bq mkdef \\\n  --source_format=PARQUET \\\n  --hive_partitioning_mode=AUTO \\\n  --hive_partitioning_source_uri_prefix=gs://regression-monkey-data/pupupuland_store_pos/ \\\n  --require_hive_partition_filter=false \\\n  'gs://regression-monkey-data/pupupuland_store_pos/*' \\\n  &gt; pupupuland_store_pos_external_def.json\n\n  bq mk --external_table_definition=pupupuland_store_pos_external_def.json \"${upload_target}\"\n\n}\n\n# main\nbq_upload\n\nbq mkdefの役割\n\nbq mkdefの役割\nGCS 上の Parquet ファイルを外部テーブルとして定義するための JSON 定義ファイルを作成\n\n\n\n\n\n\n\n\n\nオプション名\n意味\n\n\n\n\n--source_format=PARQUET\n読み込むファイル形式が Parquet であることを指定\n\n\n--hive_partitioning_mode=AUTO\nHive形式のディレクトリ構造（例：partition_month=2024-07/）からパーティション列を自動推定\n\n\n--hive_partitioning_source_uri_prefix=gs://...\nパーティション構造の共通プレフィックス（＝分岐が始まるルート）を指定\n\n\n--require_hive_partition_filter=false\nパーティション列によるフィルターを必須にしない（＝全体スキャンも可能）\n\n\n'gs://.../*'\n対象とするファイル群のパス\n\n\n&gt; pupupuland_store_pos_external_def.json\n結果として、外部テーブル定義を JSON ファイルに保存する"
  },
  {
    "objectID": "posts/2025-07-18-getting-started-with-google-cloud-storage/index.html#references",
    "href": "posts/2025-07-18-getting-started-with-google-cloud-storage/index.html#references",
    "title": "bq commandを用いたPatitioned BigQuery External Tableの作成",
    "section": "References",
    "text": "References\n\nCloud StorageからExternal Tableの作成"
  },
  {
    "objectID": "posts/2025-02-26-law-of-cosines/index.html",
    "href": "posts/2025-02-26-law-of-cosines/index.html",
    "title": "余弦定理の考え方",
    "section": "",
    "text": "Exercise 1 \n\\(AC = 30, BC = 26, \\angle C = 70^\\circ\\) となるような \\(\\triangle ABC\\) が与えられたとします．このとき，長さ \\(AB\\) を求めよ\n\n\n\nCode\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport matplotlib.patches as patches\n\n# 辺の長さと角度\nAC = 30\nBC = 26\nangle_C = 70\n\n# 角度をラジアンに変換\nangle_C_rad = np.radians(angle_C)\n\n# 点Aの座標\nA = (0, 0)\n\nAB = np.sqrt(30**2 + 26**2 - 2 * 30 * 26 * np.cos(np.radians(70)))\n\n# 点Bの座標\nB = (AB, 0)\n\n# 点Cの座標\ncos_A = (30**2 + AB**2 - 26**2) / (2 * 30 * AB)\nsin_A = np.sqrt(1 - cos_A**2)\nC = (30 * cos_A, 30 * sin_A)\n\nslope = - (C[0] - B[0])/(C[1] - B[1])\nH = (24.6, 24.6 * slope)\n\n\n# 座標をリストに変換\nfig, ax = plt.subplots(figsize=(6, 6))\n\nax.plot([A[0], H[0]], [A[1], H[1]], \"k\")  # Black line with circle markers\nax.plot([A[0], B[0]], [A[1], B[1]], \"ko-\")  # Black line with circle markers\nax.plot([B[0], C[0]], [B[1], C[1]], \"ko-\")  # Black line with circle markers\nax.plot([C[0], A[0]], [C[1], A[1]], \"ko-\")  # Black line with circle markers\n\n# 点のラベル\nplt.text(H[0]-2, H[1], \"H\")\nplt.text(A[0]-2, A[1], \"A\")\nplt.text(B[0]+1, B[1], \"B\")\nplt.text(C[0]+1, C[1], \"C\")\n\n# 軸の範囲を設定\nplt.xlim(-5, 35)\nplt.ylim(-5, 35)\n\n# 軸のラベルを設定\nplt.xlabel(\"X\")\nplt.ylabel(\"Y\")\n\n# タイトルを設定\nplt.title(\"Triangle ABC\")\n\n# Add angles as arcs\narc_radius = 5  # Radius for the arcs\n\n# Angle at B\nangle_C_arc = patches.Arc(C, arc_radius*0.8, arc_radius*0.8, angle=250, theta1=np.degrees(320), theta2=np.degrees(70), color='blue')\nax.add_patch(angle_C_arc)\nax.text(C[0]-1, C[1] - arc_radius*.8, f\"{70}°\", fontsize=12, color='blue')\n# ax.text(C[0] + arc_radius/2, B[1] + 1, f\"{70}°\", fontsize=12, color='blue')\nax.text(5, 10, \"AC = 30\", fontsize=12, color='black', horizontalalignment='center')\nax.text(30, 10, \"BC = 26\", fontsize=12, color='black', horizontalalignment='center')\n\n# 図の表示\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 1\n\n\n\nこのとき，点 \\(A\\) から \\(BC\\) に対して垂線を下ろし，その交点を \\(H\\) とします．このとき\n\\[\n\\begin{align}\nCH &= AC * \\cos(C)\\\\\nBH &= BC - AC * \\cos(C)\\\\\nAH& = AC * \\sin(C)\n\\end{align}\n\\]\nピタゴラスの定理より\n\\[\nAB^2 = AH^2 + BH^2\n\\]\nなので\n\\[\n\\begin{align}\nAB^2 &= (BC - AC * \\cos(C))^2 + (AC * \\sin(C))^2\\\\\n     &= BC^2 + AC^2 - 2\\cdot BC\\cdot AC \\cos(C)\n\\end{align}\n\\]\n従って，\n\n\nCode\nprint(f\"AB = {AB:.2f}\")\n\n\nAB = 32.29\n\n\n ▶  ベクトルを用いた直感的理解\nベクトルの内積は \\(\\vec a \\cdot \\vec b = \\lvert a \\rvert \\lvert b \\rvert \\cos \\theta\\) で定義されることを利用すると，\n\\[\n\\begin{aligned}\nAB^2\n    &= \\left\\lvert \\overrightarrow{CA} - \\overrightarrow{CB} \\right\\rvert^2 \\\\\n    &= (\\overrightarrow{CA} - \\overrightarrow{CB}) \\cdot (\\overrightarrow{CA} - \\overrightarrow{CB}) \\\\\n    &= \\left\\lvert \\overrightarrow{CA} \\right\\rvert^2 + \\left\\lvert \\overrightarrow{CB} \\right\\rvert^2\n    - 2 \\overrightarrow{CA} \\cdot \\overrightarrow{CB} \\\\\n    &= \\left\\lvert \\overrightarrow{CA} \\right\\rvert^2 + \\left\\lvert \\overrightarrow{CB} \\right\\rvert^2\n    - 2 \\left\\lvert \\overrightarrow{CA} \\right\\rvert \\left\\lvert \\overrightarrow{CB} \\right\\rvert \\cos(\\angle ACB) \\\\\n    &= AC^2 + BC^2  - 2\\cdot AC\\cdot BC \\cos(C)\n\\end{aligned}\n\\]\n\n\n\n\nExercise 2 \n四角形PABQ が以下のように与えられている\n\n\\(AB = 10\\)\n\\(\\angle PAB = {75}^\\circ\\)\n\\(\\angle PBA = {50}^\\circ\\)\n\\(\\angle PAQ = {40}^\\circ\\)\n\\(\\angle QAB = {35}^\\circ\\)\n\\(\\angle PBQ = {70}^\\circ\\)\n\nこのとき，PQの距離を求めよ．\n\nCode\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport matplotlib.patches as patches\n\n# 辺の長さと角度\nAB = 10\nangle_PAB = np.radians(75)\nangle_PBA = np.radians(50)\nangle_QAB = np.radians(35)\nangle_AQB = np.radians(25)\nangle_QBA = np.radians(120)\nangle_APB = np.radians(55)\n\n\n# 点Aの座標\nA = (0, 0)\n\n# 点Bの座標\nB = (AB, 0)\n\n# 点Pの座標\nPA = AB / np.sin(angle_APB) * np.sin(angle_PBA)\nP = ((np.cos(angle_PAB)) * PA, (np.sin(angle_PAB)) * PA)\n\n# 点Qの座標\nQA = AB / np.sin(angle_AQB) * np.sin(angle_QBA)\nQ = ((np.cos(angle_QAB)) * QA, (np.sin(angle_QAB)) * QA)\n\n\n# 座標をリストに変換\nfig, ax = plt.subplots(figsize=(6, 6))\n\nax.plot([A[0], P[0]], [A[1], P[1]], \"k\")  # Black line with circle markers\nax.plot([A[0], B[0]], [A[1], B[1]], \"ko-\")  # Black line with circle markers\nax.plot([B[0], P[0]], [B[1], P[1]], \"ko-\")  # Black line with circle markers\nax.plot([Q[0], A[0]], [Q[1], A[1]], \"ko-\")  # Black line with circle markers\nax.plot([Q[0], B[0]], [Q[1], B[1]], \"ko-\")  # Black line with circle markers\nax.plot([Q[0], P[0]], [Q[1], P[1]], \"ko-\")  # Black line with circle markers\n\n# 点のラベル\nplt.text(A[0] - 1, A[1], \"A\")\nplt.text(B[0] + 1, B[1], \"B\")\nplt.text(P[0], P[1] + 1, \"P\")\nplt.text(Q[0] + 1, Q[1], \"Q\")\n\n# 軸の範囲を設定\nplt.xlim(-2, 20)\nplt.ylim(-2, 20)\n\n# 軸のラベルを設定\nplt.xlabel(\"X\")\nplt.ylabel(\"Y\")\n\n# タイトルを設定\nplt.title(\"How far is the distance between P and Q\")\n\n# Add angles as arcs\narc_radius = 5  # Radius for the arcs\n\n# Angle at B\nax.text(A[0] + 1, A[1] + 1.8, f\"{40}°\", fontsize=10, color=\"blue\")\nax.text(A[0] + 1, A[1] + 0.2, f\"{35}°\", fontsize=10, color=\"blue\")\nax.text(B[0] - 2, B[1] + 0.2, f\"{50}°\", fontsize=10, color=\"blue\")\nax.text(B[0] - 0.5, B[1] + 1, f\"{70}°\", fontsize=10, color=\"blue\")\n# ax.text(C[0] + arc_radius/2, B[1] + 1, f\"{70}°\", fontsize=12, color='blue')\nax.text(5, -1, \"AB = 10\", fontsize=12, color=\"black\", horizontalalignment=\"center\")\nax.text(\n    (P[0] + Q[0]) / 2,\n    (P[1] + Q[1]) / 2 + 1,\n    \"PQ = ???\",\n    fontsize=12,\n    color=\"black\",\n    horizontalalignment=\"center\",\n)\n\n\n# 図の表示\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 2\n\n\n\n\n\n\n\n\n\n\n\n\nNoteSolution 1: 余弦定理を用いて解く\n\n\n\n\n\n\\(\\angle PAQ = {40}^\\circ\\) と問題分よりわかるので，\\(PA, QA\\) の長さがわかれば余弦定理より \\(PQ\\) が導出できます．\n正弦定理を用いて\n\\[\n\\begin{align}\nPA &= \\frac{AB}{\\sin({55}^\\circ)}\\times \\sin({50}^\\circ)\\\\\nQA &= \\frac{AB}{\\sin({25}^\\circ)}\\times \\sin({120}^\\circ)\n\\end{align}\n\\]\n余弦定理を用いると\n\\[\nPQ^2 = QA^2 + PA^2 - 2(PA)(QA)\\cos({40}^\\circ)\n\\]\nよって，\n\n\nCode\n# set variables\nAB = 10\nangle_APB = np.radians(55)\nangle_AQB = np.radians(25)\nangle_PBA = np.radians(50)\nangle_QBA = np.radians(120)\nangle_PAQ = np.radians(40)\n\n\n# compute PA and QA\nPA = AB / np.sin(angle_APB) * np.sin(angle_PBA)\nQA = AB / np.sin(angle_AQB) * np.sin(angle_QBA)\n\n\n# comnpute PQ using laws of cosines\nPQ = np.sqrt(PA ** 2 + QA **2 - 2 * PA * QA * np.cos(angle_PAQ))\n\nprint(f\"PQ = {PQ:.2f}\")\n\n\nPQ = 14.62\n\n\n\n\n\n\n\n\n\n\n\n\nNoteSolution 2: 座標を用いて解く\n\n\n\n\n\n各点を \\(XY\\) 平明座標に以下のように置き換えます\n\n\\(A\\) = (0, 0)\n\\(B\\) = (0, 10)\n\nこのとき，点 \\(P\\) の座標 \\((P_X, P_Y)\\) は\n\\[\n\\begin{align}\nP_X & = PA \\cdot \\cos({75}^\\circ)\\\\\nP_Y & = PA \\cdot \\sin({75}^\\circ)\n\\end{align}\n\\]\n同様に点 \\(Q\\) の座標 \\((Q_X, Q_Y)\\) は\n\\[\n\\begin{align}\nQ_X & = QA \\cdot \\cos({35}^\\circ)\\\\\nQ_Y & = QA \\cdot \\sin({35}^\\circ)\n\\end{align}\n\\]\nこのとき，長さ \\(PQ\\) は点 \\(P, Q\\) の距離と表せるので\n\\[\n\\begin{align}\nPQ &= \\lVert P - Q \\rVert\\\\\n   &= \\sqrt{(P_X - Q_X)^2 + (P_Y - Q_Y)^2}\\\\\n   &= \\sqrt{(AQ^2 + PA^2 - 2(PA)(QA)(\\cos({35}^\\circ)\\cos({75}^\\circ) + \\sin({35}^\\circ)\\sin({75}^\\circ)))}\n\\end{align}\n\\]\n加法定理より\n\\[\n\\cos (A \\pm B) = \\cos A \\cos B \\mp \\sin A \\sin B\n\\]\nなので\n\\[\n\\cos({35}^\\circ)\\cos({75}^\\circ) + \\sin({35}^\\circ)\\sin({75}^\\circ) = \\cos({40}^\\circ)\n\\]\n従って，\n\\[\nPQ^2 = QA^2 + PA^2 - 2(PA)(QA)\\cos({40}^\\circ)\n\\]"
  },
  {
    "objectID": "posts/2025-02-26-law-of-cosines/index.html#余弦定理の考え方",
    "href": "posts/2025-02-26-law-of-cosines/index.html#余弦定理の考え方",
    "title": "余弦定理の考え方",
    "section": "",
    "text": "Exercise 1 \n\\(AC = 30, BC = 26, \\angle C = 70^\\circ\\) となるような \\(\\triangle ABC\\) が与えられたとします．このとき，長さ \\(AB\\) を求めよ\n\n\n\nCode\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport matplotlib.patches as patches\n\n# 辺の長さと角度\nAC = 30\nBC = 26\nangle_C = 70\n\n# 角度をラジアンに変換\nangle_C_rad = np.radians(angle_C)\n\n# 点Aの座標\nA = (0, 0)\n\nAB = np.sqrt(30**2 + 26**2 - 2 * 30 * 26 * np.cos(np.radians(70)))\n\n# 点Bの座標\nB = (AB, 0)\n\n# 点Cの座標\ncos_A = (30**2 + AB**2 - 26**2) / (2 * 30 * AB)\nsin_A = np.sqrt(1 - cos_A**2)\nC = (30 * cos_A, 30 * sin_A)\n\nslope = - (C[0] - B[0])/(C[1] - B[1])\nH = (24.6, 24.6 * slope)\n\n\n# 座標をリストに変換\nfig, ax = plt.subplots(figsize=(6, 6))\n\nax.plot([A[0], H[0]], [A[1], H[1]], \"k\")  # Black line with circle markers\nax.plot([A[0], B[0]], [A[1], B[1]], \"ko-\")  # Black line with circle markers\nax.plot([B[0], C[0]], [B[1], C[1]], \"ko-\")  # Black line with circle markers\nax.plot([C[0], A[0]], [C[1], A[1]], \"ko-\")  # Black line with circle markers\n\n# 点のラベル\nplt.text(H[0]-2, H[1], \"H\")\nplt.text(A[0]-2, A[1], \"A\")\nplt.text(B[0]+1, B[1], \"B\")\nplt.text(C[0]+1, C[1], \"C\")\n\n# 軸の範囲を設定\nplt.xlim(-5, 35)\nplt.ylim(-5, 35)\n\n# 軸のラベルを設定\nplt.xlabel(\"X\")\nplt.ylabel(\"Y\")\n\n# タイトルを設定\nplt.title(\"Triangle ABC\")\n\n# Add angles as arcs\narc_radius = 5  # Radius for the arcs\n\n# Angle at B\nangle_C_arc = patches.Arc(C, arc_radius*0.8, arc_radius*0.8, angle=250, theta1=np.degrees(320), theta2=np.degrees(70), color='blue')\nax.add_patch(angle_C_arc)\nax.text(C[0]-1, C[1] - arc_radius*.8, f\"{70}°\", fontsize=12, color='blue')\n# ax.text(C[0] + arc_radius/2, B[1] + 1, f\"{70}°\", fontsize=12, color='blue')\nax.text(5, 10, \"AC = 30\", fontsize=12, color='black', horizontalalignment='center')\nax.text(30, 10, \"BC = 26\", fontsize=12, color='black', horizontalalignment='center')\n\n# 図の表示\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 1\n\n\n\nこのとき，点 \\(A\\) から \\(BC\\) に対して垂線を下ろし，その交点を \\(H\\) とします．このとき\n\\[\n\\begin{align}\nCH &= AC * \\cos(C)\\\\\nBH &= BC - AC * \\cos(C)\\\\\nAH& = AC * \\sin(C)\n\\end{align}\n\\]\nピタゴラスの定理より\n\\[\nAB^2 = AH^2 + BH^2\n\\]\nなので\n\\[\n\\begin{align}\nAB^2 &= (BC - AC * \\cos(C))^2 + (AC * \\sin(C))^2\\\\\n     &= BC^2 + AC^2 - 2\\cdot BC\\cdot AC \\cos(C)\n\\end{align}\n\\]\n従って，\n\n\nCode\nprint(f\"AB = {AB:.2f}\")\n\n\nAB = 32.29\n\n\n ▶  ベクトルを用いた直感的理解\nベクトルの内積は \\(\\vec a \\cdot \\vec b = \\lvert a \\rvert \\lvert b \\rvert \\cos \\theta\\) で定義されることを利用すると，\n\\[\n\\begin{aligned}\nAB^2\n    &= \\left\\lvert \\overrightarrow{CA} - \\overrightarrow{CB} \\right\\rvert^2 \\\\\n    &= (\\overrightarrow{CA} - \\overrightarrow{CB}) \\cdot (\\overrightarrow{CA} - \\overrightarrow{CB}) \\\\\n    &= \\left\\lvert \\overrightarrow{CA} \\right\\rvert^2 + \\left\\lvert \\overrightarrow{CB} \\right\\rvert^2\n    - 2 \\overrightarrow{CA} \\cdot \\overrightarrow{CB} \\\\\n    &= \\left\\lvert \\overrightarrow{CA} \\right\\rvert^2 + \\left\\lvert \\overrightarrow{CB} \\right\\rvert^2\n    - 2 \\left\\lvert \\overrightarrow{CA} \\right\\rvert \\left\\lvert \\overrightarrow{CB} \\right\\rvert \\cos(\\angle ACB) \\\\\n    &= AC^2 + BC^2  - 2\\cdot AC\\cdot BC \\cos(C)\n\\end{aligned}\n\\]\n\n\n\n\nExercise 2 \n四角形PABQ が以下のように与えられている\n\n\\(AB = 10\\)\n\\(\\angle PAB = {75}^\\circ\\)\n\\(\\angle PBA = {50}^\\circ\\)\n\\(\\angle PAQ = {40}^\\circ\\)\n\\(\\angle QAB = {35}^\\circ\\)\n\\(\\angle PBQ = {70}^\\circ\\)\n\nこのとき，PQの距離を求めよ．\n\nCode\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport matplotlib.patches as patches\n\n# 辺の長さと角度\nAB = 10\nangle_PAB = np.radians(75)\nangle_PBA = np.radians(50)\nangle_QAB = np.radians(35)\nangle_AQB = np.radians(25)\nangle_QBA = np.radians(120)\nangle_APB = np.radians(55)\n\n\n# 点Aの座標\nA = (0, 0)\n\n# 点Bの座標\nB = (AB, 0)\n\n# 点Pの座標\nPA = AB / np.sin(angle_APB) * np.sin(angle_PBA)\nP = ((np.cos(angle_PAB)) * PA, (np.sin(angle_PAB)) * PA)\n\n# 点Qの座標\nQA = AB / np.sin(angle_AQB) * np.sin(angle_QBA)\nQ = ((np.cos(angle_QAB)) * QA, (np.sin(angle_QAB)) * QA)\n\n\n# 座標をリストに変換\nfig, ax = plt.subplots(figsize=(6, 6))\n\nax.plot([A[0], P[0]], [A[1], P[1]], \"k\")  # Black line with circle markers\nax.plot([A[0], B[0]], [A[1], B[1]], \"ko-\")  # Black line with circle markers\nax.plot([B[0], P[0]], [B[1], P[1]], \"ko-\")  # Black line with circle markers\nax.plot([Q[0], A[0]], [Q[1], A[1]], \"ko-\")  # Black line with circle markers\nax.plot([Q[0], B[0]], [Q[1], B[1]], \"ko-\")  # Black line with circle markers\nax.plot([Q[0], P[0]], [Q[1], P[1]], \"ko-\")  # Black line with circle markers\n\n# 点のラベル\nplt.text(A[0] - 1, A[1], \"A\")\nplt.text(B[0] + 1, B[1], \"B\")\nplt.text(P[0], P[1] + 1, \"P\")\nplt.text(Q[0] + 1, Q[1], \"Q\")\n\n# 軸の範囲を設定\nplt.xlim(-2, 20)\nplt.ylim(-2, 20)\n\n# 軸のラベルを設定\nplt.xlabel(\"X\")\nplt.ylabel(\"Y\")\n\n# タイトルを設定\nplt.title(\"How far is the distance between P and Q\")\n\n# Add angles as arcs\narc_radius = 5  # Radius for the arcs\n\n# Angle at B\nax.text(A[0] + 1, A[1] + 1.8, f\"{40}°\", fontsize=10, color=\"blue\")\nax.text(A[0] + 1, A[1] + 0.2, f\"{35}°\", fontsize=10, color=\"blue\")\nax.text(B[0] - 2, B[1] + 0.2, f\"{50}°\", fontsize=10, color=\"blue\")\nax.text(B[0] - 0.5, B[1] + 1, f\"{70}°\", fontsize=10, color=\"blue\")\n# ax.text(C[0] + arc_radius/2, B[1] + 1, f\"{70}°\", fontsize=12, color='blue')\nax.text(5, -1, \"AB = 10\", fontsize=12, color=\"black\", horizontalalignment=\"center\")\nax.text(\n    (P[0] + Q[0]) / 2,\n    (P[1] + Q[1]) / 2 + 1,\n    \"PQ = ???\",\n    fontsize=12,\n    color=\"black\",\n    horizontalalignment=\"center\",\n)\n\n\n# 図の表示\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 2\n\n\n\n\n\n\n\n\n\n\n\n\nNoteSolution 1: 余弦定理を用いて解く\n\n\n\n\n\n\\(\\angle PAQ = {40}^\\circ\\) と問題分よりわかるので，\\(PA, QA\\) の長さがわかれば余弦定理より \\(PQ\\) が導出できます．\n正弦定理を用いて\n\\[\n\\begin{align}\nPA &= \\frac{AB}{\\sin({55}^\\circ)}\\times \\sin({50}^\\circ)\\\\\nQA &= \\frac{AB}{\\sin({25}^\\circ)}\\times \\sin({120}^\\circ)\n\\end{align}\n\\]\n余弦定理を用いると\n\\[\nPQ^2 = QA^2 + PA^2 - 2(PA)(QA)\\cos({40}^\\circ)\n\\]\nよって，\n\n\nCode\n# set variables\nAB = 10\nangle_APB = np.radians(55)\nangle_AQB = np.radians(25)\nangle_PBA = np.radians(50)\nangle_QBA = np.radians(120)\nangle_PAQ = np.radians(40)\n\n\n# compute PA and QA\nPA = AB / np.sin(angle_APB) * np.sin(angle_PBA)\nQA = AB / np.sin(angle_AQB) * np.sin(angle_QBA)\n\n\n# comnpute PQ using laws of cosines\nPQ = np.sqrt(PA ** 2 + QA **2 - 2 * PA * QA * np.cos(angle_PAQ))\n\nprint(f\"PQ = {PQ:.2f}\")\n\n\nPQ = 14.62\n\n\n\n\n\n\n\n\n\n\n\n\nNoteSolution 2: 座標を用いて解く\n\n\n\n\n\n各点を \\(XY\\) 平明座標に以下のように置き換えます\n\n\\(A\\) = (0, 0)\n\\(B\\) = (0, 10)\n\nこのとき，点 \\(P\\) の座標 \\((P_X, P_Y)\\) は\n\\[\n\\begin{align}\nP_X & = PA \\cdot \\cos({75}^\\circ)\\\\\nP_Y & = PA \\cdot \\sin({75}^\\circ)\n\\end{align}\n\\]\n同様に点 \\(Q\\) の座標 \\((Q_X, Q_Y)\\) は\n\\[\n\\begin{align}\nQ_X & = QA \\cdot \\cos({35}^\\circ)\\\\\nQ_Y & = QA \\cdot \\sin({35}^\\circ)\n\\end{align}\n\\]\nこのとき，長さ \\(PQ\\) は点 \\(P, Q\\) の距離と表せるので\n\\[\n\\begin{align}\nPQ &= \\lVert P - Q \\rVert\\\\\n   &= \\sqrt{(P_X - Q_X)^2 + (P_Y - Q_Y)^2}\\\\\n   &= \\sqrt{(AQ^2 + PA^2 - 2(PA)(QA)(\\cos({35}^\\circ)\\cos({75}^\\circ) + \\sin({35}^\\circ)\\sin({75}^\\circ)))}\n\\end{align}\n\\]\n加法定理より\n\\[\n\\cos (A \\pm B) = \\cos A \\cos B \\mp \\sin A \\sin B\n\\]\nなので\n\\[\n\\cos({35}^\\circ)\\cos({75}^\\circ) + \\sin({35}^\\circ)\\sin({75}^\\circ) = \\cos({40}^\\circ)\n\\]\n従って，\n\\[\nPQ^2 = QA^2 + PA^2 - 2(PA)(QA)\\cos({40}^\\circ)\n\\]"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "某経済学研究科修士取得後，どこかのコンサル会社に勤務してます． Arsenalが好きです．"
  }
]