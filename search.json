[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "某経済学研究科修士取得後，どこかのコンサル会社に勤務してます． Arsenalが好きです．"
  },
  {
    "objectID": "posts/2025-05-23-what-to-write-in-wiki/index.html",
    "href": "posts/2025-05-23-what-to-write-in-wiki/index.html",
    "title": "wikiにどのような情報をどのように残すか？",
    "section": "",
    "text": "NoteKey Takeaways\n\n\n\n\n\n\nWiki は，みんなが自由に編集できる Web サイト\n書かないよりかは書く！\n慣れてきたら，ストック情報を意識して何をWikiに記載すべきか判断する\nメタデータ（タイトル，作成者，更新日，タグ，関連資料など）を活用することで，情報の検索性・管理性・再利用性が向上する"
  },
  {
    "objectID": "posts/2025-05-23-what-to-write-in-wiki/index.html#projectと情報共有の課題",
    "href": "posts/2025-05-23-what-to-write-in-wiki/index.html#projectと情報共有の課題",
    "title": "wikiにどのような情報をどのように残すか？",
    "section": "1. Projectと情報共有の課題",
    "text": "1. Projectと情報共有の課題\n仕事の中で情報共有の課題はしばしば発生します．その発生の仕方は以下の２つが代表例としてあります．\n課題1：必要な情報が共有されていない\n\n\n\n\n\n\n\n\n事象\n問題分類\n\n\n\n\n退職・異動時に「前任者しか知らないこと」が多く，後任が混乱\n属人化問題\n\n\n同じ業務でも人によってやり方がバラバラ（手順の標準化がされていない）\nナレッジの一元化できてない問題\n\n\n毎回「この件ってどうやるんでしたっけ？」という質問が発生する\n非効率なコミュニケーション\n\n\n\n\n\n課題2：必要な情報を見つけるのが難しい\n\n\n\n\n\n\n\n\n事象\n問題分類\n\n\n\n\n手順書は共有フォルダ，仕様はメール，背景はSlack…とバラバラ\n情報の散逸問題\n\n\n検索しても古いバージョンや関係ない資料が出てきて混乱\n情報の最新化・正確性問題"
  },
  {
    "objectID": "posts/2025-05-23-what-to-write-in-wiki/index.html#projectにおけるwiki",
    "href": "posts/2025-05-23-what-to-write-in-wiki/index.html#projectにおけるwiki",
    "title": "wikiにどのような情報をどのように残すか？",
    "section": "2. ProjectにおけるWiki",
    "text": "2. ProjectにおけるWiki\n\nDefinition 1 Wiki \nプロジェクトやチームの知識・ノウハウ・手順・ルールなどを，誰でも編集・追加できる形で蓄積・共有するためのドキュメントシステムのことをWikiと呼ぶ．\n\nWikiは，単なるメモやドキュメントの集積ではなく，以下のような効果を持ったプロジェクトの「知識のインフラ」として機能します．\n\nナレッジの一元化\n属人化の防止\nコミュニケーションの効率化\n\n\n\nナレッジの一元化\n\n\nナレッジの一元化とは，プロジェクトやチームに関する情報・ノウハウ・手順・ルールなどを，分散せずに一箇所（Wikiなど）に集約して管理することを指します．これにより，以下のようなメリットがあります。\n\n情報の散逸防止\n\n口頭や個人メモ，チャットログなどに分散しがちな情報を，Wikiにまとめることで「どこに何が書いてあるか分からない」「必要な情報が見つからない」といった事態を防げます\n\n情報の最新化・正確性の維持\n\n仕様変更や新しい知見が得られた際，Wikiを更新するだけで全員が最新情報を参照でき，古い情報によるミスや認識ズレを防止できます\n\n\n\n\n属人化の防止\n\n\n属人化とは，特定の業務やノウハウが一部の人だけに依存し，その人がいないと作業が進まない・問題が解決できない状態を指します．Wikiは以下の観点からこの属人化を防ぐための有効なツールです．\n\n情報の共有・可視化\n\n業務手順やトラブル対応，設定方法などをWikiに記録することで，誰でも同じ情報にアクセスできるようになります\nこれにより，担当者が不在でも他のメンバーが対応可能となり，業務の停滞を防げます\n\nノウハウの蓄積と継承\n\n経験者が持つ暗黙知やコツを明文化してWikiに残すことで，後任者や新メンバーへのスムーズな引き継ぎが可能になります\n\nチーム全体のスキル底上げ\n\n皆がWikiを活用・更新することで，チーム全体の知識レベルが向上し，特定の人に依存しない強い組織づくりにつながります\n\n\n\n\nコミュニケーションの効率化\n\n\nコミュニケーションの非効率とは，情報が構造化されていないことや，一元管理されていないによって発生する無駄な時間のことです．例として以下のようなものがあります\n\n\n\n\n\n\n\n\n課題・現象\nコスト分類\n\n\n\n\n毎回同じ質問が繰り返される\n説明コスト\n\n\n情報が人によってバラバラで食い違う\n認識齟齬コスト\n\n\n確認・共有・引き継ぎに時間がかかる\n説明コスト・情報探索コスト\n\n\nメールやチャットを遡らないと情報が見つからない\n情報探索コスト\n\n\n\n\nWikiを活用することで上記のような「説明コスト」「認識齟齬コスト」「情報探索コスト」を以下のような機序で削減することができます\n\n説明コストの削減\n\nよくある質問や手順，ルールなどをWikiにまとめておくことで，同じ内容を何度も口頭やチャットで説明する必要がなくなります\n新メンバーや他部署からの問い合わせにも「Wikiを参照してください」と非同期コミュニケーションの案内でき，対応コストを大幅に削減できます\n仕様や方針，過去の議論の経緯などをWikiに記録しておくことで，議論のたびに一から説明したり，過去の経緯を探す手間が省けます\n\n認識齟齬コストの低減\n\nWikiに記載された内容は誰でも同じものを参照できるため，伝言ゲームによる情報のズレや誤解を防げます\n\n情報探索コストの低減\n\n業務に必要な情報（手順・FAQ・ルール・用語解説など）を構造的に蓄積・整理することで，情報の「どこにあるか」「最新版はどれか」を探す時間を減らすことができます"
  },
  {
    "objectID": "posts/2025-05-23-what-to-write-in-wiki/index.html#wikiに書くべき情報",
    "href": "posts/2025-05-23-what-to-write-in-wiki/index.html#wikiに書くべき情報",
    "title": "wikiにどのような情報をどのように残すか？",
    "section": "3. Wikiに書くべき情報",
    "text": "3. Wikiに書くべき情報\nWikiには情報を多く残せば残すほど基本的に良いですが，「フロー」と「ストック」という観点で情報を事前に整理することがより良いwikiへと繋がります．Wikiはストック型の情報を蓄積する場所であるので，「これはストック化すべき情報だ」と事前に分類・判断して整理する必要があります．\n\n\nフロー情報\n\n\n\n時系列に流れていく情報\n生まれた直後は価値が高く，時間やプロジェクト進行の経過と共に価値が下がっていく\n例: Slackやメールでのやり取り，日報・会議メモなど\n\n\nストック情報\n\n\n\n長期的に価値があり，何度も参照される情報\n例: マニュアルや設計書，仕様書など\n\n\n「フローとストックの区別」と良いWiki\n\n\n「フローとストックの区別」の視点を持つことで，以下のようなメリットがあります：\n\nWikiがごみ箱化せず，構造的に整理される\n情報の探しやすさが向上\n\n具体的な運用例\n\n\n\n\n\n\n\n\n\n情報の種類\n最初は\nその後\n\n\n\n\n新しいやり方の試行錯誤\nSlackで議論（フロー）\n成功したら手順をWikiに整理（ストック）\n\n\n問い合わせへの回答\nチャットで返す（フロー）\nよくある質問ならFAQとしてまとめる（ストック）\n\n\nプロジェクトの背景や目的\n議事録で共有（フロー）\n重要事項はWikiのプロジェクトページに追記（ストック）"
  },
  {
    "objectID": "posts/2025-05-23-what-to-write-in-wiki/index.html#coding-projectでwikiに書くべき情報",
    "href": "posts/2025-05-23-what-to-write-in-wiki/index.html#coding-projectでwikiに書くべき情報",
    "title": "wikiにどのような情報をどのように残すか？",
    "section": "4. Coding ProjectでWikiに書くべき情報",
    "text": "4. Coding ProjectでWikiに書くべき情報\n\nGoal: 開発メンバー全員が迷わず効率よく開発・運用できる\n\n\n\nWikiを書く目的は情報伝達の課題を解決するため\nCoding Projectにおいて情報伝達課題の解決はプロジェクトの生産性・品質・持続性を大きく左右する\n\n\n\n\n\n\n\n\n\nWikiに書く内容\nどの「迷い」や「非効率」を減らすか\n\n\n\n\n環境構築手順\n「動かない」「セットアップ方法がわからない」\n\n\n技術スタック・設計方針\n「なぜこの技術を使ってるの？」「全体像が見えない」\n\n\nコーディングルール・ブランチ戦略\n「このファイル名でいい？」「この書き方でOK？」\n\n\nデプロイ手順・運用ルール\n「本番反映って誰がどうやってるの？」\n\n\nFAQ・トラブル対応\n「よくあるエラーが出た，どうすればいい？」"
  },
  {
    "objectID": "posts/2025-05-23-what-to-write-in-wiki/index.html#metadata-fieldの活用",
    "href": "posts/2025-05-23-what-to-write-in-wiki/index.html#metadata-fieldの活用",
    "title": "wikiにどのような情報をどのように残すか？",
    "section": "5. metadata fieldの活用",
    "text": "5. metadata fieldの活用\nmetadata fieldを明確に設定することで，情報の管理性・検索性・再利用性が大きく向上します．\nmetadata field活用の効果\n\n\n\n\n目的\nメタデータが果たす役割\n\n\n\n\n検索性向上\nタグ・対象環境・チームでフィルタリング可能\n\n\n責任の明確化\n作成者/責任者がわかることで内容の信用度が上がる\n\n\n鮮度の判断\n更新日で「使える情報か？」を判断できる\n\n\nナレッジの繋がり\n関連リンクでページ間の文脈を可視化できる\n\n\n\n\n\nmetadata field項目例\n\n\n\n\n\n\n\n\n\nフィールド名\n内容\n記入例・補足\n\n\n\n\nタイトル / name\nページの内容をひと目で表すタイトル\n環境構築手順（ローカル） / バックエンド設計方針\n\n\n作成者 / author\n初期作成者，または責任者\nr.nak（Slack名やGitHubアカウントで統一）\n\n\n最終更新日 / last_updated\n内容が最後に更新された日時\n2025-05-23（日付のみ or タイムスタンプ）\n\n\n関連タグ / tags\n分類や検索性向上のためのタグ群\n#backend, #setup, #api, #infra\n\n\n対象環境 / environment\n適用される環境やバージョン範囲\nlocal, staging, v2.3.1〜\n\n\n関連資料 / related_docs\n他ページや外部リンクへの参照\n[デプロイ手順](../deployment.md) / URL可\n\n\n更新履歴 / changelog\n主な更新内容と日付\n2025-05-23: Docker対応を追加2025-03-01: 初版作成\n\n\n\n\n\nmetadata field実装例\n\nMarkdown with yamlConfluence\n\n\n---\ntitle: \"ローカル環境構築ガイド\"\nauthor: \"r.nak\"\nlast_updated: \"2025-05-23\"\ntags: [\"setup\", \"backend\", \"docker\"]\nenvironment: \"local\"\nteam: \"backend\"\nis_obsolete: false\nrelated_docs:\n  - \"../deployment.md\"\n  - \"https://example.com/db-guide\"\nchangelog:\n  - \"2025-05-23: Docker対応を追加\"\n  - \"2025-03-01: 初版作成\"\n---\n\n\n\nページの冒頭に「テーブル形式」でメタ情報を記述\nテーブルを「ページプロパティマクロ」で囲む\n他ページから「ページプロパティレポートマクロ」で一覧化が可能"
  },
  {
    "objectID": "posts/2025-05-23-what-to-write-in-wiki/index.html#wiki運用tips",
    "href": "posts/2025-05-23-what-to-write-in-wiki/index.html#wiki運用tips",
    "title": "wikiにどのような情報をどのように残すか？",
    "section": "5. Wiki運用Tips",
    "text": "5. Wiki運用Tips\nWikiは「作って終わり」ではなく，「育てて使い続ける」ことで真価を発揮します．一方，更新を怠り最新情報が反映されていなかったり，信頼性が低い内容が記載されていたりなど実運用ではトラブルが発生します．\n\nトラブル1：情報が乱立・重複してどれが正しいか分からない\n\n\n\n\n\n\n\n\n\n\n原因・目的\n対策内容\n効果・備考\n\n\n\n\n情報の分類が曖昧・乱立しやすい\nタグを事前定義（例：setup, troubleshooting, design, infra, FAQ）\nページの役割や内容を明確化し，重複や検索漏れを防ぐ\n\n\nページの乱立・重複・古い情報の放置\n定期的な「重複・類似ページ見直し会」（ミニレビュー）\n定期的な棚卸しで情報の鮮度・整理を維持し，正しい情報を残す\n\n\n古い情報や非推奨手順が残りやすい\nis_obsolete: true フラグで非推奨情報を明示\n利用者が「どれが最新・有効か」を一目で判断できるようにする\n\n\n\n\n\n\nトラブル2：情報の更新漏れで古い手順が誤用される\n\n\n\n\n\n\n\n\n\n\n原因・目的\n対策内容\n効果・備考\n\n\n\n\n情報の鮮度が分からず古い手順が誤用される\n「更新日」フィールドを必須化\nページごとに最新更新日が明示され，利用者が情報の新旧を判断しやすくなる\n\n\n実運用の変更がWikiに反映されないまま放置される\nPRや障害対応のチェックリストに「Wiki更新」を追加\n運用変更や障害対応のたびにWiki更新を強制し，情報の陳腐化・誤用を防ぐ\n\n\n\n\n\n\nトラブル3：誰が書いたのか分からず，内容の信頼性が低い\n\n\n\n\n\n\n\n\n\n\n原因・目的\n対策内容\n効果・備考\n\n\n\n\nページの責任者が不明で内容の信頼性や更新責任が曖昧になる\nすべてのページに「Author（責任者）」を必須項目として設定\n責任者が明確になり，内容の信頼性・更新体制が向上する\n\n\n担当者不在で情報が放置される\n作成者が異動・退職したページの担当を再割当\n継続的な管理・更新体制を維持できる\n\n\n責任者不明ページの放置・情報の陳腐化\n「責任者が不明なページ一覧」を抽出し，棚卸しリストに追加\n定期的な棚卸しで責任者を再割当し，情報の鮮度と信頼性を保つ\n\n\n\n\n\nトラブル4：一部の人しかWikiを更新しない\n\n\n\n\n\n\n\n\n\n\n原因・目的\n対策内容\n効果・備考\n\n\n\n\n書き方が分からず記載が進まない・属人化\nテンプレートを整備し，書く敷居を下げる\n誰でも迷わず記載でき，情報の質と量が安定する\n\n\n重要な情報が口頭やチャットで流れてしまう\nSlackやMTGで「この話Wikiに書いておこう」と声かけする文化作り\n情報のストック化が進み，ナレッジの蓄積・共有が促進される\n\n\n\n\n\n\nトラブル5：作っても使われない\n\n\n\n\n\n\n\n\n\n\n原因・目的\n対策内容\n効果・備考\n\n\n\n\n重要情報が分散し見つけづらい\nオンボーディング資料，障害手順書，開発ルールなど，必ず参照する情報をWikiに集約\n必要な情報が一箇所で見つかり，迷いなく参照できる\n\n\n質問・回答がチャットで流れてしまう\nSlackで「この質問，Wikiにありましたよ」文化をつくる\n情報のストック化が進み，同じ質問の繰り返しを防ぐ\n\n\nWikiの構造が複雑・不親切\n初心者でもどこから見ればいいか分かる構造をつくる\n迷わず必要な情報にたどり着ける，オンボーディングも円滑\n\n\n利用者視点の改善が進まない\nユーザーを巻き込むUI改善アンケートやフィードバック導線\n実際の利用者の声を反映し，使いやすいWiki運用が実現できる"
  },
  {
    "objectID": "posts/2025-05-23-what-to-write-in-wiki/index.html#references",
    "href": "posts/2025-05-23-what-to-write-in-wiki/index.html#references",
    "title": "wikiにどのような情報をどのように残すか？",
    "section": "References",
    "text": "References\n\nサル先生のWiki入門"
  },
  {
    "objectID": "posts/2025-08-01-firewall-settings/index.html",
    "href": "posts/2025-08-01-firewall-settings/index.html",
    "title": "Ubuntu 22.04でのfirewall設定",
    "section": "",
    "text": "ufwを用いてUbuntu 22.04用のファイアウォールルールを設定する\n\nPrerequisites\n\n\n\n\n条件\n備考\n\n\n\n\nufwインストール済み\napt-get install ufw\n\n\nufw有効化\nsudo  ufw enable"
  },
  {
    "objectID": "posts/2025-08-01-firewall-settings/index.html#ゴール",
    "href": "posts/2025-08-01-firewall-settings/index.html#ゴール",
    "title": "Ubuntu 22.04でのfirewall設定",
    "section": "",
    "text": "ufwを用いてUbuntu 22.04用のファイアウォールルールを設定する\n\nPrerequisites\n\n\n\n\n条件\n備考\n\n\n\n\nufwインストール済み\napt-get install ufw\n\n\nufw有効化\nsudo  ufw enable"
  },
  {
    "objectID": "posts/2025-08-01-firewall-settings/index.html#ufwとは",
    "href": "posts/2025-08-01-firewall-settings/index.html#ufwとは",
    "title": "Ubuntu 22.04でのfirewall設定",
    "section": "ufwとは？",
    "text": "ufwとは？\n\nDefinition 1 ufw(Unbcomplicated Firewall)\n\nUbuntu のファイアウォール設定ツール\niptablesのフロントエンド\n初期状態では無効になっており，ユーザーが手動で有効にする必要がある\n設定内容は /etc/ufw/user.rules (IPv4) と /etc/ufw/user6.rules (IPv6) に保存される\nファイル形式のようなアプリケーション層のコンテンツ制御は直接はできない\n\n\nufwは，netfilter を管理するためのフレームワークと，ファイアウォールを操作するためのCLIを提供してくれるソフトです．\nLinuxカーネルには，Netfilterというパケットフィルタリング機能があります．パケットの通過の可否の判断は，基本的に通信経路，IPアドレス，ポート番号，ポリシーの組み合わせで行われます． なお，デフォルトでは外部からは必要最低限のネットワーク通信しか受け付けないようにファイアウォールが設定されています．\n通信経路\n\n\n\n\n通信経路\n説明\n\n\n\n\n入力(Incoming)\n外部からLinuxへ入ってくる通信経路\n\n\n出力(Outgoing)\nLinuxから外部へ出ていく通信経路\n\n\n転送(Routed)\n別ホストへ転送する通信経路\n\n\n\n\nIPアドレス\n\n特定のクライアントのみに接続を許可したい場合のルール\n不特定多数に提供するサービスのサーバーでは設定が困難\n\n特定のIPからだけ3000ポートへの入力を許可する場合は\nsudo ufw allow from 192.168.1.100 to any port 3000\n送信先ポート番号\n入力方向(IN)の場合，任意の送信元IPからポート3000へのアクセス許可をする場合は\nsudo ufw allow to any port 3000\nポリシー\n\n\n\n\nポリシー\n説明\n\n\n\n\nallow\nルールにマッチしなかった通信を許可\n\n\ndeny\n通信を破棄\n\n\nreject\n通信を拒否してエラーを返す\n\n\n\n\n\nufw defaultの設定書式\n\nSyntax\nufw default allow|deny|reject [incomming|outgoing|routed]\n\n\n通常は内部から外部へのOutgoingのみallowにすることを推奨"
  },
  {
    "objectID": "posts/2025-08-01-firewall-settings/index.html#ufwコマンドを用いたファイヤーウォール設定",
    "href": "posts/2025-08-01-firewall-settings/index.html#ufwコマンドを用いたファイヤーウォール設定",
    "title": "Ubuntu 22.04でのfirewall設定",
    "section": "ufwコマンドを用いたファイヤーウォール設定",
    "text": "ufwコマンドを用いたファイヤーウォール設定\n\n\n\n\nファイル\n説明\n\n\n\n\n/etc/ufw/ufw.conf\nufwの有効ステータス及びLOGLEVELの設定ファイル\n\n\n/etc/ufw/user.rules\nIPv4に関連するufwルールの設定ファイル\n\n\n/etc/ufw/user6.rules\nIPv6に関連するufwルールの設定ファイル\n\n\n\n\n基本的には以下で解説するコマンド経由の設定で十分\nきめ細かい設定をする場合を上記のファイルを直接編集\n\n\nufw enable/disable\n# ufwを有効にしたい場合\nsudo ufw enable\n\n# ufwを無効にしたい場合\nsudo ufw disable\nufw disableしても，設定したルールは残されています．次回有効にしたときに以前設定したファイアウォールルールを再利用することができます．\nufw status\n設定と動作状況を確認したい場合は ufw status コマンドを実行します．コマンド実行により以下の内容が確認できます\n\nファイアウォールの動作状況: active or inactive\n設定されているルール一覧\n\n# 設定と動作状況を表示\n% sudo ufw status\nStatus: active\n\nTo                         Action      From\n--                         ------      ----\nAnywhere on tailscale0     ALLOW       Anywhere                  \n22/tcp                     LIMIT       Anywhere                  \nAnywhere (v6) on tailscale0 ALLOW       Anywhere (v6)             \n22/tcp (v6)                LIMIT       Anywhere (v6)  \nルールを削除挿入する場合はルール番号がわかると便利です．ルール番号を表示させたい場合は\n# ルール番号を表示する\n% sudo ufw status numbered\nStatus: active\n\n     To                         Action      From\n     --                         ------      ----\n[ 1] Anywhere on tailscale0     ALLOW IN    Anywhere                  \n[ 2] 22/tcp                     LIMIT IN    Anywhere                  \n[ 3] Anywhere (v6) on tailscale0 ALLOW IN    Anywhere (v6)             \n[ 4] 22/tcp (v6)                LIMIT IN    Anywhere (v6)   \nufw status verbose\nロギングモードやデフォルトポリシーを表示させる場合は ufw status verbose を実行します\n% sudo ufw status verbose \nStatus: active\nLogging: on (high)\nDefault: deny (incoming), allow (outgoing), deny (routed)\nNew profiles: skip\n\nTo                         Action      From\n--                         ------      ----\nAnywhere on tailscale0     ALLOW IN    Anywhere                  \n22/tcp                     LIMIT IN    Anywhere                  \nAnywhere (v6) on tailscale0 ALLOW IN    Anywhere (v6)             \n22/tcp (v6)                LIMIT IN    Anywhere (v6)    \nufw logging\n\nSyntax\nufw logging off|low|medium|high|full\n\nrsyslogが設定されているシステムでは，/var/log/ufw.log にログが記録される\nLEVEL(off|low|medium|high|full)を指定すると，logging頻度が設定される\ndefaultのlog levelは low\n\n\n\n\n\n\n\n\n\n\nパラメーター\n説明\n\n\n\n\noff\nログを記録しない\n\n\nlow\n定義されたポリシーに一致しないすべてのブロックされたパケット（レート制限付き） + ログルールに一致するパケットを記録\n\n\nmedium\nlowに加え，ポリシーにマッチせず許可された通信，INVALIDなパケット，新規の接続をレート制限付きで記録\n\n\nhigh\nmedium レベルのログ（レート制限なし）に加え，すべてのパケットをレート制限付きでログに記録\n\n\nfull\nhigh レベルのログ（レート制限なし）をすべて記録\n\n\n\n\nmedium より上のログレベルは，たくさんのログ出力を生成し，ディスクを短時間で使い切ってしまう可能性があります．ですので迷ったならば\n\nサーバー使用: medium\n個人用デスクトップ: low\n\nという設定で十分だと思います．\nufw allow\n\nSynatx\nufw allow service|port|protocol|IP address\n\n特定のポートやサービスへのアクセスを許可するルールを設定する際に使用\n\n\n# SSH を許可\nsudo ufw allow 22/tcp\n\n# HTTP を許可\nsudo ufw allow http\n\n# 192.168.1.0/24の範囲からのアクセスを許可\nsudo ufw allow from 192.168.1.0/24\n\n# 192.168.1.0/24の範囲からport 80へのアクセスを許可\nsudo ufw allow from 192.168.1.0/24 to any port 80\nufw deny\n\nSyntax\nufw deny service|port|protocol|IP address\n\n特定のポートやサービスへのアクセスを拒否するルールを設定する際に使用\n\n\n# Telnet を拒否\nsudo ufw deny 23/tcp\n\n# 10.0.0.5からのアクセスを拒否\nsudo ufw deny from 10.0.0.5\nufw delete\n\nSyntax\nufw delete NUM|rule\n\n既存のルールを削除する際に使用\nNUM は ufw status numbered で確認したルール番号\n\n\n# 22番ポートの許可を削除\nsudo ufw delete allow 22/tcp\n\n# 23番ポートの拒否を削除\nsudo ufw delete deny 23/tcp\n\n# 23番ポートの制限許可を削除\nsudo ufw delete limit 22/tcp \n\n# ルール 5~9 を削除(降順にすること)\nfor n in 9 8 7 6 5; do ufw delete $n; done \nufw insert\n\nSyntax\nufw insert NUM allow|deny service|port|protocol|IP address\n\nルールを指定した順番に挿入する際に使用\nNUM は挿入する位置番号\n\n\n# 80番ポート許可を最初のルールに挿入\nsudo ufw insert 1 allow 80/tcp\n\n# 192.168.1.100からのアクセス拒否ルールを２番に挿入\nsudo ufw insert 2 deny from 192.168.1.100\nufw limit\n\nSyntax\nufw limit service|port\n\n指定したポートやサービスへのアクセスを制限（レート制限）する際に使用\nDoS 攻撃やブルートフォース攻撃対策に便利\n\n\n# SSH に対して接続レート制限を設定\nsudo ufw limit 22/tcp\n\n# 192.168.1.0/24範囲からポート443への接続をレート制限\nsudo ufw limit from 192.168.1.0/24 to any port 443\n\nufw + tailscaleの設定\n\n\n\n\n\n\nNoteファイアウォール設定方針\n\n\n\n\nTailscale以外のすべてのincoming通信を拒絶\nすべてのOutgoingトラフィックを許可\n\n\n\nPrerequisites\n\ntailscaleがサーバー側でインストール済み\nufwがサーバー側でインストール済み\ntailscale経由でssh接続可能\n\n\nDefaultルールの設定\ntailscale sshでサーバーにログインした後に，ufw defaultルールを設定します\n# incoming rule\nsudo ufw default deny incoming\n\n# outgoing rule\nsudo ufw default allow outgoing\nverboseを用いてDefaultルール設定を確認します．Defaultセクションについて，以下のような設定になっていればOKです\n$ sudo ufw status verbose\nStatus: active\nLogging: on (high)\nDefault: deny (incoming), allow (outgoing), deny (routed)\nNew profiles: skip\n\nTo                         Action      From\n--                         ------      ----\n...\n次に，tailscale のincoming設定をします\n$ sudo ufw allow in on tailscale0\n改めてルール設定を確認します\n$ sudo ufw status                \nStatus: active\n\nTo                         Action      From\n--                         ------      ----\nAnywhere on tailscale0     ALLOW       Anywhere                  \nAnywhere (v6) on tailscale0 ALLOW       Anywhere (v6) \nルール設定後，ufwをリフレッシュして完了です\n$ sudo ufw reload\n\n📘 REMARKS\n\n上記のufwルール設定ではincomingがデフォルトでdeny, tailscale経由のみをincomingアクセスを許可\ntailscaleを経由しないsshは拒絶されるが，tailscale + sshは機能するはずです"
  },
  {
    "objectID": "posts/2025-08-01-firewall-settings/index.html#トラブルシューティング",
    "href": "posts/2025-08-01-firewall-settings/index.html#トラブルシューティング",
    "title": "Ubuntu 22.04でのfirewall設定",
    "section": "トラブルシューティング",
    "text": "トラブルシューティング\n\n/var/log/ufw.logが生成されない\n\n\n\n\n\n\nWarningProblem\n\n\n\nsudo ufw status verbose でlogging on担っているにも関わらず，/var/log/ufw.log が生成されない\n\n\n原因調査\nufw.log は rsyslog 経由で書き込まれるはずなので，rsyslog 自体のログを確認してみます．\nsudo cat /var/log/syslog | grep \"ufw\"\nファイルを見てみると\nrsyslogd: file '/var/log/ufw.log': open error: Permission denied [v8.2312.0 try https://www.rsyslog.com/e/2433 ]\nというラインが登場したならば，Permissionの問題であると考えることができます．\n対策\n/var/logのdefault permissonは\n\n\n\n\n項目\n設定値\n\n\n\n\nowner\nroot\n\n\ngroup\nsyslog\n\n\npermission\n755(drwxr-xr-x)\n\n\n\n\n/var/log 自体には 書き込み権限を付けないのが推奨及びデフォルトなので，個別ファイル(今回ならば /var/log/ufw.log) に権限をつけることが対応策となります．従って，\n# 空のlogファイル生成\nsudo touch /var/log/ufw.log\n\n# owner:groupの変更\nsudo chown syslog:adm /var/log/ufw.log\nもろもろがめんどくさい場合は sudo chmod 775 /var/log を実行します．"
  },
  {
    "objectID": "posts/2025-08-01-firewall-settings/index.html#appendix-1-ファイアウォール",
    "href": "posts/2025-08-01-firewall-settings/index.html#appendix-1-ファイアウォール",
    "title": "Ubuntu 22.04でのfirewall設定",
    "section": "Appendix 1: ファイアウォール",
    "text": "Appendix 1: ファイアウォール\n\nDefinition 2 ファイアウォール\n\nパケットを制御する仕組みのこと\n内部ネットワークと外部ネットワークの通信を監視・制御する\n\nセキュリティポリシーに従ってアクセスを許可／拒否する\n\n\n基本的には（TCP/IPモデル）階層ごとにヘッダの内容に応じたチェック項目を設け，それらをクリアしたデータだけを上の階層に渡すという仕組みで通信を制御します．\n\nExample 1 \n\n\n\n\n\nblock-beta\ncolumns 1\n  block:RULE1\n    A[\"ネットワーク層\"]\n    B[\"許可されたIPアドレスからのパケット以外は受け取らない\"]\n  end\n  space\n  block:RULE2\n    C[\"トランスポート層\"]\n    D[\"決められたポート宛のパケット以外はReject\"]\n  end\n  space\n  block:RULE3\n    E[\"アプリケーション層\"]\n    F[\"決められた形式以外のファイルはReject\"]\n  end\n  blockArrowId6&lt;[\"&nbsp;&nbsp;&nbsp;\"]&gt;(down)\n  G[\"通信の受取\"]\n  RULE1 --&gt; RULE2\n  RULE2 --&gt; RULE3\n\n  style B fill:#428CE6,stroke:#428CE6,color:#FFFFFF,stroke-width:2px\n  style D fill:#428CE6,stroke:#428CE6,color:#FFFFFF,stroke-width:2px\n  style F fill:#428CE6,stroke:#428CE6,color:#FFFFFF,stroke-width:2px\n\n\n\n\n\n\n\n\nUFW が扱える階層\n\n\n\n\n\n\n\n\n\nOSI階層\nTCP/IP階層\nUFWで可能なこと\n\n\n\n\nL3: ネットワーク層\nインターネット層\n- IPアドレスの許可/拒否- サブネット単位でのアクセス制御\n\n\nL4: トランスポート層\nトランスポート層\n- ポート番号指定の許可/拒否- TCP/UDP プロトコルごとの制御"
  },
  {
    "objectID": "posts/2025-08-01-firewall-settings/index.html#appendix-2-ipアドレスとサブネットマスク",
    "href": "posts/2025-08-01-firewall-settings/index.html#appendix-2-ipアドレスとサブネットマスク",
    "title": "Ubuntu 22.04でのfirewall設定",
    "section": "Appendix 2: IPアドレスとサブネットマスク",
    "text": "Appendix 2: IPアドレスとサブネットマスク\n\nDefinition 3 IPアドレスの構成\nIP address:   192.168.0.1\nSubnet mask:  255.255.255.0\nというIPv4アドレスはネットワークパートとホストパートの２つの要素によって構成されています：\n\nNewwork Identifier: デバイスがどのネットワークに属しているかを示す識別子\nHost Identifier: 属しているネットワーク上でデバイスに対して付与される識別子\n\nサブネットマスクはIPアドレスの内，どのビットまでがNetwork Identifierなのかを示します．\n\nIPv4アドレスは32-bitで定義されています．192.168.0.1はそれを読みやすくしたものであり，binary表記と対応させると\n192.168.0.1 =\n11000000.10101000.00000000.00000001\nサブネットマスクも同様で\n255.255.255.0 =\n11111111.11111111.11111111.00000000\n\n1: network portion\n0: host portion\n\n解釈すると，192.168.0 がネットワーク識別子で，1がホスト識別子となります．\nIPv4とサブネットマスクの解釈\n\n\n\n\n\n\n\n\n\nNetwork ID\n192.168.0.0\n\n\n\nBroadcast address\n192.168.0.255\n同じネットワークに属するすべてのデバイスに一斉にメッセージを届けるための特別なIPアドレスのこと\n\n\nValid hosts\n192.168.0.1 ~ 192.168.0.254\n254個のデバイスが同一ネットワークに登録可能\n\n\n\n\n\n\n\n\n\n\nNoteBroadcast address vs 0.0.0.0\n\n\n\nBroadcast addressは通信の宛先アドレスですが，0.0.0.0 は宛先ではなく「このマシンが持つ全てのIPv4アドレスで待ち受ける」という意味になります．間隔としては，\n\n0.0.0.0: 自分の家の全てのドアを開けて待っている（誰でも入れる状態にする）\n192.168.0.255: 町内の 全住人にスピーカーで呼びかける\n\n\n\n\n\n\n\n\n\n\nアドレス\n意味\n使い方\n\n\n\n\n0.0.0.0\n「全ての自分のIPアドレスで待ち受ける」\nサーバープログラムのバインド用\n\n\n192.168.0.255\n「192.168.0.0/24 の全ホストに送信する」\nブロードキャスト通信の宛先\n\n\n\n\n\n\n\nCIDR表記\nフルのサブネットマスク（255.255.255.0）のように表記する代わりに，ネットワーク部に使うビット数だけを指定する方法をCIDR表記といいます．\n\n192.168.1.10/24: 24 はネットワーク部が 24 ビットという意味（マスクは 255.255.255.0）\n10.0.0.1/8: /8 はネットワーク部が 8 ビットという意味（マスクは 255.0.0.0）\n\n\nExample 2 \n172.18.1.10/12 のネットワークの有効ホスト範囲とブロードキャストアドレスは\n\n有効ホスト範囲: 172.16.0.1～ 172.31.255.254\nブロードキャストアドレス: 172.31.255.255"
  },
  {
    "objectID": "posts/2025-08-01-firewall-settings/index.html#references",
    "href": "posts/2025-08-01-firewall-settings/index.html#references",
    "title": "Ubuntu 22.04でのfirewall設定",
    "section": "References",
    "text": "References\n\nUbuntu manuals &gt; ufw\nTailscale &gt; Use UFW to lock down an Ubuntu server"
  },
  {
    "objectID": "posts/2025-05-01-how-css-works/index.html",
    "href": "posts/2025-05-01-how-css-works/index.html",
    "title": "CSSの組み込み方",
    "section": "",
    "text": "NoteKey Takeaways\n\n\n\n\n\n\n\n方法\n保守性\n再利用性\n適している場面\n\n\n\n\nインライン\n悪い\nなし\n一時的・緊急の変更\n\n\n内部CSS\n普通\nなし\n単一ページのスタイリング\n\n\n外部CSS\n良い\n高い\n大規模・再利用が前提の開発\n\n\n\n\n\n\nCSSをHTMLに組み込む方法として，\n\nインラインCSS\n内部参照CSS\n外部参照CSS\n\nの3つがあります．それぞれの使い分けも簡潔に解説します．\n1: インラインCSS\n&lt;p style=\"color: #ff0000; font-weight: bold;\"&gt;これは赤い太字のテキストです&lt;/p&gt;\n\nHTMLタグのstyle属性に直接書く方法\n特定の要素だけ一時的にスタイルを指定したいときに使用するが，構造であるHTMLドキュメントに直接デザインの指定をしてしまうので，多用するとメンテナンスが難しくなります\n一時的にテストするとき以外は原則として使用しないこと\n\nセレクタ(selector)とプロパティ(property)\n\nセレクタ: 「どのHTML要素にスタイルを適用するか」を指定する部分\nプロパティ: 「何をどうスタイルするか」の内容部分\n\nh1 {\n    color:#FF0000;\n}\nこの例では，h1がセレクタ，colorがプロパティ，#FF0000がプロパティに対応するValue\n2: 内部参照CSS\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n  &lt;style&gt;\n    p {\n      color: blue;\n      font-size: 18px;\n    }\n  &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;p&gt;これは青いテキストです。&lt;/p&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\nHTMLの&lt;head&gt;内に&lt;style&gt;タグでCSSを書く方法\nHTMLに直接書き込むスタイルなので，そのHTML1ページだけのスタイル指定(=使い回しができない)\n一時的にテストするとき以外は原則として使用しないこと\n\n3. 外部参照CSS\n\n\nhtml file\n\n&lt;head&gt;\n    &lt;link rel=\"stylesheet\" href=\"styles.css\" media=\"all\"&gt;\n&lt;/head&gt;\n\n\n\nstyle.css\n\np {\n  color: green;\n}\n\n\nHTMLの中に直接スタイルを書くのではなく，別ファイル（.css）として分けて管理し参照するスタイル\n複数ページに共通するデザインを一箇所で管理できるため，保守性や再利用性が高い\nブラウザがCSSファイルをキャッシュできるため，2回目以降の読み込みが速い\nHTML（構造）とCSS（デザイン）を分離するのはベストプラクティスとされている\n\n外部CSS参照の基本書式\n\n\n\n\n\n\n\n\n引数\n内容\n\n\n\n\nrel属性\n外部リソースとの関係性を指定．CSSを読み込む場合は \"stylesheet\"\n\n\nhref属性\n読み込むCSSファイルのURLやパスを指定\n\n\nmedia属性\nスタイルを適用するメディアタイプを指定．通常は \"all\" や \"screen\""
  },
  {
    "objectID": "posts/2025-05-01-how-css-works/index.html#cssをhtmlに組み込む方法",
    "href": "posts/2025-05-01-how-css-works/index.html#cssをhtmlに組み込む方法",
    "title": "CSSの組み込み方",
    "section": "",
    "text": "NoteKey Takeaways\n\n\n\n\n\n\n\n方法\n保守性\n再利用性\n適している場面\n\n\n\n\nインライン\n悪い\nなし\n一時的・緊急の変更\n\n\n内部CSS\n普通\nなし\n単一ページのスタイリング\n\n\n外部CSS\n良い\n高い\n大規模・再利用が前提の開発\n\n\n\n\n\n\nCSSをHTMLに組み込む方法として，\n\nインラインCSS\n内部参照CSS\n外部参照CSS\n\nの3つがあります．それぞれの使い分けも簡潔に解説します．\n1: インラインCSS\n&lt;p style=\"color: #ff0000; font-weight: bold;\"&gt;これは赤い太字のテキストです&lt;/p&gt;\n\nHTMLタグのstyle属性に直接書く方法\n特定の要素だけ一時的にスタイルを指定したいときに使用するが，構造であるHTMLドキュメントに直接デザインの指定をしてしまうので，多用するとメンテナンスが難しくなります\n一時的にテストするとき以外は原則として使用しないこと\n\nセレクタ(selector)とプロパティ(property)\n\nセレクタ: 「どのHTML要素にスタイルを適用するか」を指定する部分\nプロパティ: 「何をどうスタイルするか」の内容部分\n\nh1 {\n    color:#FF0000;\n}\nこの例では，h1がセレクタ，colorがプロパティ，#FF0000がプロパティに対応するValue\n2: 内部参照CSS\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n  &lt;style&gt;\n    p {\n      color: blue;\n      font-size: 18px;\n    }\n  &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;p&gt;これは青いテキストです。&lt;/p&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\nHTMLの&lt;head&gt;内に&lt;style&gt;タグでCSSを書く方法\nHTMLに直接書き込むスタイルなので，そのHTML1ページだけのスタイル指定(=使い回しができない)\n一時的にテストするとき以外は原則として使用しないこと\n\n3. 外部参照CSS\n\n\nhtml file\n\n&lt;head&gt;\n    &lt;link rel=\"stylesheet\" href=\"styles.css\" media=\"all\"&gt;\n&lt;/head&gt;\n\n\n\nstyle.css\n\np {\n  color: green;\n}\n\n\nHTMLの中に直接スタイルを書くのではなく，別ファイル（.css）として分けて管理し参照するスタイル\n複数ページに共通するデザインを一箇所で管理できるため，保守性や再利用性が高い\nブラウザがCSSファイルをキャッシュできるため，2回目以降の読み込みが速い\nHTML（構造）とCSS（デザイン）を分離するのはベストプラクティスとされている\n\n外部CSS参照の基本書式\n\n\n\n\n\n\n\n\n引数\n内容\n\n\n\n\nrel属性\n外部リソースとの関係性を指定．CSSを読み込む場合は \"stylesheet\"\n\n\nhref属性\n読み込むCSSファイルのURLやパスを指定\n\n\nmedia属性\nスタイルを適用するメディアタイプを指定．通常は \"all\" や \"screen\""
  },
  {
    "objectID": "posts/2025-11-16-counter-object/index.html",
    "href": "posts/2025-11-16-counter-object/index.html",
    "title": "Counterオブジェクト",
    "section": "",
    "text": "Definition 1 Counter\n\nCounter は，ハッシュ可能なオブジェクトの出現回数を数えるための辞書サブクラス\n要素を辞書のキーとして保持し，その出現回数を値として保持するコレクション\nカウント値には 0 や負の値を含む任意の整数が使用可能\n\n\nリストの要素の出現回数を集計する場合，Dict を用いる場合\n\n\nCode\nwords = ['red', 'blue', 'red', 'green', 'blue', 'blue']\ncount_dict = {}\n\nfor word in words:\n    # dict.get(key, default) returns default if key does not exist\n    count_dict[word] = count_dict.get(word, 0) + 1\n\nprint(count_dict)\n\n\n{'red': 2, 'blue': 3, 'green': 1}\n\n\nCounterを用いることで以下のようにより簡単に集計することが出来ます\n\n\nCode\nfrom collections import Counter\n\nword_counter = Counter(words)\n\nprint(word_counter)\n\n\nCounter({'blue': 3, 'red': 2, 'green': 1})\n\n\nまた，すべての要素の出現頻度の合計は total() メソッドを用いて表示できます\n\n\nCode\nprint(word_counter.total())   # 6 = 3 + 2 + 1\n\n\n6\n\n\n\nExample 1 (単語出現頻度の計測) \nハムレットの一節を内容とする hamlet.txt を例に，出現単語のTop 5の計測を行います．Counter クラスには most_common() メソッドがあり，要素を出現頻度に応じて降順で返してくれます．引数として整数を指定すると，最上位から数えてその個数分だけを出力してくれるので\n\n\nCode\nimport re\nfrom collections import Counter\n\n# 単語を抽出（小文字化して正規表現でマッチ，句読点は除く）\nhamlet_words = re.findall(r'\\w+', open('hamlet.txt').read().lower())\nCounter(hamlet_words).most_common(5)\n\n\n[('to', 4), ('the', 3), ('be', 2), ('or', 2), ('and', 2)]\n\n\n出現頻度下位Top 3を出力したい場合は\n\n\nCode\nhamlet_counter = Counter(hamlet_words)\nhamlet_counter.most_common()[:-4:-1]\n\n\n[('them', 1), ('end', 1), ('opposing', 1)]\n\n\n\n\n\n\n\n\nCode\nfrom collections import Counter\n\n# 1. 空の Counter を作る\nc = Counter()                           \nprint(c)  # Counter()\n\n# 2. イテラブルから作る\nc = Counter('gallahad')                 \nprint(c)  # Counter({'a': 3, 'l': 2, 'g': 1, 'h': 1, 'd': 1})\n\n# 3. 辞書（マッピング）から作る\nc = Counter({'red': 1, 'blue': 2})      \nprint(c)  # Counter({'red': 1, 'blue': 2})\n\n# 4. キーワード引数から作る\nc = Counter(cats=4, dogs=8)     \nprint(c)  # Counter({'dogs': 8, 'cats': 4}) \n\n\nCounter()\nCounter({'a': 3, 'l': 2, 'g': 1, 'h': 1, 'd': 1})\nCounter({'blue': 2, 'red': 1})\nCounter({'dogs': 8, 'cats': 4})\n\n\n\n\n\nCounter では存在しないキーにアクセスしても KeyError にはならず，0 が返るのが特徴です\n\n\nCode\nfrom collections import Counter\n\n# カウンター作成\nc = Counter(['eggs', 'ham'])\n\n# 存在するキー\nprint(c['eggs'])    # 1\n\n# 存在しないキー\nprint(c['bacon'])   # 0 ← KeyError にはならない\n\n\n1\n0\n\n\n\nExample 2 (dict と KeyError) \n\n\nCode\nfoods = {'eggs': 1, 'ham': 1}\n\ntry:\n  print(\"bacon:\", foods['bacon']) # 存在しないキーは KeyError\nexcept KeyError as e:\n  print(f\"KeyError: {e}\")\n\n\nKeyError: 'bacon'\n\n\n\n\n\n\n\nPython 3.7 以降，Counter は内部的には挿入順を保持しています．print などでkey-valueを出力するとvalueに応じた降順でソートされたように見えますが，Counter.keys() などでkeyの順番を確認すると，挿入順となっています\n\n\nCode\nfrom collections import Counter\n\nc = Counter('gallahad')\n\n# check display order\nprint(c)                    # 出力は頻度順\nprint(list(c))              # 内部の挿入順\nprint(c.keys())             # 内部の挿入順\nprint(list(c.elements()))   # elements順\n\n\nCounter({'a': 3, 'l': 2, 'g': 1, 'h': 1, 'd': 1})\n['g', 'a', 'l', 'h', 'd']\ndict_keys(['g', 'a', 'l', 'h', 'd'])\n['g', 'a', 'a', 'a', 'l', 'l', 'h', 'd']\n\n\n演算処理の順番\nCounter オブジェクトは，+ を使った加算処理ができます．このとき，基本的なキーの順番は左オペラントとなり，新しいキーは右オペランドから追加されるという内部処理になります．\nつまり，要素順は，左オペランドの出現順 → 右オペランドで新規に現れた順で決まります．\n\n\nCode\nfrom collections import Counter\n\nc1 = Counter('zbcaad')\nc2 = Counter('abcd')\n\n# 算術演算\nc3 = c1 + c2\n\n# 出力\nprint(c3)\nprint(c3.keys())\nprint(list(c3.elements()))\n\n\nCounter({'a': 3, 'b': 2, 'c': 2, 'd': 2, 'z': 1})\ndict_keys(['z', 'b', 'c', 'a', 'd'])\n['z', 'b', 'b', 'c', 'c', 'a', 'a', 'a', 'd', 'd']"
  },
  {
    "objectID": "posts/2025-11-16-counter-object/index.html#counter-オブジェクト",
    "href": "posts/2025-11-16-counter-object/index.html#counter-オブジェクト",
    "title": "Counterオブジェクト",
    "section": "",
    "text": "Definition 1 Counter\n\nCounter は，ハッシュ可能なオブジェクトの出現回数を数えるための辞書サブクラス\n要素を辞書のキーとして保持し，その出現回数を値として保持するコレクション\nカウント値には 0 や負の値を含む任意の整数が使用可能\n\n\nリストの要素の出現回数を集計する場合，Dict を用いる場合\n\n\nCode\nwords = ['red', 'blue', 'red', 'green', 'blue', 'blue']\ncount_dict = {}\n\nfor word in words:\n    # dict.get(key, default) returns default if key does not exist\n    count_dict[word] = count_dict.get(word, 0) + 1\n\nprint(count_dict)\n\n\n{'red': 2, 'blue': 3, 'green': 1}\n\n\nCounterを用いることで以下のようにより簡単に集計することが出来ます\n\n\nCode\nfrom collections import Counter\n\nword_counter = Counter(words)\n\nprint(word_counter)\n\n\nCounter({'blue': 3, 'red': 2, 'green': 1})\n\n\nまた，すべての要素の出現頻度の合計は total() メソッドを用いて表示できます\n\n\nCode\nprint(word_counter.total())   # 6 = 3 + 2 + 1\n\n\n6\n\n\n\nExample 1 (単語出現頻度の計測) \nハムレットの一節を内容とする hamlet.txt を例に，出現単語のTop 5の計測を行います．Counter クラスには most_common() メソッドがあり，要素を出現頻度に応じて降順で返してくれます．引数として整数を指定すると，最上位から数えてその個数分だけを出力してくれるので\n\n\nCode\nimport re\nfrom collections import Counter\n\n# 単語を抽出（小文字化して正規表現でマッチ，句読点は除く）\nhamlet_words = re.findall(r'\\w+', open('hamlet.txt').read().lower())\nCounter(hamlet_words).most_common(5)\n\n\n[('to', 4), ('the', 3), ('be', 2), ('or', 2), ('and', 2)]\n\n\n出現頻度下位Top 3を出力したい場合は\n\n\nCode\nhamlet_counter = Counter(hamlet_words)\nhamlet_counter.most_common()[:-4:-1]\n\n\n[('them', 1), ('end', 1), ('opposing', 1)]\n\n\n\n\n\n\n\n\nCode\nfrom collections import Counter\n\n# 1. 空の Counter を作る\nc = Counter()                           \nprint(c)  # Counter()\n\n# 2. イテラブルから作る\nc = Counter('gallahad')                 \nprint(c)  # Counter({'a': 3, 'l': 2, 'g': 1, 'h': 1, 'd': 1})\n\n# 3. 辞書（マッピング）から作る\nc = Counter({'red': 1, 'blue': 2})      \nprint(c)  # Counter({'red': 1, 'blue': 2})\n\n# 4. キーワード引数から作る\nc = Counter(cats=4, dogs=8)     \nprint(c)  # Counter({'dogs': 8, 'cats': 4}) \n\n\nCounter()\nCounter({'a': 3, 'l': 2, 'g': 1, 'h': 1, 'd': 1})\nCounter({'blue': 2, 'red': 1})\nCounter({'dogs': 8, 'cats': 4})\n\n\n\n\n\nCounter では存在しないキーにアクセスしても KeyError にはならず，0 が返るのが特徴です\n\n\nCode\nfrom collections import Counter\n\n# カウンター作成\nc = Counter(['eggs', 'ham'])\n\n# 存在するキー\nprint(c['eggs'])    # 1\n\n# 存在しないキー\nprint(c['bacon'])   # 0 ← KeyError にはならない\n\n\n1\n0\n\n\n\nExample 2 (dict と KeyError) \n\n\nCode\nfoods = {'eggs': 1, 'ham': 1}\n\ntry:\n  print(\"bacon:\", foods['bacon']) # 存在しないキーは KeyError\nexcept KeyError as e:\n  print(f\"KeyError: {e}\")\n\n\nKeyError: 'bacon'\n\n\n\n\n\n\n\nPython 3.7 以降，Counter は内部的には挿入順を保持しています．print などでkey-valueを出力するとvalueに応じた降順でソートされたように見えますが，Counter.keys() などでkeyの順番を確認すると，挿入順となっています\n\n\nCode\nfrom collections import Counter\n\nc = Counter('gallahad')\n\n# check display order\nprint(c)                    # 出力は頻度順\nprint(list(c))              # 内部の挿入順\nprint(c.keys())             # 内部の挿入順\nprint(list(c.elements()))   # elements順\n\n\nCounter({'a': 3, 'l': 2, 'g': 1, 'h': 1, 'd': 1})\n['g', 'a', 'l', 'h', 'd']\ndict_keys(['g', 'a', 'l', 'h', 'd'])\n['g', 'a', 'a', 'a', 'l', 'l', 'h', 'd']\n\n\n演算処理の順番\nCounter オブジェクトは，+ を使った加算処理ができます．このとき，基本的なキーの順番は左オペラントとなり，新しいキーは右オペランドから追加されるという内部処理になります．\nつまり，要素順は，左オペランドの出現順 → 右オペランドで新規に現れた順で決まります．\n\n\nCode\nfrom collections import Counter\n\nc1 = Counter('zbcaad')\nc2 = Counter('abcd')\n\n# 算術演算\nc3 = c1 + c2\n\n# 出力\nprint(c3)\nprint(c3.keys())\nprint(list(c3.elements()))\n\n\nCounter({'a': 3, 'b': 2, 'c': 2, 'd': 2, 'z': 1})\ndict_keys(['z', 'b', 'c', 'a', 'd'])\n['z', 'b', 'b', 'c', 'c', 'a', 'a', 'a', 'd', 'd']"
  },
  {
    "objectID": "posts/2025-11-16-counter-object/index.html#counter-と算術演算",
    "href": "posts/2025-11-16-counter-object/index.html#counter-と算術演算",
    "title": "Counterオブジェクト",
    "section": "Counter と算術演算",
    "text": "Counter と算術演算\nTL;DRs\n\n\nCode\nfrom collections import Counter\n\n# 2つのカウンターを作成\nc = Counter(a=3, b=1, c=1)\nd = Counter(a=1, b=2, c=1)\n\n# -------------------------------\n# 算術演算と集合演算\n# -------------------------------\n\nprint(\"c + d =\", c + d)   # 足し算: 各キーの値を加算\n\nprint(\"c - d =\", c - d)   # 引き算: 正の値のみ保持, 0 は除外される\n\nprint(\"c & d =\", c & d)   # 積集合: min(c[x], d[x])\n\nprint(\"c | d =\", c | d)   # 和集合: max(c[x], d[x])\n\n# -------------------------------\n# 比較演算\n# -------------------------------\n\nprint(\"c == d ?\", c == d)  # 等価判定\nprint(\"c &lt;= d ?\", c &lt;= d)  # 部分集合判定 (すべての要素が &lt;=)\nprint(\"c &gt;= d ?\", c &gt;= d)  # 部分集合判定 (すべての要素が &gt;=)\n\n\nc + d = Counter({'a': 4, 'b': 3, 'c': 2})\nc - d = Counter({'a': 2})\nc & d = Counter({'a': 1, 'b': 1, 'c': 1})\nc | d = Counter({'a': 3, 'b': 2, 'c': 1})\nc == d ? False\nc &lt;= d ? False\nc &gt;= d ? False\n\n\n\nsubtract メソッド\n\nDefinition 2 Counter.subtract\n\nある Counter から別の Counter や iterable の要素を減算するメソッド\n結果のカウント値は 負の値 になることもある\n元の Counter が 変更される（新しいオブジェクトは返らない）\n\n\n基本的な使い方は\n\n\nCode\nfrom collections import Counter\n\nc1 = Counter('aabbcc')\nc2 = Counter('abc')\n\n# c1 から c2 を減算\nc1.subtract(c2)\n\nprint(c1)\n\n\nCounter({'a': 1, 'b': 1, 'c': 1})\n\n\n\nExample 3 (iterableからの減算) \n\n\nCode\nc = Counter('banana')\nc.subtract('an')   # 'a','n' をそれぞれ 1 ずつ減らす\nprint(c)\n\n\nCounter({'a': 2, 'b': 1, 'n': 1})\n\n\n\n\n\nExample 4 (値は 0 未満になる場合) \n\n\nCode\nc = Counter('banana2')\nc.subtract('and2')   # 'a','n' , 'd'をそれぞれ 1 ずつ減らす\n\n# 出力\nprint(c)    # 演算結果の出力\nprint(+c)   # 0以上の要素のみ出力（0は含まない）\nprint(-c)   # 0未満の要素のみ出力\n\n\nCounter({'a': 2, 'b': 1, 'n': 1, '2': 0, 'd': -1})\nCounter({'a': 2, 'b': 1, 'n': 1})\nCounter({'d': 1})\n\n\n\n\n\n\n実行順番の注意\n\n\n\n\n\n\nCaution\n\n\n\n\nCounter の 算術演算は順序によって出力のキー順序が変わることがある\n負の値の処理が関わる場合，結果の値自体も変わる\n\n\n\n\n\nCode\nfrom collections import Counter\n\n# 3つのカウンターを作成\nx = Counter(a=3, b=1, c=-2)\ny = Counter(a=1, b=2, c=1, d=1)\nz = Counter(a=1, b=2, c=2, e=1)\n\nprint(x + y + z)\nprint(x + z + y)\n\n\nCounter({'a': 5, 'b': 5, 'c': 2, 'd': 1, 'e': 1})\nCounter({'a': 5, 'b': 5, 'e': 1, 'c': 1, 'd': 1})\n\n\nロバストな加算処理\n値を置き換えるのではなく，順序ロバストにカウントを加算して計算したい場合は update メソッドを用いるほうが良いかもしれません\n\n\nCode\nfrom collections import Counter\n\nx = Counter(a=3, b=1, c=-2)\ny = Counter(a=1, b=2, c=1, d=1)\nz = Counter(a=1, b=2, c=2, e=1)\n\nc_total_xyz = Counter()\nc_total_xzy = Counter()\n\nfor c1 in [x, y, z]:\n    c_total_xyz.update(c1)\n\nfor c2 in [x, z, y]:\n    c_total_xzy.update(c2)\n\n# 計算結果\nprint(f\"c_total_xyz: {c_total_xyz}\")\nprint(f\"c_total_xzy: {c_total_xzy}\")\n\n# 比較\nprint(c_total_xyz == c_total_xzy)\n\n\nc_total_xyz: Counter({'a': 5, 'b': 5, 'c': 1, 'd': 1, 'e': 1})\nc_total_xzy: Counter({'a': 5, 'b': 5, 'c': 1, 'e': 1, 'd': 1})\nTrue"
  },
  {
    "objectID": "posts/2025-11-16-counter-object/index.html#references",
    "href": "posts/2025-11-16-counter-object/index.html#references",
    "title": "Counterオブジェクト",
    "section": "References",
    "text": "References\n\nCounter objects"
  },
  {
    "objectID": "posts/2025-05-30-how-to-write-document/index.html",
    "href": "posts/2025-05-30-how-to-write-document/index.html",
    "title": "ドキュメントの書き方",
    "section": "",
    "text": "Noteこの記事のスコープ\n\n\n\n\nドキュメントを書くにあたっての基本ルールの紹介"
  },
  {
    "objectID": "posts/2025-05-30-how-to-write-document/index.html#ドキュメントに何を書くかwhat",
    "href": "posts/2025-05-30-how-to-write-document/index.html#ドキュメントに何を書くかwhat",
    "title": "ドキュメントの書き方",
    "section": "ドキュメントに何を書くか？(What)",
    "text": "ドキュメントに何を書くか？(What)\nドキュメントとは「ある情報を、ある対象に伝える」ための手段です．ドキュメントを書くにあたって事前に\n\n「誰に」対して\n「何を」伝えるか\n\nを明確化し，その目的に応じて構成や表現を設計することが重要です．\n\nExample 1 : ドキュメント種類別の読み手と目的整理表\n\n\n\n\n\n\n\n\n\nドキュメント種類\n誰に\n何を\n\n\n\n\n企画書\n経営層・チームマネジャー・開発メンバー\nPJの目的・スコープ・予算・スケジュール\n\n\n要件定義書\nエンジニア\nシステムの機能要件・非機能要件\n\n\n基本設計書\nエンジニア\nシステムの動作仕様・インターフェース仕様\n\n\n詳細設計\nエンジニア\nソフトウェアの内部構造・モジュール感のインターフェース・データ構造\n\n\nテスト仕様書\nプロダクトマネジャー・エンジニア\nテスト項目・テストデータ・テスト結果\n\n\nユーザーマニュアル\nユーザー\n機能の説明・利用目的・操作方法\n\n\n管理・保守マニュアル\nシステム管理者\n管理や保守に関する機能の説明・利用目的・操作方法\n\n\nリリースノート\nユーザー・システム管理者\nプロダクトのアップデートに伴う変更点\n\n\n\n\n\n\n読み手の定義\n\nルール\n「誰に」対してを特定する際，以下の３つを明確化することが有用です：\n\n読み手の目的・ニーズ\n読み手の知識レベル\n読み手の立場\n\n説明\n\n目的が違えば、必要な情報・深さ・順序が変わる\n\n\n意思決定者 → 意思決定や承認に足る根拠がほしい → 結論とインパクト重視\n現場担当者 → どう使うか／どう実装するかの具体的な手順を知りたい → 詳細手順や実装方法が重要\n\n\n知識レベルが違えば 説明の粒度・用語の選び方・例の使い方が変わる\n\n\n初心者 → 用語の定義や背景から丁寧に\n専門家 → 論点にフォーカスし冗長さを排除\n\n\n同じ事実でも、立場によって関心ポイントが異なる\n\n\n営業 → 顧客影響やKPIに注目\nエンジニア → 技術的妥当性や仕組みが重要\n\n例: ユーザーマニュアルと開発者マニュアルのアウトラインの差異\n\n\n\n\n\n\n\n\n\n種類\nアウトライン構成方針\n例\n\n\n\n\nユーザーマニュアル\nユーザーが操作する順番\n初期設定 → ログイン → 基本操作 → 応用操作 → トラブル対応\n\n\n開発者マニュアル\n開発者が開発する順番\n環境構築 → モジュール設計 → API定義 → データ構造 → エラーハンドリング\n\n\n\n\nアンチパターンと改善例\n\n\n\n\n\n\nImportantアンチパターン: 読み手の定義がぼやけている\n\n\n\n\nプロダクトのユーザーに，プロダクトの使い方を伝える\n\n\n\n\n\n\n\n\n\nTip改善例:\n\n\n\n\nプロダクトを新規導入するシステム管理者に，プロダクトの導入手順を伝える\nプロダクトの利用中にエラーに遭遇したユーザーに，エラーの原因と対処方法を伝える"
  },
  {
    "objectID": "posts/2025-05-30-how-to-write-document/index.html#どのようにドキュメントを書くかhow",
    "href": "posts/2025-05-30-how-to-write-document/index.html#どのようにドキュメントを書くかhow",
    "title": "ドキュメントの書き方",
    "section": "どのようにドキュメントを書くか？(How)",
    "text": "どのようにドキュメントを書くか？(How)\n良いドキュメントを書くためには、次の３点を押さえる必要があります：\n\nEffectiveness; 必要な情報を正しく伝えられる, 合目的的であること\nEfficiency: 効率よく内容が理解できる, readability\nSatisfaction: 読み手に対する配慮があること\n\n\nEffectiveness\n\n\n\n説明\n\n書き表された情報が読み手に一意に伝わること\n書き表された情報がドキュメントの目的と合致していること\n\nアクション\n\n\nメインメッセージの構成要素が漏れなく分解されている\n曖昧さを廃し，明確な文章で書く\n誤解なく読める文章で書く\nできるだけ具体的に書く\n\n\n\n\nEfficiency\n\n\n\n説明\n\n効率よく内容が理解できること\n読み手は流し読みする傾向があるので，流し読みでも情報が伝わるように構成立てること\n\nアクション\n\n\n要点を先に伝える(MMUF, Main Message Up-Front)\n話の流れを整理し，どこに何が書いてあるかわかりやすくする(=アウトライン設計)\n\nドキュメントを書く前に事前にアウトライン設計（どこに何を書くのか）\n文章ブロックに対して，書かれている内容を端的に表す見出しを付ける\none heading, one message\n\n必要な情報だけに絞り，簡潔で読みやすい文章にする\n\n\n\n\nSatisfaction\n\n\n\n説明\n\n読み手が「読んでよかった」「わかりやすかった」と感じられること\nストレスなく読める体験が提供されていること\n\nアクション\n\n\n読み手の立場・前提知識・目的を想定して内容や語り口を調整する\n図表・余白・見出しなどで視認性を高める\n論理の正確さだけでなく、文の印象・ニュアンスにも気を配る\n\n\n\n\nわかりやすい文の書き方\n\n\n\n\n\n\nWarning文を書き始めるのはアウトライン設計後\n\n\n\n\n文章はすぐに書き始めるのではなく，まず「構造」＝アウトラインを先に設計する\n\n\n\nわかりやすい文を書くにあたって，次の4点を抑える必要があります\n\n係り受けを明確にする\n並列関係を明確にする\n順序関係を明確にする\n「の」は一つの文に２つまでに留める\n\n\n係り受けを明確にする\n\n\n説明\n\n誤解を招く文の原因の一つが，係り受けの曖昧さ\n係り受けはできる限り近い位置に配置するべき\n\n例\n\n❌ 簡単なチャットアプリの作り方\n👍 チャットアプリの簡単な作り方\n\n\n\n並列関係を明確にする\n\n\n説明\n\n並列する要素（AとB、～や～など）は、文法的・意味的に対等な構造で書く必要がある\n並列構造が乱れると、何が並列なのか、読み手が混乱する\n\n例\n\n❌ このツールは、設定の保存、読み込み、そしてファイルの圧縮ができます\n👍 このツールは、設定の保存・読み込み、ファイルの圧縮ができます\n\n\n\n順序関係を明確にする\n\n\n説明\n\n複数の出来事や手順がある場合は、どの順で発生・実行されるかを明確にすることが重要\n順序が不明瞭だと、因果関係や手順が誤解されやすくなる\n\n例\n\n❌ 入力が完了したら、ファイルを保存し、名前を入力してください\n👍 入力が完了したら、名前を入力し、その後でファイルを保存してください\n\n\n\n「の」は一つの文に２つまでに留める\n\n\n説明\n\n「の」を多用すると、文の構造が複雑になり、意味があいまいになる\nそのため、一文に「の」は2つまでに抑えるのが、読みやすさの目安。\n\n例\n\n❌ データ処理の高速化のためのアルゴリズムの最適化手法の調査\n👍 データ処理を高速化するための、アルゴリズム最適化手法の調査\n👍 アルゴリズム最適化手法について、データ処理を高速化する観点から調査した"
  },
  {
    "objectID": "posts/2025-05-30-how-to-write-document/index.html#アンチパターンと発生原因",
    "href": "posts/2025-05-30-how-to-write-document/index.html#アンチパターンと発生原因",
    "title": "ドキュメントの書き方",
    "section": "アンチパターンと発生原因",
    "text": "アンチパターンと発生原因\n\n\n\n\n\n\nImportantProblem 1: なにを書いていいかわからない\n\n\n\n\n\n\n\n\nドキュメントの目的がわかっていない\nドキュメントの目的から導き出されるテーマについて，その構成要素を分解できていない\n\n\n\n\n\n\n\n\nImportantProblem 2: あれもこれもと，情報詰め込んでしまう\n\n\n\n\n\n\n\n\n読み手とテーマが明確に定義されていない\n\n\n\n\n\n\n\n\nImportantProblem 3: 自分で説明するとき，何故か説明しづらい\n\n\n\n\n\n\n\n\nドキュメントの目的に対して，テーマが十分分解されていない\n分解されたテーマの配置が不自然な流れになっている\n\nheadingsとkey takeawaysだけ読んでみたとき，目が止まってしまう or 順番が飛んでしまう\n\n\n\n\n\n\n\n\n\nImportantProblem 4: 何が言いたいかわからないheadingsがある\n\n\n\n\n\n\n\n\nkey takeawaysが定義されていない\nMMUFの構成になっていない\n\n\n\n\n\n\n\n\nImportantProblem 5: 作成したユーザーマニュアルが読みづらいと言われた\n\n\n\n\n\n\n\n\n各見出しにおける想定ユーザーが明確に定義されていない\n想定ユーザーについて，書き手が仮定した読み手知識レベルが対応していない\n読み手を主語にした文となっていない\n\nユーザーマニュアルは読者の立場に立った指示やガイドを提供するべき"
  },
  {
    "objectID": "posts/2025-05-30-how-to-write-document/index.html#appendix-パラグラフと段落の違い",
    "href": "posts/2025-05-30-how-to-write-document/index.html#appendix-パラグラフと段落の違い",
    "title": "ドキュメントの書き方",
    "section": "Appendix: パラグラフと段落の違い",
    "text": "Appendix: パラグラフと段落の違い\n「パラグラフ」と「段落」は、日常的には同じ意味で使われることも多いですが、ドキュメント作成の文脈では以下のような差異が有ります:\n\n\n\n\n\n\n\n\n\n用語\n視点\n意味\n\n\n\n\n段落\n見た目\n改行による文章の区切り何を１段落にまとめるかの自由度が高い\n\n\nパラグラフ\n意味\n1つの主張を持った論理的な文の集まり1 paragraph 1 topic\n\n\n\n\nPragraphの構成\n1つのパラグラフは、原則として以下のような構造で成り立っています：\n\n\n\n\n\n\n\n\n構成要素\n説明\n\n\n\n\ntopic sentence\nパラグラフの最初に置かれ、その段落で述べたい中心的な主張やポイントを示す\n\n\nsupport sentence\n「なぜそう言えるのか？」「どんな意味があるのか？」を展開する"
  },
  {
    "objectID": "posts/2025-05-30-how-to-write-document/index.html#references",
    "href": "posts/2025-05-30-how-to-write-document/index.html#references",
    "title": "ドキュメントの書き方",
    "section": "References",
    "text": "References\n\n構造化されたストーリーとしてのスライド"
  },
  {
    "objectID": "posts/2025-08-25-columnar-storage/index.html",
    "href": "posts/2025-08-25-columnar-storage/index.html",
    "title": "Columnar Storageの特徴",
    "section": "",
    "text": "Definition 1 Columnar Storage\n\n1つのレコードをcolumn valuesグループ毎に分割し，それぞれを異なるストレージ領域に格納する技術\n従来のデータベースは通常，レコード全体を1つのストレージ領域に格納する\nファイルフォーマットまで着目すると，column-based formatの例としてParquetがある\n\n\n\n\nColumnar storage image\n\n\n\nColumnar Storageの特徴\n\n\n\n\n\n\nNote1: 通信量の最小化\n\n\n\n\nクエリ実行時に，必要な列の値だけがスキャンされ，転送される\nSELECT title FROM fooは，title 列の値だけにアクセスする\nSELECT * FROM foo だと結局ずべてのストーレージ領域に対してアクセスしてしまい，columnar-storageのメリットが活かせなくなる\n\n\n\n\n\n\n\n\n\nNote2: 高い圧縮率\n\n\n\n\n従来のrow-based storageはおおよそ 1:3 の圧縮に対して，Column storageは 1:10 の圧縮率を達成できるとされる(see here)\nColumnには似通った値が並ぶため傾向があるため（特に列のcardinalityが低い場合），row-based storageよりも高い圧縮率を得やすい\n\n\n\n\n\n\n\n\n\nImportant3: 更新処理の非効率性\n\n\n\n\n既存レコードの更新に弱く，1つのレコードを更新する場合でも列ごとに分割して保存されているため，複数のストレージ領域へアクセスする必要がある\nrow-based storageだとrowが１つのストレージ領域へ保存されるので，更新時のアクセスは１つのストレージ領域で済む\n\n\n\n\nExample 1 columnar storage vs row-based storage\nSNO  PRICE CITY    SNAME\n---  ------ ----    -----\nS1       20 London  Smith\nS2       10 Paris   Jones\nS3       30 Paris   Blake\nS4       20 London  Clark\nS5       30 Athens  Adams\nというような FOO テーブルを考えます．シンプルなColumnar storageの場合，以下のように;で区切られたグループ毎にストーレージ領域に保存します\nS1S2S3S4S5;2010302030;LondonParisParisLondonAthens;SmithJonesBlakeClarkAdams \n一方，row-based storageの場合\nS120LondonSmith;S210ParisJones;S330ParisBlake;S420LondonClark;S530AthensAdams\nそれぞれのstorageパターンに対して\nSELECT CITY, SUM(PRICE) \nFROM FOO \nGROUP BY CITY;\nというクエリを実行すると\n\nRow-based storage: 全列(=不要列（SNO, SNAME）もI/O)を毎回読み込んでから，PRICE と CITY を抽出して集計\nColumnar storage: 必要な列だけ読み込む．集計系クエリで圧倒的に速い\n\n\n\n\nExample 2 row-based storageの方が効率が良い場合\n次のようなSELECT文ではrow-based storageの方が効率的な可能性があります\nSELECT *\nFROM SomeTable\nWHERE col_1 = 'A';\ncol_a = 'A' の条件によってレコード数を大きく絞り込めたとしても，columnar storageの場合は結局 SELECT * によってすべての列にアクセスする必要があります． col_1 がインデックスを持つ場合だと，インデックス探索で col_1 = 'A' の行位置を即座に特定してから必要なストーレージ領域のみ読み込めば良いので，効率的なスキャンが期待できます．"
  },
  {
    "objectID": "posts/2025-08-25-columnar-storage/index.html#columnar-storageの特徴",
    "href": "posts/2025-08-25-columnar-storage/index.html#columnar-storageの特徴",
    "title": "Columnar Storageの特徴",
    "section": "",
    "text": "Definition 1 Columnar Storage\n\n1つのレコードをcolumn valuesグループ毎に分割し，それぞれを異なるストレージ領域に格納する技術\n従来のデータベースは通常，レコード全体を1つのストレージ領域に格納する\nファイルフォーマットまで着目すると，column-based formatの例としてParquetがある\n\n\n\n\nColumnar storage image\n\n\n\nColumnar Storageの特徴\n\n\n\n\n\n\nNote1: 通信量の最小化\n\n\n\n\nクエリ実行時に，必要な列の値だけがスキャンされ，転送される\nSELECT title FROM fooは，title 列の値だけにアクセスする\nSELECT * FROM foo だと結局ずべてのストーレージ領域に対してアクセスしてしまい，columnar-storageのメリットが活かせなくなる\n\n\n\n\n\n\n\n\n\nNote2: 高い圧縮率\n\n\n\n\n従来のrow-based storageはおおよそ 1:3 の圧縮に対して，Column storageは 1:10 の圧縮率を達成できるとされる(see here)\nColumnには似通った値が並ぶため傾向があるため（特に列のcardinalityが低い場合），row-based storageよりも高い圧縮率を得やすい\n\n\n\n\n\n\n\n\n\nImportant3: 更新処理の非効率性\n\n\n\n\n既存レコードの更新に弱く，1つのレコードを更新する場合でも列ごとに分割して保存されているため，複数のストレージ領域へアクセスする必要がある\nrow-based storageだとrowが１つのストレージ領域へ保存されるので，更新時のアクセスは１つのストレージ領域で済む\n\n\n\n\nExample 1 columnar storage vs row-based storage\nSNO  PRICE CITY    SNAME\n---  ------ ----    -----\nS1       20 London  Smith\nS2       10 Paris   Jones\nS3       30 Paris   Blake\nS4       20 London  Clark\nS5       30 Athens  Adams\nというような FOO テーブルを考えます．シンプルなColumnar storageの場合，以下のように;で区切られたグループ毎にストーレージ領域に保存します\nS1S2S3S4S5;2010302030;LondonParisParisLondonAthens;SmithJonesBlakeClarkAdams \n一方，row-based storageの場合\nS120LondonSmith;S210ParisJones;S330ParisBlake;S420LondonClark;S530AthensAdams\nそれぞれのstorageパターンに対して\nSELECT CITY, SUM(PRICE) \nFROM FOO \nGROUP BY CITY;\nというクエリを実行すると\n\nRow-based storage: 全列(=不要列（SNO, SNAME）もI/O)を毎回読み込んでから，PRICE と CITY を抽出して集計\nColumnar storage: 必要な列だけ読み込む．集計系クエリで圧倒的に速い\n\n\n\n\nExample 2 row-based storageの方が効率が良い場合\n次のようなSELECT文ではrow-based storageの方が効率的な可能性があります\nSELECT *\nFROM SomeTable\nWHERE col_1 = 'A';\ncol_a = 'A' の条件によってレコード数を大きく絞り込めたとしても，columnar storageの場合は結局 SELECT * によってすべての列にアクセスする必要があります． col_1 がインデックスを持つ場合だと，インデックス探索で col_1 = 'A' の行位置を即座に特定してから必要なストーレージ領域のみ読み込めば良いので，効率的なスキャンが期待できます．"
  },
  {
    "objectID": "posts/2025-08-25-columnar-storage/index.html#columnar-storageとlimit句",
    "href": "posts/2025-08-25-columnar-storage/index.html#columnar-storageとlimit句",
    "title": "Columnar Storageの特徴",
    "section": "Columnar storageとLIMIT句",
    "text": "Columnar storageとLIMIT句\nSELECT * FROM table LIMIT 10;\nと実行するとColumnar storage型のBigQueryでもPostgreSQLでも，返す行は最大 10 行と結果の行数を制限するという意味では同じです． ただし，クエリ実行計画まで着目するとその挙動に差異があります．\nBigQueryの場合\n\nLIMITはクエリで返す行数を制限する句\nLIMITは「処理するデータ量」を制限するものではなく，最終的に返す行数を制御するだけ\nそのため，SELECT * に LIMIT を付けても，テーブル全体が読み取られるため課金対象の量を減らすことはできない\n結果件数だけ制御するだけで，処理量や課金は減らない\n\nPostgreSQLの場合\n\nPostgresは，row-basedデータベースで基本的に必要な行だけ返す\nLIMITを付けると，クエリプランナーは「どのくらい行を読むか」を考慮するため，実際の処理コストは下がることが多い\n結果件数だけでなく，実行計画にも効いて実際の処理量削減につながる余地がある"
  },
  {
    "objectID": "posts/2025-08-25-columnar-storage/index.html#rerferences",
    "href": "posts/2025-08-25-columnar-storage/index.html#rerferences",
    "title": "Columnar Storageの特徴",
    "section": "Rerferences",
    "text": "Rerferences\n\nColumn-Oriented Database Systems, Stavros Harizopoulos, Daniel Abadi, Peter Boncz, VLDB 2009 Tutorial\nBigQuery &gt; Documentation &gt; クエリ計算を最適化する"
  },
  {
    "objectID": "posts/2025-06-17-countable-set-and-cardinality/index.html",
    "href": "posts/2025-06-17-countable-set-and-cardinality/index.html",
    "title": "可算集合と濃度",
    "section": "",
    "text": "自然数の集合 \\(\\mathbb N\\) と1対1に対応している集合は，\\(\\mathbb N\\) と「同じ個数の元」を持つと考えても良いと思われますが，無限集合の場合は 「元をすべて数え上げるということはできない」．ここで登場するのが「濃度」という概念です．\n\n\n\nDefinition 1 1対1対応\n集合 \\(M\\) から集合 \\(N\\) への写像 \\(\\varphi\\) で，次の(1), (2) の性質を満たすものが存在するとき，\\(M, N\\) は1対1対応しているという\n\n\\(a, a^\\prime \\in M\\) で \\(a\\neq a^\\prime\\) ならば \\(\\varphi(a)\\neq \\varphi(a^\\prime)\\)\n任意の \\(\\tilde b \\in N\\) に対して，ある \\(\\tilde a\\in M\\) が存在して，\\(\\varphi(\\tilde a) = \\tilde b\\)\n\n\n\nDefinition 2 濃度\n\\(M, N\\) は1対1対応しているとき，\\(M\\) と \\(N\\) は同じ濃度をもつという．\n\nカントールの対関数の全単射性の証明より，自然数の対 \\((m, n)\\) 全体の作る集合は \\(\\mathbb N\\) と1対1対応している = 同じ濃度であることがわかります．\nこれを一般的な定理に拡張すると，\n\n\\(M, N\\) を可算集合とすると，直積集合 \\(M\\times N\\) も可算集合である\n\nということになります．ただし，可算集合 \\(A_i\\) について \\(\\displaystyle\\Pi_{i=1}^\\infty A_i\\) は可算集合とはなりません，\n\nDefinition 3 可算\n自然数の集合 \\(\\mathbb N\\) と同じ濃度を持つ集合を，可算集合と呼ぶ．この可算集合の濃度を \\(\\mathfrak{N}_0\\) と表す．\n\n\nExample 1 偶数と奇数の集合\n偶数の自然数の全体の集合を \\(\\pmb{E}_0\\) としたとき，写像 \\(f: \\mathbb N \\to \\pmb{E}_0\\) を\n\\[\nf(n) = 2n\n\\]\nとすると，\\(f\\) は全単射になります．このとき，\\(\\pmb{E}_0 \\subset \\mathbb N\\) であるが，\n\\[\n|\\pmb{E}_0| = |\\mathbb N|\n\\]\nという有限集合ではありえない性質が成立します．\nまた，奇数の自然数の全体の集合を \\(\\pmb{E}_1\\) としたとき，写像 \\(g: \\mathbb N \\to \\pmb{E}_1\\) を\n\\[\ng(n) = 2(n - 1) + 1\n\\]\nとすると，\\(g\\) も全単射となります．\n\n\n\nExample 2 整数の集合と可算集合\n整数の集合 \\(\\mathbb Z\\) について，写像 \\(\\varphi: \\mathbb N \\to \\mathbb Z\\) を\n\\[\n\\begin{align}\n\\varphi(n) =\n  \\left\\{\\begin{array}{c}\n  \\frac{n}{2} & ( n \\in \\mathbb E_0 )\\\\\n  -\\frac{n-1}{2} & ( n \\in \\mathbb E_1)\n  \\end{array}\\right.\n\\end{align}\n\\]\nとすると，\\(\\varphi\\) は全単射になります．\n\n\n\n\n\n\nTheorem 1 \n\\(M\\) を可算集合とする，\\(S\\subset M\\) が無限集合であるとすると，\\(S\\) は可算集合である\n\n\n\n\n\n\n\nNoteProof\n\n\n\n\n\n\\(M\\) は可算集合であるので，\\(M\\) は\n\\[\nM = \\{a_1, a_2, a_3, \\cdots, a_n, \\cdots\\}\n\\]\nと表すことができます．\\(S\\) の元で，この並び方の最初に現れるものを \\(a_{i_1}\\) とすると，\n\\[\nS =  \\{a_{i_1}, a_{i_2}, a_{i_3}, \\cdots, a_{i_n}, \\cdots\\}\n\\]\nとなり，また，\\(S\\) は無限集合なのでこの系列が途中で止まることはありません．写像 \\(f: \\mathbb N\\to S\\) を\n\\[\nf(n) = a_{i_n}\n\\]\nとすると，\\(f\\) は1対1写像となるので，\\(S\\) は可算集合であることがわかります．\n\n\n\n\nExample 3 素数集合と可算集合\n素数が無限にあることは，背理法を用いると示しやすいです，素数が有限個しかないとして，その総数を \\(n\\) とすると素数全体の集合 \\(\\mathbb P\\) は\n\\[\n\\mathbb P = \\{2, 3, 5, \\cdots, p_n\\}\n\\]\nこのとき自然数 \\(q\\) を\n\\[\nq = 2 \\cdot 3 \\cdot \\cdots p_n + 1\n\\]\nは \\(q\\) はどんな素数でも割り切れないものになってしまうので，素数となりますが，これは素数の総数 \\(n\\) という仮定と矛盾．つまり，素数は無限に存在します．\n素数集合は\n\\[\n\\mathbb P \\subset \\mathbb N\n\\]\nであるので，素数集合は可算集合となります．"
  },
  {
    "objectID": "posts/2025-06-17-countable-set-and-cardinality/index.html#可算集合と濃度",
    "href": "posts/2025-06-17-countable-set-and-cardinality/index.html#可算集合と濃度",
    "title": "可算集合と濃度",
    "section": "",
    "text": "自然数の集合 \\(\\mathbb N\\) と1対1に対応している集合は，\\(\\mathbb N\\) と「同じ個数の元」を持つと考えても良いと思われますが，無限集合の場合は 「元をすべて数え上げるということはできない」．ここで登場するのが「濃度」という概念です．\n\n\n\nDefinition 1 1対1対応\n集合 \\(M\\) から集合 \\(N\\) への写像 \\(\\varphi\\) で，次の(1), (2) の性質を満たすものが存在するとき，\\(M, N\\) は1対1対応しているという\n\n\\(a, a^\\prime \\in M\\) で \\(a\\neq a^\\prime\\) ならば \\(\\varphi(a)\\neq \\varphi(a^\\prime)\\)\n任意の \\(\\tilde b \\in N\\) に対して，ある \\(\\tilde a\\in M\\) が存在して，\\(\\varphi(\\tilde a) = \\tilde b\\)\n\n\n\nDefinition 2 濃度\n\\(M, N\\) は1対1対応しているとき，\\(M\\) と \\(N\\) は同じ濃度をもつという．\n\nカントールの対関数の全単射性の証明より，自然数の対 \\((m, n)\\) 全体の作る集合は \\(\\mathbb N\\) と1対1対応している = 同じ濃度であることがわかります．\nこれを一般的な定理に拡張すると，\n\n\\(M, N\\) を可算集合とすると，直積集合 \\(M\\times N\\) も可算集合である\n\nということになります．ただし，可算集合 \\(A_i\\) について \\(\\displaystyle\\Pi_{i=1}^\\infty A_i\\) は可算集合とはなりません，\n\nDefinition 3 可算\n自然数の集合 \\(\\mathbb N\\) と同じ濃度を持つ集合を，可算集合と呼ぶ．この可算集合の濃度を \\(\\mathfrak{N}_0\\) と表す．\n\n\nExample 1 偶数と奇数の集合\n偶数の自然数の全体の集合を \\(\\pmb{E}_0\\) としたとき，写像 \\(f: \\mathbb N \\to \\pmb{E}_0\\) を\n\\[\nf(n) = 2n\n\\]\nとすると，\\(f\\) は全単射になります．このとき，\\(\\pmb{E}_0 \\subset \\mathbb N\\) であるが，\n\\[\n|\\pmb{E}_0| = |\\mathbb N|\n\\]\nという有限集合ではありえない性質が成立します．\nまた，奇数の自然数の全体の集合を \\(\\pmb{E}_1\\) としたとき，写像 \\(g: \\mathbb N \\to \\pmb{E}_1\\) を\n\\[\ng(n) = 2(n - 1) + 1\n\\]\nとすると，\\(g\\) も全単射となります．\n\n\n\nExample 2 整数の集合と可算集合\n整数の集合 \\(\\mathbb Z\\) について，写像 \\(\\varphi: \\mathbb N \\to \\mathbb Z\\) を\n\\[\n\\begin{align}\n\\varphi(n) =\n  \\left\\{\\begin{array}{c}\n  \\frac{n}{2} & ( n \\in \\mathbb E_0 )\\\\\n  -\\frac{n-1}{2} & ( n \\in \\mathbb E_1)\n  \\end{array}\\right.\n\\end{align}\n\\]\nとすると，\\(\\varphi\\) は全単射になります．\n\n\n\n\n\n\nTheorem 1 \n\\(M\\) を可算集合とする，\\(S\\subset M\\) が無限集合であるとすると，\\(S\\) は可算集合である\n\n\n\n\n\n\n\nNoteProof\n\n\n\n\n\n\\(M\\) は可算集合であるので，\\(M\\) は\n\\[\nM = \\{a_1, a_2, a_3, \\cdots, a_n, \\cdots\\}\n\\]\nと表すことができます．\\(S\\) の元で，この並び方の最初に現れるものを \\(a_{i_1}\\) とすると，\n\\[\nS =  \\{a_{i_1}, a_{i_2}, a_{i_3}, \\cdots, a_{i_n}, \\cdots\\}\n\\]\nとなり，また，\\(S\\) は無限集合なのでこの系列が途中で止まることはありません．写像 \\(f: \\mathbb N\\to S\\) を\n\\[\nf(n) = a_{i_n}\n\\]\nとすると，\\(f\\) は1対1写像となるので，\\(S\\) は可算集合であることがわかります．\n\n\n\n\nExample 3 素数集合と可算集合\n素数が無限にあることは，背理法を用いると示しやすいです，素数が有限個しかないとして，その総数を \\(n\\) とすると素数全体の集合 \\(\\mathbb P\\) は\n\\[\n\\mathbb P = \\{2, 3, 5, \\cdots, p_n\\}\n\\]\nこのとき自然数 \\(q\\) を\n\\[\nq = 2 \\cdot 3 \\cdot \\cdots p_n + 1\n\\]\nは \\(q\\) はどんな素数でも割り切れないものになってしまうので，素数となりますが，これは素数の総数 \\(n\\) という仮定と矛盾．つまり，素数は無限に存在します．\n素数集合は\n\\[\n\\mathbb P \\subset \\mathbb N\n\\]\nであるので，素数集合は可算集合となります．"
  },
  {
    "objectID": "posts/2025-06-17-countable-set-and-cardinality/index.html#references",
    "href": "posts/2025-06-17-countable-set-and-cardinality/index.html#references",
    "title": "可算集合と濃度",
    "section": "References",
    "text": "References\n\nカントールの対関数の全単射性の証明"
  },
  {
    "objectID": "posts/2025-09-12-kernel-function/index.html",
    "href": "posts/2025-09-12-kernel-function/index.html",
    "title": "代表的なカーネル関数",
    "section": "",
    "text": "Noteカーネル関数例\n\n\n\n\\[\n\\begin{align}\n\\text{Gaussian kernel: } & k(u) = \\frac{1}{\\sqrt{2\\pi}}\\exp\\left(-\\frac{u^2}{2}\\right)\\\\\n\\text{Epanechnikov kernel: } & k(u) = \\frac{3}{4}(1 - u^2)\\mathbf I\\{|u| \\leq 1\\} = \\frac{3}{4}\\max\\{1 - u^2, 0\\}\\\\\n\\text{Biweight kernel: } & k(u) = \\frac{15}{16}(1 - u^2)^2\\mathbf I\\{|u| \\leq 1\\}\\\\\n\\text{Uniform kernel: } & k(u) = \\frac{1}{2}\\mathbf I\\{|u| \\leq 1\\}\\\\[5pt]\n\\text{Triangular kernel: } & k(u) = (1 - |u|)\\mathbf I\\{|u| \\leq 1\\}\n\\end{align}\n\\]\n\n\n上記のカーネル関数は以下のような特徴があります\n\n\\(K(u)\\) is symmetric\n\\(\\int k(u)du = 1\\): KDEで推定された関数が密度関数であるための必要条件\n\\(\\lim_{u\\to\\infty}k(u) = \\lim_{u\\to-\\infty}k(u) = 0\\)\n\n\n\nカーネル密度関数推定量を\n\\[\n\\hat f(x) = \\frac{1}{nh}\\sum_{i=1}^n k\\left(\\frac{X_i - x}{h}\\right)\n\\]\nとして，それぞれのカーネル関数を用いた推定結果を以下可視化します．\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nfrom sklearn.neighbors import KernelDensity\n\n# okabe-ito color\ncolor = [\n    \"#E69F00\",\n    \"#56B4E9\",\n    \"#009E73\",\n    \"#F0E442\",\n    \"#0072B2\",\n    \"#D55E00\",\n    \"#CC79A7\",\n    \"#000000\",\n]\n\n\n# Gaussian kernel function\ndef gaussian_kernel(u):\n    return (1 / np.sqrt(2 * np.pi)) * np.exp(-0.5 * u**2)\n\n\ndef epanechnikov_kernel(u):\n    const = 3 / 4\n    return const * (1 - u**2) * (np.abs(u) &lt;= 1).astype(float)\n\n\ndef biweight_kernel(u):\n    const = 15 / 16\n    return const * ((1 - u**2) ** 2) * (np.abs(u) &lt;= 1).astype(float)\n\n\ndef uniform_kernel(u):\n    return 0.5 * (np.abs(u) &lt;= 1).astype(float)\n\n\ndef triangular_kernel(u):\n    return (1 - np.abs(u)) * (np.abs(u) &lt;= 1).astype(float)\n\n\n# KDE\ndef kde(x, data, bandwidth, kernel_func):\n    n = len(data)\n    return (1 / (n * bandwidth)) * np.sum(kernel_func((x - data) / bandwidth))\n\n\n# Load Old Faithful dataset (from seaborn)\ndata = sns.load_dataset(\"geyser\")  # modern version of faithful dataset\nwaiting = data[\"waiting\"].dropna().values\n\n# Plot kernels\nu = np.linspace(-3, 3, 200)\nx_plot = np.linspace(40, 100, 1000)\nfig, axes = plt.subplots(5, 2, figsize=(16, 6 * 5))\n\n# gaussian\nkde_vals = list(map(lambda x: kde(x, waiting, 0.5, gaussian_kernel), x_plot))\naxes[0, 0].plot(u, gaussian_kernel(u), color[0], lw=2)\naxes[0, 0].set_ylabel(\"value\", fontsize=12)\naxes[0, 0].set_title(\"Gaussian Kernel\", fontsize=14)\naxes[0, 1].plot(x_plot, kde_vals, color[1], lw=1)\naxes[0, 1].set_ylabel(\"Density\", fontsize=12)\naxes[0, 1].set_xlabel(\"geyser$waiting\", fontsize=12)\naxes[0, 1].set_title(\"Gaussian KDE with bandwidth: 0.5\", fontsize=14)\n\n\n# epanechnikov\nkde_vals = list(map(lambda x: kde(x, waiting, 2, epanechnikov_kernel), x_plot))\naxes[1, 0].plot(u, epanechnikov_kernel(u), color[0], lw=2)\naxes[1, 0].set_ylabel(\"value\", fontsize=12)\naxes[1, 0].set_title(\"Epanechnikov Kernel\", fontsize=14)\naxes[1, 1].plot(x_plot, kde_vals, color[1], lw=1)\naxes[1, 1].set_ylabel(\"Density\", fontsize=12)\naxes[1, 1].set_xlabel(\"geyser$waiting\", fontsize=12)\naxes[1, 1].set_title(\"Epanechnikov KDE with bandwidth: 2\", fontsize=14)\n\n# Biweight\nkde_vals = list(map(lambda x: kde(x, waiting, 1, biweight_kernel), x_plot))\naxes[2, 0].plot(u, biweight_kernel(u), color[0], lw=2)\naxes[2, 0].set_ylabel(\"value\", fontsize=12)\naxes[2, 0].set_title(\"Biweight Kernel\", fontsize=14)\naxes[2, 1].plot(x_plot, kde_vals, color[1], lw=1)\naxes[2, 1].set_ylabel(\"Density\", fontsize=12)\naxes[2, 1].set_xlabel(\"geyser$waiting\", fontsize=12)\naxes[2, 1].set_title(\"Biweight KDE with bandwidth: 2\", fontsize=14)\n\n# Uniform\nkde_vals = list(map(lambda x: kde(x, waiting, 0.5, uniform_kernel), x_plot))\naxes[3, 0].plot(u, uniform_kernel(u), color[0], lw=2)\naxes[3, 0].set_ylabel(\"value\", fontsize=12)\naxes[3, 0].set_title(\"uniform Kernel\", fontsize=14)\naxes[3, 1].plot(x_plot, kde_vals, color[1], lw=1)\naxes[3, 1].set_ylabel(\"Density\", fontsize=12)\naxes[3, 1].set_xlabel(\"geyser$waiting\", fontsize=12)\naxes[3, 1].set_title(\"uniform KDE with bandwidth: 0.5\", fontsize=14)\n\n# Triangular\nkde_vals = list(map(lambda x: kde(x, waiting, 1.0, triangular_kernel), x_plot))\naxes[4, 0].plot(u, triangular_kernel(u), color[0], lw=2)\naxes[4, 0].set_ylabel(\"value\", fontsize=12)\naxes[4, 0].set_title(\"Triangular Kernel\", fontsize=14)\naxes[4, 1].plot(x_plot, kde_vals, color[1], lw=1)\naxes[4, 1].set_ylabel(\"Density\", fontsize=12)\naxes[4, 1].set_xlabel(\"geyser$waiting\", fontsize=12)\naxes[4, 1].set_title(\"Triangular KDE with bandwidth: 1.0\", fontsize=14)\n\nplt.show()"
  },
  {
    "objectID": "posts/2025-09-12-kernel-function/index.html#代表的なカーネル",
    "href": "posts/2025-09-12-kernel-function/index.html#代表的なカーネル",
    "title": "代表的なカーネル関数",
    "section": "",
    "text": "Noteカーネル関数例\n\n\n\n\\[\n\\begin{align}\n\\text{Gaussian kernel: } & k(u) = \\frac{1}{\\sqrt{2\\pi}}\\exp\\left(-\\frac{u^2}{2}\\right)\\\\\n\\text{Epanechnikov kernel: } & k(u) = \\frac{3}{4}(1 - u^2)\\mathbf I\\{|u| \\leq 1\\} = \\frac{3}{4}\\max\\{1 - u^2, 0\\}\\\\\n\\text{Biweight kernel: } & k(u) = \\frac{15}{16}(1 - u^2)^2\\mathbf I\\{|u| \\leq 1\\}\\\\\n\\text{Uniform kernel: } & k(u) = \\frac{1}{2}\\mathbf I\\{|u| \\leq 1\\}\\\\[5pt]\n\\text{Triangular kernel: } & k(u) = (1 - |u|)\\mathbf I\\{|u| \\leq 1\\}\n\\end{align}\n\\]\n\n\n上記のカーネル関数は以下のような特徴があります\n\n\\(K(u)\\) is symmetric\n\\(\\int k(u)du = 1\\): KDEで推定された関数が密度関数であるための必要条件\n\\(\\lim_{u\\to\\infty}k(u) = \\lim_{u\\to-\\infty}k(u) = 0\\)\n\n\n\nカーネル密度関数推定量を\n\\[\n\\hat f(x) = \\frac{1}{nh}\\sum_{i=1}^n k\\left(\\frac{X_i - x}{h}\\right)\n\\]\nとして，それぞれのカーネル関数を用いた推定結果を以下可視化します．\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nfrom sklearn.neighbors import KernelDensity\n\n# okabe-ito color\ncolor = [\n    \"#E69F00\",\n    \"#56B4E9\",\n    \"#009E73\",\n    \"#F0E442\",\n    \"#0072B2\",\n    \"#D55E00\",\n    \"#CC79A7\",\n    \"#000000\",\n]\n\n\n# Gaussian kernel function\ndef gaussian_kernel(u):\n    return (1 / np.sqrt(2 * np.pi)) * np.exp(-0.5 * u**2)\n\n\ndef epanechnikov_kernel(u):\n    const = 3 / 4\n    return const * (1 - u**2) * (np.abs(u) &lt;= 1).astype(float)\n\n\ndef biweight_kernel(u):\n    const = 15 / 16\n    return const * ((1 - u**2) ** 2) * (np.abs(u) &lt;= 1).astype(float)\n\n\ndef uniform_kernel(u):\n    return 0.5 * (np.abs(u) &lt;= 1).astype(float)\n\n\ndef triangular_kernel(u):\n    return (1 - np.abs(u)) * (np.abs(u) &lt;= 1).astype(float)\n\n\n# KDE\ndef kde(x, data, bandwidth, kernel_func):\n    n = len(data)\n    return (1 / (n * bandwidth)) * np.sum(kernel_func((x - data) / bandwidth))\n\n\n# Load Old Faithful dataset (from seaborn)\ndata = sns.load_dataset(\"geyser\")  # modern version of faithful dataset\nwaiting = data[\"waiting\"].dropna().values\n\n# Plot kernels\nu = np.linspace(-3, 3, 200)\nx_plot = np.linspace(40, 100, 1000)\nfig, axes = plt.subplots(5, 2, figsize=(16, 6 * 5))\n\n# gaussian\nkde_vals = list(map(lambda x: kde(x, waiting, 0.5, gaussian_kernel), x_plot))\naxes[0, 0].plot(u, gaussian_kernel(u), color[0], lw=2)\naxes[0, 0].set_ylabel(\"value\", fontsize=12)\naxes[0, 0].set_title(\"Gaussian Kernel\", fontsize=14)\naxes[0, 1].plot(x_plot, kde_vals, color[1], lw=1)\naxes[0, 1].set_ylabel(\"Density\", fontsize=12)\naxes[0, 1].set_xlabel(\"geyser$waiting\", fontsize=12)\naxes[0, 1].set_title(\"Gaussian KDE with bandwidth: 0.5\", fontsize=14)\n\n\n# epanechnikov\nkde_vals = list(map(lambda x: kde(x, waiting, 2, epanechnikov_kernel), x_plot))\naxes[1, 0].plot(u, epanechnikov_kernel(u), color[0], lw=2)\naxes[1, 0].set_ylabel(\"value\", fontsize=12)\naxes[1, 0].set_title(\"Epanechnikov Kernel\", fontsize=14)\naxes[1, 1].plot(x_plot, kde_vals, color[1], lw=1)\naxes[1, 1].set_ylabel(\"Density\", fontsize=12)\naxes[1, 1].set_xlabel(\"geyser$waiting\", fontsize=12)\naxes[1, 1].set_title(\"Epanechnikov KDE with bandwidth: 2\", fontsize=14)\n\n# Biweight\nkde_vals = list(map(lambda x: kde(x, waiting, 1, biweight_kernel), x_plot))\naxes[2, 0].plot(u, biweight_kernel(u), color[0], lw=2)\naxes[2, 0].set_ylabel(\"value\", fontsize=12)\naxes[2, 0].set_title(\"Biweight Kernel\", fontsize=14)\naxes[2, 1].plot(x_plot, kde_vals, color[1], lw=1)\naxes[2, 1].set_ylabel(\"Density\", fontsize=12)\naxes[2, 1].set_xlabel(\"geyser$waiting\", fontsize=12)\naxes[2, 1].set_title(\"Biweight KDE with bandwidth: 2\", fontsize=14)\n\n# Uniform\nkde_vals = list(map(lambda x: kde(x, waiting, 0.5, uniform_kernel), x_plot))\naxes[3, 0].plot(u, uniform_kernel(u), color[0], lw=2)\naxes[3, 0].set_ylabel(\"value\", fontsize=12)\naxes[3, 0].set_title(\"uniform Kernel\", fontsize=14)\naxes[3, 1].plot(x_plot, kde_vals, color[1], lw=1)\naxes[3, 1].set_ylabel(\"Density\", fontsize=12)\naxes[3, 1].set_xlabel(\"geyser$waiting\", fontsize=12)\naxes[3, 1].set_title(\"uniform KDE with bandwidth: 0.5\", fontsize=14)\n\n# Triangular\nkde_vals = list(map(lambda x: kde(x, waiting, 1.0, triangular_kernel), x_plot))\naxes[4, 0].plot(u, triangular_kernel(u), color[0], lw=2)\naxes[4, 0].set_ylabel(\"value\", fontsize=12)\naxes[4, 0].set_title(\"Triangular Kernel\", fontsize=14)\naxes[4, 1].plot(x_plot, kde_vals, color[1], lw=1)\naxes[4, 1].set_ylabel(\"Density\", fontsize=12)\naxes[4, 1].set_xlabel(\"geyser$waiting\", fontsize=12)\naxes[4, 1].set_title(\"Triangular KDE with bandwidth: 1.0\", fontsize=14)\n\nplt.show()"
  },
  {
    "objectID": "posts/2026-01-21-check-login-user-list/index.html",
    "href": "posts/2026-01-21-check-login-user-list/index.html",
    "title": "ログインユーザーリストを確認する",
    "section": "",
    "text": "w コマンドは，Linux システムに 現在ログインしているユーザーと，各ユーザーんお実行中プロセスをまとめて確認するときに使用するコマンド\nwho や uptime よりも情報量が多い\n\n\nDefinition 1 w コマンド\n\n現在ログイン中のユーザー情報を表示するコマンド\n\nオプションなし: 全ログインユーザーの状況を表示\nユーザー指定: 特定ユーザーのみ表示\n\n現在ログイン中のユーザー情報を保持するバイナリファイルである /var/run/utmp やプロセス情報 /proc から情報を取得\nTTY/pseudo-TTY に紐付いたログインしか見れない(= vscode経由のsshが見れるわけではない)\n\n\nsyntax\nw [options] [user]\n出力内容: ヘッダー\nuptime コマンドと同様に\n\n現在時刻\nシステム稼働時間（uptime）\nログイン中ユーザー数\nロードアベレージ（1 / 5 / 15 分）\n\nを表示します．\n$ uptime\n 17:58:44 up 100 days, 23:21, 14 users,  load average: 0.82, 1.07, 0.89\n\n$ % w   \n 18:00:21 up 100 days, 23:23, 14 users,  load average: 0.29, 0.82, 0.81\nUSER     TTY      FROM             LOGIN@   IDLE   JCPU   PCPU WHAT\n...\noptions\n\n\n\n\nオプション\nロング形式\n内容\n\n\n\n\n-h\n--no-header\nヘッダ行を表示しない\n\n\n-s\n--short\n簡易表示（LOGIN@ / JCPU / PCPU を省略）\n\n\n-u\n--no-current\n現在ユーザー判定を無視して CPU 時間を計算\n\n\n-f\n--from\nFROM（接続元ホスト）欄を表示／非表示切替\n\n\n-i\n--ip-addr\nFROM をホスト名ではなく IP アドレスで表示\n\n\n\n\n出力内容: ユーザーごとの情報\nログインユーザーについて，次の項目が表示されます．\n\n\n\n\n項目\n説明\n\n\n\n\nUSER\nログインユーザー名\n\n\nTTY\n利用中の端末（pts/0 など）\n\n\nFROM\n接続元ホスト（SSH の場合など）\n\n\nLOGIN@\nログイン時刻\n\n\nIDLE\n最後の操作からの経過時間\n\n\nJCPU\nその TTY に紐づく全プロセスの CPU 使用時間\n\n\nPCPU\n現在実行中プロセスの CPU 使用時間\n\n\nWHAT\n現在実行しているコマンド\n\n\n\n\n$ w\n 17:23:16 up 100 days, 22:46, 14 users,  load average: 0.39, 0.20, 0.31\nUSER     TTY      FROM                 LOGIN@   IDLE     JCPU   PCPU WHAT\nuser01   pts/0    tmux(session-A)      10Jan26 10days    1:31   0.12s -bash\nuser01   pts/1    tmux(session-A)      Sat22   40:46m   0.16s  0.16s -bash\nuser02   pts/2    tmux(session-B)      30Oct25  3:34m   0.14s  0.14s /bin/bash\nuser01   pts/7    tmux(session-A)      14Jan26  7days   0.04s  0.04s -bash\nuser03   pts/8    tmux(session-C)      29Dec25 22days   0.07s  0.07s -bash\nuser04   pts/4    remote-ip-A          17:23    2.00s  0.00s  0.00s tmux -u -2 -f /usr/share/by\nuser05   :1       local-display        24Oct25 ?xdm?    2days  0.00s /usr/libexec/gdm-x-session\nuser01   pts/9    tmux(session-A)      12Nov25 70days   0.06s  0.06s -bash\nuser04   pts/12   tmux(session-D)      17:23    1.00s  0.05s  0.01s w\nuser03   pts/13   remote-ip-B          16:38   44:12   0.03s  0.03s -bash\nuser01   pts/28   tmux(session-A)      14Jan26  5days  0.15s  0.15s -bash\nuser03   pts/29   tmux(session-C)      Mon18   47:15m  0.01s  0.01s -bash\nuser06   pts/34   remote-ip-C          15:59    1:22m  0.04s  0.04s -bash\nuser06   pts/35   remote-ip-C          16:01    1:21m  0.05s  0.05s -bash\nwho コマンドとの違い\nwho コマンドはデフォルト動作では /var/run/utmp 飲みの情報を参照して，現在のユーザーのログイン情報を表示します．\nwho /var/log/wtmp\nとすることで，last コマンドのように過去のログイン情報を参照することができるという特色があります．\nvar/run/utmp のパーミッション\n/var/run/utmp のパーミッションは，システム起動時に systemd または init によって設定されます．systemd の場合は， /usr/lib/tmpfiles.d/systemd.conf に以下のように設定されています\n$ cat /usr/lib/tmpfiles.d/systemd.conf | grep \"utmp\"\nF! /run/utmp 0664 root utmp -\n/usr/lib/tmpfiles.d/systemd.conf の各レコードは\n&lt;type&gt; &lt;path&gt; &lt;mode&gt; &lt;user&gt; &lt;group&gt; &lt;age&gt;\nで設定が記述されます．0644 を 0660 とすると一般ユーザーは read の権限がなくなります．再起動後，新たな設定に基づいて権限が設定されます． read の権限がなくなった場合は，who や w を叩いても，ユーザー情報が表示されなくなります．\n\n\n\n\n\n\nNote/usr/lib/tmpfiles.d/systemd.conf の各項目\n\n\n\n\n\n\n\n\n\n\n\n\n\n項目\n説明\n例\n補足\n\n\n\n\ntype\n作成・管理の種類\nF!, d, f, Z\nファイルかディレクトリか，初期化するか等を指定\n\n\npath\n対象パス\n/run/utmp\n絶対パスで指定\n\n\nmode\nパーミッション\n0664\nchmod と同じ形式（8進数）\n\n\nuser\n所有ユーザー\nroot\n- を指定すると変更しない\n\n\ngroup\n所有グループ\nutmp\n- を指定すると変更しない\n\n\nage\n有効期限・削除条件\n-, 10d, 1w\n古いファイルを自動削除する条件"
  },
  {
    "objectID": "posts/2026-01-21-check-login-user-list/index.html#w-コマンドを用いてログインユーザーリストを確認する",
    "href": "posts/2026-01-21-check-login-user-list/index.html#w-コマンドを用いてログインユーザーリストを確認する",
    "title": "ログインユーザーリストを確認する",
    "section": "",
    "text": "w コマンドは，Linux システムに 現在ログインしているユーザーと，各ユーザーんお実行中プロセスをまとめて確認するときに使用するコマンド\nwho や uptime よりも情報量が多い\n\n\nDefinition 1 w コマンド\n\n現在ログイン中のユーザー情報を表示するコマンド\n\nオプションなし: 全ログインユーザーの状況を表示\nユーザー指定: 特定ユーザーのみ表示\n\n現在ログイン中のユーザー情報を保持するバイナリファイルである /var/run/utmp やプロセス情報 /proc から情報を取得\nTTY/pseudo-TTY に紐付いたログインしか見れない(= vscode経由のsshが見れるわけではない)\n\n\nsyntax\nw [options] [user]\n出力内容: ヘッダー\nuptime コマンドと同様に\n\n現在時刻\nシステム稼働時間（uptime）\nログイン中ユーザー数\nロードアベレージ（1 / 5 / 15 分）\n\nを表示します．\n$ uptime\n 17:58:44 up 100 days, 23:21, 14 users,  load average: 0.82, 1.07, 0.89\n\n$ % w   \n 18:00:21 up 100 days, 23:23, 14 users,  load average: 0.29, 0.82, 0.81\nUSER     TTY      FROM             LOGIN@   IDLE   JCPU   PCPU WHAT\n...\noptions\n\n\n\n\nオプション\nロング形式\n内容\n\n\n\n\n-h\n--no-header\nヘッダ行を表示しない\n\n\n-s\n--short\n簡易表示（LOGIN@ / JCPU / PCPU を省略）\n\n\n-u\n--no-current\n現在ユーザー判定を無視して CPU 時間を計算\n\n\n-f\n--from\nFROM（接続元ホスト）欄を表示／非表示切替\n\n\n-i\n--ip-addr\nFROM をホスト名ではなく IP アドレスで表示\n\n\n\n\n出力内容: ユーザーごとの情報\nログインユーザーについて，次の項目が表示されます．\n\n\n\n\n項目\n説明\n\n\n\n\nUSER\nログインユーザー名\n\n\nTTY\n利用中の端末（pts/0 など）\n\n\nFROM\n接続元ホスト（SSH の場合など）\n\n\nLOGIN@\nログイン時刻\n\n\nIDLE\n最後の操作からの経過時間\n\n\nJCPU\nその TTY に紐づく全プロセスの CPU 使用時間\n\n\nPCPU\n現在実行中プロセスの CPU 使用時間\n\n\nWHAT\n現在実行しているコマンド\n\n\n\n\n$ w\n 17:23:16 up 100 days, 22:46, 14 users,  load average: 0.39, 0.20, 0.31\nUSER     TTY      FROM                 LOGIN@   IDLE     JCPU   PCPU WHAT\nuser01   pts/0    tmux(session-A)      10Jan26 10days    1:31   0.12s -bash\nuser01   pts/1    tmux(session-A)      Sat22   40:46m   0.16s  0.16s -bash\nuser02   pts/2    tmux(session-B)      30Oct25  3:34m   0.14s  0.14s /bin/bash\nuser01   pts/7    tmux(session-A)      14Jan26  7days   0.04s  0.04s -bash\nuser03   pts/8    tmux(session-C)      29Dec25 22days   0.07s  0.07s -bash\nuser04   pts/4    remote-ip-A          17:23    2.00s  0.00s  0.00s tmux -u -2 -f /usr/share/by\nuser05   :1       local-display        24Oct25 ?xdm?    2days  0.00s /usr/libexec/gdm-x-session\nuser01   pts/9    tmux(session-A)      12Nov25 70days   0.06s  0.06s -bash\nuser04   pts/12   tmux(session-D)      17:23    1.00s  0.05s  0.01s w\nuser03   pts/13   remote-ip-B          16:38   44:12   0.03s  0.03s -bash\nuser01   pts/28   tmux(session-A)      14Jan26  5days  0.15s  0.15s -bash\nuser03   pts/29   tmux(session-C)      Mon18   47:15m  0.01s  0.01s -bash\nuser06   pts/34   remote-ip-C          15:59    1:22m  0.04s  0.04s -bash\nuser06   pts/35   remote-ip-C          16:01    1:21m  0.05s  0.05s -bash\nwho コマンドとの違い\nwho コマンドはデフォルト動作では /var/run/utmp 飲みの情報を参照して，現在のユーザーのログイン情報を表示します．\nwho /var/log/wtmp\nとすることで，last コマンドのように過去のログイン情報を参照することができるという特色があります．\nvar/run/utmp のパーミッション\n/var/run/utmp のパーミッションは，システム起動時に systemd または init によって設定されます．systemd の場合は， /usr/lib/tmpfiles.d/systemd.conf に以下のように設定されています\n$ cat /usr/lib/tmpfiles.d/systemd.conf | grep \"utmp\"\nF! /run/utmp 0664 root utmp -\n/usr/lib/tmpfiles.d/systemd.conf の各レコードは\n&lt;type&gt; &lt;path&gt; &lt;mode&gt; &lt;user&gt; &lt;group&gt; &lt;age&gt;\nで設定が記述されます．0644 を 0660 とすると一般ユーザーは read の権限がなくなります．再起動後，新たな設定に基づいて権限が設定されます． read の権限がなくなった場合は，who や w を叩いても，ユーザー情報が表示されなくなります．\n\n\n\n\n\n\nNote/usr/lib/tmpfiles.d/systemd.conf の各項目\n\n\n\n\n\n\n\n\n\n\n\n\n\n項目\n説明\n例\n補足\n\n\n\n\ntype\n作成・管理の種類\nF!, d, f, Z\nファイルかディレクトリか，初期化するか等を指定\n\n\npath\n対象パス\n/run/utmp\n絶対パスで指定\n\n\nmode\nパーミッション\n0664\nchmod と同じ形式（8進数）\n\n\nuser\n所有ユーザー\nroot\n- を指定すると変更しない\n\n\ngroup\n所有グループ\nutmp\n- を指定すると変更しない\n\n\nage\n有効期限・削除条件\n-, 10d, 1w\n古いファイルを自動削除する条件"
  },
  {
    "objectID": "posts/2026-01-21-check-login-user-list/index.html#loginctl-を用いてログインセッションを確認する",
    "href": "posts/2026-01-21-check-login-user-list/index.html#loginctl-を用いてログインセッションを確認する",
    "title": "ログインユーザーリストを確認する",
    "section": "loginctl を用いてログインセッションを確認する",
    "text": "loginctl を用いてログインセッションを確認する\nw コマンドは TTY/pseudo-TTY に紐付いたログインしか確認できないため，GUI セッションや RDP 接続などを含めた包括的なログイン情報を取得するには loginctl コマンドを使用します．\n\nDefinition 2 loginctl コマンド\n\nsystemd-logind が管理するログインセッションを一覧・操作するコマンド\nTTY だけでなく，GUI（X11/Wayland），SSH，RDP など全てのセッションを表示可能\nセッション単位で詳細情報（アイドル状態，接続元，プロセスリーダー等）を取得できる\n\n\n主要なサブコマンド\n\n\n\n\nサブコマンド\n説明\n\n\n\n\nlist-sessions\n現在のセッション一覧を表示\n\n\nshow-session &lt;ID&gt;\n指定セッションの詳細情報を表示\n\n\nlist-users\nログイン中のユーザー一覧を表示\n\n\nterminate-session &lt;ID&gt;\n指定セッションを強制終了\n\n\nlock-session &lt;ID&gt;\n指定セッションをロック\n\n\n\n\n# セッション一覧を表示\n$ loginctl list-sessions\nSESSION  UID USER   SEAT  TTY\n      1 1000 user01 seat0 tty2\n     12 1001 user02       pts/1\n     15 1000 user01\n\n# 特定セッションの詳細を表示\n$ loginctl show-session 12\nId=12\nUser=1001\nName=user02\nTimestamp=Thu 2026-01-20 10:30:00 JST\n...\n\nw コマンド風の出力を loginctl で実現するスクリプト\n以下のスクリプトは loginctl の情報を w コマンドに似た形式で出力します．GUI セッションや RDP 接続も含めて表示できる点が利点です．\n\n\nloginctl-w.sh\n\n#!/bin/bash\n\n# key=value 形式から値だけ取り出す関数\nget() { awk -F= -v k=\"$1\" '$1==k{print $2}'; }\n\nprintf \"%-20s %-8s %-8s %-8s %-16s %-8s %s\\n\" \\\n  \"USER\" \"SESSION\" \"LOGIN\" \"IDLE\" \"FROM\" \"TYPE\" \"WHAT\"\n\nloginctl list-sessions --no-legend | while read -r sid uid user seat tty; do\n  info=$(loginctl show-session \"$sid\")\n\n  name=$(echo \"$info\" | get Name)\n  service=$(echo \"$info\" | get Service)\n  type=$(echo \"$info\" | get Type)\n  tty_v=$(echo \"$info\" | get TTY)\n  display=$(echo \"$info\" | get Display)\n  leader=$(echo \"$info\" | get Leader)\n  remote=$(echo \"$info\" | get RemoteHost)\n  ts=$(echo \"$info\" | get Timestamp)\n  idle_hint=$(echo \"$info\" | get IdleHint)\n  idle_since=$(echo \"$info\" | get IdleSinceHint)\n\n  # LOGIN\n  login_time=$(date -d \"$ts\" \"+%H:%M\" 2&gt;/dev/null || echo \"-\")\n\n  # IDLE（w 互換）\n  if [[ \"$idle_hint\" != \"yes\" || \"$idle_since\" -le 0 ]]; then\n    idle_fmt=\".\"\n  else\n    idle_sec=$(( ( $(date +%s) * 1000000 - idle_since ) / 1000000 ))\n\n    if (( idle_sec &lt; 60 )); then\n      idle_fmt=\".\"\n    elif (( idle_sec &lt; 3600 )); then\n      idle_fmt=\"$((idle_sec/60))m\"\n    elif (( idle_sec &lt; 86400 )); then\n      idle_fmt=\"$(printf \"%d:%02d\" $((idle_sec/3600)) $((idle_sec%3600/60)))\"\n    else\n      idle_fmt=\"$((idle_sec/86400))days\"\n    fi\n  fi\n\n  # FROM\n  from=\"${remote:--}\"\n\n  # TYPE\n  case \"$service\" in\n    sshd)\n      type_disp=\"ssh\"\n      ;;\n    xrdp-sesman)\n      type_disp=\"rdp\"\n      ;;\n    gdm-password|gdm-wayland-session|gdm-x-session)\n      type_disp=\"gui\"\n      ;;\n    *)\n      if [[ \"$type\" == \"x11\" || \"$type\" == \"wayland\" ]]; then\n        type_disp=\"gui\"\n      else\n        type_disp=\"${type:-unknown}\"\n      fi\n      ;;\n  esac\n\n  # WHAT\n  if [[ -n \"$tty_v\" ]]; then\n    what=\"tty:$tty_v\"\n  elif [[ -n \"$display\" ]]; then\n    what=\"display:$display\"\n  else\n    what=\"pid:$leader\"\n  fi\n\n  printf \"%-20s %-8s %-8s %-8s %-16s %-8s %s\\n\" \\\n    \"$name\" \"$sid\" \"$login_time\" \"$idle_fmt\" \"$from\" \"$type_disp\" \"$what\"\ndone\n\nスクリプトの処理フロー\n\n\n\n\n\nflowchart TD\n    A[loginctl list-sessions] --&gt; B[各セッションIDでループ]\n    B --&gt; C[loginctl show-session でセッション詳細取得]\n    C --&gt; D[get関数で各プロパティを抽出]\n    D --&gt; E[LOGIN: Timestampから時刻を整形]\n    D --&gt; F[IDLE: IdleHint/IdleSinceHintからアイドル時間を計算]\n    D --&gt; G[FROM: RemoteHostを取得]\n    D --&gt; H[TYPE: Serviceからセッション種別を判定]\n    D --&gt; I[WHAT: TTY/Display/Leaderから接続先を決定]\n    E & F & G & H & I --&gt; J[printf で整形出力]\n\n\n\n\n\n\n各処理の詳細解説\n1. get 関数: key=value 形式のパース\nget() { awk -F= -v k=\"$1\" '$1==k{print $2}'; }\nloginctl show-session の出力は Key=Value 形式なので，指定したキーの値を抽出するヘルパー関数を定義しています．\n2. セッション一覧の取得とループ\nloginctl list-sessions --no-legend | while read -r sid uid user seat tty; do\n\n--no-legend: ヘッダー行を除外して出力\nread -r: 各フィールドを変数に格納（sid=セッションID，uid=ユーザーID 等）\n\n3. IDLE 時間の計算\nidle_sec=$(( ( $(date +%s) * 1000000 - idle_since ) / 1000000 ))\n\nIdleSinceHint はマイクロ秒単位の UNIX タイムスタンプ\n現在時刻との差分を秒に変換し，w コマンド風の形式（5m, 1:30, 2days）に整形\n\n4. TYPE の判定ロジック\ncase \"$service\" in\n  sshd)           type_disp=\"ssh\" ;;\n  xrdp-sesman)    type_disp=\"rdp\" ;;\n  gdm-password|gdm-wayland-session|gdm-x-session)\n                  type_disp=\"gui\" ;;\n  *)\n    if [[ \"$type\" == \"x11\" || \"$type\" == \"wayland\" ]]; then\n      type_disp=\"gui\"\n    else\n      type_disp=\"${type:-unknown}\"\n    fi\n    ;;\nesac\nService プロパティからセッションの接続方式を判定:\n\nsshd → SSH 接続\nxrdp-sesman → RDP 接続\ngdm-* → GDM 経由の GUI ログイン\nその他は Type プロパティ（x11, wayland, tty）で判定\n\n5. WHAT の判定\nif [[ -n \"$tty_v\" ]]; then\n  what=\"tty:$tty_v\"\nelif [[ -n \"$display\" ]]; then\n  what=\"display:$display\"\nelse\n  what=\"pid:$leader\"\nfi\n接続先の情報を優先度順で表示:\n\nTTY が存在すれば tty:pts/0 のように表示\nDisplay があれば display::0 のように表示\nどちらもなければセッションリーダーの PID を表示\n\n出力例\nUSER                 SESSION  LOGIN    IDLE     FROM             TYPE     WHAT\nuser01               1        09:30    .        -                gui      display::1\nuser02               12       10:45    15m      192.168.1.100    ssh      tty:pts/1\nuser03               15       14:20    2:30     10.0.0.50        rdp      pid:12345\nw コマンドとの比較\n\n\n\n\n項目\nw コマンド\nloginctl スクリプト\n\n\n\n\nTTY セッション\n○\n○\n\n\nGUI セッション\n△（限定的）\n○\n\n\nSSH 接続\n○\n○\n\n\nRDP 接続\n×\n○\n\n\nJCPU/PCPU\n○\n×\n\n\n実行中コマンド\n○\n×（PID のみ）\n\n\n\n\nw コマンドは TTY に紐付いたプロセス情報（CPU 使用時間，実行中コマンド）を詳細に表示できる一方，loginctl ベースのスクリプトは GUI や RDP を含む全セッションを統一的に扱える利点があります．"
  },
  {
    "objectID": "posts/2025-10-10-zsh-inline-comment/index.html",
    "href": "posts/2025-10-10-zsh-inline-comment/index.html",
    "title": "Zshインタラクティブモードでコメントアウトを使用する",
    "section": "",
    "text": "Definition 1 INTERACTIVE_COMMENTS\nZsh sourceforge &gt; 6.7 Commentsに以下のように定義されています\n\nIn non-interactive shells, or in interactive shells with the INTERACTIVE_COMMENTS option set, a word beginning with the third character of the histchars parameter (‘#’ by default) causes that word and all the following characters up to a newline to be ignored.\n\n\nINTERACTIVE_COMMENTS を有効にすると，histchars の3番目の文字（デフォルトは #）で始まる文字列について，その単語とその後の改行までの文字列がコメント扱いになり無視されるようになります．\nhistchars\n% echo $histchars\n!^#\n# が三番目の文字であることがわかります．\n\n\n\n\n\n\nWarning\n\n\n\n\nhistchars 特殊変数の設定は絶対変えないこと\n\n\n\n設定方法\ncurrent sessionでのみ有効化したい場合は\n% setopt INTERACTIVE_COMMENTS\nを実行します．\n## 設定していない場合\n% echo hello #world            \nhello #world\n\n## setopt INTERACTIVE_COMMENTS実行後\n% echo hello #world          \nhello\n\n\n\n\n\n\nNoteインタラクティブシェル全般用の設定\n\n\n\n\nインタラクティブシェル全般でコメントアウト機能Onにしたい場合は，.zshrc に記載します\n\n\n\n設定の解除\n設定の解除は以下のコマンドを実行します\n% unsetopt INTERACTIVE_COMMENTS"
  },
  {
    "objectID": "posts/2025-10-10-zsh-inline-comment/index.html#interactive_comments-option",
    "href": "posts/2025-10-10-zsh-inline-comment/index.html#interactive_comments-option",
    "title": "Zshインタラクティブモードでコメントアウトを使用する",
    "section": "",
    "text": "Definition 1 INTERACTIVE_COMMENTS\nZsh sourceforge &gt; 6.7 Commentsに以下のように定義されています\n\nIn non-interactive shells, or in interactive shells with the INTERACTIVE_COMMENTS option set, a word beginning with the third character of the histchars parameter (‘#’ by default) causes that word and all the following characters up to a newline to be ignored.\n\n\nINTERACTIVE_COMMENTS を有効にすると，histchars の3番目の文字（デフォルトは #）で始まる文字列について，その単語とその後の改行までの文字列がコメント扱いになり無視されるようになります．\nhistchars\n% echo $histchars\n!^#\n# が三番目の文字であることがわかります．\n\n\n\n\n\n\nWarning\n\n\n\n\nhistchars 特殊変数の設定は絶対変えないこと\n\n\n\n設定方法\ncurrent sessionでのみ有効化したい場合は\n% setopt INTERACTIVE_COMMENTS\nを実行します．\n## 設定していない場合\n% echo hello #world            \nhello #world\n\n## setopt INTERACTIVE_COMMENTS実行後\n% echo hello #world          \nhello\n\n\n\n\n\n\nNoteインタラクティブシェル全般用の設定\n\n\n\n\nインタラクティブシェル全般でコメントアウト機能Onにしたい場合は，.zshrc に記載します\n\n\n\n設定の解除\n設定の解除は以下のコマンドを実行します\n% unsetopt INTERACTIVE_COMMENTS"
  },
  {
    "objectID": "posts/2025-10-10-zsh-inline-comment/index.html#コメントアウトのユースケース紹介",
    "href": "posts/2025-10-10-zsh-inline-comment/index.html#コメントアウトのユースケース紹介",
    "title": "Zshインタラクティブモードでコメントアウトを使用する",
    "section": "コメントアウトのユースケース紹介",
    "text": "コメントアウトのユースケース紹介\nzsh では ctrl + R でreverse history search（インクリメンタル検索）が実行できます．過去の実行コマンドを検索したい場合，コメントアウト機能と組み合わせると簡単に目的コマンドを探せるのでとても便利です．\n\n\n\n\nseach word\nexpected command\n\n\n\n\npoetry-preview\npoetry run quarto preview\n\n\nquarto vanilla preview\nquarto preview\n\n\napt-update\nsudo apt update && sudo apt upgrade -y\n\n\ngit cd\ncd $(git root)"
  },
  {
    "objectID": "posts/2025-03-01-herons-formula/index.html",
    "href": "posts/2025-03-01-herons-formula/index.html",
    "title": "ヘロンの公式の導出",
    "section": "",
    "text": "Theorem 1 : ヘロンの公式 \n\\(\\triangle ABC\\) の3辺の長さがそれぞれ \\(a, b, c\\) で与えられているとき，\n\\[\ns = \\frac{1}{2}(a + b + c)\n\\]\nとおくと，\\(\\triangle ABC\\) の面積 \\(S\\) は\n\\[\nS = \\sqrt{s(s-a)(s-b)(s-c)}\n\\]\n\n\n\n\n\n\n\n\n\nNote余弦定理を用いた証明\n\n\n\n\n\n3辺の長さがわかっているので，余弦定理より\n\\[\n\\begin{align}\na^2 &= b^2 + c^2 - 2bc\\cos A\\\\\n\\Rightarrow &\\cos A = \\frac{b^2+c^2-a^2}{2bc}\n\\end{align}\n\\]\n\\(\\sin^2 A + \\cos^2 A = 1\\) より\n\\[\n\\sin A = \\sqrt{1 - \\cos^2 A}\n\\]\n従って，面積 \\(S\\) は\n\\[\nS = \\frac{1}{2}bc\\sqrt{1 - \\cos^2 A}\n\\]\nこれを展開すると\n\\[\n\\begin{align}\nS\n    &= \\frac{1}{2}bc\\sqrt{1 - \\cos^2 A}\\\\\n    &= \\frac{1}{2}bc\\sqrt{1 - \\frac{(b^2+c^2-a^2)^2}{4b^2c^2}}\\\\\n    &= \\frac{1}{2}\\sqrt{b^2c^2 - \\left(\\frac{(b^2+c^2-a^2)}{2}\\right)^2}\\\\\n    &= \\frac{1}{2}\\sqrt{\\left(-\\frac{b^2+c^2-a^2-2bc}{2}\\right)\\left(\\frac{b^2+c^2-a^2+2bc}{2}\\right)}\\\\\n    &= \\frac{1}{2}\\sqrt{\\left(-\\frac{(b-c)^2-a^2}{2}\\right)\\left(\\frac{(b+c)^2-a^2}{2}\\right)}\\\\\n    &= \\frac{1}{2}\\sqrt{\\frac{(a+b-c)(a+c-b)}{2}\\frac{(a+b+c)(b+c-a)}{2}}\\\\\n    &= \\sqrt{\\frac{(a+b-c)}{2}\\frac{(a+c-b)}{2}\\frac{(a+b+c)}{2}\\frac{(b+c-a)}{2}}\\\\\n    &= \\sqrt{s(s-a)(s-b)(s-c)}\n\\end{align}\n\\]\n\n\n\n\n\n\n\n\n\n\nNote三角形の傍接円からのヘロンの公式\n\n\n\n\n\n下記のように \\(\\triangle ABC\\) について内心 \\(D\\) と傍心 \\(G\\) を考えます．\n\n前準備として \\(\\triangle ABC\\) のそれぞれの角の対辺を \\(a, b, c\\) として\n\\[\ns = \\frac{1}{2}(a + b + c)\n\\]\nと変数 \\(s\\) を定義します．また，内接円の性質（各頂点の内角の二等分線上に内心が存在）より\n\\[\n\\begin{align}\nAH &= AN\\\\\nCN &= CI\\\\\nBH &= BI\n\\end{align}\n\\]\n従って，\n\\[\n\\begin{align}\nAH &= s - a\\\\\nBH &= s - b\\\\\nCN &= s = c\n\\end{align}\n\\]\n傍接円の傍心 \\(G\\) は\n\n\\(\\angle A\\) の二等分線上\n\\(B\\) と \\(C\\)の外角の二等分線上\n\nに存在することから\n\\[\nAL = AE\n\\]\nまた，\n\\[\n\\begin{align}\nAL + AE\n    &= (AC + CL) + (AB + BE)\\\\\n    &= (AC + CO) + (AB + BO)\\\\\n    &=  a + b + c\\\\\n    &= 2s\n\\end{align}\n\\]\n従って，\n\\[\nAL = AE = s\n\\]\n内接円の内心 \\(D\\) が \\(\\angle B, \\angle C\\) の二等分線上に存在するので\n\\[\n\\begin{align}\n180^\\circ\n    &= 2\\angle HBD + 2\\angle EBG\\\\\n\\Rightarrow & 90^\\circ = \\angle HBD + \\angle EBG\n\\end{align}\n\\]\n従って，\n\\[\n\\begin{align}\n\\angle BDH &= \\angle EBG\n\\angle HBD &= \\angle BGE\n\\end{align}\n\\]\nここから\n\\[\n\\triangle HBD \\sim \\triangle EGB\n\\]\nこれより\n\\[\n\\frac{s - b}{r_1}=\\frac{r_2}{s - c}\n\\]\nこれを整理すると\n\\[\nr_1r_2 = (s-b)(s-c) \\label{#eq-1}\n\\]\nまた，\\(\\triangle HDE\\) と \\(\\triangle HDO\\) の面積が等しいことから\n\\[\nsr_1 = (s-a)r_2  \\label{#eq-2}\n\\]\n\\(\\eqref{#eq-1}\\), \\(\\eqref{#eq-2}\\) を 掛け合わせて \\(r_2\\) を両辺から除して \\(s\\) を両辺にかけると\n\\[\ns^2r_1^2 = s(s-a)(s-b)(s-c)\n\\]\n従って\n\\[\nsr_1 = \\sqrt{s(s-a)(s-b)(s-c)}\n\\]\nLHSは \\(\\triangle ABC\\) の面積と一致するので，これでヘロンの公式が示された．"
  },
  {
    "objectID": "posts/2025-03-01-herons-formula/index.html#辺から三角形の面積を求める",
    "href": "posts/2025-03-01-herons-formula/index.html#辺から三角形の面積を求める",
    "title": "ヘロンの公式の導出",
    "section": "",
    "text": "Theorem 1 : ヘロンの公式 \n\\(\\triangle ABC\\) の3辺の長さがそれぞれ \\(a, b, c\\) で与えられているとき，\n\\[\ns = \\frac{1}{2}(a + b + c)\n\\]\nとおくと，\\(\\triangle ABC\\) の面積 \\(S\\) は\n\\[\nS = \\sqrt{s(s-a)(s-b)(s-c)}\n\\]\n\n\n\n\n\n\n\n\n\nNote余弦定理を用いた証明\n\n\n\n\n\n3辺の長さがわかっているので，余弦定理より\n\\[\n\\begin{align}\na^2 &= b^2 + c^2 - 2bc\\cos A\\\\\n\\Rightarrow &\\cos A = \\frac{b^2+c^2-a^2}{2bc}\n\\end{align}\n\\]\n\\(\\sin^2 A + \\cos^2 A = 1\\) より\n\\[\n\\sin A = \\sqrt{1 - \\cos^2 A}\n\\]\n従って，面積 \\(S\\) は\n\\[\nS = \\frac{1}{2}bc\\sqrt{1 - \\cos^2 A}\n\\]\nこれを展開すると\n\\[\n\\begin{align}\nS\n    &= \\frac{1}{2}bc\\sqrt{1 - \\cos^2 A}\\\\\n    &= \\frac{1}{2}bc\\sqrt{1 - \\frac{(b^2+c^2-a^2)^2}{4b^2c^2}}\\\\\n    &= \\frac{1}{2}\\sqrt{b^2c^2 - \\left(\\frac{(b^2+c^2-a^2)}{2}\\right)^2}\\\\\n    &= \\frac{1}{2}\\sqrt{\\left(-\\frac{b^2+c^2-a^2-2bc}{2}\\right)\\left(\\frac{b^2+c^2-a^2+2bc}{2}\\right)}\\\\\n    &= \\frac{1}{2}\\sqrt{\\left(-\\frac{(b-c)^2-a^2}{2}\\right)\\left(\\frac{(b+c)^2-a^2}{2}\\right)}\\\\\n    &= \\frac{1}{2}\\sqrt{\\frac{(a+b-c)(a+c-b)}{2}\\frac{(a+b+c)(b+c-a)}{2}}\\\\\n    &= \\sqrt{\\frac{(a+b-c)}{2}\\frac{(a+c-b)}{2}\\frac{(a+b+c)}{2}\\frac{(b+c-a)}{2}}\\\\\n    &= \\sqrt{s(s-a)(s-b)(s-c)}\n\\end{align}\n\\]\n\n\n\n\n\n\n\n\n\n\nNote三角形の傍接円からのヘロンの公式\n\n\n\n\n\n下記のように \\(\\triangle ABC\\) について内心 \\(D\\) と傍心 \\(G\\) を考えます．\n\n前準備として \\(\\triangle ABC\\) のそれぞれの角の対辺を \\(a, b, c\\) として\n\\[\ns = \\frac{1}{2}(a + b + c)\n\\]\nと変数 \\(s\\) を定義します．また，内接円の性質（各頂点の内角の二等分線上に内心が存在）より\n\\[\n\\begin{align}\nAH &= AN\\\\\nCN &= CI\\\\\nBH &= BI\n\\end{align}\n\\]\n従って，\n\\[\n\\begin{align}\nAH &= s - a\\\\\nBH &= s - b\\\\\nCN &= s = c\n\\end{align}\n\\]\n傍接円の傍心 \\(G\\) は\n\n\\(\\angle A\\) の二等分線上\n\\(B\\) と \\(C\\)の外角の二等分線上\n\nに存在することから\n\\[\nAL = AE\n\\]\nまた，\n\\[\n\\begin{align}\nAL + AE\n    &= (AC + CL) + (AB + BE)\\\\\n    &= (AC + CO) + (AB + BO)\\\\\n    &=  a + b + c\\\\\n    &= 2s\n\\end{align}\n\\]\n従って，\n\\[\nAL = AE = s\n\\]\n内接円の内心 \\(D\\) が \\(\\angle B, \\angle C\\) の二等分線上に存在するので\n\\[\n\\begin{align}\n180^\\circ\n    &= 2\\angle HBD + 2\\angle EBG\\\\\n\\Rightarrow & 90^\\circ = \\angle HBD + \\angle EBG\n\\end{align}\n\\]\n従って，\n\\[\n\\begin{align}\n\\angle BDH &= \\angle EBG\n\\angle HBD &= \\angle BGE\n\\end{align}\n\\]\nここから\n\\[\n\\triangle HBD \\sim \\triangle EGB\n\\]\nこれより\n\\[\n\\frac{s - b}{r_1}=\\frac{r_2}{s - c}\n\\]\nこれを整理すると\n\\[\nr_1r_2 = (s-b)(s-c) \\label{#eq-1}\n\\]\nまた，\\(\\triangle HDE\\) と \\(\\triangle HDO\\) の面積が等しいことから\n\\[\nsr_1 = (s-a)r_2  \\label{#eq-2}\n\\]\n\\(\\eqref{#eq-1}\\), \\(\\eqref{#eq-2}\\) を 掛け合わせて \\(r_2\\) を両辺から除して \\(s\\) を両辺にかけると\n\\[\ns^2r_1^2 = s(s-a)(s-b)(s-c)\n\\]\n従って\n\\[\nsr_1 = \\sqrt{s(s-a)(s-b)(s-c)}\n\\]\nLHSは \\(\\triangle ABC\\) の面積と一致するので，これでヘロンの公式が示された．"
  },
  {
    "objectID": "posts/2025-08-31-stdout-stderr/index.html",
    "href": "posts/2025-08-31-stdout-stderr/index.html",
    "title": "シェルスクリプトにおける標準出力・標準エラー出力",
    "section": "",
    "text": "標準ストリーム（standard streams）とは，Unix系OS において，プログラムの活動実体であるプロセスとその実行環境の間でやり取りされる データの通り道（入出力チャネル） のことです．特に，キーボードからの入力を標準入力，ディスプレイへの出力を標準出力と呼びます.\n多くのコマンドは，何も指定しなくても実行結果をディスプレイに表示しますが，これは標準出力としてディスプレイを使うことが デフォルトとして設定されているためです.\n\n\n\n\n\n\n\n\n\n\n\n\n名称\nファイル記述子\n方向\n主な用途\n\n\n\n\n標準入力(stdin)\n0\n入力\nキーボードや他プログラムの出力からデータを受け取る\n\n\n標準出力(stdout)\n1\n出力\n通常の結果やメッセージを出力する\n\n\n標準エラー出力(stderr)\n2\n出力\nエラーメッセージなどを出力する\n\n\n\n\n\n\n\n\n標準ストリーム\n\n\n\n\n\n\n標準出力（stdout） は，通常の処理結果やプログラムの出力を表します． これをリダイレクトしたりパイプで別のコマンドに渡した場合， 出力内容がファイルや別のコマンドへ送られるため，端末上には表示されません．\n標準エラー出力（stderr） は，エラーメッセージや警告を伝えるための専用ストリームとなっています． 通常のリダイレクト（CMD &gt; file1 など）では stderr はリダイレクトされず，端末画面にそのまま表示されます． そのため，\n\nユーザーは標準出力をファイルや他の処理系に渡していても，エラーメッセージを見落とすことなく確認できる\nログ処理とエラー監視を独立して制御できる\n\n\n\n\n\n\n\n\n\n\nNoteリダイレクト\n\n\n\n\n標準出入力先を変更する機能のことをリダイレクトといいます\n標準出入力とリダイレクトを理解することで，コマンドがどこに出力するのかをコントロールできます\n\n\n\n\nExample 1 (Bash 標準ストリームのリダイレクト一覧) \n\n\n\n\n\n\n\n\n構文\n意味\n\n\n\n\n&lt; FileA\n標準入力を FileA に変更\n\n\n&gt; FileA\n標準出力を FileA に変更（上書き）．コマンドの出力先を画面上からファイルに切り替えること\n\n\n&gt;&gt; FileA\n標準出力を FileA の末尾に追記\n\n\n2&gt; FileA\n標準エラー出力を FileA に変更（上書き）\n\n\n2&gt;&gt; FileA\n標準エラー出力を FileA の末尾に追記\n\n\n&gt; FileA 2&gt;&1\n標準出力と標準エラー出力をまとめて FileA に変更\n\n\n&&gt; FileA\n標準出力と標準エラー出力をまとめて FileA に変更\n\n\n2&gt;&1\n標準エラー出力（stderr）を標準出力（stdout）の現在の設定にリダイレクト\n\n\n2&gt;&1 1&gt; /dev/null\nラーを標準出力，標準出力を /dev/null に捨てる\n\n\n\n\n\n\nというメリットがあります．\n/dev/null ファイル\nLinux系OSでは /dev/null という疑似デバイスファイルを用意してあります． /dev/null に書き込まれたデータはすべて破棄され，どこからどれだけ読み込んでも何もデータを返しません．\nエラーメッセージのみ出力させたくない場合は\necho 'stderr' 2&gt; /dev/null\nとしたりします．\n\n\n\n\n\n\nNote&lt;&lt; EOF という似て非なるヒアドキュメント構文\n\n\n\ncommand &lt;&lt;EOF\n... 任意のテキスト ...\nEOF\n\n&lt;&lt;EOF は「この後に続く行を，EOF が現れるまで標準入力として command に渡す」という意味\n&lt;&lt;EOF でなくても &lt;&lt;WORD や &lt;&lt;INPUT としても良いですが，慣例的に EOF が使われる\n\n\n\n\n\n\n\n\n\n\n\n\nNoteパイプ\n\n\n\n\nコマンドによって得られた結果を別コマンドに引き渡す機能のこと\n通常では標準エラー出力（STDERR）はパイプされない\n\n\n\nCMD1 の実行結果を CMD2 の標準入力に渡す場合\nCMD1 | CMD2\n標準出力と標準エラー出力をまとめてパイプで渡したい場合は，2&gt;&1 |，または |& を用います．\n## 標準エラー出力用のパイプ\nsed |& wc -l\n\n## ファイル記述子とパイプの組み合わせ\nsed 2&gt;&1 | wc -l"
  },
  {
    "objectID": "posts/2025-08-31-stdout-stderr/index.html#標準ストリーム",
    "href": "posts/2025-08-31-stdout-stderr/index.html#標準ストリーム",
    "title": "シェルスクリプトにおける標準出力・標準エラー出力",
    "section": "",
    "text": "標準ストリーム（standard streams）とは，Unix系OS において，プログラムの活動実体であるプロセスとその実行環境の間でやり取りされる データの通り道（入出力チャネル） のことです．特に，キーボードからの入力を標準入力，ディスプレイへの出力を標準出力と呼びます.\n多くのコマンドは，何も指定しなくても実行結果をディスプレイに表示しますが，これは標準出力としてディスプレイを使うことが デフォルトとして設定されているためです.\n\n\n\n\n\n\n\n\n\n\n\n\n名称\nファイル記述子\n方向\n主な用途\n\n\n\n\n標準入力(stdin)\n0\n入力\nキーボードや他プログラムの出力からデータを受け取る\n\n\n標準出力(stdout)\n1\n出力\n通常の結果やメッセージを出力する\n\n\n標準エラー出力(stderr)\n2\n出力\nエラーメッセージなどを出力する\n\n\n\n\n\n\n\n\n標準ストリーム\n\n\n\n\n\n\n標準出力（stdout） は，通常の処理結果やプログラムの出力を表します． これをリダイレクトしたりパイプで別のコマンドに渡した場合， 出力内容がファイルや別のコマンドへ送られるため，端末上には表示されません．\n標準エラー出力（stderr） は，エラーメッセージや警告を伝えるための専用ストリームとなっています． 通常のリダイレクト（CMD &gt; file1 など）では stderr はリダイレクトされず，端末画面にそのまま表示されます． そのため，\n\nユーザーは標準出力をファイルや他の処理系に渡していても，エラーメッセージを見落とすことなく確認できる\nログ処理とエラー監視を独立して制御できる\n\n\n\n\n\n\n\n\n\n\nNoteリダイレクト\n\n\n\n\n標準出入力先を変更する機能のことをリダイレクトといいます\n標準出入力とリダイレクトを理解することで，コマンドがどこに出力するのかをコントロールできます\n\n\n\n\nExample 1 (Bash 標準ストリームのリダイレクト一覧) \n\n\n\n\n\n\n\n\n構文\n意味\n\n\n\n\n&lt; FileA\n標準入力を FileA に変更\n\n\n&gt; FileA\n標準出力を FileA に変更（上書き）．コマンドの出力先を画面上からファイルに切り替えること\n\n\n&gt;&gt; FileA\n標準出力を FileA の末尾に追記\n\n\n2&gt; FileA\n標準エラー出力を FileA に変更（上書き）\n\n\n2&gt;&gt; FileA\n標準エラー出力を FileA の末尾に追記\n\n\n&gt; FileA 2&gt;&1\n標準出力と標準エラー出力をまとめて FileA に変更\n\n\n&&gt; FileA\n標準出力と標準エラー出力をまとめて FileA に変更\n\n\n2&gt;&1\n標準エラー出力（stderr）を標準出力（stdout）の現在の設定にリダイレクト\n\n\n2&gt;&1 1&gt; /dev/null\nラーを標準出力，標準出力を /dev/null に捨てる\n\n\n\n\n\n\nというメリットがあります．\n/dev/null ファイル\nLinux系OSでは /dev/null という疑似デバイスファイルを用意してあります． /dev/null に書き込まれたデータはすべて破棄され，どこからどれだけ読み込んでも何もデータを返しません．\nエラーメッセージのみ出力させたくない場合は\necho 'stderr' 2&gt; /dev/null\nとしたりします．\n\n\n\n\n\n\nNote&lt;&lt; EOF という似て非なるヒアドキュメント構文\n\n\n\ncommand &lt;&lt;EOF\n... 任意のテキスト ...\nEOF\n\n&lt;&lt;EOF は「この後に続く行を，EOF が現れるまで標準入力として command に渡す」という意味\n&lt;&lt;EOF でなくても &lt;&lt;WORD や &lt;&lt;INPUT としても良いですが，慣例的に EOF が使われる\n\n\n\n\n\n\n\n\n\n\n\n\nNoteパイプ\n\n\n\n\nコマンドによって得られた結果を別コマンドに引き渡す機能のこと\n通常では標準エラー出力（STDERR）はパイプされない\n\n\n\nCMD1 の実行結果を CMD2 の標準入力に渡す場合\nCMD1 | CMD2\n標準出力と標準エラー出力をまとめてパイプで渡したい場合は，2&gt;&1 |，または |& を用います．\n## 標準エラー出力用のパイプ\nsed |& wc -l\n\n## ファイル記述子とパイプの組み合わせ\nsed 2&gt;&1 | wc -l"
  },
  {
    "objectID": "posts/2025-08-31-stdout-stderr/index.html#標準データストリームリダイレクトパイプの実践",
    "href": "posts/2025-08-31-stdout-stderr/index.html#標準データストリームリダイレクトパイプの実践",
    "title": "シェルスクリプトにおける標準出力・標準エラー出力",
    "section": "標準データストリーム，リダイレクト，パイプの実践",
    "text": "標準データストリーム，リダイレクト，パイプの実践\n\nCASE 1: FileAの内容を並び替えて，その結果を別のファイルFileBに保存する\nsort &lt; FileA &gt; FileB\n\nsort コマンドは FileA の内容を読み取り（&lt; FileA）\nsortコマンドを実行し，並び替えを行う\nその結果を FileB に出力（&gt; FileB）\n\nただし，同じ動作は\nsort FileA &gt; FileB\nでも達成できます．\n\n\nCASE 2: エラーメッセージのみ出力させる\nユーザーがリダイレクトを用いて設定しなくては行けないことは\n\n標準出力結果を /dev/null へ捨てる\n標準エラー出力を標準出力へ渡す\n\nの２点となるので，以下の①と④を組み合わせて設定すればよいですが，設定順序がポイントなります．\n\n\n\n\n\n\n\n\n\n\nIndex\n目的\nコマンド例\n意味\n\n\n\n\n①\n標準出力を捨てる\nCMD &gt; /dev/nullCMD 1&gt; /dev/null\n結果は捨てるが、エラーは表示\n\n\n②\n標準エラーを捨てる\nCMD 2&gt; /dev/null\nエラーだけ捨てる\n\n\n③\n標準出力・標準エラーを両方捨てる\nCMD &&gt; /dev/nullCMD &gt; /dev/null 2&gt;&1\nすべての出力を破棄\n\n\n④\n標準エラーを標準出力へ渡す\nCMD 2&gt;&1\n両者を一緒に処理（例：パイプでまとめる）\n\n\n\n\n正しい設定例\nまず正しい例は\nCMD1 2&gt;&1 1&gt; /dev/null\nBashはリダイレクトを左から右へ順に評価するため，先にエラーを標準出力に結合し，次に出力を破棄という設定順番になります．\n誤った設定例\nCMD 1&gt; /dev/null 2&gt;&1\nだと，先に標準出力を破棄，次にエラーを現在の標準出力設定に結合になるので，標準出力及び標準エラー出力両方が /dev/null に捨てられてしまいます．\n\nExample 2 (poetryで標準エラー出力のみを表示する場合) \npoetry コマンドを用いるときなど，標準出力結果には興味がないがエラーだけ知りたいという場合があります．この場合は\npoetry update 1&gt; /dev/null\n\npoetry update &gt; /dev/null\n\npoetry update 2&gt;&1 1&gt; /dev/null\nのいずれかの実行で標準エラー出力のみを表示することができます．最後の設定は標準エラー出力を標準出力にリダイレクトしているので， 厳密には挙動は同じではないことに注意してください．\n\n\n\n\nCASE 3: ファイルへの書き込みと標準出力を同時に行う\ntee コマンドを使うと標準出力を保持しつつファイルにも書き込むことができます．\n\n\n\n\n\n\nNotetee コマンド\n\n\n\n\nteeコマンドは，標準入力から読み込んだデータを標準出力とファイルの両方に出力するコマンド\nCMD | tee ファイル名\nデフォルトは上書き挙動だが，-a オプションを付与することで追記(append)設定も可能\n\n\n\n\nExample 3 \n/etc/passwd ファイルの内容に行番号を付け，その結果をパイプを通してファイルへ出力し，さらにその結果をパイプでheadコマンドに渡す場合は\n$ nl /etc/passwd | tee test.txt | head -3\n     1  root:x:0:0:root:/root:/usr/bin/zsh\n     2  daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin\n     3  bin:x:2:2:bin:/bin:/usr/sbin/nologin\n\n\n\nExample 4 (エラーを端末に表示しつつファイルに書く) \n標準出力を /dev/null に流しながら，標準エラー出力をファイルに書きたい場合は\nCMD 1&gt; /dev/null 2&gt; error.log\nで十分ですが，これだと端末にエラー出力が表示されません．標準エラー出力表示を維持したい場合は，Bashのプロセス置換 &gt;(...) を用いて\nCMD 1&gt; /dev/null 2&gt; &gt;(tee error.log)\nと記述します．"
  },
  {
    "objectID": "posts/2025-08-31-stdout-stderr/index.html#references",
    "href": "posts/2025-08-31-stdout-stderr/index.html#references",
    "title": "シェルスクリプトにおける標準出力・標準エラー出力",
    "section": "References",
    "text": "References\n\nUNIXの絵本, 株式会社アンク著\nLinux Crash Course - Data Streams (stdin, stdout & stderr)"
  },
  {
    "objectID": "posts/2024-12-18-secure-shell/index.html",
    "href": "posts/2024-12-18-secure-shell/index.html",
    "title": "Secure Shellの仕組み",
    "section": "",
    "text": "Definition 1 Secure Shell\n\nSSH(Secure SHell)は，ネットワークで接続された他コンピューターを遠隔操作するためのプロトコルのこと\nTCP/IPプロトコルスイートの上で動作する\n\n$ cat /etc/services | grep ^ssh \nssh     22/tcp              # SSH Remote Login Protocol\n\nSSHプロトコルには現在，SSH1とSSH2という２つのプロトコルがあります. それぞれのプロトコルには互換性はありません. 一般的には，SSH1プロトコルには脆弱性が発見されているのでSSH2を用います. Ubuntu Serverでは，デフォルトでSSH2のみが有効となっています.\n ▶  特徴\n\n強力な認証機能と暗号化により，ファイル転送やリモート操作を安全に行うことができる\nユーザーログイン時のユーザー認証に先立って，クライアントがサーバーの正当性を確認するホスト認証が毎回行われるため偽サーバーに接続することで発生する情報漏えいリスクを低減することができる\nクライアント側から ssh コマンドを用いてSSH接続を試みる場合は，接続先のコンピュータでsshd（SSH daemon：SSHのサーバプログラム）が 動作している必要がある\n\n\n\n\n\n\n\n\nNoteSSH接続の認証手順\n\n\n\n\n\n\nSSH接続を試みる際の認証は\n\nホスト認証\nユーザー認証\n\nの２段階に分かれます\n ▶  ホスト認証\n\n\n\n\n\nsequenceDiagram\n    participant A as ssh(client)\n    participant B as sshd(server)\n    A-&gt;&gt;B: ssh接続要求\n    B-&gt;&gt;A: ホスト認証鍵をクライアントへ渡す\n    A-&gt;&gt;B: ホスト認証鍵で暗号化した乱数をサーバーへ渡す\n    B-&gt;&gt;A: ホスト認証鍵の秘密鍵で復号化し，そのハッシュ値を送付\n    Note over A,B: ハッシュ値を比較し一致していれば接続成功&lt;br&gt;=ホスト認証完了\n\n\n\n\n\n\n ▶  秘密鍵公開鍵によるユーザー認証\nユーザー認証はホスト認証完了後に行われる処理となります.\n\n\n\n\n\nsequenceDiagram\n    participant A as ssh(client)\n    participant B as sshd(server)\n    A--&gt;&gt;B: 公開鍵をサーバーに設置\n    A-&gt;&gt;B: ssh接続要求\n    B-&gt;&gt;A: 公開鍵で暗号化した乱数をssh側に渡す\n    A-&gt;&gt;B: 秘密鍵で復号化し，そのハッシュ値を送付\n    Note over A,B: ハッシュ値を比較し一致していれば接続成功&lt;br&gt;=ユーザー認証完了\n\n\n\n\n\n\n\n\n\n\n\n\n\nDefinition 2 ホスト認証\n接続先が正当な相手であるのかどうかの認証のこと\n\nsshコマンドで初めてサーバーに接続するとき，サーバーから送られてきた公開鍵のフィンガープリントの値が表示される. このフィンガープリントをクライアント側で受け入れると，~/.ssh/known_hostsに以下の情報が登録されます\n\n接続先サーバーのホスト名\n接続先サーバーのIPアドレス\n接続先サーバーの公開鍵\n\n初回接続時の際は，接続先サーバーのホスト認証鍵を持っていないので,接続先ホストが登録されていない旨のWarningが表示されます. このとき，接続をこのまま続けるか？と聞かれます. yesと選択すると，SSH接続先サーバーが~/.ssh/known_hostsに登録されます.\n% ssh hogehoge@123.456.78.9\nThe authenticity of host '123.456.78.9 (123.456.78.9)' can not be established.\nECDSA key fingerprint is SHA256:ghzvH/1TBjI0wvlYiRNDJvUsiYAX/R9eip5bw6+Rv10.\nAre you sure you want to continue connecting (yes/no/[fingerprint])?\n$ yes\nWarning: Permanently added '123.456.78.9' (ECDSA) to the list of known hosts.\nPassword:\nLast login: Thu Apr 11 04:16:45 2021\n上記におけるECDSA key fingerprintSHA256:ghzvH/1TBjI0wvlYiRNDJvUsiYAX/R9eip5bw6+Rv10，の意味はSHA256で公開鍵をハッシュ化すると ghzvH/1TBjI0wvlYiRNDJvUsiYAX/R9eip5bw6+Rv10というフィンガープリントが発行されることを指しています.\n一度接続するとクライアントの known_hosts というファイルにサーバーの公開鍵が保存されるので，初回接続以降は自動的に認証が行われるため警告が表示されなくなります.\n ▶  WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED! \n目的外のサーバーに接続している場合やサーバーの公開鍵が変わっている場合，警告が表示されます.一般的にはホストキーの変更は滅多に行わなれないため、許可済みのサーバーに接続した際、 WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED! のような警告が出た場合は注意する必要があります.\n% ssh ubuntu@12.3.4.56\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n\n\n@@\nIT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!\nSomeone could be eavesdropping on you right now (man-in-the-middle attack)!\nIt is also possible that a host key has just been changed.\nThe fingerprint for the ECDSA key sent by the remote host is\nSHA256:tfZBzQ16o7O7SH6u4ixBmL061Sxz8DOo1cFZ9oMuGjE.\nPlease contact your system administrator.\nAdd correct host key in /home/hogehoge/.ssh/known_hosts to get rid of this message.\nOffending ECDSA key in /home/hogehoge/.ssh/known_hosts:4\n  remove with:\n  ssh-keygen -f \"/home/hogehoge/.ssh/known_hosts\" -R \"12.3.4.56\"\nECDSA host key for 12.3.4.56 has changed and you have requested strict checking.\nHost key verification failed.\n\n\n\nホスト認証後に実施されるユーザー認証は，デフォルトでは，公開鍵認証，パスワード認証の順に実施されます. 公開鍵認証を行うには予めクライアントの公開鍵を接続先サーバーに登録する必要があります.\n ▶  公開鍵の置き場所\n公開鍵によるユーザー認証を行うにはクライアントが作成した秘密鍵/公開鍵キーペアのうち，後者をサーバー側にコピーする必要があります. 一般的には\n\n~/.ssh/authorized_keysファイルに登録する\n~/.ssh/authorized_keys以外のファイルに保存したい場合は，サーバー側の設定ファイルsshd_configで明示的に参照ファイルを指定する\n\n\nExample 1 : sshd_config設定 \netc/ssh/sshd_config にて AuthorizedKeysFile フィールドに\nAuthorizedKeysFile     .ssh/authorized_keys .ssh/authorized_keys2\nと設定することで .ssh/authorized_keys，.ssh/authorized_keys2 の２つを公開鍵読み込みファイルとして認識させることができます"
  },
  {
    "objectID": "posts/2024-12-18-secure-shell/index.html#sshの仕組み",
    "href": "posts/2024-12-18-secure-shell/index.html#sshの仕組み",
    "title": "Secure Shellの仕組み",
    "section": "",
    "text": "Definition 1 Secure Shell\n\nSSH(Secure SHell)は，ネットワークで接続された他コンピューターを遠隔操作するためのプロトコルのこと\nTCP/IPプロトコルスイートの上で動作する\n\n$ cat /etc/services | grep ^ssh \nssh     22/tcp              # SSH Remote Login Protocol\n\nSSHプロトコルには現在，SSH1とSSH2という２つのプロトコルがあります. それぞれのプロトコルには互換性はありません. 一般的には，SSH1プロトコルには脆弱性が発見されているのでSSH2を用います. Ubuntu Serverでは，デフォルトでSSH2のみが有効となっています.\n ▶  特徴\n\n強力な認証機能と暗号化により，ファイル転送やリモート操作を安全に行うことができる\nユーザーログイン時のユーザー認証に先立って，クライアントがサーバーの正当性を確認するホスト認証が毎回行われるため偽サーバーに接続することで発生する情報漏えいリスクを低減することができる\nクライアント側から ssh コマンドを用いてSSH接続を試みる場合は，接続先のコンピュータでsshd（SSH daemon：SSHのサーバプログラム）が 動作している必要がある\n\n\n\n\n\n\n\n\nNoteSSH接続の認証手順\n\n\n\n\n\n\nSSH接続を試みる際の認証は\n\nホスト認証\nユーザー認証\n\nの２段階に分かれます\n ▶  ホスト認証\n\n\n\n\n\nsequenceDiagram\n    participant A as ssh(client)\n    participant B as sshd(server)\n    A-&gt;&gt;B: ssh接続要求\n    B-&gt;&gt;A: ホスト認証鍵をクライアントへ渡す\n    A-&gt;&gt;B: ホスト認証鍵で暗号化した乱数をサーバーへ渡す\n    B-&gt;&gt;A: ホスト認証鍵の秘密鍵で復号化し，そのハッシュ値を送付\n    Note over A,B: ハッシュ値を比較し一致していれば接続成功&lt;br&gt;=ホスト認証完了\n\n\n\n\n\n\n ▶  秘密鍵公開鍵によるユーザー認証\nユーザー認証はホスト認証完了後に行われる処理となります.\n\n\n\n\n\nsequenceDiagram\n    participant A as ssh(client)\n    participant B as sshd(server)\n    A--&gt;&gt;B: 公開鍵をサーバーに設置\n    A-&gt;&gt;B: ssh接続要求\n    B-&gt;&gt;A: 公開鍵で暗号化した乱数をssh側に渡す\n    A-&gt;&gt;B: 秘密鍵で復号化し，そのハッシュ値を送付\n    Note over A,B: ハッシュ値を比較し一致していれば接続成功&lt;br&gt;=ユーザー認証完了\n\n\n\n\n\n\n\n\n\n\n\n\n\nDefinition 2 ホスト認証\n接続先が正当な相手であるのかどうかの認証のこと\n\nsshコマンドで初めてサーバーに接続するとき，サーバーから送られてきた公開鍵のフィンガープリントの値が表示される. このフィンガープリントをクライアント側で受け入れると，~/.ssh/known_hostsに以下の情報が登録されます\n\n接続先サーバーのホスト名\n接続先サーバーのIPアドレス\n接続先サーバーの公開鍵\n\n初回接続時の際は，接続先サーバーのホスト認証鍵を持っていないので,接続先ホストが登録されていない旨のWarningが表示されます. このとき，接続をこのまま続けるか？と聞かれます. yesと選択すると，SSH接続先サーバーが~/.ssh/known_hostsに登録されます.\n% ssh hogehoge@123.456.78.9\nThe authenticity of host '123.456.78.9 (123.456.78.9)' can not be established.\nECDSA key fingerprint is SHA256:ghzvH/1TBjI0wvlYiRNDJvUsiYAX/R9eip5bw6+Rv10.\nAre you sure you want to continue connecting (yes/no/[fingerprint])?\n$ yes\nWarning: Permanently added '123.456.78.9' (ECDSA) to the list of known hosts.\nPassword:\nLast login: Thu Apr 11 04:16:45 2021\n上記におけるECDSA key fingerprintSHA256:ghzvH/1TBjI0wvlYiRNDJvUsiYAX/R9eip5bw6+Rv10，の意味はSHA256で公開鍵をハッシュ化すると ghzvH/1TBjI0wvlYiRNDJvUsiYAX/R9eip5bw6+Rv10というフィンガープリントが発行されることを指しています.\n一度接続するとクライアントの known_hosts というファイルにサーバーの公開鍵が保存されるので，初回接続以降は自動的に認証が行われるため警告が表示されなくなります.\n ▶  WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED! \n目的外のサーバーに接続している場合やサーバーの公開鍵が変わっている場合，警告が表示されます.一般的にはホストキーの変更は滅多に行わなれないため、許可済みのサーバーに接続した際、 WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED! のような警告が出た場合は注意する必要があります.\n% ssh ubuntu@12.3.4.56\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n\n\n@@\nIT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!\nSomeone could be eavesdropping on you right now (man-in-the-middle attack)!\nIt is also possible that a host key has just been changed.\nThe fingerprint for the ECDSA key sent by the remote host is\nSHA256:tfZBzQ16o7O7SH6u4ixBmL061Sxz8DOo1cFZ9oMuGjE.\nPlease contact your system administrator.\nAdd correct host key in /home/hogehoge/.ssh/known_hosts to get rid of this message.\nOffending ECDSA key in /home/hogehoge/.ssh/known_hosts:4\n  remove with:\n  ssh-keygen -f \"/home/hogehoge/.ssh/known_hosts\" -R \"12.3.4.56\"\nECDSA host key for 12.3.4.56 has changed and you have requested strict checking.\nHost key verification failed.\n\n\n\nホスト認証後に実施されるユーザー認証は，デフォルトでは，公開鍵認証，パスワード認証の順に実施されます. 公開鍵認証を行うには予めクライアントの公開鍵を接続先サーバーに登録する必要があります.\n ▶  公開鍵の置き場所\n公開鍵によるユーザー認証を行うにはクライアントが作成した秘密鍵/公開鍵キーペアのうち，後者をサーバー側にコピーする必要があります. 一般的には\n\n~/.ssh/authorized_keysファイルに登録する\n~/.ssh/authorized_keys以外のファイルに保存したい場合は，サーバー側の設定ファイルsshd_configで明示的に参照ファイルを指定する\n\n\nExample 1 : sshd_config設定 \netc/ssh/sshd_config にて AuthorizedKeysFile フィールドに\nAuthorizedKeysFile     .ssh/authorized_keys .ssh/authorized_keys2\nと設定することで .ssh/authorized_keys，.ssh/authorized_keys2 の２つを公開鍵読み込みファイルとして認識させることができます"
  },
  {
    "objectID": "posts/2024-12-18-secure-shell/index.html#ssh-コマンドの実践",
    "href": "posts/2024-12-18-secure-shell/index.html#ssh-コマンドの実践",
    "title": "Secure Shellの仕組み",
    "section": "ssh コマンドの実践",
    "text": "ssh コマンドの実践\n\n\n\n\n\n\nNotesshコマンド\n\n\n\nSSHを使ってサーバーに接続するには，以下のようにsshコマンドを使います. 終了する場合は，exit，または Ctrl + Dを入力します.\n% ssh [option] &lt;username&gt;@&lt;hostname&gt;\n\n\n\n\n\n\n\nOption\n説明\n\n\n\n\n-p ポート番号\n接続に使用するポート番号を指定する\n\n\n-l ユーザー名\n接続に使用するユーザー名を指定する\n\n\n-i IDファイル\n接続に使用する公開鍵ファイルを指定する\n\n\n-f\nコマンドを実行する際にsshをバックグラウンドにする（Xアプリケーションを実行する際に使用）\n\n\n-F 設定ファイル\n設定ファイルを指定する\n\n\n\n\n\n ▶  接続先情報の設定ファイル: ~/.ssh/config\nsshコマンド実行時のオプションを~/.ssh/configで登録することができます.\nHost DEDEDE\n  HostName 100.21.209.82\n  User kirby_MBP\n  Port 1000\n  IdentityFile ~/.ssh/my_id_rsa\n  LocalForward 9999 localhost:9999\nと設定すると以下のコマンドは同じ挙動になります\n% ssh DEDEDE\n% ssh kirby_MBP@100.21.209.82 -p 1000 -i ~/.ssh/my_id_rsa -L 9999:localhost:9999\n\nssh-keygenコマンドによる認証鍵生成\n% ssh-keygen [option]\n\n\n\n\n\n\n\nOption\n説明\n\n\n\n\n-t タイプ\n暗号化タイプの指定\n\n\n-l\n鍵のフィンガープリントを表示する\n\n\n-f ファイル名\n鍵ファイルを指定する（生成または読み出すファイルを指定）\n\n\n-R ホスト名\n指定したホスト情報をknwon_hostsファイルから削除する\n\n\n-C コメント\nコメントを指定する（デフォルトは「ユーザー名@ホスト名」。「-C ““」でコメントを削除）\n\n\n\n暗号化アルゴリズムの種類\n\n\n\n\n\n\n\nSSH version\nssh-keygenコマンド\n\n\n\n\nSSH1 RSA\nssh-keygen -t rsa1\n\n\nSSH2 DSA\nssh-keygen -t dsa\n\n\nSSH2 RSA\nssh-keygen -t rsa\n\n\nSSH2 ECDSA\nssh-keygen -t ecdsa\n\n\nSSH2 ED25519\nssh-keygen -t ed25519\n\n\n\n\n\n\n\n\n\nTipED25519のススメ\n\n\n\nGitHubやGitLabのドキュメントを確認すると，ED25519の使用が推奨されています.\nGitLabより引用すると\n\nThe book Practical Cryptography With Go suggests that ED25519 keys are more secure and performant than RSA keys. OpenSSH 6.5 introduced ED25519 SSH keys in 2014，and they should be available on most operating systems.\n\nED25519は以下のような特徴があります\n\n楕円曲線を用いた暗号\nRSAやDSAの鍵長の約半分以下で同等のセキュリティ強度が得られる\n鍵長が短いので，暗号化/復号化の計算を高速に行える\n\n従って，以下のコマンドで鍵を生成するようにしてください.\n% ssh-keygen -t e\n\n\n鍵の生成\nssh-keygenコマンドを使うと\n\n鍵ファイル名の指定（そのままEnterを入力するとデフォルトのファイル名となる）\nパスフレーズの入力（特別な理由がない限り設定する）\n\nが求められます. 特段の事情がない限り個人的には設定する方針としています. なお生成される公開鍵には，デフォルトではユーザ名とホスト名がコメントとして記載されています(以下の例ではhoge@foofoo)\n% ssh-keygen -t ed25519                                           \nGenerating public/private ed25519 key pair.\nEnter file in which to save the key (/home/hogehoge/.ssh/id_ed25519): hogehoge_ed25519\nEnter passphrase (empty for no passphrase): \nEnter same passphrase again: \nYour identification has been saved in hogehoge_ed25519\nYour public key has been saved in hogehoge_ed25519.pub\nThe key fingerprint is:\nSHA256:MnM1r0IqwugnLCTEnSHjuPoTk7mdmSMExw+r5cOkrwQ hoge@foofoo\nThe key's randomart image is:\n+--[ED25519 256]--+\n|@+%.  o  o       |\n|.o.Eo *  + S     |\n|. o..oo +        |\n|@+%.  o  o       |\n| .oo=.= S =      |\n|   ..B o + +     |\n|    = * . o .    |\n| o++o            |\n|+B==.. ....      |\n+----[SHA256]-----+\n秘密鍵の作成後，誤って内容が書き換わってしまうリスクを抑えるため，Permissionを400に設定しときます:\n% sudo chmod 400 id_ed25519\n\n\nssh-copy-idコマンド: 接続先ホストへの公開鍵登録\n鍵ペア作成後，公開鍵を接続先ホストへ登録する必要あります. この時使われるコマンドが ssh-copy-idコマンドです. なお，初回登録時点では接続先ホストではパスワード認証によるログインが許可されている必要があります.\n\nExample 2 : ssh-copy-idコマンド \n以下のコマンドで接続先サーバーの.ssh/authorized_keysに公開鍵を追記することができます\n% ssh-copy-id [-p ポート番号] -i 公開鍵ファイル名 USERNAME@$HOST\n\n# 以下のコマンドと同義\n# cat 公開鍵ファイル名 \\\n#  | ssh -p ポート番号 USERNAME@$HOST \\\n#  \"mkdir -p ~/.ssh; cat &gt;&gt; ~/.ssh/authorized_keys\"\n\n.ssh/authorized_keysファイルが存在しなくても，自動的に作成してくれます\nこのコマンド実施時には接続先ホストのパスワード入力が求められます.\n登録後はOpenSSHサーバーの設定を変更し，パスワード認証を無効にすることが推奨されます.\n\n\n\n\n\nsshpass コマンド\n\nsshpass(noninteractive ssh password provider)とは，sshコマンドでSSH接続を試みる際に要求されるログインパスワードを 事前に指定した方法でコマンドプロンプトへ渡し，簡単にSSH接続を実現するCLI機能のこと\nsshpass -p &lt;password&gt; ssh &lt;usename@&gt;接続先ホスト という形で実行するとシステムユーザーによるpsコマンドで パスワードがバレてしまうというリスクがあるので，便利さの一方，セキュリティリスクがある点について留意が必要\n\nインストール方法\n% sudo apt install sshpass ## Ubuntu\nMacだと以下のようなメッセージで怒られます.\n#Error: No available formula or cask with the name \"sshpass\".\n#We won't add sshpass because it makes it too easy for novice SSH users to\n#ruin SSH's security.\nそれでもインストールしたい場合は，ソースから直接以下のような方法でインストールします:\n% wget http://sourceforge.net/projects/sshpass/files/latest/download -O sshpass.tar.gz\n% tar -xvf sshpass.tar.gz\n% cd sshpass-1.08\n% ./configure\n% sudo make install \n% which sshpass ##pathが通っているか確認\n ▶  sshpassコマンドの利用方法\nヘルプコマンドで利用方法を確認してみます:\n% sshpass -h\nUsage: sshpass [-f|-d|-p|-e] [-hV] command parameters\n   -f filename   Take password to use from file\n   -d number     Use number as file descriptor for getting password\n   -p password   Provide password as argument (security unwise)\n   -e            Password is passed as env-var \"SSHPASS\"\n   With no parameters - password will be taken from stdin\n\n   -P prompt     Which string should sshpass search for to detect a password prompt\n   -v            Be verbose about what you're doing\n   -h            Show help (this screen)\n   -V            Print version information\nAt most one of -f，-d，-p or -e should be used\n% sshpass -p '&lt;passphrase&gt;' ssh username@host \nという形で利用することもできますが，psコマンドでpassphraseがダダ漏れになってしまうので\n% sshpass -f &lt;configfilepath&gt; ssh username@host\nまたは，-eオプションを指定することで環境変数SSHPASSを参照することができるので\n% export SSHPASS='my_pass_here'\n% echo $SSHPASS\n% sshpass -e ssh username@host \n\n\nscp コマンド: ホストとクライアント間のファイル転送\n% scp [オプション] コピー元 コピー先 \nコピー元，コピー先はそれぞれのPATHを入力しますがリモート側/ローカル側の書式例は以下です:\n\nリモートサーバー側: username@hostname：PATH\nローカルクライアント側:PATH\n\n\n\n\n\n\n\n\nOption\n説明\n\n\n\n\n-i 秘密鍵ファイル\nRSAまたはDSA認証の秘密鍵ファイルを指定する\n\n\n-P ポート番号\nポート番号を指定する\n\n\n-p\nコピー元ファイルとディレクトリの更新時間、アクセス時間、パーミッションを保持したまま転送する場合\n\n\n-r\nディレクトリ内を再帰的にコピーする\n\n\n\n ▶  ローカルからリモートホストにファイル/ディレクトリをコピー\n## ファイルのコピー\n% scp ~/tmp/file1 user@192.168.10.1:/home/user/tmp/ \n\n## ディレクトリのコピー\n% scp -r ~/tmp user1@192.168.10.1:/home/user/tmp\n\n## sshpassとの組合せ\n% sshpass -f passwordFile scp ~/tmp/file1 user@192.168.10.1:/home/user/tmp/ \n ▶  リモートホストからローカルにファイル/ディレクトリをコピー\n## ファイルのコピー\n% scp user@192.168.10.1:/home/user/file1 ~/tmp\n \n## ディレクトリのコピー\n% scp -r user@192.168.10.1:/home/user/tmp ~/tmp\n \n## 複数のファイルを、{}で囲んで「,」で区切り指定しコピーする例\n% scp user@192.168.10.1:/home/user/{file1,file2,file3} ~/tmp\n ▶  リモートホストから別のリモートホストにファイル/ディレクトリをコピー\n% scp user1@192.168.10.1:/home/user/tmp/file1 user2@192.168.10.2:/home/user/tmp/"
  },
  {
    "objectID": "posts/2024-12-18-secure-shell/index.html#appendix-tcpとudpの比較表",
    "href": "posts/2024-12-18-secure-shell/index.html#appendix-tcpとudpの比較表",
    "title": "Secure Shellの仕組み",
    "section": "Appendix: TCPとUDPの比較表",
    "text": "Appendix: TCPとUDPの比較表\n\n\n\n\n\n\n\n\n\n特徴\nTCP\nUDP\n\n\n\n\nOSI参照モデル\nトランスポート層\nトランスポート層\n\n\n接続形式\nコネクション型\nコネクションレス型\n\n\n信頼性\n高い\n低い\n\n\n順序保証\nあり\nなし\n\n\n再送制御\nあり\nなし\n\n\n軽量さ\n遅い（オーバーヘッドあり）\n速い\n\n\n用途例\nSSH, HTTP, FTP\nDNS, VoIP, 動画配信, NTP, DHCP\n\n\n\n\nTCPの特徴\n\nTransmission Control Protocol\nコネクションを確立し，確立した通信路で転送を行う\n受信側でパケットの喪失を検知すると，送信側は喪失パケットの再送を行う\n受信パケットを正しい順番で並び替える（パケットのシーケンス制御）\n受信データのエラー訂正機能あり\n\nUDPの直腸\n\nUser Datagram Protocol\nコネクションを確立しない\nTCPのような，喪失パケットの再送・シーケンス制御・エラー訂正機能はない（→その分，オーバーヘッドはない）\n\n\nExample 3 (/etc/services から http で始まるサービス名を抽出) \n$ cat /etc/services | grep ^http\nhttp        80/tcp      www     # WorldWideWeb HTTP\nhttps       443/tcp             # http protocol over TLS/SSL\nhttps       443/udp             # HTTP/3\nhttp-alt    8080/tcp    webcache    # WWW caching service"
  },
  {
    "objectID": "posts/2025-07-30-POSIX-File-end-with-newline/index.html",
    "href": "posts/2025-07-30-POSIX-File-end-with-newline/index.html",
    "title": "なぜテキストファイルは改行で終わるべきなのか？",
    "section": "",
    "text": "Definition 1 3.195 Incomplete Line\n\nA sequence of one or more non-&lt;newline&gt; characters at the end of the file.\n\n\n\nDefinition 2 3.206 Line\n\nA sequence of zero or more non-&lt;newline&gt; characters plus a terminating &lt;newline&gt; character.\nLineとは，1つ以上の &lt;newline&gt; 文字以外の文字と，行末の &lt;newline&gt; 文字によって成り立つ\n\n\n多くのUNIX系のツールは Definition 2 に基づいており，改行文字で終わらない「行」は Definition 1 のように「行」とはみなされません．\nEditorと改行\n\n\n\n\n\n\n\nエディタ\n末尾の改行の挙動\n\n\n\n\nVS Code\n設定次第で自動追加 (files.insertFinalNewline)\n\n\nVim\nデフォルトで改行追加（:set nofixeol で抑制可）\n\n\nEmacs\nデフォルトで改行追加（require-final-newline 変数）\n\n\n\n\n\ncat でファイルを結合する場合，改行で終わるファイル (a.txt と c.txt) と改行で終わらないファイル (b.txt) では，結合時の挙動が異なります．\nまず，改行ありと改行なしの.txtファイルを生成します\n改行ありファイルの生成\n\nBashZsh\n\n\n#!/bin/bash\n\nwords=(foo bar baz)\nfiles=(a b c)\n\nfor i in \"${!words[@]}\"; do\n  echo \"${words[i]}\" &gt; \"${files[i]}.txt\"\ndone\n\n\n#!/bin/zsh\n\nwords=(foo bar baz)\nfiles=(a b c)\n\nfor i in {1..${#words[@]}}; do\n  echo \"${words[i]}\" &gt; \"${files[i]}.txt\"\ndone\n\n\n\n改行なしファイルの生成\n\nBashZsh\n\n\n#!/bin/bash\n\nwords=(foo bar baz)\nfiles=(a b c)\n\nfor i in \"${!words[@]}\"; do\n  printf \"%s\" \"${words[i]}\" &gt; \"${files[i]}_without_newline.txt\"\ndone\n\n\n#!/bin/zsh\n\nwords=(foo bar baz)\nfiles=(a b c)\n\nfor i in {1..${#words[@]}}; do\n  printf \"%s\" \"${words[i]}\" &gt; \"${files[i]}_without_newline.txt\"\ndone\n\n\n\nつぎに catコマンドで結合をしてみます．\ncat コマンドで結合\n\n改行ありファイル改行なしファイル\n\n\n% cat {a,b,c}.txt\nfoo\nbar\nbaz\n\n\n% cat {a,b,c}_without_newline.txt      \nfoobarbaz% \n\n\n\n\n\n\n\nDefinition 3 wc コマンドマニュアル\n\nA line is defined as a string of characters delimited by a &lt;newline&gt; character.\n\n\nwcコマンドは &lt;newline&gt; の数で行数を数えています．実際に\n## 改行なし\n$ echo -n \"Line not ending in a new line\" | wc -l\n0\n\n## 改行あり\n$ echo \"Line ending with a new line\" | wc -l\n1\n\nExample 1 結合ファイルとwcコマンド\n\n改行ありファイル改行なしファイル\n\n\n% cat {a,b,c}.txt | wc -l\n3\n\n\n% cat {a,b,c}_without_newline.txt | wc -l\n0"
  },
  {
    "objectID": "posts/2025-07-30-POSIX-File-end-with-newline/index.html#posix標準の考え方",
    "href": "posts/2025-07-30-POSIX-File-end-with-newline/index.html#posix標準の考え方",
    "title": "なぜテキストファイルは改行で終わるべきなのか？",
    "section": "",
    "text": "Definition 1 3.195 Incomplete Line\n\nA sequence of one or more non-&lt;newline&gt; characters at the end of the file.\n\n\n\nDefinition 2 3.206 Line\n\nA sequence of zero or more non-&lt;newline&gt; characters plus a terminating &lt;newline&gt; character.\nLineとは，1つ以上の &lt;newline&gt; 文字以外の文字と，行末の &lt;newline&gt; 文字によって成り立つ\n\n\n多くのUNIX系のツールは Definition 2 に基づいており，改行文字で終わらない「行」は Definition 1 のように「行」とはみなされません．\nEditorと改行\n\n\n\n\n\n\n\nエディタ\n末尾の改行の挙動\n\n\n\n\nVS Code\n設定次第で自動追加 (files.insertFinalNewline)\n\n\nVim\nデフォルトで改行追加（:set nofixeol で抑制可）\n\n\nEmacs\nデフォルトで改行追加（require-final-newline 変数）\n\n\n\n\n\ncat でファイルを結合する場合，改行で終わるファイル (a.txt と c.txt) と改行で終わらないファイル (b.txt) では，結合時の挙動が異なります．\nまず，改行ありと改行なしの.txtファイルを生成します\n改行ありファイルの生成\n\nBashZsh\n\n\n#!/bin/bash\n\nwords=(foo bar baz)\nfiles=(a b c)\n\nfor i in \"${!words[@]}\"; do\n  echo \"${words[i]}\" &gt; \"${files[i]}.txt\"\ndone\n\n\n#!/bin/zsh\n\nwords=(foo bar baz)\nfiles=(a b c)\n\nfor i in {1..${#words[@]}}; do\n  echo \"${words[i]}\" &gt; \"${files[i]}.txt\"\ndone\n\n\n\n改行なしファイルの生成\n\nBashZsh\n\n\n#!/bin/bash\n\nwords=(foo bar baz)\nfiles=(a b c)\n\nfor i in \"${!words[@]}\"; do\n  printf \"%s\" \"${words[i]}\" &gt; \"${files[i]}_without_newline.txt\"\ndone\n\n\n#!/bin/zsh\n\nwords=(foo bar baz)\nfiles=(a b c)\n\nfor i in {1..${#words[@]}}; do\n  printf \"%s\" \"${words[i]}\" &gt; \"${files[i]}_without_newline.txt\"\ndone\n\n\n\nつぎに catコマンドで結合をしてみます．\ncat コマンドで結合\n\n改行ありファイル改行なしファイル\n\n\n% cat {a,b,c}.txt\nfoo\nbar\nbaz\n\n\n% cat {a,b,c}_without_newline.txt      \nfoobarbaz% \n\n\n\n\n\n\n\nDefinition 3 wc コマンドマニュアル\n\nA line is defined as a string of characters delimited by a &lt;newline&gt; character.\n\n\nwcコマンドは &lt;newline&gt; の数で行数を数えています．実際に\n## 改行なし\n$ echo -n \"Line not ending in a new line\" | wc -l\n0\n\n## 改行あり\n$ echo \"Line ending with a new line\" | wc -l\n1\n\nExample 1 結合ファイルとwcコマンド\n\n改行ありファイル改行なしファイル\n\n\n% cat {a,b,c}.txt | wc -l\n3\n\n\n% cat {a,b,c}_without_newline.txt | wc -l\n0"
  },
  {
    "objectID": "posts/2025-07-30-POSIX-File-end-with-newline/index.html#git-trackingテキストファイルを対象に改行有無判定スクリプト",
    "href": "posts/2025-07-30-POSIX-File-end-with-newline/index.html#git-trackingテキストファイルを対象に改行有無判定スクリプト",
    "title": "なぜテキストファイルは改行で終わるべきなのか？",
    "section": "git trackingテキストファイルを対象に改行有無判定スクリプト",
    "text": "git trackingテキストファイルを対象に改行有無判定スクリプト\n\n\n\n\n\n\nNoteスクリプト全体\n\n\n\n以下のシェルスクリプトは，バイナリファイルを除外した上で，ファイル末尾の改行の有無をチェックするスクリプトです\ngit ls-files -z | while IFS= read -r -d '' file; do\n  file --mime \"${file}\" | grep -q -e \"charset=binary\" -e \"image/svg+xml\" ||\n  tail -c1 \"${file}\" | read -r _ ||\n  echo \"Missing newline: ${file}\"\ndone\n\n\nアルゴリズム\n\\begin{algorithm}\n\\caption{Checking Files for Missing Trailing Newlines}\n\\begin{algorithmic}\n\\State file\\_list \\(\\leftarrow\\) Get all Git-tracked files with NUL delimiter\n\\ForAll{file in file\\_list}\n    \\State mime\\_info \\(\\leftarrow\\) \\texttt{file --mime file}\n    \\If{mime\\_info contains \"charset=binary\" OR \"image/svg+xml\"}\n        \\State \\textbf{continue (skip binary/SVG files)}\n    \\Else\n        \\State last\\_byte \\(\\leftarrow\\) Get final byte of file\n        \\If{last\\_byte is not newline character}\n            \\State Output \"Missing newline: file\"\n        \\EndIf\n    \\EndIf\n\\EndFor\n\\end{algorithmic}\n\\end{algorithm}\n\n\n各コマンド\n\n\n\n\n\n\n\nコマンド\n説明\n\n\n\n\ngit ls-files -z\nGitで管理されているファイルを一覧表示-zオプションで区切り文字としてNUL文字を使用（ファイル名に特殊文字が含まれる場合の安全な処理のため）\n\n\nwhile IFS= read -r -d '' file\nNUL文字を区切りとしてファイルを順次処理IFS=で空白文字の保持-rでバックスラッシュの解釈を防止-d ''：read でヌル文字区切りに対応\n\n\nfile --mime \"${file}\" | grep -q -e \"charset=binary\" -e \"image/svg+xml\" ||\nバイナリファイルとSVGファイルをスキップテキストファイルのみを処理||は「このコマンドが失敗した場合に次のコマンドを実行」を意味\n\n\ntail -c1 \"${file}\" | read -r _ ||\nファイルの最後の1バイトをチェックreadは改行があれば0，なければ1を返す\n\n\necho \"Missing newline: ${file}\"\n改行のないファイルを報告\n\n\n\n\nExample 2 カレントディレクトリ以下のファイルに対しての改行判定スクリプト\n#!/bin/bash\nfind . -maxdepth 1 -type f -print0 | while IFS= read -r -d '' file; do \n  file --mime \"${file}\" | grep -q -e \"charset=binary\" -e \"image/svg+xml\" ||\n  tail -c1 \"${file}\" | read -r _ ||\n  echo \"Missing newline: ${file}\"\ndone\n\n-print0: 各ファイル名の末尾に NUL文字 (\\0) を付けて出力\n\n\n\n\n改行なしと判定されたファイルに対して&lt;newline&gt;を付与する\n\n\n\n\n\n\nNoteシェルスクリプト\n\n\n\nfind . -maxdepth 1 -type f -print0 | while IFS= read -r -d '' file; do\n  # バイナリファイルやSVGはスキップ\n  file --mime \"$file\" | grep -q -e \"charset=binary\" -e \"image/svg+xml\" && continue\n\n  # 最後の1バイトを確認（改行がないなら）\n  if ! tail -c1 \"$file\" | read -r _; then\n      echo &gt;&gt; \"$file\"; echo \"✓ Newline added to: $file\"\n  fi\ndone\n\n\n\necho &gt;&gt; \"$file\" で&lt;newline&gt;を行末に追加"
  },
  {
    "objectID": "posts/2025-07-30-POSIX-File-end-with-newline/index.html#改行忘れの対策",
    "href": "posts/2025-07-30-POSIX-File-end-with-newline/index.html#改行忘れの対策",
    "title": "なぜテキストファイルは改行で終わるべきなのか？",
    "section": "改行忘れの対策",
    "text": "改行忘れの対策\n\n.editorconfigの用いた改行設定\nEditorConfigとは?\n\nコードスタイル（インデントや改行コードなど）を統一するための設定ファイルの仕組み\n異なるエディタ・OS間でのコードスタイルを統一させたいときに便利なツール\n\nEditorConfigによる改行設定例\n\n\n\n\n\n\n\n\n\nプロパティ名\n内容\n例\n\n\n\n\nindent_style\nインデントの種類（space または tab）\nindent_style = space\n\n\nindent_size\nインデントの幅\nindent_size = 4\n\n\nend_of_line\n改行コード（lf/crlf/cr）\nend_of_line = lf\n\n\ncharset\n文字コード\ncharset = utf-8\n\n\ntrim_trailing_whitespace\n行末の空白を削除するか\ntrim_trailing_whitespace = true\n\n\ninsert_final_newline\n最終行の末尾に改行を追加するか\ninsert_final_newline = true\n\n\n\n\n# .editorconfig\n\n# このファイルが設定のルートであることを示す\nroot = true\n\n# すべてのファイルに適用\n[*]\nindent_style = space\nindent_size = 4\nend_of_line = lf\ncharset = utf-8\ntrim_trailing_whitespace = true\ninsert_final_newline = true\n\n\nVSCodeでの改行設定\nsettings.jsonで以下の項目を追加します\n{\n  // Editor Settings\n  \"files.insertFinalNewline\": true,\n  \"notebook.insertFinalNewline\": true\n}\n\n\n\n\n\n\n\n\n設定キー\n意味\n\n\n\n\n\"files.insertFinalNewline\": true\nファイル保存時に、末尾に改行を自動で追加します（通常の .txt, .js, .py などすべて対象）\n\n\n\"notebook.insertFinalNewline\": true\nJupyter Notebook（.ipynb）などのノートブック形式のファイルにおいて、セル内のソースに末尾改行を追加する設定（拡張機能依存）"
  },
  {
    "objectID": "posts/2025-07-30-POSIX-File-end-with-newline/index.html#appendix-改行コードの種類",
    "href": "posts/2025-07-30-POSIX-File-end-with-newline/index.html#appendix-改行コードの種類",
    "title": "なぜテキストファイルは改行で終わるべきなのか？",
    "section": "Appendix: 改行コードの種類",
    "text": "Appendix: 改行コードの種類\n\n\n\n\n\n\n\n\n\n\n\n\n改行コード\n記号\n名称\n主なOS\nバイナリ表現\n説明\n\n\n\n\nLF\n\\n\nLine Feed（行送り）\nLinux / macOS（Unix系）\n0x0A\n行末で「次の行の先頭」に移動\n\n\nCRLF\n\\r\\n\nCarriage Return + Line Feed\nWindows\n0x0D 0x0A\n行頭に戻りつつ次の行へ（古いタイプライタ由来）\n\n\nCR\n\\r\nCarriage Return（復帰）\n古いMac OS（〜OS9）\n0x0D\n行頭に戻るだけ（現在はほぼ使われない）\n\n\n\n\n歴史的背景\nタイプライターの動きと対応させると改行には３つの考え方がありました\n\nLF は紙を上に移動させ (水平方向の位置は変わらない)\nCR は「キャリッジ」を戻して，次の入力文字が紙の左端の同じ行に表示\nCR+LF は両方を実行し，新しい行の入力準備"
  },
  {
    "objectID": "posts/2025-07-30-POSIX-File-end-with-newline/index.html#references",
    "href": "posts/2025-07-30-POSIX-File-end-with-newline/index.html#references",
    "title": "なぜテキストファイルは改行で終わるべきなのか？",
    "section": "References",
    "text": "References\n\nPOSIX standard\nEditorConfig"
  },
  {
    "objectID": "posts/2025-11-11-vscode-shortcut-for-git-rebase-message/index.html",
    "href": "posts/2025-11-11-vscode-shortcut-for-git-rebase-message/index.html",
    "title": "自分用VSCodeショートカットシート: Git Rebase Message",
    "section": "",
    "text": "{\n  // Git Rebase Message\n  {\n    \"key\": \"ctrl+enter\",\n    \"command\": \"runCommands\",\n    \"args\": {\n      \"commands\": [\n        \"workbench.action.files.save\",\n        \"workbench.action.closeActiveEditor\"\n      ]\n    },\n    \"when\": \"editorTextFocus && !editorReadonly && editorLangId == 'git-rebase'\"\n  },\n}\n技術スペック\n\n\n\n\n\n\n\n\n項目\n内容\n\n\n\n\n目的\nGit rebase 用メッセージ編集画面で，Ctrl+Enter により「保存＋エディタを閉じる」操作を自動化する\n\n\nキー割り当て\nctrl+enter\n\n\nコマンド\nrunCommands（複数コマンドの連続実行）\n\n\n実行コマンド列\n1. workbench.action.files.save（ファイル保存）2. workbench.action.closeActiveEditor（エディタを閉じる）\n\n\n動作条件\neditorTextFocus && !editorReadonly && editorLangId == 'git-rebase'＝ 編集可能な Git rebase メッセージ編集中のみ有効\n\n\n適用範囲\n言語モードが git-rebase のファイル（通常 .git/rebase-merge/git-rebase-todo）\n\n\n\n\n\n\nwhen条件\n\n\n\n\n\n\n\n\n条件\n意味\n\n\n\n\neditorTextFocus\nテキストエディタにフォーカスがある（＝テキスト入力できる状態）\n\n\n!editorReadonly\nエディタが読み取り専用でない（＝編集可能）\n\n\neditorLangId == 'git-rebase'\n開いているファイルの言語モードが \"git-rebase\"（＝Git rebase メッセージ編集画面）"
  },
  {
    "objectID": "posts/2025-11-11-vscode-shortcut-for-git-rebase-message/index.html#設定内容の全体像",
    "href": "posts/2025-11-11-vscode-shortcut-for-git-rebase-message/index.html#設定内容の全体像",
    "title": "自分用VSCodeショートカットシート: Git Rebase Message",
    "section": "",
    "text": "{\n  // Git Rebase Message\n  {\n    \"key\": \"ctrl+enter\",\n    \"command\": \"runCommands\",\n    \"args\": {\n      \"commands\": [\n        \"workbench.action.files.save\",\n        \"workbench.action.closeActiveEditor\"\n      ]\n    },\n    \"when\": \"editorTextFocus && !editorReadonly && editorLangId == 'git-rebase'\"\n  },\n}\n技術スペック\n\n\n\n\n\n\n\n\n項目\n内容\n\n\n\n\n目的\nGit rebase 用メッセージ編集画面で，Ctrl+Enter により「保存＋エディタを閉じる」操作を自動化する\n\n\nキー割り当て\nctrl+enter\n\n\nコマンド\nrunCommands（複数コマンドの連続実行）\n\n\n実行コマンド列\n1. workbench.action.files.save（ファイル保存）2. workbench.action.closeActiveEditor（エディタを閉じる）\n\n\n動作条件\neditorTextFocus && !editorReadonly && editorLangId == 'git-rebase'＝ 編集可能な Git rebase メッセージ編集中のみ有効\n\n\n適用範囲\n言語モードが git-rebase のファイル（通常 .git/rebase-merge/git-rebase-todo）\n\n\n\n\n\n\nwhen条件\n\n\n\n\n\n\n\n\n条件\n意味\n\n\n\n\neditorTextFocus\nテキストエディタにフォーカスがある（＝テキスト入力できる状態）\n\n\n!editorReadonly\nエディタが読み取り専用でない（＝編集可能）\n\n\neditorLangId == 'git-rebase'\n開いているファイルの言語モードが \"git-rebase\"（＝Git rebase メッセージ編集画面）"
  },
  {
    "objectID": "posts/2025-11-11-vscode-shortcut-for-git-rebase-message/index.html#appendix-vscodeでのmultiple-commandsショートカットの設定",
    "href": "posts/2025-11-11-vscode-shortcut-for-git-rebase-message/index.html#appendix-vscodeでのmultiple-commandsショートカットの設定",
    "title": "自分用VSCodeショートカットシート: Git Rebase Message",
    "section": "Appendix: VSCodeでのmultiple Commandsショートカットの設定",
    "text": "Appendix: VSCodeでのmultiple Commandsショートカットの設定\nVScodeでは \"command\": \"runCommands\", を設定することで，複数のコマンドを順番に実行するように設定できます．\n\nExample 1 (引数なしで複数のコマンドを実行) \n\n現在の行を下にコピー\n現在の行をコメント化\nコピーした行にカーソルを移動\n\nという手順を実行するショートカットの場合，以下のように keybindings.json を設定します\n\n\n\nExample 2 (引数付コマンドの実行) \n  {\n    \"key\": \"ctrl+meta+l\",\n    \"command\": \"runCommands\",\n    \"args\": {\n      \"commands\": [\n        {\n          \"command\": \"workbench.action.terminal.focus\"\n        },\n        {\n          \"command\": \"workbench.action.terminal.sendSequence\",\n          \"args\": {\n            \"text\": \"git lastdiff ${file}\\u000D\"\n          }\n        }\n      ]\n    },\n    \"when\": \"editorFocus\"\n  },\n\n\n\n\n\n\n\n\n項目\n説明\n\n\n\n\n\"key\": \"ctrl+meta+l\"\nこのショートカットを押したときに動作\n\n\nworkbench.action.terminal.focus\nターミナルにフォーカスを移す\n\n\nworkbench.action.terminal.sendSequence\nターミナルに文字列を送信（\\u000D は Enter キー）\n\n\n\"when\": \"editorFocus\"\nエディタにフォーカスがあるときのみ有効\n\n\n\n\n\n\n\nExample 3 (複数の引数を渡したい場合) \n{\n  \"key\": \"ctrl+shift+e\",\n  \"command\": \"runCommands\",\n  \"args\": {\n    \"commands\": [\n      {\n        // command invoked with 2 arguments: vscode.executeCommand(\"myCommand\", \"arg1\", \"arg2\")\n        \"command\": \"myCommand\",\n        \"args\": [\"arg1\", \"arg2\"]\n      }\n    ]\n  }\n}"
  },
  {
    "objectID": "posts/2025-11-11-vscode-shortcut-for-git-rebase-message/index.html#references",
    "href": "posts/2025-11-11-vscode-shortcut-for-git-rebase-message/index.html#references",
    "title": "自分用VSCodeショートカットシート: Git Rebase Message",
    "section": "References",
    "text": "References\n\nKeyboard shortcuts for Visual Studio Code &gt; Running multiple commands"
  },
  {
    "objectID": "posts/2025-08-27-bias-variance-tradeoff/index.html",
    "href": "posts/2025-08-27-bias-variance-tradeoff/index.html",
    "title": "Bias-Variance Tradeoff",
    "section": "",
    "text": "何かしらのパラメータ \\(\\theta\\) の推定量の性質を考えるとき，基本的には推定誤差\n\\[\n\\hat\\theta - \\theta\n\\]\nの分布についてまず考えます．この評価手法の１例としてRMSEが挙げられます．\n\\[\n\\operatorname{RMSE} = \\sqrt{\\mathbb E_{\\pmb\\theta}[(\\hat\\theta - \\theta)^2]}\n\\]\nRMSEの単位は \\(\\theta\\) の単位と同じなので，誤差のスケールを直感的に理解しやすいというメリットがあります．ただし，推定量の性質を考えるときはMSEのほうが取り回しが良いときが多いのでMSEの次に考えます．\n\nDefinition 1 MSE\n\n\\[\n\\begin{align}\n\\operatorname{MSE}\n  &= \\mathbb E_{\\pmb\\theta}[(\\hat\\theta - \\theta)^2] \\\\\n  &= \\mathbb E_{\\pmb\\theta}[(\\hat\\theta - \\mathbb E_{\\pmb\\theta}[\\hat\\theta] + \\mathbb E_{\\pmb\\theta}[\\hat\\theta] - \\theta)^2] \\\\\n  &= \\mathbb E_{\\pmb\\theta}[(\\hat\\theta - \\mathbb E_{\\pmb\\theta}[\\hat\\theta])^2] + \\mathbb E_{\\pmb\\theta}[(\\mathbb E_{\\pmb\\theta}[\\hat\\theta] - \\theta)^2] + 2\\mathbb E_{\\pmb\\theta}[(\\hat\\theta - \\mathbb E_{\\pmb\\theta}[\\hat\\theta])(\\mathbb E_{\\pmb\\theta}[\\hat\\theta] - \\theta)] \\\\\n  &= \\mathbb E_{\\pmb\\theta}[(\\hat\\theta - \\mathbb E_{\\pmb\\theta}[\\hat\\theta])^2] + (\\mathbb E_{\\pmb\\theta}[\\hat\\theta] - \\theta)^2 \\\\\n  &= \\operatorname{Variance} + \\operatorname{Bias}^2\n\\end{align}\n\\]\n\n\n上記の定義よりMSEは以下のように分解されます\n\\[\n\\operatorname{MSE} = \\operatorname{Variance} + \\operatorname{Bias}^2\n\\]\n\nExample 1 \n\\(\\{X_1, \\cdots, X_n\\}\\) がなにかしらの分布 \\(D(\\mu, \\sigma)\\) からのi.i.dサンプルだとします．なお，\\(\\mu\\neq 0\\), \\(\\mathbb E[X_i^4] &lt; \\infty\\) とします．\n\\(\\sigma^2\\) の推定量の候補として\n\\[\n\\sigma^2 = \\mathbb E[X^2] - \\mathbb E[X]^2\n\\]\nであるので，\n\\[\n\\begin{align}\n\\overline{X^2} &= \\frac{1}{n}\\sum_{i=1}^n X_i^2\\\\\n\\overline{X} &= \\frac{1}{n}\\sum_{i=1}^n X_i\\\\\n\\hat\\sigma^2 &= \\overline{X^2} - \\overline{X}^2\n\\end{align}\n\\]\nこのとき，\n\\[\n\\begin{align}\n\\mathbb E[(\\overline{X})^2]\n  &= \\operatorname{Var}(\\overline{X}) + (\\mathbb E[\\overline{X}])^2\\\\\n  &= \\frac{1}{n}\\sigma^2 + \\mu^2\n\\end{align}\n\\]\n\\[\n\\begin{align}\n\\mathbb E[\\overline{X^2}]\n  &= \\frac{1}{n}\\sum_{i=1}^n\\mathbb E[X_i^2]\\\\\n  &= \\sigma^2 + \\mu^2\n\\end{align}\n\\]\n従って，\\(\\hat\\sigma^2\\) のBiasは\n\\[\n\\begin{align}\n\\mathbb E[\\hat\\sigma^2] - \\sigma^2\n  &= \\mathbb E[\\overline{X^2}] - \\mathbb E[(\\overline{X})^2] - \\sigma^2\\\\\n  &= \\sigma^2 + \\mu^2 - \\frac{1}{n}\\sigma^2 - \\mu^2 \\sigma^2\\\\\n  &= - \\frac{1}{n}\\sigma^2\n\\end{align}\n\\]\n一方，\\(\\hat\\sigma^2\\) のVarianceは，Delta methodを用いた漸近近似により\n\\[\n\\begin{align}\n\\operatorname{Var}(\\hat\\sigma^2)\n  &= \\operatorname{Var}(\\overline{X^2}) + \\operatorname{Var}(\\overline{X}^2)\\\\\n  &\\approx  \\frac{1}{n}\\operatorname{Var}(X_i^2) + (2\\mu)^2\\frac{\\sigma^2}{n}\\\\\n  &= \\mathcal{O}(n^{-1})\n\\end{align}\n\\]\n\nRemark 1. \nLarge Samplesの場合は，\n\n\\(\\operatorname{Variance}\\) は \\(1/n\\) の速さで小さくなる\n\\(\\operatorname{Bias}^2\\) は \\(1/n^2\\) の速さで小さくなる\n\n以上より \\(\\operatorname{MSE}\\) を最小化したい場合はvarianceの方を小さくするのが有効であることがわかる．\n\n\n\n\nExample 2 MSEの比較\n\\[\n\\begin{align}\n\\{X_1, \\cdots, X_n\\} \\overset{\\mathrm{iid}}{\\sim} N(\\mu, \\sigma^2) \\label{eq-exm}\n\\end{align}\n\\]\nとしたとき，\\(\\sigma^2\\) のunbiased estimatorとして\n\\[\nS^2 = \\frac{1}{n-1}\\sum_{i=1}^n (X_i - \\overline{X})^2 \\label{eq-exm-2}\n\\]\nが考えられます．このとき，かんたんな計算により Example 1 の推定量との関係として\n\\[\nS^2 = \\frac{n}{n-1}\\hat\\sigma^2\n\\]\n\\(\\eqref{eq-exm}\\) と \\(\\eqref{eq-exm-2}\\) より\n\\[\n(n-1)\\frac{S^2}{\\sigma^2} \\sim \\operatorname{\\chi^2}(n-1)\n\\]\n従って，\n\\[\n\\operatorname{Var}(S^2)=\\frac{2}{n-1}\\sigma^4\n\\]\n\\(\\operatorname{MSE}(S^2)\\) と \\(\\operatorname{MSE}(\\hat\\sigma^2)\\) を比較すると，\n\\[\n\\begin{align}\n\\operatorname{MSE}(\\hat\\sigma^2)\n  &= \\mathbb E[(\\hat\\sigma^2 - \\sigma^2)^2]\\\\\n  &= \\frac{2(n-1)}{n^2}\\sigma^4 + \\frac{1}{n^2}\\sigma^4\\\\\n  &= \\frac{2n-1}{n^2}\\sigma^4\\\\\n  &&lt; \\frac{2}{n-1}\\sigma^4\\\\\n  &= \\operatorname{Var}(S^2)\\\\\n  &= \\operatorname{MSE}(S^2)\n\\end{align}\n\\]"
  },
  {
    "objectID": "posts/2025-08-27-bias-variance-tradeoff/index.html#統計的推測とbias-variance-tradeoff",
    "href": "posts/2025-08-27-bias-variance-tradeoff/index.html#統計的推測とbias-variance-tradeoff",
    "title": "Bias-Variance Tradeoff",
    "section": "",
    "text": "何かしらのパラメータ \\(\\theta\\) の推定量の性質を考えるとき，基本的には推定誤差\n\\[\n\\hat\\theta - \\theta\n\\]\nの分布についてまず考えます．この評価手法の１例としてRMSEが挙げられます．\n\\[\n\\operatorname{RMSE} = \\sqrt{\\mathbb E_{\\pmb\\theta}[(\\hat\\theta - \\theta)^2]}\n\\]\nRMSEの単位は \\(\\theta\\) の単位と同じなので，誤差のスケールを直感的に理解しやすいというメリットがあります．ただし，推定量の性質を考えるときはMSEのほうが取り回しが良いときが多いのでMSEの次に考えます．\n\nDefinition 1 MSE\n\n\\[\n\\begin{align}\n\\operatorname{MSE}\n  &= \\mathbb E_{\\pmb\\theta}[(\\hat\\theta - \\theta)^2] \\\\\n  &= \\mathbb E_{\\pmb\\theta}[(\\hat\\theta - \\mathbb E_{\\pmb\\theta}[\\hat\\theta] + \\mathbb E_{\\pmb\\theta}[\\hat\\theta] - \\theta)^2] \\\\\n  &= \\mathbb E_{\\pmb\\theta}[(\\hat\\theta - \\mathbb E_{\\pmb\\theta}[\\hat\\theta])^2] + \\mathbb E_{\\pmb\\theta}[(\\mathbb E_{\\pmb\\theta}[\\hat\\theta] - \\theta)^2] + 2\\mathbb E_{\\pmb\\theta}[(\\hat\\theta - \\mathbb E_{\\pmb\\theta}[\\hat\\theta])(\\mathbb E_{\\pmb\\theta}[\\hat\\theta] - \\theta)] \\\\\n  &= \\mathbb E_{\\pmb\\theta}[(\\hat\\theta - \\mathbb E_{\\pmb\\theta}[\\hat\\theta])^2] + (\\mathbb E_{\\pmb\\theta}[\\hat\\theta] - \\theta)^2 \\\\\n  &= \\operatorname{Variance} + \\operatorname{Bias}^2\n\\end{align}\n\\]\n\n\n上記の定義よりMSEは以下のように分解されます\n\\[\n\\operatorname{MSE} = \\operatorname{Variance} + \\operatorname{Bias}^2\n\\]\n\nExample 1 \n\\(\\{X_1, \\cdots, X_n\\}\\) がなにかしらの分布 \\(D(\\mu, \\sigma)\\) からのi.i.dサンプルだとします．なお，\\(\\mu\\neq 0\\), \\(\\mathbb E[X_i^4] &lt; \\infty\\) とします．\n\\(\\sigma^2\\) の推定量の候補として\n\\[\n\\sigma^2 = \\mathbb E[X^2] - \\mathbb E[X]^2\n\\]\nであるので，\n\\[\n\\begin{align}\n\\overline{X^2} &= \\frac{1}{n}\\sum_{i=1}^n X_i^2\\\\\n\\overline{X} &= \\frac{1}{n}\\sum_{i=1}^n X_i\\\\\n\\hat\\sigma^2 &= \\overline{X^2} - \\overline{X}^2\n\\end{align}\n\\]\nこのとき，\n\\[\n\\begin{align}\n\\mathbb E[(\\overline{X})^2]\n  &= \\operatorname{Var}(\\overline{X}) + (\\mathbb E[\\overline{X}])^2\\\\\n  &= \\frac{1}{n}\\sigma^2 + \\mu^2\n\\end{align}\n\\]\n\\[\n\\begin{align}\n\\mathbb E[\\overline{X^2}]\n  &= \\frac{1}{n}\\sum_{i=1}^n\\mathbb E[X_i^2]\\\\\n  &= \\sigma^2 + \\mu^2\n\\end{align}\n\\]\n従って，\\(\\hat\\sigma^2\\) のBiasは\n\\[\n\\begin{align}\n\\mathbb E[\\hat\\sigma^2] - \\sigma^2\n  &= \\mathbb E[\\overline{X^2}] - \\mathbb E[(\\overline{X})^2] - \\sigma^2\\\\\n  &= \\sigma^2 + \\mu^2 - \\frac{1}{n}\\sigma^2 - \\mu^2 \\sigma^2\\\\\n  &= - \\frac{1}{n}\\sigma^2\n\\end{align}\n\\]\n一方，\\(\\hat\\sigma^2\\) のVarianceは，Delta methodを用いた漸近近似により\n\\[\n\\begin{align}\n\\operatorname{Var}(\\hat\\sigma^2)\n  &= \\operatorname{Var}(\\overline{X^2}) + \\operatorname{Var}(\\overline{X}^2)\\\\\n  &\\approx  \\frac{1}{n}\\operatorname{Var}(X_i^2) + (2\\mu)^2\\frac{\\sigma^2}{n}\\\\\n  &= \\mathcal{O}(n^{-1})\n\\end{align}\n\\]\n\nRemark 1. \nLarge Samplesの場合は，\n\n\\(\\operatorname{Variance}\\) は \\(1/n\\) の速さで小さくなる\n\\(\\operatorname{Bias}^2\\) は \\(1/n^2\\) の速さで小さくなる\n\n以上より \\(\\operatorname{MSE}\\) を最小化したい場合はvarianceの方を小さくするのが有効であることがわかる．\n\n\n\n\nExample 2 MSEの比較\n\\[\n\\begin{align}\n\\{X_1, \\cdots, X_n\\} \\overset{\\mathrm{iid}}{\\sim} N(\\mu, \\sigma^2) \\label{eq-exm}\n\\end{align}\n\\]\nとしたとき，\\(\\sigma^2\\) のunbiased estimatorとして\n\\[\nS^2 = \\frac{1}{n-1}\\sum_{i=1}^n (X_i - \\overline{X})^2 \\label{eq-exm-2}\n\\]\nが考えられます．このとき，かんたんな計算により Example 1 の推定量との関係として\n\\[\nS^2 = \\frac{n}{n-1}\\hat\\sigma^2\n\\]\n\\(\\eqref{eq-exm}\\) と \\(\\eqref{eq-exm-2}\\) より\n\\[\n(n-1)\\frac{S^2}{\\sigma^2} \\sim \\operatorname{\\chi^2}(n-1)\n\\]\n従って，\n\\[\n\\operatorname{Var}(S^2)=\\frac{2}{n-1}\\sigma^4\n\\]\n\\(\\operatorname{MSE}(S^2)\\) と \\(\\operatorname{MSE}(\\hat\\sigma^2)\\) を比較すると，\n\\[\n\\begin{align}\n\\operatorname{MSE}(\\hat\\sigma^2)\n  &= \\mathbb E[(\\hat\\sigma^2 - \\sigma^2)^2]\\\\\n  &= \\frac{2(n-1)}{n^2}\\sigma^4 + \\frac{1}{n^2}\\sigma^4\\\\\n  &= \\frac{2n-1}{n^2}\\sigma^4\\\\\n  &&lt; \\frac{2}{n-1}\\sigma^4\\\\\n  &= \\operatorname{Var}(S^2)\\\\\n  &= \\operatorname{MSE}(S^2)\n\\end{align}\n\\]"
  },
  {
    "objectID": "posts/2025-08-27-bias-variance-tradeoff/index.html#cef-decomposition-property",
    "href": "posts/2025-08-27-bias-variance-tradeoff/index.html#cef-decomposition-property",
    "title": "Bias-Variance Tradeoff",
    "section": "CEF Decomposition Property",
    "text": "CEF Decomposition Property\n\nTheorem 1 CEF Decomposition Property\n\\[\nY_i = \\mathbb E[Y_i|X_i] + \\epsilon_i\n\\]\n\n\n\\(\\mathbb E[\\epsilon_i | X_i] = 0\\): \\(\\epsilon_i\\) is mean independent of \\(X_i\\)\n\\(\\epsilon_i\\) is uncorrelated with any function of \\(X_i\\)\n\n\n\n\n\n\n\n\n\nNoteProof (i)\n\n\n\n\n\n\\[\n\\begin{align}\n\\mathbb E[\\epsilon_i | X_i]\n  &= \\mathbb E[Y_i - \\mathbb E[Y_i|X_i]|X_i]\\\\[3pt]\n  &= \\mathbb E[Y_i|X_i] - \\mathbb E[Y_i|X_i]\\\\[3pt]\n  &= 0\n\\end{align}\n\\]\n\n\n\n\n\n\n\n\n\nNoteProof (ii)\n\n\n\n\n\n\\(b(X_i)\\) を \\(X_i\\) についての任意の関数とするとき\n\\[\n\\begin{align}\n\\mathbb E[b(X_i)\\epsilon]\n  &= \\mathbb E[\\mathbb E[b(X_i)\\epsilon | X_i]]\\\\\n  &= \\mathbb E[b(X_i)\\mathbb E[\\epsilon | X_i]]\\\\\n  &= 0\n\\end{align}\n\\]\n従って，\\(X_i\\) についての任意の関数と \\(\\epsilon_i\\) は無相関(uncorrelated, orthogonal)であることがわかる．\n\n\n\n\nTheorem 2 CEFとMSE\n\\(m(X_i)\\) を \\(X_i\\) の関数とするとき，\n\\[\n\\mathbb E[Y_i | X_i]\n  = \\underset{m(X_i)}{\\arg\\min}\\mathbb E[(Y_i - m(X_i))^2]\n\\]\nつまり，\\(\\mathbb E[Y_i | X_i]\\) は \\(X_i\\) で条件づけた \\(Y_i\\) の予測関数についてのMinimum Mean Squared Error(MMSE) である．\n\n\n\n\n\n\n\nNoteProof\n\n\n\n\n\n\n\\[\n\\begin{align}\n(Y_i - m(X_i))^2\n  &= (Y_i - \\mathbb E[Y_i | X_i] + \\mathbb E[Y_i | X_i] - m(X_i))^2\\\\\n  &= (Y_i - \\mathbb E[Y_i | X_i])^2 + 2(Y_i - \\mathbb E[Y_i | X_i])(\\mathbb E[Y_i | X_i] - m(X_i))^2 + (\\mathbb E[Y_i | X_i] - m(X_i))^2\\\\\n  &= \\epsilon^2 + 2\\epsilon(\\mathbb E[Y_i | X_i] - m(X_i)) + (\\mathbb E[Y_i | X_i] - m(X_i))^2\n\\end{align}\n\\]\n\n期待値を取ると\n\n\\[\n\\mathbb E[(Y_i - m(X_i))^2] = \\mathbb E[\\epsilon_i^2] + \\mathbb E[(\\mathbb E[Y_i | X_i] - m(X_i))^2]\n\\]\n\n従って，\n\\[\nE[Y_i | X_i] = m(X_i)\n\\]\nのときMSEの意味で \\(E[Y_i | X_i]\\) が最小化関数であることがわかる．"
  },
  {
    "objectID": "posts/2025-06-14-pressure-enthalpy-chart/index.html",
    "href": "posts/2025-06-14-pressure-enthalpy-chart/index.html",
    "title": "PH線図: pressure-enthalpy chart",
    "section": "",
    "text": "PH線図（圧力－比エンタルピー線図）は，縦軸に圧力ｐ，横軸に比エンタルピーｈをとり， 実用上の便利さから縦軸は圧力の対数で目盛られています． 比エンタルピーは直接測定することは困難ですが，圧力と温度は測定することができるので，それらの値からPH線図をベースに比エンタルピーを計算し，冷媒の状態を把握します．\n\n\n\n\n\n\n\n\n\n用語\n意味\n図での位置\n\n\n\n\n飽和液線\n液体が蒸発を始める境界．この線の左側は「液体（サブクール液）」領域\n湿り蒸気領域の左端（青線）\n\n\n飽和蒸気線\n蒸気が凝縮を始める境界．この線の右側は「過熱蒸気（superheated vapor）」領域\n湿り蒸気領域の右端（オレンジ線）\n\n\n二相領域\n液体と蒸気が共存（沸騰 or 凝縮中）\n飽和液線と蒸気線の間\n\n\n\n\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom CoolProp.CoolProp import PropsSI  # ← インストール後に import\n\nfluid = \"R410A\"  # 任意の冷媒に変更可\npa_converter = 10**6\n\n\n# Saturation curve\nT_min = PropsSI(\"Ttriple\", fluid) + 1.0  # [K]\nT_crit = PropsSI(\"Tcrit\", fluid)  # [K]\nT_sat = np.linspace(T_min, T_crit - 1e-5, 200)\n\np_sat = PropsSI(\"P\", \"T\", T_sat, \"Q\", 0, fluid)\nh_liq = PropsSI(\"H\", \"T\", T_sat, \"Q\", 0, fluid) / 1000  # [kJ/kg]\nh_vap = PropsSI(\"H\", \"T\", T_sat, \"Q\", 1, fluid) / 1000  # [kJ/kg]\n\nplt.figure(figsize=(8, 6))\nplt.plot(h_liq, p_sat / pa_converter, label=\"Saturated Liquid\")\nplt.plot(h_vap, p_sat / pa_converter, label=\"Saturated Vapor\")\n\n# 適当な等温線（任意で）\nfor T_iso in np.linspace(T_crit - 123.5, T_crit + 60, 4):\n    p_iso = np.logspace(np.log10(p_sat.min()), np.log10(p_sat.max()), 150)\n    h_iso = PropsSI(\"H\", \"T\", T_iso, \"P\", p_iso, fluid) / 1000\n    plt.plot(\n        h_iso,\n        p_iso / pa_converter,\n        linestyle=\"--\",\n        label=f\"{T_iso - 273.15:.0f} °C Isotherm\",\n    )\n\nplt.yscale(\"log\")\nplt.xlabel(\"Enthalpy [kJ/kg]\")\nplt.ylabel(\"Pressure [MPa]\")\nplt.title(f\"Pressure–Enthalpy (p-h) Diagram for {fluid}\")\nplt.legend()\nplt.grid(True, which=\"both\", ls=\":\")\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\nFigure 1\n\n\n\n\n\n\n\n飽和蒸気と飽和液が共存している湿り蒸気状態は，温度と圧力の他に，湿り蒸気中の飽和蒸気の質量分率を指定しないと比エンタルピーの位置は定まりません．\n\nDefinition 1 乾き度\n\n湿り蒸気 1kg 中に飽和蒸気が x(kg) 含まれているとき，この湿り蒸気の乾き度は x であるという\n湿り度は，飽和液の質量分率 (1 - x) のことをいう\n\n\n\n\n\n\n\n\n\n\n\n状態\n説明\n乾き度 \\(x\\)\n\n\n\n\n過冷却液\n飽和液体よりも温度が低い状態（液体のみ）\n\\(x = 0\\)\n\n\n飽和液体\n蒸発開始直前の状態\n\\(x = 0\\)\n\n\n混合（液 + 蒸気）\n液体と蒸気が共存する状態（蒸発中），湿り蒸気\n\\(0 &lt; x &lt; 1\\)\n\n\n飽和蒸気\n蒸発終了直後の状態\n\\(x = 1\\)\n\n\n加熱蒸気\n飽和蒸気よりも高温の蒸気（完全に蒸気）\n\\(x = 1\\)\n\n\n\n\n\nCode\n# Define data arrays\nx_values = np.array([0.0, 1.0])\nkawaki_values = [0, 0.2, 1.0]\nh_vap_line = np.zeros_like(x_values)\nTC = -15\nT = TC + 273.15\n\nfor i, x in enumerate(x_values):\n    h_vap_line[i] = PropsSI(\"H\", \"T\", T, \"Q\", x, fluid) / 1000\np_sat_line = PropsSI(\"P\", \"T\", T, \"Q\", 0, fluid)\n\nplt.figure(figsize=(8, 6))\n\nfor i, kawaki in enumerate(kawaki_values):\n    plt.scatter(\n        (1 - kawaki) * h_vap_line[0] + kawaki * h_vap_line[1],\n        p_sat_line / pa_converter,\n        label=f\"h{i}\",\n    )\n\n# 飽和液～飽和蒸気を結ぶ -15 °C 等温線（破線）\nplt.plot([h_vap_line[0], h_vap_line[1]], [p_sat_line / pa_converter, p_sat_line / pa_converter],\n         linestyle='--', color='gray', label=f'{TC} °C Isotherm')\n\nplt.plot(h_liq, p_sat / pa_converter, label=\"Saturated Liquid\")\nplt.plot(h_vap, p_sat / pa_converter, label=\"Saturated Vapor\")\nplt.yscale(\"log\")\nplt.xlabel(\"Enthalpy [kJ/kg]\")\nplt.ylabel(\"Pressure [MPa]\")\nplt.legend()\nplt.grid(True, which=\"both\", ls=\":\")\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n\n\\(h_1\\) における乾き度の計算は以下\n\\[\nx = \\frac{h_1 - h_0}{h_2 - h_0}\n\\]\n\n\n\n\n\n\n\nNote熱伝達と粘性係数\n\n\n\n\n冷媒側熱伝達率はプラントル数に依存\nプラントル数は熱伝導に関する無次元の物性値であり，流体の動粘度と熱拡散係数の比です．\n\n\\[\nPr = \\frac{\\mu \\cdot C_p}{\\lambda}\n\\]\n\n\\(Pr\\): プラントル数\n\\(\\mu\\): 粘性係数 [kg/m･s]\n\\(C_p\\): 定圧比熱 [J/kg･K]\n\\(\\lambda\\): 熱伝導率 [W/m･K]\n\nそして粘性係数 \\(\\mu\\) はMcAdamsモデルを用いると\n\\[\n\\frac{1}{\\mu} = \\frac{x}{\\mu_v} + \\frac{1-x}{\\mu_l}\n\\]\n\n\\(x\\): 乾き度\n\\(v\\): ガス相\n\\(l\\): 液相\n\n\n\n\n\n\n加熱蒸気の比体積 \\(v_h\\) [m³/kg] は，加熱蒸気を理想気体と近似できる場合には理想気体の状態方程式より以下のように表すことができます\n\\[\n\\begin{align}\nv_h\n  &= \\frac{v_eT_h}{T_e}\\\\\n  &= v_e\\left(1 + \\frac{\\Delta_h}{T_e}\\right)\n\\end{align}\n\\]\n\n\\(v_e\\): 飽和蒸気線での比体積\n\\(T_h\\): 加熱蒸気の温度\n\\(\\Delta_h\\): 加熱度\n\n\n\n\n\n\n\nNote比体積と圧縮機と冷媒循環量\n\n\n\n系の冷媒循環量 \\(q_m\\) [kg/h] は熱交換量を決定する重要な要素です．そして，\\(q_m\\) は圧縮機の性能と運転条件に依存します． 容積型蒸気圧縮機は，単位時間あたり一定容積のガスを吸い込んで吐き出すものです．理論押しのけ量 \\(V_p\\) [m³/h] は\n\\[\nV_p = V_{st} \\times N_{comp} \\times 3600 \\times 10^{-6}\n\\]\n\n\\(V_{st}\\): ストロークボリューム [cm³]\n\\(N_{comp}\\): 回転 / 秒 = Hz\n\\(V_p\\): 理論ピストン押しのけ量 [m³/h]\n\nこれを質量に変換すると循環流量 \\(q_m\\) になります\n\\[\nq_m = V_p \\times \\frac{1}{v_g}\\times \\eta_v\n\\]\n\n\\(v_g\\): 吸入冷媒ガスの比容積\n\\(1/v_g\\): 密度\n\\(\\eta_v\\): 体積効率 (0.8~0.9程度)\n\n\n\n\n\n\n\nDefinition 2 臨界点(Critical Point)\n\nPH線図の，飽和液体線と飽和蒸気線の高圧・高温側の終点（接合点）を臨界点と呼ぶ\nこの点における圧力を臨界圧力，温度を臨界温度と言う\n臨界点以上では蒸発現象も液化現象もなく，液相と気相の区別はつかなくなって，相変化は存在しない\n\n\n冷凍サイクルでは冷媒ガスの液化（凝縮）の過程を必要とするので，冷媒としては臨界点（臨界温度）は 液化させるための冷却水または冷却空気の温度より著しく高いことが必要となります． Figure 1 の紫色線は臨界温度と同じ等温線を表しています．この温度よりも高い温度では冷媒を液化することはできません．\n\n\nCode\nimport pandas as pd\nref_list = ['R134a', 'R22', 'R410A', 'R717', 'R744']\n\nref_list = ['R134a', 'R22', 'R410A', 'R717', 'R744']\n\nrecords = []\nfor ref in ref_list:\n    T_c = PropsSI('Tcrit', ref)          # [K]\n    P_c = PropsSI('Pcrit', ref) / 1e6    # [MPa]\n    records.append({'Fluid': ref,\n                    'T_crit [K]': T_c,\n                    'T_crit [°C]': T_c - 273.15,\n                    'P_crit [MPa]': P_c})\n\ndf = pd.DataFrame(records)\ndf\n\n\n\n\n\n\n\n\n\n\n\nFluid\nT_crit [K]\nT_crit [°C]\nP_crit [MPa]\n\n\n\n\n0\nR134a\n374.2100\n101.0600\n4.059280\n\n\n1\nR22\n369.2950\n96.1450\n4.990000\n\n\n2\nR410A\n344.4940\n71.3440\n4.901200\n\n\n3\nR717\n405.5600\n132.4100\n11.363391\n\n\n4\nR744\n304.1282\n30.9782\n7.377300\n\n\n\n\n\n\n\nFigure 2: 冷媒の臨界温度と臨界圧力\n\n\n\n\n\n\n\n\nExercise 1 R410AのPH線図作図\n入力条件\n\n\n\n\nパラメータ\n値\n\n\n\n\n蒸発温度 \\(T_{\\text{evap}}\\)\n-15 ℃\n\n\n凝縮温度 \\(T_{\\text{cond}}\\)\n30 ℃\n\n\n過冷却度\n5 ℃\n\n\n過熱度\n5 ℃\n\n\n冷媒\nR410A\n\n\n\n\n\n\n\n\n\n\n\nNoteSolution\n\n\n\n\n\n\n\nCode\nimport CoolProp.CoolProp as CP\n\nfluid = \"R22\"\n\n# 温度設定（すべて [K] に変換）\nT_evap = -15 + 273.15  # 蒸発温度\nT_cond = 30 + 273.15  # 凝縮温度\ndT_subcool = 5  # 過冷却\ndT_superheat = 5  # 過熱\n\n# 飽和圧力（蒸発器側と凝縮器側）\nP_evap = CP.PropsSI(\n    \"P\", \"T\", T_evap, \"Q\", 1, fluid\n)  # 温度 T_evap で品質（乾き度）Q = 1 のとき(=飽和蒸気)の圧力 P\nP_cond = CP.PropsSI(\n    \"P\", \"T\", T_cond, \"Q\", 0, fluid\n)  # 温度 T_cond で品質（乾き度）Q = 0 のときの圧力 P\n\n# 状態1: 蒸発器出口（過熱蒸気）\nT1 = T_evap + dT_superheat\nh1 = CP.PropsSI(\"H\", \"T\", T1, \"P\", P_evap, fluid)\ns1 = CP.PropsSI(\"S\", \"T\", T1, \"P\", P_evap, fluid)\n\n# 状態2: 圧縮機出口（断熱圧縮）\nh2 = CP.PropsSI(\"H\", \"P\", P_cond, \"S\", s1, fluid)\nT2 = CP.PropsSI(\"T\", \"P\", P_cond, \"H\", h2, fluid)\n\n# ========= 等エントロピー線を生成 =========\n# 入口圧～出口圧まで対数刻みでサンプリング\nP_line = np.logspace(np.log10(P_evap), np.log10(P_cond), 200)  # [Pa]\nh_line = CP.PropsSI(\"H\", \"P\", P_line, \"S\", s1, fluid)  # [J/kg]\n\n# 状態3: 凝縮器出口（過冷却液）\nT3 = T_cond - dT_subcool\nh3 = CP.PropsSI(\"H\", \"T\", T3, \"P\", P_cond, fluid)\n\n# 状態4: 膨張弁出口（等エンタルピー膨張）\nh4 = h3\nT4 = CP.PropsSI(\"T\", \"P\", P_evap, \"H\", h4, fluid)\n\n# 冷凍能力（1 kgあたり）\nq_in = h1 - h4  # 蒸発器での吸熱\nw_in = h2 - h1  # 圧縮機の仕事\nq_out = h2 - h3  # 凝縮器での放熱\nCOP = q_in / w_in  # 成績係数\n\n# 結果表示\nprint(\"=== 冷凍サイクル各点の状態（単位: SI） ===\")\nprint(f\"状態1（過熱蒸気）: T={T1 - 273.15:.2f}°C, h={h1 / 1000:.2f} kJ/kg\")\nprint(f\"状態2（圧縮後）  : T={T2 - 273.15:.2f}°C, h={h2 / 1000:.2f} kJ/kg\")\nprint(f\"状態3（過冷却液）: T={T3 - 273.15:.2f}°C, h={h3 / 1000:.2f} kJ/kg\")\nprint(f\"状態4（膨張後）  : T={T4 - 273.15:.2f}°C, h={h4 / 1000:.2f} kJ/kg\")\n\nprint(\"\\n=== 性能指標 ===\")\nprint(f\"冷凍能力 q_in   : {q_in / 1000:.2f} kJ/kg\")\nprint(f\"圧縮機仕事 w_in : {w_in / 1000:.2f} kJ/kg\")\nprint(f\"COP (成績係数)  : {COP:.2f}\")\n\n# plot\nh_points = [h2 / 1e3, h3 / 1e3, h4 / 1e3, h1 / 1e3]\nP_points = [P_cond / 1e6, P_cond / 1e6, P_evap / 1e6, P_evap / 1e6]\n\nplt.figure(figsize=(8, 6))\nplt.plot(\n    h_points,\n    P_points,\n    marker=\"o\",\n    linestyle=\"-\",\n    color=\"blue\",\n    label=\"refrigeration cycle\",\n)\n\n# Add labels at each point\nfor i, (h, P) in enumerate(zip(h_points, P_points), start=1):\n    plt.text(\n        h + 1, P + 0.02, f\"{(i % 4) + 1}\", fontsize=12, color=\"black\"\n    )  # adjust offsets as needed\n\nplt.plot(h_line / 1000, P_line / 1e6, linestyle=\"-\", color=\"blue\")\nplt.xlabel(\"h [kJ/kg]\")\nplt.ylabel(\"P [MPa]\")\nplt.grid(True)\n\n# Saturation curve\nT_min = -20 + 273.15\nT_crit = 49 + 273.15  # [K]\nT_sat = np.linspace(T_min, T_crit - 1e-5, 200)\n\np_sat = PropsSI(\"P\", \"T\", T_sat, \"Q\", 0, fluid)\nh_liq = PropsSI(\"H\", \"T\", T_sat, \"Q\", 0, fluid) / 1000  # [kJ/kg]\nh_vap = PropsSI(\"H\", \"T\", T_sat, \"Q\", 1, fluid) / 1000  # [kJ/kg]\n\nplt.plot(h_liq, p_sat / pa_converter, label=\"Saturated Liquid\")\nplt.plot(h_vap, p_sat / pa_converter, label=\"Saturated Vapor\")\n\nplt.yscale(\"log\")\nplt.xlabel(\"Enthalpy [kJ/kg]\")\nplt.ylabel(\"Pressure [MPa]\")\nplt.title(f\"Pressure–Enthalpy (p-h) Diagram for {fluid}\")\nplt.legend()\nplt.grid(True, which=\"both\", ls=\":\")\nplt.tight_layout()\nplt.show()\n\n\n=== 冷凍サイクル各点の状態（単位: SI） ===\n状態1（過熱蒸気）: T=-10.00°C, h=402.57 kJ/kg\n状態2（圧縮後）  : T=58.13°C, h=438.30 kJ/kg\n状態3（過冷却液）: T=25.00°C, h=230.29 kJ/kg\n状態4（膨張後）  : T=-15.00°C, h=230.29 kJ/kg\n\n=== 性能指標 ===\n冷凍能力 q_in   : 172.28 kJ/kg\n圧縮機仕事 w_in : 35.74 kJ/kg\nCOP (成績係数)  : 4.82\n\n\n\n\n\n\n\n\n\n\n\n\n1→2: 断熱変化\n\n蒸発器を出た加熱状態の冷媒蒸気は，圧縮機に吸い込まれて等比エントロピーで可逆断熱圧縮され，高圧で加熱度の大きな加熱蒸気になって吐き出される\n\n2→3: 等圧変化\n\n圧縮機から吐き出された加熱ガスは，凝縮器での冷却作用により，等圧のもとで顕熱を放出して飽和蒸気になる\n凝縮行程が進むに連れ，凝縮の潜熱を放出して湿り蒸気になり，更に冷却されると乾き度がゼロの飽和液になる\nその後，顕熱を放出して過冷却液になる\n\n3→4: 等比エンタルピー変化\n\n膨張弁で絞り膨張される\n\n絞り膨張: 流体が弁部などの狭い通路を通過する際，流れの抵抗により圧力硬化する現象\n\n熱と仕事の出入りがないので比エンタルピーは変化せずに圧力が下がる\n飽和液線を超えると自身の熱エネルギーを蒸発の潜熱として消費し，湿り蒸気となって蒸発器に流入\n\n発生した蒸気をフラッシュ蒸気と呼ぶ\n\n膨張によって冷媒の比エンタルピーは変化しないが，比エントロピーは増大する\n\n4→1: 等圧変化\n\n冷媒は蒸発気に入り，等圧のもとで外部から熱を受け入れる\n冷媒液に潜熱が加えられ，乾き度が大きくなり，飽和蒸気となる\n更に顕熱が加えられ，加熱蒸気になり，圧縮機に吸い込まれる\n\n\n\n\n湿り蒸気領域における等温線は，単一成分冷媒では等圧線と並行ですが，非共沸混合冷媒では右下がりの勾配を持った線になります． 湿り蒸気が加熱（蒸発器内）または冷却（凝縮器内）に伴う相変化によって乾き度が変化すると，湿り蒸気中の飽和蒸気と飽和液のいずれも混合組成割合が 変わるため，等温のもとでは，飽和圧力が変化することによる．\n\n\nCode\nfluid = \"R407C\"  # 任意の冷媒に変更可\npa_converter = 10**6\n\n\ndef linear_interp_inf(x):\n    x = np.array(x)\n    mask = np.isfinite(x)  # finiteなインデックス\n    return np.interp(np.arange(len(x)), np.where(mask)[0], x[mask])\n\n\n# Saturation curve\nT_min = PropsSI(\"Ttriple\", fluid) + 1.0  # [K]\nT_crit = PropsSI(\"Tcrit\", fluid)  # [K]\nT_sat = np.linspace(T_min, T_crit - 1e-5, 200)\n\np_sat = PropsSI(\"P\", \"T\", T_sat, \"Q\", 0, fluid)\nh_liq = PropsSI(\"H\", \"T\", T_sat, \"Q\", 0, fluid) / 1000  # [kJ/kg]\nh_vap = PropsSI(\"H\", \"T\", T_sat, \"Q\", 1, fluid) / 1000  # [kJ/kg]\n\nplt.figure(figsize=(8, 6))\nplt.plot(h_liq, p_sat / pa_converter, label=\"Saturated Liquid\")\nplt.plot(h_vap, p_sat / pa_converter, label=\"Saturated Vapor\")\n\n# 適当な等温線（任意で）\nfor T_iso in np.linspace(T_crit - 123.5, T_crit + 60, 4):\n    p_iso = np.logspace(np.log10(p_sat.min()), np.log10(p_sat.max()), 150)\n    h_iso = PropsSI(\"H\", \"T\", T_iso, \"P\", p_iso, fluid) / 1000\n    h_iso = linear_interp_inf(h_iso)\n    plt.plot(\n        h_iso,\n        p_iso / pa_converter,\n        linestyle=\"-\",\n        label=f\"{T_iso - 273.15:.0f} °C Isotherm\",\n    )\n\nplt.yscale(\"log\")\nplt.xlabel(\"Enthalpy [kJ/kg]\")\nplt.ylabel(\"Pressure [MPa]\")\nplt.title(f\"Pressure–Enthalpy (p-h) Diagram for {fluid}\")\nplt.legend()\nplt.grid(True, which=\"both\", ls=\":\")\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\nFigure 3\n\n\n\n\n\n\nDefinition 3 温度勾配\nある一定の等圧線上の沸点と露点の温度が異なり，露点における温度のほうが沸点における温度よりも高くなっているとき，この等圧線上の沸点と露点との温度差を温度勾配と呼ぶ\n\n\nR404AやR410Aは0.2~0.4Kのオーダー\nR407Cは温度勾配が大きく4.5Kほど"
  },
  {
    "objectID": "posts/2025-06-14-pressure-enthalpy-chart/index.html#ph線図",
    "href": "posts/2025-06-14-pressure-enthalpy-chart/index.html#ph線図",
    "title": "PH線図: pressure-enthalpy chart",
    "section": "",
    "text": "PH線図（圧力－比エンタルピー線図）は，縦軸に圧力ｐ，横軸に比エンタルピーｈをとり， 実用上の便利さから縦軸は圧力の対数で目盛られています． 比エンタルピーは直接測定することは困難ですが，圧力と温度は測定することができるので，それらの値からPH線図をベースに比エンタルピーを計算し，冷媒の状態を把握します．\n\n\n\n\n\n\n\n\n\n用語\n意味\n図での位置\n\n\n\n\n飽和液線\n液体が蒸発を始める境界．この線の左側は「液体（サブクール液）」領域\n湿り蒸気領域の左端（青線）\n\n\n飽和蒸気線\n蒸気が凝縮を始める境界．この線の右側は「過熱蒸気（superheated vapor）」領域\n湿り蒸気領域の右端（オレンジ線）\n\n\n二相領域\n液体と蒸気が共存（沸騰 or 凝縮中）\n飽和液線と蒸気線の間\n\n\n\n\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom CoolProp.CoolProp import PropsSI  # ← インストール後に import\n\nfluid = \"R410A\"  # 任意の冷媒に変更可\npa_converter = 10**6\n\n\n# Saturation curve\nT_min = PropsSI(\"Ttriple\", fluid) + 1.0  # [K]\nT_crit = PropsSI(\"Tcrit\", fluid)  # [K]\nT_sat = np.linspace(T_min, T_crit - 1e-5, 200)\n\np_sat = PropsSI(\"P\", \"T\", T_sat, \"Q\", 0, fluid)\nh_liq = PropsSI(\"H\", \"T\", T_sat, \"Q\", 0, fluid) / 1000  # [kJ/kg]\nh_vap = PropsSI(\"H\", \"T\", T_sat, \"Q\", 1, fluid) / 1000  # [kJ/kg]\n\nplt.figure(figsize=(8, 6))\nplt.plot(h_liq, p_sat / pa_converter, label=\"Saturated Liquid\")\nplt.plot(h_vap, p_sat / pa_converter, label=\"Saturated Vapor\")\n\n# 適当な等温線（任意で）\nfor T_iso in np.linspace(T_crit - 123.5, T_crit + 60, 4):\n    p_iso = np.logspace(np.log10(p_sat.min()), np.log10(p_sat.max()), 150)\n    h_iso = PropsSI(\"H\", \"T\", T_iso, \"P\", p_iso, fluid) / 1000\n    plt.plot(\n        h_iso,\n        p_iso / pa_converter,\n        linestyle=\"--\",\n        label=f\"{T_iso - 273.15:.0f} °C Isotherm\",\n    )\n\nplt.yscale(\"log\")\nplt.xlabel(\"Enthalpy [kJ/kg]\")\nplt.ylabel(\"Pressure [MPa]\")\nplt.title(f\"Pressure–Enthalpy (p-h) Diagram for {fluid}\")\nplt.legend()\nplt.grid(True, which=\"both\", ls=\":\")\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\nFigure 1\n\n\n\n\n\n\n\n飽和蒸気と飽和液が共存している湿り蒸気状態は，温度と圧力の他に，湿り蒸気中の飽和蒸気の質量分率を指定しないと比エンタルピーの位置は定まりません．\n\nDefinition 1 乾き度\n\n湿り蒸気 1kg 中に飽和蒸気が x(kg) 含まれているとき，この湿り蒸気の乾き度は x であるという\n湿り度は，飽和液の質量分率 (1 - x) のことをいう\n\n\n\n\n\n\n\n\n\n\n\n状態\n説明\n乾き度 \\(x\\)\n\n\n\n\n過冷却液\n飽和液体よりも温度が低い状態（液体のみ）\n\\(x = 0\\)\n\n\n飽和液体\n蒸発開始直前の状態\n\\(x = 0\\)\n\n\n混合（液 + 蒸気）\n液体と蒸気が共存する状態（蒸発中），湿り蒸気\n\\(0 &lt; x &lt; 1\\)\n\n\n飽和蒸気\n蒸発終了直後の状態\n\\(x = 1\\)\n\n\n加熱蒸気\n飽和蒸気よりも高温の蒸気（完全に蒸気）\n\\(x = 1\\)\n\n\n\n\n\nCode\n# Define data arrays\nx_values = np.array([0.0, 1.0])\nkawaki_values = [0, 0.2, 1.0]\nh_vap_line = np.zeros_like(x_values)\nTC = -15\nT = TC + 273.15\n\nfor i, x in enumerate(x_values):\n    h_vap_line[i] = PropsSI(\"H\", \"T\", T, \"Q\", x, fluid) / 1000\np_sat_line = PropsSI(\"P\", \"T\", T, \"Q\", 0, fluid)\n\nplt.figure(figsize=(8, 6))\n\nfor i, kawaki in enumerate(kawaki_values):\n    plt.scatter(\n        (1 - kawaki) * h_vap_line[0] + kawaki * h_vap_line[1],\n        p_sat_line / pa_converter,\n        label=f\"h{i}\",\n    )\n\n# 飽和液～飽和蒸気を結ぶ -15 °C 等温線（破線）\nplt.plot([h_vap_line[0], h_vap_line[1]], [p_sat_line / pa_converter, p_sat_line / pa_converter],\n         linestyle='--', color='gray', label=f'{TC} °C Isotherm')\n\nplt.plot(h_liq, p_sat / pa_converter, label=\"Saturated Liquid\")\nplt.plot(h_vap, p_sat / pa_converter, label=\"Saturated Vapor\")\nplt.yscale(\"log\")\nplt.xlabel(\"Enthalpy [kJ/kg]\")\nplt.ylabel(\"Pressure [MPa]\")\nplt.legend()\nplt.grid(True, which=\"both\", ls=\":\")\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n\n\\(h_1\\) における乾き度の計算は以下\n\\[\nx = \\frac{h_1 - h_0}{h_2 - h_0}\n\\]\n\n\n\n\n\n\n\nNote熱伝達と粘性係数\n\n\n\n\n冷媒側熱伝達率はプラントル数に依存\nプラントル数は熱伝導に関する無次元の物性値であり，流体の動粘度と熱拡散係数の比です．\n\n\\[\nPr = \\frac{\\mu \\cdot C_p}{\\lambda}\n\\]\n\n\\(Pr\\): プラントル数\n\\(\\mu\\): 粘性係数 [kg/m･s]\n\\(C_p\\): 定圧比熱 [J/kg･K]\n\\(\\lambda\\): 熱伝導率 [W/m･K]\n\nそして粘性係数 \\(\\mu\\) はMcAdamsモデルを用いると\n\\[\n\\frac{1}{\\mu} = \\frac{x}{\\mu_v} + \\frac{1-x}{\\mu_l}\n\\]\n\n\\(x\\): 乾き度\n\\(v\\): ガス相\n\\(l\\): 液相\n\n\n\n\n\n\n加熱蒸気の比体積 \\(v_h\\) [m³/kg] は，加熱蒸気を理想気体と近似できる場合には理想気体の状態方程式より以下のように表すことができます\n\\[\n\\begin{align}\nv_h\n  &= \\frac{v_eT_h}{T_e}\\\\\n  &= v_e\\left(1 + \\frac{\\Delta_h}{T_e}\\right)\n\\end{align}\n\\]\n\n\\(v_e\\): 飽和蒸気線での比体積\n\\(T_h\\): 加熱蒸気の温度\n\\(\\Delta_h\\): 加熱度\n\n\n\n\n\n\n\nNote比体積と圧縮機と冷媒循環量\n\n\n\n系の冷媒循環量 \\(q_m\\) [kg/h] は熱交換量を決定する重要な要素です．そして，\\(q_m\\) は圧縮機の性能と運転条件に依存します． 容積型蒸気圧縮機は，単位時間あたり一定容積のガスを吸い込んで吐き出すものです．理論押しのけ量 \\(V_p\\) [m³/h] は\n\\[\nV_p = V_{st} \\times N_{comp} \\times 3600 \\times 10^{-6}\n\\]\n\n\\(V_{st}\\): ストロークボリューム [cm³]\n\\(N_{comp}\\): 回転 / 秒 = Hz\n\\(V_p\\): 理論ピストン押しのけ量 [m³/h]\n\nこれを質量に変換すると循環流量 \\(q_m\\) になります\n\\[\nq_m = V_p \\times \\frac{1}{v_g}\\times \\eta_v\n\\]\n\n\\(v_g\\): 吸入冷媒ガスの比容積\n\\(1/v_g\\): 密度\n\\(\\eta_v\\): 体積効率 (0.8~0.9程度)\n\n\n\n\n\n\n\nDefinition 2 臨界点(Critical Point)\n\nPH線図の，飽和液体線と飽和蒸気線の高圧・高温側の終点（接合点）を臨界点と呼ぶ\nこの点における圧力を臨界圧力，温度を臨界温度と言う\n臨界点以上では蒸発現象も液化現象もなく，液相と気相の区別はつかなくなって，相変化は存在しない\n\n\n冷凍サイクルでは冷媒ガスの液化（凝縮）の過程を必要とするので，冷媒としては臨界点（臨界温度）は 液化させるための冷却水または冷却空気の温度より著しく高いことが必要となります． Figure 1 の紫色線は臨界温度と同じ等温線を表しています．この温度よりも高い温度では冷媒を液化することはできません．\n\n\nCode\nimport pandas as pd\nref_list = ['R134a', 'R22', 'R410A', 'R717', 'R744']\n\nref_list = ['R134a', 'R22', 'R410A', 'R717', 'R744']\n\nrecords = []\nfor ref in ref_list:\n    T_c = PropsSI('Tcrit', ref)          # [K]\n    P_c = PropsSI('Pcrit', ref) / 1e6    # [MPa]\n    records.append({'Fluid': ref,\n                    'T_crit [K]': T_c,\n                    'T_crit [°C]': T_c - 273.15,\n                    'P_crit [MPa]': P_c})\n\ndf = pd.DataFrame(records)\ndf\n\n\n\n\n\n\n\n\n\n\n\nFluid\nT_crit [K]\nT_crit [°C]\nP_crit [MPa]\n\n\n\n\n0\nR134a\n374.2100\n101.0600\n4.059280\n\n\n1\nR22\n369.2950\n96.1450\n4.990000\n\n\n2\nR410A\n344.4940\n71.3440\n4.901200\n\n\n3\nR717\n405.5600\n132.4100\n11.363391\n\n\n4\nR744\n304.1282\n30.9782\n7.377300\n\n\n\n\n\n\n\nFigure 2: 冷媒の臨界温度と臨界圧力\n\n\n\n\n\n\n\n\nExercise 1 R410AのPH線図作図\n入力条件\n\n\n\n\nパラメータ\n値\n\n\n\n\n蒸発温度 \\(T_{\\text{evap}}\\)\n-15 ℃\n\n\n凝縮温度 \\(T_{\\text{cond}}\\)\n30 ℃\n\n\n過冷却度\n5 ℃\n\n\n過熱度\n5 ℃\n\n\n冷媒\nR410A\n\n\n\n\n\n\n\n\n\n\n\nNoteSolution\n\n\n\n\n\n\n\nCode\nimport CoolProp.CoolProp as CP\n\nfluid = \"R22\"\n\n# 温度設定（すべて [K] に変換）\nT_evap = -15 + 273.15  # 蒸発温度\nT_cond = 30 + 273.15  # 凝縮温度\ndT_subcool = 5  # 過冷却\ndT_superheat = 5  # 過熱\n\n# 飽和圧力（蒸発器側と凝縮器側）\nP_evap = CP.PropsSI(\n    \"P\", \"T\", T_evap, \"Q\", 1, fluid\n)  # 温度 T_evap で品質（乾き度）Q = 1 のとき(=飽和蒸気)の圧力 P\nP_cond = CP.PropsSI(\n    \"P\", \"T\", T_cond, \"Q\", 0, fluid\n)  # 温度 T_cond で品質（乾き度）Q = 0 のときの圧力 P\n\n# 状態1: 蒸発器出口（過熱蒸気）\nT1 = T_evap + dT_superheat\nh1 = CP.PropsSI(\"H\", \"T\", T1, \"P\", P_evap, fluid)\ns1 = CP.PropsSI(\"S\", \"T\", T1, \"P\", P_evap, fluid)\n\n# 状態2: 圧縮機出口（断熱圧縮）\nh2 = CP.PropsSI(\"H\", \"P\", P_cond, \"S\", s1, fluid)\nT2 = CP.PropsSI(\"T\", \"P\", P_cond, \"H\", h2, fluid)\n\n# ========= 等エントロピー線を生成 =========\n# 入口圧～出口圧まで対数刻みでサンプリング\nP_line = np.logspace(np.log10(P_evap), np.log10(P_cond), 200)  # [Pa]\nh_line = CP.PropsSI(\"H\", \"P\", P_line, \"S\", s1, fluid)  # [J/kg]\n\n# 状態3: 凝縮器出口（過冷却液）\nT3 = T_cond - dT_subcool\nh3 = CP.PropsSI(\"H\", \"T\", T3, \"P\", P_cond, fluid)\n\n# 状態4: 膨張弁出口（等エンタルピー膨張）\nh4 = h3\nT4 = CP.PropsSI(\"T\", \"P\", P_evap, \"H\", h4, fluid)\n\n# 冷凍能力（1 kgあたり）\nq_in = h1 - h4  # 蒸発器での吸熱\nw_in = h2 - h1  # 圧縮機の仕事\nq_out = h2 - h3  # 凝縮器での放熱\nCOP = q_in / w_in  # 成績係数\n\n# 結果表示\nprint(\"=== 冷凍サイクル各点の状態（単位: SI） ===\")\nprint(f\"状態1（過熱蒸気）: T={T1 - 273.15:.2f}°C, h={h1 / 1000:.2f} kJ/kg\")\nprint(f\"状態2（圧縮後）  : T={T2 - 273.15:.2f}°C, h={h2 / 1000:.2f} kJ/kg\")\nprint(f\"状態3（過冷却液）: T={T3 - 273.15:.2f}°C, h={h3 / 1000:.2f} kJ/kg\")\nprint(f\"状態4（膨張後）  : T={T4 - 273.15:.2f}°C, h={h4 / 1000:.2f} kJ/kg\")\n\nprint(\"\\n=== 性能指標 ===\")\nprint(f\"冷凍能力 q_in   : {q_in / 1000:.2f} kJ/kg\")\nprint(f\"圧縮機仕事 w_in : {w_in / 1000:.2f} kJ/kg\")\nprint(f\"COP (成績係数)  : {COP:.2f}\")\n\n# plot\nh_points = [h2 / 1e3, h3 / 1e3, h4 / 1e3, h1 / 1e3]\nP_points = [P_cond / 1e6, P_cond / 1e6, P_evap / 1e6, P_evap / 1e6]\n\nplt.figure(figsize=(8, 6))\nplt.plot(\n    h_points,\n    P_points,\n    marker=\"o\",\n    linestyle=\"-\",\n    color=\"blue\",\n    label=\"refrigeration cycle\",\n)\n\n# Add labels at each point\nfor i, (h, P) in enumerate(zip(h_points, P_points), start=1):\n    plt.text(\n        h + 1, P + 0.02, f\"{(i % 4) + 1}\", fontsize=12, color=\"black\"\n    )  # adjust offsets as needed\n\nplt.plot(h_line / 1000, P_line / 1e6, linestyle=\"-\", color=\"blue\")\nplt.xlabel(\"h [kJ/kg]\")\nplt.ylabel(\"P [MPa]\")\nplt.grid(True)\n\n# Saturation curve\nT_min = -20 + 273.15\nT_crit = 49 + 273.15  # [K]\nT_sat = np.linspace(T_min, T_crit - 1e-5, 200)\n\np_sat = PropsSI(\"P\", \"T\", T_sat, \"Q\", 0, fluid)\nh_liq = PropsSI(\"H\", \"T\", T_sat, \"Q\", 0, fluid) / 1000  # [kJ/kg]\nh_vap = PropsSI(\"H\", \"T\", T_sat, \"Q\", 1, fluid) / 1000  # [kJ/kg]\n\nplt.plot(h_liq, p_sat / pa_converter, label=\"Saturated Liquid\")\nplt.plot(h_vap, p_sat / pa_converter, label=\"Saturated Vapor\")\n\nplt.yscale(\"log\")\nplt.xlabel(\"Enthalpy [kJ/kg]\")\nplt.ylabel(\"Pressure [MPa]\")\nplt.title(f\"Pressure–Enthalpy (p-h) Diagram for {fluid}\")\nplt.legend()\nplt.grid(True, which=\"both\", ls=\":\")\nplt.tight_layout()\nplt.show()\n\n\n=== 冷凍サイクル各点の状態（単位: SI） ===\n状態1（過熱蒸気）: T=-10.00°C, h=402.57 kJ/kg\n状態2（圧縮後）  : T=58.13°C, h=438.30 kJ/kg\n状態3（過冷却液）: T=25.00°C, h=230.29 kJ/kg\n状態4（膨張後）  : T=-15.00°C, h=230.29 kJ/kg\n\n=== 性能指標 ===\n冷凍能力 q_in   : 172.28 kJ/kg\n圧縮機仕事 w_in : 35.74 kJ/kg\nCOP (成績係数)  : 4.82\n\n\n\n\n\n\n\n\n\n\n\n\n1→2: 断熱変化\n\n蒸発器を出た加熱状態の冷媒蒸気は，圧縮機に吸い込まれて等比エントロピーで可逆断熱圧縮され，高圧で加熱度の大きな加熱蒸気になって吐き出される\n\n2→3: 等圧変化\n\n圧縮機から吐き出された加熱ガスは，凝縮器での冷却作用により，等圧のもとで顕熱を放出して飽和蒸気になる\n凝縮行程が進むに連れ，凝縮の潜熱を放出して湿り蒸気になり，更に冷却されると乾き度がゼロの飽和液になる\nその後，顕熱を放出して過冷却液になる\n\n3→4: 等比エンタルピー変化\n\n膨張弁で絞り膨張される\n\n絞り膨張: 流体が弁部などの狭い通路を通過する際，流れの抵抗により圧力硬化する現象\n\n熱と仕事の出入りがないので比エンタルピーは変化せずに圧力が下がる\n飽和液線を超えると自身の熱エネルギーを蒸発の潜熱として消費し，湿り蒸気となって蒸発器に流入\n\n発生した蒸気をフラッシュ蒸気と呼ぶ\n\n膨張によって冷媒の比エンタルピーは変化しないが，比エントロピーは増大する\n\n4→1: 等圧変化\n\n冷媒は蒸発気に入り，等圧のもとで外部から熱を受け入れる\n冷媒液に潜熱が加えられ，乾き度が大きくなり，飽和蒸気となる\n更に顕熱が加えられ，加熱蒸気になり，圧縮機に吸い込まれる\n\n\n\n\n湿り蒸気領域における等温線は，単一成分冷媒では等圧線と並行ですが，非共沸混合冷媒では右下がりの勾配を持った線になります． 湿り蒸気が加熱（蒸発器内）または冷却（凝縮器内）に伴う相変化によって乾き度が変化すると，湿り蒸気中の飽和蒸気と飽和液のいずれも混合組成割合が 変わるため，等温のもとでは，飽和圧力が変化することによる．\n\n\nCode\nfluid = \"R407C\"  # 任意の冷媒に変更可\npa_converter = 10**6\n\n\ndef linear_interp_inf(x):\n    x = np.array(x)\n    mask = np.isfinite(x)  # finiteなインデックス\n    return np.interp(np.arange(len(x)), np.where(mask)[0], x[mask])\n\n\n# Saturation curve\nT_min = PropsSI(\"Ttriple\", fluid) + 1.0  # [K]\nT_crit = PropsSI(\"Tcrit\", fluid)  # [K]\nT_sat = np.linspace(T_min, T_crit - 1e-5, 200)\n\np_sat = PropsSI(\"P\", \"T\", T_sat, \"Q\", 0, fluid)\nh_liq = PropsSI(\"H\", \"T\", T_sat, \"Q\", 0, fluid) / 1000  # [kJ/kg]\nh_vap = PropsSI(\"H\", \"T\", T_sat, \"Q\", 1, fluid) / 1000  # [kJ/kg]\n\nplt.figure(figsize=(8, 6))\nplt.plot(h_liq, p_sat / pa_converter, label=\"Saturated Liquid\")\nplt.plot(h_vap, p_sat / pa_converter, label=\"Saturated Vapor\")\n\n# 適当な等温線（任意で）\nfor T_iso in np.linspace(T_crit - 123.5, T_crit + 60, 4):\n    p_iso = np.logspace(np.log10(p_sat.min()), np.log10(p_sat.max()), 150)\n    h_iso = PropsSI(\"H\", \"T\", T_iso, \"P\", p_iso, fluid) / 1000\n    h_iso = linear_interp_inf(h_iso)\n    plt.plot(\n        h_iso,\n        p_iso / pa_converter,\n        linestyle=\"-\",\n        label=f\"{T_iso - 273.15:.0f} °C Isotherm\",\n    )\n\nplt.yscale(\"log\")\nplt.xlabel(\"Enthalpy [kJ/kg]\")\nplt.ylabel(\"Pressure [MPa]\")\nplt.title(f\"Pressure–Enthalpy (p-h) Diagram for {fluid}\")\nplt.legend()\nplt.grid(True, which=\"both\", ls=\":\")\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\nFigure 3\n\n\n\n\n\n\nDefinition 3 温度勾配\nある一定の等圧線上の沸点と露点の温度が異なり，露点における温度のほうが沸点における温度よりも高くなっているとき，この等圧線上の沸点と露点との温度差を温度勾配と呼ぶ\n\n\nR404AやR410Aは0.2~0.4Kのオーダー\nR407Cは温度勾配が大きく4.5Kほど"
  },
  {
    "objectID": "posts/2025-06-14-pressure-enthalpy-chart/index.html#理解度チェック",
    "href": "posts/2025-06-14-pressure-enthalpy-chart/index.html#理解度チェック",
    "title": "PH線図: pressure-enthalpy chart",
    "section": "📘 理解度チェック",
    "text": "📘 理解度チェック\n\nExercise 2 臨界温度\n次の記述のうち正しいものはどれか？\n\n臨界点は，気体と液体の区別がなくなる状態点である．この臨界点は飽和圧力曲線の終点として表される．臨界点における温度および圧力を臨界温度および臨界圧力という．\n冷凍装置は，通常，凝縮温度を冷媒の臨界温度よりも高い温度で使用している\n\n\n\n\n\n\n\n\nNoteSolution\n\n\n\n\n\na\n\n\n\n\nExercise 3 圧縮機\n次の記述のうち正しいものはどれか？\n\n圧縮機の吸い込み蒸気の比体積を直接測定するのは困難である．そのため，吸い込み蒸気の圧力と温度を図って，それらの値からPH線図や熱力学性質表を用いて冷媒の比体積を求める\n比体積の単位は m³/kg であり，比体積が大きくなると冷媒蒸気の密度は小さくなる\n圧縮機吸込み圧力が低下すると，吸込み蒸気の比体積が大きくなるので，圧縮機駆動の軸動力は小さくなる\n\n\n\n\n\n\n\n\nNoteSolution\n\n\n\n\n\na, b, c\n\n\n\n\nExercise 4 膨張弁\n次の記述のうち正しいものはどれか？\n\n膨張弁は過冷却となった冷媒液を絞り膨張させることで，蒸発圧力まで冷媒の圧力を下げる\n膨張弁で蒸発圧力まで冷媒の圧力を下げる際，例b内は周囲との間で，熱と仕事の授受を行うことで冷媒自身の温度を下げている\n\n\n\n\n\n\n\n\nNoteSolution\n\n\n\n\n\na,"
  },
  {
    "objectID": "posts/2025-08-18-install-meld-via-flatpak/index.html",
    "href": "posts/2025-08-18-install-meld-via-flatpak/index.html",
    "title": "flatpak経由でMeldをインストール",
    "section": "",
    "text": "NoteMeldの導入\n\n\n\n\nMeldはファイル間やディレクトリ間のdiffをGUIベースで可視化してくれるツール\nLinux版のWinMergeみたいなツール\n\n\n\nGit管理されたディレクトリでは.gitconfigで設定したEditorでのgit difftoolで十分かなと考えていますが， Git管理されていないファイルをアドホックに差分比較したいときに使うツールとしてMeldの利用を考えています．\nGUI差分ツールでの利用のみなので，今回はaptではなくflatpak経由でのインストールを実行します．\n環境情報\n% lsb_release -a\nDistributor ID: Ubuntu\nDescription:    Ubuntu 24.04.3 LTS\nRelease:    24.04\nCodename:   noble\nflatpakでインストール可能なVersion\n% flatpak search Meld                                                                                       \nName       Description                        Application ID       Version       Branch       Remotes\nMeld       Compare and merge your files       org.gnome.meld       3.22.3        stable       flathub\naptでインストール可能なversion\n% apt-cache policy meld\nmeld:\n  Installed: (none)\n  Candidate: 3.22.2-1\n  Version table:\n     3.22.2-1 500\n        500 http://jp.archive.ubuntu.com/ubuntu noble/universe amd64 Packages\n        500 http://jp.archive.ubuntu.com/ubuntu noble/universe i386 Packages\nまとめ時点ではあんまりバージョン変わらない．．．"
  },
  {
    "objectID": "posts/2025-08-18-install-meld-via-flatpak/index.html#今回の方針",
    "href": "posts/2025-08-18-install-meld-via-flatpak/index.html#今回の方針",
    "title": "flatpak経由でMeldをインストール",
    "section": "",
    "text": "NoteMeldの導入\n\n\n\n\nMeldはファイル間やディレクトリ間のdiffをGUIベースで可視化してくれるツール\nLinux版のWinMergeみたいなツール\n\n\n\nGit管理されたディレクトリでは.gitconfigで設定したEditorでのgit difftoolで十分かなと考えていますが， Git管理されていないファイルをアドホックに差分比較したいときに使うツールとしてMeldの利用を考えています．\nGUI差分ツールでの利用のみなので，今回はaptではなくflatpak経由でのインストールを実行します．\n環境情報\n% lsb_release -a\nDistributor ID: Ubuntu\nDescription:    Ubuntu 24.04.3 LTS\nRelease:    24.04\nCodename:   noble\nflatpakでインストール可能なVersion\n% flatpak search Meld                                                                                       \nName       Description                        Application ID       Version       Branch       Remotes\nMeld       Compare and merge your files       org.gnome.meld       3.22.3        stable       flathub\naptでインストール可能なversion\n% apt-cache policy meld\nmeld:\n  Installed: (none)\n  Candidate: 3.22.2-1\n  Version table:\n     3.22.2-1 500\n        500 http://jp.archive.ubuntu.com/ubuntu noble/universe amd64 Packages\n        500 http://jp.archive.ubuntu.com/ubuntu noble/universe i386 Packages\nまとめ時点ではあんまりバージョン変わらない．．．"
  },
  {
    "objectID": "posts/2025-08-18-install-meld-via-flatpak/index.html#flatpak経由でのmeldインストール",
    "href": "posts/2025-08-18-install-meld-via-flatpak/index.html#flatpak経由でのmeldインストール",
    "title": "flatpak経由でMeldをインストール",
    "section": "flatpak経由でのMeldインストール",
    "text": "flatpak経由でのMeldインストール\n\nDefinition 1 ユニバーサルパッケージ\n\nLinuxディストリビューションに依存しないパッケージのこと\n依存関係は原則存在せず，必要なものはすべてパッケージの中に取り込んだ状態で提供(アプリ用の環境まるごと提供)\nサンドボックス化によるセキュリティの向上と，ディストリビューションとアプリケーションの分離の推進\nsnap や flatpak でインストール可能なパッケージがユニバーサルパッケージ\n\n\nDebianならapt, dpkg，RHEL系ならdnf, yum, prm などLinuxディストリビューションに応じてパッケージマネージャを使い分ける必要があります． なにかしらのアプリをインストールしたいとき，ユーザーはディストリビューションに応じてコマンドがありますし，アプリの開発者はディストリビューション毎に「依存関係の解決」に対応したパッケージを作る必要があります．\nLinuxユーザー，Linux用アプリ開発者が直面したこのような状況への対応作として登場したのがユニバーサルパッケージという概念です． 基本的に必要なものはすべてパッケージの中に取り込んだ状態で提供するので，Linuxカーネルとパッケージ管理システムが動いているシステムならどこでも利用可能です．\nユニバーサルパッケージのデメリット\n\n\n\n\n\n\n\n\n項目\n内容\n\n\n\n\nディスク容量\nライブラリを同梱するため，同種のライブラリが重複し容量を消費する\n\n\n起動・性能\nサンドボックスや抽象化層を経由するため，ネイティブパッケージより起動が遅い場合がある\n\n\nシステム統合性\nテーマやフォント，ファイルシステムとの統合が弱く，見た目や操作感がネイティブより不自然になることがある\n\n\n\n\n\nsnap vs flatpak\n\n\n\n\n\n\n\n\n\n観点\nSnap\nFlatpak\n\n\n\n\n依存関係と容量\n依存関係を各パッケージに同梱．重複が発生しやすく，容量効率が悪い\n依存関係を各パッケージに同梱するが，ランタイム共有とデータ重複排除（deduplication）により容量効率が良い\n\n\nセキュリティ\nサンドボックス化は可能だが必須ではない\nデフォルトでサンドボックス化され，明示的な権限許可が必要\n\n\n運営主体\nCanonical（Ubuntu開発元）が中央管理．バックエンドは事実上プロプライエタリ\nコミュニティ主体．仕様やコードはオープン\n\n\nシステム統合\nSnapごとにマウントされるため，lsblk 出力を汚す（多数のloopデバイスが見える）\nそうした副作用はない\n\n\nアップデート制御\n強制的に自動更新され，ユーザーが制御できない\nユーザーが更新のタイミングを選べる\n\n\nアプリ（バックエンド系）\nCLIツールやバックエンド系アプリなどインフラ関連をCanonicalが公式に提供\n基本はGUIデスクトップアプリ中心\n\n\n\n\n\n\nflatpak Setup and Meld Install\nStep 1: Flatpakのインストール\n% sudo apt install flatpak\nStep 2: GNOME Software pluginのインストール\nFlatpak アプリを GNOME Softwareから扱えるようにするためFlatpak用のpluginを導入します．\n# プラグイン導入\n% sudo apt install gnome-software-plugin-flatpak\nStep 3: リポジトリ登録\n初期状態ではどこのリポジトリも登録されていないので，リポジトリ登録します\n# Flathub（Flatpak のメインリポジトリ）を追加\n% flatpak remote-add --if-not-exists flathub https://flathub.org/repo/flathub.flatpakrepo\nStep 4: Restart system\nシステムの再起動を行うことで，GNOME Softwareが Flatpak への対応が完了します．\nStep 5: Meldのインストール\nCLIでインストールする場合は以下のコマンドを実行します\n% flatpak install flathub org.gnome.meld\n\n\n\n\n\n\nWarningPublisherの確認のすすめ\n\n\n\n\n\nFlatpakでGoogle chromeパッケージは提供されていますが，提供元は verified されていません．おそらく問題はないですがパッケージインストール時に確認するクセをつけましょう．\nFirefoxの方はverified されたMozillaが提供していることが確認できます\n\n\n\n\n\n\n\nchrome not verified\n\n\n\n\n\n\n\nfirefox verified\n\n\n\n\n\n\n\n\n\nflatpakの使い方\ninstall syntax\nflatpak install flathub com.github.tchx84.Flatseal\n\n\n\n\n項目\n説明\n\n\n\n\nflatpak\nfaltpak command\n\n\ninstall\nfaltpak commandへの指示コマンド\n\n\nflathub\nダウンロードパッケージの登録レポジトリ\n\n\ncom.github.tchx84.Flatseal\nパッケージ名\n\n\n\n\n\n\n\n\n\n\nNoteFlatsealパッケージ\n\n\n\n\nFlatpakパッケージのpermission管理用のツール\nGUIベースでAppごとにリソースマネジメントが可能\n\n\n\n[インストールの種類: User vs System Mode]\nデフォルトではFlatpakはアプリをsystem modeでインストールします．ユーザーAがThunderbirdをflatpakでインストールすると，同じシステムの別ユーザーもアプリを利用することができます． ユーザー専用でアプリを使用したい場合は\nflatpak --user install flathub org.mozilla.Thunderbird\nとなります．--user optionを利用してインストールしたアプリを削除するときは\nflatpak --user uninstall org.mozilla.Thunderbird\nとする必要があります．flatpak update についても同様です．\nflatpak appのconfig格納先\nhomeディレクトリ下の .var に以下にconfigファイルを含めた形で格納されています\n% ls ~/.var/app\norg.gnome.meld/\nその他コマンド\n\n\n\n\n\n\n\nコマンド\n説明\n\n\n\n\nflatpak remotes\n登録されたリポジトリリストの確認\n\n\nflatpak remote-delete &lt;repository&gt;\n登録されたリポジトリの削除\n\n\nflatpak update\nインストール済み Flatpak アプリ・ランタイムを更新する\n\n\nflatpak list\nインストール済みのすべての Flatpak を一覧表示する\n\n\nflatpak list --app\nインストール済みのアプリ（アプリケーションのみ）を一覧表示する\n\n\nflatpak history\nインストール・削除・更新などの操作履歴を確認する\n\n\nflatpak uninstall &lt;app-id&gt;\nflatpak appの削除．ただし，~/.var/app/&lt;app-id&gt; のデータは残る\n\n\nflatpak uninstall --delete-data &lt;app-id&gt;\n~/.var/app/&lt;app-id&gt; のデータとともにアプリを削除"
  },
  {
    "objectID": "posts/2025-08-18-install-meld-via-flatpak/index.html#references",
    "href": "posts/2025-08-18-install-meld-via-flatpak/index.html#references",
    "title": "flatpak経由でMeldをインストール",
    "section": "References",
    "text": "References\n\nMeld\nFlatpak Ubuntu Quick Setup\nFlatpak documentation &gt; Using Flatpak\nFlatpak Uninstallation\nFlathub &gt; Meld"
  },
  {
    "objectID": "posts/2025-07-17-mlflow-setup/index.html",
    "href": "posts/2025-07-17-mlflow-setup/index.html",
    "title": "モデル管理プラットフォームMLflowの設定",
    "section": "",
    "text": "Noteセキュリティを保ちつつローカルからリモート操作\n\n\n\n\nクライアント視点では，自分の localhost:5000 にアクセスしている体感\n実際には ssh -L によってサーバの MLflow にトンネル転送されている\n\n\n\n\n\n\n\n\n\n\n\nsequenceDiagram\n    participant ClientPC as クライアントPC&lt;br&gt;(Python)\n    participant SSH as SSHトンネル&lt;br&gt;(ポートフォワーディング)\n    participant MLflowServer as Docker上のMLflow Server&lt;br&gt;(mlflow server 起動中)\n\n    ClientPC --&gt;&gt; SSH: HTTPリクエスト&lt;br&gt;(localhost:5000 → SSHトンネル)\n    SSH --&gt;&gt; MLflowServer: HTTPリクエスト&lt;br&gt;(サーバlocalhost:5000)\n    MLflowServer --&gt;&gt; SSH: HTTPレスポンス\n    SSH --&gt;&gt; ClientPC: HTTPレスポンス\n\n\n\n\n\n\n\n\nFigure 1\n\n\n\nスコープについて\n\nArtifact StoreやBackend Storeはサーバーのストーレージ領域を使用することにします"
  },
  {
    "objectID": "posts/2025-07-17-mlflow-setup/index.html#mlflowサーバーアクセスイメージ",
    "href": "posts/2025-07-17-mlflow-setup/index.html#mlflowサーバーアクセスイメージ",
    "title": "モデル管理プラットフォームMLflowの設定",
    "section": "",
    "text": "Noteセキュリティを保ちつつローカルからリモート操作\n\n\n\n\nクライアント視点では，自分の localhost:5000 にアクセスしている体感\n実際には ssh -L によってサーバの MLflow にトンネル転送されている\n\n\n\n\n\n\n\n\n\n\n\nsequenceDiagram\n    participant ClientPC as クライアントPC&lt;br&gt;(Python)\n    participant SSH as SSHトンネル&lt;br&gt;(ポートフォワーディング)\n    participant MLflowServer as Docker上のMLflow Server&lt;br&gt;(mlflow server 起動中)\n\n    ClientPC --&gt;&gt; SSH: HTTPリクエスト&lt;br&gt;(localhost:5000 → SSHトンネル)\n    SSH --&gt;&gt; MLflowServer: HTTPリクエスト&lt;br&gt;(サーバlocalhost:5000)\n    MLflowServer --&gt;&gt; SSH: HTTPレスポンス\n    SSH --&gt;&gt; ClientPC: HTTPレスポンス\n\n\n\n\n\n\n\n\nFigure 1\n\n\n\nスコープについて\n\nArtifact StoreやBackend Storeはサーバーのストーレージ領域を使用することにします"
  },
  {
    "objectID": "posts/2025-07-17-mlflow-setup/index.html#mlflowサーバーの保存領域",
    "href": "posts/2025-07-17-mlflow-setup/index.html#mlflowサーバーの保存領域",
    "title": "モデル管理プラットフォームMLflowの設定",
    "section": "MLflowサーバーの保存領域",
    "text": "MLflowサーバーの保存領域\nログやメタデータ，ファイル成果物を保存・管理する保存領域として，Artifact store と Backend storeの２種類があります．\n\n\n\n\n\n\n\n\ngraph TB\n    A[MLflow Tracking&lt;br&gt;mlflow server] --&gt; B[Backend Store&lt;br&gt;メタデータ保存]\n    A --&gt; C[Artifact Store&lt;br&gt;成果物ファイル保存]\n\n\n\n\n\n\n\n\nFigure 2\n\n\n\n\n\n\n\n\n\n\n\n保存領域\n役割\n\n\n\n\nArtifact Store\n実験で生成された Artifacts = 成果物（モデル，画像，ログファイルなど） を保存する領域\n\n\nBackend Store\nモデルや実験やRunのメタデータ(パラメータ，Metricsなどを含む)を格納する領域\n\n\n\n\n\nArtifact Store\n\n\n保存オブジェクト例\n基本的には以下のような大容量になりがちなものを保存します\n\n学習済みモデル(model.pkl)\n学習に出力した画像やプロット(ts-plot.png)\n学習時に利用したデータ(train.parquet)\n\n\nサポートされる保存先\n\nローカルディレクトリ(例: /mlflow/mlruns)\nAmazon S3(例: s3://&lt;bucket&gt;/&lt;path&gt;)\nGoogle Cloud Storage(例: gs://&lt;bucket&gt;/&lt;path&gt;)\nAzure Blob Storage\nFTP/SFTP ServerやNFS共有ディレクトリなど\n\n\n\n\n\nBackend Store\n\n\n保存オブジェクト例\n\nModel ID\nRun ID\nStart & end time\nParameters\nMetrics\nSource file name\n\n\nサポートされる保存先\n\nデフォルトではローカルの ./mlruns ディレクトリに保存\nconfigureでデータベースを指定可能"
  },
  {
    "objectID": "posts/2025-07-17-mlflow-setup/index.html#mlflowサーバー構築手順",
    "href": "posts/2025-07-17-mlflow-setup/index.html#mlflowサーバー構築手順",
    "title": "モデル管理プラットフォームMLflowの設定",
    "section": "MLflowサーバー構築手順",
    "text": "MLflowサーバー構築手順\n\nサーバー側での公式MLflow Docker Imageのインストール\n\n最新版MLflowイメージのPull\ndocker pull ghcr.io/mlflow/mlflow:latest\n\nMLflowイメージversionの確認\ndocker run --rm ghcr.io/mlflow/mlflow:latest mlflow --version\n\nMLflowイメージの削除\ndocker rmi ghcr.io/mlflow/mlflow:latest\n\n\nDockerベースのMLflow環境の構築\n基本手順としては\n\nArtifact Storeの作成と指定(./mlruns)\nBackend Storeの作成と指定(./mlflow.db)\n\nを行います．Dockerベースで行うため，Permissionの指定には注意します．\n# MLflowのデータを保存したい任意のディレクトリに移動\ncd &lt;target-directory&gt;\n\n# tracking dataを保存するために使用する空のSQLiteデータベースファイルを作成\ntouch ./mlflow.db\n\n# Artifact（モデル，プロットなど）を保存するためのディレクトリを作成\nmkdir -p ./mlruns\n\n# MLflowデータベースファイルに読み書き権限を設定．Dockerコンテナ内でMLflowが正しく動作するために必要\nchmod 666 ./mlflow.db\n\n# MLflowの実行（run）ディレクトリに読み書き実行権限を設定．MLflowがArtifactを作成&保存可能にするため必要。\nchmod 777 ./mlruns\n\n# MLflowサーバーをDockerコンテナとして起動．--host 0.0.0.0以下はMLflowサーバーに任意のIPアドレスからポート5000でアクセス可能にするため\ndocker run -d --name mlflow-server -p 5000:5000 \\\n  -v $(pwd)/mlruns:/mlflow/mlruns \\ \n  -v $(pwd)/mlflow.db:/mlflow/mlflow.db \\ \n  ghcr.io/mlflow/mlflow:latest mlflow server \\ \n  --backend-store-uri sqlite:///mlflow/mlflow.db \\ \n  --default-artifact-root /mlflow/mlruns \\ \n  --host 0.0.0.0 --port 5000\nMLflowコンテナの停止と削除\n# 現在実行中のコンテナ mlflow-server を 停止 \ndocker stop mlflow-server \n\n# 停止された mlflow-server コンテナを 削除 \ndocker rm mlflow-server\n\n\n\n\n\n\nNote\n\n\n\n\nコンテナを削除しても，mlruns/ や mlflow.db がマウントされていれば中のデータは保持されます\n\n\n\n\n\nDocker compose fileの作成\n\nコンテナの構成・起動・管理を簡潔・再現可能にしたい\n毎回 docker runの長いスクリプトを実施したくない\n\n以上の理由から，docker-compose.ymlベースでコンテナの起動を実施します．\ndocker-compose.ymlの実装\nservices:\n  mlflow-server:\n    image: ghcr.io/mlflow/mlflow:latest\n    container_name: mlflow-server\n    ports:\n      - \"5000:5000\"\n    volumes:\n      - ./mlruns:/mlflow/mlruns\n      - ./mlflow.db:/mlflow/mlflow.db\n    command: &gt;\n      mlflow server\n      --backend-store-uri sqlite:///mlflow/mlflow.db\n      --default-artifact-root /mlflow/mlruns\n      --host 0.0.0.0\n      --port 5000\nservicesセクション\nservices:\n  mlflow-server:\n\nCompose で起動するサービスの名前を mlflow-server と指定\nあくまでコンテナ名ではなく，docker composeで管理するサービス名\n\ncontainer_nameの指定\ncontainer_name: mlflow-server\n\n起動したコンテナの名前を明示的に mlflow-server に指定\n\nポートの指定\nports:\n  - \"5000:5000\"\n\nhost-port:container-portの順番で指定\nホストのポート5000 を，コンテナのポート5000 にマッピング\nhttp://localhost:5000 でブラウザからアクセスできるようになる\n\nVolumesの指定\nvolumes:\n  - ./mlruns:/mlflow/mlruns\n  - ./mlflow.db:/mlflow/mlflow.db\n\nartifact（成果物）保存先: ./mlruns:/mlflow/mlruns\nbackend store保存先: ./mlflow.db:/mlflow/mlflow.db\n\ncommand\n\nmlflow server: MLflow Tracking Server を起動\n--backend-store-uri sqlite:///mlflow/mlflow.db: SQLite を使用\n--host 0.0.0.0: 外部アクセスを許可\n\n実行方法\n# カレントディレクトリに mlflow.db が無いなら作成しておく\ntouch mlflow.db\nchmod 666 mlflow.db  # SQLiteが読み書きできるように\n\n# コンテナ作成\ndocker compose up -d\n\n# コンテナ起動\ndocker compose start\n\n# 停止\ndocker compose stop\n\n# 削除\ndocker compose down\n\n# 稼動状況の確認\ndocker ps -f name=mlflow-server\n\n\n\n\n\n\nNoteその他の設定例\n\n\n\n本記事では紹介しませんが，さらなる設定として以下のような方針が考えられます\n\nPostgreSQL や MySQL に backend-store を切り替える\nS3 や MinIO に artifact-store を変更\nsystemd 経由で自動起動"
  },
  {
    "objectID": "posts/2025-07-17-mlflow-setup/index.html#ssh経由でのmlflowへのアクセス",
    "href": "posts/2025-07-17-mlflow-setup/index.html#ssh経由でのmlflowへのアクセス",
    "title": "モデル管理プラットフォームMLflowの設定",
    "section": "ssh経由でのMLFlowへのアクセス",
    "text": "ssh経由でのMLFlowへのアクセス\nブラウザでlocalhostアクセスするためには，SSH接続時に自動的にポートフォワーディング（ローカルフォワード） する設定が必要です．これは\nssh -L 5000:localhost:5000 user@remote\nというコマンドでも実現可能ですが，.ssh/config に以下のように記載したほうが楽に成ると判断しています．\nHost mlflowserver\n    Hostname mlserver-desktop\n    User hoshinokirby\n    ForwardAgent yes\n    RequestTTY yes \n    LocalForward 5000 localhost:5000\nこの設定のよって，ssh user@remote だけで，自動的にポートフォワーディングしてくれます．\n\nBackgroundでSSH接続\n\nbackground接続\nMLflowサーバーの ~/mlflow-playground にdocker-compose.yml があり，それを立ち上がっている状況で，backgroundでssh接続したい場合は以下のコマンドを実行します．\nssh mlflowserver -fN\n\n-fN オプション\n\n\n\n\n\n\n\n\nオプション\n動作\n\n\n\n\n-f\nSSH接続後，すぐにバックグラウンドに回る（foreground → background）\n\n\n-N\nリモートでコマンドを実行せず、シェルも起動しない（トンネル用途向け）\n\n\n-T\n疑似ターミナル（tty）を割り当てない．対話的操作が不要な非対話型コマンドの実行時に使用\n\n\n\n\n接続状況の確認\nssh コマンドがバックグラウンドでまだ動いているか確認したい場合，現在動作中の ssh 関連プロセスを表示することで確かめます．\nps aux | grep \"ssh -fN -L 5000:localhost:5000\" | grep -v grep\n\n\n\n\n\n\n\n\nコマンド部分\n意味\n\n\n\n\nps aux\n全ユーザー（a）、端末に関係なく（x）、詳細情報（u）付きで すべてのプロセスを一覧表示\n\n\ngrep \"ssh\"\nその中から 「ssh」を含む行だけを抽出\n\n\ngrep -v grep\nさらにそこから grep ssh 自体の行を除外（-vは「除外」を意味）\n\n\n\n\n該当プロセスをkillしたい場合は\n# ssh processをkill\nkill [PID]\n\n# 強制kill\nkill -9 [PID]\nとなります．または，pkillを用いて\npkill -f \"ssh mlflowserver -fT\"\n\n\n\n\n\n\n\n\n部分\n意味\n\n\n\n\npkill\n条件に合うプロセスに**終了シグナル（デフォルトは SIGTERM）**を送る\n\n\n-f\nプロセス名だけでなくコマンドライン全体を検索対象にする\n\n\n\"ssh mlflowserver -fT\"\n条件：ssh mlflowserver -fT を含むコマンドを実行しているプロセス"
  },
  {
    "objectID": "posts/2025-02-05-surveying/index.html",
    "href": "posts/2025-02-05-surveying/index.html",
    "title": "測量法における測量の分類",
    "section": "",
    "text": "測量の分類は，一般的には，\n\n測量の手法\n測量の目的\n\nによって分類され，具体的には，多角測量，水準測量，地形測量，写真測量，地図測量，GISなどがあります．一方，測量法に基づく測量の分類という観点だと，測量法では，測量を\n\n基本測量\n公共測量\n基本測量及び公共測量以外の測量\n\nの三種類に分類しています．\n\n\n\n測量法第4条 \n「基本測量」とは，すべての測量の基礎となる測量で，国土地理院の行うものをいう\n\n基本測量とは以下２つの特徴があります\n\n国土地理院が実施する測量\nすべての測量の基礎となる測量\n\n ▶  基本測量事業内容\n\n\n\n\n\n\n\n測量内容\n説明\n\n\n\n\n基準点測量\n各種測量に地球上の正確な位置と高さを与える国家基準点体系（三角点，水準点等）の整備と維持管理事業\n\n\n地殻変動観測\n準点測量を継続的に行うことにより，地殻の動きをとらえる測量事業\n\n\n地理情報の整備や２万５千分の１地形図等基本図の作成\nデジタル形式の基本図「電子国土基本図」の整備など\n\n\n\n ▶  測量標の保全\n\n測量法第22条 \n何人も，国土地理院の長の承諾を得ないで，基本測量の測量標を移転し，汚損し，その他その効用を害する行為をしてはならない．\n\n\n\n\n\n測量法第5条 \n「公共測量」とは，基本測量以外の測量で次に掲げるものをいい，建物に関する測量その他の局地的測量又は小縮尺図の調製その他の高度の精度を必要としない測量で政令で定めるものを除く．\n\nその測量の実施に要する費用の全部又は一部を国又は公共団体が負担し，又は補助して行う測量\n基本測量又は公共測量の測量成果を使用して次の事業のために実施する測量で国土交通大臣が指定したもの\n\n行政庁の許可，認可その他の処分を受けて行われる事業\nその実施に要する費用の全部又は一部について国又は公共団体の負担又は補助，貸付けその他の助成を受けて行われる事業\n\n\n\n公共測量となる測量は以下の条件すべてを満たす測量だけとなります\n\n測量経費: 測量の費用を国・公共団体が負担・補助して実施する測量\n測量の精度: 高精度な測量に限る．国土地理院が測量計画機関から提出された計画書を審査し必要な精度が得られる方法で行われているか判断\n使用する測量: 基本測量・公共測量成果を２点以上使用する測量１点以下の場合でも規模大の測量\n\n公共測量は日本で実施される測量の大部分を占めています．（source: 国土地理院）\n\n\n\n\n\npie title 測量種類別の事業費の割合\n         \"公共測量\" : 89\n         \"民間の測量\" : 20\n         \"基本測量\": 1\n\n\n\n\n\n\n\n ▶  公共測量の表示等\n\n測量法第37条 \n公共測量を実施する者は，当該測量において設置する測量標に，公共測量の測量標であること及び測量計画機関の名称を表示しなければならない．\n\n公共測量を実施する者は，関係市町村長に対して当該測量を実施するために必要な情報の提供を求めることができる．\n測量計画機関は，公共測量において永久標識を設置したときは，遅滞なく，その種類及び所在地その他国土交通省令で定める事項を国土地理院の長に通知しなければならない．\n測量計画機関は，自ら実施した公共測量の永久標識を移転し，撤去し，又は廃棄したときは，遅滞なく，その種類及び旧所在地その他国土交通省令で定める事項を国土地理院の長に通知しなければならない．\n\n\n測量法第37条2にて，公共測量を実施するにあたって，地元の事情に最も精通していると考えられる関係市町村長に情報の提供を求めることができると規定されています．都道府県知事ではなく関係市町村長であるところに注意が必要です．\n\n\n\n\n測量法第6条 \nこの法律において「基本測量及び公共測量以外の測量」とは，基本測量又は公共測量の測量成果を使用して実施する基本測量及び公共測量以外の測量（建物に関する測量その他の局地的測量又は小縮尺図の調製その他の高度の精度を必要としない測量で政令で定めるものを除く．）をいう．"
  },
  {
    "objectID": "posts/2025-02-05-surveying/index.html#測量法における測量の分類",
    "href": "posts/2025-02-05-surveying/index.html#測量法における測量の分類",
    "title": "測量法における測量の分類",
    "section": "",
    "text": "測量の分類は，一般的には，\n\n測量の手法\n測量の目的\n\nによって分類され，具体的には，多角測量，水準測量，地形測量，写真測量，地図測量，GISなどがあります．一方，測量法に基づく測量の分類という観点だと，測量法では，測量を\n\n基本測量\n公共測量\n基本測量及び公共測量以外の測量\n\nの三種類に分類しています．\n\n\n\n測量法第4条 \n「基本測量」とは，すべての測量の基礎となる測量で，国土地理院の行うものをいう\n\n基本測量とは以下２つの特徴があります\n\n国土地理院が実施する測量\nすべての測量の基礎となる測量\n\n ▶  基本測量事業内容\n\n\n\n\n\n\n\n測量内容\n説明\n\n\n\n\n基準点測量\n各種測量に地球上の正確な位置と高さを与える国家基準点体系（三角点，水準点等）の整備と維持管理事業\n\n\n地殻変動観測\n準点測量を継続的に行うことにより，地殻の動きをとらえる測量事業\n\n\n地理情報の整備や２万５千分の１地形図等基本図の作成\nデジタル形式の基本図「電子国土基本図」の整備など\n\n\n\n ▶  測量標の保全\n\n測量法第22条 \n何人も，国土地理院の長の承諾を得ないで，基本測量の測量標を移転し，汚損し，その他その効用を害する行為をしてはならない．\n\n\n\n\n\n測量法第5条 \n「公共測量」とは，基本測量以外の測量で次に掲げるものをいい，建物に関する測量その他の局地的測量又は小縮尺図の調製その他の高度の精度を必要としない測量で政令で定めるものを除く．\n\nその測量の実施に要する費用の全部又は一部を国又は公共団体が負担し，又は補助して行う測量\n基本測量又は公共測量の測量成果を使用して次の事業のために実施する測量で国土交通大臣が指定したもの\n\n行政庁の許可，認可その他の処分を受けて行われる事業\nその実施に要する費用の全部又は一部について国又は公共団体の負担又は補助，貸付けその他の助成を受けて行われる事業\n\n\n\n公共測量となる測量は以下の条件すべてを満たす測量だけとなります\n\n測量経費: 測量の費用を国・公共団体が負担・補助して実施する測量\n測量の精度: 高精度な測量に限る．国土地理院が測量計画機関から提出された計画書を審査し必要な精度が得られる方法で行われているか判断\n使用する測量: 基本測量・公共測量成果を２点以上使用する測量１点以下の場合でも規模大の測量\n\n公共測量は日本で実施される測量の大部分を占めています．（source: 国土地理院）\n\n\n\n\n\npie title 測量種類別の事業費の割合\n         \"公共測量\" : 89\n         \"民間の測量\" : 20\n         \"基本測量\": 1\n\n\n\n\n\n\n\n ▶  公共測量の表示等\n\n測量法第37条 \n公共測量を実施する者は，当該測量において設置する測量標に，公共測量の測量標であること及び測量計画機関の名称を表示しなければならない．\n\n公共測量を実施する者は，関係市町村長に対して当該測量を実施するために必要な情報の提供を求めることができる．\n測量計画機関は，公共測量において永久標識を設置したときは，遅滞なく，その種類及び所在地その他国土交通省令で定める事項を国土地理院の長に通知しなければならない．\n測量計画機関は，自ら実施した公共測量の永久標識を移転し，撤去し，又は廃棄したときは，遅滞なく，その種類及び旧所在地その他国土交通省令で定める事項を国土地理院の長に通知しなければならない．\n\n\n測量法第37条2にて，公共測量を実施するにあたって，地元の事情に最も精通していると考えられる関係市町村長に情報の提供を求めることができると規定されています．都道府県知事ではなく関係市町村長であるところに注意が必要です．\n\n\n\n\n測量法第6条 \nこの法律において「基本測量及び公共測量以外の測量」とは，基本測量又は公共測量の測量成果を使用して実施する基本測量及び公共測量以外の測量（建物に関する測量その他の局地的測量又は小縮尺図の調製その他の高度の精度を必要としない測量で政令で定めるものを除く．）をいう．"
  },
  {
    "objectID": "posts/2025-02-05-surveying/index.html#測量法と測量の基準",
    "href": "posts/2025-02-05-surveying/index.html#測量法と測量の基準",
    "title": "測量法における測量の分類",
    "section": "測量法と測量の基準",
    "text": "測量法と測量の基準\n\n測量法第11条1項 \n位置は，地理学的経緯度及び平均海面からの高さで表示する． ただし，場合により，直角座標及び平均海面からの高さ，極座標及び平均海面からの高さ又は地心直交座標で表示することができる\n\n測量の基準に関して，位置の表示は原則「位置は，地理学的経緯度及び平均海面からの高さで表示する」ということになっています．\n\n世界測地系\n\n測量法第11条第2項 \n前項第一号の地理学的経緯度は，世界測地系に従つて測定しなければならない．\n\n世界測地系は，概念としてはただ一つのものですが，国ごとに採用する時期や構築に当たっての詳細な手法及び実現精度が異なります．代表例として以下の世界測地系があります：\n\n\n\n\n\n\n\n世界測地系\n特徴\n\n\n\n\nITRF系（国際地球基準座標系）\n地球の重心が原点，X軸をグリニッジ子午線と赤道との交点の方向，Y軸を東経90度の方向，Z軸を北極の方向にとった３次元直交座標(=Z軸は地球の自転軸と一致している)\n\n\nWGS系\nアメリカのGPSに用いられている．高精度・継続性よりむしろリアルタイム性が重要視される軍事，航法，海図，ナビゲーションの分野に適した世界測地系とされている．ITRF系とほぼ同一\n\n\nPZ系\nロシアの測位システムに用いられている\n\n\n\n日本では，ITRF系GRS80楕円体を採用しています．\n\n\n\n\n\n\nTip🌍: GRS80楕円体\n\n\n\n地球の形状は，自転による遠心力のため扁平な回転楕円体ですが，この楕円体の超半径と扁平率を与えたものを準拠楕円体と呼びます．準拠楕円体の１つであるGRS80楕円体では以下のように定められます\n\n長半径: 6,378,137m\n扁平率: 1/298.257222101\n\n\n\n\n回転楕円体\n\n\n\n\n\n\nジオイド\n\nDef: ジオイド \n平均海面を仮想的に陸地へ延長した面を「ジオイド」と呼ぶ．日本では，日本経緯度原点に最も近い東京湾の平均海面を通る水準面がジオイドと一致するものと考え, 高さの基準としている．ジオイドは重力方向に対して直交しています．\n\n\n\nGeoid\n\n\n\n水は重力の影響を受けて，高いところから低いところへ流れますが，地面が平坦なところでも，重力が小さいところから大きいところへ水が流れます． 地球内部の質量分布の不均一などによって，重力分布は一様ではないため，東京湾平均海面を基準としたジオイドはゆるやかな凹凸をしています．\n日本の土地の高さ（標高）は，東京湾の平均海面を基準（標高０ｍ）として測られています．水が高いこところから低いところへ流れることを表したジオイドを用いて標高が計算されているので．標高の高さと水の流れる方向は対応しているといえます．\n ▶  標高とジオイド高と楕円体高\n\n\n\nジオイド高さと標高と楕円体高\n\n\n\nジオイド高: 衛星測位の高さの基準である楕円体面から「ジオイド」までの高さ，国土地理院が発表している\n楕円体高: GPSや準天頂衛星システム等のGNSS測量で得られる高さで，楕円体面から地表面までの高さ\n\n\\[\n\\text{標高} = \\text{楕円体高} - \\text{ジオイド高}\n\\]"
  },
  {
    "objectID": "posts/2025-02-28-cavalieri-principle/index.html",
    "href": "posts/2025-02-28-cavalieri-principle/index.html",
    "title": "カバリエリの原理",
    "section": "",
    "text": "一辺長さ \\(2\\) の正方形を底面として高さ3の直方体と，それをちょっとずつねじる形でずらした立体を以下のように考えます． 右図において，\\(xy\\) 平面に並行な各断面はどれも等しく一辺の長さ \\(2\\) の正方形で，その面積は \\(4\\) となってるとします．\nこのとき，カバリエリの原理よりどちらの立体像の体積は等しいことが言えます．\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.mplot3d.art3d import Poly3DCollection\n\n\ndef plot_cuboid(data, length=2, width=2, height=3, ax=None):\n    if ax is None:\n        fig = plt.figure()\n        ax = fig.add_subplot(111, projection=\"3d\")\n    poly3d = Poly3DCollection(data, alpha=0.2, edgecolor=\"k\")\n    ax.add_collection3d(poly3d)\n\n    # Set limits\n    max_dim = max(length, width, height)\n    ax.set_xlim([-max_dim, max_dim])\n    ax.set_ylim([-max_dim, max_dim])\n    ax.set_zlim([0, height * 1.1])\n    ax.set_xlabel(\"X\")\n    ax.set_ylabel(\"Y\")\n    ax.set_zlabel(\"Z\")\n\n\ndef twisted_cuboid(\n    length=2, width=2, height=3, twist_angle=np.pi / 2, num_segments=500\n):\n    # Define the base (bottom) of the cuboid\n    base_vertices = np.array(\n        [\n            [-length / 2, -width / 2, 0],\n            [length / 2, -width / 2, 0],\n            [length / 2, width / 2, 0],\n            [-length / 2, width / 2, 0],\n        ]\n    )\n\n    # Define the top face with a twist\n    rotation_matrix = np.array(\n        [\n            [np.cos(twist_angle), -np.sin(twist_angle), 0],\n            [np.sin(twist_angle), np.cos(twist_angle), 0],\n            [0, 0, 1],\n        ]\n    )\n    top_vertices = base_vertices @ rotation_matrix.T + np.array([0, 0, height])\n\n    # Interpolate between base and top vertices\n    vertices = []\n    for i in range(num_segments + 1):\n        t = i / num_segments\n        interpolated_vertices = (1 - t) * base_vertices + t * top_vertices\n        vertices.append(interpolated_vertices)\n    vertices = np.vstack(vertices)\n\n    # Define faces\n    faces = []\n    for i in range(num_segments):\n        for j in range(4):\n            next_j = (j + 1) % 4\n            faces.append(\n                [\n                    vertices[i * 4 + j],\n                    vertices[i * 4 + next_j],\n                    vertices[(i + 1) * 4 + next_j],\n                    vertices[(i + 1) * 4 + j],\n                ]\n            )\n\n    return faces\n\n\ndef cuboid(length=2, width=2, height=3, num_segments=100, ax=None):\n    # Define the base (bottom) of the cuboid\n    base_vertices = np.array(\n        [\n            [-length / 2, -width / 2, 0],\n            [length / 2, -width / 2, 0],\n            [length / 2, width / 2, 0],\n            [-length / 2, width / 2, 0],\n        ]\n    )\n\n    # Define the top face without a twist\n    top_vertices = base_vertices + np.array([0, 0, height])\n\n    # Interpolate between base and top vertices\n    vertices = []\n    for i in range(num_segments + 1):\n        t = i / num_segments\n        interpolated_vertices = (1 - t) * base_vertices + t * top_vertices\n        vertices.append(interpolated_vertices)\n    vertices = np.vstack(vertices)\n\n    # Define faces\n    faces = []\n    for i in range(num_segments):\n        for j in range(4):\n            next_j = (j + 1) % 4\n            faces.append(\n                [\n                    vertices[i * 4 + j],\n                    vertices[i * 4 + next_j],\n                    vertices[(i + 1) * 4 + next_j],\n                    vertices[(i + 1) * 4 + j],\n                ]\n            )\n\n    return faces\n\n\n# compute points\ncuboid_records = cuboid()\ntwisted_cuboid_records = twisted_cuboid()\n\n# plots\nfig = plt.figure(figsize=(12, 6))\nax1 = fig.add_subplot(121, projection=\"3d\")\nax2 = fig.add_subplot(122, projection=\"3d\")\n\nplot_cuboid(cuboid_records, ax=ax1)\nplot_cuboid(twisted_cuboid_records, ax=ax2)\n\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\nTheorem 1 : カバリエリの原理 \n2つの立体について，平行な平面で切った切り口を比べる．互いの面積がいつも等しいならば，この２つの立体の体積は等しい．\n\n\n半径 \\(r\\) の円を底面とする高さ \\(h\\) の円柱を考えます． なお \\(h = r\\) とします．この円柱から，半径 \\(r\\) の円を底面とする円錐を以下のように抜き取った立体を作ります（以降，穴あき円柱と呼ぶ）．\n\n\n\nカバリエリの原理\n\n\nこの穴開き円柱の体積は\n\\[\n\\begin{align}\n\\pi r^2\\times h - \\pi r^2\\times \\frac{h}{3}\n    &= \\frac{2}{3} \\pi r^2 h\n\\end{align}\n\\]\n一方，半径 \\(r\\) の半球の体積は\n\\[\n\\begin{align}\n\\frac{1}{2} \\times \\frac{4}{3}\\pi r^3 = \\frac{2}{3} \\pi r^2h\n\\end{align}\n\\]\n２つの立体の体積が一致することがわかります．これをカバリエリの原理を使って確かめてみます．\nまず穴あき円錐について，高さ \\(a \\in [0, h]\\) における断面積（緑色の部分）は\n\\[\nr^2\\pi - \\left(\\frac{a}{r}r\\right)^2\\pi = (r^2 - a^2)\\pi\n\\]\n半球の方は，ピタゴラスの定理より高さ \\(a\\) のときの半径が \\(\\sqrt{r^2 - a^2}\\) と求まるので\n\\[\n(\\sqrt{r^2 - a^2})^2\\pi = (r^2 - a^2)\\pi\n\\]\n従って，２つの立体について任意の高さ \\(a \\in [0, h]\\) において互いの面積がいつも等しいことがわかります．\n\n\n半径 \\(r\\), 弧の長さ \\(l\\) の扇形の面積を求めたいとします．扇形に対し，分割交互ずらしをして以下のように長方形へ極限等積変形を実施します．\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom matplotlib.patches import Wedge, Polygon\n\n# Parameters\nr = 1  # radius\nl = 0.5  # arc length\n\n# Calculate the angle of the sector\ntheta = l / r  # in radians\ndivide_num = 4\n\n# Create the sector\nfig, ax = plt.subplots(1, 2, figsize=(12, 6))\n\n# Plot the original sector\nsector = Wedge(\n    (0, 0), r, 0, np.degrees(theta), facecolor=\"lightblue\", edgecolor=\"black\"\n)\nax[0].add_patch(sector)\nax[0].set_xlim(-0.1, r * 1.2)\nax[0].set_ylim(-0.1, l)\nax[0].set_aspect(\"equal\", \"box\")\nax[0].set_title(\"Original Sector\")\n\n# Divide the sector into four parts\nangles = np.linspace(0, theta, divide_num+1)\nfor i in range(divide_num):\n    wedge = Wedge(\n        (0, 0),\n        r,\n        np.degrees(angles[i]),\n        np.degrees(angles[i + 1]),\n        facecolor=\"none\",\n        edgecolor=\"black\",\n    )\n    ax[0].add_patch(wedge)\n\n# Rearrange the parts into a parallelogram\n\n# Create the parallelogram by shifting the parts\nfor i in range(divide_num):\n    if i % 2 == 0:\n        sector = Wedge(\n            (0, np.sin(theta / divide_num) * (i // 2)), r, 0, np.degrees(theta / divide_num), facecolor=\"lightblue\", edgecolor=\"black\"\n        )\n    else:\n        sector = Wedge(\n            (np.cos(theta / divide_num), np.sin(theta / divide_num) * (i // 2 + 1 )),\n            r,\n            np.degrees(np.pi),\n            np.degrees(theta / divide_num + np.pi),\n            facecolor=\"lightblue\",\n            edgecolor=\"black\",\n        )\n    ax[1].add_patch(sector)\n    \n\n# add info\nax[1].text(1.01, l/4, f\"Height = $l/2$\", horizontalalignment=\"left\")\n\nax[1].set_xlim(-0.1, r * 1.2)\nax[1].set_ylim(-0.1, l)\nax[1].set_aspect(\"equal\", \"box\")\nax[1].set_title(\"Rearranged into Parallelogram\")\n\nplt.show()\n\n\n\n\n\n\n\n\n\n上の図では４分割ですが，これを細かくすると横の長さ \\(r\\), 縦の長さ \\(l/2\\) の長方形へ変形することができるとみなせるので\n\\[\nS = \\frac{l}{2}r\n\\]\nと計算することが出来ます．半径 \\(r\\), 弧の長さ \\(l = 2\\pi r\\) のとき，扇形は円になりますが，その円の面積も同様に\n\\[\nS = \\frac{2\\pi r}{2}r = r^2 \\pi\n\\]\nと計算でき，円の面積の公式と一致することがわかります\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom matplotlib.patches import Wedge, Polygon\n\n# Parameters\nr = 2  # radius\nl = 2*np.pi * r  # arc length\n\n# Calculate the angle of the sector\ntheta = l / r  # in radians\ndivide_num = 100\n\n# Create the sector\nfig, ax = plt.subplots(1, 2, figsize=(12, 6))\n\n# Plot the original sector\nsector = Wedge(\n    (0, 0), r, 0, np.degrees(theta), facecolor=\"lightblue\", edgecolor=\"black\"\n)\nax[0].add_patch(sector)\nax[0].set_xlim(-r * 1.2, r * 1.2)\nax[0].set_ylim(-r * 1.2, r * 1.2)\nax[0].set_aspect(\"equal\", \"box\")\nax[0].set_title(\"Original Sector\")\n\n# Divide the sector into four parts\nangles = np.linspace(0, theta, divide_num+1)\nfor i in range(divide_num):\n    wedge = Wedge(\n        (0, 0),\n        r,\n        np.degrees(angles[i]),\n        np.degrees(angles[i + 1]),\n        facecolor=\"none\",\n        edgecolor=\"black\",\n    )\n    ax[0].add_patch(wedge)\n\n# Rearrange the parts into a parallelogram\n\n# Create the parallelogram by shifting the parts\nfor i in range(divide_num):\n    if i % 2 == 0:\n        sector = Wedge(\n            (0, np.sin(theta / divide_num) * (i // 2)* r), r, 0, np.degrees(theta / divide_num), facecolor=\"lightblue\", edgecolor=\"black\"\n        )\n    else:\n        sector = Wedge(\n            (np.cos(theta / divide_num)* r, np.sin(theta / divide_num) * r * (i // 2 + 1 )),\n            r,\n            np.degrees(np.pi),\n            np.degrees(theta / divide_num + np.pi),\n            facecolor=\"lightblue\",\n            edgecolor=\"black\",\n        )\n    ax[1].add_patch(sector)\n    \n\n# add info\nax[1].text(r + 0.01, l/4, f\"Height = $r\\pi$\", horizontalalignment=\"left\")\n\nax[1].set_xlim(-0.5, r * 1.2)\nax[1].set_ylim(-0.5, l/2 * 1.05)\nax[1].set_aspect(\"equal\", \"box\")\nax[1].set_title(\"Rearranged into Parallelogram\")\n\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n半径 \\(2\\), 弧の長さが \\(\\displaystyle L = \\frac{2}{3}\\pi\\) の扇形から，半径 \\(2/3\\), 弧の長さが \\(\\displaystyle l = \\frac{2}{9}\\pi\\) の扇形を除いたパイン形を考えます．このパイン形に対して，「分割交互ずらし」を適用して極限を取ると，底辺の長さ \\(\\displaystyle \\frac{4}{3}\\)，高さ\n\\[\n\\text{height} = \\frac{l + L}{2} = \\frac{4}{9}\\pi\n\\]\nの長方形へ収束します．このとき，このパイン型の面積は\n\\[\nS = \\frac{l + L}{2}\\times \\frac{4}{3} = \\frac{16}{27}\\pi\n\\]\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom shapely.geometry import Polygon\nfrom shapely.affinity import translate\nfrom shapely.ops import unary_union\nfrom shapely.affinity import rotate\nimport geopandas as gpd\n\n\ndef create_sector(center, radius, angle_start, angle_end, num_points=100):\n    \"\"\"Creates a sector shape as a polygon using Shapely.\"\"\"\n    angles = np.linspace(np.radians(angle_start), np.radians(angle_end), num_points)\n    outer_arc = [\n        (center[0] + radius * np.cos(a), center[1] + radius * np.sin(a)) for a in angles\n    ]\n    return Polygon([center] + outer_arc + [center])  # Close the polygon\n\n\n# Parameters\ndivide_num = 20\nring_sector_list = []\nouter_radius = 2\nangle = 60 / divide_num\n\nfor i in range(divide_num):\n    center = (0, 0)\n    inner_radius = outer_radius / 3\n    angle_start, angle_end = angle * i, angle * (i + 1)  # Angle in degrees\n\n    # Create outer and inner sectors\n    outer_sector = create_sector(center, outer_radius, angle_start, angle_end)\n    inner_sector = create_sector(center, inner_radius, angle_start, angle_end)\n\n    # Subtract inner sector from outer sector to get the ring shape\n    ring_sector = outer_sector.difference(inner_sector)\n    ring_sector_list.append(ring_sector)\n\n\n# plot\nfig, ax = plt.subplots(1, 2, figsize=(12, 6))\n\nfor ring_sector in ring_sector_list:\n    # Plot using GeoPandas\n    gdf = gpd.GeoSeries([ring_sector])\n    gdf.plot(ax=ax[0], color=\"lightblue\", edgecolor=\"black\")\n\n# Formatting\nax[0].set_xlim(-0.05, outer_radius + 0.1)\nax[0].set_ylim(-0.05, outer_radius + 0.1)\n\ngdf = gpd.GeoSeries([ring_sector_list[0]])\nrotated_gdf = gpd.GeoSeries(rotate(ring_sector_list[0], 180, origin=\"center\"))\nfor i in range(len(ring_sector_list)):\n    # Plot using GeoPandas\n    if i % 2 == 0:\n        gdf_tmp = gdf.apply(\n            lambda geom: translate(\n                geom, xoff=-2/3, yoff=np.sin(np.radians(angle))*8/3 * (i//2)\n            )\n        )\n        gdf_tmp.plot(ax=ax[1], color=\"lightblue\", edgecolor=\"black\")\n    else:\n        gdf_tmp = rotated_gdf.apply(\n            lambda geom: translate(\n                geom, xoff=-2/3, yoff=np.sin(np.radians(angle))*2/3 * (i//2 + 1) + np.sin(np.radians(angle))*6/3 * (i//2)\n            ))\n        gdf_tmp.plot(ax=ax[1], color=\"lightblue\", edgecolor=\"black\")\n\n\nplt.show()"
  },
  {
    "objectID": "posts/2025-02-28-cavalieri-principle/index.html#カバリエリの原理",
    "href": "posts/2025-02-28-cavalieri-principle/index.html#カバリエリの原理",
    "title": "カバリエリの原理",
    "section": "",
    "text": "一辺長さ \\(2\\) の正方形を底面として高さ3の直方体と，それをちょっとずつねじる形でずらした立体を以下のように考えます． 右図において，\\(xy\\) 平面に並行な各断面はどれも等しく一辺の長さ \\(2\\) の正方形で，その面積は \\(4\\) となってるとします．\nこのとき，カバリエリの原理よりどちらの立体像の体積は等しいことが言えます．\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.mplot3d.art3d import Poly3DCollection\n\n\ndef plot_cuboid(data, length=2, width=2, height=3, ax=None):\n    if ax is None:\n        fig = plt.figure()\n        ax = fig.add_subplot(111, projection=\"3d\")\n    poly3d = Poly3DCollection(data, alpha=0.2, edgecolor=\"k\")\n    ax.add_collection3d(poly3d)\n\n    # Set limits\n    max_dim = max(length, width, height)\n    ax.set_xlim([-max_dim, max_dim])\n    ax.set_ylim([-max_dim, max_dim])\n    ax.set_zlim([0, height * 1.1])\n    ax.set_xlabel(\"X\")\n    ax.set_ylabel(\"Y\")\n    ax.set_zlabel(\"Z\")\n\n\ndef twisted_cuboid(\n    length=2, width=2, height=3, twist_angle=np.pi / 2, num_segments=500\n):\n    # Define the base (bottom) of the cuboid\n    base_vertices = np.array(\n        [\n            [-length / 2, -width / 2, 0],\n            [length / 2, -width / 2, 0],\n            [length / 2, width / 2, 0],\n            [-length / 2, width / 2, 0],\n        ]\n    )\n\n    # Define the top face with a twist\n    rotation_matrix = np.array(\n        [\n            [np.cos(twist_angle), -np.sin(twist_angle), 0],\n            [np.sin(twist_angle), np.cos(twist_angle), 0],\n            [0, 0, 1],\n        ]\n    )\n    top_vertices = base_vertices @ rotation_matrix.T + np.array([0, 0, height])\n\n    # Interpolate between base and top vertices\n    vertices = []\n    for i in range(num_segments + 1):\n        t = i / num_segments\n        interpolated_vertices = (1 - t) * base_vertices + t * top_vertices\n        vertices.append(interpolated_vertices)\n    vertices = np.vstack(vertices)\n\n    # Define faces\n    faces = []\n    for i in range(num_segments):\n        for j in range(4):\n            next_j = (j + 1) % 4\n            faces.append(\n                [\n                    vertices[i * 4 + j],\n                    vertices[i * 4 + next_j],\n                    vertices[(i + 1) * 4 + next_j],\n                    vertices[(i + 1) * 4 + j],\n                ]\n            )\n\n    return faces\n\n\ndef cuboid(length=2, width=2, height=3, num_segments=100, ax=None):\n    # Define the base (bottom) of the cuboid\n    base_vertices = np.array(\n        [\n            [-length / 2, -width / 2, 0],\n            [length / 2, -width / 2, 0],\n            [length / 2, width / 2, 0],\n            [-length / 2, width / 2, 0],\n        ]\n    )\n\n    # Define the top face without a twist\n    top_vertices = base_vertices + np.array([0, 0, height])\n\n    # Interpolate between base and top vertices\n    vertices = []\n    for i in range(num_segments + 1):\n        t = i / num_segments\n        interpolated_vertices = (1 - t) * base_vertices + t * top_vertices\n        vertices.append(interpolated_vertices)\n    vertices = np.vstack(vertices)\n\n    # Define faces\n    faces = []\n    for i in range(num_segments):\n        for j in range(4):\n            next_j = (j + 1) % 4\n            faces.append(\n                [\n                    vertices[i * 4 + j],\n                    vertices[i * 4 + next_j],\n                    vertices[(i + 1) * 4 + next_j],\n                    vertices[(i + 1) * 4 + j],\n                ]\n            )\n\n    return faces\n\n\n# compute points\ncuboid_records = cuboid()\ntwisted_cuboid_records = twisted_cuboid()\n\n# plots\nfig = plt.figure(figsize=(12, 6))\nax1 = fig.add_subplot(121, projection=\"3d\")\nax2 = fig.add_subplot(122, projection=\"3d\")\n\nplot_cuboid(cuboid_records, ax=ax1)\nplot_cuboid(twisted_cuboid_records, ax=ax2)\n\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\nTheorem 1 : カバリエリの原理 \n2つの立体について，平行な平面で切った切り口を比べる．互いの面積がいつも等しいならば，この２つの立体の体積は等しい．\n\n\n半径 \\(r\\) の円を底面とする高さ \\(h\\) の円柱を考えます． なお \\(h = r\\) とします．この円柱から，半径 \\(r\\) の円を底面とする円錐を以下のように抜き取った立体を作ります（以降，穴あき円柱と呼ぶ）．\n\n\n\nカバリエリの原理\n\n\nこの穴開き円柱の体積は\n\\[\n\\begin{align}\n\\pi r^2\\times h - \\pi r^2\\times \\frac{h}{3}\n    &= \\frac{2}{3} \\pi r^2 h\n\\end{align}\n\\]\n一方，半径 \\(r\\) の半球の体積は\n\\[\n\\begin{align}\n\\frac{1}{2} \\times \\frac{4}{3}\\pi r^3 = \\frac{2}{3} \\pi r^2h\n\\end{align}\n\\]\n２つの立体の体積が一致することがわかります．これをカバリエリの原理を使って確かめてみます．\nまず穴あき円錐について，高さ \\(a \\in [0, h]\\) における断面積（緑色の部分）は\n\\[\nr^2\\pi - \\left(\\frac{a}{r}r\\right)^2\\pi = (r^2 - a^2)\\pi\n\\]\n半球の方は，ピタゴラスの定理より高さ \\(a\\) のときの半径が \\(\\sqrt{r^2 - a^2}\\) と求まるので\n\\[\n(\\sqrt{r^2 - a^2})^2\\pi = (r^2 - a^2)\\pi\n\\]\n従って，２つの立体について任意の高さ \\(a \\in [0, h]\\) において互いの面積がいつも等しいことがわかります．\n\n\n半径 \\(r\\), 弧の長さ \\(l\\) の扇形の面積を求めたいとします．扇形に対し，分割交互ずらしをして以下のように長方形へ極限等積変形を実施します．\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom matplotlib.patches import Wedge, Polygon\n\n# Parameters\nr = 1  # radius\nl = 0.5  # arc length\n\n# Calculate the angle of the sector\ntheta = l / r  # in radians\ndivide_num = 4\n\n# Create the sector\nfig, ax = plt.subplots(1, 2, figsize=(12, 6))\n\n# Plot the original sector\nsector = Wedge(\n    (0, 0), r, 0, np.degrees(theta), facecolor=\"lightblue\", edgecolor=\"black\"\n)\nax[0].add_patch(sector)\nax[0].set_xlim(-0.1, r * 1.2)\nax[0].set_ylim(-0.1, l)\nax[0].set_aspect(\"equal\", \"box\")\nax[0].set_title(\"Original Sector\")\n\n# Divide the sector into four parts\nangles = np.linspace(0, theta, divide_num+1)\nfor i in range(divide_num):\n    wedge = Wedge(\n        (0, 0),\n        r,\n        np.degrees(angles[i]),\n        np.degrees(angles[i + 1]),\n        facecolor=\"none\",\n        edgecolor=\"black\",\n    )\n    ax[0].add_patch(wedge)\n\n# Rearrange the parts into a parallelogram\n\n# Create the parallelogram by shifting the parts\nfor i in range(divide_num):\n    if i % 2 == 0:\n        sector = Wedge(\n            (0, np.sin(theta / divide_num) * (i // 2)), r, 0, np.degrees(theta / divide_num), facecolor=\"lightblue\", edgecolor=\"black\"\n        )\n    else:\n        sector = Wedge(\n            (np.cos(theta / divide_num), np.sin(theta / divide_num) * (i // 2 + 1 )),\n            r,\n            np.degrees(np.pi),\n            np.degrees(theta / divide_num + np.pi),\n            facecolor=\"lightblue\",\n            edgecolor=\"black\",\n        )\n    ax[1].add_patch(sector)\n    \n\n# add info\nax[1].text(1.01, l/4, f\"Height = $l/2$\", horizontalalignment=\"left\")\n\nax[1].set_xlim(-0.1, r * 1.2)\nax[1].set_ylim(-0.1, l)\nax[1].set_aspect(\"equal\", \"box\")\nax[1].set_title(\"Rearranged into Parallelogram\")\n\nplt.show()\n\n\n\n\n\n\n\n\n\n上の図では４分割ですが，これを細かくすると横の長さ \\(r\\), 縦の長さ \\(l/2\\) の長方形へ変形することができるとみなせるので\n\\[\nS = \\frac{l}{2}r\n\\]\nと計算することが出来ます．半径 \\(r\\), 弧の長さ \\(l = 2\\pi r\\) のとき，扇形は円になりますが，その円の面積も同様に\n\\[\nS = \\frac{2\\pi r}{2}r = r^2 \\pi\n\\]\nと計算でき，円の面積の公式と一致することがわかります\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom matplotlib.patches import Wedge, Polygon\n\n# Parameters\nr = 2  # radius\nl = 2*np.pi * r  # arc length\n\n# Calculate the angle of the sector\ntheta = l / r  # in radians\ndivide_num = 100\n\n# Create the sector\nfig, ax = plt.subplots(1, 2, figsize=(12, 6))\n\n# Plot the original sector\nsector = Wedge(\n    (0, 0), r, 0, np.degrees(theta), facecolor=\"lightblue\", edgecolor=\"black\"\n)\nax[0].add_patch(sector)\nax[0].set_xlim(-r * 1.2, r * 1.2)\nax[0].set_ylim(-r * 1.2, r * 1.2)\nax[0].set_aspect(\"equal\", \"box\")\nax[0].set_title(\"Original Sector\")\n\n# Divide the sector into four parts\nangles = np.linspace(0, theta, divide_num+1)\nfor i in range(divide_num):\n    wedge = Wedge(\n        (0, 0),\n        r,\n        np.degrees(angles[i]),\n        np.degrees(angles[i + 1]),\n        facecolor=\"none\",\n        edgecolor=\"black\",\n    )\n    ax[0].add_patch(wedge)\n\n# Rearrange the parts into a parallelogram\n\n# Create the parallelogram by shifting the parts\nfor i in range(divide_num):\n    if i % 2 == 0:\n        sector = Wedge(\n            (0, np.sin(theta / divide_num) * (i // 2)* r), r, 0, np.degrees(theta / divide_num), facecolor=\"lightblue\", edgecolor=\"black\"\n        )\n    else:\n        sector = Wedge(\n            (np.cos(theta / divide_num)* r, np.sin(theta / divide_num) * r * (i // 2 + 1 )),\n            r,\n            np.degrees(np.pi),\n            np.degrees(theta / divide_num + np.pi),\n            facecolor=\"lightblue\",\n            edgecolor=\"black\",\n        )\n    ax[1].add_patch(sector)\n    \n\n# add info\nax[1].text(r + 0.01, l/4, f\"Height = $r\\pi$\", horizontalalignment=\"left\")\n\nax[1].set_xlim(-0.5, r * 1.2)\nax[1].set_ylim(-0.5, l/2 * 1.05)\nax[1].set_aspect(\"equal\", \"box\")\nax[1].set_title(\"Rearranged into Parallelogram\")\n\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n半径 \\(2\\), 弧の長さが \\(\\displaystyle L = \\frac{2}{3}\\pi\\) の扇形から，半径 \\(2/3\\), 弧の長さが \\(\\displaystyle l = \\frac{2}{9}\\pi\\) の扇形を除いたパイン形を考えます．このパイン形に対して，「分割交互ずらし」を適用して極限を取ると，底辺の長さ \\(\\displaystyle \\frac{4}{3}\\)，高さ\n\\[\n\\text{height} = \\frac{l + L}{2} = \\frac{4}{9}\\pi\n\\]\nの長方形へ収束します．このとき，このパイン型の面積は\n\\[\nS = \\frac{l + L}{2}\\times \\frac{4}{3} = \\frac{16}{27}\\pi\n\\]\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom shapely.geometry import Polygon\nfrom shapely.affinity import translate\nfrom shapely.ops import unary_union\nfrom shapely.affinity import rotate\nimport geopandas as gpd\n\n\ndef create_sector(center, radius, angle_start, angle_end, num_points=100):\n    \"\"\"Creates a sector shape as a polygon using Shapely.\"\"\"\n    angles = np.linspace(np.radians(angle_start), np.radians(angle_end), num_points)\n    outer_arc = [\n        (center[0] + radius * np.cos(a), center[1] + radius * np.sin(a)) for a in angles\n    ]\n    return Polygon([center] + outer_arc + [center])  # Close the polygon\n\n\n# Parameters\ndivide_num = 20\nring_sector_list = []\nouter_radius = 2\nangle = 60 / divide_num\n\nfor i in range(divide_num):\n    center = (0, 0)\n    inner_radius = outer_radius / 3\n    angle_start, angle_end = angle * i, angle * (i + 1)  # Angle in degrees\n\n    # Create outer and inner sectors\n    outer_sector = create_sector(center, outer_radius, angle_start, angle_end)\n    inner_sector = create_sector(center, inner_radius, angle_start, angle_end)\n\n    # Subtract inner sector from outer sector to get the ring shape\n    ring_sector = outer_sector.difference(inner_sector)\n    ring_sector_list.append(ring_sector)\n\n\n# plot\nfig, ax = plt.subplots(1, 2, figsize=(12, 6))\n\nfor ring_sector in ring_sector_list:\n    # Plot using GeoPandas\n    gdf = gpd.GeoSeries([ring_sector])\n    gdf.plot(ax=ax[0], color=\"lightblue\", edgecolor=\"black\")\n\n# Formatting\nax[0].set_xlim(-0.05, outer_radius + 0.1)\nax[0].set_ylim(-0.05, outer_radius + 0.1)\n\ngdf = gpd.GeoSeries([ring_sector_list[0]])\nrotated_gdf = gpd.GeoSeries(rotate(ring_sector_list[0], 180, origin=\"center\"))\nfor i in range(len(ring_sector_list)):\n    # Plot using GeoPandas\n    if i % 2 == 0:\n        gdf_tmp = gdf.apply(\n            lambda geom: translate(\n                geom, xoff=-2/3, yoff=np.sin(np.radians(angle))*8/3 * (i//2)\n            )\n        )\n        gdf_tmp.plot(ax=ax[1], color=\"lightblue\", edgecolor=\"black\")\n    else:\n        gdf_tmp = rotated_gdf.apply(\n            lambda geom: translate(\n                geom, xoff=-2/3, yoff=np.sin(np.radians(angle))*2/3 * (i//2 + 1) + np.sin(np.radians(angle))*6/3 * (i//2)\n            ))\n        gdf_tmp.plot(ax=ax[1], color=\"lightblue\", edgecolor=\"black\")\n\n\nplt.show()"
  },
  {
    "objectID": "posts/2025-02-28-cavalieri-principle/index.html#線分の運動とずらし面積",
    "href": "posts/2025-02-28-cavalieri-principle/index.html#線分の運動とずらし面積",
    "title": "カバリエリの原理",
    "section": "線分の運動とずらし面積",
    "text": "線分の運動とずらし面積\n野球グラウンドをならすときトンボという道具を使ったりします．このトンボを引きづる用な形でグラウンドを適当に歩くと，トンボがなす線分がグラウンドを通過することで図形が出来ます． 線分の運動の観点から，この図形の面積を求める方法をここでは紹介します．\n\n\nCode\nfrom scipy import interpolate\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nN = 1000\n\nx = np.linspace(0, 5, N)\n\ny = (\n    np.sin(x)\n    + np.cos(x ** 2) / 10\n)\n\ndydx = np.cos(x) - (2 / 10) * np.sin(x ** 2) * x\ndydx = np.where(abs(dydx) &gt; 1e-10, dydx, 0)\n\n\nupper_x = []\nupper_y = []\nlower_x = []\nlower_y = []\n\nfor i in range(N):\n    if dydx[i] &lt; 0:\n        dy = abs(1/dydx[i])\n        dist = np.sqrt(dy**2 + 1) * 10\n        dx = 1 / dist\n        dy = dy / dist\n    elif dydx[i] &gt; 0:\n        dy = abs(1/dydx[i])\n        dist = np.sqrt(dy**2 + 1)  * 10\n        dx = -1/ dist\n        dy = dy / dist\n    else:\n        dx, dy = (0, 1 / 10)\n    \n    upper_y.append(y[i] + dy)\n    upper_x.append(x[i] + dx)\n    lower_y.append(y[i] - dy)\n    lower_x.append(x[i] - dx)\n\nfig, ax = plt.subplots()\n\nax.plot(x, y, label = 'Trajectory of the center point')\nax.plot(upper_x, upper_y, color='gray', linestyle='--')\nax.plot(lower_x, lower_y, color='gray', linestyle='--')\n\nax.set_aspect('equal', 'box')  # Ensure the x and y axes have the same ratio\n\nax.set_title(\"Trajectory of a bar with length 0.2\")\n\nplt.legend()\nplt.show()\n\n\n\n\n\n\n\n\n\n一般に，大きさのある物体（剛体という）の運動は，「並進運動」と「回転運動」の合成で表されます．長さ \\(0.2\\) のトンボがグラウンドを並進運動と回転運動で通過する際に描かれる図形をplotしたものが上の図となります． 灰色の点線がそれぞれトンボの両端の軌跡を描いており，青の実線がトンボの中心点の軌跡となります．トンボがならしたグラウンドの面積は灰色で囲まれたエリアとなります．\n ▶  shapely.Polygonを用いた面積の計算\n上記で中心点の軌跡から両端の軌跡の座標を計算してあるので，それらを用いて shapely.Polygon をまず定義します．\n\n\nCode\n# shapely.Polygonの設定\npolygon_coords = list(zip(upper_x, upper_y)) + list(zip(lower_x[::-1], lower_y[::-1]))\npolygon = Polygon(polygon_coords)\n\n# Plot the polygon\nfig, ax = plt.subplots()\nx, y = polygon.exterior.xy\nax.plot(x, y, color='black')\nax.fill(x, y, color='lightblue', alpha=0.5)\nax.set_title(\"Shapely Polygon from Upper and Lower Coordinates\")\nax.set_aspect('equal', 'box')  # Ensure the x and y axes have the same ratio\nplt.show()\n\n\n\n\n\n\n\n\n\nその後，Polygon によって定義された図形の面積を計算すれば良いので\n\n\nCode\npolygon.area\n\n\n1.2470071445781767\n\n\n ▶  曲線の長さの公式と線分の移動\n詳しい説明はのちの機会としますが，線分が履く面積は\n\\[\n\\text{線分がはく面積} = \\text{中点の移動距離} \\times \\text{線分の長さ}\n\\]\nで計算することが出来ます．線分の長さは \\(0.2\\) とわかっているので，「中点の移動距離」を求めれば面積が求まりそうなことがわかります．\n\n\nTheorem 2 : 曲線の長さ \n\\(y=f(x)\\) で表される曲線の \\(x \\in [a, b]\\) の部分の長さ \\(L\\) は，\n\\[\nL = \\int^b_a \\sqrt{1 + f^\\prime(x)^2} dx\n\\]\n​（ただし，\\(f(x)\\) は微分可能で \\(f^\\prime(x)\\) は連続とする）\n\n\n点 \\(x\\) から\\(\\Delta x\\) 動いたとき，\\(\\Delta y \\approx f^\\prime(x)\\Delta x\\) 動くことから，その区間での曲線の長さは\n\\[\n\\sqrt{(\\Delta x)^2 + (f^\\prime(x)\\Delta x)^2} = \\sqrt{1 + f^\\prime(x)^2}\\Delta x\n\\]\nで近似できます．従って，\\(\\Delta x \\to dx\\) と極限を取ることで\n\\[\nL = \\int^b_a \\sqrt{1 + f^\\prime(x)^2} dx\n\\]\nと理解することが出来ます．\n今回の曲線 \\(f(x)\\) は \\([0, 5]\\) 区間で以下のように記述することができるとします．\n\\[\nf(x) =  \\sin(x) + 0.1\\cos(x^2)\n\\]\nこのとき，\\(f(x)\\) の1次導関数は\n\\[\nf^\\prime(x) = \\cos(x) - 0.2 x \\sin(x^2)\n\\]\n従って，曲線の公式より\n\\[\nL = \\int^5_0 \\sqrt{1 +  \\cos^2(x) + 0.04 x^2 \\sin^2(x^2) - 0.4x\\cos(x)\\sin(x^2)}dx\n\\]\nscipy.integrate.quad を用いて数値計算すると\n\n\nCode\nfrom scipy.integrate import quad\n\n\ndef curve_length(x):\n    return np.sqrt(\n        np.cos(x) ** 2\n        + 1 / 25 * np.sin(x**2) ** 2 * x**2\n        - 2 / 5 * np.cos(x) * np.sin(x**2) * x\n        + 1\n    )\n\n\nprint(quad(curve_length, 0, 5)[0] * 0.2)\n\n\n1.24703476690297\n\n\nshapely.Polygon を用いた計算結果と近しい値であることから計算結果の妥当性をうかがい知ることができます．"
  },
  {
    "objectID": "posts/2024-06-07-ubuntu-noble-numbat/index.html",
    "href": "posts/2024-06-07-ubuntu-noble-numbat/index.html",
    "title": "[過去記事の転記] Ubuntu Desktop Noble Numbatのインストール",
    "section": "",
    "text": "Note目的\n\n\n\n\nUbuntu Desktop Noble NumbatをIntel Core i7-9700デスクトップへインストール"
  },
  {
    "objectID": "posts/2024-06-07-ubuntu-noble-numbat/index.html#作業環境情報",
    "href": "posts/2024-06-07-ubuntu-noble-numbat/index.html#作業環境情報",
    "title": "[過去記事の転記] Ubuntu Desktop Noble Numbatのインストール",
    "section": "作業環境情報",
    "text": "作業環境情報\nUbuntu Desktop Noble Numbatインストール先\n\nCPU: Intel Core i7-9700 CPU 3.00 GHz\nMemory: RAM 32.0 GB\nGPU: NVIDIA GeForce RTX 2060 SUPER\n\nUbuntu インストールメディア作成環境\n\nUbuntu 22.04.4 LTS x86_64 6.5.0-35-generic\nディスク管理ツール Disks を用いてインストールメディアを作成"
  },
  {
    "objectID": "posts/2024-06-07-ubuntu-noble-numbat/index.html#作業",
    "href": "posts/2024-06-07-ubuntu-noble-numbat/index.html#作業",
    "title": "[過去記事の転記] Ubuntu Desktop Noble Numbatのインストール",
    "section": "作業",
    "text": "作業\n\n\n\n\n\n\nNote作業手順\n\n\n\n\nUbuntu Desktop 24.04 LTSのISOファイルのダウンロード (15~20 min)\nUSBインストールメディアの作成 (1~2 min)\nUbuntu 24.04 LTSのインストール(20 min)\n\n\n\n\n1. Ubuntu ISOファイルのダウンロード\n日本のUbuntuミラーサーバーの一つであるTsukuba WIDEのUbuntu Desktop 24.04 isoファイルダウンロードリンク より isoファイルを取得します．isoファイルサイズは約 6 GBで，ダウンロード時間は15~20分程度(6 MB/sec)程度かかりました．\n\nDefinition 1 ISOファイル\n\nCD-ROMやDVDのディスクイメージ(光ディスク用アーカイブファイル)をそのままファイルにしたもの\nディスクからコピーした一般的なファイルでは，ヘッダー情報が消失しており完全なデータは含まれないが，ISOファイルにはディスクからのヘッダー情報を含む完全なデータが格納されている\n\n\nここで言うヘッダーは ファイルのヘッダーではなく，以下のようなディスクレベルのヘッダー・メタ情報のことです．\n\nブートセクタ / EFI System Partition 情報\nパーティションテーブル（MBR / GPT）\nファイルシステムの管理情報\nブートローダ配置情報\n\nOSを書き込むときは，対象デバイスにはOSは存在しないので，ファイルという概念をデバイスが理解することが出来ません．この段階でできることは ディスクの先頭から決められた位置を読むという作業になります．これはBIOS/UEFIによって実行されます．\nそのため，起動可能であるためには，ディスク先頭（LBA 0 付近）に起動コードや構造情報が物理配置として存在している必要があります． なので普通のファイルではなくISOファイルが必要となります．\n\n\n2. USBインストールメディアの作成\n\nDefinition 2 インストールメディア\n\nISOファイルを実体化したもの\nISOファイルに格納されたディスクイメージをUSBメモリ上にセクタ単位で書き表し，BIOS / UEFI が直接起動可能な状態にした媒体のこと\n\n\nファイルを置いたUSBだけではBIOS/UEFIで読み込むことは出来ないため，ISOファイルを焼いてインストールメディアを作成します．\n手順\n「Disks」アプリケーションを利用してUSBインストールメディアを作成しました．手順は\n\nアプリケーションから「Disks」を立ち上げる\n左ペインのDisk一覧からUSBインストールメディアの物理デバイスとなるUSBフラッシュメモリを選択\n右上のメニューボタンから Restore Disk image を選択\nDestination が意図した物理デバイスかどうか確認\nImage to Restore 項目にて，上でダウンロードしたISOファイルを選択し，Start Restoring をクリック\n\n上記手順に従い実行したところ，約2分ほどでインストールメディア作成が完了しました．\n\n\n3. Ubuntu 24.04 LTS インストール\n手順\n\nUSBインストールメディアを差し込んだ状態でUEFI環境経由boot managerを起動\n\n\nHP製なので esc + F10\n\n\n起動デバイスを差し込んだUSBフラッシュメモリにする\nTry to install Ubuntuを選択し，案内通りに作業を行う(約 20 min)\nUbuntu Proをenableする\n\n注意点\nインストール言語\n\n基本的にEnglishを選択すること\n日本語に変更したい場合は，インストール後に変更すること\nフォントが足りず文字化けが発生するリスクを抑えるため\n\nインストール先ディスクの選択\nインストーラーは接続されている全ディスクを表示するので，間違ったものを選ばないこと．対策として，\n\nインストール前に不要な外付けHDD/USBは物理的に抜く\n事前にディスクサイズや型番を確認する\n\nネットワーク接続\nUbuntu Pro設定や最新アップデートの適用などネットワーク接続舌状態でインストールするほうが便利です． 事前にIPアドレス等を確認しておくことを推奨します．\nユーサーの設定\nユーザー名とhostnameもインストール時に設定します．事前にちゃんと考えておきましょう．\n\n\n\n\n\n\n\n\n\n項目\n正確な意味\n実際に使われる場所\n\n\n\n\nYour name\n表示名（フルネーム）\nGUIログイン画面，設定画面\n\n\nYour computer’s name\nマシンの識別名（hostname）\nターミナル，SSH，ネットワーク，ログ\n\n\nPick a username\nLinux内部で使われるユーザー名（ユーザーID）\n/home/username，sudo，SSH，所有者情報，大文字は使えない\n\n\nUse Active Directory\nWindowsドメイン（AD）連携設定\nログイン認証，ユーザー管理\n\n\n\n\nタイムゾーンの変更\nインストール後に時刻がおかしい場合は，UTCになっている可能性が高いです．\n# 現在のタイムゾーンの確認\ntimedatectl\n\n# 利用可能なタイムゾーンの確認\ntimedatectl list-timezones\n\n# ある程度見当がついているなら\ntimedatectl list-timezones | grep Tokyo\n\n# タイムゾーンの設定\nsudo timedatectl set-timezone Asia/Tokyo\nただ，システムロケール選択内容に合わせて設定されるので，基本的には心配は不要です\nホームディレクトリの暗号化\nハードディスクを取り出して他のパソコンに接続されると，OSを動かすことはできなくてもデータは見られてしまいます． そのためラップトップの場合は，暗号化したほうが良いと思いますが，デスクトップやサーバーの場合は不要だと思います．"
  },
  {
    "objectID": "posts/2024-06-07-ubuntu-noble-numbat/index.html#references",
    "href": "posts/2024-06-07-ubuntu-noble-numbat/index.html#references",
    "title": "[過去記事の転記] Ubuntu Desktop Noble Numbatのインストール",
    "section": "References",
    "text": "References\n\nUbuntu 24.04.3へのupgrade"
  },
  {
    "objectID": "posts/2025-09-18-wh1000xm4-setup/index.html",
    "href": "posts/2025-09-18-wh1000xm4-setup/index.html",
    "title": "Sony WH-1000XM4をUbuntu 24.04 LTSで使う",
    "section": "",
    "text": "Ubuntu 24.04 LTSに対するLDAC利用可能な状態でのWH-1000XM4接続設定\nEasyEffectsを用いたWH-1000XM4用Equalizerの設定\n\nPackage Requirements\n\n\n\n\n\n\n\n\nカテゴリ\nパッケージ\n説明\n\n\n\n\nBluetooth LDAC\nlibldacbt-abr-dev\nLDAC の ABR (Adaptive Bitrate) ライブラリ（開発用）\n\n\n\nlibldacbt-enc-dev\nLDAC エンコーダライブラリ（開発用）\n\n\nBluetooth 管理\nblueman\nBluetooth デバイス管理用 GUI\n\n\nオーディオ基盤\npipewire\nオーディオサーバ（PulseAudio 互換）\n\n\n\npipewire-pulse\nPulseAudio アプリ互換サーバ\n\n\n\nwireplumber\nPipeWire のsession / policy manager\n\n\n音質補正\neasyeffects\n音響補正ツール(Equalizerなど)\n\n\n\n今回はPipewire環境での接続設定となります．"
  },
  {
    "objectID": "posts/2025-09-18-wh1000xm4-setup/index.html#goals",
    "href": "posts/2025-09-18-wh1000xm4-setup/index.html#goals",
    "title": "Sony WH-1000XM4をUbuntu 24.04 LTSで使う",
    "section": "",
    "text": "Ubuntu 24.04 LTSに対するLDAC利用可能な状態でのWH-1000XM4接続設定\nEasyEffectsを用いたWH-1000XM4用Equalizerの設定\n\nPackage Requirements\n\n\n\n\n\n\n\n\nカテゴリ\nパッケージ\n説明\n\n\n\n\nBluetooth LDAC\nlibldacbt-abr-dev\nLDAC の ABR (Adaptive Bitrate) ライブラリ（開発用）\n\n\n\nlibldacbt-enc-dev\nLDAC エンコーダライブラリ（開発用）\n\n\nBluetooth 管理\nblueman\nBluetooth デバイス管理用 GUI\n\n\nオーディオ基盤\npipewire\nオーディオサーバ（PulseAudio 互換）\n\n\n\npipewire-pulse\nPulseAudio アプリ互換サーバ\n\n\n\nwireplumber\nPipeWire のsession / policy manager\n\n\n音質補正\neasyeffects\n音響補正ツール(Equalizerなど)\n\n\n\n今回はPipewire環境での接続設定となります．"
  },
  {
    "objectID": "posts/2025-09-18-wh1000xm4-setup/index.html#実行環境",
    "href": "posts/2025-09-18-wh1000xm4-setup/index.html#実行環境",
    "title": "Sony WH-1000XM4をUbuntu 24.04 LTSで使う",
    "section": "💻 実行環境",
    "text": "💻 実行環境\n\nUbuntu\nDistribution\n% lsb_release -a\nNo LSB modules are available.\nDistributor ID: Ubuntu\nDescription:    Ubuntu 24.04.3 LTS\nRelease:    24.04\nCodename:   noble\nLinux kernel\n% uname -srpo\nLinux 6.14.0-29-generic x86_64 GNU/Linux\n\n\n🎧 Sony WH-1000XM4のスペック\nワイヤレス機能\n\n\n\n\n\n\n\n項目\n内容\n\n\n\n\nBluetoothバージョン\nVer.5.0 / Class 1\n\n\n連続再生時間\n最大30時間（NC ON時） / 最大38時間（NC OFF時）\n\n\n充電時間\n約3時間\n\n\n対応コーデック\nSBC / AAC / LDAC\n\n\nNFC\n○\n\n\nTWS Plus対応\n☓\n\n\nマルチペアリング対応\n○\n\n\nマルチポイント対応\n○\n\n\n\n機能\n\n\n\n項目\n内容\n\n\n\n\n重量\n254g\n\n\nノイズキャンセリング\n○\n\n\nハイレゾ\n○\n\n\nマイク\n○\n\n\n外音取り込み\n○\n\n\n音質調整\n○\n\n\n防水・防塵性能\n☓\n\n\nリモコン操作\n○\n\n\n折りたたみ\n○\n\n\nサラウンド\n☓\n\n\nAIアシスタント搭載\nGoogle アシスタント / Amazon Alexa\n\n\nAIアシスタント呼び出し機能\n○\n\n\n\n\n\n\n\n\n\nCautionマルチポイント接続の注意点\n\n\n\n\nWH-1000XM4ではマルチポイント接続設定OnにするとLDACが使用できなくなります\nWH-1000XM5以降ではこの点は改善されています\n\n\n\nLDACとは？\nLDACとはSony が開発した Bluetoothオーディオコーデックです．Bluetoothのコーデックとは，スマホや音楽再生プレイヤーなどのデバイスからワイヤレスイヤホンやヘッドホンなどに無線で音楽のデータを送る際の符号化の規格です． 圧縮の規格でもあるので元の音楽データを圧縮エンコードしBluetoothで飛ばし，受信デバイスのイヤホンなどでデコードすることで音楽の再生をしています．そのため，コーデックの違いにより，音質や遅延に違いが出ます．\n\n\n\n\n\n\n\n特性項目\n内容\n\n\n\n\nコーデック名\nLDAC\n\n\n特徴\nハイレゾ対応の最高音質 Bluetooth コーデック（Sony 開発）\n\n\n主な採用機器\nハイレゾ対応 Android / iOS / Windows / Mac / Linux (PipeWire)\n\n\nサンプリング周波数\n最大 96 kHz\n\n\n量子化ビット数\n最大 24 bit\n\n\nビットレートモード\n330 kbps / 660 kbps / 990 kbps の 3 段階（ABRで自動調整可）\n\n\n遅延\nSBC / AAC より大きめ（高音質優先のため）"
  },
  {
    "objectID": "posts/2025-09-18-wh1000xm4-setup/index.html#wh-1000xm4接続設定",
    "href": "posts/2025-09-18-wh1000xm4-setup/index.html#wh-1000xm4接続設定",
    "title": "Sony WH-1000XM4をUbuntu 24.04 LTSで使う",
    "section": "🔨 WH-1000XM4接続設定",
    "text": "🔨 WH-1000XM4接続設定\n\n\nCode\n---\nconfig:\n  theme: redux\n  themeVariables:\n    fontFamily: '\"Meiryo\"'\n    fontSize: 1.1em\n    lineHeight: 1.4\n---\ntimeline\n    title WH-1000XM4接続設定手順\n    section ① Bluetooth 接続確認\n        Bluetooth Manager&lt;br&gt;のインストール\n            : Blueman&lt;br&gt;のインストール\n        LDAC サポート確認\n            : LDAC encoding toolのインストール\n            : Adaptive bit rate tooのインストール\n    section ② Config調整\n        Pipewire設定\n            : sampling frequencyの設定\n        Wireplumber設定\n            : LDAC encoding qualityの設定\n    section ③ WH-1000MX4動作確認\n        Bluetooth ペアリング : Bluemanで WH-1000XM4 を接続\n        接続確認\n            : 周波数確認\n            : Codec確認\n            : LDAC bit rate確認\n\n\n\n\n\n---\nconfig:\n  theme: redux\n  themeVariables:\n    fontFamily: '\"Meiryo\"'\n    fontSize: 1.1em\n    lineHeight: 1.4\n---\ntimeline\n    title WH-1000XM4接続設定手順\n    section ① Bluetooth 接続確認\n        Bluetooth Manager&lt;br&gt;のインストール\n            : Blueman&lt;br&gt;のインストール\n        LDAC サポート確認\n            : LDAC encoding toolのインストール\n            : Adaptive bit rate tooのインストール\n    section ② Config調整\n        Pipewire設定\n            : sampling frequencyの設定\n        Wireplumber設定\n            : LDAC encoding qualityの設定\n    section ③ WH-1000MX4動作確認\n        Bluetooth ペアリング : Bluemanで WH-1000XM4 を接続\n        接続確認\n            : 周波数確認\n            : Codec確認\n            : LDAC bit rate確認\n\n\n\n\n\n\n\nBluetooth Managerのインストール\nまずBluetooth デバイス管理ツール Blueman をインストールします． Ubuntu 24.04 LTSにはデフォルトでBluetooth Managerが入っているので「接続して音を出す」だけならばインストール不要です．\n一方，接続プロファイルやcodecの選択といった制御がしやすいので今回導入します．\nsudo apt install blueman\nLDAC codecの設定\nUbuntu 24.04 のデフォルトの Bluetooth ManagerだとLDACは使用できないので，以下のパッケージをインストールします\n\nlibldacbt-enc-dev: LDACエンコーディング処理用パッケージ\nlibldacbt-abr-dev: Adaptive Bit Rateに対応するための開発ライブラリ\n\n-dev suffixが無いものでも良いような気がしますが，今後ビルドとかするかもなので大は小を兼ねるとして開発用ライブラリをインストール． インストールコマンドは以下\nsudo apt install libldacbt-abr-dev libldacbt-enc-dev\nBluetooth接続確認\nBluetooth Managerを起動して，WH-1000XM4をペアリング接続します．このとき，LDAC codecを指定するのを忘れずに\n\n\n\nBluetooth初期接続\n\n\n次に pactl list sinks コマンドを用いて接続状態を確認してみます．\n\n\n\n\n\n\n\n\n構成要素\n説明\n\n\n\n\npactl\nPulseAudio の制御ツール．サウンドデバイスの状態取得や操作のコマンド．\n\n\nlist sinks\n出力デバイス（sink＝スピーカーやBluetoothイヤホンなど）の一覧を表示するサブコマンド\n\n\n\n\nBluetoothデバイスは Name: bluez というsink名になります．これらを踏まえて状態を確認してみます\n% pactl list sinks | grep -A 20 'Name: bluez'\n    Name: bluez_output.xx_xx_xx_xx_xx_xx.1\n    Description: WH-1000XM4\n    Driver: PipeWire\n    Sample Specification: float32le 2ch 48000Hz\n    Channel Map: front-left,front-right\n    Owner Module: 4294967295\n    Mute: no\n    Volume: front-left: 28382 /  43% / -21.81 dB,   front-right: 28382 /  43% / -21.81 dB\n            balance 0.00\n    Base Volume: 65536 / 100% / 0.00 dB\n    Monitor Source: bluez_output.xx_xx_xx_xx_xx_xx.1.monitor\n    Latency: 0 usec, configured 0 usec\n    Flags: HARDWARE HW_VOLUME_CTRL DECIBEL_VOLUME LATENCY \n    Properties:\n        api.bluez5.address = \"xx:xx:xx:xx:xx:xx\"\n        api.bluez5.codec = \"ldac\"\n        api.bluez5.profile = \"a2dp-sink\"\n        api.bluez5.transport = \"\"\n        card.profile.device = \"1\"\n        device.id = \"179\"\n        device.routes = \"1\"\nここから，Bluetooth コーデックとサンプリングレートの確認ができます．\n以下のようにcodecは問題なくLDACの認識となってます\n  api.bluez5.codec = \"ldac\"\n  api.bluez5.profile = \"a2dp-sink\"\n一方，samplking frequencyが\n    Sample Specification: float32le 2ch 48000Hz\nとなっています．LDACは最大96kHz対応できるはずなので，PipeWire のサンプリング周波数を設定します．\nsampling frequencyの設定\n/usr/share/pipewire/pipewire.conf に設定ファイルがあるのでこれを修正します．\n\ndefault.clock.rate: フォルトのサンプリング周波数(Hz)\ndefault.clock.allowed-rates: PipeWire が切り替えを許可するサンプルレートのリスト\n\n以上2つの項目を修正します．\ndefault.clock.rate          = 96000\ndefault.clock.allowed-rates = [ 48000, 96000 ]\nという形に変更します．/usr/share/pipewire/pipewire.conf は root ownerのファイルなので，修正するときは\nsudo vim /usr/share/pipewire/pipewire.conf\nで編集します．\n...\ncontext.properties = {\n    ## Configure properties in the system.\n    #library.name.system                   = support/libspa-support\n    #context.data-loop.library.name.system = support/libspa-support\n    #support.dbus                          = true\n    #link.max-buffers                      = 64\n    link.max-buffers                       = 16                       # version &lt; 3 clients can't handle more\n    #mem.warn-mlock                        = false\n    #mem.allow-mlock                       = true\n    #mem.mlock-all                         = false\n    #clock.power-of-two-quantum            = true\n    #log.level                             = 2\n    #cpu.zero.denormals                    = false\n\n    core.daemon = true              # listening for socket connections\n    core.name   = pipewire-0        # core name and socket name\n\n    ## Properties for the DSP configuration.\n    default.clock.rate          = 96000\n    default.clock.allowed-rates = [ 48000, 96000 ]\n    default.clock.quantum       = 1024\n    default.clock.min-quantum   = 32\n    default.clock.max-quantum   = 2048\n    default.clock.quantum-limit = 8192\n    default.clock.quantum-floor = 4\n    #default.video.width         = 640\n    #default.video.height        = 480\n    #default.video.rate.num      = 25\n    #default.video.rate.denom    = 1\n    #\n    #settings.check-quantum      = false\n    #settings.check-rate         = false\n    #\n    # These overrides are only applied when running in a vm.\n    vm.overrides = {\n        default.clock.min-quantum = 1024\n    }\n...\n編集後にサービスを再起動して設定を読み込ませます．\nsystemctl --user restart pipewire pipewire-pulse wireplumber\nもし接続が安定していればsampling frequencyを確認すると96kHzになっているはずです\n% pactl list sinks | grep -A 20 'Name: bluez'|grep \"Sample Specification:\"\n    Sample Specification: float32le 2ch 96000Hz\nただし，かならず96kHzとはなりません．あくまで最大96kHzであって，接続状態に応じて 48kHz になったります．\nLDAC encoding qualityの設定\nBit rateは，動画の1秒あたりのデータ量を示す値です． bps（bits per second）と表記され，1Mbpsに設定されている場合，1秒あたりデータ量が0.125MB（1byte＝8bit）の動画ということになります． ビットレートが高い動画ほど，データ量が多く高画質です．\nLDACのbit rateを高品質モードで安定させたい場合は，WirePlumber の Bluetooth 設定ファイル /usr/share/wireplumber/bluetooth.lua.d/50-bluez-config.lua を編集します． bluez5.a2dp.ldac.quality というフィールドがLDAC のエンコード品質を設定するオプションです．\n\n\n\n\n\n\n\n\n\n値\n説明\nビットレート\n\n\n\n\nauto\n適応ビットレート（Adaptive Bitrate），デフォルト\n変動\n\n\nhq\n高品質モード\n990 / 909 kbps\n\n\nsq\n標準品質モード\n660 / 606 kbps\n\n\nmq\nモバイル用低ビットレートモード\n330 / 303 kbps\n\n\n\n\nhq を設定すれば，理論上は最大 96 kHz のサンプルレートをフル品質で利用できるはずです．\nmatches = {\n      {\n        -- Matches all sources.\n        { \"node.name\", \"matches\", \"bluez_input.*\" },\n      },\n      {\n        -- Matches all sinks.\n        { \"node.name\", \"matches\", \"bluez_output.*\" },\n      },\n    },\n上記のセクションで [\"bluez5.a2dp.ldac.quality\"] = \"hq\",  -- LDAC HQ モード という設定をします．このセクションは\n\n\"bluez_input.*\": すべての Bluetooth 入力ノード（マイクなど）\n\"bluez_output.*\": すべての Bluetooth 出力ノード（ヘッドホンなど）\n\n正規表現で上記にマッチするすべてのノードに apply_properties を適用するという内容になります．従って，以下のような設定になります\n...\n  {\n    matches = {\n      {\n        -- Matches all sources.\n        { \"node.name\", \"matches\", \"bluez_input.*\" },\n      },\n      {\n        -- Matches all sinks.\n        { \"node.name\", \"matches\", \"bluez_output.*\" },\n      },\n    },\n    apply_properties = {\n      --[\"node.nick\"] = \"My Node\",\n      --[\"priority.driver\"] = 100,\n      --[\"priority.session\"] = 100,\n      --[\"node.pause-on-idle\"] = false,\n      --[\"resample.quality\"] = 4,\n      --[\"channelmix.normalize\"] = false,\n      --[\"channelmix.mix-lfe\"] = false,\n      --[\"session.suspend-timeout-seconds\"] = 5,  -- 0 disables suspend\n      --[\"monitor.channel-volumes\"] = false,\n\n      -- Media source role, \"input\" or \"playback\"\n      -- Defaults to \"playback\", playing stream to speakers\n      -- Set to \"input\" to use as an input for apps\n      --[\"bluez5.media-source-role\"] = \"input\",\n      [\"bluez5.a2dp.ldac.quality\"] = \"hq\",  -- LDAC HQ モード\n    },\n  },\n...\n上記実行後再びサービスを再起動しときます．\nsystemctl --user restart pipewire pipewire-pulse wireplumber\nすると以下のような接続状態になるはずです\n% pactl list sinks | grep -A 20 'Name: bluez'                             \n    Name: bluez_output.xx_xx_xx_xx_xx_xx.1\n    Description: WH-1000XM4\n    Driver: PipeWire\n    Sample Specification: float32le 2ch 96000Hz\n    Channel Map: front-left,front-right\n    Owner Module: 4294967295\n    Mute: no\n    Volume: front-left: 19609 /  30% / -31.44 dB,   front-right: 19609 /  30% / -31.44 dB\n            balance 0.00\n    Base Volume: 65536 / 100% / 0.00 dB\n    Monitor Source: bluez_output.xx_xx_xx_xx_xx_xx.1.monitor\n    Latency: 0 usec, configured 0 usec\n    Flags: HARDWARE HW_VOLUME_CTRL DECIBEL_VOLUME LATENCY \n    Properties:\n        allowed-rates = \"table: 0xxxxxxxxxxxxx\"\n        api.bluez5.address = \"xx:xx:xx:xx:xx:xx\"\n        api.bluez5.codec = \"ldac\"\n        api.bluez5.profile = \"a2dp-sink\"\n        api.bluez5.transport = \"\"\n        bluez5.a2dp.ldac.quality = \"hq\"\n        card.profile.device = \"1\"\n以上で設定は完了です．\n\n\n\n\n\n\nNote周波数は96kHzの方が本当に良いのか？\n\n\n\n48kHzに比べ96kHzは転送可能データ量は倍増しますが，その分Bluetooth 帯域の負荷が高くなります．そのため，音途切れが出やすくなります． 家や障害物の少ない環境なら良いとは思いますが，外出のときに使う場合は96kHzにこだわる必要はないと思います．また，そもそも論としてあくまでLDACは音楽を聞くためのcodecであって，通話とかのときは使えません．\n\n\n\nその他フィールドについて\nOwner Module\nOwner Moduleは，音源（Sink）や音声ノードを 所有している PipeWire モジュール の IDをしめすフィールドです．\nOwner Module: 4294967295\nとなってますが\n\\[\n4,294,967,295 = 2^{32} - 1\n\\]\nであることから特別な意味がありそうなことが推察できます．実際に，PipeWire / PulseAudio では 「所有者なし」 を表すフラグ的な値として扱われてます．\nPulseAudio / PipeWire における音量の内部表現\nBase Volume: 65536 / 100% / 0.00 dB という行があります．\n\\[\n65,536 = 2^{16}\n\\]\nで音量の最大値を示しています．PipeWire/pipewire Repository &gt; volume.h sourceの実装を確認してみると\ntypedef uint32_t pa_volume_t;\n\n#define PA_VOLUME_MUTED ((pa_volume_t) 0U)\n#define PA_VOLUME_NORM ((pa_volume_t) 0x10000U)\n#define PA_VOLUME_MAX ((pa_volume_t) UINT32_MAX/2)\nとなっており，音量は 32bit unsigned intとして扱われてますが，\n#define PA_VOLUME_NORM ((pa_volume_t) 0x10000U)\nで16bit 正規化 (0x10000) が基準となっていることも読み取れます．"
  },
  {
    "objectID": "posts/2025-09-18-wh1000xm4-setup/index.html#easyeffectsの導入",
    "href": "posts/2025-09-18-wh1000xm4-setup/index.html#easyeffectsの導入",
    "title": "Sony WH-1000XM4をUbuntu 24.04 LTSで使う",
    "section": "🎚️ EasyEffectsの導入",
    "text": "🎚️ EasyEffectsの導入\nヘッドホンは各製品ごとに個性が強く，同じ音源でも聞こえかたが異なります． 具体的には，ヘッドホンはその再生周波数特性が各製品ごとに異なり，その特性に応じて「ドンシャリ傾向」「かまぼこ傾向」「フラット傾向」の再生音となります．\n\n\n\n\n\n\n\n\n\n音傾向\n特徴\n向いている音楽ジャンル・用途\n\n\n\n\nドンシャリ\n低音と高音が強調される．低音が「ドンドン」，高音が「シャリシャリ」する派手な音．\nロック，EDM\n\n\nかまぼこ\n中音域が際立ち，低音・高音は抑えめ．ボーカルやメロディが前に出やすい．\nアコースティック，ボーカル重視の楽曲，バラード\n\n\nフラット\n周波数特性が均一に近く，原音忠実性が高い．録音やモニタリング用途に理想的．\nクラシック，ジャズ，音源分析\n\n\n\n\n\n\n\nsource: audio-technica &gt; ヘッドホン・イヤホンを識る\n\n\n無理に調整する必要はないですが，Linux環境でEqualizer調整したい場合はPipewire環境でも動作するEasyEffectsがおすすめです．\nEqualizerとは？\nイコライザーは音質傾向をリケーブルのように物理的にではなく，ソフトウェアで間接的に音質を変える手法です．\n\n音楽リスニングで好みの音質に調整\nヘッドホンでバーチャルサラウンド化\n\nという目的のために諒されます．Equalizer を使うと，各周波数帯（低音領域・中音領域・高温領域）の音量を個別に増減できます．\n\n\n\nEqualizer by EasyEffects\n\n\nEasy Effectsのインストール\napt packageで入れる場合は以下のコマンドでインストールします\n# apt package\nsudo apt install easyeffects\nEqualizer設定\n基本的には自分が理想とする音質に合わせて周波数ごとのゲインを調整します． 自分はAutoEQの周波数補正プリセットをベースラインとして少し自分好みに変更しました．\nselect headphonesのところに，Sony WH-1000XM4 (ANC Off)を入力すると以下のようなグラフがでてきます\n\n\n\nAutoEq\n\n\n\n\n\n\n\n\n\n\n用語\n説明\n\n\n\n\nRAW\n元のヘッドホン・スピーカーの周波数特性（補正前）\n\n\nTARGET\n理想の周波数特性（目標カーブ）\n\n\nEQUALIZED\nEQ 補正を適用した後の特性（RAW → TARGET に近づけた状態）\n\n\n\n\n31-band Graphic Eqをコピペして，ちょっと自分好みに編集します．その後以下の形式でtxtファイルを保存します．\nPreamp: 0db\nFilter 1: ON PK Fc 20 Hz Gain 0 dB Q 4.36\nFilter 2: ON PK Fc 25 Hz Gain 0 dB Q 4.36\nFilter 3: ON PK Fc 32 Hz Gain 0 dB Q 4.36\nFilter 4: ON PK Fc 40 Hz Gain 0 dB Q 4.36\nFilter 5: ON PK Fc 50 Hz Gain 0 dB Q 4.36\nFilter 6: ON PK Fc 63 Hz Gain 0 dB Q 4.36\nFilter 7: ON PK Fc 80 Hz Gain -0.2 dB Q 4.36\nFilter 8: ON PK Fc 101 Hz Gain 1.1 dB Q 4.36\nFilter 9: ON PK Fc 127 Hz Gain 0 dB Q 4.36\nFilter 10: ON PK Fc 160 Hz Gain 0 dB Q 4.36\nFilter 11: ON PK Fc 202 Hz Gain 0 dB Q 4.36\nFilter 12: ON PK Fc 254 Hz Gain -0.9 dB Q 4.36\nFilter 13: ON PK Fc 320 Hz Gain 0.7 dB Q 4.36\nFilter 14: ON PK Fc 403 Hz Gain 2.2 dB Q 4.36\nFilter 15: ON PK Fc 508 Hz Gain 0.3 dB Q 4.36\nFilter 16: ON PK Fc 640 Hz Gain 3 dB Q 4.36\nFilter 17: ON PK Fc 806 Hz Gain 2.3 dB Q 4.36\nFilter 18: ON PK Fc 1016 Hz Gain 0.8 dB Q 4.36\nFilter 19: ON PK Fc 1280 Hz Gain 1 dB Q 4.36\nFilter 20: ON PK Fc 1613 Hz Gain -1.1 dB Q 4.36\nFilter 21: ON PK Fc 2032 Hz Gain 0.5 dB Q 4.36\nFilter 22: ON PK Fc 2560 Hz Gain -1.1 dB Q 4.36\nFilter 23: ON PK Fc 3225 Hz Gain -0.7 dB Q 4.36\nFilter 24: ON PK Fc 4064 Hz Gain 2.2 dB Q 4.36\nFilter 25: ON PK Fc 5120 Hz Gain 1.7 dB Q 4.36\nFilter 26: ON PK Fc 6451 Hz Gain 0.2 dB Q 4.36\nFilter 27: ON PK Fc 8127 Hz Gain -3 dB Q 4.36\nFilter 28: ON PK Fc 10240 Hz Gain -0.4 dB Q 4.36\nFilter 29: ON PK Fc 12902 Hz Gain 2 dB Q 4.36\nFilter 30: ON PK Fc 16255 Hz Gain 4.7 dB Q 4.36\nFilter 31: ON PK Fc 20480 Hz Gain 10.7 dB Q 4.36\nそれをImport PresetのAPOから読み込ませれば完了です．気に入らなければtoggleでon/offできるのもEasyEffectsの良いところです．\n利用してるときにトラブルが発生した場合\nEasyEffectsを利用しているとき，たまに音声出力やEQ処理でフリーズしたりします． 自分が直面したケースだとPipeWire や Bluetooth 接続自体の問題ではなく，EasyEffects の GUI やプラグインが原因だったので， 実行中の EasyEffects プロセスを強制終了する形で対処しています．コマンドは以下\nkillall easyeffects"
  },
  {
    "objectID": "posts/2025-09-18-wh1000xm4-setup/index.html#appendix-1-bluetooth",
    "href": "posts/2025-09-18-wh1000xm4-setup/index.html#appendix-1-bluetooth",
    "title": "Sony WH-1000XM4をUbuntu 24.04 LTSで使う",
    "section": "Appendix 1: Bluetooth",
    "text": "Appendix 1: Bluetooth\n\nDefinition 1 Bluetooth\n\n2.54GHz帯の電波を使って通信する無線通信規格\n赤外線(IrDA)と異なり，インファーフェース部分を大勝利きに向ける必要はない\nWi-Fiのように高速通信ではないが，消費電力が少なく小型の機器に向いている\n\n\nBluetooth製品の規格で重要なのが「Version」「Class」「Profile」の三点．\n\n\n\n\n\n\n\n\n項目\n説明\n\n\n\n\nVersion\n通信方式や通信速度を規定したもの\n\n\nClass\n電波強度と最大通信距離を表す\n\n\nProfile\nBluetoothでやり取りするために通信ルール．音声ステレオ通信ならば「A2DP」，マウスやキーボードなどの入力装置ならば「HID」\n\n\n\n\n\nDefinition 2 Bluetooth Class\n\nBluetoothのクラスとは，電波の最大出力や到達距離を規定した名称\n最大通信距離によって「クラス1」，「クラス2」，「クラス3」の3つの種類に分けられています．\n\n\n\n\n\n\nクラスの種類\n最大出力\n通信最大距離\n\n\n\n\nクラス1\n100mW\n約100m\n\n\nクラス2\n2.5mW\n約10m\n\n\nクラス3\n1mW\n約1m\n\n\n\n\nなお日本国内では「クラス1」といえど10mWが限界のため最大値の1/10が最大出力です．"
  },
  {
    "objectID": "posts/2025-09-18-wh1000xm4-setup/index.html#appendix-2-bluetoothトラブルシューティング",
    "href": "posts/2025-09-18-wh1000xm4-setup/index.html#appendix-2-bluetoothトラブルシューティング",
    "title": "Sony WH-1000XM4をUbuntu 24.04 LTSで使う",
    "section": "Appendix 2: Bluetoothトラブルシューティング",
    "text": "Appendix 2: Bluetoothトラブルシューティング\nPipeWire音声サーバの再起動\nsystemctl --user restart pipewire pipewire-pulse\n\n「接続済みなのに音が出ない」，「Sink が認識されない」などのトラブルが発生したらまずこれ\n\nBlueetooth deviceの再接続\nBlueetooth device接続設定を以下の手順で完全リセット\n\nDisconnect\nRemove（ペアリング情報クリア）\nPair（再ペアリング）\nTrust & Connect（自動信頼・再接続）\n\nここでいう Trust は指定したデバイスを 信頼済み（Trusted） とマークすることで，信頼済みデバイスは自動接続可能．一方， 信頼していない場合は，毎回ユーザー承認が必要になります．\n#!/bin/bash\n# -----------------------------------------------------------------------------\n# Author: Ryo Nakagami\n# Revised: 2025-12-28\n# Script: bt_repair.sh\n# Description:\n#   Bluetooth device re-pairing script for troubleshooting connection issues.\n#   Completely removes and re-establishes the pairing with a Bluetooth device.\n#\n#   Steps:\n#     1. Disconnect the specified Bluetooth device\n#     2. Remove the device (clear pairing information)\n#     3. Re-pair with the device\n#     4. Trust and reconnect to the device\n#\n# Arguments:\n#   &lt;MAC_ADDRESS&gt;   Bluetooth device MAC address (e.g., 00:02:3C:8B:88:90)\n#\n# Usage:\n#   ./bt_repair.sh &lt;MAC_ADDRESS&gt;        # Re-pair with specified device\n#   ./bt_repair.sh 00:02:3C:8B:88:90    # Example with actual MAC address\n#   ./bt_repair.sh                      # Show usage and available devices\n#\n# Notes:\n#   - Requires bluetoothctl (part of bluez package) installed.\n#   - Device must be in pairing mode before running this script.\n#   - AutoEnable=true in /etc/bluetooth/main.conf is recommended.\n# -----------------------------------------------------------------------------\n\n# 引数チェック\nif [ -z \"$1\" ]; then\n    echo \"Usage: $0 &lt;MAC_ADDRESS&gt;\"\n    echo \"Example: $0 00:02:3C:8B:88:90\"\n    echo \"\"\n    echo \"Available devices:\"\n    bluetoothctl devices\n    exit 1\nfi\n\nDEVICE_MAC=\"$1\"\n\necho \"=== Bluetooth Re-pairing ===\"\necho \"MAC Address: ${DEVICE_MAC}\"\necho \"\"\n\n# 1. 接続解除\necho \"[1/4] Disconnecting...\"\nbluetoothctl disconnect \"${DEVICE_MAC}\" 2&gt;/dev/null\nsleep 1\n\n# 2. デバイス削除（ペアリング情報をクリア）\necho \"[2/4] Removing device...\"\nbluetoothctl remove \"${DEVICE_MAC}\" 2&gt;/dev/null\nsleep 2\n\n# 3. 再ペアリング\necho \"[3/4] Pairing...\"\necho \"※ デバイスがペアリングモードになっていることを確認してください\"\nbluetoothctl pair \"${DEVICE_MAC}\"\nsleep 2\n\n# 4. 接続\necho \"[4/4] Connecting...\"\nbluetoothctl trust \"${DEVICE_MAC}\"\nbluetoothctl connect \"${DEVICE_MAC}\"\n\necho \"\"\necho \"=== Complete ===\""
  },
  {
    "objectID": "posts/2025-09-18-wh1000xm4-setup/index.html#appendix-3-0x10000u-のprefixとsuffix",
    "href": "posts/2025-09-18-wh1000xm4-setup/index.html#appendix-3-0x10000u-のprefixとsuffix",
    "title": "Sony WH-1000XM4をUbuntu 24.04 LTSで使う",
    "section": "Appendix 3: 0x10000U のprefixとsuffix",
    "text": "Appendix 3: 0x10000U のprefixとsuffix\n0x10000U には 0x というprefixと U というsuffixが付いてます．\n\n0x: 続くdigitsが16進数(hexadecimal number)であることを表す\nU: unsignedを表す．つまり今回は unsigned integer\n\n従って，0x10000U は\n\\[\n65,536 = 1 \\times 16^4 + 0 \\times 16^3 + 0 \\times 16^2 + 0 \\times 16^1  + 0 \\times 16^0\n\\]\nとなります．\nC, C++で使用されるsuffix例\n\n\n\n\n\n\n\n\n\nvalue\nsuffix\nmeaning\n\n\n\n\n123\n\nデフォルトの整数型（通常 int）\n\n\n123u\nu\nunsigned int（符号なし整数）\n\n\n123l\nl\nlong（符号付き長整数，環境依存で32bit）\n\n\n123L\nL\nlong（符号付き長整数）\n\n\n123uL\nuL\nunsigned long（符号なし長整数）\n\n\n123LL\nLL\nlong long（符号付き64bit整数）\n\n\n123uLL\nuLL\nunsigned long long（符号なし64bit整数）\n\n\n\n\n% gcc check_numeric_type.c -o test && ./test\nType                 Bytes  Min                    Max                   \nint                  4      -2147483648            2147483647            \nshort                2      -32768                 32767                 \nlong                 8      -9223372036854775808   9223372036854775807   \nunsigned short       2      0                      65535                 \nunsigned long        8      0                      18446744073709551615  \nlong long            8      -9223372036854775808   9223372036854775807   \nunsigned long long   8      0                      18446744073709551615  \nfloat                4      -3.402823e+38          3.402823e+38          \ndouble               8      -1.797693e+308         1.797693e+308         \nlong double          16     -1.189731e+4932        1.189731e+4932 \nつまり，long long は 8 bytes(=64 bits)であることがわかります．"
  },
  {
    "objectID": "posts/2025-09-18-wh1000xm4-setup/index.html#references",
    "href": "posts/2025-09-18-wh1000xm4-setup/index.html#references",
    "title": "Sony WH-1000XM4をUbuntu 24.04 LTSで使う",
    "section": "References",
    "text": "References\n\nAutoEQ\naudio-technica &gt; ヘッドホン・イヤホンを識る\nWirePlumber setting\nPipeWire/pipewire Repository &gt; volume.h source\nRyo’s Tech Blog &gt; Sony WF-1000XM3 Bluetoothの設定"
  },
  {
    "objectID": "posts/2026-01-02-man-document/index.html",
    "href": "posts/2026-01-02-man-document/index.html",
    "title": "man ドキュメントの使い方メモ",
    "section": "",
    "text": "Note\n\n\n\n\nman はデフォルトでは less ページャーとして利用\n\n-P more で more を利用できる\n\n-N で行番号の表示\n3600g で3600行目へジャンプ\n/&lt;文字列&gt; で前方検索，n で次のマッチへ"
  },
  {
    "objectID": "posts/2026-01-02-man-document/index.html#tldr",
    "href": "posts/2026-01-02-man-document/index.html#tldr",
    "title": "man ドキュメントの使い方メモ",
    "section": "",
    "text": "Note\n\n\n\n\nman はデフォルトでは less ページャーとして利用\n\n-P more で more を利用できる\n\n-N で行番号の表示\n3600g で3600行目へジャンプ\n/&lt;文字列&gt; で前方検索，n で次のマッチへ"
  },
  {
    "objectID": "posts/2026-01-02-man-document/index.html#man-bash-のような-長い-man-ページで現在位置を把握したい",
    "href": "posts/2026-01-02-man-document/index.html#man-bash-のような-長い-man-ページで現在位置を把握したい",
    "title": "man ドキュメントの使い方メモ",
    "section": "1. man bash のような 長い man ページで現在位置を把握したい",
    "text": "1. man bash のような 長い man ページで現在位置を把握したい\n行番号の表示は，ページャー(デフォルトでは less) の機能を用いて実現できます．\n\n起動後に -N を入力すると，行番号表示のトグルとして使えます\n起動時から有効にしたい場合は man bash | less -N"
  },
  {
    "objectID": "posts/2026-01-02-man-document/index.html#直接指定した行へジャンプ",
    "href": "posts/2026-01-02-man-document/index.html#直接指定した行へジャンプ",
    "title": "man ドキュメントの使い方メモ",
    "section": "2. 直接指定した行へジャンプ",
    "text": "2. 直接指定した行へジャンプ\nless をページャとして用いる場合は\n基本操作\n\n&lt;行番号&gt;g: 指定行へ移動\nG: 最終行へ移動\ng: 先頭への移動"
  },
  {
    "objectID": "posts/2026-01-02-man-document/index.html#文字列検索",
    "href": "posts/2026-01-02-man-document/index.html#文字列検索",
    "title": "man ドキュメントの使い方メモ",
    "section": "3. 文字列検索",
    "text": "3. 文字列検索\n基本操作\n\n/pattern : 前方検索\n?pattern : 後方検索\nn : 次のマッチへ\nN : 前のマッチへ\n\n\nExample 1 \n.profile を含む行を検索する場合は\n/\\.profile\n. は正規表現なので，\\. とエスケープすることが必要\n\n\n\n\n\n\n\n\nNote前方検索 vs 後方検索\n\n\n\n\n前方検索: 現在位置から下に向かって検索．次にマッチの n は下に移動する\n後方検索: 現在位置から上方向 に向かって検索．次にマッチの n は上に移動する\n\nn, N は同じ方向・逆方向の次にマッチに相当します．"
  },
  {
    "objectID": "posts/2026-01-02-man-document/index.html#クリップボードへコピー",
    "href": "posts/2026-01-02-man-document/index.html#クリップボードへコピー",
    "title": "man ドキュメントの使い方メモ",
    "section": "4. クリップボードへコピー",
    "text": "4. クリップボードへコピー\n\n\n\n\n\n\nNoteクリップボードへコピーするコマンド\n\n\n\nln コマンドの man ページを，整形済みのプレーンテキストにして，クリップボードへコピーするコマンドは以下\n\n# 通常\nman ln | col -bx | xclip -selection clipboard\n\n# markdownへ変換したものをclipboardへ\nman ln | col -bx | pandoc -t markdown | xclip -selection clipboard\n\n処理の流れは以下\n\nman でマニュアルを表示\ncol -bx で余計な改行コードを整形\nxclip -selection clipboard でクリップボードへコピー\n\n\n\n\ncolコマンド\n\nDefinition 1 col コマンド\n\n行送り・バックスペース・制御文字を解釈して，再構成するフィルタ用コマンド\nman や tbl のような端末制御前提の出力を前処理する際に用いる\n\n\noptions\n\n\n\nオプション\n役割\n\n\n\n\n-b\nman 特有の太字・下線を完全除去\n\n\n-x\nタブをスペースにして崩れ防止\n\n\n\n\nExample 2 (pandoc を用いてPDF化) \nman ln | col -bx | pandoc -t pdf -o &lt;output-path&gt;\n他のフォーマットで出力したい場合は，pandoc --list-input-formats で出力可能形式を調べることができます．"
  },
  {
    "objectID": "posts/2026-01-02-man-document/index.html#appendix-less-vs-vim",
    "href": "posts/2026-01-02-man-document/index.html#appendix-less-vs-vim",
    "title": "man ドキュメントの使い方メモ",
    "section": "Appendix: less vs vim",
    "text": "Appendix: less vs vim\n移動\n\n\n\n操作\nless\nvim\n\n\n\n\n下へ1行\nj\nj\n\n\n上へ1行\nk\nk\n\n\n先頭へ\ng\ngg\n\n\n末尾へ\nG\nG\n\n\n指定行へ\n3600g\n:3600 / 3600G\n\n\n\n検索\n\n\n\n操作\nless\nvim\n\n\n\n\n前方検索\n/pattern\n/pattern\n\n\n後方検索\n?pattern\n?pattern\n\n\n次のマッチ\nn\nn\n\n\n前のマッチ\nN\nN\n\n\n\n表示\n\n\n\n操作\nless\nvim\n\n\n\n\n行番号表示\n-N\n:set number\n\n\n行番号OFF\n-N\n:set nonumber"
  },
  {
    "objectID": "posts/2025-04-30-css-unit/index.html",
    "href": "posts/2025-04-30-css-unit/index.html",
    "title": "CSSで使う単位",
    "section": "",
    "text": "NoteCSSで使用する単位一覧\n\n\n\n\n\n\n\n ▶  相対単位\n\n\n\n\n\n\n\n\npx\nモニターの画素(ピクセル)を1とする単位\n\n\n%\n%で割合を指定\n\n\nem\n親要素の大文字Mのフォントサイズを1とする単位\n\n\nex\n親要素の小文字xフォントサイズを1とする単位\n\n\nrem\nルート要素の大文字のフォントサイズを1とする単位\n\n\n\n\n\n ▶  絶対単位\n\n\n\n\n\n\n\n\npt\n1/72インチを1とする単位\n\n\npc\n12ptを1とする単位\n\n\nmm\nミリメートル基準\n\n\ncm\nセンチメートル基準\n\n\nin\nインチを1とする単位\n▶  emの使いどころ\nユーザー環境によってフォントのサイズが変わってしまうWebデザインにおいて，\nといったその時々のフォントサイズに応じたサイズ指定を試みたい場合に，親要素の文字の大きさを単位とするemが役に立ちます．"
  },
  {
    "objectID": "posts/2025-04-30-css-unit/index.html#emとremの違い",
    "href": "posts/2025-04-30-css-unit/index.html#emとremの違い",
    "title": "CSSで使う単位",
    "section": "emとremの違い",
    "text": "emとremの違い\nemもremも相対単位となりますが，remは常に最上位のルート要素のフォントサイズを規準に計算されるという特徴があります．活用例として，remは要素が入れ子になるような場合に，意図せずサイズが変更されるようなリスクを低減することができます．\n\n\n\n\n\n\n\nNotehtml code example\n\n\n\n\n\n&lt;style&gt;\n  html {\n    font-size: 16px; /* 1rem = 16px */\n  }\n\n  li.em-example {\n    font-size: 1.5em; /* 1.5 × 20px = 30px */\n    color: steelblue;\n  }\n\n  li.rem-example {\n    font-size: 1.5rem; /* 1.5 × 16px = 24px */\n    color: darkorange;\n  }\n&lt;/style&gt;\n\n&lt;ul&gt;\n    &lt;li class=\"em-example\"&gt;This text uses &lt;code&gt;1.5em&lt;/code&gt; font size&lt;/li&gt;\n    &lt;li class=\"em-example\"&gt;This text uses &lt;code&gt;1.5em&lt;/code&gt; font size\n        &lt;ul&gt;\n            &lt;li class=\"em-example\"&gt;This text uses &lt;code&gt;1.5em&lt;/code&gt; (relative to &lt;code&gt;&lt;ul&gt;&lt;/code&gt; font size)&lt;/li&gt;\n    &lt;/li&gt;\n&lt;/ul&gt;\n\n\n&lt;ul&gt;\n    &lt;li class=\"rem-example\"&gt;This text uses &lt;code&gt;1.5rem&lt;/code&gt; font size&lt;/li&gt;\n    &lt;li class=\"rem-example\"&gt;This text uses &lt;code&gt;1.5rem&lt;/code&gt; font size\n        &lt;ul&gt;\n            &lt;li class=\"rem-example\"&gt;This text uses &lt;code&gt;1.5rem&lt;/code&gt; (relative to &lt;code&gt;&lt;ul&gt;&lt;/code&gt; font size)&lt;/li&gt;\n        &lt;/ul&gt;\n    &lt;/li&gt;\n&lt;/ul&gt;\n\n\n\n ▶  emの挙動\n\n\n\n    This text uses 1.5em font size\n    This text uses 1.5em font size\n        \n            This text uses 1.5em (relative to &lt;ul&gt; font size)\n    \n  \n\n ▶  remの挙動\n\n\n\n    This text uses 1.5rem font size\n    This text uses 1.5rem font size\n        \n            This text uses 1.5rem (relative to &lt;ul&gt; font size)\n        \n    \n  \n\n\n\n\n\n\nNotekey takeaways\n\n\n\n\nemでは入れ子構造となってる&lt;li&gt;セクションについて，直前のフォントサイズ 1.5emにたいして更に 1.5em でフォントサイズを計算している\nremでは入れ子構造となってる&lt;li&gt;セクションでも，ルート要素フォントサイズ16pxを参照して, 1.5remを計算している"
  },
  {
    "objectID": "posts/2021-05-07-linux-system-clock/index.html",
    "href": "posts/2021-05-07-linux-system-clock/index.html",
    "title": "[過去ブログからの転記] Linuxにおける時刻管理",
    "section": "",
    "text": "Definition 1 システムクロック\n\nOSが内部に持っている時計をシステムクロックという\nファイルのタイムスタンプやプロセスやカーネルログの記録などに使用される\nシステムクロック自体はUTCで管理される\nハードウェアクロック(CMOS Clock)とは別物\n\n\nLinuxシステムの時刻はシステムクロックによって管理されています．このシステムクロックは date コマンドで確認することができます\n## Local timezone\n$ date\nSat May 30 08:19:29 PM JST 2020\n\n## UTC timezone\n$ date -u\nSat May 30 11:19:29 AM UTC 2020\n\n$ date --utc\nSat May 30 11:19:29 AM UTC 2020\n\n## 一時的にNewYork TZ\n$ TZ=New_York date\nThu Jan 29 05:54:45 PM New 2026\n\n## Unixエポックの日時表示\n$ date -d @1769729151\nFri Jan 30 08:25:51 AM JST 2026\nシステムクロックはLinuxカーネルのメモリ上に次の２つのデータの組として保持されています:\n\nUnixエポック(1970-01-01 00:00:00)からの経過秒数\n現在秒からの経過ナノ秒数\n\nそして，インターバルタイマーの割り込みにより時計が進みます．\n\nExample 1 (C言語によるシステムクロックの直接参照) \nシステムクロックはカーネル内で「Unixエポックからの経過秒数」と「ナノ秒」の組として保持されています． C言語の clock_gettime 関数（システムコール本体ではなくPOSIXが定義する時刻取得API）を使用すると，ライブラリおよびシステムコールを介して，カーネルメモリ上のこの生の値を直接取得できます\ncat &lt;&lt;'EOF' | gcc -x c - -o cgt && ./cgt && rm -f cgt\n#include &lt;time.h&gt;   // clock_gettime, struct timespec の定義\n#include &lt;stdio.h&gt;\n\nint main() {\n    struct timespec ts;\n    /*\n     * clock_gettime()\n     *\n     * 関連するシステムコール:\n     *   - SYS_clock_gettime        (32bit time_t 環境)\n     *   - SYS_clock_gettime64      (64bit time_t / Y2038 対応)\n     *\n     * 引数1: CLOCK_REALTIME\n     *   - Unix Epoch (1970-01-01 00:00:00 UTC) からの実時間\n     *   - NTP 等により前後に補正される可能性あり\n     *\n     * 引数2: &ts\n     *    - 結果を格納する構造体のポインタ \n     */\n    clock_gettime(CLOCK_REALTIME, &ts);\n\n    /* \n      ts.tv_sec : Unixエポックからの経過秒数\n      ts.tv_nsec: 現在秒からの経過ナノ秒数\n    */\n    printf(\"%ld %ld\\n\", ts.tv_sec, ts.tv_nsec);\n}\nEOF\n上記をターミナルで実行すると 1769729151 441034261 という形式で，現在のシステムクロックの状態が出力されます．\n\n1769729151 : Unixエポックからの経過秒数\n441034261 : 現在の秒数内でのナノ秒単位の経過（\\(0 \\sim 999,999,999\\)）\n\n\n\n\n\n\n\n\n\nNoteタイムゾーン情報\n\n\n\n各タイムゾーンの時差情報は /usr/share/zoneinfo ディレクトリに格納されています．Linuxシステムインストール時に，指定されたタイムゾーンに従って， etc/localtime に /usr/share/zoneinfo 以下のタイムゾーンファイルへのシンボリックリンクが貼られ，この情報に従って，date コマンドの表示が ローカルタイムゾーン換算に変更されます．\n$ ls -l /etc/localtime\nlrwxrwxrwx 1 root root 30 May 29  2025 /etc/localtime -&gt; /usr/share/zoneinfo/Asia/Tokyo\n\n\nTZ 変数によるシステムタイムゾーンの上書き\nTZ変数は，プロセスだけ別の時計を持たせるための環境変数です．\n$ date\nSat Jan 31 10:31:39 PM JST 2026\n\n$ TZ=Asia/Tokyo date\nSat Jan 31 10:31:56 PM JST 2026\n\n$ TZ=UTC date\nSat Jan 31 01:32:06 PM UTC 2026\n\n$ date\nSat Jan 31 10:32:25 PM JST 2026\n設定可能なタイムゾーン一覧の確認は，systemd環境ならば\ntimedatectl list-timezones\nで確認することができます．\ntzselect: 対話的に TZ 環境変数を決める\ntzselect コマンドは，対話形式でタイムゾーンを選択するコマンドです． コマンドを実行しても，etc/localtime は変更されず，あくまで TZ 環境変数が設定されるだけです．\n実行例は以下\n$ tzselect\nPlease identify a location so that time zone rules can be set correctly.\nPlease select a continent, ocean, \"coord\", or \"TZ\".\n 1) Africa\n 2) Americas\n 3) Antarctica\n 4) Asia\n 5) Atlantic Ocean\n 6) Australia\n 7) Europe\n 8) Indian Ocean\n 9) Pacific Ocean\n10) coord - I want to use geographical coordinates.\n11) TZ - I want to specify the timezone using the Posix TZ format.\n#? 4\nPlease select a country whose clocks agree with yours.\n 1) Afghanistan          30) Kyrgyzstan\n 2) Antarctica           31) Laos\n 3) Armenia          32) Lebanon\n 4) Australia            33) Macau\n 5) Azerbaijan           34) Malaysia\n 6) Bahrain          35) Mongolia\n 7) Bangladesh           36) Myanmar (Burma)\n 8) Bhutan           37) Nepal\n 9) Brunei           38) Oman\n10) Cambodia             39) Pakistan\n11) China            40) Palestine\n12) Christmas Island         41) Philippines\n13) Cocos (Keeling) Islands  42) Qatar\n14) Cyprus           43) Réunion\n15) East Timor           44) Russia\n16) French S. Terr.      45) Saudi Arabia\n17) Georgia          46) Seychelles\n18) Hong Kong            47) Singapore\n19) India            48) Sri Lanka\n20) Indonesia            49) Syria\n21) Iran             50) Taiwan\n22) Iraq             51) Tajikistan\n23) Israel           52) Thailand\n24) Japan            53) Turkmenistan\n25) Jordan           54) United Arab Emirates\n26) Kazakhstan           55) Uzbekistan\n27) Korea (North)        56) Vietnam\n28) Korea (South)        57) Yemen\n29) Kuwait\n#? 24\n\nThe following information has been given:\n\n    Japan\n    Eyre Bird Observatory\n\nTherefore TZ='Asia/Tokyo' will be used.\nSelected time is now:   Sat Jan 31 10:39:05 PM JST 2026.\nUniversal Time is now:  Sat Jan 31 01:39:05 PM UTC 2026.\nIs the above information OK?\n1) Yes\n2) No\n#? 1\n\nYou can make this change permanent for yourself by appending the line\n    TZ='Asia/Tokyo'; export TZ\nto the file '.profile' in your home directory; then log out and log in again.\n\nHere is that TZ value again, this time on standard output so that you\ncan use the /usr/bin/tzselect command in shell scripts:\nAsia/Tokyo"
  },
  {
    "objectID": "posts/2021-05-07-linux-system-clock/index.html#システムクロック",
    "href": "posts/2021-05-07-linux-system-clock/index.html#システムクロック",
    "title": "[過去ブログからの転記] Linuxにおける時刻管理",
    "section": "",
    "text": "Definition 1 システムクロック\n\nOSが内部に持っている時計をシステムクロックという\nファイルのタイムスタンプやプロセスやカーネルログの記録などに使用される\nシステムクロック自体はUTCで管理される\nハードウェアクロック(CMOS Clock)とは別物\n\n\nLinuxシステムの時刻はシステムクロックによって管理されています．このシステムクロックは date コマンドで確認することができます\n## Local timezone\n$ date\nSat May 30 08:19:29 PM JST 2020\n\n## UTC timezone\n$ date -u\nSat May 30 11:19:29 AM UTC 2020\n\n$ date --utc\nSat May 30 11:19:29 AM UTC 2020\n\n## 一時的にNewYork TZ\n$ TZ=New_York date\nThu Jan 29 05:54:45 PM New 2026\n\n## Unixエポックの日時表示\n$ date -d @1769729151\nFri Jan 30 08:25:51 AM JST 2026\nシステムクロックはLinuxカーネルのメモリ上に次の２つのデータの組として保持されています:\n\nUnixエポック(1970-01-01 00:00:00)からの経過秒数\n現在秒からの経過ナノ秒数\n\nそして，インターバルタイマーの割り込みにより時計が進みます．\n\nExample 1 (C言語によるシステムクロックの直接参照) \nシステムクロックはカーネル内で「Unixエポックからの経過秒数」と「ナノ秒」の組として保持されています． C言語の clock_gettime 関数（システムコール本体ではなくPOSIXが定義する時刻取得API）を使用すると，ライブラリおよびシステムコールを介して，カーネルメモリ上のこの生の値を直接取得できます\ncat &lt;&lt;'EOF' | gcc -x c - -o cgt && ./cgt && rm -f cgt\n#include &lt;time.h&gt;   // clock_gettime, struct timespec の定義\n#include &lt;stdio.h&gt;\n\nint main() {\n    struct timespec ts;\n    /*\n     * clock_gettime()\n     *\n     * 関連するシステムコール:\n     *   - SYS_clock_gettime        (32bit time_t 環境)\n     *   - SYS_clock_gettime64      (64bit time_t / Y2038 対応)\n     *\n     * 引数1: CLOCK_REALTIME\n     *   - Unix Epoch (1970-01-01 00:00:00 UTC) からの実時間\n     *   - NTP 等により前後に補正される可能性あり\n     *\n     * 引数2: &ts\n     *    - 結果を格納する構造体のポインタ \n     */\n    clock_gettime(CLOCK_REALTIME, &ts);\n\n    /* \n      ts.tv_sec : Unixエポックからの経過秒数\n      ts.tv_nsec: 現在秒からの経過ナノ秒数\n    */\n    printf(\"%ld %ld\\n\", ts.tv_sec, ts.tv_nsec);\n}\nEOF\n上記をターミナルで実行すると 1769729151 441034261 という形式で，現在のシステムクロックの状態が出力されます．\n\n1769729151 : Unixエポックからの経過秒数\n441034261 : 現在の秒数内でのナノ秒単位の経過（\\(0 \\sim 999,999,999\\)）\n\n\n\n\n\n\n\n\n\nNoteタイムゾーン情報\n\n\n\n各タイムゾーンの時差情報は /usr/share/zoneinfo ディレクトリに格納されています．Linuxシステムインストール時に，指定されたタイムゾーンに従って， etc/localtime に /usr/share/zoneinfo 以下のタイムゾーンファイルへのシンボリックリンクが貼られ，この情報に従って，date コマンドの表示が ローカルタイムゾーン換算に変更されます．\n$ ls -l /etc/localtime\nlrwxrwxrwx 1 root root 30 May 29  2025 /etc/localtime -&gt; /usr/share/zoneinfo/Asia/Tokyo\n\n\nTZ 変数によるシステムタイムゾーンの上書き\nTZ変数は，プロセスだけ別の時計を持たせるための環境変数です．\n$ date\nSat Jan 31 10:31:39 PM JST 2026\n\n$ TZ=Asia/Tokyo date\nSat Jan 31 10:31:56 PM JST 2026\n\n$ TZ=UTC date\nSat Jan 31 01:32:06 PM UTC 2026\n\n$ date\nSat Jan 31 10:32:25 PM JST 2026\n設定可能なタイムゾーン一覧の確認は，systemd環境ならば\ntimedatectl list-timezones\nで確認することができます．\ntzselect: 対話的に TZ 環境変数を決める\ntzselect コマンドは，対話形式でタイムゾーンを選択するコマンドです． コマンドを実行しても，etc/localtime は変更されず，あくまで TZ 環境変数が設定されるだけです．\n実行例は以下\n$ tzselect\nPlease identify a location so that time zone rules can be set correctly.\nPlease select a continent, ocean, \"coord\", or \"TZ\".\n 1) Africa\n 2) Americas\n 3) Antarctica\n 4) Asia\n 5) Atlantic Ocean\n 6) Australia\n 7) Europe\n 8) Indian Ocean\n 9) Pacific Ocean\n10) coord - I want to use geographical coordinates.\n11) TZ - I want to specify the timezone using the Posix TZ format.\n#? 4\nPlease select a country whose clocks agree with yours.\n 1) Afghanistan          30) Kyrgyzstan\n 2) Antarctica           31) Laos\n 3) Armenia          32) Lebanon\n 4) Australia            33) Macau\n 5) Azerbaijan           34) Malaysia\n 6) Bahrain          35) Mongolia\n 7) Bangladesh           36) Myanmar (Burma)\n 8) Bhutan           37) Nepal\n 9) Brunei           38) Oman\n10) Cambodia             39) Pakistan\n11) China            40) Palestine\n12) Christmas Island         41) Philippines\n13) Cocos (Keeling) Islands  42) Qatar\n14) Cyprus           43) Réunion\n15) East Timor           44) Russia\n16) French S. Terr.      45) Saudi Arabia\n17) Georgia          46) Seychelles\n18) Hong Kong            47) Singapore\n19) India            48) Sri Lanka\n20) Indonesia            49) Syria\n21) Iran             50) Taiwan\n22) Iraq             51) Tajikistan\n23) Israel           52) Thailand\n24) Japan            53) Turkmenistan\n25) Jordan           54) United Arab Emirates\n26) Kazakhstan           55) Uzbekistan\n27) Korea (North)        56) Vietnam\n28) Korea (South)        57) Yemen\n29) Kuwait\n#? 24\n\nThe following information has been given:\n\n    Japan\n    Eyre Bird Observatory\n\nTherefore TZ='Asia/Tokyo' will be used.\nSelected time is now:   Sat Jan 31 10:39:05 PM JST 2026.\nUniversal Time is now:  Sat Jan 31 01:39:05 PM UTC 2026.\nIs the above information OK?\n1) Yes\n2) No\n#? 1\n\nYou can make this change permanent for yourself by appending the line\n    TZ='Asia/Tokyo'; export TZ\nto the file '.profile' in your home directory; then log out and log in again.\n\nHere is that TZ value again, this time on standard output so that you\ncan use the /usr/bin/tzselect command in shell scripts:\nAsia/Tokyo"
  },
  {
    "objectID": "posts/2021-05-07-linux-system-clock/index.html#ハードウェアクロック",
    "href": "posts/2021-05-07-linux-system-clock/index.html#ハードウェアクロック",
    "title": "[過去ブログからの転記] Linuxにおける時刻管理",
    "section": "ハードウェアクロック",
    "text": "ハードウェアクロック\n\nDefinition 2 ハードウェアクロック\n\nハードウェアクロックは，マザーボード上のICによって提供される時計\nバッテリーのバックアップがあるので，PCの電源を切っても時計が進む\nRTC（Real Time Clock）あるいはCMOSクロックとも呼ばれる\n\n\nRTCはCMOSメモリ上にデータを保持しています．ハードウェアクロックの時刻はLinuxシステム立ち上げ時にhwclockコマンドで読み取られ，システムクロックに設定されます． また, システムの停止時に，hwclock コマンドによってシステムクロックの時刻がハードウェアクロックに設定されます.\n\n\n\n\n\nsequenceDiagram\n    participant HW as hardware clock\n    participant IT as interval timer\n    participant SC as system clock\n    participant NTP\n\n    HW-&gt;&gt;SC: boot時に&lt;br&gt;hardware clockを反映\n    NTP-&gt;&gt;SC: NTPによる時刻同期\n    IT-&gt;&gt;SC: 割り込みにより&lt;br&gt;system clockを進める\n    SC-&gt;&gt;HW: システム停止時に&lt;br&gt;system clockを反映\n\n\n\n\n\n\n\nhwclockコマンド\nハードウェアクロック操作に関係するコマンド hwclock は /dev/rtc デバイスを open() し，RTCのread/writeを行います．\n$ ls -l /dev/rtc \nlrwxrwxrwx 1 root root 4 Jan 31 21:39 /dev/rtc -&gt; rtc0\n\n$ ls -l /dev/rtc0\ncrw------- 1 root root 248, 0 Jan 31 21:39 /dev/rtc0\nとなっているため，hwclock を用いたRTC表示などにはスーパーユーザー権限が必要であることがわかります．\n\n\n\n\n\n\n\n\n\nコマンド\n方向\n何をするか\n\n\n\n\nsudo hwclock --show\nRTC → 表示\nハードウェアクロック（RTC）の現在値を表示\n\n\nsudo hwclock --systohc\nsystem → RTC\nシステムクロックの時刻をハードウェアクロックに書き込む\n\n\nsudo hwclock --hctosys\nRTC → system\nハードウェアクロックの時刻をシステムクロックに反映"
  },
  {
    "objectID": "posts/2021-05-07-linux-system-clock/index.html#network-time-protocal",
    "href": "posts/2021-05-07-linux-system-clock/index.html#network-time-protocal",
    "title": "[過去ブログからの転記] Linuxにおける時刻管理",
    "section": "Network Time Protocal",
    "text": "Network Time Protocal\n\n\n\n\n\n\nNote現在の Ubuntu / systemd 環境では標準的には使われていない\n\n\n\n\nUbuntu 16.04以降では timedatectl/timesync が ntpdate/ntp の代わりに用いられている\nntpdate はデフォルトではインストールされていない場合が多い\n\n\n\n\nDefinition 3 Network Time Protocol\n\nNTPはコンピュータが，ネットワーク上のほかのコンピュータの時刻を参照して時刻の同期を取るためのプロトコル\n時刻をstratumと呼ばれる階層で管理し，原子時計/GPS/標準電波などのレファレンスクロックが最上位の階層stratum0になり，最下位の階層stratum16まで階層化できる\nNTPデーモンやコマンドにより，システムクロックを設定できる\n\n\n原子時計/GPS/標準電波が最上位の階層stratum0になり，それを時刻源とするNTPサーバがstratum1となります． stratum1のNTPサーバから時刻を受信するコンピュータ（NTPサーバあるいはNTPクライアント）はstratum2となります.\n\n\n\nNTPとstratum\n\n\nNTPクライアントとNTPサーバー\n\n\n\n\n\n\n\n\n項目\nNTPクライアント\nNTPサーバー\n\n\n\n\n役割\n時刻を取得し、自身の時刻を同期・補正する\n正確な時刻を他のノードへ提供する\n\n\n時刻の参照先\n上位 stratum の NTPサーバー\n上位 stratum、またはレファレンスクロック\n\n\nstratum\nサーバーより下位（数値が大きい）\n上位（数値が小さい）\n\n\n主な実装\nsystemd-timesyncd, ntpdate\nntpd\n\n\n\n\nNTPによる時刻修正方法\n\nDefinition 4 ntpdate コマンド\n\nntpdateコマンドは，NTPクライアントプログラムで，日付と時刻を NTP サーバーと同期することができる\nkernelが管理するシステムクロックを変更するコマンドなので，実行にはroot権限が必要\n基本的には，Step方式で時刻修正がされる\n\nsudo ntpdate [option] NTP-server\n\nNTPによる時刻修正は Slew と Step の2種類があります．\n\n\n\n\n\n\n\n\n\n項目\nslew（徐々に補正）\nstep（即時補正）\n\n\n\n\n補正方法\nクロックの進み方を少しずつ調整\n時刻を一気にジャンプさせる\n\n\n時刻の連続性\n✅ 保たれる\n❌ 失われる\n\n\nシステムへの影響\n小さい\n大きい\n\n\nログ・ジョブへの影響\nほぼなし\n時刻逆行・重複の可能性あり\n\n\n\n\nntpdate コマンドでは基本的には Step方式で時刻修正がされます．\n## 強制step\nsudo ntpdate -b ntp.ubuntu.com\n\n## 擬似的Slew修正\nsudo ntpdate -B ntp.ubuntu.com\n厳密には，-B オプションによる修正は，Slew方式修正ではなくカーネル PLL による周波数補正になります．\nNTPサーバーとシステムクロックのオフセット確認\nNTPサーバーとシステムクロックの差分(offset)を確認するには，ntpdate -q コマンドを用います．\n$ sudo ntpdate -q ntp.nict.jp\n31 MAy 02:19:09 ntpdate[5393]: step time server 133.243.238.243\noffset 99.535574 sec\n今回の例では約99秒ほどsystem clockが遅れていることがわかります．先行している場合は-(マイナス)で表現されます．\nNTPサーバーはDNS名で指定する\nsudo ntpdate [option] NTP-server の NTP-server部分はDNS名（ホスト名）による指定が推奨されます． timedatectl timesync-status の出力を確認すると\n% timedatectl timesync-status\n       Server: 2620:2d:4000:1::41 (ntp.ubuntu.com)\nPoll interval: 17min 4s (min: 32s; max 34min 8s)\n         Leap: normal\n...\n実際に通信しているのは 2620:2d:4000:1::41 ですが，DNS 名 ntp.ubuntu.com から解決されたものです． ntp.ubuntu.com を nslookup すると\n$ nslookup ntp.ubuntu.com\nServer:     127.0.0.53\nAddress:    127.0.0.53#53\n\nNon-authoritative answer:\nName:   ntp.ubuntu.com\nAddress: 185.125.190.57\nName:   ntp.ubuntu.com\nAddress: 185.125.190.58\nName:   ntp.ubuntu.com\nAddress: 91.189.91.157\nName:   ntp.ubuntu.com\nAddress: 185.125.190.56\nName:   ntp.ubuntu.com\nAddress: 2620:2d:4000:1::3f\nName:   ntp.ubuntu.com\nAddress: 2620:2d:4000:1::41\nName:   ntp.ubuntu.com\nAddress: 2620:2d:4000:1::40\nntp.ubuntu.com は1台ではないことがわかります．ntp.ubuntu.com はNTPサーバープールであり，複数の独立した NTP サーバーから構成されています． なお，ntp.ubuntu.com はCanonicalが運用管理しているNTPプールです．\nNTPサーバーは，一般的に，複数のサーバーによるDNSラウンドロビン(問い合わせのたびに順繰りに異なったIPアドレスを返す仕組み)によってサーバーの負荷分散を行っています． そのため，NTPを用いるときはDNS名（ホスト名）を指定することが推奨されています．\n\n\nntpd を用いた時刻調整\n\nDefinition 5 ntpd\n\nntpd はNTPにより時刻の動機を取るデーモン\n設定ファイル /etc/ntp.confで指定されたサーバーに，指定された感覚でとう合わせを行い時刻調整を行う\n現在では chronyd デーモンにとって代わられている\n\n\n設定医ファイル /etc/ntp.conf は\n$ cat /etc/ntp.conf\n\n# /etc/ntp.conf, configuration for ntpd\ndriftfile /var/lib/ntp/ntp.drift\nstatsdir /var/log/ntpstats/\n\n# You do need to talk to an NTP server or two (or three).\n#server ntp.ubuntu.com\nserver ntp.nict.jp iburst\n\n#localhostをNTPサーバに設定 & アクセス制限なし\nrestrict 127.0.0.1\n\n\n\n\n\n\n\n\nconfiguration\n説明\n\n\n\n\ndriftfile\nntpd が時刻の調整を行う際に NTP サーバーから入手した時刻と ntpd が動作しているマシンとの時刻のずれを記録するファイルを指定\n\n\nserver\n時刻を同期する NTP サーバーを指定\n\n\nstatsdir\n統計ログファイルを指定\n\n\nrestrict\naccess control listの指定. 「誰からのNTP通信を許す／拒否するか」を決める\n\n\n\n\niburst オプション\niburst は server コマンドと組みわせて使用するオプションで，指定時にはNTPサーバーとの初期同期時に 2秒間隔で8個のパケットを送信して同期を取ります = 初期の同期にかかる時間を短縮します． iburst を指定しない場合，ntpd は起動直後から「通常の poll 制御」に入り，minpoll（デフォルト 6 = 64秒）間隔で問い合わせをします．\nrestrict コマンド\nrestrict default kod nomodify nopeer noquery\nrestrict 127.0.0.1\nと指定した場合，\n\n\n\n\n\n\n\n\n\n要素\n対象\n効果\n\n\n\n\nrestrict default\n全外部ホスト\nこのルールを適用\n\n\nkod\n過剰アクセス元\nKiss-of-Death を返す（DoS / 過負荷防止）\n\n\nnomodify\n外部\n設定変更・時刻強制変更を禁止\n\n\nnopeer\n外部\npeer 化を禁止(踏み台化防止)\n\n\nnoquery\n外部\n状態取得を禁止\n\n\n\n\nrestrict 127.0.0.1 は何も制限がないという設定になります．\n複数のサーバーの指定\nserver 0.jp.pool.ntp.org\nserver 1.jp.pool.ntp.org\nserver 2.jp.pool.ntp.org\nserver 3.jp.pool.ntp.org\nのように複数の日本国内のプールを指定することができます．複数指定する目的として，「精度のため」＋「安全のため」があります． 1台の時刻は信用しない，というのが基本思想になります．\nntpq コマンド\n\nDefinition 6 ntpq コマンド\n\nnep queryの略\nntpd が現在どのように時刻同期を行っているかを確認するための管理コマンド\nntpq -p or ntpq --peers を実行することで，参照している NTP サーバー一覧と，その状態を表示\n\n\n$ ntpq -p\n     remote           refid      st t when poll reach   delay   offset  jitter\n==============================================================================\n*ntp-b2.nict.go. .NICT.           1 u    1   64  377   91.074   20.475  82.456\n LOCAL(0)        .LOCL.          10 l   57   64  377    0.000    0.000   0.001\n\n\n\n\n\n\n\n\n\n列名\n意味\n見るポイント\n\n\n\n\nremote\nNTPサーバー名\n/etc/ntp.conf で指定したサーバー\n\n\n* +\n同期状態\n*: 現在採用中のサーバー． +: 候補として有効 -: 候補から除外\n\n\nwhen\n次の問い合わせまでの残り秒\n動いていればカウントダウンする\n\n\npoll\nポーリング間隔（秒）\n64, 128 など\n\n\nreach\n到達履歴（8回分）\n377 なら安定\n\n\ndelay\n通信遅延（ms）\n小さいほど良い\n\n\noffset\nサーバーとの差（ms）\n0に近いほど良い\n\n\njitter\n揺らぎ\n小さいほど安定"
  },
  {
    "objectID": "posts/2021-05-07-linux-system-clock/index.html#ubuntuにおけるntp-server時刻同期",
    "href": "posts/2021-05-07-linux-system-clock/index.html#ubuntuにおけるntp-server時刻同期",
    "title": "[過去ブログからの転記] Linuxにおける時刻管理",
    "section": "UbuntuにおけるNTP server時刻同期",
    "text": "UbuntuにおけるNTP server時刻同期\n\n\n\n\n\n\nNote\n\n\n\n\nデフォルトでは systemd-timesyncd が使用される\nchrony がインストールされている場合は，chronyが時刻同期を担当する挙動になる\n\nNTPデーモンは，ntpd, chronyd, systemd-timesyncd のどれか１つしか用いない(複数起動はダメ)\n\n\n\n\nデフォルトでは systemd-timesyncd がNTPクライアントとして有効になっています．\n$ timedatectl status\n               Local time: Sun 2026-02-01 01:57:15 JST\n           Universal time: Sat 2026-01-31 16:57:15 UTC\n                 RTC time: Sat 2026-01-31 16:57:15\n                Time zone: Asia/Tokyo (JST, +0900)\nSystem clock synchronized: yes\n              NTP service: active\n          RTC in local TZ: no\n設定ファイルは /etc/systemd/timesyncd.conf に存在します．\ntimedatectl timesync-status\ntimedatectl timesync-status は ntpq に対応するコマンドです．\n$ timedatectl timesync-status\n       Server: 2620:2d:4000:1::41 (ntp.ubuntu.com)\nPoll interval: 34min 8s (min: 32s; max 34min 8s)\n         Leap: normal\n      Version: 4\n      Stratum: 2\n    Reference: B7A08584\n    Precision: 1us (-25)\nRoot distance: 785us (max: 5s)\n       Offset: +38.605ms\n        Delay: 327.165ms\n       Jitter: 93.195ms\n Packet count: 14\n    Frequency: +3.245ppm\n\n\n\n\n\n\n\n\n\n項目\n表示例\n意味\n\n\n\n\nServer\n2620:2d:4000:1::41 (ntp.ubuntu.com)\n現在同期に使用しているNTPサーバ\n\n\nPoll interval\n34min 8s\n問い合わせ間隔\n\n\nLeap\nnormal\nうるう秒情報\n\n\nVersion\n4\nNTPプロトコルのバージョン\n\n\nStratum\n2\n基準時計からの段数\n\n\nReference\nB7A08584\n上位参照クロックID\n\n\nPrecision\n1us (-25)\n内部時計の分解能\n\n\nRoot distance\n785us\n基準時計からの推定誤差\n\n\nRoot distance max\n5s\n許容最大誤差\n\n\nOffset\n+38.605ms\nサーバとの差\n\n\nDelay\n327.165ms\nネットワーク遅延\n\n\nJitter\n93.195ms\n遅延のばらつき\n\n\nPacket count\n14\n送受信したパケット数\n\n\nFrequency\n+3.245ppm\n時計のクセ（drift）"
  },
  {
    "objectID": "posts/2021-05-07-linux-system-clock/index.html#appendix-date-コマンドによる表示形式の調整",
    "href": "posts/2021-05-07-linux-system-clock/index.html#appendix-date-コマンドによる表示形式の調整",
    "title": "[過去ブログからの転記] Linuxにおける時刻管理",
    "section": "Appendix: date コマンドによる表示形式の調整",
    "text": "Appendix: date コマンドによる表示形式の調整\n\n\n\n\n\n\nNotedate コマンドの表示形式\n\n\n\n\ndate コマンドは表示形式の設定もできます\n表示形式の書式指定では最初に + を付け，そのあとにパターンを指定します\n\n\n\n\n\n\n\n\n\n\nフォーマット\nコマンド例\n出力サンプル\n\n\n\n\nYYYY/MM/DD hh:mm:ss\ndate \"+%Y/%m/%d %H:%M:%S\"\n2017/09/07 07:16:51\n\n\nYYYY-MM-DDThh:mm:ss\ndate +%Y-%m-%dT%H:%M:%S\n2017-09-07T07:16:51\n\n\nYYYYMMDD-hhmmss\ndate +%Y%m%d-%H%M%S\n20170907-071651\n\n\nMonth DD hh:mm:ss\ndate '+%B %d %T'\nAugust 12 21:30:57\n\n\nMon DD hh:mm:ss\ndate '+%B %d %T'\nJan 30 10:30:21\n\n\nUnix Epoch Time\ndate --date=\"2020-05-01 18:36:10\" +%s\n1588325770"
  },
  {
    "objectID": "posts/2025-07-05-power-set/index.html",
    "href": "posts/2025-07-05-power-set/index.html",
    "title": "集合 \\((0,1)^N\\) の濃度",
    "section": "",
    "text": "Definition 1 べき集合\n集合 \\(M\\) があたえられたとき，\\(M\\) の部分集合全体の作る集合を \\(\\mathfrak{B}(M)\\) と表し，\\(M\\) のべき集合と呼ぶ．\n\n\\(M = \\{1, 2\\}\\) のとき，\\(M\\)の部分集合全体の作る集合は\n\\[\n\\mathfrak{B}(M) = \\{\\emptyset, \\{1\\}, \\{2\\}, \\{1,2\\}\\}\n\\]\nまた，冪集合も集合なので，\n\\[\n\\begin{align*}\n\\mathfrak{B}(\\mathfrak{B}(M)) =& \\{\n  \\emptyset,\\{\\emptyset\\}, \\{\\{1\\}\\},  \\{\\{2\\}\\}, \\{\\{1, 2\\}\\}, \\\\\n& \\{\\emptyset,  \\{1\\}\\}, \\{\\emptyset,  \\{2\\}\\}, \\{\\emptyset,  \\{1,2\\}\\}, \\{\\{1\\},  \\{2\\}\\}, \\{\\{1\\},  \\{1,2\\}\\}, \\{\\{2\\},  \\{1,2\\}\\}, \\\\\n& \\{\\emptyset, \\{1\\},  \\{2\\}\\}, \\{\\emptyset, \\{1\\},  \\{1,2\\}\\}, \\{\\emptyset, \\{2\\},  \\{1,2\\}\\}, \\{\\{1\\}, \\{2\\}, \\{1,2\\}\\}\\\\\n& \\{\\emptyset, \\{1\\},  \\{2\\}, \\{1, 2\\}\\}\n\\end{align*}\n\\]\nこれらを元の個数の観点から見てみると\n\\[\n\\begin{align}\n|M| &= |\\{1, 2\\}| = 2\\\\\n|\\mathfrak{B}(M)| &= 2^2 = 4\\\\\n|\\mathfrak{B}(\\mathfrak{B}(M))| &= 2^4 = 16\n\\end{align}\n\\]"
  },
  {
    "objectID": "posts/2025-07-05-power-set/index.html#べき集合",
    "href": "posts/2025-07-05-power-set/index.html#べき集合",
    "title": "集合 \\((0,1)^N\\) の濃度",
    "section": "",
    "text": "Definition 1 べき集合\n集合 \\(M\\) があたえられたとき，\\(M\\) の部分集合全体の作る集合を \\(\\mathfrak{B}(M)\\) と表し，\\(M\\) のべき集合と呼ぶ．\n\n\\(M = \\{1, 2\\}\\) のとき，\\(M\\)の部分集合全体の作る集合は\n\\[\n\\mathfrak{B}(M) = \\{\\emptyset, \\{1\\}, \\{2\\}, \\{1,2\\}\\}\n\\]\nまた，冪集合も集合なので，\n\\[\n\\begin{align*}\n\\mathfrak{B}(\\mathfrak{B}(M)) =& \\{\n  \\emptyset,\\{\\emptyset\\}, \\{\\{1\\}\\},  \\{\\{2\\}\\}, \\{\\{1, 2\\}\\}, \\\\\n& \\{\\emptyset,  \\{1\\}\\}, \\{\\emptyset,  \\{2\\}\\}, \\{\\emptyset,  \\{1,2\\}\\}, \\{\\{1\\},  \\{2\\}\\}, \\{\\{1\\},  \\{1,2\\}\\}, \\{\\{2\\},  \\{1,2\\}\\}, \\\\\n& \\{\\emptyset, \\{1\\},  \\{2\\}\\}, \\{\\emptyset, \\{1\\},  \\{1,2\\}\\}, \\{\\emptyset, \\{2\\},  \\{1,2\\}\\}, \\{\\{1\\}, \\{2\\}, \\{1,2\\}\\}\\\\\n& \\{\\emptyset, \\{1\\},  \\{2\\}, \\{1, 2\\}\\}\n\\end{align*}\n\\]\nこれらを元の個数の観点から見てみると\n\\[\n\\begin{align}\n|M| &= |\\{1, 2\\}| = 2\\\\\n|\\mathfrak{B}(M)| &= 2^2 = 4\\\\\n|\\mathfrak{B}(\\mathfrak{B}(M))| &= 2^4 = 16\n\\end{align}\n\\]"
  },
  {
    "objectID": "posts/2025-07-05-power-set/index.html#直積集合",
    "href": "posts/2025-07-05-power-set/index.html#直積集合",
    "title": "集合 \\((0,1)^N\\) の濃度",
    "section": "直積集合",
    "text": "直積集合\n\nDefinition 2 直積集合\n2つの有限集合 \\(M, N\\) が与えられたとき，\\(a\\in M, b\\in N\\) からなる対 \\((a, b)\\) を考える．このような１つ１つの対を元と考え，この全体を１つの集合と考えたものを \\(M\\) と \\(N\\) の直積集合といい\n\\[\nM\\times N\n\\]\nと表す\n\n\nTheorem 1 直積集合の濃度\n集合 \\(M\\), \\(N\\) を有限集合とする．このとき，\n\\[\n|M\\times N| = |M| \\times |N|\n\\]\n\n\n\n\n\n\n\nNoteProof\n\n\n\n\n\n証明は直積集合の濃度を参照してください．"
  },
  {
    "objectID": "posts/2025-07-05-power-set/index.html#集合-mn",
    "href": "posts/2025-07-05-power-set/index.html#集合-mn",
    "title": "集合 \\((0,1)^N\\) の濃度",
    "section": "集合 \\(M^N\\)",
    "text": "集合 \\(M^N\\)\n有限集合 \\(M，N\\) が与えられたとき，\n\\[\nM^N\n\\]\nという集合を考えることができます．この集合は，\\(N\\) の元の個数だけ，\\(M\\) を直積させたものとして定義します．つまり， \\(N = \\{b_1, \\cdots, b_n\\}\\) であるならば，\n\\[\nM^N = \\underbrace{M\\times \\cdots \\times M}_{n個}\n\\]\nまた，濃度についても以下のように計算ができます\n\\[\n|M^N| = \\underbrace{|M|\\times \\cdots \\times |M|}_{n個} = m^n\n\\]"
  },
  {
    "objectID": "posts/2025-07-05-power-set/index.html#m-から-n-への写像全体の作る集合",
    "href": "posts/2025-07-05-power-set/index.html#m-から-n-への写像全体の作る集合",
    "title": "集合 \\((0,1)^N\\) の濃度",
    "section": "\\(M\\) から \\(N\\) への写像全体の作る集合",
    "text": "\\(M\\) から \\(N\\) への写像全体の作る集合\n\nDefinition 3 写像\n\\(M, N\\) を有限集合とします．\\(M\\) の各元から，\\(N\\) の各元を対応させる仕方が与えられているとき， \\(M\\) から \\(N\\) の写像 \\(\\varphi\\) が与えられたという．\n写像 \\(\\varphi\\) によって \\(a\\in M\\) が \\(b\\in N\\) にうつされるとき\n\\[\nb= \\varphi(a)\n\\]\nとあらわす．\n\n\\(M = \\{x, y, z\\}\\), \\(N = \\{0, 1\\}\\) のとき，MからNへの写像は以下のように \\(2^3\\) 個考えることができます．\n\n\nCode\nfrom itertools import product\nimport pandas as pd\n\n# 集合の定義\nM = ['x', 'y', 'z']\nN = [0, 1]\n\n# 写像の全列挙\nmappings = list(product(N, repeat=len(M)))\n\n# DataFrameに変換\ndf = pd.DataFrame(mappings, columns=M)\ndf.index = df.index + 1  # 1始まりにする\n\n# 表示\ndf\n\n\n\n\n\n\n\n\n\nx\ny\nz\n\n\n\n\n1\n0\n0\n0\n\n\n2\n0\n0\n1\n\n\n3\n0\n1\n0\n\n\n4\n0\n1\n1\n\n\n5\n1\n0\n0\n\n\n6\n1\n0\n1\n\n\n7\n1\n1\n0\n\n\n8\n1\n1\n1\n\n\n\n\n\n\n\n\nDefinition 4 写像全体の集合\n有限集合 \\(M\\) から 有限集合 \\(N\\) への写像の１つ１つを元と考えて，その全体を１つのまとまった集合と考えたものを\n\\[\n\\operatorname{Map}(M, N)\n\\]\nと表す．\n\n\nTheorem 2 \\[\n|\\operatorname{Map}(M, N)| = |N^M|\n\\]\n\n\n\n\n\n\n\nNoteProof\n\n\n\n\n\n\\(M = \\{a_1, \\cdots, a_m\\}, N = \\{b_1, \\cdots, b_n\\}\\) とする．\\(\\varphi\\) を \\(\\operatorname{Map}(M, N)\\) の元とする．\\(\\varphi\\) がきまるということは \\(M\\) の元の移り先が決まっていること，つまり\n\\[\n(\\varphi(a_1), \\varphi(a_2), \\cdots, \\varphi(a_m))\n\\]\nによって決まる．\\(i=1, 2, \\cdots, m\\) について \\(\\varphi(a_i) \\in N\\) であるので\n\\[\n(\\varphi(a_1), \\varphi(a_2), \\cdots, \\varphi(a_m)) \\in N\\times N\\times \\cdots \\times N = N^M\n\\]\n逆に \\(N^M\\) の元 \\((b_{i_1}, b_{i_2}, \\cdots, b_{i_m})\\) があたえられると\n\\[\n\\varphi(a_k) = b_{i_k}\n\\]\nで，\\(M \\to N\\) の写像が定まる．従って，\\(\\operatorname{Map}(M, N)\\) の元 \\(\\varphi\\) と \\(N^M\\) の元が1対1対応している．従って，\n\\[\n|\\operatorname{Map}(M, N)| = |N^M|\n\\]\n\n\n\nべき集合との関係\n有限集合 \\(M\\) に対して，その部分集合 \\(S\\) を１つとるということは \\(x\\in M\\) に対して\n\n「含める」か「含めない」かをきめる\n「含めるを1」「含めないを0」とするならば写像 \\(\\varphi: M\\to \\{0, 1\\}\\) を１つ決めることと同じ\n\nであるので \\(M\\) から \\(\\{0, 1\\}\\) への写像 \\(\\varphi\\) を１つ決めることと1対1対応します． 従って，\\(\\mathfrak{B}(M)\\) の元と，\\(\\operatorname{Map}(M, \\{0, 1\\})\\) が1対1に対応することから．\\(m = |M|\\) とすると\n\\[\n|\\operatorname{Map}(M, \\{0, 1\\})| = |\\mathfrak{B}(M)| = 2^m\n\\]\n\nExample 1 \n\\(M = \\{a, b, c\\}\\) とするとそのすべての部分集合と対応する写像は\n\n\n\n部分集合 \\(S\\)\n写像 \\(\\varphi: M \\to \\{0,1\\}\\)\n\n\n\n\n\\(\\emptyset\\)\n\\(\\varphi(a)=0, \\varphi(b)=0, \\varphi(c)=0\\)\n\n\n\\(\\{a\\}\\)\n\\(\\varphi(a)=1, \\varphi(b)=0, \\varphi(c)=0\\)\n\n\n\\(\\{b\\}\\)\n\\(\\varphi(a)=0, \\varphi(b)=1, \\varphi(c)=0\\)\n\n\n\\(\\{c\\}\\)\n\\(\\varphi(a)=0, \\varphi(b)=0, \\varphi(c)=1\\)\n\n\n\\(\\{a, b\\}\\)\n\\(\\varphi(a)=1, \\varphi(b)=1, \\varphi(c)=0\\)\n\n\n\\(\\{a, c\\}\\)\n\\(\\varphi(a)=1, \\varphi(b)=0, \\varphi(c)=1\\)\n\n\n\\(\\{b, c\\}\\)\n\\(\\varphi(a)=0, \\varphi(b)=1, \\varphi(c)=1\\)\n\n\n\\(\\{a, b, c\\}\\)\n\\(\\varphi(a)=1, \\varphi(b)=1, \\varphi(c)=1\\)"
  },
  {
    "objectID": "posts/2025-07-05-power-set/index.html#無限集合と高々加算集合の直和",
    "href": "posts/2025-07-05-power-set/index.html#無限集合と高々加算集合の直和",
    "title": "集合 \\((0,1)^N\\) の濃度",
    "section": "無限集合と高々加算集合の直和",
    "text": "無限集合と高々加算集合の直和\n\nDefinition 5 高々加算集合\n集合 \\(M\\) が，有限集合か，加算集合のとき，\\(M\\) を高々加算集合という\n\n\\(M\\) を加算集合として，\\(S\\subset M\\) となるような無限集合を考えます．\\(M\\) は加算集合であるので\n\\[\nM = \\{a_1, a_2, \\cdots, a_n, \\cdots\\}\n\\]\nと集合を \\(\\mathbb N\\) と対応させて表現することができます．次に，\\(S\\) の元について，\\(M\\) の元の並び方のうち最初に \\(S\\) の元として現れるものを \\(a_{i_1}\\), 次は \\(a_{i_2}, \\cdots\\) とすると\n\\[\nS = \\{a_{i_1}, a_{i_2}, \\cdots\\}\n\\]\nとなります．\\(S\\) は定義より無限集合であり，また写像 \\(\\varphi: \\mathbb N\\to S\\) を\n\\[\n\\varphi(n) = a_{i_n}\n\\]\nとすると，\\(\\varphi\\) は1対1写像となります．従って，\\(S\\) は加算集合となります．つまり，\\(M\\) を加算集合とすると，\\(M\\) の任意の部分集合は高々加算集合ということになります．\n\nTheorem 3 \n\\(M\\) を無限集合，\\(A\\) を高々加算集合とする．このとき，\\(M\\) と \\(M\\sqcup A\\) の間には１対１の対応があり，そのため，２つの濃度は等しい:\n\\[\n|M| = |M \\sqcup A|\n\\]\n\n\n\n\n\n\n\nNoteProof\n\n\n\n\n\n\\(M\\) から１つの元 \\(b_1\\) をとると，\\(M - \\{b_1\\}\\) は空襲号ではないので，同じ操作を繰り返すことができます．また，\\(M\\) は無限集合であるので，無限回繰り返して，その結果得られた \\(b_i\\) を以下のような集合で表現する\n\\[\nB = \\{b_1, b_2, \\cdots, b_n, \\cdots \\}\n\\]\nこのとき，\\(B\\subset M\\) かつ \\(B\\) は加算集合です．加算集合と加算集合の和は加算集合なので \\(B\\sqcup A\\) も加算集合となります．従って，\\(B\\) と \\(B\\sqcup A\\) はある写像 \\(\\varphi\\) によって1対1に対応します．\n次に\n\\[\n\\tilde\\varphi: (M-B) \\sqcup B\\to (M-B)\\sqcup (B\\sqcup A)\n\\]\nを考えます．\n\n\\(x\\in M -B\\) ならば \\(\\tilde\\varphi(x) = x\\)\n\\(x\\in B\\) ならば \\(\\tilde\\varphi(x) = \\varphi(x)\\)\n\nとすると，\\(\\tilde\\varphi\\) も1対1写像となります．\n\\[\n\\begin{align}\nM-B \\sqcup B &= M\\\\\n(M-B)\\sqcup (B\\sqcup A) &= M \\sqcup A\n\\end{align}\n\\]\nであることから\n\\[\n|M| = |M| + |A|\n\\]"
  },
  {
    "objectID": "posts/2025-07-05-power-set/index.html#mathfrakbmathbb-n-の濃度",
    "href": "posts/2025-07-05-power-set/index.html#mathfrakbmathbb-n-の濃度",
    "title": "集合 \\((0,1)^N\\) の濃度",
    "section": "\\(\\mathfrak{B}(\\mathbb N)\\) の濃度",
    "text": "\\(\\mathfrak{B}(\\mathbb N)\\) の濃度\nこれまでは有限集合を前提に話してきましたが，ここからは自然数集合 \\(\\mathbb N\\) という加算無限集合を取り扱います．\n\\[\n|\\mathbb N| = \\aleph_0\n\\]\nであることに留意すると，\n\\[\n|\\mathfrak{B}(\\mathbb N)| = 2^{\\aleph_0}\n\\]\nこれがどれくらいの濃度を持つのか考えてみます．\n\nTheorem 4 \\[\n2^{\\aleph_0} = \\aleph\n\\]\n\n\n\n\n\n\n\nNoteProof\n\n\n\n\n\n濃度 \\(2\\) を持つ集合として \\(\\{0, 1\\}\\) を考えます．このとき，\\(2^{\\aleph_0}\\) は，直積集合\n\\[\nP = \\{0, 1\\}\\times \\{0, 1\\}\\times \\{0, 1\\}\\times \\cdots\n\\]\nの濃度と等しくなります．\\(\\aleph\\) が実数集合の濃度と等しいので，\\(|(0, 1]|= \\aleph\\) であることから\n\\[\n|P| = |(0, 1]|\n\\]\nを示せれば良いとなります．\n\\(P\\) の元は 0と1 からなる数列として，\\((a_1, a_2, \\cdots)\\) と表せるので，これを2進小数で表現された実数と対応させることができます．つまり，\n\\[\n0.a_1a_2\\cdots\n\\]\n\\((0, 1]\\) に属する実数を無限２進小数で表現すると，その表し方はただ１通りとなります．\n次に，\\((0, 1]\\) に属する実数について，有限2進小数に表せる集合 \\(S\\) を考えてみます．このとき，\\(S \\subset \\mathbb Q\\) であることから\n\\[\n|S| = \\aleph_0\n\\]\n次に，写像 \\(\\varphi: P\\to (0, 1] \\sqcup S\\) を考えてみます．\\(x\\in P\\) について，\n\\[\nx = (a_1, \\cdots, a_n, 0, 0, \\cdots)\n\\]\nとあるところから先すべてが0になっているものについて，\n\\[\n\\varphi(x) = 0.a_1a_2\\cdots a_n \\in S\n\\]\nと対応させます．また，それ以外の場合は\n\\[\n\\varphi(x) = 0.a_1a_2\\cdots a_n\\cdots \\in (0, 1]\n\\]\nとなるので，\\(x\\in P \\Rightarrow \\varphi(x) \\in ((0, 1] \\sqcup S)\\)，また \\(\\varphi\\) は \\(P\\) から \\((0, 1] \\sqcup S\\) に対して１対１の対応を与えてます．つまり，\n\\[\n|P| = |(0, 1] \\sqcup S|\n\\]\nまた無限集合 Aと高々加算集合 B について Theorem 3 より\n\\[\n|A| = |A\\sqcup B|\n\\]\nであることから\n\\[\n|P| = |(0, 1] \\sqcup S| = |(0, 1]|\n\\]\n従って，\n\\[\n2^{\\aleph_0} = \\aleph\n\\]"
  },
  {
    "objectID": "posts/2025-12-23-memory-channel/index.html",
    "href": "posts/2025-12-23-memory-channel/index.html",
    "title": "CPUとDRAMの「メモリチャネル」とは何か？",
    "section": "",
    "text": "Definition 1 メモリチャネル\n\nCPUとメインメモリ（RAM）間の64bit データ伝送経路(物理バス)の数のこと\nチャネル数が多ければ多いほど，一度に転送できるデータ量が増え，結果的にシステムのパフォーマンスが向上\n扱えるチャネル数はCPU側で決まる\n\n\nCPUがメモリにアクセスする際に，CPU上のメモリコントローラを介して，このチャネルを通してデータの読み書きを行います． 複数のチャネルが同時に動作（＝マルチチャネル）することで，メモリの帯域幅が増加します．\nQuestion: メモリスロットとは違うのか？\n\nAnswer: メモリスロット数 ≠ メモリチャネル数\nメモリチャネルはCPU内蔵メモリコントローラ（IMC）が持つ独立した通信路\nメモリスロットとはDIMMを挿すための物理的な差し込み口\n\nQuestion: どのメモリがどのチャネルを利用しているのか\nどのメモリがどのチャネルを使用しているかは dmidecode で確認することが出来ます\n$ sudo dmidecode -t memory | less\n...\nHandle 0x0013, DMI type 17, 92 bytes\nMemory Device\n    Array Handle: 0x000E\n    Error Information Handle: 0x0012\n    Total Width: 64 bits\n    Data Width: 64 bits\n    Size: 32 GB\n    Form Factor: DIMM\n    Set: None\n    Locator: DIMMA2\n    Bank Locator: P0 CHANNEL A\n    Type: DDR5\n    Type Detail: Synchronous Unbuffered (Unregistered)\n    Speed: 4800 MT/s\n    Manufacturer: A-DATA Technology\n    Serial Number: 00xxxxxx\n    Asset Tag: Not Specified\n    Part Number: AD5U480032G-B       \n    Rank: 2\n    Configured Memory Speed: 4800 MT/s\n  ...\n上記から以下の情報を読み取ることが出来ます\n\n\n\n\n\n\n\n\n\ndmidecode項目\n表示例\n何を意味するか\n\n\n\n\nBank Locator\nP0 CHANNEL A\nCPUソケット0 (P0) の メモリチャネルA に接続\n\n\nLocator\nDIMMA2\nマザーボード上の 物理メモリスロット名\n\n\nTotal Width\n64 bits\nDIMM全体のバス幅\n\n\nData Width\n64 bits\nCPUから見える 有効データ幅\n\n\nRank\n2\nDual Rank DIMM（1枚のDIMM内に2 Rank）\n\n\nType\nDDR5\nメモリ世代（DDR5）\n\n\nSpeed\n4800 MT/s\nメモリ転送レート（メガトランスファ/秒）\n\n\nConfigured Memory Speed\n4800 MT/s\n実際に動作している速度\n\n\nForm Factor\nDIMM / SODIMM\nモジュール形状\n\n\nMemory Technology\nDRAM\n揮発性メモリ\n\n\n\n\nランクとは？\n\nDefinition 2 ランク\n上記のメモリは DIMM となっています．DIMMとは Dual Inline Memory Moduleの略で，複数のDRAMチップをプリント基板上に搭載したメモリモジュールのことです． DIMM内のDRAMチップのうち，メモリコントローラとのアクセスに用いられるアドレス・ラインを共有し，同時に選択される DRAM チップの集合を Rank（ランク）と呼びます．\n\n１つのランクは64ビットの単位で入出力をします．１つのメモリチャネルが64 bitであることに対応しており， 1 Rank がちょうど 1 メモリチャネルを占有して通信する構造になっています．\nそのため，\n\n1 チャネルあたり同時にアクセスできる Rank は 1 つのみ\nDual Rank DIMM では，Rank 0 と Rank 1 を 時間的に切り替えて使用する\n\nという動作になります．"
  },
  {
    "objectID": "posts/2025-12-23-memory-channel/index.html#メモリチャネルとは",
    "href": "posts/2025-12-23-memory-channel/index.html#メモリチャネルとは",
    "title": "CPUとDRAMの「メモリチャネル」とは何か？",
    "section": "",
    "text": "Definition 1 メモリチャネル\n\nCPUとメインメモリ（RAM）間の64bit データ伝送経路(物理バス)の数のこと\nチャネル数が多ければ多いほど，一度に転送できるデータ量が増え，結果的にシステムのパフォーマンスが向上\n扱えるチャネル数はCPU側で決まる\n\n\nCPUがメモリにアクセスする際に，CPU上のメモリコントローラを介して，このチャネルを通してデータの読み書きを行います． 複数のチャネルが同時に動作（＝マルチチャネル）することで，メモリの帯域幅が増加します．\nQuestion: メモリスロットとは違うのか？\n\nAnswer: メモリスロット数 ≠ メモリチャネル数\nメモリチャネルはCPU内蔵メモリコントローラ（IMC）が持つ独立した通信路\nメモリスロットとはDIMMを挿すための物理的な差し込み口\n\nQuestion: どのメモリがどのチャネルを利用しているのか\nどのメモリがどのチャネルを使用しているかは dmidecode で確認することが出来ます\n$ sudo dmidecode -t memory | less\n...\nHandle 0x0013, DMI type 17, 92 bytes\nMemory Device\n    Array Handle: 0x000E\n    Error Information Handle: 0x0012\n    Total Width: 64 bits\n    Data Width: 64 bits\n    Size: 32 GB\n    Form Factor: DIMM\n    Set: None\n    Locator: DIMMA2\n    Bank Locator: P0 CHANNEL A\n    Type: DDR5\n    Type Detail: Synchronous Unbuffered (Unregistered)\n    Speed: 4800 MT/s\n    Manufacturer: A-DATA Technology\n    Serial Number: 00xxxxxx\n    Asset Tag: Not Specified\n    Part Number: AD5U480032G-B       \n    Rank: 2\n    Configured Memory Speed: 4800 MT/s\n  ...\n上記から以下の情報を読み取ることが出来ます\n\n\n\n\n\n\n\n\n\ndmidecode項目\n表示例\n何を意味するか\n\n\n\n\nBank Locator\nP0 CHANNEL A\nCPUソケット0 (P0) の メモリチャネルA に接続\n\n\nLocator\nDIMMA2\nマザーボード上の 物理メモリスロット名\n\n\nTotal Width\n64 bits\nDIMM全体のバス幅\n\n\nData Width\n64 bits\nCPUから見える 有効データ幅\n\n\nRank\n2\nDual Rank DIMM（1枚のDIMM内に2 Rank）\n\n\nType\nDDR5\nメモリ世代（DDR5）\n\n\nSpeed\n4800 MT/s\nメモリ転送レート（メガトランスファ/秒）\n\n\nConfigured Memory Speed\n4800 MT/s\n実際に動作している速度\n\n\nForm Factor\nDIMM / SODIMM\nモジュール形状\n\n\nMemory Technology\nDRAM\n揮発性メモリ\n\n\n\n\nランクとは？\n\nDefinition 2 ランク\n上記のメモリは DIMM となっています．DIMMとは Dual Inline Memory Moduleの略で，複数のDRAMチップをプリント基板上に搭載したメモリモジュールのことです． DIMM内のDRAMチップのうち，メモリコントローラとのアクセスに用いられるアドレス・ラインを共有し，同時に選択される DRAM チップの集合を Rank（ランク）と呼びます．\n\n１つのランクは64ビットの単位で入出力をします．１つのメモリチャネルが64 bitであることに対応しており， 1 Rank がちょうど 1 メモリチャネルを占有して通信する構造になっています．\nそのため，\n\n1 チャネルあたり同時にアクセスできる Rank は 1 つのみ\nDual Rank DIMM では，Rank 0 と Rank 1 を 時間的に切り替えて使用する\n\nという動作になります．"
  },
  {
    "objectID": "posts/2025-12-23-memory-channel/index.html#ddr5-と-サブチャネル",
    "href": "posts/2025-12-23-memory-channel/index.html#ddr5-と-サブチャネル",
    "title": "CPUとDRAMの「メモリチャネル」とは何か？",
    "section": "DDR5 と サブチャネル",
    "text": "DDR5 と サブチャネル\n\n\n\nDDR RDIMMモジュール\n\n\n「DDR5メモリは1枚でデュアルチャネル」という言葉をよく耳にしますが，たしかに標準のDDR5モジュールは 2 つの独立型 32 bit サブチャネルを備えています． これはDDR5が 1つの64 bitメモリチャネルを内部的に分けて使用することを意味します．\nつまり，\n\nDDR5は「メモリバス幅を広げた」のではなく64bit バスを 2 つの 32bit に分割して“使い勝手を良くしただけで，1つのDDR5メモリで２つのCPUメモリチャネルを専有するわけではない\nDDR5 モジュールは，CPU からは 64bit 幅のメモリチャネルとして接続されているが，DIMM 内部ではこの 64bit データ経路が 2 つの独立した 32bit サブチャネルとして論理的に分割 されているだけ\nデュアルチャネルはあくまでDIMMの中の話\n\nCPU メモリチャネル（64bit）\n        │\n        ├─ Sub-channel A : 32bit\n        └─ Sub-channel B : 32bit\n\n\n\n\n\n\nNoteimage図ではなぜ40 bitなのか？\n\n\n\n\nECCメモリを用いた例のため（Error Correcting Code）\nECCメモリは，メモリ故障などに起因して 1 bitの反転エラーが発生したときに，それを検知・自動補正ができるようにするための誤り訂正符号(ECC)と呼ばれるパリティ情報が付与されたメモリ\n\nメモリ故障が発生するとECCメモリではない場合，OSレベルの異常終了になってしまうが，ECCメモリの場合ではOSが以上を検知してアラートを出してくれる\nアラート発報後，通常終了を行いメモリを交換というアクションが可能\n\n40 bit = 32 data bit + 8 ECC bit\n\n\n\n\nExample 1 (AMD Ryzen Threadripper PRO 9975Wと理論メモリ帯域) \n公式仕様を確認すると\n\nメモリ規格：DDR5 RDIMM\nメモリチャネル数：8 チャネル\n最大転送レート：6400 MT/s\n\nまず１チャネルあたりのメモリ帯域は\n\\[\n6,400 \\operatorname{MT/s} \\times 64 \\operatorname{bits} = 51,200 \\operatorname{MB/s}\n\\]\nこれを合計 8 チャネルで使用できるとすると\n\\[\n51,200 \\operatorname{MB/s} \\times 8 = 409.6 \\operatorname{GB/s}\n\\]"
  },
  {
    "objectID": "posts/2025-12-23-memory-channel/index.html#appendix-メモリテクノロジー",
    "href": "posts/2025-12-23-memory-channel/index.html#appendix-メモリテクノロジー",
    "title": "CPUとDRAMの「メモリチャネル」とは何か？",
    "section": "Appendix: メモリテクノロジー",
    "text": "Appendix: メモリテクノロジー\n\n\n\n\n\n\n\n\n\n観点\nSRAM\nDRAM\n\n\n\n\n名称\nstatic random access memory\ndynamic random access memory\n\n\n特徴\n速度\n容量・SRAMより安価\n\n\nどこにある？\nCPUの中\nCPUの外\n\n\nデータサイエンス/数値計算\nキャッシュヒット率が重要\n帯域・チャネル数が重要\n\n\n\n\nrandom accessとは？\n\n磁気テープ装置は順を追ってしか読み書きできない\nRAMでは，どの部分を読み出すにもかかる時間は同じ\n\nDRAMはなぜSRAMよりも容量が大きいのか？\n\n1ビットあたりの回路が極めて小さい\n同じシリコン面積ならDRAMの方が圧倒的に多くのビットを実装できる\nビットあたりのトランジスタもDRAMは1ビットあたり1トランジスタ，SRAMは1ビットあたり6トランジスタを必要 → 製造コスト・歩留まりの面でもDRAMが有利\n\nDynamic vs static\nDRAMはキャパシタに電荷を蓄えることで情報を保持します．電荷は時間とともに漏れるため，一定周期でのリフレッシュ（再書き込み） = Dynamicが必要となります． 一方，SRAMは電源が供給されている限り状態を保持できるため，このリフレッシュが不要のため，静的 = static と呼ばれます．\nメモリテクノロジー別アクセス時間・コストテーブル\n\n\n\n\n\n\n\n\n\n\n\n種類\n代表例\n代表的アクセス時間（レイテンシ）\n1GiBあたりのコスト感(2012年)\n主な用途\n\n\n\n\nSRAM\nCPU L1/L2/L3 Cache\n0.5〜2.5 ns\n500 ~ 1,000ドル / GiB\nキャッシュ，レジスタ\n\n\nDRAM\nDDR4 / DDR5\n50〜70 ns\n10 ~ 20ドル / GiB\nメインメモリ\n\n\nフラッシュ半導体メモリ\nNAND（SSD, NVMe）\n50〜500 µs\n0.75 ~ 1ドル / GiB\nストレージ（高速）\n\n\n磁気ディスク\nHDD\n5〜20 ms\n0.05 ~ 0.1ドル / GiB\n大容量保存"
  },
  {
    "objectID": "posts/2025-12-23-memory-channel/index.html#references",
    "href": "posts/2025-12-23-memory-channel/index.html#references",
    "title": "CPUとDRAMの「メモリチャネル」とは何か？",
    "section": "References",
    "text": "References\n\nCan someone please explain RAM Channels to me?"
  },
  {
    "objectID": "posts/2025-06-18-cantor-pairing-functions/index.html",
    "href": "posts/2025-06-18-cantor-pairing-functions/index.html",
    "title": "カントールの対関数の全単射性の証明",
    "section": "",
    "text": "Note自然数集合の定義\n\n\n\n\\(\\mathbb N = \\{1, 2, 3, \\cdots\\}\\) とする．\n\n\n\nDefinition 1 カントールの対関数\n次の関数 \\(J: \\mathbb N\\times \\mathbb N\\to \\mathbb N\\) をカントールの対関数という\n\\[\nJ(x, y) = \\frac{(x + y - 2)(x + y - 1)}{2} + y\n\\]\n\n\\(J\\) は全単射という性質があります\n\n\nカントールの対関数のイメージは Figure 1 です．\\(J: \\mathbb N\\times \\mathbb N\\to \\mathbb N\\) が全単射であることから，自然数の対 \\((m, n)\\) 全体の作る集合は \\(\\mathbb N\\) と濃度が同じ = 可算集合であることがわかるようになります．\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Define the grid size\nmax_val = 5\nX, Y = np.meshgrid(np.arange(1, max_val + 1), np.arange(1, max_val + 1))\n\n# Compute Cantor pairing number\nZ = ((X + Y - 2) * (X + Y - 1)) // 2 + Y\n\n# Flatten the arrays for easier iteration and sorting\npoints = []\nfor i in range(X.shape[0]):\n    for j in range(X.shape[1]):\n        x = X[i, j]\n        y = Y[i, j]\n        z = Z[i, j]\n        if z &lt;= 15:\n            points.append((z, x, y))  # (number, x, y)\n\n# Sort by the Cantor number\npoints.sort()\n\n# Plotting\nplt.figure(figsize=(7, 7))\nplt.xlim(0.3, max_val + 0.3)\nplt.ylim(0.3, max_val + 0.3)\nplt.xticks(np.arange(1, max_val + 1))\nplt.yticks(np.arange(1, max_val + 1))\nplt.grid(True)\n\n# Plot points and labels\nfor z, x, y in points:\n    plt.text(x, y + 0.1, str(z), ha='center', va='center', fontsize=12, color='black')\n    plt.plot(x, y, 'ko', markersize=5)\n\n# Draw arrows from one point to the next in order\nfor i in range(len(points) - 1):\n    _, x0, y0 = points[i]\n    _, x1, y1 = points[i + 1]\n    dx = x1 - x0\n    dy = y1 - y0\n    plt.arrow(x0, y0, dx * 0.85, dy * 0.85,\n              head_width=0.1, head_length=0.1,\n              length_includes_head=True, linestyle='dashed', color='#575757')\n\nplt.title('Cantor Pairing Function with Ordered Arrows')\nplt.xlabel('x')\nplt.ylabel('y')\nplt.gca().set_aspect('equal')\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\nFigure 1\n\n\n\n\n\n\n\n\n\n\n\nNoteProof: 全射性の証明\n\n\n\n\n\n任意の \\(k\\in \\mathbb N\\) について，ある \\(x, y \\in \\mathbb N\\) が存在して，\\(J(x, y) = k\\) になることを，数学的帰納法を用いると容易に示すことができます．\n\\(k = 1\\) について\n\\(k = 1\\) については，\\((x, y) = (1, 1)\\) とすると，\n\\[\nJ(1, 1) = \\frac{(1 + 1 - 2)(1 + 1 - 1)}{2} + 1\n\\]\nより自明．\n\\(k &gt; 1\\) について\nつぎに，ある \\(k\\in \\mathbb N\\) について，ある \\(x, y \\in \\mathbb N\\) が存在すると仮定して，\\(k+1\\) についても同様に成り立つことを示します．\n\\(x = 1\\) のときは \\((x^\\prime, y^\\prime) = (y + 1, 1)\\) とおくと，\n\\[\n\\begin{align}\nJ(x^\\prime, y^\\prime)\n  &= \\frac{(x^\\prime + y^\\prime - 2)(x^\\prime + y^\\prime - 1)}{2} + y^\\prime\\\\\n  &= \\frac{(y + 1 + 1 - 2)(y + 1 + 1 - 1)}{2} + 1\\\\\n  &= \\frac{(y)(y + 1)}{2} + 1\\\\\n  &= \\frac{(y - 1)(y)}{2} + y + 1\\\\\n  &= J(x, y) + 1\\\\\n  &= k + 1\n\\end{align}\n\\]\n\\(x &gt; 1\\) のときは \\((x^\\prime, y^\\prime) = (x - 1, y + 1)\\) とおくと，\n\\[\n\\begin{align}\nJ(x^\\prime, y^\\prime)\n  &= \\frac{(x + y - 2)(x + y - 1)}{2} + y + 1\\\\\n  &= J(x, y) + 1\\\\\n  &= k + 1\n\\end{align}\n\\]\n以上の数学的帰納法により，任意の \\(k \\in \\mathbb{N}\\) に対して，ある \\((x, y) \\in \\mathbb{N}^2\\) が存在して \\(J(x, y) = k\\) となる．\n\n\n\n\n\n\n\n\n\nNoteProof: 単射性の証明\n\n\n\n\n\n\\((x, y)\\neq (x^\\prime, y^\\prime)\\) を任意にとると，\n\\(x + y = x^\\prime + y^\\prime\\) のときは，\n\\[\nJ(x, y) - J(x^\\prime, y^\\prime) = y - y^\\prime \\neq 0\n\\]\n\\(x + y \\neq x^\\prime + y^\\prime\\) のときは，\\(x + y &lt; x^\\prime + y^\\prime\\) としても一般性を失わないので，\n\\[\n\\begin{align}\nJ(x, y)\n  &= \\sum^{x + y - 2}_i i + y\\\\\n  &\\leq \\sum^{x + y - 2}_i i + x + y - 1\\\\\n  &= \\sum^{x + y - 1}_i\\\\\n  &\\leq \\sum^{x^\\prime + y^\\prime - 2}_i\\\\\n  &&lt; \\sum^{x^\\prime + y^\\prime - 2}_i + y^\\prime\\\\\n  &= J(x^\\prime, y^\\prime)\n\\end{align}\n\\]\n従って，単射性が示された．"
  },
  {
    "objectID": "posts/2025-06-18-cantor-pairing-functions/index.html#カントールの対関数",
    "href": "posts/2025-06-18-cantor-pairing-functions/index.html#カントールの対関数",
    "title": "カントールの対関数の全単射性の証明",
    "section": "",
    "text": "Note自然数集合の定義\n\n\n\n\\(\\mathbb N = \\{1, 2, 3, \\cdots\\}\\) とする．\n\n\n\nDefinition 1 カントールの対関数\n次の関数 \\(J: \\mathbb N\\times \\mathbb N\\to \\mathbb N\\) をカントールの対関数という\n\\[\nJ(x, y) = \\frac{(x + y - 2)(x + y - 1)}{2} + y\n\\]\n\n\\(J\\) は全単射という性質があります\n\n\nカントールの対関数のイメージは Figure 1 です．\\(J: \\mathbb N\\times \\mathbb N\\to \\mathbb N\\) が全単射であることから，自然数の対 \\((m, n)\\) 全体の作る集合は \\(\\mathbb N\\) と濃度が同じ = 可算集合であることがわかるようになります．\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Define the grid size\nmax_val = 5\nX, Y = np.meshgrid(np.arange(1, max_val + 1), np.arange(1, max_val + 1))\n\n# Compute Cantor pairing number\nZ = ((X + Y - 2) * (X + Y - 1)) // 2 + Y\n\n# Flatten the arrays for easier iteration and sorting\npoints = []\nfor i in range(X.shape[0]):\n    for j in range(X.shape[1]):\n        x = X[i, j]\n        y = Y[i, j]\n        z = Z[i, j]\n        if z &lt;= 15:\n            points.append((z, x, y))  # (number, x, y)\n\n# Sort by the Cantor number\npoints.sort()\n\n# Plotting\nplt.figure(figsize=(7, 7))\nplt.xlim(0.3, max_val + 0.3)\nplt.ylim(0.3, max_val + 0.3)\nplt.xticks(np.arange(1, max_val + 1))\nplt.yticks(np.arange(1, max_val + 1))\nplt.grid(True)\n\n# Plot points and labels\nfor z, x, y in points:\n    plt.text(x, y + 0.1, str(z), ha='center', va='center', fontsize=12, color='black')\n    plt.plot(x, y, 'ko', markersize=5)\n\n# Draw arrows from one point to the next in order\nfor i in range(len(points) - 1):\n    _, x0, y0 = points[i]\n    _, x1, y1 = points[i + 1]\n    dx = x1 - x0\n    dy = y1 - y0\n    plt.arrow(x0, y0, dx * 0.85, dy * 0.85,\n              head_width=0.1, head_length=0.1,\n              length_includes_head=True, linestyle='dashed', color='#575757')\n\nplt.title('Cantor Pairing Function with Ordered Arrows')\nplt.xlabel('x')\nplt.ylabel('y')\nplt.gca().set_aspect('equal')\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\nFigure 1\n\n\n\n\n\n\n\n\n\n\n\nNoteProof: 全射性の証明\n\n\n\n\n\n任意の \\(k\\in \\mathbb N\\) について，ある \\(x, y \\in \\mathbb N\\) が存在して，\\(J(x, y) = k\\) になることを，数学的帰納法を用いると容易に示すことができます．\n\\(k = 1\\) について\n\\(k = 1\\) については，\\((x, y) = (1, 1)\\) とすると，\n\\[\nJ(1, 1) = \\frac{(1 + 1 - 2)(1 + 1 - 1)}{2} + 1\n\\]\nより自明．\n\\(k &gt; 1\\) について\nつぎに，ある \\(k\\in \\mathbb N\\) について，ある \\(x, y \\in \\mathbb N\\) が存在すると仮定して，\\(k+1\\) についても同様に成り立つことを示します．\n\\(x = 1\\) のときは \\((x^\\prime, y^\\prime) = (y + 1, 1)\\) とおくと，\n\\[\n\\begin{align}\nJ(x^\\prime, y^\\prime)\n  &= \\frac{(x^\\prime + y^\\prime - 2)(x^\\prime + y^\\prime - 1)}{2} + y^\\prime\\\\\n  &= \\frac{(y + 1 + 1 - 2)(y + 1 + 1 - 1)}{2} + 1\\\\\n  &= \\frac{(y)(y + 1)}{2} + 1\\\\\n  &= \\frac{(y - 1)(y)}{2} + y + 1\\\\\n  &= J(x, y) + 1\\\\\n  &= k + 1\n\\end{align}\n\\]\n\\(x &gt; 1\\) のときは \\((x^\\prime, y^\\prime) = (x - 1, y + 1)\\) とおくと，\n\\[\n\\begin{align}\nJ(x^\\prime, y^\\prime)\n  &= \\frac{(x + y - 2)(x + y - 1)}{2} + y + 1\\\\\n  &= J(x, y) + 1\\\\\n  &= k + 1\n\\end{align}\n\\]\n以上の数学的帰納法により，任意の \\(k \\in \\mathbb{N}\\) に対して，ある \\((x, y) \\in \\mathbb{N}^2\\) が存在して \\(J(x, y) = k\\) となる．\n\n\n\n\n\n\n\n\n\nNoteProof: 単射性の証明\n\n\n\n\n\n\\((x, y)\\neq (x^\\prime, y^\\prime)\\) を任意にとると，\n\\(x + y = x^\\prime + y^\\prime\\) のときは，\n\\[\nJ(x, y) - J(x^\\prime, y^\\prime) = y - y^\\prime \\neq 0\n\\]\n\\(x + y \\neq x^\\prime + y^\\prime\\) のときは，\\(x + y &lt; x^\\prime + y^\\prime\\) としても一般性を失わないので，\n\\[\n\\begin{align}\nJ(x, y)\n  &= \\sum^{x + y - 2}_i i + y\\\\\n  &\\leq \\sum^{x + y - 2}_i i + x + y - 1\\\\\n  &= \\sum^{x + y - 1}_i\\\\\n  &\\leq \\sum^{x^\\prime + y^\\prime - 2}_i\\\\\n  &&lt; \\sum^{x^\\prime + y^\\prime - 2}_i + y^\\prime\\\\\n  &= J(x^\\prime, y^\\prime)\n\\end{align}\n\\]\n従って，単射性が示された．"
  },
  {
    "objectID": "posts/2025-06-18-cantor-pairing-functions/index.html#カントールの対関数の逆関数",
    "href": "posts/2025-06-18-cantor-pairing-functions/index.html#カントールの対関数の逆関数",
    "title": "カントールの対関数の全単射性の証明",
    "section": "カントールの対関数の逆関数",
    "text": "カントールの対関数の逆関数\n証明の関係上，\\(\\mathbb N = \\{0, 1, 2, 3, \\cdots\\}\\) とします．\nこのとき，のカントール対関数は\n\\[\nJ(x, y) = \\frac{(x + y)(x + y + 1)}{2} + y\n\\]\nとなります．\n\nTheorem 1 カントールの対関数の逆関数\n\\[\nJ(x, y) = \\frac{(x + y)(x + y + 1)}{2} + y\n\\]\nの逆関数は\n\\[\nt = \\left\\lfloor \\frac{-1 + \\sqrt{1 + 8J}}{2}\\right\\rfloor\n\\]\nとおくと，\n\\[\n\\begin{cases}\nx =\\frac{t^3 + 3t}{2} - J\\\\\ny = J - \\frac{t^2 + t}{2}\n\\end{cases}\n\\]\n\n\n\n\n\n\n\nNoteProof\n\n\n\n\n\n\\(t = x + y\\) とおくと，カントールの対関数は\n\\[\n\\begin{align}\nJ(x, y) &= \\frac{t^2 + t}{2} + y\\\\\nJ(x, 0) &= \\frac{x^2 + x}{2}\n\\end{align}\n\\]\nまた定義より\n\\[\n\\begin{align}\nJ(x, y) &= J(x + y, 0) + y\\\\\nJ(x, y) &= J(0, x + y) - x\\\\\nJ(0, x+y) + 1 &= J(x + y + 1, 0)\n\\end{align}\n\\]\n従って，\n\\[\nJ(x + y, 0) \\leq J(x, y) \\leq J(0, x + y) &lt; J(x + y + 1, 0)\n\\]\nつまり，\n\\[\n\\frac{t^2 + t}{2} \\leq J(x, y)  = \\frac{t^2 + t}{2} + y &lt; \\frac{(t + 1)^2 + t + 1}{2}\n\\]\nこれを整理すると\n\\[\n\\begin{gather}\nt^2 + t - 2J \\leq 0\\\\\n(t + 1)^2 + (t + 1) - 2J &gt; 0\n\\end{gather}\n\\]\nこれを解くと，\n\\[\n\\begin{gather}\n\\frac{-1 - \\sqrt{1 + 8J}}{2} \\leq t \\leq \\frac{-1 + \\sqrt{1 + 8J}}{2}\\\\\nt + 1 &lt;\\frac{-1 - \\sqrt{1 + 8J}}{2} \\lor \\frac{-1 + \\sqrt{1 + 8J}}{2} &lt; t + 1\\\\\n\\end{gather}\n\\]\nここで，\\(t \\geq 0\\) であることから\n\\[\nt  \\leq \\frac{-1 + \\sqrt{1 + 8J}}{2} &lt; t + 1\n\\]\n\\(t \\in \\mathbb N\\) より\n\\[\nt = \\left\\lfloor \\frac{-1 + \\sqrt{1 + 8J}}{2}\\right\\rfloor\n\\]\nこれを，\\((x, y)\\) に対応させると\n\\[\n\\begin{align}\nx &= t - y\\\\\ny &= J - \\frac{t^2 + t}{2}\n\\end{align}\n\\]\nよって，\n\\[\n\\begin{cases}\nx =\\frac{t^3 + 3t}{2} - J\\\\\ny = J - \\frac{t^2 + t}{2}\n\\end{cases}\n\\]\n\n\n\n\n\n\n\n\n\nNote\n\n\n\n\\(\\mathbb N = \\{1, 2, 3, \\cdots\\}\\) とした場合は\n\\[\nt = \\left\\lfloor \\frac{-1 + \\sqrt{8J - 7}}{2}\\right\\rfloor\n\\]\n\\[\n\\begin{cases}\nx =\\frac{t^3 + 3t}{2} - J + 2\\\\\ny = J - \\frac{t^2 + t}{2}\n\\end{cases}\n\\]"
  },
  {
    "objectID": "posts/2025-07-20-decorator-checking-running-time/index.html",
    "href": "posts/2025-07-20-decorator-checking-running-time/index.html",
    "title": "実行時間計測デコレーター",
    "section": "",
    "text": "Definition 1 デコレーター\n\nデコレータとは，関数の前後に追加処理（ロギング・計測・バリデーションなど）を組み込む仕組み\n\n\n\n\nCode\nfrom time import time, sleep\n\ndef running_time(func):\n    \"\"\"\n    関数の実行時間（秒）を有効桁小数点３桁で表示して、元の関数の戻り値を返すデコレータ\n    \"\"\"\n    def wrapper(*args, **kwargs):\n        start = time()\n        result = func(*args, **kwargs)\n        end = time()\n        elapsed = end - start\n        print(f\"Execution time: {elapsed:.3f} seconds\")\n        return result\n    return wrapper\n\n\n\nExample 1 カントールの対関数の逆関数と実行時間計算\n\n\nCode\nimport numpy as np\n\n@running_time\ndef compute_contor_inverse(J: int):\n    \"\"\"Compute the inverse of the Cantor pairing function.\n    \n    The Cantor pairing function maps pairs of natural numbers to single natural numbers.\n    This function computes the inverse mapping, taking a natural number and returning the \n    original pair of numbers.\n    \n    Args:\n        J (int): A natural number that was produced by the Cantor pairing function.\n            Must be non-negative.\n    \n    Returns:\n        tuple[int, int]: A pair (x, y) of numbers such that their Cantor pairing \n        would produce J. The first element x represents the first number in the original \n        pair, and y represents the second number.\n    \"\"\"\n\n    t = int((np.sqrt(1 + 8 * J) - 1) // 2)\n    x = (t ** 3 + 3 * t) // 2 - J\n    y = J - (t ** 2 + t) // 2\n\n    return x, y\n\n\noutput = compute_contor_inverse(100)\nprint(output)\n\n\nExecution time: 0.000 seconds\n(1018, 9)"
  },
  {
    "objectID": "posts/2025-07-20-decorator-checking-running-time/index.html#実行時間を秒単位で表示するデコレータ",
    "href": "posts/2025-07-20-decorator-checking-running-time/index.html#実行時間を秒単位で表示するデコレータ",
    "title": "実行時間計測デコレーター",
    "section": "",
    "text": "Definition 1 デコレーター\n\nデコレータとは，関数の前後に追加処理（ロギング・計測・バリデーションなど）を組み込む仕組み\n\n\n\n\nCode\nfrom time import time, sleep\n\ndef running_time(func):\n    \"\"\"\n    関数の実行時間（秒）を有効桁小数点３桁で表示して、元の関数の戻り値を返すデコレータ\n    \"\"\"\n    def wrapper(*args, **kwargs):\n        start = time()\n        result = func(*args, **kwargs)\n        end = time()\n        elapsed = end - start\n        print(f\"Execution time: {elapsed:.3f} seconds\")\n        return result\n    return wrapper\n\n\n\nExample 1 カントールの対関数の逆関数と実行時間計算\n\n\nCode\nimport numpy as np\n\n@running_time\ndef compute_contor_inverse(J: int):\n    \"\"\"Compute the inverse of the Cantor pairing function.\n    \n    The Cantor pairing function maps pairs of natural numbers to single natural numbers.\n    This function computes the inverse mapping, taking a natural number and returning the \n    original pair of numbers.\n    \n    Args:\n        J (int): A natural number that was produced by the Cantor pairing function.\n            Must be non-negative.\n    \n    Returns:\n        tuple[int, int]: A pair (x, y) of numbers such that their Cantor pairing \n        would produce J. The first element x represents the first number in the original \n        pair, and y represents the second number.\n    \"\"\"\n\n    t = int((np.sqrt(1 + 8 * J) - 1) // 2)\n    x = (t ** 3 + 3 * t) // 2 - J\n    y = J - (t ** 2 + t) // 2\n\n    return x, y\n\n\noutput = compute_contor_inverse(100)\nprint(output)\n\n\nExecution time: 0.000 seconds\n(1018, 9)"
  },
  {
    "objectID": "posts/2025-07-20-decorator-checking-running-time/index.html#デコレーター自身に引数を読み込ませる場合",
    "href": "posts/2025-07-20-decorator-checking-running-time/index.html#デコレーター自身に引数を読み込ませる場合",
    "title": "実行時間計測デコレーター",
    "section": "デコレーター自身に引数を読み込ませる場合",
    "text": "デコレーター自身に引数を読み込ませる場合\n上記の running_time で小数点桁数を３桁固定としていましたが，これを引数に応じて変化させる場合を考えます．\n\n\nCode\nfrom time import time, sleep\n\n\ndef running_time_with_input(decimal: int = 3):\n    def decorator(func):\n        \"\"\"\n        関数の実行時間（秒）を有効桁小数点３桁で表示して、元の関数の戻り値を返すデコレータ\n        \"\"\"\n\n        def wrapper(*args, **kwargs):\n            start = time()\n            result = func(*args, **kwargs)\n            end = time()\n            elapsed = end - start\n            print(f\"Execution time: {elapsed:.{decimal}f} seconds\")\n            return result\n\n        return wrapper\n\n    return decorator\n\n\n実行例\n\n\nCode\n@running_time_with_input(decimal=10)\ndef do_task():\n    sleep(1.2345)\n\ndo_task()\n# =&gt; Execution time: 1.23 seconds\n\n\nExecution time: 1.2346060276 seconds"
  },
  {
    "objectID": "posts/2025-07-20-decorator-checking-running-time/index.html#appendix-args-と-kwargs",
    "href": "posts/2025-07-20-decorator-checking-running-time/index.html#appendix-args-と-kwargs",
    "title": "実行時間計測デコレーター",
    "section": "Appendix: *args と **kwargs",
    "text": "Appendix: *args と **kwargs\n\n\n\n\n\n\n\n\n\n書き方\n意味\n例\n\n\n\n\n*args\nタプルとして位置引数を全部受け取る\nfunc(1, 2, 3) → args = (1, 2, 3)\n\n\n**kwargs\n辞書としてキーワード引数を全部受け取る\nfunc(a=10, b=20) → kwargs = {'a': 10, 'b': 20}\n\n\n\n\n動作確認\n\n\nCode\ndef example(*args, **kwargs):\n    print(\"args:\", args)\n    print(\"kwargs:\", kwargs)\n\nexample(1, 2, 3, a=10, b=20)\n\n\nargs: (1, 2, 3)\nkwargs: {'a': 10, 'b': 20}"
  },
  {
    "objectID": "posts/2025-09-26-network-connection-trouble/index.html",
    "href": "posts/2025-09-26-network-connection-trouble/index.html",
    "title": "ネットワークトラブルの切り分け",
    "section": "",
    "text": "Ubuntu 24.04 LTSにて，S3 storage s3.amazonaws.com にある日突然接続できなくなった"
  },
  {
    "objectID": "posts/2025-09-26-network-connection-trouble/index.html#トラブル",
    "href": "posts/2025-09-26-network-connection-trouble/index.html#トラブル",
    "title": "ネットワークトラブルの切り分け",
    "section": "",
    "text": "Ubuntu 24.04 LTSにて，S3 storage s3.amazonaws.com にある日突然接続できなくなった"
  },
  {
    "objectID": "posts/2025-09-26-network-connection-trouble/index.html#トラブルシューティングフローチャート",
    "href": "posts/2025-09-26-network-connection-trouble/index.html#トラブルシューティングフローチャート",
    "title": "ネットワークトラブルの切り分け",
    "section": "🔍 トラブルシューティングフローチャート",
    "text": "🔍 トラブルシューティングフローチャート\n\n\n\n\n\n---\nconfig:\n  layout: elk\n---\nflowchart LR\n    A[\"ネットワークに問題発生\"] --&gt; B[\"ping ホスト名を実行\"]\n    B --&gt; C{\"応答あり？\"}\n    C -- YES --&gt; D[\"名前解決 &amp; 通信OK\"]\n    C -- NO --&gt; E[\"ping IPアドレスを実行\"]\n    E --&gt; F{\"応答あり？\"}\n    F -- YES --&gt; G[\"名前解決の問題&lt;br&gt;DNS設定確認\"]\n    F -- NO --&gt; H[\"ネットワーク未接続&lt;br&gt;ケーブル/ルータ確認\"]\n\n    %% フォントサイズをノードごとに指定\n    style A font-size:1.2em\n    style B font-size:1.2em\n    style C font-size:1.2em\n    style D font-size:1.2em\n    style E font-size:1.2em\n    style F font-size:1.2em\n    style G font-size:1.2em\n    style H font-size:1.1em\n\n\n\n\n\n\n今回のトラブルでは，掃除のタイミングでケーブルを抜いており，物理的にケーブルが刺さっていませんでした．．．\n\npingコマンド\n\nDefinition 1 pingコマンド\n\npingコマンドは指定したホストとの間でネットワークが疎通しているかどうかを調べるコマンド\nping ホスト名を実行すると，サイズの小さなパケットを相手に送信して，その応答を調べる\nping6 は /usr/bin/ping6 -&gt; ping* とシンボリックリンクになっている\n\nping [option] destination\n\npingコマンドは相手のコンピューターに対してICMPメッセージ(ネットワーク層のプロトコル)を送信し，その応答で通信状況を判断します．以下の例ではグローバルIPアドレスに対してですが， プライベートIPアドレスに対して送信することも可能です．\n\n\n\n\n\n\n\n\nsequenceDiagram\n    participant PC as ユーザー端末\n    participant Router as ルーター\n    participant Target as 宛先サーバー (例: google.com)\n\n    %% ICMP Echo Request\n    PC -&gt;&gt; Router: ICMP Echo Request\n    Router -&gt;&gt; Target: ICMP Echo Request\n\n    %% ICMP Echo Reply\n    Target --&gt;&gt; Router: ICMP Echo Reply\n    Router --&gt;&gt; PC: ICMP Echo Reply\n\n    %% Note\n    Note over PC,Target: PCは応答を受け取ってRTT（Round-Trip Time，往復時間）を計測\n\n\n\n\n\n\n\n\nFigure 1\n\n\n\n\nExample 1 ping出力 \n% ping 8.8.8.8 -c 3\nPING 8.8.8.8 (8.8.8.8) 56(84) bytes of data.\n64 bytes from 8.8.8.8: icmp_seq=1 ttl=117 time=7.46 ms\n64 bytes from 8.8.8.8: icmp_seq=2 ttl=117 time=17.9 ms\n64 bytes from 8.8.8.8: icmp_seq=3 ttl=117 time=14.1 ms\n\n--- 8.8.8.8 ping statistics ---\n3 packets transmitted, 3 received, 0% packet loss, time 2003ms\nrtt min/avg/max/mdev = 7.463/13.149/17.850/4.297 ms\n\n8.8.8.8: Google Public DNS\nttl: time to live, パケットがネットワーク上を通過できる最大ホップ数を指定する値\n\n\n\nOptions\n\n\n\n\n\n\n\n\nオプション\n意味\n\n\n\n\n-4\nIPv4を使用する（pingコマンドのデフォルト）\n\n\n-6\nIPv6を使用する（ping6コマンドのデフォルト）\n\n\n-c 回数\nパケットを送る回数\n\n\n-i 秒数\n個々の送信の後に待つ秒数（デフォルトは1秒）\n\n\n-w 秒数\n状況を問わず、pingコマンドの実行を指定した秒数で終了\n\n\n-n\n数値出力のみを行う（IPアドレスからホスト名を検索しない）\n\n\n-q\n開始と終了時の要約のみで他は表示しない（quiet）\n\n\n-v\n詳細な出力を行う（verbose）\n\n\n-p パターン\n送出するパケットを埋める値をパターンで指定（例: -p ff で全て 1 で埋めたパケット）\n\n\n-s サイズ\n送出するパケットのサイズを指定（デフォルト 56バイト＋ICMPヘッダ8バイト＝合計64バイト）\n\n\n-R\n経路を記録する\n\n\n-r\n通常のルーティングを無視して接続する\n\n\n-I インタフェース\n指定したインタフェースからマルチキャストパケットを送る\n\n\n-L\nマルチキャストパケットのループバックを抑制する\n\n\n-t TTL値\nTime To Liveを設定する\n\n\n\n\n\npingコマンドを用いた問題の切り分け\n\n\n\n\n\n\n\n\n\n\nテスト内容\nコマンド例\n結果\n考えられる原因 / 対策\n\n\n\n\nIPv4 外部接続\nping 8.8.8.8\n✅ 応答あり\nIPv4経路は正常\n\n\nIPv4 外部接続\nping 8.8.8.8\n❌ 応答なし\nIPv4経路問題（ルーティング・ファイアウォール等）\n\n\nIPv6 外部接続\nping -6 2001:4860:4860::8888\n✅ 応答あり\nIPv6経路は正常\n\n\nIPv6 外部接続\nping -6 2001:4860:4860::8888\n❌ 応答なし\nIPv6経路問題（ルーティング・ICMPv6制限・ISP未対応）\n\n\n特定インターフェース経由\nping -I eno1 8.8.8.8\n✅ / ❌\nインターフェース選択による疎通確認、VPN/物理NIC切替の検証\n\n\n\n\n\n\nネットワークインターフェース一覧の確認\nインターフェース一覧のみを出力する場合は\nip link show\nを実行します．実行結果例として\n1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 ...\n2: eno1: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 ...\n3: docker0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 ...\n4: tailscale0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 ...\nまたは\n$ ls /sys/class/net/\ndocker0@  eno1@  lo@  tailscale0@\nでも確認することができます．\n\nExample 2 ネットワークインターフェース例 \n\n\n\n\n\n\n\n\n\nインターフェース名\n種類\n説明\n\n\n\n\nlo\nループバック\nローカル内部通信専用．自分自身との通信に使用される（127.0.0.1 / ::1）．\n\n\neno1\n有線LAN（Ethernet）\n物理 NIC．Onboard NIC．マザーボード直付けのポート 1\n\n\nenp6s0\n有線LAN（Ethernet）\n物理 NIC．複数NIC構成の場合の追加ポート．\n\n\nwlp13s0\n無線LAN（Wi-Fi）\nWi-Fi接続用の物理 NIC．無線ネットワークに接続される．\n\n\ndocker0\n仮想ブリッジ\nDocker が作成する仮想ネットワーク．コンテナ間通信やホスト通信に使用．\n\n\nbr-xxxxxxxxxxx\n仮想ブリッジ\nDocker などが作成するカスタムブリッジ．コンテナ専用ネットワーク用．\n\n\ntailscale0\nVPN仮想NIC\nTailscale VPN用の仮想インターフェース．VPN経由の通信に使用．\n\n\n\n\n基本的には\n\nwlから始まる: ワイヤレス\nenから始まる: 有線LAN\n\nという命名規則になっています．またp6やs0といった数値はPCIバス番号とスロット番号に対応しています\n\n\n\n\n部分\n意味\n\n\n\n\nwl\nワイヤレス（Wireless LAN）デバイス\n\n\np13\nPCI バス番号（このデバイスが接続されているバスの位置）\n\n\ns0\nスロット番号（同じバス内でのスロット位置）"
  },
  {
    "objectID": "posts/2025-09-26-network-connection-trouble/index.html#appendix-icmp",
    "href": "posts/2025-09-26-network-connection-trouble/index.html#appendix-icmp",
    "title": "ネットワークトラブルの切り分け",
    "section": "Appendix: ICMP",
    "text": "Appendix: ICMP\nIPはUDP(トランスポート層プロトコル)と同じコネクションレス型の通信を行うため，データが相手に届いたかどうかについては感知しません． IPデータグラムの通信状況を確認するためのネットワーク層プロトコルとして，ICMP(Internet Control Message Protocol)という仕組みが考案されました．\n主にpingコマンドやtracerouteコマンドで使用されます．\n\n\n\n\n\n\nNoteICMPはあくまでIPの補助\n\n\n\n\nICMPメッセージは単独で送られることはなく，IPのヘッダが付与されて送られる\nあくまでも「IPを助けるプロトコル」\nIPデータグラムは，IPヘッダがついたデータ（トランスポート層でのセグメントに対応）のこと．\n\n\n\nICMPヘッダ\n\n\n\n\n\nblock-beta\n  columns 3\n  A[\"&lt;strong&gt;タイプ(8bit)&lt;/strong&gt;&lt;br&gt;メッセージの種類を表す\"]:1\n  B[\"&lt;strong&gt;コード(8bit)&lt;/strong&gt;&lt;br&gt;エラー原因などを示す\"]:1\n  C[\"&lt;strong&gt;チェックサム(16 bit)&lt;/strong&gt;&lt;br&gt;データが無事かどうかを確認\"]:2\n  \n  style A fill:#fff,stroke:#000,stroke-width:2px,font-size:1.5em\n  style B fill:#fff,stroke:#000,stroke-width:2px,font-size:1.5em\n  style C fill:#fff,stroke:#000,stroke-width:2px,font-size:1.5em\n\n\n\n\n\n\n主なタイプ一覧\n\n\n\n\n\n\n\n\n\n\nICMP Type\nNICMPv6 Type\n種類\n説明\n\n\n\n\n0\n129\nEcho Reply\nメッセージが無事に届きました\n\n\n3\n1\nDestination Unreachable\n宛先に到達できませんでした\n\n\n5\n137\nRedirect\nルーティング経路の変更通知\n\n\n8\n128\nEcho Request\nこのメッセージが届いたら，返事をください\n\n\n11\n3\nTime Exceeded\nTTLやフラグメント再構築時間超過\n\n\n\n\n\n\n\n\n\nsequenceDiagram\n    participant PC as 自端末 (Type 8)\n    participant Router as ルーター\n    participant Target as 宛先ホスト (Type 0)\n\n    %% ICMP Echo Request\n    PC -&gt;&gt; Router: ICMP Echo Request (Type 8)\n    Router -&gt;&gt; Target: ICMP Echo Request (Type 8)\n\n    %% ICMP Echo Reply\n    Target --&gt;&gt; Router: ICMP Echo Reply (Type 0)\n    Router --&gt;&gt; PC: ICMP Echo Reply (Type 0)"
  },
  {
    "objectID": "posts/2025-09-26-network-connection-trouble/index.html#appendix-pppoe方式",
    "href": "posts/2025-09-26-network-connection-trouble/index.html#appendix-pppoe方式",
    "title": "ネットワークトラブルの切り分け",
    "section": "Appendix: PPPoE方式",
    "text": "Appendix: PPPoE方式\nIPv4ではPPPoE接続方式が使用されています．一方，IPv6ではPPPoE接続方式に加えて，IPoE方式が利用できます．ここでは従来のPPPoE方式を解説します．\n\nDefinition 2 Point-to-Point Protocol(PPP)\n\n2点間で1対1の通信を行ためのデータリンク層プロトコル\nデータをPPPフレームにカプセル化して伝送\n1対1の通信なのでMACアドレスは基本的には使わない\n\n\n\n\n\n\n\n\n\n\nsequenceDiagram\n    participant A as Computer A\n    participant B as Computer B\n\n    A -&gt;&gt; B: 通信をしたいときは，&lt;br&gt;通信要求を相手に送信\n    B -&gt;&gt; A: 接続する資格を持ったユーザーか確認&lt;br&gt;(ユーザー認証)\n    B -&gt;&gt; A: 通信条件について，相談\n    B -&gt;&gt; A: 通信を開始\n\n    %% 接続\n    Note over A,B: 接続が確立した状態\n\n\n\n\n\n\n\n\nFigure 2\n\n\n\nPPPフレーム\n\n\n\n\n\nblock-beta\n  columns 2\n  A[\"&lt;strong&gt;開始符号(8bit)&lt;/strong&gt;&lt;br&gt;01111110が入る\"]:1\n  B[\"&lt;strong&gt;アドレス(8bit)&lt;/strong&gt;&lt;br&gt;固定値(11111111)が入る\"]:1\n  C[\"&lt;strong&gt;制御部(8 bit)&lt;/strong&gt;&lt;br&gt;伝送を制御するための情報\"]:1\n  D[\"&lt;strong&gt;プロトコル部(8 bit)&lt;/strong&gt;&lt;br&gt;上位層のプロトコルを指定\"]:1\n  E[\"&lt;strong&gt;データ&lt;/strong&gt;&lt;br&gt;カプセル化されたIPヘッダ/TCPヘッダ/アプリケーションヘッダ/データが入る\"]:2\n  F[\"&lt;strong&gt;FCS(Frane Check Sequence) (32bit)&lt;/strong&gt;&lt;br&gt;フレームが壊れていないかどうかを調べる値\"]:2\n  G[\"&lt;strong&gt;終了符号(8bit)&lt;/strong&gt;&lt;br&gt;01111110が入る\"]:2\n\n  style A fill:#fff,stroke:#000,stroke-width:2px,font-size:1.5em\n  style B fill:#fff,stroke:#000,stroke-width:2px,font-size:1.5em\n  style C fill:#fff,stroke:#000,stroke-width:2px,font-size:1.5em\n  style D fill:#fff,stroke:#000,stroke-width:2px,font-size:1.5em\n  style E fill:#fff,stroke:#000,stroke-width:2px,font-size:1.5em\n  style F fill:#fff,stroke:#000,stroke-width:2px,font-size:1.5em\n  style G fill:#fff,stroke:#000,stroke-width:2px,font-size:1.5em\n\n\n\n\n\n\n\nDefinition 3 PPPoE\n\nイーサネットフレーム上にPPPフレームをカプセル化するための通信プロトコル\nPPPoEを用いることで，イーサネット上にある2台のコンピューター間で認証を行える\n光回線を使ってアクセスサーバー経由でインターネットに接続するときに使う\n\n\nPPPoEは，PPPの昨日をEthernet上で利用するためのプロトコルです．PPPoEはLAN上においてもユーザ認証が可能で，IPアドレスの割当も可能という特徴があります．\nPPPoEフレーム\nPPPoEフレームは，Ethernetフレームに包まれて運ばれていきます．PPPoEフレームの構成は以下\n\n\n\n\n\nblock-beta\n  columns 4\n  A[\"version(4 bit)&lt;br&gt;PPPoEのバージョン情報\"]:1\n  B[\"タイプ(4 bit)&lt;br&gt;PPPoEのタイプ情報\"]:1\n  C[\"コードビット(8 bit)&lt;br&gt;PPPoEのパケットの種類\"]:2\n  D[\"Session ID(16 bit)&lt;br&gt;PPPoEを使った通信を行うための固有値\"]:4\n  E[\"データ長(16 bit)&lt;br&gt;最大64KB\"]:4\n  F[\"データ&lt;br&gt;PPPヘッダが入る\"]:4\n\n\n\n\n\n\nIP通信確立までのステップ\nPPPoE接続を行ってIP通信ができるようになるまでには，DiscoveryステージとPPPセッションステージの2つのステップを踏む必要があります．\n\n\n\n\n\n\n\n\nステージ\n説明\n\n\n\n\nDiscoveryステージ\n最初にPPPoEセッションをはるまで(=PPPoEセッションIDの割り当てを行うまで)\n\n\nPPPセッションステージ\nPPP通信による認証実施ステージ(IPアドレス割当まで)\n\n\n\n\nPPPoE接続が上手くいかない場合，一般的には「PPPセッションステージ」での認証トラブルが多いです．\n\n\n\n\n\n\n\n\nsequenceDiagram\n    participant C as PPPoEクライアント (PC)\n    participant S as PPPoEサーバー (ISP AC)\n    participant R as RADIUSサーバー\n    participant G as 接続先 (google.com)\n\n    %% --- Discovery Stage ---\n    C -&gt;&gt; S: PADI (接続要求ブロードキャスト)\n    S -&gt;&gt; C: PADO (サービス提供応答)\n    C -&gt;&gt; S: PADR (AC選択 → 接続要求)\n    S -&gt;&gt; C: PADS (セッション確立・Session ID付与)\n\n    Note over C,S: PPPoE セッション確立\n\n    %% --- PPP Session Stage (LCP + 認証) ---\n    C -&gt;&gt; S: LCPネゴシエーション\n    S -&gt;&gt; C: 認証要求 (PAP/CHAP)\n    C -&gt;&gt; S: 認証応答\n\n    %% --- 認証処理 (RADIUS連携) ---\n    S -&gt;&gt; R: Access-Request (ユーザー名/パスワード)\n    R -&gt;&gt; S: Access-Accept (認証成功, 属性情報[IP割当等])\n\n    S -&gt;&gt; C: 認証成功通知 + IPアドレス割当\n\n    Note over C,S: PPP セッション確立 (グローバルIP付与)\n\n    %% --- IP通信 Stage ---\n    C -&gt;&gt; G: HTTPリクエスト (例: https://google.com)\n    G -&gt;&gt; C: HTTPレスポンス (Googleページ返却)\n\n\n\n\n\n\n\n\n\nFigure 3"
  },
  {
    "objectID": "posts/2025-09-26-network-connection-trouble/index.html#references",
    "href": "posts/2025-09-26-network-connection-trouble/index.html#references",
    "title": "ネットワークトラブルの切り分け",
    "section": "References",
    "text": "References\n\n【 ping 】コマンド／【 ping6 】コマンド――通信相手にパケットを送って応答を調べる\nStackExchange &gt; what is the difference between eth1 and eno1?\nip6.me"
  },
  {
    "objectID": "posts/2025-07-11-oss-contribution/index.html",
    "href": "posts/2025-07-11-oss-contribution/index.html",
    "title": "GitHub OSS Contribution: ForkからPull Request",
    "section": "",
    "text": "GitHubで ForkからPull Requestを出す手順を紹介します\n修正箇所は事前に見つかっている前提とします"
  },
  {
    "objectID": "posts/2025-07-11-oss-contribution/index.html#スコープ",
    "href": "posts/2025-07-11-oss-contribution/index.html#スコープ",
    "title": "GitHub OSS Contribution: ForkからPull Request",
    "section": "",
    "text": "GitHubで ForkからPull Requestを出す手順を紹介します\n修正箇所は事前に見つかっている前提とします"
  },
  {
    "objectID": "posts/2025-07-11-oss-contribution/index.html#oss-contributionまでの手順",
    "href": "posts/2025-07-11-oss-contribution/index.html#oss-contributionまでの手順",
    "title": "GitHub OSS Contribution: ForkからPull Request",
    "section": "🔨 OSS contributionまでの手順",
    "text": "🔨 OSS contributionまでの手順\n\n\n\n\n\nsequenceDiagram\n    participant 開発者 as Local repo\n    participant フォークしたリポジトリ as fork repo\n    participant オリジナルのリポジトリ as original repo\n    participant リポジトリの所有者 as repository owner\n\n    オリジナルのリポジトリ-&gt;&gt;フォークしたリポジトリ: フォークする\n    フォークしたリポジトリ-&gt;&gt;開発者: クローンを作成\n    開発者-&gt;&gt;開発者: 機能ブランチを作成\n    開発者-&gt;&gt;開発者: コードの変更とテスト\n    開発者-&gt;&gt;フォークしたリポジトリ: 変更をpush\n    フォークしたリポジトリ-&gt;&gt;オリジナルのリポジトリ: プルリクエストを送信\n    オリジナルのリポジトリ-&gt;&gt;リポジトリの所有者: レビュー依頼\n    リポジトリの所有者-&gt;&gt;オリジナルのリポジトリ: コメントとフィードバック\n    オリジナルのリポジトリ-&gt;&gt;開発者: レビュー内容の共有\n    開発者-&gt;&gt;開発者: 修正作業（ローカル）\n    開発者-&gt;&gt;フォークしたリポジトリ: 修正をpush\n    フォークしたリポジトリ-&gt;&gt;オリジナルのリポジトリ: プルリクエストを更新\n    リポジトリの所有者-&gt;&gt;オリジナルのリポジトリ: プルリクエストを承認\n    リポジトリの所有者-&gt;&gt;オリジナルのリポジトリ: プルリクエストをマージ\n\n\n\n\n\n\n\n\n\n\n\n\nNoteREMARKS\n\n\n\n\n通常「repository owner」のみが，original repositoryに対して直接操作\n実際の運用では，レビューは複数人で行われることもあるが，上のシークエンス図ではシンプルに一人と仮定\n\n\n\n\nStep 1: プロジェクトルールの事前確認\n開発をスタートする前に，以下のルール文書を必ず確認してください．これらはコードレビューを円滑かつ効率的に進めるための共通認識を定めたもので，遵守することでPRは「内容」に集中した建設的なレビューになり，反復的なスタイル修正や手戻りを最小化できます．\n\n\n\n\n\n\n\n\nファイル名\n目的・レビュー効率への寄与\n\n\n\n\ncontribution.md\nPR 作成のフォーマットや粒度，コミットメッセージの書き方が明文化されており，認識のズレを減らせます．\n\n\nbranch-strategy.md\n適切なブランチ運用により，他の開発との競合やマージ事故を防ぎ，レビュー対象を明確にできます．\n\n\ncoding-convention.md\nスタイルや命名規則が統一されていることで，コード内容の議論に集中でき，フォーマットの指摘を減らせます．\n\n\n.editorconfig\nインデント幅・改行コード・文字コードなどのエディタ設定が統一され，スタイル差分の混入を防ぎます．\n\n\n\n\nプロジェクトルール確認チェックリスト\n\ncontribution.md を読んだ\nbranch-strategy.md に従ってブランチを作成した\ncoding-convention.md に準拠したコードを書いた\n.editorconfig に準拠したエディタ設定を行っている\n\n\n\nStep 2: Issueを作成\nPRを出す前に，まず Issue を作成して修正提案を相談します．\n\nExample 1 🐞 Bug Report: caption-number: false is not respected in metadata\n\n\nDescription\nWhen setting the following in Quarto YAML front matter:\npseudocode:\n  caption-number: false\nthe pseudocode filter still adds numbers to the captions. The expected behavior is that setting caption-number: false should disable caption numbering.\n\n\nCurrent Behavior\nThe false value is ignored, because false or x always evaluates to x in Lua. Therefore, the default is used even when false is explicitly specified.\n\n\nProposed Fix\nReplace line 268 in pseudocode.lua:\nglobal_options.caption_number = doc.meta[\"pseudocode\"][\"caption-number\"] or global_options.caption_number\nwith:\nif doc.meta.pseudocode and doc.meta.pseudocode[\"caption-number\"] ~= nil then\n  global_options.caption_number = doc.meta.pseudocode[\"caption-number\"]\nelse\n  global_options.caption_number = global_options.caption_number\nend\n\nBtw, thank you for developing this great extension — I really appreciate your work and love using it in my quarto projects!\n\n\n\n\n\n\nStep 3: Fork（リポジトリを複製）\n\nPRを送りたいリポジトリにアクセス\n右上の [Fork] ボタンをクリックして，自分のアカウントに複製\n\n\n\nStep 4: 自分の環境にClone & 開発用ブランチの作成\ngit clone https://github.com/your-username/project-name.git\ncd project-name\ngit switch -c my-feature-or-fix\n\n\n\n\n\n\nNote\n\n\n\n\nbranch strategyに則ったブランチ名をつけるようにします\n\n\n\n\n\nStep 4: git commit and push\nコードを編集し，コミットします\n# 編集後\ngit add .\ngit commit -m \"Fix: typo in README\"\n\n# fork repositoryへpush\ngit push origin my-feature-or-fix\n\n\n\n\n\n\nNotecommit message方針\n\n\n\ncontribution.md や開発者ガイドに則したコミットメッセージを記載します．基本構造としては．\n&lt;タイプ&gt;: &lt;短く要点を伝えるメッセージ（50文字以内）&gt;\nPrefix例\n\n\n\n\n\n\n\n\n\nPrefix\n意味・用途\n使用例（タイトル）\n\n\n\n\nFix\nバグ修正\nFix: crash when input is null\n\n\nImplement\nロジックや処理を新規実装\nImplement: user login logic with token generation\n\n\nEnhance\n仕様に基づいた変更や改善．振る舞いを変更するがバグではない場合\nEnhance: replace polling with websocket\n\n\nRemove\n機能やコードの削除．不要になった処理を明確に消すとき\nRemove: deprecated API endpoint\n\n\nRefactor\n動作に影響を与えない内部構造の改善（リネーム，分割，整理など）\nRefactor: split UserService into modules\n\n\nDocs\nドキュメントの変更（README，注釈，Wiki連携など）\nDocs: fix typo in usage example\n\n\nTest\nテストコードの追加・変更\nTest: add edge case test for empty array\n\n\nStyle\nフォーマット・コードスタイル修正（意味のある動作変更なし）\nStyle: format code with Prettier\n\n\nRevert\n以前のコミットを取り消す\nRevert: remove async version due to bug\n\n\nPerf\nパフォーマンス改善\nPerf: reduce image loading time by 50%\n\n\nBuild\nビルドシステムや依存関係の変更（npm, poetry, Dockerなど）\nBuild: upgrade TypeScript to v5.3\n\n\n\n\n\n\n\n\nStep 5: Pull Request作成\n\nGitHub上で，「Compare & pull request」をクリックし，PRを作成します\nPR作成後，diff内容に問題がなければ Create Pull Request をクリックします．\n\nこれらの手続きを実行すると，PR送り先リポジトリの管理者にPRが作成されたことが通知されます．\n\n\n\n\n\n\nNotePR作成チェックリスト\n\n\n\n\nIssueを事前に作成している\nタイトルと説明が明確\n関連Issueがリンクされている\n\n\n\n\nExample 2 FIX: respecting caption-number: false in user setting\n\n\nRelated Issue\n\n#8\n\n\n\nDescription\nThis PR updates the logic assigning global_options.caption_number so that a user-specified false value in doc.meta.pseudocode[\"caption-number\"] is not overridden by the default.\n\nBefore\nThe old logic:\n  global_options.caption_number = doc.meta[\"pseudocode\"][\"caption-number\"] or global_options.caption_number\ncaused issues when caption-number: false was explicitly set in metadata. Since false is false in Lua, it incorrectly fell back to the default.\n\n\nAfter\nThis fix ensures that false is respected by explicitly checking for nil:\nif doc.meta.pseudocode and doc.meta.pseudocode[\"caption-number\"] ~= nil then\n  global_options.caption_number = doc.meta.pseudocode[\"caption-number\"]\nelse\n  global_options.caption_number = global_options.caption_number\nend"
  },
  {
    "objectID": "posts/2025-07-11-oss-contribution/index.html#description",
    "href": "posts/2025-07-11-oss-contribution/index.html#description",
    "title": "GitHub OSS Contribution: ForkからPull Request",
    "section": "Description",
    "text": "Description\nWhen setting the following in Quarto YAML front matter:\npseudocode:\n  caption-number: false\nthe pseudocode filter still adds numbers to the captions. The expected behavior is that setting caption-number: false should disable caption numbering."
  },
  {
    "objectID": "posts/2025-07-11-oss-contribution/index.html#current-behavior",
    "href": "posts/2025-07-11-oss-contribution/index.html#current-behavior",
    "title": "GitHub OSS Contribution: ForkからPull Request",
    "section": "Current Behavior",
    "text": "Current Behavior\nThe false value is ignored, because false or x always evaluates to x in Lua. Therefore, the default is used even when false is explicitly specified."
  },
  {
    "objectID": "posts/2025-07-11-oss-contribution/index.html#proposed-fix",
    "href": "posts/2025-07-11-oss-contribution/index.html#proposed-fix",
    "title": "GitHub OSS Contribution: ForkからPull Request",
    "section": "Proposed Fix",
    "text": "Proposed Fix\nReplace line 268 in pseudocode.lua:\nglobal_options.caption_number = doc.meta[\"pseudocode\"][\"caption-number\"] or global_options.caption_number\nwith:\nif doc.meta.pseudocode and doc.meta.pseudocode[\"caption-number\"] ~= nil then\n  global_options.caption_number = doc.meta.pseudocode[\"caption-number\"]\nelse\n  global_options.caption_number = global_options.caption_number\nend\n\nBtw, thank you for developing this great extension — I really appreciate your work and love using it in my quarto projects!"
  },
  {
    "objectID": "posts/2025-07-11-oss-contribution/index.html#related-issue",
    "href": "posts/2025-07-11-oss-contribution/index.html#related-issue",
    "title": "GitHub OSS Contribution: ForkからPull Request",
    "section": "Related Issue",
    "text": "Related Issue\n\n#8"
  },
  {
    "objectID": "posts/2025-07-11-oss-contribution/index.html#description-1",
    "href": "posts/2025-07-11-oss-contribution/index.html#description-1",
    "title": "GitHub OSS Contribution: ForkからPull Request",
    "section": "Description",
    "text": "Description\nThis PR updates the logic assigning global_options.caption_number so that a user-specified false value in doc.meta.pseudocode[\"caption-number\"] is not overridden by the default.\n\nBefore\nThe old logic:\n  global_options.caption_number = doc.meta[\"pseudocode\"][\"caption-number\"] or global_options.caption_number\ncaused issues when caption-number: false was explicitly set in metadata. Since false is false in Lua, it incorrectly fell back to the default.\n\n\nAfter\nThis fix ensures that false is respected by explicitly checking for nil:\nif doc.meta.pseudocode and doc.meta.pseudocode[\"caption-number\"] ~= nil then\n  global_options.caption_number = doc.meta.pseudocode[\"caption-number\"]\nelse\n  global_options.caption_number = global_options.caption_number\nend"
  },
  {
    "objectID": "posts/2025-07-11-oss-contribution/index.html#references",
    "href": "posts/2025-07-11-oss-contribution/index.html#references",
    "title": "GitHub OSS Contribution: ForkからPull Request",
    "section": "References",
    "text": "References\n\nGitHub Docs &gt; Creating a pull request"
  },
  {
    "objectID": "posts/2025-02-13-complex-plane/index.html",
    "href": "posts/2025-02-13-complex-plane/index.html",
    "title": "複素平面と複素数による回転",
    "section": "",
    "text": "NoteKey takeways\n\n\n\n\\(z_1, z_2\\in \\mathbb C\\) のとき，\n\\[\n\\begin{align}\nz_1 &= r_1(\\cos\\theta_1 + i\\sin\\theta_1)\\\\\nz_2 &= r_2(\\cos\\theta_2 + i\\sin\\theta_2)\n\\end{align}\n\\]\nとすると，以下が成立する\n\\[\n\\begin{align}\n&z_1z_2 = r_1r_2(\\cos(\\theta_1 + \\theta_2) + i\\sin(\\theta_1 + \\theta_2))\\\\\n&|z_1z_2| = |z_1||z_2|\\\\\n&\\operatorname{arg}(z_1z_2) = \\operatorname{arg}(z_1) + \\operatorname{arg}(z_2)\\\\\n&\\frac{z_1}{z_2} = r_1r_2(\\cos(\\theta_1 - \\theta_2) + i\\sin(\\theta_1 - \\theta_2))\\\\\n&\\left|\\frac{z_1}{z_2}\\right| = \\frac{|z_1|}{|z_2|}\\\\\n&\\operatorname{arg}\\left(\\frac{z_1}{z_2}\\right) = \\operatorname{arg}(z_1) - \\operatorname{arg}(z_2)\n\\end{align}\n\\]"
  },
  {
    "objectID": "posts/2025-02-13-complex-plane/index.html#複素数の性質",
    "href": "posts/2025-02-13-complex-plane/index.html#複素数の性質",
    "title": "複素平面と複素数による回転",
    "section": "複素数の性質",
    "text": "複素数の性質\n\nDef: 複素数と 0 \n複素数 \\(z = a + bi = 0\\) のとき，\\(a = b = 0\\) である．\n\nこの定義より，複素数 \\(z\\) の絶対値 \\(\\vert z \\vert = 0\\) であるならば，\n\\[\n\\begin{align}\n\\vert z \\vert = 0 \\Leftrightarrow (a^2 + b^2) = 0 \\Leftrightarrow a = b = 0 \\Leftrightarrow z = 0\n\\end{align}\n\\]\nであることがわかります．\n\nDef: 共役複素数 \n複素数 \\(z = a + bi\\) に対して，\\(a - bi\\) を \\(z\\) の共役複素数と呼び，\\(\\overline z\\) と表す．\n\n足すと 5 になり，掛けると 7 になる２つの数を考えてみたいと思います．それぞれの数を \\(\\alpha, \\beta\\) とすると解と係数の関係より\n\\[\nx^2 - 5x + 7 =0\n\\]\nという二次方程式の解を求めることで求まります．これをといてみると\n\\[\n\\alpha, \\beta = \\frac{5 \\pm \\sqrt{25 - 28}}{2} = \\frac{5 \\pm \\sqrt{3}i}{2}\n\\]\nという複素解がでてきます．また，共役複素数の定義より\n\\[\n\\overline \\alpha = \\beta\n\\]\nであることがわかります．また，もともとの問題が２つの和が \\(5\\), 積が \\(7\\) を満たす数を求める問題であったとことから\n\\[\n\\begin{gather}\n\\alpha + \\overline\\alpha = 5\\\\\n\\alpha \\overline\\alpha = 7\n\\end{gather}\n\\]\nとなりますが，このように共役複素数は積と和が実数になるという特徴が有ります．\n\n\nTheorem 1 \n複素数 \\(z = a + bi\\) について，\n\\[\nz\\overline z = a^2 + b^2\n\\]\nが成り立つ．\n\n\n\n\n\n\n\n\n\nNoteProof\n\n\n\n\n\n\\[\n\\begin{align}\n(a + bi)(a - bi)\n    &= a^2 - (bi)^2\\\\\n    &= a^2 - b^2i^2\\\\\n    &= a^2 + b^2\n\\end{align}\n\\]\n\n\n\n複素数 \\(z = a + bi\\) について，\\(z\\overline{z} = 1\\) となるような複素数 \\(\\overline{z}\\) を（乗法）逆元と呼ぶとき，\n\\[\n\\frac{z\\overline{z}}{a^2 + b^2} = 1\n\\]\nとなることから，\\(\\displaystyle \\frac{\\overline{z}}{\\vert z \\vert^2} = \\frac{\\overline{z}}{z\\overline{z}} = \\frac{a - bi}{a^2 + b^2}\\) が逆源となることがわかります．\n\n\nTheorem 2 : 共役複素数 \n２つの複素数 \\(z, w\\) に対して，\n\\[\n\\begin{gather}\n\\overline{z + w} = \\overline{z} + \\overline{w} \\label{#eq-complex-1}\\\\\n\\overline{z w} = \\overline{z}\\,\\overline{w} \\label{#eq-complex-2}\n\\end{gather}\n\\]\nが成り立つ．\n\n\n\n\n\n\n\n\n\nNoteProof\n\n\n\n\n\n以下では，\\(z = a + bi, w = c + di\\) とします．\n ▶  \\(\\eqref{#eq-complex-1}\\) の証明\n\\[\n\\begin{align}\n\\overline{z + w}\n    &= \\overline{(a + c) + (b+d)i}\\\\\n    &= (a + c) - (b+d)i\\\\\n    &= (a - bi) + (c - di)\\\\\n    &= \\overline{z} + \\overline{w}\n\\end{align}\n\\]\n ▶  \\(\\eqref{#eq-complex-2}\\) の証明\n\\[\n\\begin{align}\n&zw = (ac - bd) + (ad + bc)i\\\\\n\\Rightarrow & \\overline{zw} = (ac - bd) - (ad + bc)i\n\\end{align}\n\\]\n次に\n\\[\n\\begin{align}\n\\overline{z}\\,\\overline{w}\n    &=  (ac - bd) + (ad + bc)i\n\\end{align}\n\\]\nしたがって，\\(\\eqref{#eq-complex-2}\\) が成り立つ．"
  },
  {
    "objectID": "posts/2025-02-13-complex-plane/index.html#複素平面",
    "href": "posts/2025-02-13-complex-plane/index.html#複素平面",
    "title": "複素平面と複素数による回転",
    "section": "複素平面",
    "text": "複素平面\n複素数 \\(z = a + bi\\) は実部と虚部に着目すると２つの実数の組 \\((a, b)\\) と1:1対応していることがわかります．一方，２つの実数の組 \\((a, b)\\) を与えるということは 実数平面空間の１点と対応することと同じなので，平面上の点全体と複素数の全体は１対１に対応するということがわかります．\nこの対応によって，平面が複素数全体であると考えたものを複素平面またはガウス平面と呼びます．複素平面においては，\\(x\\) 軸を実軸，\\(y\\) 軸を虚軸といいます．\n\n極形式の導入\n複素平面において，複素数 \\(z = a + bi\\) の位置ベクトル \\(\\overrightarrow{OZ}\\) について\n\n\\(r\\): \\(||\\overrightarrow{OZ}||\\)\n\\(\\theta\\) : ベクトル \\(\\overrightarrow{OZ}\\) が実軸となす角\n\nと極座標に対応させて考えると，\\(r = |z|\\) となりますし，また偏角についても\n\\[\n\\theta = \\operatorname{arg} z\n\\]\nと表します．ここから複素数について次のような表し方を得ます\n\\[\nz = r(\\cos\\theta + i\\sin\\theta)\n\\]\nこれを \\(z\\) の極形式といいます．\n\n📘 REMARKS \n複素数 \\(z = a + bi\\) について，複素平面上では\n\n\\(-z = -a - bi\\): 原点に関する対称移動\n\\(\\overline{z} = a - bi\\): 実軸に関する対称移動\n\\(-\\overline{z} = -a + bi\\): 虚軸に関する対称移動\n\n\nCode\nimport matplotlib.pyplot as plt\n\n# 複素数の定義（例として z = 2 + 1i）\na, b = 2, 1\nz = complex(a, b)\n\n# 各変換\nminus_z = -z                # -z\nconj_z = z.conjugate()      # z̄\nminus_conj_z = -conj_z      # -z̄\n\n# 複素数の点とラベル\npoints = {\n    \"z\": z,\n    \"-z\": minus_z,\n    \"z̄\": conj_z,\n    \"-z̄\": minus_conj_z\n}\n\n# プロット\nfig, ax = plt.subplots(figsize=(6,6))\nax.set_facecolor(\"#EFF5F5\")\n\nfor label, point in points.items():\n    ax.plot(point.real, point.imag, 'o', c=\"#4477AA\")\n    ax.text(point.real + 0.1, point.imag + 0.1, label, fontsize=12)\n\ndef draw_arrow(from_point, to_point, color):\n    ax.annotate(\"\",\n                xy=(to_point.real, to_point.imag),\n                xytext=(from_point.real, from_point.imag),\n                arrowprops=dict(arrowstyle=\"-&gt;\", color=color, lw=1.2))\n\ndraw_arrow(0, z, \"#4477AA\")\ndraw_arrow(complex(0, z.imag), z, \"#4477AA\")\ndraw_arrow(complex(0, z.imag), minus_conj_z, \"gray\")\ndraw_arrow(0, minus_z, \"gray\")      # z → -z\ndraw_arrow(complex(z.real, 0), conj_z, \"gray\")\ndraw_arrow(complex(z.real, 0), z, \"#4477AA\")\n\n\n# 軸設定\nax.set_xlim(-2.5, 2.5)\nax.set_ylim(-2.5, 2.5)\nax.axhline(0, color='gray', linewidth=0.5)\nax.axvline(0, color='gray', linewidth=0.5)\nax.set_xlabel('Re')\nax.set_ylabel('Im')\n\nax.set_title('Symmetries of complex numbers')\nax.grid(True, which=\"both\", linestyle=\"--\", linewidth=0.5)\nax.set_aspect(\"equal\", adjustable=\"box\")  # Make axes equal scale\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 1\n\n\n\n\n\n\n複素数の積と回転\n２つの複素数 \\(z, w\\) の積を考えます．\n\\[\n\\begin{align}\n\\vert z \\vert = r_1, \\quad & \\operatorname{arg}z = \\theta_1\\\\\n\\vert w \\vert = r_2, \\quad & \\operatorname{arg}w = \\theta_2\n\\end{align}\n\\]\nとおくと，加法定理を用いて以下のように展開できます\n\\[\n\\begin{align}\nzw\n    &= r_1(\\cos\\theta_1 + i \\sin\\theta_1)r_2(\\cos\\theta_2 + i \\sin\\theta_2)\\\\\n    &= r_1r_2\\{(\\cos\\theta_1\\cos\\theta_2 - \\sin\\theta_1\\sin\\theta_1) + i(\\cos\\theta_1\\sin\\theta_2 + \\cos\\theta_2\\sin\\theta_1)\\}\\\\\n    &= r_1r_2(\\cos(\\theta_1 + \\theta_2) + i\\sin(\\theta_1 + \\theta_2))\n\\end{align}\n\\]\nここから以下のことがわかります\n\\[\n\\begin{gather}\n\\vert zw \\vert  = \\vert z\\vert\\, \\vert w \\vert\\\\\n\\operatorname{arg} zw \\equiv \\operatorname{arg} z + \\operatorname{arg} w \\quad(\\operatorname{mod} 2\\pi)\n\\end{gather}\n\\]\n積 \\(zw\\) の位置ベクトルは，\\(z\\) の位置ベクトルを \\(\\vert w \\vert\\) 倍に拡大し，原点 \\(O\\) のまわりに角 \\(\\operatorname{arg} w\\) だけ回転させたものであると解釈できます．\n\nCode\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# --- Define your complex numbers here ---\nz = 1 + 1j\nw = complex(1, np.sqrt(3))\n# ----------------------------------------\n\n## Calculate the product\nproduct = z * w\n\n# Points and labels for scattering (Origin + z, w, product)\nnums_to_label = {\"z\": z, \"w\": w, \"z*w\": product}\npoints = list(nums_to_label.values())\nreal_parts = [p.real for p in points]\nimag_parts = [p.imag for p in points]\nscatter_labels = [f\"{name} = {num:.2f}\" for name, num in nums_to_label.items()]\n\n\n# Create the plot\nfig, ax = plt.subplots(figsize=(6, 6))\nax.set_facecolor(\"#EFF5F5\")\n# Scatter plot for the points\ncolors = [\"#4477AA\", \"gray\", \"#2E45B8\"]  # Origin, z, w, product\nmarkers = [\"o\", \"o\", \"o\"]\nfor i in range(len(points)):\n    ax.scatter(\n        real_parts[i],\n        imag_parts[i],\n        color=colors[i],\n        marker=markers[i],\n        s=50,\n        label=scatter_labels[i],\n    )\n    # Add arrows from origin\n    ax.annotate(\n        \"\",\n        xy=(real_parts[i], imag_parts[i]),\n        xytext=(0, 0),\n        arrowprops=dict(arrowstyle=\"-&gt;\", color=colors[i]),\n    )\n\n# Add argument text annotations\ntext_offset = 0.15  # Small offset for text position, adjust as needed\nfor name, num in nums_to_label.items():\n    # Calculate argument in degrees\n    arg_rad = np.angle(num)\n    arg_deg = np.degrees(arg_rad)\n\n    # Create text label\n    text_label = f\"arg({name}) = {arg_deg:.1f}°\"  # Format to 1 decimal place\n\n    # Position the text slightly offset from the point\n    # You might need to fine-tune text_x, text_y for better placement\n    text_x = num.real + text_offset * np.cos(\n        arg_rad + np.pi / 8\n    )  # Offset slightly outwards\n    text_y = num.imag + text_offset * np.sin(arg_rad + np.pi / 8)\n\n    ax.text(\n        text_x,\n        text_y,\n        text_label,\n        fontsize=9,\n        color=colors[list(nums_to_label.keys()).index(name)],\n    )  # Use point's color\n\n\n# --- Plot Styling ---\n# Set plot limits to ensure all points and text are visible\nmax_abs_val = max(abs(p) for p in points[1:]) if len(points) &gt; 1 else 1\npadding = max_abs_val * 0.4  # Add padding based on magnitude\nax.set_xlim(min(real_parts) - padding, max(real_parts) + padding)\nax.set_ylim(min(imag_parts) - padding, max(imag_parts) + padding)\n\n# Determine symmetric limits centered at 0\nlim = max(abs(l) for l in ax.get_xlim() + ax.get_ylim())\nax.set_xlim(-2, lim)\nax.set_ylim(-1, lim)\n\n\n# Add grid, labels, and title\nax.grid(True, which=\"both\", linestyle=\"--\", linewidth=0.5)\nax.axhline(y=0, color=\"k\", linewidth=0.8)\nax.axvline(x=0, color=\"k\", linewidth=0.8)\nax.set_xlabel(\"Real Axis\")\nax.set_ylabel(\"Imaginary Axis\")\nax.set_title(\"Complex Numbers z, w, z*w, and their Arguments\")\nax.set_aspect(\"equal\", adjustable=\"box\")  # Make axes equal scale\nax.legend()\n\n# Show the plot\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 2\n\n\n\n ▶  加法定理を用いずに回転を理解する\nここでは加法定理を用いずに大きさが1の複素数 \\(\\cos\\theta + i\\sin\\theta\\) を掛ける操作が複素平面上の \\(\\theta\\) 回転を表すことを確認します．\n\\[\n\\begin{gather}\nz = a + ib\\\\\nw = \\cos\\theta + i\\sin\\theta\n\\end{gather}\n\\]\nの２つの複素数の積は\n\\[\n\\begin{align}\nzw\n    &= (a + ib)(\\cos\\theta + i\\sin\\theta)\\\\\n    &= (a\\cos\\theta - b\\sin\\theta) + i(a\\sin\\theta + b\\cos\\theta )\n\\end{align}\n\\]\n以下の図では \\(z = a + ib\\) として\n\n複素数 \\(z\\) と対応する点２次元実数空間に表した点を \\(P =(a, b)\\)\n\\(P\\) を \\(\\theta\\) 回転させた点を \\(Q\\)\n\\(P\\) を \\(90^\\prime\\) 回転させた点を \\(R  = (-b, a)\\)\n\\(\\overrightarrow{OQ}\\) を \\(\\overrightarrow{OP}\\) に正射影したベクトルを \\(\\overrightarrow{OP^\\prime}\\)\n\nとしています．ベクトルの正射影の考え方より\n\\[\n\\begin{align}\n\\overrightarrow{OP^\\prime} = \\vert OQ \\vert \\cos\\theta \\frac{\\overrightarrow{OP}}{\\vert OP\\vert} = \\cos\\theta \\overrightarrow{OP}\\\\\n\\overrightarrow{P^\\prime Q} = \\vert OQ \\vert \\sin\\theta \\frac{\\overrightarrow{OR}}{\\vert OR\\vert} = \\sin\\theta \\overrightarrow{OR}\n\\end{align}\n\\]\n従って，\n\\[\n\\begin{align}\n\\overrightarrow{OQ}\n    &= \\overrightarrow{OP^\\prime} + \\overrightarrow{P^\\prime Q}\\\\\n    &= \\cos\\theta \\overrightarrow{OP} + \\sin\\theta \\overrightarrow{OR}\n\\end{align}\n\\]\nここで，成分を考えると\n\\[\n\\overrightarrow{OQ} = (a\\cos\\theta - b\\sin\\theta, a\\sin\\theta + b\\cos\\theta)\n\\]\nこれは複素数 \\((a\\cos\\theta - b\\sin\\theta) + i(a\\sin\\theta + b\\cos\\theta )\\) に対応しているので，複素数の積 \\(zw\\) は \\(z\\) を \\(\\operatorname{arg} w\\) だけ回転させた複素平面の点に対応することがわかりました．\n\nCode\nimport matplotlib.patches as patches\nimport cmath\n\nfig, ax = plt.subplots(figsize=(6, 6))\nax.set_facecolor(\"#EFF5F5\")\n\n# Circle parameters\nr = 2  # radius\ntheta = np.linspace(0, 2 * np.pi, 500)\ncircle = r * np.exp(1j * theta)\nax.plot(circle.real, circle.imag, label=f\"|z| = {r}\", color=\"gray\")\n\n## define points\nOP = complex(np.sqrt(3), 1)\nOR = OP * 1j\nO = complex(0, 0)\nOQ = complex(np.cos(np.pi / 3), np.sin(np.pi / 3)) * OP\nOP_2 = np.cos(np.pi / 3) * OP\n\n\n## plots\npoints = [OP, OR, OQ]\nscatter_labels = [\"P\", \"R\", \"Q\"]\n\nax.text(\n    0,\n    -0.15,\n    \"O\",\n    fontsize=10,\n    color=\"black\",\n)\n\n# 直交する2本の線を描画\nfor i in range(len(points)):\n    point = points[i]\n    ax.plot([0, point.real], [0, point.imag], \"k\", linewidth=2)  # OP\n    ax.text(\n        point.real,\n        point.imag + 0.05,\n        scatter_labels[i],\n        fontsize=10,\n        color=\"black\",\n    )\n\n## ad P'Q\nax.plot([OP_2.real, OQ.real], [OP_2.imag, OQ.imag], color=\"gray\", linestyle=\"dotted\")\nax.text(\n    OP_2.real + 0.05,\n    OP_2.imag * 0.8,\n    r\"$P^\\prime$\",\n    fontsize=10,\n    color=\"black\",\n)\n\n\n# 直角記号（小さな四角）を原点付近に描画\n# 直角記号（原点から少しオフセット）\ntheta = cmath.phase(OP)  # 60 degrees\northogonal_theta = theta + np.pi / 2  # 90° 直交\noffset = 0.0\n# 直角マークの位置を作成（60°方向に少し移動 → 90°方向に正方形を描く）\nbase_x = offset * np.cos(theta)\nbase_y = offset * np.sin(theta)\nrect_dx = 0.2 * np.cos(orthogonal_theta)\nrect_dy = 0.2 * np.sin(orthogonal_theta)\n\n# 小さな直角マーク（平行四辺形を回転して表現）\nright_angle = patches.Polygon(\n    [\n        (base_x, base_y),\n        (base_x + rect_dx, base_y + rect_dy),\n        (\n            base_x + rect_dx + 0.2 * np.cos(theta),\n            base_y + rect_dy + 0.2 * np.sin(theta),\n        ),\n        (base_x + 0.2 * np.cos(theta), base_y + 0.2 * np.sin(theta)),\n    ],\n    closed=True,\n    edgecolor=\"black\",\n    facecolor=\"none\",\n)\n\nax.add_patch(right_angle)\narc = patches.Arc(\n    (0, 0),\n    0.8,\n    0.8,\n    angle=np.degrees(cmath.phase(OP)),  # start\n    theta1=0,\n    theta2=np.degrees(cmath.phase(OQ)) - np.degrees(cmath.phase(OP)),\n    color=\"black\",\n)\n\n## add angle theta\ntheta_r = 0.5\nax.text(\n    theta_r * np.cos(np.mean([cmath.phase(OQ), cmath.phase(OP)])),\n    theta_r * np.sin(np.mean([cmath.phase(OQ), cmath.phase(OP)])),\n    r\"$\\theta$\",\n    color=\"black\",\n    fontsize=10,\n)\n\nax.add_patch(arc)\n\n# 軸設定\nax.set_xlim(-2.5, 2.5)\nax.set_ylim(-2.5, 2.5)\nax.set_aspect(\"equal\")\nax.grid(True)\n\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 3\n\n\n\n ▶  複素数の割り算\n２つの複素数 \\(z, w\\) を上と同様に考えます． \\(\\vert w \\vert \\neq 0\\) であるとき，\n\\[\n\\begin{align}\n\\frac{1}{w}\n    &= \\frac{1}{r_2(\\cos \\theta_2 + i\\sin\\theta_2)}\\\\\n    &= \\frac{1}{r_2}(\\cos \\theta_2 - i\\sin\\theta_2)\\\\\n    &= \\frac{1}{r_2}(\\cos (-\\theta_2) + i\\sin(-\\theta_2))\\\\\n\\end{align}\n\\]\nであるので\n\\[\n\\begin{align}\n\\frac{z}{w}\n    &= \\frac{r_1}{r_2}\\{(\\cos\\theta_1\\cos(-\\theta_2) - \\sin\\theta_1\\sin(-\\theta_2)) + i(\\cos\\theta_1\\sin(-\\theta_2 )+ \\sin\\theta_1\\cos(-\\theta_2))\\}\\\\\n    &= \\frac{r_1}{r_2}\\{(\\cos\\theta_1\\cos\\theta_2 + \\sin\\theta_1\\sin\\theta_2) + i(-\\cos\\theta_1\\sin\\theta_2 +  \\sin\\theta_1\\cos\\theta_2)\\}\\\\\n    &= \\frac{r_1}{r_2}(\\cos(\\theta_1 - \\theta_2) + i (\\sin\\theta_1 - \\theta_2))\n\\end{align}\n\\]\nしたがって，\n\\[\n\\begin{gather}\n\\bigg\\vert \\frac{z}{w} \\bigg\\vert  = \\frac{\\vert z\\vert}{\\vert w \\vert}\\\\\n\\operatorname{arg}  \\frac{z}{w}  \\equiv \\operatorname{arg} z - \\operatorname{arg} w \\quad(\\operatorname{mod} 2\\pi)\n\\end{gather}\n\\]\n\n\nTheorem 3 : ド・モアブルの公式 \n正の整数 \\(n\\) に対して，\n\\[\n(\\cos\\theta + i\\sin\\theta)^n = \\cos n\\theta + i\\sin n \\theta\n\\]\nが成り立つ．\n\n\n\n\n\n\n\n\n\nNoteProof\n\n\n\n\n\n数学的帰納法を用いて示す．\\(n = 1\\) のとき成立するのは明らか．\\(n = k\\) のとき，ド・モアブルの公式が成立すると仮定すると\n\\[\n\\begin{align}\n(\\cos\\theta + i\\sin\\theta)^{k+1}\n    &= (\\cos\\theta + i\\sin\\theta)^{k} \\cdot (\\cos\\theta + i\\sin\\theta)\\\\\n    &= (\\cos k\\theta + i\\sin k\\theta)(\\cos\\theta + i\\sin\\theta)\\\\\n    &= (\\cos k\\theta \\cos \\theta - \\sin k\\theta\\sin \\theta) + i(\\cos k\\theta \\sin\\theta + \\sin k\\theta \\cos\\theta)\\\\\n    &= \\cos(k\\theta + \\theta) + i\\sin(k\\theta + \\theta)\\\\\n    &= \\cos(k+1)\\theta + i\\sin(k+1) \\theta\n\\end{align}\n\\]\n従って，\\(k+1\\) のときもド・モアブルの公式が成立することがわかる．\n\n\n\n ▶  1の \\(n\\) 乗根を複素数の範囲で求める\n\\(n\\) 乗すると \\(a\\) になる数を \\(a\\) の \\(n\\) 乗根といいます．ここで1の6乗根を求めてみたいと思います．\n\\(z^6 =1\\) より \\(\\vert z \\vert = 1\\). つまり，\n\\[\nz = \\cos\\theta + i \\sin\\theta\n\\]\nと表すことができます．ド・モアブルの公式より\n\\[\nz^6 = \\cos6\\theta + i \\sin6\\theta = 1\n\\]\nつまり，\n\\[\n\\begin{gather}\n6\\theta \\equiv 0 \\, \\operatorname{mod} 2\\pi\n\\end{gather}\n\\]\n\\(\\displaystyle \\zeta = \\cos\\frac{2\\pi}{6} + i \\sin \\frac{2\\pi}{6}\\) とおくと，\n\\[\n(1, \\zeta, \\zeta^2, \\zeta^3, \\zeta^4, \\zeta^5)\n\\]\nが解となります．これをplotすると以下のよう単位円周を６等分した点になることがわかります．\n\nCode\nzeta = complex(np.cos(2 * np.pi / 6), np.sin(2 * np.pi / 6))\npoints = [zeta ** i for i in range(6)]\nscatter_labels = [1] + [fr'$\\zeta^{i}$' for i in range(1, 6)]\n\n# Create the plot\nfig, ax = plt.subplots(figsize=(6, 6))\nax.set_facecolor(\"#EFF5F5\")\nfor i in range(len(points)):\n    ax.scatter(\n        points[i].real,\n        points[i].imag,\n        s=50,\n        color=\"#4477AA\",\n    )\n\n    ax.text(\n        points[i].real,\n        points[i].imag+0.05,\n        scatter_labels[i],\n        fontsize=9,\n        color='black',\n    )\n\n\n# Circle parameters\nr = 1  # radius\ntheta = np.linspace(0, 2 * np.pi, 500)\ncircle = r * np.exp(1j * theta) \nax.plot(circle.real, circle.imag, label=f'|z| = {r}', color='gray')\n\n# Add grids\nax.grid(True, which=\"both\", linestyle=\"--\", linewidth=0.5)\nax.axhline(y=0, color=\"k\", linewidth=0.8)\nax.axvline(x=0, color=\"k\", linewidth=0.8)\nax.set_xlabel(\"Real Axis\")\nax.set_ylabel(\"Imaginary Axis\")\nax.set_title(\"6th Roots of Unity on the Complex Plane\")\nax.set_aspect(\"equal\", adjustable=\"box\")  # Make axes equal scale\nax.legend()\n\n# Show the plot\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 4\n\n\n\n ▶  \\(\\alpha \\in \\mathbb C\\) の \\(n\\) 乗根\n\\(0\\) 出ない一般の複素数 \\(\\alpha = r(\\cos \\theta + i\\sin\\theta)\\) の \\(n\\) 乗根を求めます．\n\\[\nz^n = r(\\cos \\theta + i\\sin\\theta)\n\\]\nであるためには，ド・モアブルの定理より次の条件を満たすのが必要十分となります．\n\\[\n\\begin{align}\n|z|^n &= r\\\\\nn\\operatorname{arg}(z) &= \\theta  + 2k\\pi\\quad(k = 0, 1, 2, 3, \\cdots)\n\\end{align}\n\\]\n重複を避けるために，\\(k = 0, 1, \\cdots, n-1\\) とすると\n\\[\nz_k = r^{1/n}\\left\\{\\cos\\left(\\frac{\\theta}{n} + \\frac{2\\pi}{n}\\times k\\right) + i\\sin\\left(\\frac{\\theta}{n} + \\frac{2\\pi}{n}\\times k\\right)\\right\\}\n\\]\n ▶  大きさが1の複素数とLie群\n大きさが1の複素数の集合は，複素平面で考えると大きさが1の円周になります．この集合を\n\\[\nS = \\{z \\in \\mathbb C | \\vert z\\vert = 1\\}\n\\]\nと表すことができますが，オイラーの公式を用いると\n\\[\nS = \\{\\exp(i\\theta) \\in \\mathbb C | 0 \\leq \\theta &lt; 2\\pi\\}\n\\]\nと表すことができます．このとき，\\(S\\) の元は積の演算で閉じていることがわかります．つまり，\n\\[\n\\exp(i\\theta_1), \\exp(i\\theta_2) \\in S \\Rightarrow \\exp(i\\theta_1)\\exp(i\\theta_2) \\in S\n\\]\nこの積の演算に関して \\(S\\) は以下が成立するので群となります\n\n結合法則: \\((\\exp(i\\theta_1)\\exp(i\\theta_2))\\exp(i\\theta_3) = \\exp(i\\theta_1)(\\exp(i\\theta_2)\\exp(i\\theta_3)) = \\exp(i(\\theta_1 + \\theta_2 + \\theta_3))\\)\n単位元の存在: \\(\\exp(i\\cdot 0) = 1\\)\n逆元の存在: \\(\\exp(i\\theta)\\) に対して，\\(\\exp(-i\\theta)\\) が逆元として定義できる\n\nこのように，大きさが1である複素数の集合を考えることで，図形的な側面だけでなく，演算が定義された代数的な側面を持つ数学的な対象を考えることができます．\n\n\n\n\n\n\n\nNote📘 Key Takeaways\n\n\n\n\n\n ▶  複素ベクトル空間\n１次元複素ベクトル空間 \\(\\mathbb{C}\\) について，複素数 \\(z = a + bi, (a, b \\in \\mathbb R)\\) に対して\n\n\\((a, b)\\) を対応させる写像 \\(\\mathbb C\\to \\mathbb R^2\\) は全単射\n任意の \\(w, z \\in \\mathbb C\\) に対して，\\(w + z\\) の実部と虚部の組は \\(\\mathbb R^2\\) に含まれるので，和を保つ\nスカラーとして \\(\\lambda \\in \\mathbb R\\) を考えると，スカラー倍も保つ\n\n以上より，\\(\\mathbb{C}\\) は２次元実ベクトル空間 \\(\\mathbb R^2\\) と同一視できます．同様に \\(n\\)次元複素ベクトル空間 \\(\\mathbb C^n\\)は \\(2n\\)次元実ベクトル空間 \\(\\mathbb R^{2n}\\) とみなすことができます．\n ▶  複素ベクトル空間と実ベクトル空間の違い\n\nベクトル空間として，実数上で考えるのと複素数上で考えるのでは多くの場合大差はない\n一方，固有値や固有ベクトル，内積を考える場合には違いが生じる"
  },
  {
    "objectID": "posts/2025-02-25-law-of-sines/index.html",
    "href": "posts/2025-02-25-law-of-sines/index.html",
    "title": "正弦定理の考え方",
    "section": "",
    "text": "Exercise 1 \n\\(BC = 30, \\angle B = 70^\\circ, \\angle C = 63^\\circ\\) となるような \\(\\triangle ABC\\) が与えられたとします．このとき，長さ \\(AB\\) を求めよ\n\n\n設問の \\(\\triangle ABC\\) を図示すると以下のようになります．\\(B\\) から \\(AC\\) に対して垂線を垂らし，その交点を \\(BH\\) とします．\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport matplotlib.patches as patches\n\ndef plot_triangular(base_length: float, angles: tuple, fig_size=(6,6)):\n    # Given values\n    BC = 30  # Side BC\n    angle_B = np.radians(angles[0])  # Convert degrees to radians\n    angle_C = np.radians(angles[1])  # Convert degrees to radians\n\n    # Calculate angle A\n    angle_A = np.radians(180 - sum(angles))\n\n    # Use Law of Sines to find AB and AC\n    AB = BC * np.sin(angle_B) / np.sin(angle_A)\n    AC = BC * np.sin(angle_C) / np.sin(angle_A)\n\n    # Set points in a 2D coordinate system\n    B = np.array([0, 0])  # Point B at the origin\n    C = np.array([BC, 0])  # Point C on the x-axis\n\n    # Calculate A's coordinates using trigonometry\n    A_x = BC - AC * np.cos(angle_B)  # Projection of AC on x-axis\n    A_y = AC * np.sin(angle_B)  # Height of A\n\n    A = np.array([A_x, A_y])\n\n    # Plot the triangle using ax\n    fig, ax = plt.subplots(figsize = fig_size)\n    ax.plot([A[0], B[0]], [A[1], B[1]], 'ko-')  # Black line with circle markers\n    ax.plot([B[0], C[0]], [B[1], C[1]], 'ko-')  # Black line with circle markers\n    ax.plot([C[0], A[0]], [C[1], A[1]], 'ko-')  # Black line with circle markers\n\n    # Annotate points\n    ax.text(A[0], A[1], '  A', fontsize=12, verticalalignment='bottom')\n    ax.text(B[0], B[1], '  B', fontsize=12, verticalalignment='top', horizontalalignment='right')\n    ax.text(C[0], C[1], '  C', fontsize=12, verticalalignment='top', horizontalalignment='left')\n\n    # Add angles as arcs\n    arc_radius = 5  # Radius for the arcs\n\n    # Angle at B\n    angle_B_arc = patches.Arc(B, arc_radius, arc_radius, angle=0, theta1=0, theta2=np.degrees(angle_B), color='blue')\n    ax.add_patch(angle_B_arc)\n    ax.text(B[0] + arc_radius/2, B[1] + 1, f\"{70}°\", fontsize=12, color='blue')\n\n    # Angle at C\n    angle_C_arc = patches.Arc(C, arc_radius, arc_radius, angle=0, theta1=180 - np.degrees(angle_C), theta2=180, color='red')\n    ax.add_patch(angle_C_arc)\n    ax.text((C[0] - arc_radius/2) - 2, C[1] + 1, f\"{63}°\", fontsize=12, color='red')\n\n    return fig, ax, (A, B, C)\n\n# plot\nfig, ax, coordinates = plot_triangular(30, (70, 63))\n\n# add BH\nslope = -1/((coordinates[2][1] - coordinates[0][1])/(coordinates[2][0] - coordinates[0][0]))\nax.plot((0, 26.5), (0, slope * 26.5))\nax.text(26.5, slope * 26.5, '  H', fontsize=12, verticalalignment='top', horizontalalignment='left')\n\n# add labels\nax.text(15, -2, \"BC = 30\", fontsize=12, color='black', horizontalalignment='center')\nax.axhline(0, color='black',linewidth=0.5)\nax.axvline(0, color='black',linewidth=0.5)\nax.grid(True, linestyle='--', alpha=0.6)\nax.set_xlim(-5, 35)\nax.set_ylim(-5, 42)\nax.set_title(\"Triangle ABC\")\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 1\n\n\n\n\\(\\triangle BCH, \\triangle ABH\\) を考えると，\n\\[\n\\begin{align}\nBH &= \\sin( A) * AB\\\\\nBH &= \\sin( C) * BC\n\\end{align}\n\\]\nこれを整理すると\n\\[\n\\begin{align}\nAB &= \\frac{\\sin(C) * BC}{\\sin A}\\label{eq-law-of-sines-1}\\\\\n   &= \\frac{30 \\cdot \\sin(63^\\circ)}{\\sin(47^\\circ)}\\label{eq-law-of-sines-2}\n\\end{align}\n\\]\n従って，\n\n\nCode\nprint(f\"BC = {30 * np.sin(63/180 * np.pi)/np.sin(47/180 * np.pi):.4f}\")\n\n\nBC = 36.5489\n\n\nと計算されます．\n\n\n\\(\\eqref{eq-law-of-sines-1}\\), \\(\\eqref{eq-law-of-sines-2}\\) を整理すると\n\\[\n\\frac{AB}{\\sin A} = \\frac{BC}{\\sin C}\n\\]\nを得ます．同様の方法で \\(AC\\) を求めて整理すると，\n\\[\n\\frac{AB}{\\sin A}= \\frac{AC}{\\sin B} = \\frac{BC}{\\sin C}\n\\]\nこれは，\\(\\triangle ABC\\) の外接円を考えたとき，その外接円の半径を \\(R\\) としたとき\n\\[\n\\frac{AB}{\\sin A}= \\frac{AC}{\\sin B} = \\frac{BC}{\\sin C} = 2R\n\\]\nという正弦定理へ繋がります．\n ▶  対辺と\\(\\sin\\) の比率が直径 \\(2R\\)に一致する証明\n\n\n\n\n\n\n\nNoteProof\n\n\n\n\n\n\\(\\triangle ABC\\) の外接円について，弧BC以外の円周上の点 \\(P\\) を適当に取ったときに形成される角度 \\(\\angle BPC\\) を弧BCの円周角といいます． 中心角と円周角の関係として，\n\\[\n\\text{中心角} = 2\\times (\\text{円周角})\n\\]\nここから，「同じ弧に対する円周角は等しい」ことがいえます．ここで，\\(CP\\) が外接円の直径となるように \\(P\\) を取ると直径に対する円周角は直角なので \\(\\triangle BCP\\) は直角三角形となります．\\(CP\\) を斜辺，\\(BC\\)を対辺とすると\n\\[\nBC = 2R \\times \\sin(\\angle BPC) = 2R \\times \\sin(A)\n\\]\n従って，\n\\[\n\\frac{BC}{\\sin A} = 2R\n\\]\n従って，\n\\[\n\\frac{AB}{\\sin A}= \\frac{AC}{\\sin B} = \\frac{BC}{\\sin C} = 2R\n\\]\n\n\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# 与えられた条件\nBC = 30  # 辺BC\nangle_B = np.radians(70)  # 角B (ラジアン変換)\nangle_C = np.radians(63)  # 角C (ラジアン変換)\n\n# 角Aを計算\nangle_A = np.radians(180 - (70 + 63))\n\n# 正弦定理を使ってABとACを求める\nAB = BC * np.sin(angle_B) / np.sin(angle_A)\nAC = BC * np.sin(angle_C) / np.sin(angle_A)\n\n# 頂点座標\nB = np.array([0, 0])  # Bを原点に配置\nC = np.array([BC, 0])  # Cをx軸上に配置\nA_x = BC - AC * np.cos(angle_B)  # Aのx座標\nA_y = AC * np.sin(angle_B)  # Aのy座標\nA = np.array([A_x, A_y])\n\n# 垂直二等分線の交点（外心）を求める\ndef circumcenter(A, B, C):\n    D = 2 * (A[0] * (B[1] - C[1]) + B[0] * (C[1] - A[1]) + C[0] * (A[1] - B[1]))\n    Ux = ((A[0]**2 + A[1]**2) * (B[1] - C[1]) + (B[0]**2 + B[1]**2) * (C[1] - A[1]) + (C[0]**2 + C[1]**2) * (A[1] - B[1])) / D\n    Uy = ((A[0]**2 + A[1]**2) * (C[0] - B[0]) + (B[0]**2 + B[1]**2) * (A[0] - C[0]) + (C[0]**2 + C[1]**2) * (B[0] - A[0])) / D\n    return np.array([Ux, Uy])\n\ncircumcenter_point = circumcenter(A, B, C)\nradius = np.linalg.norm(A - circumcenter_point)  # 外接円の半径\n\n# 円周上の点P（円周角を示す）\ntheta_P = np.radians(120)  # 任意の角度 (120°)\nP_x = circumcenter_point[0] + radius * np.cos(theta_P)\nP_y = circumcenter_point[1] + radius * np.sin(theta_P)\nP = np.array([0, 30/np.sin(angle_A) * np.sin(np.pi/2 - angle_A)])\n\n# 図を作成\nfig, ax = plt.subplots(figsize=(6,6))\n\n# 三角形ABCをプロット\nax.plot([A[0], B[0]], [A[1], B[1]], 'bo-', label=\"AB\")\nax.plot([B[0], C[0]], [B[1], C[1]], 'ro-', label=\"BC\")\nax.plot([C[0], A[0]], [C[1], A[1]], 'go-', label=\"CA\")\n\n# 外接円をプロット\ncircle = plt.Circle(circumcenter_point, radius, color='cyan', fill=False, linestyle='dashed', label=\"Circumcircle\")\nax.add_patch(circle)\n\n# 円周角を示す点Pと三角形BPC\nax.plot([B[0], P[0]], [B[1], P[1]], 'purple', linestyle='dotted', label=\"BP\")\nax.plot([C[0], P[0]], [C[1], P[1]], 'purple', linestyle='dotted', label=\"CP\")\n\n# 点のラベル\nax.text(A[0], A[1], '  A', fontsize=12, verticalalignment='bottom')\nax.text(B[0], B[1], '  B', fontsize=12, verticalalignment='top', horizontalalignment='right')\nax.text(C[0], C[1], '  C', fontsize=12, verticalalignment='top', horizontalalignment='left')\nax.text(P[0], P[1], '  P', fontsize=12, verticalalignment='bottom', horizontalalignment='right', color='purple')\nax.scatter(circumcenter_point[0], circumcenter_point[1], color='black')  # 外心O\n\n# グリッドと範囲設定\nax.axhline(0, color='black', linewidth=0.5)\nax.axvline(0, color='black', linewidth=0.5)\nax.grid(True, linestyle='--', alpha=0.6)\nax.set_xlim(-radius-5, BC+radius+5)\nax.set_ylim(-radius-5, radius+AC+5)\nax.legend()\nax.set_title(\"Triangle ABC with Circumcircle and Inscribed Angle\")\n\n# 図を表示\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 2\n\n\n\n\n\n\n\n\nExercise 2 \nとある山へハイキングにいくとします．\n\n山頂をC\n山の麓のA地点から同じ標高で直線距離で1000m離れている地点をB\nA地点からCを見たときの仰角は \\(30^\\circ\\)\n\\(\\triangle ABC\\) について，\\(\\angle CAB = 75^\\circ, \\angle ABC = 45^\\circ\\)\n\nということがわかっているとします．このとき，Cの標高を求めよ．なお，\\(A, B\\) の標高は 0m とする．\n\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.mplot3d.art3d import Poly3DCollection\n\n# Given angles and side lengths\nangle_A = np.radians(75)\nangle_B = np.radians(45)\nAB = 1000  # Given\n\n# Compute angle C\nangle_C = np.radians(180 - 75 - 45)  # C = 60 degrees\n\n# Compute sides using the Law of Sines\nBC = AB * np.sin(angle_A) / np.sin(angle_C)\nAC = AB * np.sin(angle_B) / np.sin(angle_C)\n\n# Compute coordinates of A, B, and C\nA = np.array([0, 0, 0])  # A is the origin\nB = np.array([AB, 0, 0])  # B is along the x-axis\nC_x = 0  # Projection of AC on x-axis\nC_y = AC * np.cos(np.radians(30))\nC_z = AC * np.sin(np.radians(30))  # Projection on y-axis\nC = np.array([0, C_y, C_z])  # C remains in the XY plane\n\n# Triangle ACH: Given CAH = 30°, CHA = 90° (Right Triangle)\nangle_CAH = np.radians(30)\n\n# H's coordinates (directly above C in the Z direction)\nH = np.array([0, C_y, 0])\n\n# Create 3D plot\nfig = plt.figure(figsize=(8, 8))\nax = fig.add_subplot(111, projection='3d')\n\n# Plot edges of tetrahedron\nedges = [\n    (A, B), (B, C), (C, A),  # Triangle ABC\n    (A, H), (C, H), (B, H)   # Connecting H to A, C, and B\n]\n\nfor edge in edges:\n    ax.plot(*zip(*edge), 'k-')\n\n# Define faces for tetrahedron visualization\nfaces = [\n    [A, B, C],  # Base ABC\n    [A, C, H],  # Side ACH\n    [C, B, H],  # Side CBH\n    [A, H, B]   # Side AHB\n]\n\n# Add face shading\nax.add_collection3d(Poly3DCollection(faces, alpha=0.3, color='cyan'))\n\n# Annotate points\nax.text(*A, \" A\", color='black', fontsize=12)\nax.text(*B, \" B\", color='black', fontsize=12)\nax.text(*C, \" C\", color='black', fontsize=12)\nax.text(*H, \" H\", color='black', fontsize=12)\n\n# Labels and grid\nax.set_xlabel(\"X-axis\")\nax.set_ylabel(\"Y-axis\")\nax.set_zlabel(\"Z-axis\")\nax.set_title(\"3D Tetrahedron CAHB\")\nax.grid(True)\n\nax.view_init(elev=20, azim=-55) \n\n# Show the plot\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 3\n\n\n\n\n\n\n\n\n\n\nNoteSolution\n\n\n\n\n\n上の図のようにCから\\(XY\\)平面に垂線を下ろして，XY平面との交点を \\(H\\) としたとき，今回求めたい長さは \\(CH\\)．\n問題文の情報を用いて正弦定理を利用すると\n\\[\n\\displaystyle AC = \\frac{AB}{\\sin (\\angle ACB)} \\cdot \\sin(\\angle ABC)\n\\]\nここで\n\\[\n\\begin{align}\nCH &= AC \\cdot \\sin(\\angle CAH)\\\\\n    &= \\frac{AB}{\\sin (\\angle ACB)} \\cdot \\sin(\\angle ABC) \\cdot \\sin(\\angle CAH)\n\\end{align}\n\\]\n従って，\n\n\nCode\nprint(f\"CH = {C_z:.2f}\")\n\n\nCH = 408.25"
  },
  {
    "objectID": "posts/2025-02-25-law-of-sines/index.html#正弦定理の考え方",
    "href": "posts/2025-02-25-law-of-sines/index.html#正弦定理の考え方",
    "title": "正弦定理の考え方",
    "section": "",
    "text": "Exercise 1 \n\\(BC = 30, \\angle B = 70^\\circ, \\angle C = 63^\\circ\\) となるような \\(\\triangle ABC\\) が与えられたとします．このとき，長さ \\(AB\\) を求めよ\n\n\n設問の \\(\\triangle ABC\\) を図示すると以下のようになります．\\(B\\) から \\(AC\\) に対して垂線を垂らし，その交点を \\(BH\\) とします．\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport matplotlib.patches as patches\n\ndef plot_triangular(base_length: float, angles: tuple, fig_size=(6,6)):\n    # Given values\n    BC = 30  # Side BC\n    angle_B = np.radians(angles[0])  # Convert degrees to radians\n    angle_C = np.radians(angles[1])  # Convert degrees to radians\n\n    # Calculate angle A\n    angle_A = np.radians(180 - sum(angles))\n\n    # Use Law of Sines to find AB and AC\n    AB = BC * np.sin(angle_B) / np.sin(angle_A)\n    AC = BC * np.sin(angle_C) / np.sin(angle_A)\n\n    # Set points in a 2D coordinate system\n    B = np.array([0, 0])  # Point B at the origin\n    C = np.array([BC, 0])  # Point C on the x-axis\n\n    # Calculate A's coordinates using trigonometry\n    A_x = BC - AC * np.cos(angle_B)  # Projection of AC on x-axis\n    A_y = AC * np.sin(angle_B)  # Height of A\n\n    A = np.array([A_x, A_y])\n\n    # Plot the triangle using ax\n    fig, ax = plt.subplots(figsize = fig_size)\n    ax.plot([A[0], B[0]], [A[1], B[1]], 'ko-')  # Black line with circle markers\n    ax.plot([B[0], C[0]], [B[1], C[1]], 'ko-')  # Black line with circle markers\n    ax.plot([C[0], A[0]], [C[1], A[1]], 'ko-')  # Black line with circle markers\n\n    # Annotate points\n    ax.text(A[0], A[1], '  A', fontsize=12, verticalalignment='bottom')\n    ax.text(B[0], B[1], '  B', fontsize=12, verticalalignment='top', horizontalalignment='right')\n    ax.text(C[0], C[1], '  C', fontsize=12, verticalalignment='top', horizontalalignment='left')\n\n    # Add angles as arcs\n    arc_radius = 5  # Radius for the arcs\n\n    # Angle at B\n    angle_B_arc = patches.Arc(B, arc_radius, arc_radius, angle=0, theta1=0, theta2=np.degrees(angle_B), color='blue')\n    ax.add_patch(angle_B_arc)\n    ax.text(B[0] + arc_radius/2, B[1] + 1, f\"{70}°\", fontsize=12, color='blue')\n\n    # Angle at C\n    angle_C_arc = patches.Arc(C, arc_radius, arc_radius, angle=0, theta1=180 - np.degrees(angle_C), theta2=180, color='red')\n    ax.add_patch(angle_C_arc)\n    ax.text((C[0] - arc_radius/2) - 2, C[1] + 1, f\"{63}°\", fontsize=12, color='red')\n\n    return fig, ax, (A, B, C)\n\n# plot\nfig, ax, coordinates = plot_triangular(30, (70, 63))\n\n# add BH\nslope = -1/((coordinates[2][1] - coordinates[0][1])/(coordinates[2][0] - coordinates[0][0]))\nax.plot((0, 26.5), (0, slope * 26.5))\nax.text(26.5, slope * 26.5, '  H', fontsize=12, verticalalignment='top', horizontalalignment='left')\n\n# add labels\nax.text(15, -2, \"BC = 30\", fontsize=12, color='black', horizontalalignment='center')\nax.axhline(0, color='black',linewidth=0.5)\nax.axvline(0, color='black',linewidth=0.5)\nax.grid(True, linestyle='--', alpha=0.6)\nax.set_xlim(-5, 35)\nax.set_ylim(-5, 42)\nax.set_title(\"Triangle ABC\")\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 1\n\n\n\n\\(\\triangle BCH, \\triangle ABH\\) を考えると，\n\\[\n\\begin{align}\nBH &= \\sin( A) * AB\\\\\nBH &= \\sin( C) * BC\n\\end{align}\n\\]\nこれを整理すると\n\\[\n\\begin{align}\nAB &= \\frac{\\sin(C) * BC}{\\sin A}\\label{eq-law-of-sines-1}\\\\\n   &= \\frac{30 \\cdot \\sin(63^\\circ)}{\\sin(47^\\circ)}\\label{eq-law-of-sines-2}\n\\end{align}\n\\]\n従って，\n\n\nCode\nprint(f\"BC = {30 * np.sin(63/180 * np.pi)/np.sin(47/180 * np.pi):.4f}\")\n\n\nBC = 36.5489\n\n\nと計算されます．\n\n\n\\(\\eqref{eq-law-of-sines-1}\\), \\(\\eqref{eq-law-of-sines-2}\\) を整理すると\n\\[\n\\frac{AB}{\\sin A} = \\frac{BC}{\\sin C}\n\\]\nを得ます．同様の方法で \\(AC\\) を求めて整理すると，\n\\[\n\\frac{AB}{\\sin A}= \\frac{AC}{\\sin B} = \\frac{BC}{\\sin C}\n\\]\nこれは，\\(\\triangle ABC\\) の外接円を考えたとき，その外接円の半径を \\(R\\) としたとき\n\\[\n\\frac{AB}{\\sin A}= \\frac{AC}{\\sin B} = \\frac{BC}{\\sin C} = 2R\n\\]\nという正弦定理へ繋がります．\n ▶  対辺と\\(\\sin\\) の比率が直径 \\(2R\\)に一致する証明\n\n\n\n\n\n\n\nNoteProof\n\n\n\n\n\n\\(\\triangle ABC\\) の外接円について，弧BC以外の円周上の点 \\(P\\) を適当に取ったときに形成される角度 \\(\\angle BPC\\) を弧BCの円周角といいます． 中心角と円周角の関係として，\n\\[\n\\text{中心角} = 2\\times (\\text{円周角})\n\\]\nここから，「同じ弧に対する円周角は等しい」ことがいえます．ここで，\\(CP\\) が外接円の直径となるように \\(P\\) を取ると直径に対する円周角は直角なので \\(\\triangle BCP\\) は直角三角形となります．\\(CP\\) を斜辺，\\(BC\\)を対辺とすると\n\\[\nBC = 2R \\times \\sin(\\angle BPC) = 2R \\times \\sin(A)\n\\]\n従って，\n\\[\n\\frac{BC}{\\sin A} = 2R\n\\]\n従って，\n\\[\n\\frac{AB}{\\sin A}= \\frac{AC}{\\sin B} = \\frac{BC}{\\sin C} = 2R\n\\]\n\n\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# 与えられた条件\nBC = 30  # 辺BC\nangle_B = np.radians(70)  # 角B (ラジアン変換)\nangle_C = np.radians(63)  # 角C (ラジアン変換)\n\n# 角Aを計算\nangle_A = np.radians(180 - (70 + 63))\n\n# 正弦定理を使ってABとACを求める\nAB = BC * np.sin(angle_B) / np.sin(angle_A)\nAC = BC * np.sin(angle_C) / np.sin(angle_A)\n\n# 頂点座標\nB = np.array([0, 0])  # Bを原点に配置\nC = np.array([BC, 0])  # Cをx軸上に配置\nA_x = BC - AC * np.cos(angle_B)  # Aのx座標\nA_y = AC * np.sin(angle_B)  # Aのy座標\nA = np.array([A_x, A_y])\n\n# 垂直二等分線の交点（外心）を求める\ndef circumcenter(A, B, C):\n    D = 2 * (A[0] * (B[1] - C[1]) + B[0] * (C[1] - A[1]) + C[0] * (A[1] - B[1]))\n    Ux = ((A[0]**2 + A[1]**2) * (B[1] - C[1]) + (B[0]**2 + B[1]**2) * (C[1] - A[1]) + (C[0]**2 + C[1]**2) * (A[1] - B[1])) / D\n    Uy = ((A[0]**2 + A[1]**2) * (C[0] - B[0]) + (B[0]**2 + B[1]**2) * (A[0] - C[0]) + (C[0]**2 + C[1]**2) * (B[0] - A[0])) / D\n    return np.array([Ux, Uy])\n\ncircumcenter_point = circumcenter(A, B, C)\nradius = np.linalg.norm(A - circumcenter_point)  # 外接円の半径\n\n# 円周上の点P（円周角を示す）\ntheta_P = np.radians(120)  # 任意の角度 (120°)\nP_x = circumcenter_point[0] + radius * np.cos(theta_P)\nP_y = circumcenter_point[1] + radius * np.sin(theta_P)\nP = np.array([0, 30/np.sin(angle_A) * np.sin(np.pi/2 - angle_A)])\n\n# 図を作成\nfig, ax = plt.subplots(figsize=(6,6))\n\n# 三角形ABCをプロット\nax.plot([A[0], B[0]], [A[1], B[1]], 'bo-', label=\"AB\")\nax.plot([B[0], C[0]], [B[1], C[1]], 'ro-', label=\"BC\")\nax.plot([C[0], A[0]], [C[1], A[1]], 'go-', label=\"CA\")\n\n# 外接円をプロット\ncircle = plt.Circle(circumcenter_point, radius, color='cyan', fill=False, linestyle='dashed', label=\"Circumcircle\")\nax.add_patch(circle)\n\n# 円周角を示す点Pと三角形BPC\nax.plot([B[0], P[0]], [B[1], P[1]], 'purple', linestyle='dotted', label=\"BP\")\nax.plot([C[0], P[0]], [C[1], P[1]], 'purple', linestyle='dotted', label=\"CP\")\n\n# 点のラベル\nax.text(A[0], A[1], '  A', fontsize=12, verticalalignment='bottom')\nax.text(B[0], B[1], '  B', fontsize=12, verticalalignment='top', horizontalalignment='right')\nax.text(C[0], C[1], '  C', fontsize=12, verticalalignment='top', horizontalalignment='left')\nax.text(P[0], P[1], '  P', fontsize=12, verticalalignment='bottom', horizontalalignment='right', color='purple')\nax.scatter(circumcenter_point[0], circumcenter_point[1], color='black')  # 外心O\n\n# グリッドと範囲設定\nax.axhline(0, color='black', linewidth=0.5)\nax.axvline(0, color='black', linewidth=0.5)\nax.grid(True, linestyle='--', alpha=0.6)\nax.set_xlim(-radius-5, BC+radius+5)\nax.set_ylim(-radius-5, radius+AC+5)\nax.legend()\nax.set_title(\"Triangle ABC with Circumcircle and Inscribed Angle\")\n\n# 図を表示\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 2\n\n\n\n\n\n\n\n\nExercise 2 \nとある山へハイキングにいくとします．\n\n山頂をC\n山の麓のA地点から同じ標高で直線距離で1000m離れている地点をB\nA地点からCを見たときの仰角は \\(30^\\circ\\)\n\\(\\triangle ABC\\) について，\\(\\angle CAB = 75^\\circ, \\angle ABC = 45^\\circ\\)\n\nということがわかっているとします．このとき，Cの標高を求めよ．なお，\\(A, B\\) の標高は 0m とする．\n\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.mplot3d.art3d import Poly3DCollection\n\n# Given angles and side lengths\nangle_A = np.radians(75)\nangle_B = np.radians(45)\nAB = 1000  # Given\n\n# Compute angle C\nangle_C = np.radians(180 - 75 - 45)  # C = 60 degrees\n\n# Compute sides using the Law of Sines\nBC = AB * np.sin(angle_A) / np.sin(angle_C)\nAC = AB * np.sin(angle_B) / np.sin(angle_C)\n\n# Compute coordinates of A, B, and C\nA = np.array([0, 0, 0])  # A is the origin\nB = np.array([AB, 0, 0])  # B is along the x-axis\nC_x = 0  # Projection of AC on x-axis\nC_y = AC * np.cos(np.radians(30))\nC_z = AC * np.sin(np.radians(30))  # Projection on y-axis\nC = np.array([0, C_y, C_z])  # C remains in the XY plane\n\n# Triangle ACH: Given CAH = 30°, CHA = 90° (Right Triangle)\nangle_CAH = np.radians(30)\n\n# H's coordinates (directly above C in the Z direction)\nH = np.array([0, C_y, 0])\n\n# Create 3D plot\nfig = plt.figure(figsize=(8, 8))\nax = fig.add_subplot(111, projection='3d')\n\n# Plot edges of tetrahedron\nedges = [\n    (A, B), (B, C), (C, A),  # Triangle ABC\n    (A, H), (C, H), (B, H)   # Connecting H to A, C, and B\n]\n\nfor edge in edges:\n    ax.plot(*zip(*edge), 'k-')\n\n# Define faces for tetrahedron visualization\nfaces = [\n    [A, B, C],  # Base ABC\n    [A, C, H],  # Side ACH\n    [C, B, H],  # Side CBH\n    [A, H, B]   # Side AHB\n]\n\n# Add face shading\nax.add_collection3d(Poly3DCollection(faces, alpha=0.3, color='cyan'))\n\n# Annotate points\nax.text(*A, \" A\", color='black', fontsize=12)\nax.text(*B, \" B\", color='black', fontsize=12)\nax.text(*C, \" C\", color='black', fontsize=12)\nax.text(*H, \" H\", color='black', fontsize=12)\n\n# Labels and grid\nax.set_xlabel(\"X-axis\")\nax.set_ylabel(\"Y-axis\")\nax.set_zlabel(\"Z-axis\")\nax.set_title(\"3D Tetrahedron CAHB\")\nax.grid(True)\n\nax.view_init(elev=20, azim=-55) \n\n# Show the plot\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 3\n\n\n\n\n\n\n\n\n\n\nNoteSolution\n\n\n\n\n\n上の図のようにCから\\(XY\\)平面に垂線を下ろして，XY平面との交点を \\(H\\) としたとき，今回求めたい長さは \\(CH\\)．\n問題文の情報を用いて正弦定理を利用すると\n\\[\n\\displaystyle AC = \\frac{AB}{\\sin (\\angle ACB)} \\cdot \\sin(\\angle ABC)\n\\]\nここで\n\\[\n\\begin{align}\nCH &= AC \\cdot \\sin(\\angle CAH)\\\\\n    &= \\frac{AB}{\\sin (\\angle ACB)} \\cdot \\sin(\\angle ABC) \\cdot \\sin(\\angle CAH)\n\\end{align}\n\\]\n従って，\n\n\nCode\nprint(f\"CH = {C_z:.2f}\")\n\n\nCH = 408.25"
  },
  {
    "objectID": "posts/2025-01-30-differential-equations/index.html",
    "href": "posts/2025-01-30-differential-equations/index.html",
    "title": "微分方程式を用いたToy models",
    "section": "",
    "text": "Exercise 1 : マルサスの人口論 \n時刻 \\(t\\) におけるとある国の人口が \\(N(t) &gt; 0\\) で表されるとする．マルサスは時刻 \\(t\\) から \\(t+\\Delta t\\) の人口増分 \\(\\Delta N = N(t+\\Delta) - N(t)\\) は\n\\[\n\\Delta N = k N(t)\\Delta t \\qquad (k: \\text{constant})\n\\]\nのように \\(N, \\Delta t\\) に比例するとした．ここから以下のように式変形を行い\n\\[\n\\frac{\\Delta N}{\\Delta t} = k N(t)\n\\]\n\\(\\Delta t\\to 0\\) として次のような微分方程式を得たとします\n\\[\n\\frac{dN(t)}{dt} = kN(t) \\label{eq-de-01}\n\\]\n\\((t, N(t))\\) が \\((0, 1.00 \\times 10^8), (1, 1.25 \\times 10^8)\\) と与えられているとき，\\(t = 2\\) の人口 \\(N(2)\\) を推定せよ．\n\n\n\n\n\n\n\n\n\nNoteSolution\n\n\n\n\n\n微分方程式 \\(\\eqref{eq-de-01}\\) を以下のように変形し積分すると\n\\[\n\\begin{align}\n&\\frac{dN(t)}{dt} = kN(t) \\\\\n&\\Rightarrow \\int \\frac{1}{N(t)}\\frac{dN(t)}{dt} dt= \\int k dt \\\\\n&\\Rightarrow \\log \\vert N(t) \\vert = kt + C\\\\[5pt]\n&\\Rightarrow \\log N(t) = kt + C\n\\end{align}\n\\]\n従って，\n\\[\nN(t) = \\exp(C + kt) = \\tilde C\\exp(kt)\n\\]\n\\(t = 0\\) のときの \\(N(0) = N_0\\) とすると，\\(\\tilde C = N_0\\) でなければならないので\n\\[\nN(t) = N_0\\exp(kt) \\label{eq-malthus-solution}\n\\]\n\\((t, N(t))\\) が \\((0, 1.00 \\times 10^8), (1, 1.25 \\times 10^8)\\) と与えられているので，\n\\[\nN_0 = 1.00 \\times 10^8\n\\]\n次に\n\\[\n\\begin{align}\n&N(1) = 1.00 \\times 10^8 \\exp(k)\\\\[5pt]\n&\\Rightarrow \\exp(k) = 1.25\n\\end{align}\n\\]\n従って，\n\\[\nN(2) = (1.25)^2 \\times 10^8 \\approx 1.56 \\times 10^8\n\\]\n\n\n\n ▶  Python Simulation\nscipy.integrateパッケージのodeintを用いれば微分方程式を解くことができます．\n\nCode\nimport numpy as np\nfrom scipy.integrate import odeint\nimport matplotlib.pyplot as plt\n\n# malthusian growth func\ndef malthusian_model(y, t, k=np.log(1.25)):\n    dydt = k * y\n    return dydt\n\n# init\nN_0 = 1.0\n\n# data point\ndata = (0, 1), (1, 1.25)\n\n# time\nt = np.linspace(0, 5, 21)\n\n# solve\nn = odeint(malthusian_model, N_0, t)\n\n# plot\nplt.plot(t, n)\nplt.scatter(*zip(*data), color='red', label='observed data points')\nplt.legend()\nplt.xlabel(\"t\")\nplt.ylabel(\"$N(t)$\")\nplt.title(\"Malthusian gwrowth simulation\")\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 1\n\n\n\nFigure 1 をみると \\(N(t)\\) は指数関数的に増加していることが読み取れます．これは \\(k\\) の符号に依存しています．\n\n\\(k &gt; 0\\): 指数関数的増加\n\\(k = 0\\): 変化なし\n\\(k &lt; 0\\): 指数関数的減衰\n\nとなります．図示すると以下のようになります\n\nCode\nimport statsmodels.api as sm\n\n# params\nk_args = (-0.2, 0, 0.2)\n\n# solve\nfor k in k_args:\n    n = odeint(malthusian_model, N_0, t, args=(k,))\n    plt.plot(t, n, label=f\"k={k}\")\n\nplt.legend()\nplt.xlabel(\"t\")\nplt.ylabel(\"$N(t)$\")\nplt.title(\"Malthusian growth simulation with different $k$\")\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 2\n\n\n\n\n\n\n\n\n\nTip🍵 マルサスモデルの限界\n\n\n\nマルサスモデルは，\\(k &gt; 0\\) のとき人口が指数関数的に増加すると予測しています．実際には，食料や石油といった資源は有限であるので人口増加を抑制する要因があるため，現実でマルサスモデル的増加をすることは到底起こりえません．\n\n\n\n\n\n\\(N(t)\\) は 4期間ごとに観測される(=観測されるtは\\((0, 1, 2, 4)\\))\n観測される \\(N(t)\\) にはノイズが乗ってしまっている: \\(\\epsilon_t \\sim N(0, 0.1)\\)\n\nという状況ののもと，\\((N_0, k)\\) を推定し，\\(t&gt;4\\) の範囲の人口について予測することはできるのか？という問題を考えてみます．\n\\(\\eqref{eq-malthus-solution}\\) について対数を取ると\n\\[\n\\log N(t) = \\log(N_0) + kt\n\\]\nとなります．つまり，対数変換した変数についての線形モデルとして推定量を考えることができます．観測ノイズ \\(\\epsilon_t\\) を踏まえると，観測される人口を \\(\\tilde N(t)\\) とすると\n\\[\n\\begin{align}\n&\\tilde N(t) = N_0\\exp(kt) + \\epsilon_t\\\\\n&\\Rightarrow\\log \\tilde N(t) = \\log (N_0\\exp(kt) + \\epsilon_t)\n\\end{align}\n\\]\nとなってしまいますが，近似式として\n\\[\n\\log\\tilde N(t) = \\alpha + \\beta t + e_i\n\\]\nで推定するとします．\\(\\epsilon_i\\)がhomogeneousとしても\\(e_i\\)がhomogeneousとは限らないのでheteroskedasticity residual erroを想定して推定します．\n\nCode\nimport statsmodels.api as sm\n\nnp.random.seed(42)\n\n# observation step\nSTEP = 4\n\n# DGP\nactual_n = n.flatten()\nobserved_n = actual_n[::STEP][:-1] + +np.random.normal(0, 0.1, len(actual_n[::STEP][:-1]))\nobserved_t = t[::STEP][:-1]\nX = sm.add_constant(observed_t)\n\n# fit\nmodel = sm.OLS(np.log(observed_n), X).fit(cov_type=\"HC0\")\nestimated_n_0, estimated_k = model.params\n\n# simulation\nsimulated_n = odeint(malthusian_model, np.exp(estimated_n_0), t, args=(estimated_k,))\n\n# plot\nplt.plot(t, simulated_n, label=\"simulated\")\nplt.scatter(observed_t, observed_n, color=\"gray\", alpha=0.8, marker='x', label=\"actual data points\")\nplt.scatter(t, actual_n, color=\"red\", alpha=0.8, label=\"actual data points\")\nplt.legend()\nplt.xlabel(\"t\")\nplt.ylabel(\"$N(t)$\")\nplt.title(\"Malthusian growth prediction\")\nplt.axvspan(4.25, t[-1], color='gray', alpha=0.3)\nplt.text(4.65, 2.0, \"Prediction\\nPeriod\", ha='center', va='center', fontsize=11, color='black')\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 3"
  },
  {
    "objectID": "posts/2025-01-30-differential-equations/index.html#マルサスモデル",
    "href": "posts/2025-01-30-differential-equations/index.html#マルサスモデル",
    "title": "微分方程式を用いたToy models",
    "section": "",
    "text": "Exercise 1 : マルサスの人口論 \n時刻 \\(t\\) におけるとある国の人口が \\(N(t) &gt; 0\\) で表されるとする．マルサスは時刻 \\(t\\) から \\(t+\\Delta t\\) の人口増分 \\(\\Delta N = N(t+\\Delta) - N(t)\\) は\n\\[\n\\Delta N = k N(t)\\Delta t \\qquad (k: \\text{constant})\n\\]\nのように \\(N, \\Delta t\\) に比例するとした．ここから以下のように式変形を行い\n\\[\n\\frac{\\Delta N}{\\Delta t} = k N(t)\n\\]\n\\(\\Delta t\\to 0\\) として次のような微分方程式を得たとします\n\\[\n\\frac{dN(t)}{dt} = kN(t) \\label{eq-de-01}\n\\]\n\\((t, N(t))\\) が \\((0, 1.00 \\times 10^8), (1, 1.25 \\times 10^8)\\) と与えられているとき，\\(t = 2\\) の人口 \\(N(2)\\) を推定せよ．\n\n\n\n\n\n\n\n\n\nNoteSolution\n\n\n\n\n\n微分方程式 \\(\\eqref{eq-de-01}\\) を以下のように変形し積分すると\n\\[\n\\begin{align}\n&\\frac{dN(t)}{dt} = kN(t) \\\\\n&\\Rightarrow \\int \\frac{1}{N(t)}\\frac{dN(t)}{dt} dt= \\int k dt \\\\\n&\\Rightarrow \\log \\vert N(t) \\vert = kt + C\\\\[5pt]\n&\\Rightarrow \\log N(t) = kt + C\n\\end{align}\n\\]\n従って，\n\\[\nN(t) = \\exp(C + kt) = \\tilde C\\exp(kt)\n\\]\n\\(t = 0\\) のときの \\(N(0) = N_0\\) とすると，\\(\\tilde C = N_0\\) でなければならないので\n\\[\nN(t) = N_0\\exp(kt) \\label{eq-malthus-solution}\n\\]\n\\((t, N(t))\\) が \\((0, 1.00 \\times 10^8), (1, 1.25 \\times 10^8)\\) と与えられているので，\n\\[\nN_0 = 1.00 \\times 10^8\n\\]\n次に\n\\[\n\\begin{align}\n&N(1) = 1.00 \\times 10^8 \\exp(k)\\\\[5pt]\n&\\Rightarrow \\exp(k) = 1.25\n\\end{align}\n\\]\n従って，\n\\[\nN(2) = (1.25)^2 \\times 10^8 \\approx 1.56 \\times 10^8\n\\]\n\n\n\n ▶  Python Simulation\nscipy.integrateパッケージのodeintを用いれば微分方程式を解くことができます．\n\nCode\nimport numpy as np\nfrom scipy.integrate import odeint\nimport matplotlib.pyplot as plt\n\n# malthusian growth func\ndef malthusian_model(y, t, k=np.log(1.25)):\n    dydt = k * y\n    return dydt\n\n# init\nN_0 = 1.0\n\n# data point\ndata = (0, 1), (1, 1.25)\n\n# time\nt = np.linspace(0, 5, 21)\n\n# solve\nn = odeint(malthusian_model, N_0, t)\n\n# plot\nplt.plot(t, n)\nplt.scatter(*zip(*data), color='red', label='observed data points')\nplt.legend()\nplt.xlabel(\"t\")\nplt.ylabel(\"$N(t)$\")\nplt.title(\"Malthusian gwrowth simulation\")\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 1\n\n\n\nFigure 1 をみると \\(N(t)\\) は指数関数的に増加していることが読み取れます．これは \\(k\\) の符号に依存しています．\n\n\\(k &gt; 0\\): 指数関数的増加\n\\(k = 0\\): 変化なし\n\\(k &lt; 0\\): 指数関数的減衰\n\nとなります．図示すると以下のようになります\n\nCode\nimport statsmodels.api as sm\n\n# params\nk_args = (-0.2, 0, 0.2)\n\n# solve\nfor k in k_args:\n    n = odeint(malthusian_model, N_0, t, args=(k,))\n    plt.plot(t, n, label=f\"k={k}\")\n\nplt.legend()\nplt.xlabel(\"t\")\nplt.ylabel(\"$N(t)$\")\nplt.title(\"Malthusian growth simulation with different $k$\")\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 2\n\n\n\n\n\n\n\n\n\nTip🍵 マルサスモデルの限界\n\n\n\nマルサスモデルは，\\(k &gt; 0\\) のとき人口が指数関数的に増加すると予測しています．実際には，食料や石油といった資源は有限であるので人口増加を抑制する要因があるため，現実でマルサスモデル的増加をすることは到底起こりえません．\n\n\n\n\n\n\\(N(t)\\) は 4期間ごとに観測される(=観測されるtは\\((0, 1, 2, 4)\\))\n観測される \\(N(t)\\) にはノイズが乗ってしまっている: \\(\\epsilon_t \\sim N(0, 0.1)\\)\n\nという状況ののもと，\\((N_0, k)\\) を推定し，\\(t&gt;4\\) の範囲の人口について予測することはできるのか？という問題を考えてみます．\n\\(\\eqref{eq-malthus-solution}\\) について対数を取ると\n\\[\n\\log N(t) = \\log(N_0) + kt\n\\]\nとなります．つまり，対数変換した変数についての線形モデルとして推定量を考えることができます．観測ノイズ \\(\\epsilon_t\\) を踏まえると，観測される人口を \\(\\tilde N(t)\\) とすると\n\\[\n\\begin{align}\n&\\tilde N(t) = N_0\\exp(kt) + \\epsilon_t\\\\\n&\\Rightarrow\\log \\tilde N(t) = \\log (N_0\\exp(kt) + \\epsilon_t)\n\\end{align}\n\\]\nとなってしまいますが，近似式として\n\\[\n\\log\\tilde N(t) = \\alpha + \\beta t + e_i\n\\]\nで推定するとします．\\(\\epsilon_i\\)がhomogeneousとしても\\(e_i\\)がhomogeneousとは限らないのでheteroskedasticity residual erroを想定して推定します．\n\nCode\nimport statsmodels.api as sm\n\nnp.random.seed(42)\n\n# observation step\nSTEP = 4\n\n# DGP\nactual_n = n.flatten()\nobserved_n = actual_n[::STEP][:-1] + +np.random.normal(0, 0.1, len(actual_n[::STEP][:-1]))\nobserved_t = t[::STEP][:-1]\nX = sm.add_constant(observed_t)\n\n# fit\nmodel = sm.OLS(np.log(observed_n), X).fit(cov_type=\"HC0\")\nestimated_n_0, estimated_k = model.params\n\n# simulation\nsimulated_n = odeint(malthusian_model, np.exp(estimated_n_0), t, args=(estimated_k,))\n\n# plot\nplt.plot(t, simulated_n, label=\"simulated\")\nplt.scatter(observed_t, observed_n, color=\"gray\", alpha=0.8, marker='x', label=\"actual data points\")\nplt.scatter(t, actual_n, color=\"red\", alpha=0.8, label=\"actual data points\")\nplt.legend()\nplt.xlabel(\"t\")\nplt.ylabel(\"$N(t)$\")\nplt.title(\"Malthusian growth prediction\")\nplt.axvspan(4.25, t[-1], color='gray', alpha=0.3)\nplt.text(4.65, 2.0, \"Prediction\\nPeriod\", ha='center', va='center', fontsize=11, color='black')\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 3"
  },
  {
    "objectID": "posts/2025-01-30-differential-equations/index.html#ヴェアフルストの人口論",
    "href": "posts/2025-01-30-differential-equations/index.html#ヴェアフルストの人口論",
    "title": "微分方程式を用いたToy models",
    "section": "ヴェアフルストの人口論",
    "text": "ヴェアフルストの人口論\n人口過密の要因を考慮に入れてマルサスモデルを修正したのがヴェアフルストモデルです．\n ▶  仮定の設定\n\n人口の上限 \\(N_\\infty\\) が存在する\n現在の人口を \\(N(t)\\) としたとき，人口増加 \\(\\Delta N(t)\\) は \\(N(t)\\) と \\(\\displaystyle 1 - \\frac{N(t)}{N_\\infty}\\) と時間区間 \\(\\Delta\\) に比例する\n\n ▶  問題の定式化\n比例定数を \\(k\\) としたとき\n\\[\n\\Delta N(t) = kN(t)\\left(1 - \\frac{N(t)}{N_\\infty}\\right)\\Delta t\n\\]\n\\(\\Delta t\\to 0\\) と極限をとると\n\\[\n\\frac{dN(t)}{dt} = kN(t)\\left(1 - \\frac{N(t)}{N_\\infty}\\right)\\label{eq-logistic-model}\n\\]\n人口変化は上記のような一階上微分方程式で表せるという形で定式化できました．\n ▶  モデルを解く\n\\(\\eqref{eq-logistic-model}\\) を変形すると\n\\[\n\\frac{N_\\infty}{N_\\infty - N(t)}\\frac{dN(t)}{N(t)dt} = k\n\\]\n両辺を \\(t\\) について積分すると\n\\[\n\\begin{align}\n& \\int\\frac{N_\\infty}{N_\\infty - N(t)}\\frac{dN(t)}{N(t)dt} dt= \\int k dt\\\\\n&\\Rightarrow \\int\\left(\\frac{1}{N(t)}+\\frac{1}{N_\\infty - N(t)}\\right)dN(t) = \\int k dt\\\\\n&\\Rightarrow \\log N(t) - \\log(N_\\infty - N(t)) = kt + C\\\\\n&\\Rightarrow \\log \\frac{N(t)}{N_\\infty - N(t)} = kt + C\n\\end{align}\n\\]\nこのとき，\\(N(0) = N_0\\) と初期条件が与えられたとすると\n\\[\n\\exp(C) = \\frac{N_0}{N_\\infty - N_0}\n\\]\nよって，\n\\[\n\\frac{N(t)}{N_\\infty - N(t)} = \\frac{N_0}{N_\\infty - N_0}\\exp(kt)\n\\]\nこれを \\(N(t)\\) についてとくと，\n\\[\nN(t) = \\frac{N_\\infty}{1 + [(N_\\infty/N_0 - 1)]\\exp(-kt)}\n\\]\nまたは\n\\[\n\\frac{1}{N(t)} = \\frac{1}{N_\\infty} + \\left(\\frac{1}{N_0} - \\frac{1}{N_\\infty}\\right)\\exp(-kt)\n\\]\n ▶  解釈\n\\(t\\to\\infty\\) のとき，\\(\\lim_{t\\to\\infty}\\exp(-kt) = 0\\) より\n\\[\n\\lim_{t\\to\\infty}N(t) = N_\\infty\n\\]\nとなることがわかります．初期値に応じて \\(N_\\infty\\) へ到達する経路は異なります．仮に \\(N_\\infty = 12, k=0.2\\) として，初期値が \\((1, 3, 6, 9, 12, 15)\\) と異なる水準で与えられたとします．\n\n\nCode\nfrom scipy.integrate import solve_ivp\n\n\n# Define logistic growth model\ndef logistic_growth(t, N, k=0.2, M=12):\n    dydt = k * N * (1 - N / M)\n    return dydt\n\n# Set up the grid for the direction field\nt_vals = np.linspace(0, 30, 20)  # Time values\nP_vals = np.linspace(0, 16, 20)  # Population values\nT, P = np.meshgrid(t_vals, P_vals)\n\n# Compute direction field (dP/dt values)\ndP_dt = logistic_growth(None, P)\n\n# Normalize arrows for visualization\nnorm = np.sqrt(1**2 + dP_dt**2)\nU = 1 / norm  # Time step is 1 (arbitrary)\nV = dP_dt / norm  # Scale arrows properly\n\n# Plot the direction field\nplt.figure(figsize=(8, 5))\nplt.quiver(T, P, U, V, color=\"gray\", alpha=0.7) # [T, P]: arrow location, [U, V]: arrow direction\n\n# Solve the ODE for different initial conditions\ninitial_conditions = [1, 3, 6, 9, 12, 15,]\nt_span = (0, 30)\nt_eval = np.linspace(0, 30, 100)\n\nfor P0 in initial_conditions:\n    sol = solve_ivp(logistic_growth, t_span, [P0], t_eval=t_eval)\n    if sol.success:\n        plt.plot(sol.t, sol.y[0], linewidth=2, label=f\"P(0)={P0}\")\n    else:\n        raise ValueError(\"computation failed\")\n\n# Labels and title\nplt.xlabel(\"t\")\nplt.ylabel(\"P(t)\")\nplt.title(\"Logistic Growth Model\")\nplt.legend()\nplt.grid()\n\n# Show the plot\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\\(0&lt; N_0 &lt; N_\\infty\\): はじめの増加は指数関数的だが，ある程度の水準から増加の度合いは減衰していく\n\\(N_0 = N_\\infty\\): 変化なし\n\\(N_0 &gt; N_\\infty\\): \\(N_\\infty\\)に近づく方向で減少していく．減衰の度合いは減衰していく\n\\(N_0 = 0\\): これも一つの均衡だが，ちょっとしたショックがあるだけで \\(N_\\infty\\) を目指すPathに乗ってしまう(= unstable equilibrium)\n\n ▶  Validation\nヴェアフルストモデルが人口動態を表した良いモデルなのか，1820-1930のアメリカの人口データを用いて検証してみます．\n\n\nCode\nimport pandas as pd\n\n# Historical population data (year, population in millions)\ndata = {\n    \"year\": [1820, 1830, 1840, 1850, 1860, 1870, 1880, 1890, 1900, 1910, 1920, 1930, 2000],\n    \"us_population_million\": [9.6, 12.9, 17.1, 23.2, 31.4, 38.6, 50.2, 62.9, 76.0, 92.0, 106.5, 123.2, 282.2]\n}\n\n# Create DataFrame\ndf = pd.DataFrame(data)\n\n# Display table\ndf\n\n\n\n\n\n\n\n\n\nyear\nus_population_million\n\n\n\n\n0\n1820\n9.6\n\n\n1\n1830\n12.9\n\n\n2\n1840\n17.1\n\n\n3\n1850\n23.2\n\n\n4\n1860\n31.4\n\n\n5\n1870\n38.6\n\n\n6\n1880\n50.2\n\n\n7\n1890\n62.9\n\n\n8\n1900\n76.0\n\n\n9\n1910\n92.0\n\n\n10\n1920\n106.5\n\n\n11\n1930\n123.2\n\n\n12\n2000\n282.2\n\n\n\n\n\n\n\nパラメーターを \\(N_0 = 3.9, k = 0.3134, N_\\infty = 197\\) と選ぶと\n\nCode\nt_index = np.linspace(0, (df.shape[0] + 10), 100)\nsol = solve_ivp(logistic_growth, [0, t_index[-1]], [3.9], t_eval=t_index, args=(0.3134, 197))\nplt.plot(1790 + sol.t*10, sol.y[0], linewidth=2, label=f\"prediction\")\nplt.scatter(\n    df.year,\n    df.us_population_million,\n    color=\"gray\",\n    alpha=0.8,\n    marker=\"x\",\n    label=\"actual data points\",\n)\nplt.xlabel('year')\nplt.ylabel('population(million)')\nplt.legend()\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 4: Model prediction vs actual USA population\n\n\n\nこのように, 1800-1930年のアメリカ人口動態を上手く説明するモデルとなっていることがわかります．一方，モデルの上限は \\(197\\times 10^6\\) であるが，2000年の人口は \\(282.2\\times 10^6\\) となっており，長期における人口動態を説明できるものにはなっていないことも読み取れます．\n\\(N_\\infty\\) の仮定が間違っていたと解釈することが一つ考えられますが，人口変化を支配する法則は技術変化や政治といった要因に影響を受けるため，常に同じ支配法則に基づいていると仮定することが間違っているとも解釈することが出来ます．"
  },
  {
    "objectID": "posts/2025-06-28-datamart-principle/index.html",
    "href": "posts/2025-06-28-datamart-principle/index.html",
    "title": "Datamart作成Tips",
    "section": "",
    "text": "Definition 1 データマート\n\n特定のクエリ群で必要とされるデータだけを保持する，相対的に小さなサイズのテーブルのこと\nアクセス対象テーブルサイズを小さくすることでI/O量を減らすのが種目的\n\n\n\nDefinition 2 ゾンビマート\n\nもう参照されていないのに無駄に同期処理が行われているデータマート"
  },
  {
    "objectID": "posts/2025-06-28-datamart-principle/index.html#データマートとは",
    "href": "posts/2025-06-28-datamart-principle/index.html#データマートとは",
    "title": "Datamart作成Tips",
    "section": "",
    "text": "Definition 1 データマート\n\n特定のクエリ群で必要とされるデータだけを保持する，相対的に小さなサイズのテーブルのこと\nアクセス対象テーブルサイズを小さくすることでI/O量を減らすのが種目的\n\n\n\nDefinition 2 ゾンビマート\n\nもう参照されていないのに無駄に同期処理が行われているデータマート"
  },
  {
    "objectID": "posts/2025-06-28-datamart-principle/index.html#データマートの実装方法",
    "href": "posts/2025-06-28-datamart-principle/index.html#データマートの実装方法",
    "title": "Datamart作成Tips",
    "section": "データマートの実装方法",
    "text": "データマートの実装方法\nデータマートをどう構築するかは要件次第で，大きく分けると以下の方法があります．\n方法A: 物理テーブルに実装\n\nデータマート専用のテーブルを作成し，ETL/ELT処理で定期的にロードする\n長所: 高速，データが安定している\n短所: ETLコストが高い，ストレージ消費が大きい\n\n方法B: ビュー (View) で実装\n\nDWHの基盤テーブルに対するSQLを「ビュー」として定義し，利用者はビューを参照\n長所: 柔軟で開発が早い，ストレージ不要\n短所: 元テーブルに毎回クエリが走るため重い集計では遅くなる\n\n方法C: マテリアライズドビューで実装\n\n上記の「ビュー」の欠点を補う形で，集計結果をあらかじめ保存\n基本的に「単一テーブルに対する単純な集計」が対象\n長所: 高速，利用者からはビュー同様に見える\n短所: 更新タイミングの設計が必要（鮮度とパフォーマンスのトレードオフ）\n\n\n\n\n\n\n\nTipBigQuery のマテリアライズドビューに関する制限事項\n\n\n\n\nマテリアライズドビューで使える集計関数は限定的で，「基本的な集約 + 一部の近似集計やビット演算」に限られる\n自己結合や RIGHT/FULL OUTER JOIN はサポートされていない\nユーザー定義関数（UDF）やウインドウ関数などは使用することができない"
  },
  {
    "objectID": "posts/2025-06-28-datamart-principle/index.html#データマート作成にあたっての観点",
    "href": "posts/2025-06-28-datamart-principle/index.html#データマート作成にあたっての観点",
    "title": "Datamart作成Tips",
    "section": "データマート作成にあたっての観点",
    "text": "データマート作成にあたっての観点\n\n\n\n\n\n\nNote1: データ同期のタイミング\n\n\n\n\nオリジナルテーブルとの動機タイミングが短いほどデータ鮮度は新しくなる\n一方，更新頻度が多いほどDWHに与える負荷は大きくなる\n一般的には，同期は夜間バッチにおいて実行されることが多く，この場合のデータ鮮度は最低１日前となる\n\n\n\n\n\n\n\n\n\nNote2: データマートのサイズ\n\n\n\n\nオリジナルテーブルとサイズがあまり変わらないデータマートを作ってもI/O量の節約にはつながらない\nデータマート設計段階で，取引単位や日次集計かなどを観測単位を設計し，事前にGROUP BY処理を実施することが推奨\n\n\n\n\n\n\n\n\n\nNote3: データマートの数\n\n\n\n\nデータマートは分析用途ごとに作成されることが多く，数が増えるほど管理工数やストレージ負荷が増加する\n同じ指標やマスタを複数のデータマートでばらばらに管理すると，分析結果の整合性が崩れるリスクがある\n過剰に細分化すると更新処理や同期の複雑さが増すため，必要最小限の粒度で統合・共通化を検討\n\n\n\n\n\n\n\n\n\nNote4: バッチウィンドウ\n\n\n\n\nデータマートのETL処理自体にもコンピュテーションリソースを消費する\n夜間や利用が少ない時間帯にバッチ処理を集中させることで，システム負荷を分散できる\nバッチウィンドウの長さが短い場合，大規模データや複雑な処理が間に合わないリスクがある\n\n\n\n\n\n\n\n\n\nNote5: データ品質・正規化\n\n\n\n\n欠損値や異常値の補正方針を明確にしておく\n名寄せやコード体系の統一（部門コード・商品コードなど）が必要\nデータマート内のデータ品質を保証することで，分析結果の信頼性を向上\n\n\n\n\n\n\n\n\n\nNote6: パフォーマンス最適化\n\n\n\n\nインデックスやパーティション分割の活用を検討\nデータマートの実装方法として，materialized viewでの実装を検討\nクエリ実行時間やI/O負荷を抑え，利用者のストレスを低減"
  },
  {
    "objectID": "posts/2025-06-28-datamart-principle/index.html#references",
    "href": "posts/2025-06-28-datamart-principle/index.html#references",
    "title": "Datamart作成Tips",
    "section": "References",
    "text": "References\n\nSQL実践入門: 高速でわかりやすいクエリの書き方\nBigQueey &gt; Introduction to materialized views\nBigQueey &gt; Materialized views query support"
  },
  {
    "objectID": "posts/2025-11-28-generate-random-passwd/index.html",
    "href": "posts/2025-11-28-generate-random-passwd/index.html",
    "title": "乱数生成シェルスクリプト",
    "section": "",
    "text": "NoteDOCSTRINGS\n\n\n\n\n\n/dev/urandomを活用して任意の長さの疑似ランダム文字列を生成\nデフォルトは Base64 形式\n-n オプションを利用するとInteger型で疑似ランダム列を生成\n出現文字列の一様性を保証するものではないので，あくまでsandbox環境での簡易的なpasswordの生成などに用途を限定\n\n\n\nシェルスクリプト全体\n#!/bin/bash\n# -----------------------------------------------------------------------------\n# Author: Ryo Nakagami\n# Revised: 2025-11-28\n# Script: generate-random-passwd\n# Description:\n#   Generates a random string of specified length in either base64 or\n#   numeric-only format. Useful for passwords, tokens, or test data.\n#\n#   Steps:\n#     1. Parse command-line options (-n for numeric, -h for help).\n#     2. Validate input length (must be integer, less than 77).\n#     3. Generate random string using /dev/urandom:\n#        - base64 output by default\n#        - numeric-only if -n is specified\n#\n# Options:\n#    -n    Generate numeric-only random string\n#    -h    Show this help message\n#\n# Usage:\n#   ./generate-random-passwd &lt;length&gt;      # Generates base64 string\n#   ./generate-random-passwd -n &lt;length&gt;   # Generates numeric string\n#   ./generate-random-passwd &lt;length&gt; -n   # Generates numeric string\n#\n# Notes:\n#   - Requires /dev/urandom device.\n#   - Requires base64 and tr utilities.\n#   - Sources lib/docstring.sh for usage_helper.\n# -----------------------------------------------------------------------------\n\n# ---- Load library functions ----\nsource \"$(dirname \"${BASH_SOURCE[0]}\")/../lib/docstring.sh\"\n\n# ---- Default values ----\nPATTERN=\"BASE64\"\n\nif [ -z \"$1\" ]; then\n    # call library function usage_helper\n    usage_helper\n    exit 1\nfi\n\n\n# ---- Parse command-line options ----\nparse_opts() {\n    while getopts \"hn\" opt; do\n        case \"$opt\" in\n            h) usage_helper; exit 0 ;;\n            n) PATTERN=\"NUMERIC\" ;;\n            *) usage_helper; exit 1 ;;\n        esac\n    done\n}\n\n# ---- 1st pass: parse leading options ----\nparse_opts \"$@\"\nshift $((OPTIND - 1))\n\n# ---- NUMBER_INPUT might be here ----\nif [[ \"$1\" =~ ^[0-9]+$ ]]; then\n    NUMBER_INPUT=\"$1\"\n    shift 1\nfi\n\n# ---- Reset OPTIND and parse remaining options (after NUMBER_INPUT) ----\nOPTIND=1\nparse_opts \"$@\"\nshift $((OPTIND - 1))\n\n# ---- Validate input ----\n# Check if NUMBER_INPUT is a positive integer\nif ! [[ \"$NUMBER_INPUT\" =~ ^[1-9][0-9]*$ ]]; then\n    echo \"Error: Input must be a positive integer greater than 0.\"\n    usage_helper\n    exit 1\nfi\n\nif (( NUMBER_INPUT &gt;= 77 )); then\n    echo \"Error: Input must be less than 77.\"\n    usage_helper\n    exit 1\nfi\n\nif [ \"$PATTERN\" != \"BASE64\" ] && [ \"$PATTERN\" != \"NUMERIC\" ]; then\n    echo \"Error: Invalid pattern specified.\"\n    usage_helper\n    exit 1\nfi\n\n\n# ---- Generate random string based on pattern ----\nif [ \"$PATTERN\" = \"BASE64\" ]; then\n    # ---- Generate random string ----\n    base64 /dev/urandom | head -c \"$NUMBER_INPUT\"\n    echo\n    exit 0\nelif [ \"$PATTERN\" = \"NUMERIC\" ]; then\n    # ---- Generate numeric-only random string ----\n    tr -dc '0-9' &lt; /dev/urandom | head -c \"$NUMBER_INPUT\"\n    echo\n    exit 0\nfi\n\nExample 1 (実行例)  \n% generate-random-passwd 10\nzCJPhQxfr6\n\n% generate-random-passwd 10 -n\n5711270805\n\n% generate-random-passwd -n 10\n9843753838"
  },
  {
    "objectID": "posts/2025-11-28-generate-random-passwd/index.html#シェルスクリプト概要",
    "href": "posts/2025-11-28-generate-random-passwd/index.html#シェルスクリプト概要",
    "title": "乱数生成シェルスクリプト",
    "section": "",
    "text": "NoteDOCSTRINGS\n\n\n\n\n\n/dev/urandomを活用して任意の長さの疑似ランダム文字列を生成\nデフォルトは Base64 形式\n-n オプションを利用するとInteger型で疑似ランダム列を生成\n出現文字列の一様性を保証するものではないので，あくまでsandbox環境での簡易的なpasswordの生成などに用途を限定\n\n\n\nシェルスクリプト全体\n#!/bin/bash\n# -----------------------------------------------------------------------------\n# Author: Ryo Nakagami\n# Revised: 2025-11-28\n# Script: generate-random-passwd\n# Description:\n#   Generates a random string of specified length in either base64 or\n#   numeric-only format. Useful for passwords, tokens, or test data.\n#\n#   Steps:\n#     1. Parse command-line options (-n for numeric, -h for help).\n#     2. Validate input length (must be integer, less than 77).\n#     3. Generate random string using /dev/urandom:\n#        - base64 output by default\n#        - numeric-only if -n is specified\n#\n# Options:\n#    -n    Generate numeric-only random string\n#    -h    Show this help message\n#\n# Usage:\n#   ./generate-random-passwd &lt;length&gt;      # Generates base64 string\n#   ./generate-random-passwd -n &lt;length&gt;   # Generates numeric string\n#   ./generate-random-passwd &lt;length&gt; -n   # Generates numeric string\n#\n# Notes:\n#   - Requires /dev/urandom device.\n#   - Requires base64 and tr utilities.\n#   - Sources lib/docstring.sh for usage_helper.\n# -----------------------------------------------------------------------------\n\n# ---- Load library functions ----\nsource \"$(dirname \"${BASH_SOURCE[0]}\")/../lib/docstring.sh\"\n\n# ---- Default values ----\nPATTERN=\"BASE64\"\n\nif [ -z \"$1\" ]; then\n    # call library function usage_helper\n    usage_helper\n    exit 1\nfi\n\n\n# ---- Parse command-line options ----\nparse_opts() {\n    while getopts \"hn\" opt; do\n        case \"$opt\" in\n            h) usage_helper; exit 0 ;;\n            n) PATTERN=\"NUMERIC\" ;;\n            *) usage_helper; exit 1 ;;\n        esac\n    done\n}\n\n# ---- 1st pass: parse leading options ----\nparse_opts \"$@\"\nshift $((OPTIND - 1))\n\n# ---- NUMBER_INPUT might be here ----\nif [[ \"$1\" =~ ^[0-9]+$ ]]; then\n    NUMBER_INPUT=\"$1\"\n    shift 1\nfi\n\n# ---- Reset OPTIND and parse remaining options (after NUMBER_INPUT) ----\nOPTIND=1\nparse_opts \"$@\"\nshift $((OPTIND - 1))\n\n# ---- Validate input ----\n# Check if NUMBER_INPUT is a positive integer\nif ! [[ \"$NUMBER_INPUT\" =~ ^[1-9][0-9]*$ ]]; then\n    echo \"Error: Input must be a positive integer greater than 0.\"\n    usage_helper\n    exit 1\nfi\n\nif (( NUMBER_INPUT &gt;= 77 )); then\n    echo \"Error: Input must be less than 77.\"\n    usage_helper\n    exit 1\nfi\n\nif [ \"$PATTERN\" != \"BASE64\" ] && [ \"$PATTERN\" != \"NUMERIC\" ]; then\n    echo \"Error: Invalid pattern specified.\"\n    usage_helper\n    exit 1\nfi\n\n\n# ---- Generate random string based on pattern ----\nif [ \"$PATTERN\" = \"BASE64\" ]; then\n    # ---- Generate random string ----\n    base64 /dev/urandom | head -c \"$NUMBER_INPUT\"\n    echo\n    exit 0\nelif [ \"$PATTERN\" = \"NUMERIC\" ]; then\n    # ---- Generate numeric-only random string ----\n    tr -dc '0-9' &lt; /dev/urandom | head -c \"$NUMBER_INPUT\"\n    echo\n    exit 0\nfi\n\nExample 1 (実行例)  \n% generate-random-passwd 10\nzCJPhQxfr6\n\n% generate-random-passwd 10 -n\n5711270805\n\n% generate-random-passwd -n 10\n9843753838"
  },
  {
    "objectID": "posts/2025-11-28-generate-random-passwd/index.html#devurandom-仮想デバイス",
    "href": "posts/2025-11-28-generate-random-passwd/index.html#devurandom-仮想デバイス",
    "title": "乱数生成シェルスクリプト",
    "section": "/dev/urandom 仮想デバイス",
    "text": "/dev/urandom 仮想デバイス\n\nDefinition 1 /dev/urandom\n\n/dev/urandomはハードウェア（キーボード・マウス・CPUなどの）動作から得られる環境ノイズを蓄積したデータ領域のこと（＝エントロピープール）\n蓄積されたデータはバイナリーデータであるが，base64 を利用することで乱数ジェネレーターとして利用できる\n出力プールの最大周期(period)は \\(2^{26\\times 32} - 1\\)\nエントロピープールを再利用する仕組みを持つため，エントロピー枯渇（entropy pool depletion）を心配する必要はない（＝いつでも利用できる）\n疑似乱数の再現性(reproducible seeding)はない\n\n\nエントロピープールを活用した疑似乱数ジェネレーターは /dev/urandom 以外に dev/random がありますが，動作の違いがあります． dev/random は乱数生成に使ったエントロピープール（= 内部状態）をそのまま再利用しないようにロックをかけるという設計になっています．\n\n乱数を出力 → プールが「公開された」とみなす\n安全のためそのプールはすぐ使わない\n新しい環境ノイズ（エントロピー）が十分に貯まるまで待つ\n\nそのため，連続した乱数生成を実施できない場合があります．\n\n連続した大量生成\n実行環境が低エントロピー環境（仮想マシンなどのノイズが少ない環境）\n\nでは，ロックがかかりやすいので /dev/urandom ベースの乱数ジェネレーターのほうが一般用途では良いとされます．\n\nBase64 エンコード\n\nDefinition 2 base64\n\nバイナリーデータをテキストに変換するためのエンコード方式\nデータを64種類の印字可能な英数字([A-Za-z0-9+/])に変換\nMIMEの基準では76文字ごとに改行コードが入る\n\n\nbase64 /dev/urandom を実行シたときの流れは\n\n/dev/urandom (バイナリ)\nbase64 でエンコード\nランダムな Base64 文字列が出力される\n\nになります．"
  },
  {
    "objectID": "posts/2025-11-28-generate-random-passwd/index.html#head-コマンド",
    "href": "posts/2025-11-28-generate-random-passwd/index.html#head-コマンド",
    "title": "乱数生成シェルスクリプト",
    "section": "head コマンド",
    "text": "head コマンド\n\nDefinition 3 head コマンド\n\nheadはテキストファイルの最初の10行を表示するコマンド\n\n\nオプション\n\n\n\n\n\n\n\n\n\n短いオプション\n長いオプション\n意味\n\n\n\n\n-c 数字\n--bytes 数字\n先頭から指定したバイト数のみ表示する．「-c 5 b」のように単位を付加することも可能（b=512, KB=1000, K=1024, MB=1000×1000, M=1024×1024…）\n\n\n-n 数字\n--lines 数字\n先頭から指定した行数のみ表示する\n\n\n-q\n--quiet, --silent\nファイルごとのヘッダ表示を行わない（複数ファイル指定時に使う）\n\n\n-v\n--verbose\n常にファイルごとのヘッダ出力を行う"
  },
  {
    "objectID": "posts/2025-11-28-generate-random-passwd/index.html#tr-コマンド",
    "href": "posts/2025-11-28-generate-random-passwd/index.html#tr-コマンド",
    "title": "乱数生成シェルスクリプト",
    "section": "tr コマンド",
    "text": "tr コマンド\n\nDefinition 4 tr コマンド\n\n標準入力の文字を別の文字に置換したり，削除したりするコマンド\n\n\nオプション\n\n\n\n\n\n\n\n\n\n短いオプション\n長いオプション\n意味\n\n\n\n\n-d\n--delete\n指定した文字を削除する\n\n\n-c\n--complement\n指定した文字セットの補集合を扱う（反転）\n\n\n-s\n--squeeze-repeats\n連続する同一文字を1つに圧縮する\n\n\n\n\n\nExample 2 (文字の置換) tr 012 abc を実行すると，\n\n「0」を「a」\n「1」を「b」\n「2」を「c」\n\nに置き換えます．「012」という連続した文字列を「abc」に置き換えるのではなく，常に1文字対1文字での置き換えとなるので，両者の長さはそろえる必要があります\n$ echo '012345' | tr 012 abc\nabc345\n\n$ echo '0142345' | tr 012 abc\nab4c345\n\n\n\nExample 3 (/dev/urandom から数値のみを抽出) \n数値のみのパスワードやトークン生成する場合は，-d '0-9' の補集合を取れば良いので\ntr -dc '0-9' &lt; /dev/urandom | head -c 16\n\n\n\nExample 4 (連続した改行を1つにする) \ntr -s は繰り返し文字の圧縮に使えるので\n$ echo 'A\\n\\n\\nA' \nA\n\n\nA\n\n$ echo 'A\\n\\n\\nA' | tr -s '\\n'\nA\nA\ntr -s '\\n' は不要改行を削除するときに使いますが，同様に tr -s '[:space:] を用いて不要スペースをまとめたりします\n% echo \"a   b   c\" | tr -s '[:space:]'\na b c"
  },
  {
    "objectID": "posts/2025-11-28-generate-random-passwd/index.html#references",
    "href": "posts/2025-11-28-generate-random-passwd/index.html#references",
    "title": "乱数生成シェルスクリプト",
    "section": "References",
    "text": "References\n\nうたカモ技術ブログ &gt; Linux 乱数ジェネレーター（/dev/random、/dev/urandom、getrandom）\nIs /dev/urandom suitable for simulation purpose?"
  },
  {
    "objectID": "posts/2026-01-14-semiconductor-industry/index.html",
    "href": "posts/2026-01-14-semiconductor-industry/index.html",
    "title": "半導体メーカーの事業形態",
    "section": "",
    "text": "Rank\nVendor\n本店所在国\nRevenue 2025 ($B)\nRevenue 2024 ($B)\nYoY Growth\n\n\n\n\n1\nNVIDIA\n米国\n125.7\n76.7\n+63.9%\n\n\n2\nSamsung\n韓国\n72.5\n65.7\n+10.4%\n\n\n3\nSK Hynix\n韓国\n60.6\n44.2\n+37.2%\n\n\n4\nIntel\n米国\n47.9\n49.8\n−3.9%\n\n\n5\nMicron\n米国\n41.5\n27.6\n+50.2%\n\n\n6\nQualcomm\n米国\n37.0\n33.0\n+12.3%\n\n\n7\nBroadcom\n米国\n34.3\n27.8\n+23.3%\n\n\n8\nAMD\n米国\n32.5\n24.1\n+34.6%\n\n\n9\nApple\n米国\n24.6\n20.5\n+19.9%\n\n\n10\nMediaTek\n台湾\n18.5\n15.9\n+15.9%\n\n\n\n\nファウンドリーランキング（推計値ベース）\n\n\n\n\n\n\n\n\n\n\nManufacturer\nMarket Share\nRevenue 2025 ($B)\nKey Technology Focus\n\n\n\n\nTSMC\n72.0%\n121.9\n3nm / 5nm / CoWoS Packaging\n\n\nSamsung\n11.5%\n19.5\n2nm GAA / HBM4 Base Die\n\n\nSMIC\n5.7%\n9.6\n7nm / Domestic AI Infrastructure\n\n\nUMC\n2.3%\n3.9\n22nm / 28nm Specialty Nodes\n\n\nGlobalFoundries\n2.0%\n3.4\nAutomotive / Photonics"
  },
  {
    "objectID": "posts/2026-01-14-semiconductor-industry/index.html#売上top-10半導体ベンダー製品売上ベース",
    "href": "posts/2026-01-14-semiconductor-industry/index.html#売上top-10半導体ベンダー製品売上ベース",
    "title": "半導体メーカーの事業形態",
    "section": "",
    "text": "Rank\nVendor\n本店所在国\nRevenue 2025 ($B)\nRevenue 2024 ($B)\nYoY Growth\n\n\n\n\n1\nNVIDIA\n米国\n125.7\n76.7\n+63.9%\n\n\n2\nSamsung\n韓国\n72.5\n65.7\n+10.4%\n\n\n3\nSK Hynix\n韓国\n60.6\n44.2\n+37.2%\n\n\n4\nIntel\n米国\n47.9\n49.8\n−3.9%\n\n\n5\nMicron\n米国\n41.5\n27.6\n+50.2%\n\n\n6\nQualcomm\n米国\n37.0\n33.0\n+12.3%\n\n\n7\nBroadcom\n米国\n34.3\n27.8\n+23.3%\n\n\n8\nAMD\n米国\n32.5\n24.1\n+34.6%\n\n\n9\nApple\n米国\n24.6\n20.5\n+19.9%\n\n\n10\nMediaTek\n台湾\n18.5\n15.9\n+15.9%\n\n\n\n\nファウンドリーランキング（推計値ベース）\n\n\n\n\n\n\n\n\n\n\nManufacturer\nMarket Share\nRevenue 2025 ($B)\nKey Technology Focus\n\n\n\n\nTSMC\n72.0%\n121.9\n3nm / 5nm / CoWoS Packaging\n\n\nSamsung\n11.5%\n19.5\n2nm GAA / HBM4 Base Die\n\n\nSMIC\n5.7%\n9.6\n7nm / Domestic AI Infrastructure\n\n\nUMC\n2.3%\n3.9\n22nm / 28nm Specialty Nodes\n\n\nGlobalFoundries\n2.0%\n3.4\nAutomotive / Photonics"
  },
  {
    "objectID": "posts/2026-01-14-semiconductor-industry/index.html#idm垂直統合型",
    "href": "posts/2026-01-14-semiconductor-industry/index.html#idm垂直統合型",
    "title": "半導体メーカーの事業形態",
    "section": "IDM(垂直統合型)",
    "text": "IDM(垂直統合型)\n\nDefinition 1 Integrated Device Manufacture(IDM)\n\n半導体のバリューチェーンを自社内で垂直に統合し，企画・研究開発 → 回路設計 → 前工程（製造） → 後工程（組立・テスト） → 販売までを一貫して担う事業形態\n半導体設計技術力だけでなく，製造能力，販売網が必要になる\n\n\n代表的なIDM企業\n\n\n\n\n\n\n\n\n企業名\n主な強み\n\n\n\n\nIntel\nCPU・SoC設計 + 先端ロジックFab（近年はファウンドリ事業も展開）\n\n\nSamsung Electronics\nDRAM / NAND などメモリ + 先端ロジック + 世界最大級Fab\n\n\nSK hynix\nDRAM・NANDフラッシュに特化したメモリIDM\n\n\nキオクシア（Kioxia）\nNANDフラッシュメモリ専業IDM\n\n\nTexas Instruments\nマイコン\n\n\n\n\nPros\n\n自社内で特許やノウハウを保持することができる\n自社の工場での生産調整など迅速な対応を取ることができる\n特定のニーズを満たす独自技術の開発ができる\n\nCons\n\n工場や製造装置などへの設備投資，既存工場の維持運用などに大きなコストがかかる（= 管理会計的に固定費比率が高くなる）\n減価償却費が意思決定に影響し，低採算製品でも稼働率維持を優先せざるを得ない構造を持つ"
  },
  {
    "objectID": "posts/2026-01-14-semiconductor-industry/index.html#ファブレス企業",
    "href": "posts/2026-01-14-semiconductor-industry/index.html#ファブレス企業",
    "title": "半導体メーカーの事業形態",
    "section": "ファブレス企業",
    "text": "ファブレス企業\n\nDefinition 2 ファブレス企業\n\n自社で工場をもたず，開発・設計，販売に特化したメーカー\n水平分業型の企業形態の１つ\n製造工程は，ファウンドリ企業やOSATへ委託\n\n\nファブレス企業\n\n\n\n企業名\n主な分野・特徴\n\n\n\n\nNVIDIA\nGPU．TSMC依存度が高い\n\n\nQualcomm\nスマートフォン向けSoC（Snapdragon）\n\n\nAMD\nCPU・GPU設計（製造はTSMC等）\n\n\nApple\nApple Silicon．製造は外部委託\n\n\n\nPros\n\n製造設備への投資や維持管理するコストがIDMと比べ小さい\n「低採算製品でも稼働率維持を優先してしまう」ような経営意思決定リスクが小さく，市場変化に合わせた経営意思決定がしやすい\n\nCons\n\n製造工程の委託先次第で品質が変わってしまう"
  },
  {
    "objectID": "posts/2026-01-14-semiconductor-industry/index.html#ファウンドリ企業",
    "href": "posts/2026-01-14-semiconductor-industry/index.html#ファウンドリ企業",
    "title": "半導体メーカーの事業形態",
    "section": "ファウンドリ企業",
    "text": "ファウンドリ企業\n\nDefinition 3 ファウンドリ企業\n\n自社ブランドでの製造は行わず，ファブレス企業などからの受託生産に特化した企業\n水平分業型の企業形態の１つ\n半導体製造において，回路の形成や微細加工といった前工程を主として受託\n\n\nファウンドリ企業\n\n\n\n\n\n\n\n企業名\n主な分野・特徴\n\n\n\n\nTSMC\n3nm量産・2nm開発など最先端プロセスに特化．Apple・NVIDIA・AMDなどハイエンド顧客を独占的に支える\n\n\nSamsung Foundry\n3nm GAAを先行導入．メモリ事業との垂直統合が特徴\n\n\nGlobalFoundries\n車載・通信・電源向けに強み．先端プロセスからは撤退 ．旧AMD製造部門\n\n\nUMC\n成熟プロセス中心（28nm/40nm）．コスト競争力と安定供給が強み．民生・産業用途向け\n\n\nSMIC\n中国最大手ファウンドリ．先端技術は輸出規制の制約下\n\n\n\nPros\n\n前工程に特化することによって，生産技術と生産設備に絞って投資できる\n数多くの顧客から受託することにより，個別の生産量が上下しても全体として安定した生産量を確保できる\n\nCons\n\n2nm回路など最先端プロセスの確立は技術的に難しい(=一部の大手会社しかできていない)\n\n後工程とOSAT\n\nDefinition 4 OSAT\n\n前工程で作られたチップを基板上に組み付けたり，検査を行ったりする後工程を専門に受託する企業"
  },
  {
    "objectID": "posts/2026-01-14-semiconductor-industry/index.html#インテルとamdの決算資料比較",
    "href": "posts/2026-01-14-semiconductor-industry/index.html#インテルとamdの決算資料比較",
    "title": "半導体メーカーの事業形態",
    "section": "インテルとAMDの決算資料比較",
    "text": "インテルとAMDの決算資料比較\n\n\n\n\n\n\nNoteREMARKS\n\n\n\n\nProperty, Plant & Equipment（有形固定資産）はIntelが総資産の51%に対し，AMDは3%\nIntelが製造設備を自社保有するIDMであるのに対し，AMDは製造を外部委託するファブレスモデルを採用していることの現れ\nAMDは有形固定資産回転率が高く，ファブレスモデルによる高い資本効率が現れている\n\n\n\n損益計算書の比較\n\n\n\n\n\n\n\n\n\n項目\nIntel (Q3 2025)\nAMD (Q3 2025)\n\n\n\n\nNet Revenue\n13.7B(YoY +3%)\n9.246B(YoY +36%)\n\n\nCost of Sales\n—\n4.206B\n\n\nGross Profit\n38.2%\n4.780B (52%)\n\n\nR&D + MG&A（研究開発費＋販売管理費）\n4.4B\n3.208B\n\n\nOperating Income（営業利益）\n0.683B (5.0%)\n1.270B (14%)\n\n\nNet Income（純利益）\n4.1B\n1.243B\n\n\nDiluted EPS（1株あたりの純利益）\n0.90\n0.75\n\n\n\n\nBalance Sheet(Asset)の比較\n\n\n\n\n\n\n\n\n\n項目\nIntel (Q3 2025)\nAMD (Q3 2025)\n\n\n\n\nTotal Assets（総資産）\n204,514M\n76,891M\n\n\nCurrent Assets（流動資産）\n51,731M\n27,000M\n\n\n現金及び現金同等物\n11,141M\n4,808M\n\n\n短期投資\n19,794M\n2,435M\n\n\n売掛金（Accounts receivable）\n3,202M\n6,201M\n\n\n棚卸資産（Inventories）\n11,489M\n7,313M\n\n\nその他流動資産\n6,105M\n2,253M\n\n\nProperty, Plant & Equipment（有形固定資産）\n105,047M\n2,205M\n\n\nEquity Investments（持分法投資等）\n8,667M\n4,720M¹\n\n\nGoodwill（のれん）\n23,912M\n25,083M\n\n\nIntangible Assets（無形資産）\n2,877M\n17,250M\n\n\nOther Non-Current Assets\n12,280M\n4,720M¹\n\n\n\n\nAsset推移\n\n\n\n\n\n\n\n\n\n\n企業\nQ3 2024 Total Assets\nQ3 2025 Total Assets\n前年同期比（YoY）成長率\n\n\n\n\nIntel\n196,485M\n204,514M\n+4.1%\n\n\nAMD\n69,226M\n76,891M\n+11.1%\n\n\n\n\n資産効率\n\n\n\n\n\n\n\n\n\n\n指標\n計算式\nIntel\nAMD\n\n\n\n\n総資産営業利益率（ROA-Operating）\n営業利益 ÷ 総資産\n0.33%\n1.65%\n\n\n有形固定資産回転率\n売上高 ÷ 有形固定資産\n0.13 回\n4.19 回\n\n\n\n\n\n総資産営業利益率は，AMDがIntelの約5倍で，資産を利益に変換する効率が高い（ファブレスの軽い資産構造）\n\n営業キャッシュフロー（Operating Cash Flow）比較\n\n\n\n項目\nIntel\nAMD\n\n\n\n\nNet Income\n0.36B\n1.31B\n\n\nDepreciation + Amortization(無形資産償却)\n8.67B\n0.5B\n\n\nStock-based Compensation\n1.90B\n0.7B\n\n\nRestructuring / Impairment\n0.84B\n0.2B\n\n\nWorking Capital影響\n▲1.6B\n▲0.3B\n\n\nOperating Cash Flow 合計\n5.41B\n4.0B 前後\n\n\n\n\nインテルの8.67Bという減価償却費は，過去の巨額設備投資の現れ\n会計上の費用であり現金流出ではないため，OCFに加算"
  },
  {
    "objectID": "posts/2026-01-14-semiconductor-industry/index.html#references",
    "href": "posts/2026-01-14-semiconductor-industry/index.html#references",
    "title": "半導体メーカーの事業形態",
    "section": "References",
    "text": "References\n\nAMD Press Release\nIntel Press Release\nGartner Says Worldwide Semiconductor Revenue Grew 21% in 2025"
  },
  {
    "objectID": "posts/2025-01-08-bigquery-preprocess-01/index.html",
    "href": "posts/2025-01-08-bigquery-preprocess-01/index.html",
    "title": "BigQuery: TIME型カラムを指定したレベルで丸めて集計する",
    "section": "",
    "text": "▶  スーパーの来店時刻データ\n\n\n\nmember_id\nusage_date\nusage_time\n\n\n\n\n\n123456\n2024-02-01\n08:09:00\n\n\n\n223456\n2024-02-01\n08:10:00\n\n\n\n223456\n2024-02-11\n08:10:00\n\n\n\n123456\n2024-02-01\n20:09:00\n\n\n\n323456\n2024-02-01\n20:09:00\n\n\n\n\nという形でとあるスーパーの来店時刻データregmonkey-sample-data.restaurant_kawasaki.customer_recordが与えられているとします． このとき，以下の3つの処理を実施して，曜日×時間帯別平均来店者数の集計を行いたいとします．\n ▶  処理1: 24時間オーバーのデータへ変換\n\n00:01:00 → 24:00:00\n01:01:59 → 25:00:00\n\nのように夜中02:59:59までは26:59:59へ変換するという処理\n ▶  処理2: TIME型データを丸める\n\n08:09:00 → 08:00:00\n08:20:00 → 08:15:00\n\nのようにTIME型データを15分刻みに丸める処理\n ▶  処理3: DATE型データをISO day of weekへ変換\n\n月曜日を1, 日曜日を7とするISO day of weekに変換する\n祝日は8をアサインする\n\n2024-02-11, 2024-02-23は8がアサインされる"
  },
  {
    "objectID": "posts/2025-01-08-bigquery-preprocess-01/index.html#what-i-want-to-do",
    "href": "posts/2025-01-08-bigquery-preprocess-01/index.html#what-i-want-to-do",
    "title": "BigQuery: TIME型カラムを指定したレベルで丸めて集計する",
    "section": "",
    "text": "▶  スーパーの来店時刻データ\n\n\n\nmember_id\nusage_date\nusage_time\n\n\n\n\n\n123456\n2024-02-01\n08:09:00\n\n\n\n223456\n2024-02-01\n08:10:00\n\n\n\n223456\n2024-02-11\n08:10:00\n\n\n\n123456\n2024-02-01\n20:09:00\n\n\n\n323456\n2024-02-01\n20:09:00\n\n\n\n\nという形でとあるスーパーの来店時刻データregmonkey-sample-data.restaurant_kawasaki.customer_recordが与えられているとします． このとき，以下の3つの処理を実施して，曜日×時間帯別平均来店者数の集計を行いたいとします．\n ▶  処理1: 24時間オーバーのデータへ変換\n\n00:01:00 → 24:00:00\n01:01:59 → 25:00:00\n\nのように夜中02:59:59までは26:59:59へ変換するという処理\n ▶  処理2: TIME型データを丸める\n\n08:09:00 → 08:00:00\n08:20:00 → 08:15:00\n\nのようにTIME型データを15分刻みに丸める処理\n ▶  処理3: DATE型データをISO day of weekへ変換\n\n月曜日を1, 日曜日を7とするISO day of weekに変換する\n祝日は8をアサインする\n\n2024-02-11, 2024-02-23は8がアサインされる"
  },
  {
    "objectID": "posts/2025-01-08-bigquery-preprocess-01/index.html#query-example",
    "href": "posts/2025-01-08-bigquery-preprocess-01/index.html#query-example",
    "title": "BigQuery: TIME型カラムを指定したレベルで丸めて集計する",
    "section": "Query Example",
    "text": "Query Example\n ▶  処理1: 24時間オーバーのデータへ変換\nTIME型のままでは23:59:59までしかカバーされないので，extended timeの表記を試みたい場合はSTRING型へ変換する必要があります．\nCREATE TEMP FUNCTION convert_extended_time(standard_time TIME)\nRETURNS STRING\nAS (\n  CASE \n    WHEN EXTRACT(HOUR FROM standard_time) &lt; 3 THEN\n      FORMAT(\"%02d:%02d:%02d\", EXTRACT(HOUR FROM standard_time) + 24, EXTRACT(MINUTE FROM standard_time), EXTRACT(SECOND FROM standard_time))\n    ELSE \n      FORMAT(\"%02d:%02d:%02d\", EXTRACT(HOUR FROM standard_time), EXTRACT(MINUTE FROM standard_time), EXTRACT(SECOND FROM standard_time))\n  END\n);\n ▶  処理2: TIME型データを丸める\nCREATE TEMP FUNCTION round_to_nearest_15_minute(usage_time TIME, round_level INT64)\nRETURNS TIME\nAS (\n  TIME_TRUNC(\n    TIME_SUB(usage_time, INTERVAL MOD(EXTRACT(MINUTE FROM usage_time), round_level) MINUTE),\n    MINUTE\n  )\n);\n ▶  処理3: DATE型データをISO day of weekへ変換\nBigQueryが提供する EXTRACT(DAYOFWEEK FROM &lt;date-column&gt;) は日曜日1から始まり土曜日7で終わる形式となっているので自分で以下のように関数をUDFを定義することが必要になります．\nCREATE TEMP FUNCTION convert_iso_dayofweek(usage_date DATE)\nRETURNS INT64\nAS (\n  MOD(EXTRACT(DAYOFWEEK FROM usage_date) + 5, 7) + 1\n);\n ▶  データ抽出クエリ\nWITH\n  daily_summary AS(\n    SELECT \n        usage_date,\n        round_to_nearest_15_minute(usage_time, 15) AS rounded_usage_time,\n        CASE\n          WHEN usage_date in (DATE('2024-02-11'), DATE('2024-02-23')) THEN 8\n          ELSE convert_iso_dayofweek(usage_date) \n        END AS dayofweek,\n        COUNT(1) AS customer_count\n    FROM \n        `regmonkey-sample-data.restaurant_kawasaki.customer_record`\n    GROUP BY\n        1, 2\n  )\nSELECT\n    dayofweek,\n    convert_extended_time(rounded_usage_time) AS rounded_usage_time,\n    AVG(customer_count) AS mean_customer_count\nFROM\n    daily_summary \nGROUP BY \n  1, 2\nORDER BY\n  1, 2;"
  },
  {
    "objectID": "posts/2025-07-03-total-differential-with-ideal-gas/index.html",
    "href": "posts/2025-07-03-total-differential-with-ideal-gas/index.html",
    "title": "理想気体の全微分",
    "section": "",
    "text": "関数 \\(z = f(x,y)\\) を \\(P = (x, y)\\) の近傍において考察します．\n\\[\n\\Delta z = f(x + \\Delta x, y + \\Delta y) - f(x, y)\n\\]\nとしたとき，次のように考える\n\\[\n\\Delta z = A\\Delta x + B\\Delta y + \\epsilon\\rho \\label{eq-differential}\n\\]\nこのとき，\n\n\\(A, B\\) は \\(\\Delta x, \\Delta y\\) には関係しない係数\n\\(\\rho = \\sqrt{\\Delta x^2 + \\Delta y^2}\\)\n\\(\\epsilon \\to 0 \\ \\ \\text{ as} \\ \\ \\rho \\to 0\\)\n\nが成立するならば，関数 \\(z\\) は点 \\(P\\) において微分可能であるといいます．\n\n\\(\\eqref{eq-differential}\\) が成り立つならば，\\(\\Delta y = 0\\) が成立するとき，\n\\[\n\\begin{align}\n\\rho &= |\\Delta x|\\\\\n\\frac{\\Delta z}{\\Delta x} &= A \\pm \\epsilon\n\\end{align}\n\\]\nこのとき，微分可能性の仮定より \\(\\Delta x \\to 0\\) と共に \\(\\epsilon \\to 0\\) だから，点P において\n\\[\n\\frac{\\partial z}{\\partial x} = A\n\\]\n同様に\n\\[\n\\frac{\\partial z}{\\partial y} = B\n\\]\n\n\n点 \\((x + \\Delta x, y + \\Delta y)\\) が一定の方向から \\((x, y)\\) に収束するとき，一定方向からなので\n\\[\n\\begin{align}\n\\Delta x &= \\rho \\cos\\alpha\\\\\n\\Delta y &= \\rho \\sin\\alpha\n\\end{align}\n\\]\nと考えることができます．このとき，\n\\[\n\\begin{gather}\n\\frac{\\Delta z}{\\rho} = A\\cos\\alpha + B\\sin\\alpha + \\epsilon\\\\\n\\lim_{\\rho\\to 0}\\frac{\\Delta z}{\\rho} = A\\cos\\alpha + B\\sin\\alpha = \\frac{\\partial z}{\\partial x} \\cos\\alpha + \\frac{\\partial z}{\\partial y} \\sin\\alpha\n\\end{gather}\n\\]\nつまり，\\(\\rho\\to 0\\) とするとき，\\(\\Delta z\\) などを \\(dz\\) と表記しなおすと\n\\[\ndz = \\frac{\\partial z}{\\partial x} dx + \\frac{\\partial z}{\\partial y} dy\n\\]\nこのように，\\(z\\) が微分可能なるとき，\\(dz\\) を \\(dx, dy\\) に関する一次式で表すことを \\(z\\) の全微分とよびます．\n\n\n\n\\(z = f(x, y)\\) がある領域の各店において微分可能であるとき，その領域において微分可能という．その場合，\\(f(x, y)\\) はその領域で連続です．\n\nTheorem 1 \nある領域で \\(\\displaystyle \\frac{\\partial z}{\\partial x}, \\frac{\\partial z}{\\partial y}\\) が存在してかつ連続であるならば，\\(z\\)はその領域において微分可能である．\n\n\n\n\n\n\n\n\nNoteProof\n\n\n\n\n\n\\(\\Delta x, \\Delta y\\) をそれぞれ \\(h, k\\) と書けば\n\\[\n\\begin{align}\n\\Delta z\n  &= f(x+h, y+k) - f(x, y)\\\\\n  &= \\underbrace{f(x + h, y +k) - f(x, y +k)}_{(A)} + \\underbrace{f(x, y +k) - f(x, y)}_{(B)}\n\\end{align}\n\\]\n\nについて，\\(\\displaystyle \\frac{\\partial z}{\\partial x}\\) が存在し，連続であるので，\\(x\\) に関して平均値の定理が利用できます．つまり，\n\n\\[\nf(x + h, y + k) - f(x, y + k) = hf_x(x+ \\theta h, y +k), \\ \\ 0&lt; \\theta &lt; 1\n\\]\n仮定より \\(f_x\\) は連続であるので\n\\[\nf_x(x+ \\theta h, y +k) = f_x(x, y) + \\epsilon\n\\]\nとおけば，\\(h, k\\to 0\\) のとき \\(\\epsilon \\to 0\\).\n同様に \\(y\\) について考えると\n\\[\nf(x, y+ k) - f(x, y) = kf_y(x, y) + k\\epsilon'\n\\]\n整理すると，\n\\[\n\\Delta z = hf_x(x, y) + kf_y(x, y) + h\\epsilon + k\\epsilon'\n\\]\n\\(\\rho = \\sqrt{h^2 + k^2}\\) とすると \\(|h|\\leq \\rho, |k|\\leq \\rho\\) であるので\n\\[\nh\\epsilon + k\\epsilon' \\leq (|\\epsilon| + |\\epsilon'|)\\rho\n\\]\n従って，\n\\[\n\\Delta z = hf_x(x, y) + kf_y(x, y) + o(\\rho)\n\\]\n従って，\\(z\\) は微分可能であることがわかります．"
  },
  {
    "objectID": "posts/2025-07-03-total-differential-with-ideal-gas/index.html#微分可能性",
    "href": "posts/2025-07-03-total-differential-with-ideal-gas/index.html#微分可能性",
    "title": "理想気体の全微分",
    "section": "",
    "text": "関数 \\(z = f(x,y)\\) を \\(P = (x, y)\\) の近傍において考察します．\n\\[\n\\Delta z = f(x + \\Delta x, y + \\Delta y) - f(x, y)\n\\]\nとしたとき，次のように考える\n\\[\n\\Delta z = A\\Delta x + B\\Delta y + \\epsilon\\rho \\label{eq-differential}\n\\]\nこのとき，\n\n\\(A, B\\) は \\(\\Delta x, \\Delta y\\) には関係しない係数\n\\(\\rho = \\sqrt{\\Delta x^2 + \\Delta y^2}\\)\n\\(\\epsilon \\to 0 \\ \\ \\text{ as} \\ \\ \\rho \\to 0\\)\n\nが成立するならば，関数 \\(z\\) は点 \\(P\\) において微分可能であるといいます．\n\n\\(\\eqref{eq-differential}\\) が成り立つならば，\\(\\Delta y = 0\\) が成立するとき，\n\\[\n\\begin{align}\n\\rho &= |\\Delta x|\\\\\n\\frac{\\Delta z}{\\Delta x} &= A \\pm \\epsilon\n\\end{align}\n\\]\nこのとき，微分可能性の仮定より \\(\\Delta x \\to 0\\) と共に \\(\\epsilon \\to 0\\) だから，点P において\n\\[\n\\frac{\\partial z}{\\partial x} = A\n\\]\n同様に\n\\[\n\\frac{\\partial z}{\\partial y} = B\n\\]\n\n\n点 \\((x + \\Delta x, y + \\Delta y)\\) が一定の方向から \\((x, y)\\) に収束するとき，一定方向からなので\n\\[\n\\begin{align}\n\\Delta x &= \\rho \\cos\\alpha\\\\\n\\Delta y &= \\rho \\sin\\alpha\n\\end{align}\n\\]\nと考えることができます．このとき，\n\\[\n\\begin{gather}\n\\frac{\\Delta z}{\\rho} = A\\cos\\alpha + B\\sin\\alpha + \\epsilon\\\\\n\\lim_{\\rho\\to 0}\\frac{\\Delta z}{\\rho} = A\\cos\\alpha + B\\sin\\alpha = \\frac{\\partial z}{\\partial x} \\cos\\alpha + \\frac{\\partial z}{\\partial y} \\sin\\alpha\n\\end{gather}\n\\]\nつまり，\\(\\rho\\to 0\\) とするとき，\\(\\Delta z\\) などを \\(dz\\) と表記しなおすと\n\\[\ndz = \\frac{\\partial z}{\\partial x} dx + \\frac{\\partial z}{\\partial y} dy\n\\]\nこのように，\\(z\\) が微分可能なるとき，\\(dz\\) を \\(dx, dy\\) に関する一次式で表すことを \\(z\\) の全微分とよびます．\n\n\n\n\\(z = f(x, y)\\) がある領域の各店において微分可能であるとき，その領域において微分可能という．その場合，\\(f(x, y)\\) はその領域で連続です．\n\nTheorem 1 \nある領域で \\(\\displaystyle \\frac{\\partial z}{\\partial x}, \\frac{\\partial z}{\\partial y}\\) が存在してかつ連続であるならば，\\(z\\)はその領域において微分可能である．\n\n\n\n\n\n\n\n\nNoteProof\n\n\n\n\n\n\\(\\Delta x, \\Delta y\\) をそれぞれ \\(h, k\\) と書けば\n\\[\n\\begin{align}\n\\Delta z\n  &= f(x+h, y+k) - f(x, y)\\\\\n  &= \\underbrace{f(x + h, y +k) - f(x, y +k)}_{(A)} + \\underbrace{f(x, y +k) - f(x, y)}_{(B)}\n\\end{align}\n\\]\n\nについて，\\(\\displaystyle \\frac{\\partial z}{\\partial x}\\) が存在し，連続であるので，\\(x\\) に関して平均値の定理が利用できます．つまり，\n\n\\[\nf(x + h, y + k) - f(x, y + k) = hf_x(x+ \\theta h, y +k), \\ \\ 0&lt; \\theta &lt; 1\n\\]\n仮定より \\(f_x\\) は連続であるので\n\\[\nf_x(x+ \\theta h, y +k) = f_x(x, y) + \\epsilon\n\\]\nとおけば，\\(h, k\\to 0\\) のとき \\(\\epsilon \\to 0\\).\n同様に \\(y\\) について考えると\n\\[\nf(x, y+ k) - f(x, y) = kf_y(x, y) + k\\epsilon'\n\\]\n整理すると，\n\\[\n\\Delta z = hf_x(x, y) + kf_y(x, y) + h\\epsilon + k\\epsilon'\n\\]\n\\(\\rho = \\sqrt{h^2 + k^2}\\) とすると \\(|h|\\leq \\rho, |k|\\leq \\rho\\) であるので\n\\[\nh\\epsilon + k\\epsilon' \\leq (|\\epsilon| + |\\epsilon'|)\\rho\n\\]\n従って，\n\\[\n\\Delta z = hf_x(x, y) + kf_y(x, y) + o(\\rho)\n\\]\n従って，\\(z\\) は微分可能であることがわかります．"
  },
  {
    "objectID": "posts/2025-07-03-total-differential-with-ideal-gas/index.html#理想気体の-pvt-の全微分",
    "href": "posts/2025-07-03-total-differential-with-ideal-gas/index.html#理想気体の-pvt-の全微分",
    "title": "理想気体の全微分",
    "section": "理想気体の \\(p,v,T\\) の全微分",
    "text": "理想気体の \\(p,v,T\\) の全微分\n1molの理想気体の状態方程式は\n\\[\npv = RT\n\\]\n\\(p\\) を \\(v, T\\) の関数とする場合\n\\[\np(v, T) = \\frac{RT}{v}\n\\]\nとして，圧力 \\(p\\) を2つの独立変数 \\(v, T\\) の2変数関数とすると，\n\\[\n\\begin{align}\ndp &= \\left(\\frac{\\partial p}{\\partial v}\\right)_T dv + \\left(\\frac{\\partial p}{\\partial T}\\right)_vdT\\\\\n   &= -\\frac{RT}{v^2}dv + \\frac{R}{v}dT\n\\end{align}\n\\]\n\\(v\\) を \\(p, T\\) の関数とする場合\n\\[\ndv = -\\frac{RT}{p^2}dp + \\frac{R}{p}dT\n\\]\n\\(T\\) を \\(p, v\\) の関数とする場合\n\\[\ndT = \\frac{v}{R}dp + \\frac{p}{R}dv\n\\]"
  },
  {
    "objectID": "posts/2025-07-02-convergence-in-sequence/index.html",
    "href": "posts/2025-07-02-convergence-in-sequence/index.html",
    "title": "収束の条件とCauchyの判定法",
    "section": "",
    "text": "Theorem 1 区間縮小法\n閉区間 \\(I_n = [a_n, b_n] \\, \\ (n=1,2,\\cdots)\\) において，\n\n各区間 \\(I_n\\) がその前の区間 \\(I_{n-1}\\) に含まれ\n\\(n\\) が限りなく増すとき，区間 \\(I_n\\) の幅 \\(b_n - a_n\\) が限りなく小さくなる\n任意の \\(m, n\\) に対して，\\(a_n &lt; b_m\\)\n\nとき，これらの各区間に共通なるただ一つの点が存在する(=各区間に共通なる数が唯一つ確定する)\n\n\n\n\n\n\n\nNoteProof\n\n\n\n\n\n仮定 1, 3 より\n\\[\na_1 \\leq a_2 \\leq \\cdots a_n \\leq \\cdots b_n \\leq \\cdots b_2 \\leq b_1\n\\]\n数列 \\(\\{a_n\\}, \\{b_n\\}\\) は有界かつ単調増加/減少であるので，\n\\[\n\\lim_{n\\to\\infty}a_n = \\alpha, \\lim_{n\\to\\infty}b_n = \\beta\n\\]\n任意の \\(m, n\\) に対して，\\(a_n &lt; b_m\\) であるので，\n\\[\n\\begin{align}\nn\\to\\infty &\\Rightarrow \\alpha \\leq b_m\\\\\nm\\to\\infty &\\Rightarrow \\alpha \\leq \\beta\n\\end{align}\n\\]\nまた, 仮定 2 より，任意の \\(\\epsilon &gt; 0\\) に対応して\n\\[\nb_n - a_n &lt; \\epsilon\n\\]\nを満たす \\(n\\) が存在し，\n\\[\na_n \\leq \\alpha \\leq \\beta \\leq b_n\n\\]\n従って，\n\\[\n0 \\leq \\beta - \\alpha &lt; \\epsilon\n\\]\n任意の \\(\\epsilon &gt;0\\) について成立するので\n\\[\n\\alpha = \\beta\n\\]\n\n\n\n\n\n\nTheorem 2 Dedekindの定理\n実数の切断 \\((A, B)\\) が与えられたとき，ただ１つの数 \\(s\\) が存在し，\\(s\\) は Aの最大数 xor Bの最小数である．\n\n\n\n\n\n\n\nNoteProof: 区間縮小法を用いた証明\n\n\n\n\n\n\\(A, N\\) から一対の数 \\(a, b\\) を取り出して，区間 \\(I_0 = [a, b]\\) を定義します．\n\\[\n\\frac{a+b}{2}\n\\]\nは中間の数なので，A または B のどちらか一方に属していなければなりません．この条件に応じて\n\\[\n\\begin{align}\n\\frac{a+b}{2} \\in A &\\Rightarrow a_1 = \\frac{a+b}{2}, b_1 = b\\\\\n\\frac{a+b}{2} \\in B &\\Rightarrow a_1 = a, b_1 = \\frac{a+b}{2}\n\\end{align}\n\\]\nとして区間を更新していきます．\n区間が更新されるたびに\n\\[\n\\begin{align}\nI_0\\text{の幅} &= b-a\\\\\nI_1\\text{の幅} &= \\frac{b-a}{2}\\\\\nI_2\\text{の幅} &= \\frac{b-a}{4}\\\\\n\\vdots &\\\\\nI_n\\text{の幅} &= \\frac{b-a}{2^n}\n\\end{align}\n\\]\nとなるので，\n\\[\nI_1 \\supset I_2 \\supset \\cdots \\supset I_n \\supset \\cdots\n\\]\n従って，各区間に共通する数はただ１つ \\(s\\) と定まり，それは切断 \\((A, B)\\) の上組または下組の属す必要があります．\n\\(s\\in A\\) とすると，任意の \\(s^\\prime &gt; s\\) は \\(b_n \\to s\\) より\n\\[\ns &lt; b_n &lt; s^\\prime \\text{なる $b_n$ が存在する} \\Rightarrow s^\\prime \\in B\n\\]\nつまり，\\(s\\) は \\(A\\) の最大数であり，このとき \\(B\\) には最小数は存在しません．仮に，\\(s^\\prime\\) を \\(B\\) の最小数とすると\n\\[\ns_0 = \\frac{s^\\prime - s}{2}\n\\]\nなる数を考えると，十分大きな\\(n\\) について任意の\\(\\epsilon &gt; 0\\) で\n\\[\n|b_n - s| &lt; \\epsilon\\Rightarrow |b_n - s| &lt; \\frac{s^\\prime - s}{4}\n\\]\nを満たすような \\(b_n\\) が考えられ，このとき \\(b_n &lt; s^\\prime\\) であるので，最小数の仮定と矛盾します．\nもしも，\\(s\\in B\\) であるならば，同様のロジックで \\(s = \\min(B)\\) であり，\\(A\\) の最大数は存在しないことになります．"
  },
  {
    "objectID": "posts/2025-07-02-convergence-in-sequence/index.html#区間縮小法",
    "href": "posts/2025-07-02-convergence-in-sequence/index.html#区間縮小法",
    "title": "収束の条件とCauchyの判定法",
    "section": "",
    "text": "Theorem 1 区間縮小法\n閉区間 \\(I_n = [a_n, b_n] \\, \\ (n=1,2,\\cdots)\\) において，\n\n各区間 \\(I_n\\) がその前の区間 \\(I_{n-1}\\) に含まれ\n\\(n\\) が限りなく増すとき，区間 \\(I_n\\) の幅 \\(b_n - a_n\\) が限りなく小さくなる\n任意の \\(m, n\\) に対して，\\(a_n &lt; b_m\\)\n\nとき，これらの各区間に共通なるただ一つの点が存在する(=各区間に共通なる数が唯一つ確定する)\n\n\n\n\n\n\n\nNoteProof\n\n\n\n\n\n仮定 1, 3 より\n\\[\na_1 \\leq a_2 \\leq \\cdots a_n \\leq \\cdots b_n \\leq \\cdots b_2 \\leq b_1\n\\]\n数列 \\(\\{a_n\\}, \\{b_n\\}\\) は有界かつ単調増加/減少であるので，\n\\[\n\\lim_{n\\to\\infty}a_n = \\alpha, \\lim_{n\\to\\infty}b_n = \\beta\n\\]\n任意の \\(m, n\\) に対して，\\(a_n &lt; b_m\\) であるので，\n\\[\n\\begin{align}\nn\\to\\infty &\\Rightarrow \\alpha \\leq b_m\\\\\nm\\to\\infty &\\Rightarrow \\alpha \\leq \\beta\n\\end{align}\n\\]\nまた, 仮定 2 より，任意の \\(\\epsilon &gt; 0\\) に対応して\n\\[\nb_n - a_n &lt; \\epsilon\n\\]\nを満たす \\(n\\) が存在し，\n\\[\na_n \\leq \\alpha \\leq \\beta \\leq b_n\n\\]\n従って，\n\\[\n0 \\leq \\beta - \\alpha &lt; \\epsilon\n\\]\n任意の \\(\\epsilon &gt;0\\) について成立するので\n\\[\n\\alpha = \\beta\n\\]\n\n\n\n\n\n\nTheorem 2 Dedekindの定理\n実数の切断 \\((A, B)\\) が与えられたとき，ただ１つの数 \\(s\\) が存在し，\\(s\\) は Aの最大数 xor Bの最小数である．\n\n\n\n\n\n\n\nNoteProof: 区間縮小法を用いた証明\n\n\n\n\n\n\\(A, N\\) から一対の数 \\(a, b\\) を取り出して，区間 \\(I_0 = [a, b]\\) を定義します．\n\\[\n\\frac{a+b}{2}\n\\]\nは中間の数なので，A または B のどちらか一方に属していなければなりません．この条件に応じて\n\\[\n\\begin{align}\n\\frac{a+b}{2} \\in A &\\Rightarrow a_1 = \\frac{a+b}{2}, b_1 = b\\\\\n\\frac{a+b}{2} \\in B &\\Rightarrow a_1 = a, b_1 = \\frac{a+b}{2}\n\\end{align}\n\\]\nとして区間を更新していきます．\n区間が更新されるたびに\n\\[\n\\begin{align}\nI_0\\text{の幅} &= b-a\\\\\nI_1\\text{の幅} &= \\frac{b-a}{2}\\\\\nI_2\\text{の幅} &= \\frac{b-a}{4}\\\\\n\\vdots &\\\\\nI_n\\text{の幅} &= \\frac{b-a}{2^n}\n\\end{align}\n\\]\nとなるので，\n\\[\nI_1 \\supset I_2 \\supset \\cdots \\supset I_n \\supset \\cdots\n\\]\n従って，各区間に共通する数はただ１つ \\(s\\) と定まり，それは切断 \\((A, B)\\) の上組または下組の属す必要があります．\n\\(s\\in A\\) とすると，任意の \\(s^\\prime &gt; s\\) は \\(b_n \\to s\\) より\n\\[\ns &lt; b_n &lt; s^\\prime \\text{なる $b_n$ が存在する} \\Rightarrow s^\\prime \\in B\n\\]\nつまり，\\(s\\) は \\(A\\) の最大数であり，このとき \\(B\\) には最小数は存在しません．仮に，\\(s^\\prime\\) を \\(B\\) の最小数とすると\n\\[\ns_0 = \\frac{s^\\prime - s}{2}\n\\]\nなる数を考えると，十分大きな\\(n\\) について任意の\\(\\epsilon &gt; 0\\) で\n\\[\n|b_n - s| &lt; \\epsilon\\Rightarrow |b_n - s| &lt; \\frac{s^\\prime - s}{4}\n\\]\nを満たすような \\(b_n\\) が考えられ，このとき \\(b_n &lt; s^\\prime\\) であるので，最小数の仮定と矛盾します．\nもしも，\\(s\\in B\\) であるならば，同様のロジックで \\(s = \\min(B)\\) であり，\\(A\\) の最大数は存在しないことになります．"
  },
  {
    "objectID": "posts/2025-07-02-convergence-in-sequence/index.html#cauchyの判定法",
    "href": "posts/2025-07-02-convergence-in-sequence/index.html#cauchyの判定法",
    "title": "収束の条件とCauchyの判定法",
    "section": "Cauchyの判定法",
    "text": "Cauchyの判定法\n\nTheorem 3 Cauchyの判定法\n数列 \\(\\{a_n\\}\\) が収束するために必要かつ十分なる条件は，任意の \\(\\epsilon &gt; 0\\) に対応して \\(n_0\\) が定められて，\n\\[\np &gt; n_0, q &gt; n_0 \\Rightarrow |a_p - a_q| &lt; \\epsilon\n\\]\n\n\n\n\n\n\n\nNoteProof: 高木解析概論 p12 より\n\n\n\n\n\n必要条件\n\\(a_n \\to \\lambda\\) であるならば収束の定義より，ある \\(N(\\epsilon)\\) が存在して\n\\[\np &gt; N(\\epsilon), q &gt; N(\\epsilon) \\Rightarrow |a_p - \\lambda| &lt;\\frac{\\epsilon}{2}, |a_q - \\lambda| &lt;\\frac{\\epsilon}{2}\n\\]\n従って，\n\\[\n\\begin{align}\n|a_p - a_q|\n  &= |a_p - \\lambda + \\lambda  - a_q|\\\\\n  &\\leq |a_p - \\lambda| + |a_q - \\lambda| \\,\\ \\because{\\text{三角不等式}}\\\\\n  & &lt; \\epsilon\n\\end{align}\n\\]\nよって，収束列はコーシー列です．\n十分性\n\\({a_n}\\) がコーシー列であるとする：\n条件より以下のように \\({a_n}\\) は有界となります．\n\\[\np &gt; n_0 \\Rightarrow |a_p - a_{n_0 + 1}| &lt; \\epsilon, \\, \\ \\text{$n_0$ は確定なので有限個の数列 $\\{a_n\\}_{n=1}^{n_0}$ を加えても有界}\n\\]\n次に，任意の \\(n\\) について，\\(\\{a_k\\}_{k=n}^\\infty\\) を対応させて，その数列に対応する上限と下限を \\(l_n, m_n\\) として，\n\\[\nI_n = [m_n, l_n]\n\\]\nとおくと，\n\\[\n\\begin{gather}\nm_1 \\leq m_2 \\leq \\cdots \\leq m_n \\leq \\cdots l_n \\leq \\cdots l_2 \\leq l_1\\\\\nI_1 \\supset I_2 \\supset \\cdots \\supset I_n \\supset \\cdots\n\\end{gather}\n\\]\nここで改めて，任意の \\(\\epsilon &gt; 0\\) に対応して \\(n_0\\) が定められて，\n\\[\np &gt; n_0,  q &gt; n_0 \\Rightarrow |a_p - a_q| &lt; \\epsilon\n\\]\n\\(n &gt; n_0\\) とすると，上限の定義より任意の \\(q \\geq n\\) に対して\n\\[\nl_n - a_q &lt; \\epsilon\n\\]\nまた，下限の定義より，\n\\[\na_q - m_n &lt; \\epsilon\n\\]\nであるので，\n\\[\nl_n - m_n \\leq 2\\epsilon\n\\]\n\\(\\epsilon &gt; 0\\) は任意なので、区間 \\(I_{n}\\) の長さ \\(l_{n} - m_{n}\\) は \\(0\\) に収束し．\n\\[\nl_n \\to \\lambda, m_n \\to \\lambda \\, \\, \\because{\\text{区間縮小法}}\n\\]\nとなるような \\(\\lambda\\) が存在します．これは，\\(a_n \\to \\lambda\\) を意味します．実際，十分大きな \\(n\\) について\n\\[\n|a_n - \\lambda| \\leq l_n - m_n \\leq \\epsilon\n\\]\nが成立します．\n\n\n\n\n無限級数の収束とCauchyの判定法\n\nDefinition 1 無限級数の収束\n数列 \\(\\{a_n\\}\\) の最初の \\(n\\) 項の和を\n\\[\ns_n = a_1 + a_2 + \\cdots + a_n\n\\]\nとしたとき，\\(\\lim_{n\\to\\infty}s_n = s\\) が存在するならば，無限級数 \\(\\sum_{n=1}^\\infty a_n\\) は収束するといいます．\n\nCauchyの判定法により \\(n\\) を十分大きくして，任意の \\(m &gt; n\\) について\n\\[\n|s_n - s_m| = |a_{n+1} + \\cdots + a_m| &lt; \\epsilon\n\\]\nが \\(s_n\\) の収束の必要十分条件となります．故に収束の場合は，\n\\[\n\\lim_{n\\to\\infty}\\sum_{p=1}^\\infty a_{n+p} = 0\n\\]\nとなります．\n\\(\\lim_{n\\to\\infty}a_n = 0\\) は無限級数収束の必要条件 but not 十分条件\nCauchyの収束条件より \\(n\\) を十分大きくしたとき\n\\[\n|s_{n+1} - s_n| &lt; \\epsilon \\Rightarrow \\lim_{n\\to\\infty} a_n = 0\n\\]\nとなりますが，逆は成り立ちません．\n例えば\n\\[\ns_n = \\sum_{k=1}^n \\frac{1}{k}\n\\]\nを考えると，\n\\[\n\\lim_{n\\to\\infty}\\frac{1}{n} = 0\n\\]\nは成立しますが，級数についてのCauchy判定条件を見てみると，\\(n\\) を十分大きくしても\n\\[\n|s_{2n} - s_n| = \\underbrace{\\frac{1}{n+1} +\\cdots +\\frac{1}{2n}}_{n\\text{個}} &gt; \\frac{1}{2n} \\times n = \\frac{1}{2}\n\\]\nとなり，条件を満たさないため収束しません．実際にオイラー定数 \\(\\gamma\\) を用いると以下のような関係式になります\n\\[\n\\sum_{k=1}^n = \\ln N + \\gamma + \\omicron(1)\n\\]"
  },
  {
    "objectID": "posts/2025-07-02-convergence-in-sequence/index.html#references",
    "href": "posts/2025-07-02-convergence-in-sequence/index.html#references",
    "title": "収束の条件とCauchyの判定法",
    "section": "References",
    "text": "References\n\n定本 解析概論, 高木貞治 著\n数列の極限 Tips"
  },
  {
    "objectID": "posts/2025-07-08-WLLN-SLLN/index.html",
    "href": "posts/2025-07-08-WLLN-SLLN/index.html",
    "title": "Law of Large Numbers",
    "section": "",
    "text": "Exercise 1 WLLN\n\\(|m|&lt; \\infty, |\\sigma| &lt; \\infty\\) として \\(X_i \\overset{\\mathrm{iid}}{\\sim} D(m, \\sigma^2)\\) とする．このとき任意の \\(\\epsilon &gt; 0\\) について，\n\\[\n\\lim_{n\\to\\infty} P\\left[\\left|\\frac{X_1 + \\cdots + X_n}{n} - m\\right| &gt; \\epsilon\\right] = 0\n\\]\nが成り立つ．\n\n\n\n\n\n\n\nNoteProof\n\n\n\n\n\n\\(Z \\equiv \\sum X_i\\) とおくと，i.i.d の仮定より\n\\[\n\\begin{align}\n\\mathbb E[Z] &= nm\\\\\n\\operatorname{Var}(Z) &= n\\sigma^2\n\\end{align}\n\\]\nよって，\n\\[\n\\begin{align}\nP\\bigg[\\bigg|\\frac{Z}{n} - m\\bigg| &gt; \\epsilon\\bigg]\n  &= P[|Z - nm| &gt; n\\epsilon]\\\\\n  &= P[(Z - nm)^2 &gt; n^2\\epsilon^2]\\\\\n  &\\leq \\frac{\\mathbb E[(Z - nm)^2]}{n^2\\epsilon^2} \\, \\ \\because{\\text{Markov不等式}}\\\\\n  &= \\frac{\\sigma^2}{n\\epsilon^2}\n\\end{align}\n\\]\n従って，\n\\[\n\\lim_{n\\to\\infty} P\\left[\\left|\\frac{X_1 + \\cdots + X_n}{n} - m\\right| &gt; \\epsilon\\right] = 0\n\\]"
  },
  {
    "objectID": "posts/2025-07-08-WLLN-SLLN/index.html#review-question",
    "href": "posts/2025-07-08-WLLN-SLLN/index.html#review-question",
    "title": "Law of Large Numbers",
    "section": "",
    "text": "Exercise 1 WLLN\n\\(|m|&lt; \\infty, |\\sigma| &lt; \\infty\\) として \\(X_i \\overset{\\mathrm{iid}}{\\sim} D(m, \\sigma^2)\\) とする．このとき任意の \\(\\epsilon &gt; 0\\) について，\n\\[\n\\lim_{n\\to\\infty} P\\left[\\left|\\frac{X_1 + \\cdots + X_n}{n} - m\\right| &gt; \\epsilon\\right] = 0\n\\]\nが成り立つ．\n\n\n\n\n\n\n\nNoteProof\n\n\n\n\n\n\\(Z \\equiv \\sum X_i\\) とおくと，i.i.d の仮定より\n\\[\n\\begin{align}\n\\mathbb E[Z] &= nm\\\\\n\\operatorname{Var}(Z) &= n\\sigma^2\n\\end{align}\n\\]\nよって，\n\\[\n\\begin{align}\nP\\bigg[\\bigg|\\frac{Z}{n} - m\\bigg| &gt; \\epsilon\\bigg]\n  &= P[|Z - nm| &gt; n\\epsilon]\\\\\n  &= P[(Z - nm)^2 &gt; n^2\\epsilon^2]\\\\\n  &\\leq \\frac{\\mathbb E[(Z - nm)^2]}{n^2\\epsilon^2} \\, \\ \\because{\\text{Markov不等式}}\\\\\n  &= \\frac{\\sigma^2}{n\\epsilon^2}\n\\end{align}\n\\]\n従って，\n\\[\n\\lim_{n\\to\\infty} P\\left[\\left|\\frac{X_1 + \\cdots + X_n}{n} - m\\right| &gt; \\epsilon\\right] = 0\n\\]"
  },
  {
    "objectID": "posts/2025-07-08-WLLN-SLLN/index.html#the-weak-law-of-large-numbers",
    "href": "posts/2025-07-08-WLLN-SLLN/index.html#the-weak-law-of-large-numbers",
    "title": "Law of Large Numbers",
    "section": "The Weak Law of Large Numbers",
    "text": "The Weak Law of Large Numbers\n\nTheorem 1 The Weak Law of Large Numbers\n\\(X_i\\) がi.i.d.にmean \\(\\mu\\) の分布に従うとする．このとき，任意の \\(\\epsilon &gt;0\\) について\n\\[\n\\lim_{n\\to\\infty} P\\left[\\left|\\frac{X_1 + \\cdots + X_n}{n} - \\mu\\right| &gt; \\epsilon\\right] = 0\n\\]\n\n\nWLLNは，\\(n\\) が十分大きいとき，標本平均の分布の大部分が母平均 \\(\\mu\\) の近くに集中することを示しています\n\\(\\mu\\) を中心とした長さのある正の区間 \\([\\mu−\\epsilon, \\mu+\\epsilon]\\) を考えると、\\(\\frac{\\sum X_i}{N}\\) がその区間内に入る確率は高い\n\n\nExample 1 conservativeな出口調査推定\n有権者の内，\\(p\\) の割合がA党を支持しているとします．\\(n\\) 人を”randomly selected”して，その結果 \\(M_n\\) の割合の人がA等を支持していたとします．マルコフ不等式より\n\\[\nP(|M_n - p|&gt;\\epsilon)\\leq \\frac{p(1-p)}{n\\epsilon^2}\n\\]\n\\(p(1-p)\\leq \\frac{1}{4}\\) から保守的に見積もると\n\\[\nP(|M_n - p|&gt;\\epsilon)\\leq \\frac{1}{4n\\epsilon^2}\n\\]\n例として \\(\\epsilon =0.01, n=50,000\\) の水準を考えると\n\\[\nP(|M_n - p|&gt;\\epsilon)\\leq \\frac{1}{4\\cdot 10,000\\cdot 0.01^2} = 0.05\n\\]\nつまり，\\(n=50,000\\) インタビューしてようやく誤差 \\(0.01\\) 未満の水準となることがわかります．\n\n\n\n\n\n\nTipREMARKS\n\n\n\n\nCLTを用いるともっと少ないサンプルサイズ \\(n\\) で誤差 \\(0.01\\) 未満の水準を達成できます"
  },
  {
    "objectID": "posts/2025-07-08-WLLN-SLLN/index.html#the-strong-law-of-large-numbers",
    "href": "posts/2025-07-08-WLLN-SLLN/index.html#the-strong-law-of-large-numbers",
    "title": "Law of Large Numbers",
    "section": "The Strong Law of Large Numbers",
    "text": "The Strong Law of Large Numbers\n\nTheorem 2 The Strong Law of Large Numbers\n\\(X_i\\) がi.i.d.にmean \\(\\mu\\) の分布に従うとする．また，\\(\\mathbb E[|X_i|] &lt; \\infty\\) であるとする．このとき，sample mean列\n\\[\nM_n = \\frac{X_1 + \\cdots + X_n}{n}\n\\]\nについて\n\\[\nP\\left(\\lim_{n\\to\\infty}\\frac{X_1 + \\cdots + X_n}{n} = \\mu\\right) = 1\n\\]\nが成り立つことを強大数の法則という．これはつまり，\n\\[\nM_n \\overset{a.s.}{\\to} \\mu\n\\]\n\n\nボレル＝カンテリの補題\n\nTheorem 3 ボレル＝カンテリの補題 I\n\\((\\Omega, \\mathcal{F}, P)\\) を確率空間とするとき，\\(A_i \\in \\mathcal{F}\\) に対して，\n\\[\n\\sum_{i=1}^\\infty P(A_i) &lt; \\infty \\Rightarrow P(\\underset{n\\to\\infty}{\\lim\\sup} A_n) = 0\n\\]\n\n\n\n\n\n\n\nNoteProof\n\n\n\n\n\n上極限の定義と確率の劣加法性より，\n\\[\n\\begin{align}\nP(\\underset{n\\to\\infty}{\\lim\\sup} A_n)\n  &= P\\left(\\bigcap_{n=1}^\\infty\\bigcup_{k=n}^\\infty A_k\\right)\\\\\n  &= \\lim_{n\\to\\infty} P\\left(\\bigcup_{k=n}^\\infty A_k\\right)\\\\\n  &\\leq \\lim_{n}\\sum_{k=n}^\\infty P(A_k)\n\\end{align}\n\\]\nここで，\\(\\sum_{i=1}^\\infty P(A_i)\\) であるので，\\(\\displaystyle\\lim_{n}\\sum_{k=n}^\\infty P(A_k) = 0\\). 従って，\n\\[\n\\sum_{i=1}^\\infty P(A_i) &lt; \\infty \\Rightarrow P(\\underset{n\\to\\infty}{\\lim\\sup} A_n) = 0\n\\]\n\n\n\nTheorem 3 は \\((A_i)_{i\\in\\mathbb N}\\) のうち高々有限個の \\(A_i\\) しか起こらないことを意味します．また，書き換えると\n\\[\nP(\\underset{n\\to\\infty}{\\lim\\sup} A_n) = 0 \\Leftrightarrow P(\\underset{n\\to\\infty}{\\lim\\inf} A^c_n)= 1\n\\]\n\nExample 2 コイン投げ問題とボレル＝カンテリの補題 I\nコインを何度も独立に投げる試行を考えます．ただし，毎回投げるコインは違いものとし，\\(n\\) 回目に投げるコインの表の出る確率は\n\\[\np_n \\in (0, 1)\n\\]\nとします．このとき，ボレル＝カンテリの補題 Iより\n\\[\n\\sum_{n=1}^\\infty p_n &lt; \\infty \\Rightarrow P(\\text{表が出る回数は有限回}) = 1\n\\]\nとなります．（\\(\\sum_{n=1}^\\infty p_n &lt; \\infty\\) の一例としてはバーゼル問題など参照）\n例として，確率変数\n\\[\nX_n = \\left\\{\\begin{array}{c}\n1 & \\text{$n$回目に表が出る}\\\\\n0 & \\text{$n$回目に裏が出る}\n\\end{array}\\right.\n\\]\nとして，\\(A_n = \\{X_n = 1\\} \\in \\mathcal{F}\\) を考えると，\n\\[\n\\sum_{n=1}^\\infty P(A_n) = \\sum_{n=1}^\\infty p_n &lt; \\infty\n\\]\nボレル=カンテリの補題 I を用いると\n\\[\nP(\\underset{n\\to\\infty}{\\lim\\inf} A^c_n) = P\\left(\\lim_{n\\to\\infty}\\bigcup_{n=1}^\\infty\\bigcap_{k=n}^\\infty\\{X_n = 0\\} \\right) =  1\n\\]\nこれは，確率1で，ある \\(n = N\\) が存在して \\(k\\geq n\\) に対して \\(\\{X_n = 0\\}\\), つまり裏が出るということを意味します．これは，表が出る回数は有限回と同じ意味です．\n\n\n\nTheorem 4 Almost surely convergence\n確率変数列 \\(\\{X_n\\}\\) について，任意の \\(\\epsilon &gt;0\\) に対して\n\\[\n\\sum_{n=1}^\\infty P(|X_n - X| &gt; \\epsilon) &lt; \\infty\n\\]\nを満たすとします．このとき，\n\\[\nX_n \\overset{\\text{a.s.}}{\\to}X\n\\]\n\n\n\n\n\n\n\nNoteProof\n\n\n\n\n\n任意の \\(p \\in \\mathbb N\\) に対して，確率事象を\n\\[\nA_n^p = \\{|X_n - X| &gt; p^{-1}\\}\n\\]\nとおきます．仮定より\n\\[\n\\sum_{n=1}^\\infty P(A_n^p) &lt; \\infty\n\\]\nであるので，ボレル=カンテリの補題 I を用いると，任意の \\(p \\in \\mathbb N\\) に対して\n\\[\nP\\left(\\underset{n\\to\\infty}{\\lim\\sup} A_n^p \\right) = 0 \\Leftrightarrow P\\left(\\underset{n\\to\\infty}{\\lim\\inf} (A_n^p)^c \\right) = 1\n\\]\n任意の \\(p\\in\\mathbb N\\) で成立することから\n\\[\n\\begin{align}\n1\n  &= P\\left(\\bigcap_{p=1}^\\infty \\left\\{\\underset{n\\to\\infty}{\\lim\\inf} (A_n^p)^c\\right\\} \\right)\\\\\n  &= P\\left(\\bigcap_{p=1}^\\infty\\bigcup_{n=1}^\\infty\\bigcap_{k\\geq n} (A_k^p)^c\\right)\\\\\n  &= P\\left(\\bigcap_{p=1}^\\infty\\bigcup_{n=1}^\\infty\\bigcap_{k\\geq n} \\{|X_k - X| \\leq p^{-1}\\}\\right)\n\\end{align}\n\\]\n\\(\\epsilon = p^{-1}\\) と対応させると，任意の \\(\\epsilon &gt;0\\) にたいして，ある \\(n\\in\\mathbb N\\) が存在して，\\(k\\geq n\\) となるすべての \\(k\\) について，\n\\[\n|X_k - X| \\leq \\epsilon\n\\]\nとなる確率が１である，ことを意味しており，これは概収束の定義と一致している．"
  },
  {
    "objectID": "posts/2025-12-19-fishers-exact-test/index.html",
    "href": "posts/2025-12-19-fishers-exact-test/index.html",
    "title": "Fisher’s Exact Test",
    "section": "",
    "text": "体外式膜型人工肺（ECMO）は，重度の呼吸不全を抱える新生児を治療するための処置です．\nある実験1にて\n\n29人の新生児がECMOで治療\n10人の新生児が従来の内科的治療（CMT）で治療\n\nが実施された結果，以下のような主要評価項目が得られました．\n\n\n\nTreatment\nDie\nLive\ntotal\n\n\n\n\nECMO\n1\n28\n29\n\n\nCMT\n4\n6\n10\n\n\ntotal\n5\n34\n39\n\n\n\nこのデータに対して，ECMOとCMTで死亡率に差があるかどうかを検定したいという問題を考えます．\n\n\n\n\n\n\n\n\nNote検証仮説\n\n\n\n\\[\nH_0: \\text{治療法（ECMO or CMT）と結果（Die or Live）は独立である}\n\\]\nつまり，ECMOで治療しようがCMTで治療しようが，死亡率は同じであるという仮説．\n\n\nこのときの対立仮説は，両側検定の場合\n\\[\nH_1: \\text{治療法と結果は独立ではない（関連がある）}\n\\]\n片側検定の場合は\n\\[\nH_1: \\text{CMTと比べECMOは死亡率の低い治療法である}\n\\]\nとなります．\n\\(H_0\\) が真のときの分布\nFisher’s exact testでは (ECMOの人数, CMTの人数) = (29, 10) はstudy designによって固定されていると考えます．\\(H_0\\)が真であるとき，39人の患者のうち5人が死亡し34人が生存するという周辺度数は固定されていると考えます．\nこのとき，ECMO群29人の中で死亡する人数 \\(X\\) は超幾何分布に従うと考え\n\\[\nX \\sim \\text{Hypergeometric}(N=39, M=5, K=29)\n\\]\nここで，\n\n\\(N = 39\\): 全患者数\n\\(M = 5\\): 全死亡者数\n\\(K = 29\\): ECMO群の患者数\n\n\\(H_0\\)の下で，ECMO群の死亡者数 \\(X = x\\) となる確率は\n\\[\nP(X = x \\mid H_0) = \\frac{\\binom{5}{x}\\binom{34}{29-x}}{\\binom{39}{29}}\n\\]\n検定統計量とp値\n観測されたECMO群の死亡者数は \\(x = 1\\) です．\n片側検定（ECMOの方が死亡率が低い）のp値は\n\\[\np_{\\text{one-sided}} = P(X \\leq 1 \\mid H_0) = \\sum_{k=0}^{1} \\frac{\\binom{5}{k}\\binom{34}{29-k}}{\\binom{39}{29}}\n\\]\n両側検定のp値の計算方法はいくつかありますが，scipy.stats.fisher_exactでは観測値の確率以下となるすべての\\(x\\)の確率を合計する方法を採用しています：\n\\[\np_{\\text{two-sided}} = \\sum_{x: P(X=x \\mid H_0) \\leq P(X=1 \\mid H_0)} P(X = x \\mid H_0)\n\\]\nつまり，観測された \\(x=1\\) の確率 \\(P(X=1 \\mid H_0)\\) を計算し，それ以下の確率を持つすべての \\(x\\) の値について確率を合計します．\n\n\nCode\nfrom scipy.stats import hypergeom, fisher_exact\nfrom scipy.stats.contingency import odds_ratio as odds_ratio_ci\nimport numpy as np\n\n# パラメータ\nN = 39  # 全患者数\nR = 5   # 全死亡者数\nK = 29  # ECMO群の患者数\n\n# P(X &lt;= 1) を計算\np_value_left = hypergeom.cdf(1, N, R, K)\nprint(f\"P(X &lt;= 1 | H_0) = {p_value_left:.6f}\")\n\n# scipy.stats.fisher_exact で確認\ntable = [[1, 28], [4, 6]]\nodds_ratio, p_two_sided = fisher_exact(table, alternative='two-sided')\n_, p_less = fisher_exact(table, alternative='less')\n\n# オッズ比の信頼区間（exact method）\nres = odds_ratio_ci(table)\nci_two_sided = res.confidence_interval(confidence_level=0.95)\nci_less = res.confidence_interval(confidence_level=0.95, alternative='less')\n\nprint(f\"\\nFisher's exact test (scipy):\")\nprint(f\"  Odds ratio: {odds_ratio:.4f}\")\nprint(f\"  95% CI (two-sided): ({ci_two_sided.low:.4f}, {ci_two_sided.high:.4f})\")\nprint(f\"  95% CI (less): (0, {ci_less.high:.4f})\")\nprint(f\"  p-value (two-sided): {p_two_sided:.6f}\")\nprint(f\"  p-value (less): {p_less:.6f}\")\n\n\nP(X &lt;= 1 | H_0) = 0.011015\n\nFisher's exact test (scipy):\n  Odds ratio: 0.0536\n  95% CI (two-sided): (0.0011, 0.7319)\n  95% CI (less): (0, 0.5453)\n  p-value (two-sided): 0.011015\n  p-value (less): 0.011015\n\n\n\n\n\n\n\n\nNote\n\n\n\n\n上記のscipyによる計算結果は R における fisher.test() とほぼ同じ計算結果となっています\none-sided testにおけるOdds ratioのCIは OR &lt; 1 をベースに計算しています\n\n\n\n\nExample 1 (両側検定で計算される領域) \n\\(N=45, M=12, K=30\\), 観測値 \\(x=5\\) における両側検定のp値計算領域を可視化します．\n\n\n\n\noutcome 1\noutcome 2\ntotal\n\n\n\n\ngroup 1\n5\n25\n30\n\n\ngroup 2\n7\n8\n15\n\n\ntotal\n12\n33\n45\n\n\n\n\n\nCode\nimport matplotlib.pyplot as plt\nfrom scipy.stats import hypergeom\nimport numpy as np\n\n# パラメータ\nN, M, K = 45, 12, 30\nobs = 5\n\n# x の範囲\nx_min = max(0, K - (N - M))\nx_max = min(M, K)\nx = np.arange(x_min, x_max + 1)\n\n# PMF の計算\npmf = hypergeom.pmf(x, N, M, K)\n\n# 観測値の確率\np_obs = hypergeom.pmf(obs, N, M, K)\n\n# 両側検定: 観測値の確率以下となる x を特定\ntwo_sided_mask = pmf &lt;= p_obs + 1e-10  # 数値誤差を考慮\n\n# 色分け\ncolors = ['red' if two_sided_mask[i] else 'steelblue' for i in range(len(x))]\n\nfig, ax = plt.subplots(figsize=(8, 5))\nbars = ax.bar(x, pmf, color=colors, alpha=0.7, edgecolor='black')\n\n# 観測値にマーカー\nax.axvline(x=obs, color='darkred', linestyle='--', linewidth=2, label=f'Observed x={obs}')\n\n# P(X=obs) の水平線\nax.axhline(y=p_obs, color='gray', linestyle=':', linewidth=1.5, label=f'P(X={obs}) = {p_obs:.4f}')\n\nax.set_xlabel('x', fontsize=12)\nax.set_ylabel('P(X = x)', fontsize=12)\nax.set_title(f'Hypergeometric Distribution under $H_0$ (N={N}, M={M}, K={K})\\nRed: two-sided p-value region', fontsize=13)\nax.set_xticks(x)\nax.legend(loc='upper right')\nax.grid(axis='y', alpha=0.3)\n\nplt.tight_layout()\nplt.show()\n\n# p値の計算\np_one_sided = hypergeom.cdf(obs, N, M, K)\np_two_sided = pmf[two_sided_mask].sum()\n\nprint(f\"P(X={obs}) = {p_obs:.6f}\")\nprint(f\"Two-sided region: x ∈ {set(int(xi) for xi in x[two_sided_mask])}\")\nprint(f\"p-value (one-sided, less): {p_one_sided:.6f}\")\nprint(f\"p-value (two-sided): {p_two_sided:.6f}\")\n\n\n\n\n\n\n\n\n\nP(X=5) = 0.031885\nTwo-sided region: x ∈ {0, 1, 2, 3, 4, 5, 11, 12}\np-value (one-sided, less): 0.038771\np-value (two-sided): 0.070269\n\n\n赤色の領域が両側検定のp値に寄与する部分です．観測値 \\(x=1\\) の確率 \\(P(X=1 \\mid H_0)\\) 以下の確率を持つすべての \\(x\\) の値（この場合 \\(x=0, 1, 2, 3, 4, 5, 11, 12\\)）の確率を合計します．\n\n検定統計量とp値\n観測されたECMO群の死亡者数は \\(x = 1\\) である．片側検定（ECMOの方が死亡率が低い）のp値は\n\\[\np = P(X \\leq 1 \\mid H_0) = \\sum_{k=0}^{1} \\frac{\\binom{5}{k}\\binom{34}{29-k}}{\\binom{39}{29}}\n\\]\n\n\nCode\nfrom scipy.stats import hypergeom, fisher_exact\nfrom scipy.stats.contingency import odds_ratio as odds_ratio_ci\nimport numpy as np\n\n# パラメータ\nN = 39  # 全患者数\nR = 5   # 全死亡者数\nK = 29  # ECMO群の患者数\n\n# P(X &lt;= 1) を計算\np_value_left = hypergeom.cdf(1, N, R, K)\nprint(f\"P(X &lt;= 1 | H_0) = {p_value_left:.6f}\")\n\n# scipy.stats.fisher_exact で確認\ntable = [[1, 28], [4, 6]]\nodds_ratio, p_two_sided = fisher_exact(table, alternative='two-sided')\n_, p_less = fisher_exact(table, alternative='less')\n\n# オッズ比の信頼区間（exact method）\nres = odds_ratio_ci(table)\nci_two_sided = res.confidence_interval(confidence_level=0.95)\nci_less = res.confidence_interval(confidence_level=0.95, alternative='less')\n\nprint(f\"\\nFisher's exact test (scipy):\")\nprint(f\"  Odds ratio: {odds_ratio:.4f}\")\nprint(f\"  95% CI (two-sided): ({ci_two_sided.low:.4f}, {ci_two_sided.high:.4f})\")\nprint(f\"  95% CI (less): (0, {ci_less.high:.4f})\")\nprint(f\"  p-value (two-sided): {p_two_sided:.6f}\")\nprint(f\"  p-value (less): {p_less:.6f}\")\n\n\nP(X &lt;= 1 | H_0) = 0.011015\n\nFisher's exact test (scipy):\n  Odds ratio: 0.0536\n  95% CI (two-sided): (0.0011, 0.7319)\n  95% CI (less): (0, 0.5453)\n  p-value (two-sided): 0.011015\n  p-value (less): 0.011015\n\n\n\n\n\nFisher’s exact testでは，サンプルサイズが大きくても周辺度数のバランスが悪いと検出力が下がることがあります．\n以下の2つのテーブルを比較してみます（どちらもオッズ比は同じ0.5）：\n\n\nCode\nfrom scipy.stats import fisher_exact\nimport pandas as pd\n\n# Case 1: バランスの取れた周辺度数 (N=40)\ntable1 = [[5, 15], [8, 12]]\nor1, p1 = fisher_exact(table1, alternative='less')\n\n# Case 2: アンバランスな周辺度数 (N=50)\ntable2 = [[10, 30], [4, 6]]\nor2, p2 = fisher_exact(table2, alternative='less')\n\nprint(\"Case 1: バランスの取れた周辺度数\")\nprint(f\"  Table: {table1}\")\nprint(f\"  N = {sum(sum(row) for row in table1)}, 行比 = 20:20 (50%:50%)\")\nprint(f\"  Odds ratio: {or1:.4f}\")\nprint(f\"  p-value (less): {p1:.6f}\")\n\nprint(\"\\nCase 2: アンバランスな周辺度数\")\nprint(f\"  Table: {table2}\")\nprint(f\"  N = {sum(sum(row) for row in table2)}, 行比 = 40:10 (80%:20%)\")\nprint(f\"  Odds ratio: {or2:.4f}\")\nprint(f\"  p-value (less): {p2:.6f}\")\n\n\nCase 1: バランスの取れた周辺度数\n  Table: [[5, 15], [8, 12]]\n  N = 40, 行比 = 20:20 (50%:50%)\n  Odds ratio: 0.5000\n  p-value (less): 0.250302\n\nCase 2: アンバランスな周辺度数\n  Table: [[10, 30], [4, 6]]\n  N = 50, 行比 = 40:10 (80%:20%)\n  Odds ratio: 0.5000\n  p-value (less): 0.283076\n\n\nなぜCase 2の方がp値が大きい（検出力が低い）のか？\n超幾何分布の観点から説明すると：\n\nCase 1: 行2（対照群）が20人いるため，死亡者13人の配分パターンが多様\nCase 2: 行2（対照群）がわずか10人のため，死亡者14人のうち最大でも10人しか行2に配分できない\n\n\n\nCode\nimport matplotlib.pyplot as plt\nfrom scipy.stats import hypergeom\nimport numpy as np\n\n# Case 1: N=40, M=13(死亡), K=20(行1)\nN1, M1, K1 = 40, 13, 20\nx1_min, x1_max = max(0, K1-(N1-M1)), min(M1, K1)\nx1 = np.arange(x1_min, x1_max + 1)\npmf1 = hypergeom.pmf(x1, N1, M1, K1)\n\n# Case 2: N=50, M=14(死亡), K=40(行1)\nN2, M2, K2 = 50, 14, 40\nx2_min, x2_max = max(0, K2-(N2-M2)), min(M2, K2)\nx2 = np.arange(x2_min, x2_max + 1)\npmf2 = hypergeom.pmf(x2, N2, M2, K2)\n\n# 観測値\nobs1, obs2 = 5, 10\n\nfig, axes = plt.subplots(1, 2, figsize=(10, 4.5))\n\n# Case 1\ncolors1 = ['red' if xi &lt;= obs1 else 'steelblue' for xi in x1]\naxes[0].bar(x1, pmf1, color=colors1, alpha=0.7, edgecolor='black')\naxes[0].set_title('Case 1: N=40, group ratio 50:50', fontsize=12)\naxes[0].set_xlabel('Die in treated', fontsize=11)\naxes[0].set_ylabel('P(X=x)', fontsize=11)\naxes[0].set_xticks(x1)\naxes[0].grid(axis='y', alpha=0.3)\n\n# Case 2\ncolors2 = ['red' if xi &lt;= obs2 else 'steelblue' for xi in x2]\naxes[1].bar(x2, pmf2, color=colors2, alpha=0.7, edgecolor='black')\naxes[1].set_title('Case 2: N=50, group ratio 80:20', fontsize=12)\naxes[1].set_xlabel('Die in treated', fontsize=11)\naxes[1].set_xticks(x2)\naxes[1].grid(axis='y', alpha=0.3)\n\nfig.suptitle('hypergeometric distribution under $H_0$', fontsize=14)\nplt.tight_layout()\nplt.show()\n\nprint(f\"Case 1: P(X ≤ {obs1}) = {hypergeom.cdf(obs1, N1, M1, K1):.6f}\")\nprint(f\"Case 2: P(X ≤ {obs2}) = {hypergeom.cdf(obs2, N2, M2, K2):.6f}\")\n\n\n\n\n\n\n\n\n\nCase 1: P(X ≤ 5) = 0.250302\nCase 2: P(X ≤ 10) = 0.283076\n\n\nCase 2では，分布の取りうる範囲が狭く（\\(x \\in [4, 14]\\)），観測値10が分布の中央付近に位置するため，p値が大きくなります．\n\n\n\n\n\n\nTip実験計画への示唆\n\n\n\nFisher’s exact testの検出力を高めるには：\n\nサンプルサイズを増やすだけでなく\n群間のバランスを取る（できれば1:1に近づける）ことが重要\n\n特に対照群のサンプルサイズが小さいと，効果量が同じでも検出力が大幅に低下します．\n\n\n\n\n\nFisher’s exact testは行と列を対称に扱うため，テーブルを転置しても検定結果は変わりません．\n\\(2 \\times 2\\) テーブルを以下のように表記します：\n\n\n\n\n\\(Y=1\\)\n\\(Y=2\\)\nsum\n\n\n\n\n\\(X=1\\)\n\\(n_{11}\\)\n\\(n_{12}\\)\n\\(n_{1+}\\)\n\n\n\\(X=2\\)\n\\(n_{21}\\)\n\\(n_{22}\\)\n\\(n_{2+}\\)\n\n\nsum\n\\(n_{+1}\\)\n\\(n_{+2}\\)\n\\(n\\)\n\n\n\n超幾何分布の確率は\n\\[\nP(n_{11}) = \\frac{\\binom{n_{+1}}{n_{11}}\\binom{n_{+2}}{n_{12}}}{\\binom{n}{n_{1+}}} = \\frac{\\binom{n_{1+}}{n_{11}}\\binom{n_{2+}}{n_{21}}}{\\binom{n}{n_{+1}}} = \\frac{n_{1+}! \\, n_{2+}! \\, n_{+1}! \\, n_{+2}!}{n! \\, n_{11}! \\, n_{12}! \\, n_{21}! \\, n_{22}!}\n\\]\nと表され，\\(n_{11}\\) セルの値で与えられます．この式は行と列について完全に対称であるため：\n\n行を入れ替えても（\\(X=1 \\leftrightarrow X=2\\)）\n列を入れ替えても（\\(Y=1 \\leftrightarrow Y=2\\)）\n行と列を転置しても（\\(X \\leftrightarrow Y\\)）\n\n超幾何分布に基づくPMFの値は変わりません．\n\n\nCode\nfrom scipy.stats import fisher_exact\n\n# 元のテーブル\ntable_original = [[1, 28], [4, 6]]\n\n# 転置したテーブル\ntable_transposed = [[1, 4], [28, 6]]\n\n# 行を入れ替えたテーブル\ntable_row_swap = [[4, 6], [1, 28]]\n\n# 列を入れ替えたテーブル\ntable_col_swap = [[28, 1], [6, 4]]\n\ntables = [\n    (\"Original\", table_original),\n    (\"Transposed\", table_transposed),\n    (\"Row swapped\", table_row_swap),\n    (\"Column swapped\", table_col_swap),\n]\n\nfor name, table in tables:\n    odds_ratio, p_two_sided = fisher_exact(table, alternative='two-sided')\n    print(f\"{name:15s}: table={table}, OR={odds_ratio:.4f}, p={p_two_sided:.6f}\")\n\n\nOriginal       : table=[[1, 28], [4, 6]], OR=0.0536, p=0.011015\nTransposed     : table=[[1, 4], [28, 6]], OR=0.0536, p=0.011015\nRow swapped    : table=[[4, 6], [1, 28]], OR=18.6667, p=0.011015\nColumn swapped : table=[[28, 1], [6, 4]], OR=18.6667, p=0.011015\n\n\nこの性質により，Fisher’s exact testは説明変数と応答変数を区別しないため，前向き研究（prospective study）でも後ろ向き研究（retrospective study）でも適用可能です．\n\n\n\n\n\n\nNote前向き研究と後ろ向き研究\n\n\n\n\n\n\n\n\n\n\n\n\n研究デザイン\n説明\n例\n\n\n\n\n前向き研究(Prospective)\n曝露（治療法など）を先に決め，その後の結果（アウトカム）を追跡観察する\nECMO vs CMT の患者を登録し，死亡/生存を追跡\n\n\n後ろ向き研究(Retrospective)\n結果（アウトカム）が既に判明している集団から，過去の曝露を調べる\n死亡/生存の患者記録から，過去にどの治療を受けたか調査\n\n\n\n\nFisher’s exact testは超幾何確率の対称性により，どちらのデザインでも同じ検定が適用できます：\n\n前向き研究：行（治療群）を固定 → 列（結果）の分布を見る\n後ろ向き研究：列（結果）を固定 → 行（治療群）の分布を見る\n\nどちらの場合も \\(n_{11}\\) の超幾何確率は同じ値になるため，p値も同一です．"
  },
  {
    "objectID": "posts/2025-12-19-fishers-exact-test/index.html#fishers-exact-testfisherの正確検定",
    "href": "posts/2025-12-19-fishers-exact-test/index.html#fishers-exact-testfisherの正確検定",
    "title": "Fisher’s Exact Test",
    "section": "",
    "text": "体外式膜型人工肺（ECMO）は，重度の呼吸不全を抱える新生児を治療するための処置です．\nある実験1にて\n\n29人の新生児がECMOで治療\n10人の新生児が従来の内科的治療（CMT）で治療\n\nが実施された結果，以下のような主要評価項目が得られました．\n\n\n\nTreatment\nDie\nLive\ntotal\n\n\n\n\nECMO\n1\n28\n29\n\n\nCMT\n4\n6\n10\n\n\ntotal\n5\n34\n39\n\n\n\nこのデータに対して，ECMOとCMTで死亡率に差があるかどうかを検定したいという問題を考えます．\n\n\n\n\n\n\n\n\nNote検証仮説\n\n\n\n\\[\nH_0: \\text{治療法（ECMO or CMT）と結果（Die or Live）は独立である}\n\\]\nつまり，ECMOで治療しようがCMTで治療しようが，死亡率は同じであるという仮説．\n\n\nこのときの対立仮説は，両側検定の場合\n\\[\nH_1: \\text{治療法と結果は独立ではない（関連がある）}\n\\]\n片側検定の場合は\n\\[\nH_1: \\text{CMTと比べECMOは死亡率の低い治療法である}\n\\]\nとなります．\n\\(H_0\\) が真のときの分布\nFisher’s exact testでは (ECMOの人数, CMTの人数) = (29, 10) はstudy designによって固定されていると考えます．\\(H_0\\)が真であるとき，39人の患者のうち5人が死亡し34人が生存するという周辺度数は固定されていると考えます．\nこのとき，ECMO群29人の中で死亡する人数 \\(X\\) は超幾何分布に従うと考え\n\\[\nX \\sim \\text{Hypergeometric}(N=39, M=5, K=29)\n\\]\nここで，\n\n\\(N = 39\\): 全患者数\n\\(M = 5\\): 全死亡者数\n\\(K = 29\\): ECMO群の患者数\n\n\\(H_0\\)の下で，ECMO群の死亡者数 \\(X = x\\) となる確率は\n\\[\nP(X = x \\mid H_0) = \\frac{\\binom{5}{x}\\binom{34}{29-x}}{\\binom{39}{29}}\n\\]\n検定統計量とp値\n観測されたECMO群の死亡者数は \\(x = 1\\) です．\n片側検定（ECMOの方が死亡率が低い）のp値は\n\\[\np_{\\text{one-sided}} = P(X \\leq 1 \\mid H_0) = \\sum_{k=0}^{1} \\frac{\\binom{5}{k}\\binom{34}{29-k}}{\\binom{39}{29}}\n\\]\n両側検定のp値の計算方法はいくつかありますが，scipy.stats.fisher_exactでは観測値の確率以下となるすべての\\(x\\)の確率を合計する方法を採用しています：\n\\[\np_{\\text{two-sided}} = \\sum_{x: P(X=x \\mid H_0) \\leq P(X=1 \\mid H_0)} P(X = x \\mid H_0)\n\\]\nつまり，観測された \\(x=1\\) の確率 \\(P(X=1 \\mid H_0)\\) を計算し，それ以下の確率を持つすべての \\(x\\) の値について確率を合計します．\n\n\nCode\nfrom scipy.stats import hypergeom, fisher_exact\nfrom scipy.stats.contingency import odds_ratio as odds_ratio_ci\nimport numpy as np\n\n# パラメータ\nN = 39  # 全患者数\nR = 5   # 全死亡者数\nK = 29  # ECMO群の患者数\n\n# P(X &lt;= 1) を計算\np_value_left = hypergeom.cdf(1, N, R, K)\nprint(f\"P(X &lt;= 1 | H_0) = {p_value_left:.6f}\")\n\n# scipy.stats.fisher_exact で確認\ntable = [[1, 28], [4, 6]]\nodds_ratio, p_two_sided = fisher_exact(table, alternative='two-sided')\n_, p_less = fisher_exact(table, alternative='less')\n\n# オッズ比の信頼区間（exact method）\nres = odds_ratio_ci(table)\nci_two_sided = res.confidence_interval(confidence_level=0.95)\nci_less = res.confidence_interval(confidence_level=0.95, alternative='less')\n\nprint(f\"\\nFisher's exact test (scipy):\")\nprint(f\"  Odds ratio: {odds_ratio:.4f}\")\nprint(f\"  95% CI (two-sided): ({ci_two_sided.low:.4f}, {ci_two_sided.high:.4f})\")\nprint(f\"  95% CI (less): (0, {ci_less.high:.4f})\")\nprint(f\"  p-value (two-sided): {p_two_sided:.6f}\")\nprint(f\"  p-value (less): {p_less:.6f}\")\n\n\nP(X &lt;= 1 | H_0) = 0.011015\n\nFisher's exact test (scipy):\n  Odds ratio: 0.0536\n  95% CI (two-sided): (0.0011, 0.7319)\n  95% CI (less): (0, 0.5453)\n  p-value (two-sided): 0.011015\n  p-value (less): 0.011015\n\n\n\n\n\n\n\n\nNote\n\n\n\n\n上記のscipyによる計算結果は R における fisher.test() とほぼ同じ計算結果となっています\none-sided testにおけるOdds ratioのCIは OR &lt; 1 をベースに計算しています\n\n\n\n\nExample 1 (両側検定で計算される領域) \n\\(N=45, M=12, K=30\\), 観測値 \\(x=5\\) における両側検定のp値計算領域を可視化します．\n\n\n\n\noutcome 1\noutcome 2\ntotal\n\n\n\n\ngroup 1\n5\n25\n30\n\n\ngroup 2\n7\n8\n15\n\n\ntotal\n12\n33\n45\n\n\n\n\n\nCode\nimport matplotlib.pyplot as plt\nfrom scipy.stats import hypergeom\nimport numpy as np\n\n# パラメータ\nN, M, K = 45, 12, 30\nobs = 5\n\n# x の範囲\nx_min = max(0, K - (N - M))\nx_max = min(M, K)\nx = np.arange(x_min, x_max + 1)\n\n# PMF の計算\npmf = hypergeom.pmf(x, N, M, K)\n\n# 観測値の確率\np_obs = hypergeom.pmf(obs, N, M, K)\n\n# 両側検定: 観測値の確率以下となる x を特定\ntwo_sided_mask = pmf &lt;= p_obs + 1e-10  # 数値誤差を考慮\n\n# 色分け\ncolors = ['red' if two_sided_mask[i] else 'steelblue' for i in range(len(x))]\n\nfig, ax = plt.subplots(figsize=(8, 5))\nbars = ax.bar(x, pmf, color=colors, alpha=0.7, edgecolor='black')\n\n# 観測値にマーカー\nax.axvline(x=obs, color='darkred', linestyle='--', linewidth=2, label=f'Observed x={obs}')\n\n# P(X=obs) の水平線\nax.axhline(y=p_obs, color='gray', linestyle=':', linewidth=1.5, label=f'P(X={obs}) = {p_obs:.4f}')\n\nax.set_xlabel('x', fontsize=12)\nax.set_ylabel('P(X = x)', fontsize=12)\nax.set_title(f'Hypergeometric Distribution under $H_0$ (N={N}, M={M}, K={K})\\nRed: two-sided p-value region', fontsize=13)\nax.set_xticks(x)\nax.legend(loc='upper right')\nax.grid(axis='y', alpha=0.3)\n\nplt.tight_layout()\nplt.show()\n\n# p値の計算\np_one_sided = hypergeom.cdf(obs, N, M, K)\np_two_sided = pmf[two_sided_mask].sum()\n\nprint(f\"P(X={obs}) = {p_obs:.6f}\")\nprint(f\"Two-sided region: x ∈ {set(int(xi) for xi in x[two_sided_mask])}\")\nprint(f\"p-value (one-sided, less): {p_one_sided:.6f}\")\nprint(f\"p-value (two-sided): {p_two_sided:.6f}\")\n\n\n\n\n\n\n\n\n\nP(X=5) = 0.031885\nTwo-sided region: x ∈ {0, 1, 2, 3, 4, 5, 11, 12}\np-value (one-sided, less): 0.038771\np-value (two-sided): 0.070269\n\n\n赤色の領域が両側検定のp値に寄与する部分です．観測値 \\(x=1\\) の確率 \\(P(X=1 \\mid H_0)\\) 以下の確率を持つすべての \\(x\\) の値（この場合 \\(x=0, 1, 2, 3, 4, 5, 11, 12\\)）の確率を合計します．\n\n検定統計量とp値\n観測されたECMO群の死亡者数は \\(x = 1\\) である．片側検定（ECMOの方が死亡率が低い）のp値は\n\\[\np = P(X \\leq 1 \\mid H_0) = \\sum_{k=0}^{1} \\frac{\\binom{5}{k}\\binom{34}{29-k}}{\\binom{39}{29}}\n\\]\n\n\nCode\nfrom scipy.stats import hypergeom, fisher_exact\nfrom scipy.stats.contingency import odds_ratio as odds_ratio_ci\nimport numpy as np\n\n# パラメータ\nN = 39  # 全患者数\nR = 5   # 全死亡者数\nK = 29  # ECMO群の患者数\n\n# P(X &lt;= 1) を計算\np_value_left = hypergeom.cdf(1, N, R, K)\nprint(f\"P(X &lt;= 1 | H_0) = {p_value_left:.6f}\")\n\n# scipy.stats.fisher_exact で確認\ntable = [[1, 28], [4, 6]]\nodds_ratio, p_two_sided = fisher_exact(table, alternative='two-sided')\n_, p_less = fisher_exact(table, alternative='less')\n\n# オッズ比の信頼区間（exact method）\nres = odds_ratio_ci(table)\nci_two_sided = res.confidence_interval(confidence_level=0.95)\nci_less = res.confidence_interval(confidence_level=0.95, alternative='less')\n\nprint(f\"\\nFisher's exact test (scipy):\")\nprint(f\"  Odds ratio: {odds_ratio:.4f}\")\nprint(f\"  95% CI (two-sided): ({ci_two_sided.low:.4f}, {ci_two_sided.high:.4f})\")\nprint(f\"  95% CI (less): (0, {ci_less.high:.4f})\")\nprint(f\"  p-value (two-sided): {p_two_sided:.6f}\")\nprint(f\"  p-value (less): {p_less:.6f}\")\n\n\nP(X &lt;= 1 | H_0) = 0.011015\n\nFisher's exact test (scipy):\n  Odds ratio: 0.0536\n  95% CI (two-sided): (0.0011, 0.7319)\n  95% CI (less): (0, 0.5453)\n  p-value (two-sided): 0.011015\n  p-value (less): 0.011015\n\n\n\n\n\nFisher’s exact testでは，サンプルサイズが大きくても周辺度数のバランスが悪いと検出力が下がることがあります．\n以下の2つのテーブルを比較してみます（どちらもオッズ比は同じ0.5）：\n\n\nCode\nfrom scipy.stats import fisher_exact\nimport pandas as pd\n\n# Case 1: バランスの取れた周辺度数 (N=40)\ntable1 = [[5, 15], [8, 12]]\nor1, p1 = fisher_exact(table1, alternative='less')\n\n# Case 2: アンバランスな周辺度数 (N=50)\ntable2 = [[10, 30], [4, 6]]\nor2, p2 = fisher_exact(table2, alternative='less')\n\nprint(\"Case 1: バランスの取れた周辺度数\")\nprint(f\"  Table: {table1}\")\nprint(f\"  N = {sum(sum(row) for row in table1)}, 行比 = 20:20 (50%:50%)\")\nprint(f\"  Odds ratio: {or1:.4f}\")\nprint(f\"  p-value (less): {p1:.6f}\")\n\nprint(\"\\nCase 2: アンバランスな周辺度数\")\nprint(f\"  Table: {table2}\")\nprint(f\"  N = {sum(sum(row) for row in table2)}, 行比 = 40:10 (80%:20%)\")\nprint(f\"  Odds ratio: {or2:.4f}\")\nprint(f\"  p-value (less): {p2:.6f}\")\n\n\nCase 1: バランスの取れた周辺度数\n  Table: [[5, 15], [8, 12]]\n  N = 40, 行比 = 20:20 (50%:50%)\n  Odds ratio: 0.5000\n  p-value (less): 0.250302\n\nCase 2: アンバランスな周辺度数\n  Table: [[10, 30], [4, 6]]\n  N = 50, 行比 = 40:10 (80%:20%)\n  Odds ratio: 0.5000\n  p-value (less): 0.283076\n\n\nなぜCase 2の方がp値が大きい（検出力が低い）のか？\n超幾何分布の観点から説明すると：\n\nCase 1: 行2（対照群）が20人いるため，死亡者13人の配分パターンが多様\nCase 2: 行2（対照群）がわずか10人のため，死亡者14人のうち最大でも10人しか行2に配分できない\n\n\n\nCode\nimport matplotlib.pyplot as plt\nfrom scipy.stats import hypergeom\nimport numpy as np\n\n# Case 1: N=40, M=13(死亡), K=20(行1)\nN1, M1, K1 = 40, 13, 20\nx1_min, x1_max = max(0, K1-(N1-M1)), min(M1, K1)\nx1 = np.arange(x1_min, x1_max + 1)\npmf1 = hypergeom.pmf(x1, N1, M1, K1)\n\n# Case 2: N=50, M=14(死亡), K=40(行1)\nN2, M2, K2 = 50, 14, 40\nx2_min, x2_max = max(0, K2-(N2-M2)), min(M2, K2)\nx2 = np.arange(x2_min, x2_max + 1)\npmf2 = hypergeom.pmf(x2, N2, M2, K2)\n\n# 観測値\nobs1, obs2 = 5, 10\n\nfig, axes = plt.subplots(1, 2, figsize=(10, 4.5))\n\n# Case 1\ncolors1 = ['red' if xi &lt;= obs1 else 'steelblue' for xi in x1]\naxes[0].bar(x1, pmf1, color=colors1, alpha=0.7, edgecolor='black')\naxes[0].set_title('Case 1: N=40, group ratio 50:50', fontsize=12)\naxes[0].set_xlabel('Die in treated', fontsize=11)\naxes[0].set_ylabel('P(X=x)', fontsize=11)\naxes[0].set_xticks(x1)\naxes[0].grid(axis='y', alpha=0.3)\n\n# Case 2\ncolors2 = ['red' if xi &lt;= obs2 else 'steelblue' for xi in x2]\naxes[1].bar(x2, pmf2, color=colors2, alpha=0.7, edgecolor='black')\naxes[1].set_title('Case 2: N=50, group ratio 80:20', fontsize=12)\naxes[1].set_xlabel('Die in treated', fontsize=11)\naxes[1].set_xticks(x2)\naxes[1].grid(axis='y', alpha=0.3)\n\nfig.suptitle('hypergeometric distribution under $H_0$', fontsize=14)\nplt.tight_layout()\nplt.show()\n\nprint(f\"Case 1: P(X ≤ {obs1}) = {hypergeom.cdf(obs1, N1, M1, K1):.6f}\")\nprint(f\"Case 2: P(X ≤ {obs2}) = {hypergeom.cdf(obs2, N2, M2, K2):.6f}\")\n\n\n\n\n\n\n\n\n\nCase 1: P(X ≤ 5) = 0.250302\nCase 2: P(X ≤ 10) = 0.283076\n\n\nCase 2では，分布の取りうる範囲が狭く（\\(x \\in [4, 14]\\)），観測値10が分布の中央付近に位置するため，p値が大きくなります．\n\n\n\n\n\n\nTip実験計画への示唆\n\n\n\nFisher’s exact testの検出力を高めるには：\n\nサンプルサイズを増やすだけでなく\n群間のバランスを取る（できれば1:1に近づける）ことが重要\n\n特に対照群のサンプルサイズが小さいと，効果量が同じでも検出力が大幅に低下します．\n\n\n\n\n\nFisher’s exact testは行と列を対称に扱うため，テーブルを転置しても検定結果は変わりません．\n\\(2 \\times 2\\) テーブルを以下のように表記します：\n\n\n\n\n\\(Y=1\\)\n\\(Y=2\\)\nsum\n\n\n\n\n\\(X=1\\)\n\\(n_{11}\\)\n\\(n_{12}\\)\n\\(n_{1+}\\)\n\n\n\\(X=2\\)\n\\(n_{21}\\)\n\\(n_{22}\\)\n\\(n_{2+}\\)\n\n\nsum\n\\(n_{+1}\\)\n\\(n_{+2}\\)\n\\(n\\)\n\n\n\n超幾何分布の確率は\n\\[\nP(n_{11}) = \\frac{\\binom{n_{+1}}{n_{11}}\\binom{n_{+2}}{n_{12}}}{\\binom{n}{n_{1+}}} = \\frac{\\binom{n_{1+}}{n_{11}}\\binom{n_{2+}}{n_{21}}}{\\binom{n}{n_{+1}}} = \\frac{n_{1+}! \\, n_{2+}! \\, n_{+1}! \\, n_{+2}!}{n! \\, n_{11}! \\, n_{12}! \\, n_{21}! \\, n_{22}!}\n\\]\nと表され，\\(n_{11}\\) セルの値で与えられます．この式は行と列について完全に対称であるため：\n\n行を入れ替えても（\\(X=1 \\leftrightarrow X=2\\)）\n列を入れ替えても（\\(Y=1 \\leftrightarrow Y=2\\)）\n行と列を転置しても（\\(X \\leftrightarrow Y\\)）\n\n超幾何分布に基づくPMFの値は変わりません．\n\n\nCode\nfrom scipy.stats import fisher_exact\n\n# 元のテーブル\ntable_original = [[1, 28], [4, 6]]\n\n# 転置したテーブル\ntable_transposed = [[1, 4], [28, 6]]\n\n# 行を入れ替えたテーブル\ntable_row_swap = [[4, 6], [1, 28]]\n\n# 列を入れ替えたテーブル\ntable_col_swap = [[28, 1], [6, 4]]\n\ntables = [\n    (\"Original\", table_original),\n    (\"Transposed\", table_transposed),\n    (\"Row swapped\", table_row_swap),\n    (\"Column swapped\", table_col_swap),\n]\n\nfor name, table in tables:\n    odds_ratio, p_two_sided = fisher_exact(table, alternative='two-sided')\n    print(f\"{name:15s}: table={table}, OR={odds_ratio:.4f}, p={p_two_sided:.6f}\")\n\n\nOriginal       : table=[[1, 28], [4, 6]], OR=0.0536, p=0.011015\nTransposed     : table=[[1, 4], [28, 6]], OR=0.0536, p=0.011015\nRow swapped    : table=[[4, 6], [1, 28]], OR=18.6667, p=0.011015\nColumn swapped : table=[[28, 1], [6, 4]], OR=18.6667, p=0.011015\n\n\nこの性質により，Fisher’s exact testは説明変数と応答変数を区別しないため，前向き研究（prospective study）でも後ろ向き研究（retrospective study）でも適用可能です．\n\n\n\n\n\n\nNote前向き研究と後ろ向き研究\n\n\n\n\n\n\n\n\n\n\n\n\n研究デザイン\n説明\n例\n\n\n\n\n前向き研究(Prospective)\n曝露（治療法など）を先に決め，その後の結果（アウトカム）を追跡観察する\nECMO vs CMT の患者を登録し，死亡/生存を追跡\n\n\n後ろ向き研究(Retrospective)\n結果（アウトカム）が既に判明している集団から，過去の曝露を調べる\n死亡/生存の患者記録から，過去にどの治療を受けたか調査\n\n\n\n\nFisher’s exact testは超幾何確率の対称性により，どちらのデザインでも同じ検定が適用できます：\n\n前向き研究：行（治療群）を固定 → 列（結果）の分布を見る\n後ろ向き研究：列（結果）を固定 → 行（治療群）の分布を見る\n\nどちらの場合も \\(n_{11}\\) の超幾何確率は同じ値になるため，p値も同一です．"
  },
  {
    "objectID": "posts/2025-12-19-fishers-exact-test/index.html#power-analuysis-for-fishers-extact-test",
    "href": "posts/2025-12-19-fishers-exact-test/index.html#power-analuysis-for-fishers-extact-test",
    "title": "Fisher’s Exact Test",
    "section": "Power Analuysis for Fishers extact test",
    "text": "Power Analuysis for Fishers extact test\nFisher’s exact testのpower analysisは Mainland and Sutcliffe (1953) に基づくと, \\(N = 2n\\), \\(M = r\\), \\(K = n\\) と対応する形で\n\\[\n\\beta(n, p_1, p_2) = \\sum_{r=0}^{2n} \\sum_{x \\in C_r} \\binom{n}{x}\\binom{n}{r-x} p_1^x(1-p_1)^{n-x} p_2^{r-x}(1-p_2)^{n-r+x}\n\\]\nで計算することが出来ます．これは2つの独立な二項分布の積，及び同時分布のうち棄却域を満たす事象の総和を取っていると解釈することが出来ます．\n\n\n\n\n記号\n意味\n\n\n\n\n\\(r\\)\n両群の成功数の合計（\\(0〜n1+n2\\)）\n\n\n\\(x\\)\n第1群の成功数\n\n\n\\(C_r\\)\n臨界領域（p値 &lt; αとなるxの集合）\n\n\n\\(p_1, p_2\\)\n各群の真の成功確率\n\n\n\n\npseudocode\n上記のPower analysis計算関数を踏まえると以下のように整理できます\n\n\n\\begin{algorithm} \\caption{Power of Fisher's Exact Test} \\begin{algorithmic} \\Procedure{PowerFisherExact}{$n_1, n_2, p_1, p_2, \\alpha$} \\State $\\beta \\gets 0$ \\Comment{検出力を初期化} \\State $n \\gets n_1 + n_2$ \\Comment{総サンプルサイズ} \\For{$r = 0$ \\To $n$} \\Comment{両群の成功数の合計} \\State $x_{min} \\gets \\max(0, r - n_2)$ \\State $x_{max} \\gets \\min(n_1, r)$ \\For{$x = x_{min}$ \\To $x_{max}$} \\Comment{群1の成功数} \\State $T \\gets \\begin{pmatrix} x & n_1 - x \\\\ r - x & n_2 - r + x \\end{pmatrix}$ \\Comment{2×2分割表} \\State $p_{value} \\gets$ \\Call{FisherExactTest}{$T$} \\If{$p_{value} &lt; \\alpha$} \\Comment{ 臨界領域の判定} \\State $P_1 \\gets \\binom{n_1}{x} p_1^x (1-p_1)^{n_1-x}$ \\Comment{群1の二項確率} \\State $P_2 \\gets \\binom{n_2}{r-x} p_2^{r-x} (1-p_2)^{n_2-r+x}$ \\Comment{群2の二項確率} \\State $\\beta \\gets \\beta + P_1 \\cdot P_2$ \\Comment{同時確率を加算} \\EndIf \\EndFor \\EndFor \\State \\Return $\\beta$ \\EndProcedure \\end{algorithmic} \\end{algorithm}\n\n\n上記を見てみると，各 \\(r\\) の計算は完全に独立のため，最後に任意の順番で各チャンクの \\(\\beta_{chunk}\\) を足すことで最終的な検出力が計算できるので，並列化できることがわかります．\n\n実装\n\n\nCode\nfrom scipy import stats\nfrom typing import Literal, Iterable\nfrom multiprocessing import Pool, cpu_count\n\ndef _power_contribution(\n    r_values: Iterable[int],\n    n1: int,\n    n2: int,\n    p1: float,\n    p2: float,\n    alpha: float,\n    alternative: str,\n) -&gt; float:\n    \"\"\"r の集合に対する検出力寄与を計算\"\"\"\n    power = 0.0\n\n    # Binomial PMF を事前計算\n    binom1 = stats.binom(n1, p1)\n    binom2 = stats.binom(n2, p2)\n\n    for r in r_values:\n        x_min = max(0, r - n2)\n        x_max = min(n1, r)\n\n        for x in range(x_min, x_max + 1):\n            table = [[x, n1 - x], [r - x, n2 - (r - x)]]\n            _, p_value = stats.fisher_exact(table, alternative=alternative)\n\n            if p_value &lt; alpha:\n                power += binom1.pmf(x) * binom2.pmf(r - x)\n\n    return power\n\ndef power_fisher_exact(\n    p1: float,\n    p2: float,\n    n1: int,\n    n2: int,\n    alpha: float = 0.05,\n    alternative: Literal[\"two-sided\", \"greater\", \"less\"] = \"two-sided\",\n    multi: bool = False,\n    n_workers: int | None = None,\n) -&gt; float:\n    \"\"\"\n    Fisher正確検定の検出力を解析的に計算する。\n\n    Mainland and Sutcliffe (1953) の検出力関数に基づき、\n    Thomas and Conlon (1991) のアルゴリズムを使用して効率的に計算します。\n\n    検出力は以下の式で計算されます:\n        β(n1, p1, p2) = Σ_{r=0}^{2n} Σ_{x∈C_r} C(n,x) * C(n,r-x) *\n                        p1^x * (1-p1)^{n-x} * p2^{r-x} * (1-p2)^{n-r+x}\n\n    ここで、rは両群の成功数の合計、xは第1群の成功数、\n    C_rは超幾何分布による臨界領域です。\n\n    Parameters\n    ----------\n    p1 : float\n        第1群の真の比率 (0 &lt; p1 &lt; 1)\n    p2 : float\n        第2群の真の比率 (0 &lt; p2 &lt; 1)\n    n1 : int\n        第1群のサンプルサイズ\n    n2 : int\n        第2群のサンプルサイズ\n    alpha : float, optional\n        有意水準 (デフォルト: 0.05)\n    alternative : {\"two-sided\", \"greater\", \"less\"}, optional\n        対立仮説の種類 (デフォルト: \"two-sided\")\n    multi : bool, optional\n        マルチプロセス並列化を使用するかどうか (デフォルト: False)\n    n_workers : int or None, optional\n        ワーカー数 (デフォルト: CPU数)。multi=Trueの場合のみ有効\n\n    Returns\n    -------\n    float\n        検出力 (0から1の間の値)\n\n    Examples\n    --------\n    &gt;&gt;&gt; power_fisher_exact(0.5, 0.9, 20, 20)\n    0.7123  # 解析的に計算された検出力\n\n    &gt;&gt;&gt; power_fisher_exact(0.5, 0.9, 100, 100, multi=True)\n    0.9999  # マルチプロセスで高速化\n\n    Notes\n    -----\n    - シミュレーションと異なり、正確な値を返します\n    - 計算量は O(n1 * n2) であり、大きなサンプルサイズでも高速です\n    - multi=Trueにすると複数CPUコアを使用して高速化できます\n\n    References\n    ----------\n    - Mainland, D. and Sutcliffe, M.I. (1953). Statistical methods in\n      medical research. Canadian Journal of Medical Sciences, 31, 406-416.\n    - Thomas, R.G. and Conlon, M. (1991). Algorithm AS 259: Statistical\n      Algorithms. Applied Statistics, 40(1), 258-261.\n    \"\"\"\n    # 入力値の検証\n    if not (0 &lt; p1 &lt; 1):\n        raise ValueError(f\"p1は0より大きく1より小さい値である必要があります: {p1}\")\n    if not (0 &lt; p2 &lt; 1):\n        raise ValueError(f\"p2は0より大きく1より小さい値である必要があります: {p2}\")\n    if n1 &lt;= 0:\n        raise ValueError(f\"n1は正の整数である必要があります: {n1}\")\n    if n2 &lt;= 0:\n        raise ValueError(f\"n2は正の整数である必要があります: {n2}\")\n    if not (0 &lt; alpha &lt; 1):\n        raise ValueError(f\"alphaは0より大きく1より小さい値である必要があります: {alpha}\")\n    if alternative not in [\"two-sided\", \"greater\", \"less\"]:\n        raise ValueError(\n            f\"alternativeは 'two-sided', 'greater', 'less' のいずれかである必要があります: {alternative}\"\n        )\n\n    n = n1 + n2  # 総サンプルサイズ\n    M_values = list(range(n + 1))\n\n    # --- single process ---\n    if not multi:\n        return _power_contribution(\n            M_values, n1, n2, p1, p2, alpha, alternative\n        )\n\n    # --- multi process ---\n    if n_workers is None:\n        n_workers = cpu_count()\n\n    chunks = [M_values[i::n_workers] for i in range(n_workers)]\n    args = [\n        (chunk, n1, n2, p1, p2, alpha, alternative)\n        for chunk in chunks\n        if chunk\n    ]\n\n    with Pool(n_workers) as pool:\n        results = pool.starmap(_power_contribution, args)\n\n    return sum(results)\n\n\n\nExample 2 (Power Analysis 動作の確認) \n冒頭のECMO vs CMTの例を用いて，power_fisher_exact 関数の動作を確認します．\n観測データは以下の通りです：\n\n\n\nTreatment\nDie\nLive\ntotal\n\n\n\n\nECMO\n1\n28\n29\n\n\nCMT\n4\n6\n10\n\n\ntotal\n5\n34\n39\n\n\n\n観測された死亡率は ECMO群で \\(\\hat{p}_1 = 1/29 \\approx 0.034\\)，CMT群で \\(\\hat{p}_2 = 4/10 = 0.4\\)．\nこの効果量（\\(p_1 = 0.034, p_2 = 0.4\\)）を真の値と仮定した場合，サンプルサイズ \\((n_1, n_2) = (29, 10)\\) でどの程度の検出力が得られるかを計算します．\n\n# 観測された効果量\np1_observed = 1 / 29  # ECMO群の死亡率\np2_observed = 4 / 10  # CMT群の死亡率\n\n# 実際のサンプルサイズ\nn1, n2 = 29, 10\n\n# 検出力を計算（片側検定：ECMOの方が死亡率が低い）\npower_less = power_fisher_exact(\n    p1=p1_observed,\n    p2=p2_observed,\n    n1=n1,\n    n2=n2,\n    alpha=0.05,\n    alternative=\"less\"\n)\n\n# 両側検定の検出力\npower_two_sided = power_fisher_exact(\n    p1=p1_observed,\n    p2=p2_observed,\n    n1=n1,\n    n2=n2,\n    alpha=0.05,\n    alternative=\"two-sided\"\n)\n\nprint(f\"観測された効果量: p1={p1_observed:.4f}, p2={p2_observed:.4f}\")\nprint(f\"サンプルサイズ: n1={n1}, n2={n2}\")\nprint(f\"\\n検出力 (α=0.05):\")\nprint(f\"  片側検定 (less): {power_less:.4f}\")\nprint(f\"  両側検定: {power_two_sided:.4f}\")\n\n観測された効果量: p1=0.0345, p2=0.4000\nサンプルサイズ: n1=29, n2=10\n\n検出力 (α=0.05):\n  片側検定 (less): 0.7560\n  両側検定: 0.7560"
  },
  {
    "objectID": "posts/2025-12-19-fishers-exact-test/index.html#appendix-超幾何分布",
    "href": "posts/2025-12-19-fishers-exact-test/index.html#appendix-超幾何分布",
    "title": "Fisher’s Exact Test",
    "section": "Appendix: 超幾何分布",
    "text": "Appendix: 超幾何分布\n\nDefinition 1 Hypergeometric Distribution\n\n\\(M\\): ツボの中の赤いボールの個数\n\\(B(= N - M)\\): ツボの中の青いボールの個数\n\\(N\\): ツボの中のボールの個数\n\n上記のセットアップにおいて，ツボから \\(K (\\leq N)\\) 個のボールを無作為に非復元抽出(sampling without replacement)したところ， 抽出できた赤いボールの個数を表す確率変数を \\(X\\) とする．このとき，PMFは\n\\[\n\\displaylines P(X= x | N, M, K) = \\frac{\\left(\\begin{array}{c}M\\\\ x\\end{array}\\right)\\left(\\begin{array}{c}N - M\\\\ K-x\\end{array}\\right)}{\\left(\\begin{array}{c}N\\\\ K\\end{array}\\right)}\n\\]\nで与えられる。ただし，\n\\[\n\\max(0, K - (N - M)) \\le x \\le \\min(M, K)\n\\]\nであり，それ以外の場合は\n\\[\nP(X = x \\mid N, M, K) = 0\n\\]\nと定義する．\n\n確率の公理\n上記のPMFが確率の公理 \\(\\sum P(X= x | N, M, K) = 1\\) を満たすことを確認します．定義より示すべきは\n\\[\n\\left(\\begin{array}{c}N\\\\ K\\end{array}\\right) = \\sum \\left(\\begin{array}{c}M\\\\ x\\end{array}\\right)\\left(\\begin{array}{c}N - M\\\\ K-x\\end{array}\\right)\n\\]\nです．ヴァンデルモンドの畳み込みで明らかですが，ここでは組み合わせ的に考えてみます． 上記の式のLHSは赤と青を合わせた \\(N\\) 個のボールから \\(K\\) 個のボールを選ぶ組み合わせとなります． これは赤のボールの組み合わせをまず選び，その後青のボールの組み合わせを計算するという場合の数に相当します．つまり，\n\nまず赤いボール \\(M\\) 個の中から \\(x\\) 個を選ぶ\n次に残りの \\(K - x\\) 個を，青いボール \\(N−R\\) 個の中から選ぶ\n赤いボールを \\(x\\) 個選ぶすべての場合について和を取る\n\nつまり，\n\\[\n\\sum \\left(\\begin{array}{c}M\\\\ x\\end{array}\\right)\\left(\\begin{array}{c}N - M\\\\ K-x\\end{array}\\right)\n\\]\nこれはRHSに相当するので, \\(\\sum P(X= x | N, M, K) = 1\\) を満たすことがわかる．\n\nExample 3 (赤ボールを \\(x\\) drawする確率) \n赤玉を \\(X\\) 引く状況を \\(2 \\times 2\\) tableで整理したものが以下となります\n\n\n\n\nRed\nBlue\ntotal\n\n\n\n\nDrawn\n\\(X\\)\n\\(K - X\\)\n\\(K\\)\n\n\nNot Drawn\n\\(M-X\\)\n\\(B-(K-X)\\)\n\\(M+B-K\\)\n\n\ntotal\n\\(M\\)\n\\(B\\)\n\\(N = R+B\\)\n\n\n\nこのとき，\\(X = x\\) となる確率は\n\\[\n\\displaylines P(X= x | N, M, K) = \\frac{\\left(\\begin{array}{c}M\\\\ x\\end{array}\\right)\\left(\\begin{array}{c}N - M\\\\ K-x\\end{array}\\right)}{\\left(\\begin{array}{c}N\\\\ K\\end{array}\\right)}\n\\]\n\n\nCode\nimport numpy as np\nfrom plotly.subplots import make_subplots\nimport plotly.graph_objects as go\nfrom scipy.stats import hypergeom\n\n# パラメータ設定\nN = 50  # 全ボール数\nR = 20  # 赤ボール数\nK_values = [15, 31]  # 抽出数\n\nfig = make_subplots(rows=1, cols=2, subplot_titles=[f'K={K}' for K in K_values], vertical_spacing=0.15)\n\nfor i, K in enumerate(K_values):\n    # x の範囲\n    x_min = max(0, K - (N - R))\n    x_max = min(R, K)\n    x = np.arange(x_min, x_max + 1)\n\n    # PMF の計算\n    pmf = hypergeom.pmf(x, N, R, K)\n\n    fig.add_trace(\n        go.Bar(x=x, y=pmf, name=f'K={K}', opacity=0.7),\n        row=1, col=i+1\n    )\n\nfig.update_layout(\n    title_text=f'Hypergeometric Distribution PMF (N={N}, R={R})',\n    title_font_size=18,\n    title_y=0.98,\n    margin=dict(t=60),\n    showlegend=False,\n    font=dict(size=14)\n)\n\n# サブプロットタイトルのフォントサイズを大きく\nfor annotation in fig['layout']['annotations']:\n    annotation['font'] = dict(size=16)\nfig.update_xaxes(title_text='x (Drawn red ball)', title_font_size=14)\nfig.update_yaxes(title_text='P(X = x)', col=1, title_font_size=14)\n\nfig.show()"
  },
  {
    "objectID": "posts/2025-12-19-fishers-exact-test/index.html#references",
    "href": "posts/2025-12-19-fishers-exact-test/index.html#references",
    "title": "Fisher’s Exact Test",
    "section": "References",
    "text": "References\n\nscipy &gt; Fisher’s exact test"
  },
  {
    "objectID": "posts/2025-12-19-fishers-exact-test/index.html#footnotes",
    "href": "posts/2025-12-19-fishers-exact-test/index.html#footnotes",
    "title": "Fisher’s Exact Test",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nExample 10.4.1 on p.412 in Statistics for the Life Sciences (5ed) by Samuels, Witmer, and Schaffner. Original study by O’Rourke et al. Pediatrics. 1989 Dec;84(6):957-63. PMID: 2685740. See also Ware, J. H. (1989). “Investigating Therapies of Potentially Great Benefit: ECMO”. Statistical Science, 4(4), 298–306. http://www.jstor.org/stable/2245829↩︎"
  },
  {
    "objectID": "posts/2024-12-17-firefox-proxy-access/index.html",
    "href": "posts/2024-12-17-firefox-proxy-access/index.html",
    "title": "Firefoxを用いたsocks5 proxyブラウザアクセス設定",
    "section": "",
    "text": "アクセス元のglobal IPが制限されたサイト(例: 社内用gitlabサーバー)へアクセスする場合，\n\n許可されたglobal IPに属するプライベートIPネットワークに接続している端末からアクセス\n別端末から上記の端末へssh接続し，プロキシサーバー的に使用をする\n\nという2つの方法が考えられます．後者の方法をFirefoxを用いて設定する方法を紹介します．\n ▶  なぜFirefoxなのか？\n\nGoogle chromeでもproxy設定は可能ですが，OS側の設定を変更してしまう\nFirefoxはブラウザレベルでproxyの設定が可能"
  },
  {
    "objectID": "posts/2024-12-17-firefox-proxy-access/index.html#what-we-want-to-do",
    "href": "posts/2024-12-17-firefox-proxy-access/index.html#what-we-want-to-do",
    "title": "Firefoxを用いたsocks5 proxyブラウザアクセス設定",
    "section": "",
    "text": "アクセス元のglobal IPが制限されたサイト(例: 社内用gitlabサーバー)へアクセスする場合，\n\n許可されたglobal IPに属するプライベートIPネットワークに接続している端末からアクセス\n別端末から上記の端末へssh接続し，プロキシサーバー的に使用をする\n\nという2つの方法が考えられます．後者の方法をFirefoxを用いて設定する方法を紹介します．\n ▶  なぜFirefoxなのか？\n\nGoogle chromeでもproxy設定は可能ですが，OS側の設定を変更してしまう\nFirefoxはブラウザレベルでproxyの設定が可能"
  },
  {
    "objectID": "posts/2024-12-17-firefox-proxy-access/index.html#firefoxにおけるsocks5-proxy設定",
    "href": "posts/2024-12-17-firefox-proxy-access/index.html#firefoxにおけるsocks5-proxy設定",
    "title": "Firefoxを用いたsocks5 proxyブラウザアクセス設定",
    "section": "Firefoxにおけるsocks5 proxy設定",
    "text": "Firefoxにおけるsocks5 proxy設定\n\nFirefoxを開いて、右上のメニューボタン（三本線）をクリック\nメニューから「設定」を選択\nネットワーク設定を開く\n「手動でプロキシ設定をする」オプションを選択\n「SOCKS v5」を選択し，SOCKSホストを127.0.0.1，ポートを1080で設定\n変更を保存\n\n\n\n\nfirefox-proxy-setting\n\n\n\nHow to use\nLinux, Windows, MacOS問わず\nssh &lt;username&gt;@&lt;proxy-server&gt; -D 1080\nとまず，ssh接続を確立します．-D オプションはダイナミックポートフォワーディング (Dynamic Port Forwarding)の設定です． 上記を実行するとローカルの 1080番ポート にSOCKS5プロキシが立ち上がります．\nFirefoxで SOCKS5プロキシ 127.0.0.1:1080と設定すると，\n\n\n\n\n\nsequenceDiagram\n    participant Client as クライアント\n    participant LocalSOCKS as localhost:1080 (SOCKSプロキシ)\n    participant SSHTunnel as SSHトンネル\n    participant RemoteServer as リモートサーバー\n    participant ExternalServer as 外部サーバー\n\n    %% 1. クライアントがSOCKSプロキシに接続\n    Client-&gt;&gt;LocalSOCKS: データ送信 (接続要求, 宛先IP/ポート)\n\n    %% 2. SOCKSプロキシがSSHトンネル経由でリモートサーバーに転送\n    LocalSOCKS-&gt;&gt;SSHTunnel: データ転送 (暗号化)\n\n    %% 3. SSHトンネルがリモートサーバーに転送\n    SSHTunnel-&gt;&gt;RemoteServer: データ中継 (トンネル経由)\n\n    %% 4. リモートサーバーが外部サーバーに接続\n    RemoteServer-&gt;&gt;ExternalServer: 外部サーバー接続要求 (TCP/UDP)\n    ExternalServer--&gt;&gt;RemoteServer: 接続応答\n\n    %% 5. 応答をクライアントに返送\n    RemoteServer--&gt;&gt;SSHTunnel: 応答データ\n    SSHTunnel--&gt;&gt;LocalSOCKS: 暗号化データ戻し\n    LocalSOCKS--&gt;&gt;Client: レスポンス転送\n\n\n\n\n\n\n\nという順序で通信されるようになります．"
  },
  {
    "objectID": "posts/2024-12-17-firefox-proxy-access/index.html#appendix-プロキシサーバーの仕組み",
    "href": "posts/2024-12-17-firefox-proxy-access/index.html#appendix-プロキシサーバーの仕組み",
    "title": "Firefoxを用いたsocks5 proxyブラウザアクセス設定",
    "section": "Appendix: プロキシサーバーの仕組み",
    "text": "Appendix: プロキシサーバーの仕組み\nクライアントの依頼に応じて，外部のサーバーにサービスを要求し，その結果をクライアントに提供するサーバーをプロキシサーバーといいます． SOCKS5は，プロキシサーバーを利用してサーバーとクライアント間のパケットをルーティングするインターネットプロトコルのことを指します．\nSOCKS5プロキシサーバーのメリットとして，安全性，匿名性，利便性の3つがあります．\n ▶  安全性\n\nSOCKS5は，ユーザー名とパスワードによる認証機能をサポートしているため，外部の不正アクセスや認証されていないクライアントからの利用を防ぐことができる\nSSHトンネルと組み合わせることで，安全にSOCKS5プロキシサーバー経由の通信を暗号化することができる = リモートアクセス時のデータ転送が保護され，悪意のあるネットワーク環境でも安全に通信可能\nプロキシサーバーを中間地点として使用することで，DDoS攻撃などの直接的な大量トラフィック攻撃を遮断することが可能\n\n ▶  匿名性\n\nネットワーク全体のトラフィックがプロキシサーバー経由で処理されるため，外部から見えるIPアドレスが プロキシのIPになる = SOCKS5プロキシを介することで，クライアントのIPアドレス/端末名を隠すことができる\n一括でアクセス元をプロキシのIPに集約し，クライアントIPを隠蔽することでセキュリティとプライバシー保護が可能になるという活用方法がある\n\nSOCKS5プロキシは，クライアントから送信されたデータをそのまま中継しますが，データ送信時のヘッダ情報（IPアドレスなど）をカプセル化します． そのため，外部サーバーはデータの中身だけを認識し，送信元（クライアント）に関する情報は知ることができないという仕組みになっています．\n ▶  利便性\n\nSOCKS5はプロトコル非依存であり，TCPとUDPの両方の通信をサポートしている = FTP, SMTP, P2P, VoIP, DNSリクエスト, オンラインゲームなど多様なアプリケーションで利用可能\n\n\n\n\n\n\nsequenceDiagram\n    participant Client as クライアント\n    participant SOCKS5ProxyServer as SOCKS5プロキシサーバー\n    participant ExternalServer as 外部サーバー\n\n    %% 1. 接続要求とハンドシェイク\n    Client-&gt;&gt;SOCKS5ProxyServer: 接続要求 (Handshake: バージョン, 認証方式)\n    SOCKS5ProxyServer--&gt;&gt;Client: 認証方式応答 (成功/失敗)\n\n    %% 2. 外部サーバーへの接続要求\n    Client-&gt;&gt;SOCKS5ProxyServer: 外部サーバー接続要求 (宛先IP, ポート)\n    note right of Client: クライアントのIPアドレスは隠蔽される\n    SOCKS5ProxyServer-&gt;&gt;ExternalServer: 接続確立要求 (プロキシのIPを使用)\n\n    %% 3. 接続確立確認\n    ExternalServer--&gt;&gt;SOCKS5ProxyServer: 接続成功応答\n    SOCKS5ProxyServer--&gt;&gt;Client: 接続確立成功通知\n\n    %% 4. データ転送 (カプセル化)\n    Client-&gt;&gt;SOCKS5ProxyServer: データ送信 (カプセル化されたパケット)\n    note over SOCKS5ProxyServer: データをそのまま中継 (IPアドレス非公開)\n    SOCKS5ProxyServer-&gt;&gt;ExternalServer: データ転送 (TCP/UDP)\n    ExternalServer--&gt;&gt;SOCKS5ProxyServer: レスポンスデータ\n    SOCKS5ProxyServer--&gt;&gt;Client: レスポンス転送\n\n    %% 5. 通信終了\n    Client-&gt;&gt;SOCKS5ProxyServer: 通信終了リクエスト\n    SOCKS5ProxyServer-&gt;&gt;ExternalServer: 接続切断\n    SOCKS5ProxyServer--&gt;&gt;Client: 通信終了通知\n\n\n\n\n\n\n\nSOCKS5プロキシはキャッシュを行わない\nHTTPプロキシは一般的に，ウェブコンテンツ（画像、HTML、動画など）をキャッシュすることで，再アクセス時にデータ転送を高速化します． 一方，SOCKS5プロキシはキャッシュを行なわないという違いがあります．\n\nSOCKS5はデータ転送のトンネルを作る役割を果たすため，通信内容のデータを確認・保存することがない\nあくまで「データを中継する」プロトコルであり，内容に依存しないため，キャッシュ機能は持たない\n\nSOCKS5はキャッシュ機能を持たないことで，シンプルかつ高速な通信環境を提供してくれるものと理解していればOKだとおもいます． キャッシュはリアルタイム通信に不要ですし，また，キャッシュ管理の手間やストレージコストが不要というメリットもあります．"
  },
  {
    "objectID": "posts/2024-12-07-meta-address/index.html",
    "href": "posts/2024-12-07-meta-address/index.html",
    "title": "IPアドレス 0.0.0.0",
    "section": "",
    "text": "pythonでhttp serverを立てて，Quartoで作成したウェブサイトを以下のコマンドで公開するとします\n% python -m http.server 3000 --directory ./_site/\nServing HTTP on 0.0.0.0 port 3000 (http://0.0.0.0:3000/) ..\nバインド先を設定せずにserverを立ち上げたところ，0.0.0.0 で立ち上げているようです． このとき，Firewallの3000 portをホスト側でAllowすると，同じnetworkの他の端末(例:iPad)からでもアクセスできるようになりました．\n ▶  プライベートIPアドレスをバインド先に指定した場合 \n自宅内のネットワークのみで有効なプライベートIPアドレス（クラスC 192.168.0.0 ~ 192.168.255.255）を指定してhttp serverを立たてみます．\n% python -m http.server 3000 --directory ./_site/ --bind 192.168.10.105\nServing HTTP on 192.168.10.105 port 3000 (http://192.168.10.105:3000/) ...\nこのとき，同じネットワーク内にあるiPadからアクセスできるようになりました． iPad側では http://192.168.10.105:3000 に接続することでQuarto contentsにアクセスできるようになりましたが， このiPad側での操作は 0.0.0.0 で立ち上げたときと同じ操作となります．\n\n❓ Question \npython http.server を使用して 0.0.0.0 にバインドしてhttp serverを立てたときの挙動がプライベートネットワーク内部で割り当てられたプライベートIPアドレスを指定したときと同じ挙動をするのか？\n\n\n\nIPv4において 0.0.0.0 (IPv6では::/0) はSepcial-Purpose Address Registry，つまり特別な目的用に予約されたアドレスです．\n\nRFC6890\n\n\n\n\n\n\nAttribute\nValue\n\n\n\n\nAddress Block\n0.0.0.0/8\n\n\nName\nThis host on this network\n\n\nRFC\n[RFC1122], Section 3.2.1.3\n\n\nAllocation Date\nSeptember 1981\n\n\nTermination Date\nN/A\n\n\nSource\nTrue\n\n\nDestination\nFalse\n\n\nForwardable\nFalse\n\n\nGlobal\nFalse\n\n\nReserved-by-Protocol\nTrue\n\n\n\n上記より0.0.0.0 ~ 0.255.255.255について以下の情報を得ることができます\n\nGlobalセクションがFalseとなっていることから，グローバルIPアドレスとして使用できない．利用はローカルネットワークに限定される\nSourceセクションTrueより，送信元アドレスとして有効\nDestinationセクションFalseより，宛先アドレスとして使用できない = ルーティング不可\n\nただし，0.0.0.0の具体的な意味はここからではまだわかりません．\n ▶  0.0.0.0/0 vs 0.0.0.0/32 \n\n\n\n\n\n\n\n\nAttribute\n0.0.0.0/0\n0.0.0.0/32\n\n\n\n\nSubnet Mask\n0.0.0.0 (all bits variable)\n255.255.255.255 (all bits fixed)\n\n\nRange\nAll IPv4 addresses (0.0.0.0 to 255.255.255.255)\n0.0.0.0\n\n\n\n\n\n\nバインド先を指定しないでhttp serverを立てるとき，バインド先を指定しない = 有効な宛先がないことを意味します． このとき使用されるのが 0.0.0.0 です．\nこの文脈での 0.0.0.0 は catch-all wildcard と呼ばれるもので，同じネットワーク上のすべてのインターフェースに対して， バインドするという特別な意味を持っています．コンピューターが複数のネットワークに接続していて，すべてのネットワークにバインドしたい場合に 0.0.0.0を指定します．ただし，不必要に使用してしまうと誤って外部のネットワークに共有してしまったりするので使用は控えたほうが良いです．\n\n📘 REMARKS \n\nPython HTTP Serverにおける 0.0.0.0 はルーティングにおけるデフォルトルートとしての0.0.0.0は異なります\n文脈に応じて 0.0.0.0 が指す内容が異なることに注意してください\npython hhtp.serverの文脈では0.0.0.0にバインドすると以下のインターフェースからアクセス可能となります\n\nLocalhost (127.0.0.1)\nThe private network (例: 192.168.x.x)\nPublic network interfaces (Firewallでアクセスを許容していた場合)\n\n\n\nPython http serverをprivate networkに限定する意図を込めて，以下のスクリプトでホスティングすることが望ましいです\n$ python3 -m http.server -b &lt;your-local-private-network IP&gt; 8080 --directory ./_site/"
  },
  {
    "objectID": "posts/2024-12-07-meta-address/index.html#ipアドレス-0.0.0.0にバインド",
    "href": "posts/2024-12-07-meta-address/index.html#ipアドレス-0.0.0.0にバインド",
    "title": "IPアドレス 0.0.0.0",
    "section": "",
    "text": "pythonでhttp serverを立てて，Quartoで作成したウェブサイトを以下のコマンドで公開するとします\n% python -m http.server 3000 --directory ./_site/\nServing HTTP on 0.0.0.0 port 3000 (http://0.0.0.0:3000/) ..\nバインド先を設定せずにserverを立ち上げたところ，0.0.0.0 で立ち上げているようです． このとき，Firewallの3000 portをホスト側でAllowすると，同じnetworkの他の端末(例:iPad)からでもアクセスできるようになりました．\n ▶  プライベートIPアドレスをバインド先に指定した場合 \n自宅内のネットワークのみで有効なプライベートIPアドレス（クラスC 192.168.0.0 ~ 192.168.255.255）を指定してhttp serverを立たてみます．\n% python -m http.server 3000 --directory ./_site/ --bind 192.168.10.105\nServing HTTP on 192.168.10.105 port 3000 (http://192.168.10.105:3000/) ...\nこのとき，同じネットワーク内にあるiPadからアクセスできるようになりました． iPad側では http://192.168.10.105:3000 に接続することでQuarto contentsにアクセスできるようになりましたが， このiPad側での操作は 0.0.0.0 で立ち上げたときと同じ操作となります．\n\n❓ Question \npython http.server を使用して 0.0.0.0 にバインドしてhttp serverを立てたときの挙動がプライベートネットワーク内部で割り当てられたプライベートIPアドレスを指定したときと同じ挙動をするのか？\n\n\n\nIPv4において 0.0.0.0 (IPv6では::/0) はSepcial-Purpose Address Registry，つまり特別な目的用に予約されたアドレスです．\n\nRFC6890\n\n\n\n\n\n\nAttribute\nValue\n\n\n\n\nAddress Block\n0.0.0.0/8\n\n\nName\nThis host on this network\n\n\nRFC\n[RFC1122], Section 3.2.1.3\n\n\nAllocation Date\nSeptember 1981\n\n\nTermination Date\nN/A\n\n\nSource\nTrue\n\n\nDestination\nFalse\n\n\nForwardable\nFalse\n\n\nGlobal\nFalse\n\n\nReserved-by-Protocol\nTrue\n\n\n\n上記より0.0.0.0 ~ 0.255.255.255について以下の情報を得ることができます\n\nGlobalセクションがFalseとなっていることから，グローバルIPアドレスとして使用できない．利用はローカルネットワークに限定される\nSourceセクションTrueより，送信元アドレスとして有効\nDestinationセクションFalseより，宛先アドレスとして使用できない = ルーティング不可\n\nただし，0.0.0.0の具体的な意味はここからではまだわかりません．\n ▶  0.0.0.0/0 vs 0.0.0.0/32 \n\n\n\n\n\n\n\n\nAttribute\n0.0.0.0/0\n0.0.0.0/32\n\n\n\n\nSubnet Mask\n0.0.0.0 (all bits variable)\n255.255.255.255 (all bits fixed)\n\n\nRange\nAll IPv4 addresses (0.0.0.0 to 255.255.255.255)\n0.0.0.0\n\n\n\n\n\n\nバインド先を指定しないでhttp serverを立てるとき，バインド先を指定しない = 有効な宛先がないことを意味します． このとき使用されるのが 0.0.0.0 です．\nこの文脈での 0.0.0.0 は catch-all wildcard と呼ばれるもので，同じネットワーク上のすべてのインターフェースに対して， バインドするという特別な意味を持っています．コンピューターが複数のネットワークに接続していて，すべてのネットワークにバインドしたい場合に 0.0.0.0を指定します．ただし，不必要に使用してしまうと誤って外部のネットワークに共有してしまったりするので使用は控えたほうが良いです．\n\n📘 REMARKS \n\nPython HTTP Serverにおける 0.0.0.0 はルーティングにおけるデフォルトルートとしての0.0.0.0は異なります\n文脈に応じて 0.0.0.0 が指す内容が異なることに注意してください\npython hhtp.serverの文脈では0.0.0.0にバインドすると以下のインターフェースからアクセス可能となります\n\nLocalhost (127.0.0.1)\nThe private network (例: 192.168.x.x)\nPublic network interfaces (Firewallでアクセスを許容していた場合)\n\n\n\nPython http serverをprivate networkに限定する意図を込めて，以下のスクリプトでホスティングすることが望ましいです\n$ python3 -m http.server -b &lt;your-local-private-network IP&gt; 8080 --directory ./_site/"
  },
  {
    "objectID": "posts/2024-12-07-meta-address/index.html#appendix-プライベートアドレス",
    "href": "posts/2024-12-07-meta-address/index.html#appendix-プライベートアドレス",
    "title": "IPアドレス 0.0.0.0",
    "section": "Appendix: プライベートアドレス",
    "text": "Appendix: プライベートアドレス\n\nDefinition 1 プライベートアドレス\n\n社内や家庭内など，限られたネットワークの中だけで有効なIPアドレスのこと\n組織内で一意でない場合は，宛先を混同して正常に通信できないので各デバイスに一意に割り当てる必要がある\n\n\n\n\n\n\nClass\nIP Address Range\nCIDR\n\n\n\n\nClass A\n10.0.0.0 ~ 10.255.255.255\n10.0.0.0/8\n\n\nClass B\n172.16.0.0 ~ 172.31.255.255\n172.16.0.0/12\n\n\nClass C\n192.168.0.0 ~ 192.168.255.255\n192.168.0.0/16\n\n\n\n\nネットワーク部に着目すると，それぞれのクラスが大規模ネットワーク向け，中規模ネットワーク向け，小規模ネットワーク向けに対応していることがわかります．"
  },
  {
    "objectID": "posts/2024-12-07-meta-address/index.html#references",
    "href": "posts/2024-12-07-meta-address/index.html#references",
    "title": "IPアドレス 0.0.0.0",
    "section": "References",
    "text": "References\n\nRFC5735"
  },
  {
    "objectID": "posts/2025-02-19-make-lag-variable/index.html",
    "href": "posts/2025-02-19-make-lag-variable/index.html",
    "title": "Group毎に定義されたラグ変数の作成",
    "section": "",
    "text": "Exercise 1 \n次のようなpandas.DataFrameを考えます\n\n\nCode\nimport pandas as pd\nimport polars as pl\n\ndf = pd.DataFrame(\n    {\n        \"entity_col\": [\"A\", \"A\", \"A\", \"A\", \"A\", \"A\", \"B\", \"B\", \"B\", \"C\"],\n        \"state\": [1, 0, 1, 1, 1, 0, 0, 0, 0, 1],\n        \"time_col\": pd.to_datetime([\n            \"2021-01-02\",\n            \"2021-01-03\",\n            \"2021-01-04\",\n            \"2021-01-01\",\n            \"2021-01-03\",\n            \"2021-01-04\",\n            \"2021-02-02\",\n            \"2021-02-03\",\n            \"2021-02-10\",\n            \"2021-01-02\",\n        ]),\n        \"temp\": [1, 2, 11, 13, 12, 14, 10, 9, 8, 0],\n    }\n)\n\ndf\n\n\n\n\n\n\n\n\n\nentity_col\nstate\ntime_col\ntemp\n\n\n\n\n0\nA\n1\n2021-01-02\n1\n\n\n1\nA\n0\n2021-01-03\n2\n\n\n2\nA\n1\n2021-01-04\n11\n\n\n3\nA\n1\n2021-01-01\n13\n\n\n4\nA\n1\n2021-01-03\n12\n\n\n5\nA\n0\n2021-01-04\n14\n\n\n6\nB\n0\n2021-02-02\n10\n\n\n7\nB\n0\n2021-02-03\n9\n\n\n8\nB\n0\n2021-02-10\n8\n\n\n9\nC\n1\n2021-01-02\n0\n\n\n\n\n\n\n\n ▶  実施したい処理\n\n(entity_col, state)でGroup Keysとして，各Group内部で time_col の順番に応じて tempカラムについてラグ変数を作成したい\nラグ変数の名前は Defaultでは f\"{target_column}_1lag, 指定があった場合はそれに倣うとする"
  },
  {
    "objectID": "posts/2025-02-19-make-lag-variable/index.html#問題設定-ラグ変数の作成",
    "href": "posts/2025-02-19-make-lag-variable/index.html#問題設定-ラグ変数の作成",
    "title": "Group毎に定義されたラグ変数の作成",
    "section": "",
    "text": "Exercise 1 \n次のようなpandas.DataFrameを考えます\n\n\nCode\nimport pandas as pd\nimport polars as pl\n\ndf = pd.DataFrame(\n    {\n        \"entity_col\": [\"A\", \"A\", \"A\", \"A\", \"A\", \"A\", \"B\", \"B\", \"B\", \"C\"],\n        \"state\": [1, 0, 1, 1, 1, 0, 0, 0, 0, 1],\n        \"time_col\": pd.to_datetime([\n            \"2021-01-02\",\n            \"2021-01-03\",\n            \"2021-01-04\",\n            \"2021-01-01\",\n            \"2021-01-03\",\n            \"2021-01-04\",\n            \"2021-02-02\",\n            \"2021-02-03\",\n            \"2021-02-10\",\n            \"2021-01-02\",\n        ]),\n        \"temp\": [1, 2, 11, 13, 12, 14, 10, 9, 8, 0],\n    }\n)\n\ndf\n\n\n\n\n\n\n\n\n\nentity_col\nstate\ntime_col\ntemp\n\n\n\n\n0\nA\n1\n2021-01-02\n1\n\n\n1\nA\n0\n2021-01-03\n2\n\n\n2\nA\n1\n2021-01-04\n11\n\n\n3\nA\n1\n2021-01-01\n13\n\n\n4\nA\n1\n2021-01-03\n12\n\n\n5\nA\n0\n2021-01-04\n14\n\n\n6\nB\n0\n2021-02-02\n10\n\n\n7\nB\n0\n2021-02-03\n9\n\n\n8\nB\n0\n2021-02-10\n8\n\n\n9\nC\n1\n2021-01-02\n0\n\n\n\n\n\n\n\n ▶  実施したい処理\n\n(entity_col, state)でGroup Keysとして，各Group内部で time_col の順番に応じて tempカラムについてラグ変数を作成したい\nラグ変数の名前は Defaultでは f\"{target_column}_1lag, 指定があった場合はそれに倣うとする"
  },
  {
    "objectID": "posts/2025-02-19-make-lag-variable/index.html#前処理関数の実装",
    "href": "posts/2025-02-19-make-lag-variable/index.html#前処理関数の実装",
    "title": "Group毎に定義されたラグ変数の作成",
    "section": "前処理関数の実装",
    "text": "前処理関数の実装\n\n\n\n\n\n\nNoteSolution: generate_lag_variable_with_group_key\n\n\n\n\n\n\nfrom typing import Optional\n\n\ndef generate_lag_variable_with_group_key(\n    df: pd.DataFrame | pl.DataFrame,\n    target_column: str,\n    sort_key: list[str],\n    group_key: list[str],\n    lag_size: int,\n    ascending: list[bool] | bool = True,\n    lagged_col_name: Optional[str] = None,\n) -&gt; pd.DataFrame | pl.DataFrame:\n    \"\"\"\n    Generate a lagged variable in a DataFrame with a specified group key.\n\n    This function creates a new column in the DataFrame that contains\n    the lagged values of an existing column, grouped by specified keys.\n    It supports both pandas and polars DataFrames.\n\n    Parameters:\n        df (pd.DataFrame | pl.DataFrame):\n            The input DataFrame, either pandas or polars.\n\n        col (str):\n            The name of the column to generate the lagged variable from.\n\n        sort_key (list[str]):\n            The list of columns to sort the DataFrame by before generating the lagged variable.\n\n        group_key (list[str]):\n            The list of columns to group the DataFrame by before generating the lagged variable.\n\n        lag_size (int):\n            The number of periods to lag the variable.\n\n        ascending (list[bool] | bool, optional):\n            The sort order for each column in sort_key. Defaults to True.\n\n        lagged_col_name (Optional[str], optional):\n            The name of the new lagged column. If None, defaults to \"{col}_{lag_size}lag\".\n\n    Returns:\n        pd.DataFrame | pl.DataFrame: The DataFrame with the new lagged variable column.\n\n    Raises:\n        TypeError: If the input DataFrame is neither pandas.DataFrame nor polars.DataFrame.\n    \"\"\"\n\n    # set up common variables\n    if lagged_col_name is None:\n        lagged_col_name = f\"{target_column}_{lag_size}lag\"\n\n    result_sort_key = group_key + sort_key\n\n    if isinstance(df, pd.DataFrame):\n        # Sort the dataframe by the specified sort key\n        df_sorted = df.sort_values(by=sort_key, ascending=ascending)\n\n        # Generate the lagged variable\n        df_sorted[lagged_col_name] = df_sorted.groupby(group_key)[target_column].shift(\n            lag_size\n        )\n\n        # Sort the dataframe by the group key and sort key\n        result_sort_key = group_key + sort_key\n        df_result = df_sorted.sort_values(by=result_sort_key).reset_index(drop=True)\n\n    elif isinstance(df, pl.DataFrame):\n        if isinstance(ascending, list):\n            order_reverse = [not x for x in ascending]\n        else:\n            order_reverse = not ascending\n\n        df_sorted = df.sort(sort_key, descending=order_reverse)\n        df_sorted = df_sorted.with_columns(\n            pl.col(target_column)\n            .shift(lag_size)\n            .over(group_key)\n            .alias(lagged_col_name)\n        )\n        df_result = df_sorted.sort(result_sort_key)\n\n    else:\n        raise TypeError(\n            f\"type(df) is {type(df)}: df should be pandas.DataFrame or polars.DataFrame\"\n        )\n\n    return df_result\n\n\n\n\n\n挙動確認\n ▶  pandas.DataFrame\n\ngenerate_lag_variable_with_group_key(\n    df=df,\n    target_column=\"temp\",\n    sort_key=[\"time_col\"],\n    group_key=[\"entity_col\", \"state\"],\n    lag_size=1,\n    ascending= [True]\n)\n\n\n\n\n\n\n\n\nentity_col\nstate\ntime_col\ntemp\ntemp_1lag\n\n\n\n\n0\nA\n0\n2021-01-03\n2\nNaN\n\n\n1\nA\n0\n2021-01-04\n14\n2.0\n\n\n2\nA\n1\n2021-01-01\n13\nNaN\n\n\n3\nA\n1\n2021-01-02\n1\n13.0\n\n\n4\nA\n1\n2021-01-03\n12\n1.0\n\n\n5\nA\n1\n2021-01-04\n11\n12.0\n\n\n6\nB\n0\n2021-02-02\n10\nNaN\n\n\n7\nB\n0\n2021-02-03\n9\n10.0\n\n\n8\nB\n0\n2021-02-10\n8\n9.0\n\n\n9\nC\n1\n2021-01-02\n0\nNaN\n\n\n\n\n\n\n\n ▶  polars.DataFrame\n\ndf_polars = pl.DataFrame(df)\ngenerate_lag_variable_with_group_key(\n    df=df_polars,\n    target_column=\"temp\",\n    sort_key=[\"time_col\"],\n    group_key=[\"entity_col\", \"state\"],\n    lag_size=1,\n)\n\n\nshape: (10, 5)\n\n\n\nentity_col\nstate\ntime_col\ntemp\ntemp_1lag\n\n\nstr\ni64\ndatetime[ns]\ni64\ni64\n\n\n\n\n\"A\"\n0\n2021-01-03 00:00:00\n2\nnull\n\n\n\"A\"\n0\n2021-01-04 00:00:00\n14\n2\n\n\n\"A\"\n1\n2021-01-01 00:00:00\n13\nnull\n\n\n\"A\"\n1\n2021-01-02 00:00:00\n1\n13\n\n\n\"A\"\n1\n2021-01-03 00:00:00\n12\n1\n\n\n\"A\"\n1\n2021-01-04 00:00:00\n11\n12\n\n\n\"B\"\n0\n2021-02-02 00:00:00\n10\nnull\n\n\n\"B\"\n0\n2021-02-03 00:00:00\n9\n10\n\n\n\"B\"\n0\n2021-02-10 00:00:00\n8\n9\n\n\n\"C\"\n1\n2021-01-02 00:00:00\n0\nnull\n\n\n\n\n\n\n\n\nUnit test with pytest\n\n📘 テスト方針 \n\n異なるラグサイズ（lag size）の処理: ラグサイズの値を自由に指定できるか？\nカスタムラグカラム名の指定: ラグカラムに任意の名前を付けることができるか？。\nソート順の指定: 昇順（ascending=True）または降順（ascending=False）でソートできるか？\n不正な入力タイプのエラー処理: 入力値が不正な場合，適切なエラーメッセージを表示するか？\n\n\n ▶  Test Examples\n\nimport pytest\nimport pandas as pd\nimport polars as pl\nimport numpy as np\n\n# Import the function to be tested\n# from hogehoge import generate_lag_variable_with_group_key  # Replace with actual module name\n\n@pytest.fixture\ndef sample_pandas_df():\n    \"\"\"Fixture to provide a sample Pandas DataFrame\"\"\"\n    return pd.DataFrame({\n        \"entity\": [\"A\", \"A\", \"A\", \"B\", \"B\", \"B\"],\n        \"time\": [\"2023-01-01\", \"2023-01-02\", \"2023-01-03\",\n                 \"2023-01-01\", \"2023-01-02\", \"2023-01-03\"],\n        \"value\": [10, 20, 30, 100, 200, 300]\n    }).assign(time=lambda df: pd.to_datetime(df[\"time\"]))  # Ensure datetime type\n\n@pytest.fixture\ndef sample_polars_df():\n    \"\"\"Fixture to provide a sample Polars DataFrame\"\"\"\n    return pl.DataFrame({\n        \"entity\": [\"A\", \"A\", \"A\", \"B\", \"B\", \"B\"],\n        \"time\": [\"2023-01-01\", \"2023-01-02\", \"2023-01-03\",\n                 \"2023-01-01\", \"2023-01-02\", \"2023-01-03\"],\n        \"value\": [10, 20, 30, 100, 200, 300]\n    }).with_columns(pl.col(\"time\").str.to_date())  # Ensure datetime type\n\n@pytest.mark.parametrize(\"df_type\", [\"pandas\", \"polars\"])\ndef test_generate_lag_variable_basic(df_type, sample_pandas_df, sample_polars_df):\n    \"\"\"Test basic functionality with Pandas and Polars\"\"\"\n    df = sample_pandas_df if df_type == \"pandas\" else sample_polars_df\n    result = generate_lag_variable_with_group_key(\n        df=df,\n        target_column=\"value\",\n        sort_key=[\"time\"],\n        group_key=[\"entity\"],\n        lag_size=1\n    )\n\n    assert \"value_1lag\" in result.columns, \"Lagged column not found!\"\n    expected_values_pandas = [np.nan, 10.0, 20.0, np.nan, 100.0, 200.0]  # Expected shifted values\n    expected_values_polars = [None, 10, 20, None, 100, 200]  # Expected shifted values\n    if df_type == \"pandas\":\n        assert np.array_equal(result[\"value_1lag\"].to_list(), expected_values_pandas, equal_nan=True)\n    else:\n        assert result[\"value_1lag\"].to_list() == expected_values_polars \n\ndef test_generate_lag_variable_custom_column(sample_pandas_df):\n    \"\"\"Test if custom column name works correctly\"\"\"\n    result = generate_lag_variable_with_group_key(\n        df=sample_pandas_df,\n        target_column=\"value\",\n        sort_key=[\"time\"],\n        group_key=[\"entity\"],\n        lag_size=1,\n        lagged_col_name=\"custom_lag\"\n    )\n    assert \"custom_lag\" in result.columns, \"Custom lag column name not applied!\"\n\ndef test_generate_lag_variable_with_descending_order(sample_pandas_df):\n    \"\"\"Test sorting order with descending time\"\"\"\n    result = generate_lag_variable_with_group_key(\n        df=sample_pandas_df,\n        target_column=\"value\",\n        sort_key=[\"time\"],\n        group_key=[\"entity\"],\n        lag_size=1,\n        ascending=False  # Reverse sorting order\n    )\n    expected_values = [20.0, 30.0, np.nan, 200.0, 300.0, np.nan]  # Because order is reversed\n    assert np.array_equal(result[\"value_1lag\"].to_list(), expected_values, equal_nan=True)\n\ndef test_generate_lag_variable_invalid_input():\n    \"\"\"Test function raises TypeError for invalid input\"\"\"\n    with pytest.raises(TypeError):\n        generate_lag_variable_with_group_key(\n            df=\"not_a_dataframe\",  # Invalid type\n            target_column=\"value\",\n            sort_key=[\"time\"],\n            group_key=[\"entity\"],\n            lag_size=1\n        )\n\n\n注意点 ! \n\nnp.nan != np.nan であるため，np.nanを含むリストを比較する場合，== を直接使用しても正しく機能しません\nNaN は未定義値であるため，NaN は自身と等しくない"
  },
  {
    "objectID": "posts/2025-08-02-PYTHONSTARTUP/index.html",
    "href": "posts/2025-08-02-PYTHONSTARTUP/index.html",
    "title": "環境変数 PYTHONSTARTUP の目的",
    "section": "",
    "text": "Definition 1 PYTHONSTARTUP\n\nPYTHONSTARTUP はインタラクティブモードのPythonを起動する直前に読み込むPythonスクリプトのPATHを示す環境変数\nインタラクティブモードPythonのための設定なので，通常は .zshrc / .bashrc で定義\n\n\n設定内容例\n\nインタラクティブモードのコマンド履歴格納ファイル .python_history のPATH設定\n起動時に .python_history に書き込むラインの設定(例: 起動時刻を履歴ファイルに書き込む)\n起動時に自動的に読み込むモジュールの設定(例: 常に import numpy as np を実行する)"
  },
  {
    "objectID": "posts/2025-08-02-PYTHONSTARTUP/index.html#シェル環境変数としての-pythonstartup",
    "href": "posts/2025-08-02-PYTHONSTARTUP/index.html#シェル環境変数としての-pythonstartup",
    "title": "環境変数 PYTHONSTARTUP の目的",
    "section": "",
    "text": "Definition 1 PYTHONSTARTUP\n\nPYTHONSTARTUP はインタラクティブモードのPythonを起動する直前に読み込むPythonスクリプトのPATHを示す環境変数\nインタラクティブモードPythonのための設定なので，通常は .zshrc / .bashrc で定義\n\n\n設定内容例\n\nインタラクティブモードのコマンド履歴格納ファイル .python_history のPATH設定\n起動時に .python_history に書き込むラインの設定(例: 起動時刻を履歴ファイルに書き込む)\n起動時に自動的に読み込むモジュールの設定(例: 常に import numpy as np を実行する)"
  },
  {
    "objectID": "posts/2025-08-02-PYTHONSTARTUP/index.html#個人用設定",
    "href": "posts/2025-08-02-PYTHONSTARTUP/index.html#個人用設定",
    "title": "環境変数 PYTHONSTARTUP の目的",
    "section": "個人用設定",
    "text": "個人用設定\n方針\n\nセッション開始から終了までのコマンド履歴を格納する履歴ファイルの設定\nセッション開始時にタイムスタンプ付きのヘッダーを履歴ファイルに追加\nデフォルトで最大 10,000 行の履歴を履歴ファイルに保存\n\n実装コード\n\n\n\n\n\n\n\n\nモジュール\n機能\n\n\n\n\nimport atexit\nプログラム終了時に特定の処理（ここでは履歴保存）を自動実行するためのモジュール\n\n\nimport readline\nPython の インタラクティブシェルで履歴や補完を扱うライブラリ\n\n\nimport os\nファイルパス操作やディレクトリ作成など，OS 関連の処理に使用\n\n\n\n\n#!/usr/bin/env python3\n\nimport atexit\nimport readline\nimport os\nfrom datetime import datetime\n\n# ==== create session header ====\ndate = datetime.now()\nsession_header = date.strftime(\"### Python session started on %Y-%m-%d %H:%M:%S ###\")\n\n# ==== save history file as ~/.cache/.python_history ====\nhistdir = os.path.expanduser(\"~/.cache/python\")\nos.makedirs(histdir, exist_ok=True)\nhistfile = os.path.join(histdir, \".python_history\")\n\n# ==== append session header to history file ====\nwith open(histfile, \"a\") as f:\n    f.write(f\"\\n{session_header}\\n\")\n\n\ntry:\n    readline.read_history_file(histfile)\n    readline.set_history_length(10000)\nexcept FileNotFoundError:\n    pass\n\n# ==== register history saving function ====\natexit.register(readline.write_history_file, histfile)\nシェル設定\n~/.zshrc または ~/.bashrcに PYTHONSTARTUP を追加:\nexport PYTHONSTARTUP=$HOME/.config/python/pythonstartup.py\n\nコードの説明\n履歴ファイルの保存場所設定\n# ==== save history file as ~/.cache/.python_history ====\nhistdir = os.path.expanduser(\"~/.cache/python\")\nos.makedirs(histdir, exist_ok=True)\nhistfile = os.path.join(histdir, \".python_history\")\n~ はPythonのファイル操作では~という文字として認識してしまい，/home/&lt;username&gt; と解釈してくれません． os.path.expanduser を用いることで，クロスプラットフォーム対応ができる形で意図したPATH展開をしてくれます\nセッションヘッダーを履歴ファイルに追記\n# ==== append session header to history file ====\nwith open(histfile, \"a\") as f:\n    f.write(f\"\\n{session_header}\\n\")\n\n\n\n\n\n\n\n\n\nモード\n説明\n影響\n\n\n\n\n\"w\"\n書き込みモード．ファイルを 開いた時点で既存の内容を削除\n履歴ファイルが完全に上書きされる．以前のコマンドもセッションヘッダーも消える\n\n\n\"a\"\n追記モード．既存の内容は残して末尾に書き込む\n以前の履歴は保持される．新しいセッションヘッダーも追加される\n\n\n\n\n履歴ファイルを読み込む\ntry:\n    readline.read_history_file(histfile)\n    readline.set_history_length(10000)\nexcept FileNotFoundError:\n    pass\n\n\n\n\n\n\n\n\nコード\n説明\n\n\n\n\nreadline.read_history_file(histfile)\n既存の履歴ファイルを読み込むことで，前回までのコマンドが ↑↓キーで呼び出せるようになる．\n\n\nreadline.set_history_length(10000)\n履歴の最大行数を 10,000行 に設定．古い履歴から順に削除される．\n\n\ntry ... except FileNotFoundError\n履歴ファイルが存在しない場合でもエラーを出さず，スクリプトを継続できるようにする．\n\n\n\n\nPython 終了時に履歴を保存\n# ==== register history saving function ====\natexit.register(readline.write_history_file, histfile)\n\n\n\n\n\n\n\n\nコード\n説明\n\n\n\n\natexit.register(...)\nPython が終了するときに自動で指定関数を呼び出す\n\n\nreadline.write_history_file(histfile)\n履セッション中に入力したコマンドを 履歴ファイルに書く．"
  },
  {
    "objectID": "posts/2025-12-15-statistical-inference/index.html",
    "href": "posts/2025-12-15-statistical-inference/index.html",
    "title": "中年男性の中性脂肪分布はLognormalで近似できるか？",
    "section": "",
    "text": "アメリカの中年男性（40-59歳）の血中中性脂肪（トリグリセリド）濃度は，Lognormal分布でどの程度近似できるか？\n\n\n\n血中脂質値は多くの場合，正規分布ではなく右に歪んだ分布を示します， 特に中性脂肪は，生活習慣や遺伝的要因により極端な高値を示す個人が存在するため，Lognormal分布での近似がしばしば用いられます． このノートでは，米国の代表的な健康調査データを用いて，この仮説を検証したいとおもいます．"
  },
  {
    "objectID": "posts/2025-12-15-statistical-inference/index.html#リサーチクエッション",
    "href": "posts/2025-12-15-statistical-inference/index.html#リサーチクエッション",
    "title": "中年男性の中性脂肪分布はLognormalで近似できるか？",
    "section": "",
    "text": "アメリカの中年男性（40-59歳）の血中中性脂肪（トリグリセリド）濃度は，Lognormal分布でどの程度近似できるか？\n\n\n\n血中脂質値は多くの場合，正規分布ではなく右に歪んだ分布を示します， 特に中性脂肪は，生活習慣や遺伝的要因により極端な高値を示す個人が存在するため，Lognormal分布での近似がしばしば用いられます． このノートでは，米国の代表的な健康調査データを用いて，この仮説を検証したいとおもいます．"
  },
  {
    "objectID": "posts/2025-12-15-statistical-inference/index.html#data",
    "href": "posts/2025-12-15-statistical-inference/index.html#data",
    "title": "中年男性の中性脂肪分布はLognormalで近似できるか？",
    "section": "2. Data",
    "text": "2. Data\nデータソース\n\nNHANES (National Health and Nutrition Examination Survey) August 2021 - August 2023\nアメリカCDCが実施する全国規模の健康・栄養調査データ．\n\n使用ファイル\n\n\n\nファイル\n内容\n\n\n\n\nDEMO_L.xpt\n人口統計学的データ（年齢，性別等）\n\n\nTRIGLY_L.xpt\n中性脂肪・LDLコレステロールデータ\n\n\n\n対象者の選択基準\n\n性別: 男性 (RIAGENDR = 1)\n年齢: 40-59歳 (RIDAGEYR)\n中性脂肪データ: 欠損なし (LBXTLG is not null)\nサンプルウェイト: 有効 (WTSAF2YR &gt; 0)\n\n測定方法\n\n中性脂肪（Triglycerides）は，12歳以上の参加者のうち，8-24時間絶食という空腹条件を満たした部分標本（fasting subsample） に対してのみ測定\n\nサンプルウェイト\n\nWTSAF2YR（空腹時サブサンプル2年MEC重み）を使用\nsee here\n\n\nDefinition 1 WTSAF2YR\n\n「当該参加者が米国の民間非施設居住人口の何人規模のグループをを代表しているか」を表す設計ウェイト\nある参加者のWTSAF2YR = 50,000 の場合，その参加者は母集団内の約50,000人グループを代表することを意味する\n\n\nウェイトの基本的な考えは\n\\[\n\\text{sample person's weight} = \\frac{1}{\\text{probability of selection}}\n\\]\n詳しい説明は省略しますが，\n\n\n\nFour Stages of NHANES Sampling Procedure\n\n\n\n米国全体を分割した一次抽出（PSU：郡または郡群）\n選ばれた PSU 内で小地域（街区・セグメント）が選ばれる\n選ばれたセグメント内で，世帯（household） が抽出される\n世帯内の構成員のうち，調査対象者として個人が選ばれる\n\nという流れでNHANESでは層化抽出が行われ probability of selection が定まります．解釈としては\n\n“A sample weight is assigned to each sample person. It is a measure of the number of people in the population represented by that sample person in NHANES, reflecting the unequal probability of selection, an adjustment for sample person non-response, and adjustment to account for differences between the final sample and the total population based on independent population control totals.”\n\nしたがって，母集団平均の推定には\n\\[\n\\text{weighted mean} = \\frac{\\sum \\text{WTSAF2YR} \\times \\text{value}}{\\sum \\text{WTSAF2YR}}\n\\]\nとなります．"
  },
  {
    "objectID": "posts/2025-12-15-statistical-inference/index.html#分析方針",
    "href": "posts/2025-12-15-statistical-inference/index.html#分析方針",
    "title": "中年男性の中性脂肪分布はLognormalで近似できるか？",
    "section": "3. 分析方針",
    "text": "3. 分析方針\nLognormal分布の仮定\n血中中性脂肪濃度は以下の特徴を持つため，Lognormal分布での近似をおこないます：\n\n正の値のみ: 濃度は必ず正の値をとる\n右に歪んだ分布: 極端な高値を示す個人が存在\n乗法的な影響: 遺伝・食事・運動などの要因が乗法的に作用すると仮定\n\n適合度の評価方法\n\n\n\n評価方法\n目的\n判断\n\n\n\n\n重み付きヒストグラム vs PDF\n視覚的な分布形状の比較\n主観的判断\n\n\nQ-Qプロット\n分位点の一致度を評価\n主観的判断\n\n\nKolmogorov-Smirnov検定\n統計的な適合度検定\n統計的判定"
  },
  {
    "objectID": "posts/2025-12-15-statistical-inference/index.html#推定関数",
    "href": "posts/2025-12-15-statistical-inference/index.html#推定関数",
    "title": "中年男性の中性脂肪分布はLognormalで近似できるか？",
    "section": "4. 推定関数",
    "text": "4. 推定関数\n\n重み付きQQ plot\n\n\nCode\nimport numpy as np\n\ndef weighted_quantiles(\n    values: np.ndarray, weights: np.ndarray, quantiles: np.ndarray\n) -&gt; np.ndarray:\n    \"\"\"\n    Compute weighted quantiles.\n\n    Parameters\n    ----------\n    values : array-like\n        Array of observed values.\n    weights : array-like\n        Sample weights corresponding to each observation.\n    quantiles : array-like\n        Quantiles to compute (values between 0 and 1).\n\n    Returns\n    -------\n    ndarray\n        Values corresponding to the specified quantiles.\n    \"\"\"\n    sorted_indices = np.argsort(values)\n    sorted_values = values[sorted_indices]\n    sorted_weights = weights[sorted_indices]\n\n    # Cumulative sum of weights, normalized to [0, 1]\n    cumsum_normalized = np.cumsum(sorted_weights) / np.sum(sorted_weights)\n\n    return np.interp(quantiles, cumsum_normalized, sorted_values)\n\n\n\n重み付きKS検定の実装\n\nscipy の ks_2samp をベースに、両側からのCDF差を計算する方法を採用\neffective sample sizeは \\((\\sum w_i)^2 / \\sum w_i^2\\) で計算 (see Monahan, J. (2011). Numerical Methods of Statistics.)\n\n\n\nCode\nfrom typing import Callable\nfrom scipy import stats\n\ndef weighted_ks_1samp(\n    values: np.ndarray, weights: np.ndarray, cdf_func: Callable[[np.ndarray], np.ndarray]\n) -&gt; tuple[float, float]:\n    \"\"\"\n    Perform a one-sample weighted Kolmogorov–Smirnov test.\n\n    The p-value is computed using an effective sample size\n    (Kish's effective sample size), following the approach\n    proposed by Monahan.\n\n    Parameters\n    ----------\n    values : np.ndarray\n        Array of observed values.\n    weights : np.ndarray\n        Sample weights corresponding to each observation.\n    cdf_func : Callable[[np.ndarray], np.ndarray]\n        CDF function of the theoretical distribution. It takes\n        an array of values and returns cumulative probabilities.\n\n    Returns\n    -------\n    tuple[float, float]\n        (ks_stat, p_value) – the KS statistic and the asymptotic p-value.\n\n    References\n    ----------\n    Monahan, J. (2011). *Numerical Methods of Statistics*.\n    \"\"\"\n    sorted_indices = np.argsort(values)\n    sorted_values = values[sorted_indices]\n    sorted_weights = weights[sorted_indices]\n\n    # Weighted ECDF: F_n(x) = Σ w_i * I(X_i ≤ x) / Σ w_i\n    cumsum = np.cumsum(sorted_weights)\n    total_weight = cumsum[-1]\n    ecdf_after = cumsum / total_weight          # F_n(x) = P(X ≤ x)\n    ecdf_before = np.concatenate([[0], ecdf_after[:-1]])  # F_n(x−)\n\n    # Theoretical CDF\n    theoretical_cdf = cdf_func(sorted_values)\n\n    # KS statistic: maximum deviation from both sides\n    d_plus = np.max(ecdf_after - theoretical_cdf)    # sup(F_n − F)\n    d_minus = np.max(theoretical_cdf - ecdf_before)  # sup(F − F_n)\n    ks_stat = max(d_plus, d_minus)\n\n    # Effective sample size (Kish's effective sample size)\n    n_eff = total_weight**2 / np.sum(sorted_weights**2)\n\n    # Asymptotic p-value (Kolmogorov distribution)\n    p_value = stats.kstwobign.sf(np.sqrt(n_eff) * ks_stat)\n\n    return float(ks_stat), float(np.clip(p_value, 0, 1))"
  },
  {
    "objectID": "posts/2025-12-15-statistical-inference/index.html#分析コード",
    "href": "posts/2025-12-15-statistical-inference/index.html#分析コード",
    "title": "中年男性の中性脂肪分布はLognormalで近似できるか？",
    "section": "5. 分析コード",
    "text": "5. 分析コード\n\n\nCode\n\"\"\"\nNHANES August 2021-August 2023 中年男性の中性脂肪分析\nヒストグラムとlognormal分布の比較\n（サンプルウェイト WTSAF2YR を考慮）\n\"\"\"\n\nimport polars as pl\nimport pyreadstat\nimport matplotlib.pyplot as plt\n\n\ndef load_data():\n    \"\"\"DEMO_L と TRIGLY_L データを読み込み結合\"\"\"\n    demo_pd, _ = pyreadstat.read_xport(\"DEMO_L.xpt\", encoding=\"latin1\")\n    trigly_pd, _ = pyreadstat.read_xport(\"TRIGLY_L.xpt\", encoding=\"latin1\")\n\n    demo = pl.from_pandas(demo_pd)\n    trigly = pl.from_pandas(trigly_pd)\n\n    df = demo.join(trigly, on=\"SEQN\", how=\"inner\")\n    return df\n\n\ndef filter_middle_aged_men(df: pl.DataFrame) -&gt; pl.DataFrame:\n    \"\"\"\n    中年男性（40-59歳）をフィルタリング\n    - RIAGENDR: 1 = Male\n    - RIDAGEYR: 年齢\n    - LBXTLG: 中性脂肪 (mg/dL)\n    - WTSAF2YR &gt; 0: 有効なサンプルウェイトを持つ参加者のみ\n    \"\"\"\n    filtered = df.filter(\n        (pl.col(\"RIAGENDR\") == 1)\n        & (pl.col(\"RIDAGEYR\") &gt;= 40)\n        & (pl.col(\"RIDAGEYR\") &lt;= 59)\n        & (pl.col(\"LBXTLG\").is_not_null())\n        & (pl.col(\"WTSAF2YR\") &gt; 0)\n    )\n    return filtered\n\n\ndef weighted_mean(values: np.ndarray, weights: np.ndarray) -&gt; float:\n    \"\"\"重み付き平均\"\"\"\n    return np.sum(values * weights) / np.sum(weights)\n\n\ndef weighted_std(values: np.ndarray, weights: np.ndarray) -&gt; float:\n    \"\"\"重み付き標準偏差\"\"\"\n    mean = weighted_mean(values, weights)\n    variance = np.sum(weights * (values - mean) ** 2) / np.sum(weights)\n    return np.sqrt(variance)\n\n\ndef weighted_median(values: np.ndarray, weights: np.ndarray) -&gt; float:\n    \"\"\"重み付き中央値\"\"\"\n    sorted_indices = np.argsort(values)\n    sorted_values = values[sorted_indices]\n    sorted_weights = weights[sorted_indices]\n    cumsum = np.cumsum(sorted_weights)\n    cutoff = np.sum(sorted_weights) / 2.0\n    return sorted_values[np.searchsorted(cumsum, cutoff)]\n\n\ndef weighted_histogram(values: np.ndarray, weights: np.ndarray, bins: int = 50):\n    \"\"\"重み付きヒストグラムのデータを計算\"\"\"\n    hist, bin_edges = np.histogram(values, bins=bins, weights=weights, density=True)\n    return hist, bin_edges\n\n\ndef weighted_ecdf(values: np.ndarray, weights: np.ndarray) -&gt; tuple:\n    \"\"\"重み付き経験累積分布関数を計算\"\"\"\n    sorted_indices = np.argsort(values)\n    sorted_values = values[sorted_indices]\n    sorted_weights = weights[sorted_indices]\n\n    cumsum = np.cumsum(sorted_weights)\n    ecdf = cumsum / cumsum[-1]\n\n    return sorted_values, ecdf\n\n\ndef filter_by_percentile(\n    values: np.ndarray,\n    weights: np.ndarray,\n    lower_pct: float = 0.05,\n    upper_pct: float = 0.95,\n) -&gt; tuple[np.ndarray, np.ndarray]:\n    \"\"\"\n    重み付きパーセンタイルでデータをフィルタリング\n\n    Parameters\n    ----------\n    values : np.ndarray\n        観測値\n    weights : np.ndarray\n        サンプルウェイト\n    lower_pct : float\n        下限パーセンタイル（0-1）\n    upper_pct : float\n        上限パーセンタイル（0-1）\n\n    Returns\n    -------\n    filtered_values : np.ndarray\n        フィルタリング後の観測値\n    filtered_weights : np.ndarray\n        フィルタリング後のウェイト\n    \"\"\"\n    quantile_bounds = weighted_quantiles(values, weights, np.array([lower_pct, upper_pct]))\n    lower_bound, upper_bound = quantile_bounds[0], quantile_bounds[1]\n\n    mask = (values &gt;= lower_bound) & (values &lt;= upper_bound)\n    return values[mask], weights[mask], lower_bound, upper_bound\n\n\n\ndef analyze_and_plot(\n    triglyceride_values: np.ndarray,\n    weights: np.ndarray,\n    save_suffix: str = \"\",\n):\n    \"\"\"ヒストグラムとlognormal分布の比較プロット（重み付き）\"\"\"\n\n    # --- 重み付きパラメータ推定 ---\n    log_values = np.log(triglyceride_values)\n    mu_weighted = weighted_mean(log_values, weights)\n    sigma_weighted = weighted_std(log_values, weights)\n\n    # プロット作成\n    fig, axes = plt.subplots(1, 2, figsize=(14, 5))\n\n    # --- 左: ヒストグラムとlognormal PDF ---\n    ax1 = axes[0]\n\n    # 重み付きヒストグラム\n    hist, bin_edges = weighted_histogram(triglyceride_values, weights, bins=50)\n    bin_centers = (bin_edges[:-1] + bin_edges[1:]) / 2\n    bin_width = bin_edges[1] - bin_edges[0]\n    ax1.bar(\n        bin_centers,\n        hist,\n        width=bin_width * 0.9,\n        alpha=0.7,\n        color=\"steelblue\",\n        edgecolor=\"white\",\n        label=\"Weighted histogram\",\n    )\n\n    # Lognormal PDF（重み付きパラメータ）\n    x = np.linspace(triglyceride_values.min(), triglyceride_values.max(), 500)\n    pdf_weighted = stats.lognorm.pdf(x, s=sigma_weighted, scale=np.exp(mu_weighted))\n    ax1.plot(\n        x,\n        pdf_weighted,\n        \"r-\",\n        linewidth=2,\n        label=f\"Lognormal (weighted)\\n(μ={mu_weighted:.2f}, σ={sigma_weighted:.2f})\",\n    )\n\n    ax1.set_xlabel(\"Triglyceride (mg/dL)\", fontsize=12)\n    ax1.set_ylabel(\"Density\", fontsize=12)\n    ax1.set_title(\n        \"Middle-aged Men (40-59 years) Triglyceride Distribution\\n\"\n        \"NHANES August 2021-August 2023 (Weighted by WTSAF2YR)\",\n        fontsize=12,\n    )\n    ax1.legend(fontsize=9)\n    ax1.grid(True, alpha=0.3)\n\n    # --- 右: 重み付きQ-Qプロット ---\n    ax2 = axes[1]\n\n    # 重み付き分位点を計算\n    n_quantiles = 100  # プロット用の分位点数\n    prob_points = np.linspace(0.001, 0.999, n_quantiles)  # 0.1%〜99.9%で裾もカバー\n\n    # 重み付き観測分位点\n    observed_quantiles = weighted_quantiles(triglyceride_values, weights, prob_points)\n\n    # 理論分位点（Lognormal）\n    theoretical_quantiles = stats.lognorm.ppf(\n        prob_points, s=sigma_weighted, scale=np.exp(mu_weighted)\n    )\n\n    ax2.scatter(\n        theoretical_quantiles, observed_quantiles, alpha=0.7, s=20, c=\"steelblue\"\n    )\n    min_val = min(theoretical_quantiles.min(), observed_quantiles.min())\n    max_val = max(theoretical_quantiles.max(), observed_quantiles.max())\n    ax2.plot(\n        [min_val, max_val], [min_val, max_val], \"r--\", linewidth=2, label=\"Perfect fit\"\n    )\n\n    ax2.set_xlabel(\"Theoretical Quantiles (Lognormal)\", fontsize=12)\n    ax2.set_ylabel(\"Weighted Observed Quantiles\", fontsize=12)\n    ax2.set_title(\"Weighted Q-Q Plot: Lognormal Distribution Fit\", fontsize=12)\n    ax2.legend(fontsize=10)\n    ax2.grid(True, alpha=0.3)\n\n    plt.tight_layout()\n    plt.savefig(f\"triglyceride_analysis{save_suffix}.png\", dpi=150, bbox_inches=\"tight\")\n    plt.show()\n\n    # 統計情報を出力\n    print(\"\\n\" + \"=\" * 70)\n    print(\"Statistics: Middle-aged Men (40-59 years) Triglyceride\")\n    print(\"NHANES August 2021-August 2023 (with sample weights)\")\n    print(\"=\" * 70)\n    print(f\"Sample size (n): {len(triglyceride_values)}\")\n    print(f\"Sum of weights: {np.sum(weights):,.0f}\")\n\n    print(f\"\\n[Descriptive Statistics - WEIGHTED (population estimates)]\")\n    print(f\"  Mean: {weighted_mean(triglyceride_values, weights):.1f} mg/dL\")\n    print(f\"  Median: {weighted_median(triglyceride_values, weights):.1f} mg/dL\")\n    print(f\"  Std Dev: {weighted_std(triglyceride_values, weights):.1f} mg/dL\")\n\n    print(f\"\\n[Descriptive Statistics - UNWEIGHTED (sample only)]\")\n    print(f\"  Mean: {np.mean(triglyceride_values):.1f} mg/dL\")\n    print(f\"  Median: {np.median(triglyceride_values):.1f} mg/dL\")\n    print(f\"  Std Dev: {np.std(triglyceride_values, ddof=1):.1f} mg/dL\")\n    print(f\"  Min: {np.min(triglyceride_values):.1f} mg/dL\")\n    print(f\"  Max: {np.max(triglyceride_values):.1f} mg/dL\")\n\n    print(f\"\\n[Lognormal Parameters - WEIGHTED]\")\n    print(f\"  μ (log-scale mean): {mu_weighted:.4f}\")\n    print(f\"  σ (log-scale std): {sigma_weighted:.4f}\")\n    print(f\"  Median from fit (exp(μ)): {np.exp(mu_weighted):.1f} mg/dL\")\n\n\n    # 適合度検定 (Kolmogorov-Smirnov)\n    def cdf_func(x):\n        return stats.lognorm.cdf(x, s=sigma_weighted, scale=np.exp(mu_weighted))\n\n    # 重み付きKS検定\n    ks_stat_weighted, ks_pvalue_weighted = weighted_ks_1samp(\n        triglyceride_values, weights, cdf_func\n    )\n\n    # 有効サンプルサイズ（Kish's effective sample size）\n    n_eff = (np.sum(weights) ** 2) / np.sum(weights**2)\n\n    # 重みなしKS検定（参考）\n    ks_stat_unweighted, ks_pvalue_unweighted = stats.kstest(\n        triglyceride_values, cdf_func\n    )\n\n    print(\"\\n[Goodness-of-fit (Kolmogorov-Smirnov)]\")\n    print(\"  [WEIGHTED]\")\n    print(f\"    KS statistic: {ks_stat_weighted:.4f}\")\n    print(f\"    Asymptotic p-value: {ks_pvalue_weighted:.4f}\")\n    print(f\"    Effective sample size (Kish): {n_eff:.1f}\")\n    print(\"    Note: p-value uses asymptotic approximation with n_eff\")\n    if ks_pvalue_weighted &gt; 0.05:\n        print(\"    -&gt; p &gt; 0.05: No significant difference from lognormal\")\n    else:\n        print(\"    -&gt; p &lt; 0.05: Significantly different from lognormal\")\n\n    print(\"  [UNWEIGHTED (reference)]\")\n    print(f\"    KS statistic: {ks_stat_unweighted:.4f}\")\n    print(f\"    p-value: {ks_pvalue_unweighted:.4f}\")\n    if ks_pvalue_unweighted &gt; 0.05:\n        print(\"    -&gt; p &gt; 0.05: No significant difference from lognormal\")\n    else:\n        print(\"    -&gt; p &lt; 0.05: Significantly different from lognormal\")\n    print(\"=\" * 70)\n\n\ndef main():\n    print(\"Loading NHANES data...\")\n    df = load_data()\n\n    print(\"Filtering middle-aged men (40-59 years) with valid weights...\")\n    middle_aged_men = filter_middle_aged_men(df)\n\n    triglyceride_values = middle_aged_men.select(\"LBXTLG\").to_numpy().flatten()\n    weights = middle_aged_men.select(\"WTSAF2YR\").to_numpy().flatten()\n\n    print(f\"Sample size: {len(triglyceride_values)}\")\n    print(f\"Excluded (WTSAF2YR = 0 or missing): checked\")\n\n    analyze_and_plot(triglyceride_values, weights)\n\nif __name__ == \"__main__\":\n    main()\n\n\nLoading NHANES data...\nFiltering middle-aged men (40-59 years) with valid weights...\nSample size: 362\nExcluded (WTSAF2YR = 0 or missing): checked\n\n\n\n\n\n\n\n\n\n\n======================================================================\nStatistics: Middle-aged Men (40-59 years) Triglyceride\nNHANES August 2021-August 2023 (with sample weights)\n======================================================================\nSample size (n): 362\nSum of weights: 39,758,496\n\n[Descriptive Statistics - WEIGHTED (population estimates)]\n  Mean: 152.6 mg/dL\n  Median: 111.0 mg/dL\n  Std Dev: 180.6 mg/dL\n\n[Descriptive Statistics - UNWEIGHTED (sample only)]\n  Mean: 149.9 mg/dL\n  Median: 108.5 mg/dL\n  Std Dev: 160.2 mg/dL\n  Min: 28.0 mg/dL\n  Max: 1745.0 mg/dL\n\n[Lognormal Parameters - WEIGHTED]\n  μ (log-scale mean): 4.7800\n  σ (log-scale std): 0.6062\n  Median from fit (exp(μ)): 119.1 mg/dL\n\n[Goodness-of-fit (Kolmogorov-Smirnov)]\n  [WEIGHTED]\n    KS statistic: 0.0893\n    Asymptotic p-value: 0.0344\n    Effective sample size (Kish): 254.8\n    Note: p-value uses asymptotic approximation with n_eff\n    -&gt; p &lt; 0.05: Significantly different from lognormal\n  [UNWEIGHTED (reference)]\n    KS statistic: 0.0892\n    p-value: 0.0059\n    -&gt; p &lt; 0.05: Significantly different from lognormal\n======================================================================"
  },
  {
    "objectID": "posts/2025-12-15-statistical-inference/index.html#結果解釈",
    "href": "posts/2025-12-15-statistical-inference/index.html#結果解釈",
    "title": "中年男性の中性脂肪分布はLognormalで近似できるか？",
    "section": "6. 結果解釈",
    "text": "6. 結果解釈\n\nQQ plot\n\n\n\n\n観測点の位置\n意味\n\n\n\n\n直線上\n理論分布と一致\n\n\n直線より上\n観測データの裾が厚い (heavy tail)\n\n\n直線より下\n観測データの裾が薄い (light tail)\n\n\n\n\n今回のデータの特徴\n\n\n\n領域\n観察されたパターン\n解釈\n\n\n\n\n下側の裾（低値）\nほぼ直線上\nLognormalと良く一致\n\n\n中央部（50-300 mg/dL）\n直線上\n良好なフィット\n\n\n上側の裾（高値）\n直線より上に乖離\nLognormalより裾が厚い\n\n\n\nInsights\n\n全体的なフィット: Lognormal分布は中性脂肪分布の大部分（約95%）を良く近似する\n上側の裾の逸脱: 極端な高値（概ね400 mg/dL以上）の出現頻度がLognormal分布の予測より高い\n臨床的含意:\n\n高トリグリセリド血症の有病率推定において、Lognormalモデルは過小評価のリスクがある\nリスク評価では、より裾の厚い分布（例：一般化ガンマ分布）の検討も有用かも？"
  },
  {
    "objectID": "posts/2025-12-15-statistical-inference/index.html#追加分析",
    "href": "posts/2025-12-15-statistical-inference/index.html#追加分析",
    "title": "中年男性の中性脂肪分布はLognormalで近似できるか？",
    "section": "7. 追加分析",
    "text": "7. 追加分析\n\n\nCode\ndef additional_analysis():\n    print(\"Loading NHANES data...\")\n    df = load_data()\n\n    print(\"Filtering middle-aged men (40-59 years) with valid weights...\")\n    middle_aged_men = filter_middle_aged_men(df)\n\n    triglyceride_values = middle_aged_men.select(\"LBXTLG\").to_numpy().flatten()\n    weights = middle_aged_men.select(\"WTSAF2YR\").to_numpy().flatten()\n\n    # === 5%-95%パーセンタイル範囲での分析 ===\n    print(\"\\n\" + \"=\" * 70)\n    print(\"ANALYSIS 2: Trimmed Data (5th-95th Percentile)\")\n    print(\"=\" * 70)\n    trimmed_values, trimmed_weights, lower_bound, upper_bound = filter_by_percentile(\n        triglyceride_values, weights, lower_pct=0.05, upper_pct=0.95\n    )\n    print(f\"Percentile range: [{lower_bound:.1f}, {upper_bound:.1f}] mg/dL\")\n    print(f\"Trimmed sample size: {len(trimmed_values)} (from {len(triglyceride_values)})\")\n    print(f\"Excluded: {len(triglyceride_values) - len(trimmed_values)} extreme values\")\n\n    analyze_and_plot(trimmed_values, trimmed_weights, save_suffix=\"_trimmed_5_95\")\n\nadditional_analysis()\n\n\nLoading NHANES data...\nFiltering middle-aged men (40-59 years) with valid weights...\n\n======================================================================\nANALYSIS 2: Trimmed Data (5th-95th Percentile)\n======================================================================\nPercentile range: [52.8, 351.4] mg/dL\nTrimmed sample size: 326 (from 362)\nExcluded: 36 extreme values\n\n\n\n\n\n\n\n\n\n\n======================================================================\nStatistics: Middle-aged Men (40-59 years) Triglyceride\nNHANES August 2021-August 2023 (with sample weights)\n======================================================================\nSample size (n): 326\nSum of weights: 35,785,691\n\n[Descriptive Statistics - WEIGHTED (population estimates)]\n  Mean: 126.0 mg/dL\n  Median: 111.0 mg/dL\n  Std Dev: 59.0 mg/dL\n\n[Descriptive Statistics - UNWEIGHTED (sample only)]\n  Mean: 127.4 mg/dL\n  Median: 108.0 mg/dL\n  Std Dev: 63.0 mg/dL\n  Min: 53.0 mg/dL\n  Max: 336.0 mg/dL\n\n[Lognormal Parameters - WEIGHTED]\n  μ (log-scale mean): 4.7400\n  σ (log-scale std): 0.4308\n  Median from fit (exp(μ)): 114.4 mg/dL\n\n[Goodness-of-fit (Kolmogorov-Smirnov)]\n  [WEIGHTED]\n    KS statistic: 0.0688\n    Asymptotic p-value: 0.2259\n    Effective sample size (Kish): 230.1\n    Note: p-value uses asymptotic approximation with n_eff\n    -&gt; p &gt; 0.05: No significant difference from lognormal\n  [UNWEIGHTED (reference)]\n    KS statistic: 0.0704\n    p-value: 0.0755\n    -&gt; p &gt; 0.05: No significant difference from lognormal\n======================================================================\n\n\n\n\n\n\n\n\nNote追加分析解釈\n\n\n\n\nlog-scale が0.6062 → 0.0688に減少: 裾の極端な値を除外したことで分散が小さくなった\nKS統計量も0.0893 → 0.4308に減少: 経験分布と理論分布の最大乖離が縮小\nQ-Qプロットを見ても，トリミング後は理論直線（赤破線）にデータポイントがいい感じに乗っている．特に上側の裾の逸脱が解消\nただし，そもそも上位5%を異常値として除外できるかどうかは，適合度のみではわからない．\n\n分析目的などによりケースバイケースで判断が必要"
  },
  {
    "objectID": "posts/2025-12-15-statistical-inference/index.html#appendix-トリグリセリド",
    "href": "posts/2025-12-15-statistical-inference/index.html#appendix-トリグリセリド",
    "title": "中年男性の中性脂肪分布はLognormalで近似できるか？",
    "section": "Appendix: トリグリセリド",
    "text": "Appendix: トリグリセリド\n\nDefinition 2 中性脂肪 / トリグリセリド\n\n肉や魚・食用油など食品中の脂質や，体内の脂質の大部分を占める物質\n中性脂肪は重要なエネルギー源であり，ビタミンの吸収を助けたり，必須脂肪酸（体内で合成されない脂肪酸）を摂取するという点においても不可欠なもの\nとりすぎると体脂肪として蓄えられて肥満を招き，心筋梗塞などになりやすくなる\n血液中の中性脂肪値は特定健診の検査項目に含まれており，空腹時150mg/dⅬ以上，随時175mg/dⅬ以上になると「高TG（トリグリセライド）血症」とされる\n\n\n\n\n\n\n\n\n\n\n\n\n測定項目\n英語名\n略称\n単位\n説明\n\n\n\n\n総コレステロール\nTotal Cholesterol\nTC\nmg/dL\n血中コレステロールの総量．心血管疾患リスク評価の基本指標\n\n\n高比重リポ蛋白コレステロール\nHigh-Density Lipoprotein Cholesterol\nHDL-C\nmg/dL\nいわゆる「善玉」コレステロール．高値は心血管リスク低下と関連\n\n\n低比重リポ蛋白コレステロール\nLow-Density Lipoprotein Cholesterol\nLDL-C\nmg/dL\nいわゆる「悪玉」コレステロール．動脈硬化リスクと強く関連\n\n\n中性脂肪\nTriglycerides\nTG\nmg/dL\n血中脂質の一種．エネルギー代謝やメタボリックリスクと関連"
  },
  {
    "objectID": "posts/2025-12-15-statistical-inference/index.html#appendix-qq-plot",
    "href": "posts/2025-12-15-statistical-inference/index.html#appendix-qq-plot",
    "title": "中年男性の中性脂肪分布はLognormalで近似できるか？",
    "section": "Appendix: QQ plot",
    "text": "Appendix: QQ plot\nデータ解析のための数理統計入門ベースで行くとQQ plotは以下のように定義されています．\n\nDefinition 3 QQ plot\n確率変数 \\(X_1, \\cdots, X_n \\overset{\\mathrm{iid}}{\\sim} F\\) とし，その順序統計量を\n\\[\nX_{(1)} \\leq \\cdots \\leq X_{(n)}\n\\]\nとする．\\(X_{(j)}\\) の実現値 \\(x_{(j)}\\) として， \\(F\\) の逆変換を施した点\n\\[\n(x_{(j)}, F^{-1}(j/(n+1)))\n\\]\nをplotしたものをQQ plotという．\n\nこの定義を正とすると，分析におけるQQ plotはQQ plotではない．ただ，久保川先生では\n\\[\nF(x_{(j)}, j/(n+1))\n\\]\nをplotしたものをPP plotと呼んでおり，分析におけるQQ plotは久保川流でいくならば PP plotということになります．PP plotの理論的根拠は， 確率積分変換により \\(F(X)\\) は一様分布に従い，iid sampleは各点独立に\n\\[\n\\mathbb E[F(X_{(j)})] = \\frac{j}{n+1}\n\\]\nになるはずという考えが背景にあります．"
  },
  {
    "objectID": "posts/2025-12-15-statistical-inference/index.html#references",
    "href": "posts/2025-12-15-statistical-inference/index.html#references",
    "title": "中年男性の中性脂肪分布はLognormalで近似できるか？",
    "section": "References",
    "text": "References\n\n厚生労働省 &gt; 健康日本21アクション支援システム ～健康づくりサポートネット～ &gt; 中性脂肪 / トリグリセリド\nNHANES (National Health and Nutrition Examination Survey) August 2021 - August 2023\nMonahan, J. (2011). Numerical Methods of Statistics.\nnumpy.interp\nデータ解析のための数理統計入門"
  },
  {
    "objectID": "posts/2025-02-02-taylor-expansion-and-polynomial/index.html",
    "href": "posts/2025-02-02-taylor-expansion-and-polynomial/index.html",
    "title": "有限個の多項式のテイラー展開",
    "section": "",
    "text": "\\(y = f(x)\\) の導関数を \\(f^\\prime(x)\\) とするとき，第二階の導関数を \\(f^{\\prime\\prime}(x)\\) と表記し，第 \\(n\\) 階の導関数を \\(f^{(n)}(x)\\) と表記します． 一点 \\(x\\) において\n\\[\n\\begin{gather}\nf^{\\prime\\prime}(x) = \\frac{d}{dx}\\left(\\frac{dy}{dx}\\right) = \\frac{d^2y}{dx^2}\\\\\nf^{(n)}(x) = \\frac{d^ny}{dx^n}\n\\end{gather}\n\\]\nとなります．\n ▶  記号の差異: \\(d^2y\\) vs \\(dx^2\\)\n\\(d^2y = d(dy)\\)，\\(dx^2 = (dx)^2\\) の意味で，この意味の差異を表現するため記号でも表記が異なっています．微分記号を用いて\n\\[\ndy = f^\\prime(x)dx\n\\]\nと書くとき，両辺の微分を取れば，\n\\[\n\\begin{align}\nd(dy) &= \\frac{d(f^{\\prime}(x))}{dx}(dx)^2 + f^\\prime(x)\\frac{d(dx)}{dx}dx\\\\\n      &= f^{\\prime\\prime}(x)(dx)^2 + f^\\prime(x)d(dx) \\label{eq-second-diff}\n\\end{align}\n\\]\n\\(x\\) が独立変数であるならば \\(dx\\) は \\(x\\) の水準関係なく自由に取れるので，\\(\\frac{d(dx)}{dx} = 0\\)．従って，\n\\[\nd^2y = f^{\\prime\\prime}(x)dx^2\n\\]\nとなります．もし，\\(x = \\varphi(t)\\) であるならば，\\(d^2x = \\varphi^{\\prime\\prime}(t)dt^2\\) となるので\n\\[\n\\frac{d}{dt^2}f(\\varphi(t)) = f^{\\prime\\prime}(\\varphi(t))(\\varphi^\\prime(t))^2 + f^\\prime(\\varphi(t))\\varphi^{\\prime\\prime}(t)\n\\]\n\n\n\n\nTheorem 1 : ライプニッツの公式(Leibniz rule) \n\\(u, v\\) が \\(x\\) の関数であるとき，\n\\[\n\\begin{align}\n\\frac{d^n(uv)}{dx^n}\n    &= u^{(n)}v + \\left(\\begin{array}{c}n\\\\1\\end{array}\\right)u^{(n-1)}v^{\\prime} + \\left(\\begin{array}{c}n\\\\2\\end{array}\\right)u^{(n-2)}v^{\\prime\\prime}+\\cdots+ \\left(\\begin{array}{c}n\\\\n-1\\end{array}\\right)u^{\\prime}v^{(n-1)} +uv^{(n)}\\\\\n    &= \\sum_{k=0}^n \\left(\\begin{array}{c}n\\\\ k\\end{array}\\right)u^{(n-k)}v^{(k)}\n\\end{align}\n\\]\n\n\n\n\n\n\n\n\n\nNoteProof\n\n\n\n\n\n\\(n=1\\) のときは，積の微分公式より\n\\[\n\\frac{d(uv)}{dx^n} = \\frac{du}{dx}v + \\frac{dv}{dx}u\n\\]\n\\(n\\geq 2\\) については，帰納法を用いて示す．\\(n=t\\) のときライプニッツの公式が成立すると仮定する．\nこのとき，\n\\[\n\\begin{align}\n\\frac{d^{(t+1)}(uv)}{dx^{t+1}}\n    &= \\frac{d}{dt}\\left(\\frac{d^{(t)}(uv)}{dx^{t}}\\right)\\\\\n    &= \\frac{d}{dt}\\left(\\sum_{k=0}^t \\left(\\begin{array}{c}t\\\\ k\\end{array}\\right)u^{(t-k)}v^{(k)}\\right)\\\\\n    &= \\sum_{k=0}^t \\left(\\begin{array}{c}t\\\\ k\\end{array}\\right)[u^{(t-k+1)}v^{(k)} + u^{(t-k)}v^{(k+1)}]\\\\\n    &= \\sum_{k=0}^t \\left(\\begin{array}{c}t\\\\ k\\end{array}\\right)u^{(t-k+1)}v^{(k)} + \\sum_{k=0}^t \\left(\\begin{array}{c}t\\\\ k\\end{array}\\right)u^{(t-k)}v^{(k+1)}\\\\\n    &= \\left\\{u^{(t+1)}v + \\sum_{k=1}^t \\left(\\begin{array}{c}t\\\\ k\\end{array}\\right)u^{(t-k+1)}v^{(k)}\\right\\}+ \\left\\{uv^{(t+1)} + \\sum_{k=0}^{t-1} \\left(\\begin{array}{c}t\\\\ k\\end{array}\\right)u^{(t-k)}v^{(k+1)}\\right\\}\\\\\n    &= \\left\\{u^{(t+1)}v + \\sum_{k=1}^t \\left(\\begin{array}{c}t\\\\ k\\end{array}\\right)u^{(t-k+1)}v^{(k)}\\right\\}+ \\left\\{uv^{(t+1)} + \\sum_{j=1}^{t} \\left(\\begin{array}{c}t\\\\ j-1\\end{array}\\right)u^{(t-j+1)}v^{j}\\right\\}\\\\\n    &= u^{(t+1)}v + uv^{(t+1)} + \\sum_{k=1}^t \\left\\{\\left(\\begin{array}{c}t\\\\ k\\end{array}\\right) + \\left(\\begin{array}{c}t\\\\ k-1\\end{array}\\right)\\right\\}u^{(t-k+1)}v^{(k)}\\\\\n    &= u^{(t+1)}v + uv^{(t+1)} + \\sum_{k=1}^t \\left(\\begin{array}{c}t+1\\\\ k\\end{array}\\right)u^{(t+1-k)}v^{(k)}\\\\\n    &= \\sum_{k=0}^{t+1} \\left(\\begin{array}{c}t+1\\\\ k\\end{array}\\right)u^{(t+1-k)}v^{(k)}\n\\end{align}\n\\]\nとなり，\\(n = t + 1\\) の場合のライプニッツの公式の成立が確かめられた．\n\n\n\n\nExample 1 \n\\(y = x^2\\sin(x)\\) について \\(n\\) 階導関数を求めめたいとします．\n\\[\n(\\sin x)^{(k)} = \\sin\\left(x + \\frac{\\pi}{2}k\\right)\n\\]\nであるので\n\\(n=1\\) のときは\n\\[\ny^\\prime = x^2\\sin\\left(x + \\frac{\\pi}{2}\\right) + 2x\\sin(x)\n\\]\n\\(n\\geq 2\\) のときは，\\(x^2\\) が2回微分可能であることを考慮してライプニッツルールを利用すると\n\\[\n\\begin{align}\n\\frac{d^n}{dx^{n}}(x^2\\sin x)\n    &= x^2(\\sin(x))^{(n)} + 2nx(\\sin(x))^{(n-1)} + n(n-1)(\\sin(x))^{(n-2)}\\\\\n    &= x^2\\sin\\left(x + \\frac{\\pi}{2}n\\right) + 2nx\\sin\\left(x + \\frac{\\pi}{2}(n-1)\\right) + n(n-1)\\sin\\left(x + \\frac{\\pi}{2}(n-2)\\right)   \n\\end{align}\n\\]\n\n\n\nExample 2 \n\\[\n\\begin{align}\n(x\\sin x)^{(n)} = x\\sin\\left(x + \\frac{\\pi}{2}n\\right) + n \\sin\\left(x + \\frac{\\pi}{2}(n-1)\\right)\\\\\n(x\\cos x)^{(n)} = x\\cos\\left(x + \\frac{\\pi}{2}n\\right) + n \\cos\\left(x + \\frac{\\pi}{2}(n-1)\\right)\\\\\n(x^2\\exp(x))^{(n)} = x^2\\exp(x) + 2nx\\exp(x) + n(n-1)\\exp(x)\n\\end{align}\n\\]"
  },
  {
    "objectID": "posts/2025-02-02-taylor-expansion-and-polynomial/index.html#高階微分法とライプニッツの公式",
    "href": "posts/2025-02-02-taylor-expansion-and-polynomial/index.html#高階微分法とライプニッツの公式",
    "title": "有限個の多項式のテイラー展開",
    "section": "",
    "text": "\\(y = f(x)\\) の導関数を \\(f^\\prime(x)\\) とするとき，第二階の導関数を \\(f^{\\prime\\prime}(x)\\) と表記し，第 \\(n\\) 階の導関数を \\(f^{(n)}(x)\\) と表記します． 一点 \\(x\\) において\n\\[\n\\begin{gather}\nf^{\\prime\\prime}(x) = \\frac{d}{dx}\\left(\\frac{dy}{dx}\\right) = \\frac{d^2y}{dx^2}\\\\\nf^{(n)}(x) = \\frac{d^ny}{dx^n}\n\\end{gather}\n\\]\nとなります．\n ▶  記号の差異: \\(d^2y\\) vs \\(dx^2\\)\n\\(d^2y = d(dy)\\)，\\(dx^2 = (dx)^2\\) の意味で，この意味の差異を表現するため記号でも表記が異なっています．微分記号を用いて\n\\[\ndy = f^\\prime(x)dx\n\\]\nと書くとき，両辺の微分を取れば，\n\\[\n\\begin{align}\nd(dy) &= \\frac{d(f^{\\prime}(x))}{dx}(dx)^2 + f^\\prime(x)\\frac{d(dx)}{dx}dx\\\\\n      &= f^{\\prime\\prime}(x)(dx)^2 + f^\\prime(x)d(dx) \\label{eq-second-diff}\n\\end{align}\n\\]\n\\(x\\) が独立変数であるならば \\(dx\\) は \\(x\\) の水準関係なく自由に取れるので，\\(\\frac{d(dx)}{dx} = 0\\)．従って，\n\\[\nd^2y = f^{\\prime\\prime}(x)dx^2\n\\]\nとなります．もし，\\(x = \\varphi(t)\\) であるならば，\\(d^2x = \\varphi^{\\prime\\prime}(t)dt^2\\) となるので\n\\[\n\\frac{d}{dt^2}f(\\varphi(t)) = f^{\\prime\\prime}(\\varphi(t))(\\varphi^\\prime(t))^2 + f^\\prime(\\varphi(t))\\varphi^{\\prime\\prime}(t)\n\\]\n\n\n\n\nTheorem 1 : ライプニッツの公式(Leibniz rule) \n\\(u, v\\) が \\(x\\) の関数であるとき，\n\\[\n\\begin{align}\n\\frac{d^n(uv)}{dx^n}\n    &= u^{(n)}v + \\left(\\begin{array}{c}n\\\\1\\end{array}\\right)u^{(n-1)}v^{\\prime} + \\left(\\begin{array}{c}n\\\\2\\end{array}\\right)u^{(n-2)}v^{\\prime\\prime}+\\cdots+ \\left(\\begin{array}{c}n\\\\n-1\\end{array}\\right)u^{\\prime}v^{(n-1)} +uv^{(n)}\\\\\n    &= \\sum_{k=0}^n \\left(\\begin{array}{c}n\\\\ k\\end{array}\\right)u^{(n-k)}v^{(k)}\n\\end{align}\n\\]\n\n\n\n\n\n\n\n\n\nNoteProof\n\n\n\n\n\n\\(n=1\\) のときは，積の微分公式より\n\\[\n\\frac{d(uv)}{dx^n} = \\frac{du}{dx}v + \\frac{dv}{dx}u\n\\]\n\\(n\\geq 2\\) については，帰納法を用いて示す．\\(n=t\\) のときライプニッツの公式が成立すると仮定する．\nこのとき，\n\\[\n\\begin{align}\n\\frac{d^{(t+1)}(uv)}{dx^{t+1}}\n    &= \\frac{d}{dt}\\left(\\frac{d^{(t)}(uv)}{dx^{t}}\\right)\\\\\n    &= \\frac{d}{dt}\\left(\\sum_{k=0}^t \\left(\\begin{array}{c}t\\\\ k\\end{array}\\right)u^{(t-k)}v^{(k)}\\right)\\\\\n    &= \\sum_{k=0}^t \\left(\\begin{array}{c}t\\\\ k\\end{array}\\right)[u^{(t-k+1)}v^{(k)} + u^{(t-k)}v^{(k+1)}]\\\\\n    &= \\sum_{k=0}^t \\left(\\begin{array}{c}t\\\\ k\\end{array}\\right)u^{(t-k+1)}v^{(k)} + \\sum_{k=0}^t \\left(\\begin{array}{c}t\\\\ k\\end{array}\\right)u^{(t-k)}v^{(k+1)}\\\\\n    &= \\left\\{u^{(t+1)}v + \\sum_{k=1}^t \\left(\\begin{array}{c}t\\\\ k\\end{array}\\right)u^{(t-k+1)}v^{(k)}\\right\\}+ \\left\\{uv^{(t+1)} + \\sum_{k=0}^{t-1} \\left(\\begin{array}{c}t\\\\ k\\end{array}\\right)u^{(t-k)}v^{(k+1)}\\right\\}\\\\\n    &= \\left\\{u^{(t+1)}v + \\sum_{k=1}^t \\left(\\begin{array}{c}t\\\\ k\\end{array}\\right)u^{(t-k+1)}v^{(k)}\\right\\}+ \\left\\{uv^{(t+1)} + \\sum_{j=1}^{t} \\left(\\begin{array}{c}t\\\\ j-1\\end{array}\\right)u^{(t-j+1)}v^{j}\\right\\}\\\\\n    &= u^{(t+1)}v + uv^{(t+1)} + \\sum_{k=1}^t \\left\\{\\left(\\begin{array}{c}t\\\\ k\\end{array}\\right) + \\left(\\begin{array}{c}t\\\\ k-1\\end{array}\\right)\\right\\}u^{(t-k+1)}v^{(k)}\\\\\n    &= u^{(t+1)}v + uv^{(t+1)} + \\sum_{k=1}^t \\left(\\begin{array}{c}t+1\\\\ k\\end{array}\\right)u^{(t+1-k)}v^{(k)}\\\\\n    &= \\sum_{k=0}^{t+1} \\left(\\begin{array}{c}t+1\\\\ k\\end{array}\\right)u^{(t+1-k)}v^{(k)}\n\\end{align}\n\\]\nとなり，\\(n = t + 1\\) の場合のライプニッツの公式の成立が確かめられた．\n\n\n\n\nExample 1 \n\\(y = x^2\\sin(x)\\) について \\(n\\) 階導関数を求めめたいとします．\n\\[\n(\\sin x)^{(k)} = \\sin\\left(x + \\frac{\\pi}{2}k\\right)\n\\]\nであるので\n\\(n=1\\) のときは\n\\[\ny^\\prime = x^2\\sin\\left(x + \\frac{\\pi}{2}\\right) + 2x\\sin(x)\n\\]\n\\(n\\geq 2\\) のときは，\\(x^2\\) が2回微分可能であることを考慮してライプニッツルールを利用すると\n\\[\n\\begin{align}\n\\frac{d^n}{dx^{n}}(x^2\\sin x)\n    &= x^2(\\sin(x))^{(n)} + 2nx(\\sin(x))^{(n-1)} + n(n-1)(\\sin(x))^{(n-2)}\\\\\n    &= x^2\\sin\\left(x + \\frac{\\pi}{2}n\\right) + 2nx\\sin\\left(x + \\frac{\\pi}{2}(n-1)\\right) + n(n-1)\\sin\\left(x + \\frac{\\pi}{2}(n-2)\\right)   \n\\end{align}\n\\]\n\n\n\nExample 2 \n\\[\n\\begin{align}\n(x\\sin x)^{(n)} = x\\sin\\left(x + \\frac{\\pi}{2}n\\right) + n \\sin\\left(x + \\frac{\\pi}{2}(n-1)\\right)\\\\\n(x\\cos x)^{(n)} = x\\cos\\left(x + \\frac{\\pi}{2}n\\right) + n \\cos\\left(x + \\frac{\\pi}{2}(n-1)\\right)\\\\\n(x^2\\exp(x))^{(n)} = x^2\\exp(x) + 2nx\\exp(x) + n(n-1)\\exp(x)\n\\end{align}\n\\]"
  },
  {
    "objectID": "posts/2025-02-02-taylor-expansion-and-polynomial/index.html#有限個の多項式のテイラー展開",
    "href": "posts/2025-02-02-taylor-expansion-and-polynomial/index.html#有限個の多項式のテイラー展開",
    "title": "有限個の多項式のテイラー展開",
    "section": "有限個の多項式のテイラー展開",
    "text": "有限個の多項式のテイラー展開\n\\(n\\) 次式の \\(f(x)\\) を考えます．このとき，定義域の任意の点 \\(a\\) を用いて，以下のように表すとします\n\\[\nf(x) = a_0 + a_1(x-a) + a_2(x-a)^2 + \\cdots + a_n(x-a)^n\n\\]\n\\(x = a\\) のとき，\\(f(a) = a_0\\)．両辺を \\(k\\) 回微分すると\n\\[\nf^{(k)}(x) = a_kk! + a_{k+1}\\frac{(k+1)!}{1!}(x-a) + a_{k+2}\\frac{(k+2)!}{2!}(x-a)^2 + \\cdots + a_{n}\\frac{n!}{(n-k)!}(x-a)^{n-k}\n\\]\nこのとき，\\(f^{(k)}(a) = a_kk!\\) であるので，\\(a_k = \\frac{f^{(k)}(a)}{k!}\\) を得る．従って，\\(n\\) 次式の \\(f(x)\\) は\n\\[\nf(x) = f(a) + \\frac{f^{\\prime}(a)}{1!}(x-a) + \\frac{f^{(2)}(a)}{2!}(x-a)^2 + \\cdots + \\frac{f^{(n)}(a)}{n!}(x-a)^n\\label{eq-poly}\n\\]\nと表すことが出来ます．\n\nExample 3 \n\\(f(x) = x^n\\) を\n\\[\nf(x) = a_0 + a_1(x-1) + a_2(x-1)^2 + \\cdots + a_n(x-1)^n\n\\]\nで表したいとします．このとき，\\(\\eqref{eq-poly}\\) より\n\\[\n\\begin{align}\nx^n\n    &= 1 + \\frac{n}{1!}(x-1)+ \\frac{n(n-1)}{2!}(x-1)^2 + \\cdots + \\frac{n!}{n!}(x-1)^n\\\\\n    &= \\sum_{k=0}^n \\left(\\begin{array}{c}n\\\\ k\\end{array}\\right)(x-1)^k\n\\end{align}\n\\]\nと表せます．これを更に式変形すると\n\\[\n\\begin{align}\n\\sum_{k=0}^n \\left(\\begin{array}{c}n\\\\ k\\end{array}\\right)(x-1)^k\n    &= \\sum_{k=0}^n \\left(\\begin{array}{c}n\\\\ k\\end{array}\\right)(x-1)^k 1^{n-k}\\\\\n    &= (x - 1 + 1)^n\\\\\n    &= x^n\n\\end{align}\n\\]\nよって \\(x^n\\) の \\(x = 1\\) まわりでのテイラー展開は \\((x - 1 + 1)^n\\) の二項展開と関係づけて理解することが出来ます．\n\n\n\n\nTheorem 2 \n\\(n\\) 次式の \\(f(x)\\) について，\\(x=a\\) が \\(k\\) 重解であるための必要十分条件は\n\\[\n\\begin{gather}\nf(a) = f^\\prime(a) = \\cdots = f^{(k-1)}(a) = 0\\\\\nf^{(k)}(a) \\neq 0\n\\end{gather}\n\\]\n\n\n\n\n\n\n\n\n\nNoteProof\n\n\n\n\n\n\\(x=a\\) が \\(k\\) 重解であるということは，\\(f(x) = (x-a)^kg(x), g(a)\\neq 0\\) と同値であることに留意して以下示します．\n ▶  十分性\n\\(\\eqref{eq-poly}\\) より\n\\[\n\\begin{align}\nf(x)\n    &=\\frac{f^{(k)}(a)}{k!}(x-a)^k + \\frac{f^{(k+1)}(a)}{(k+1)!}(x-a)^{k+1} + \\cdots +\\frac{f^{(n)}(a)}{n!}(x-a)^n\\\\\n    &= (x-a)^k\\left\\{\\frac{f^{(k)}(a)}{k!} + \\frac{f^{(k+1)}(a)}{(k+1)!}(x-a)^{1} + \\cdots + \\frac{f^{(n)}(a)}{n!}(x-a)^{n-k}\\right\\}\\\\\n    &= (x-a)^kg(x)\n\\end{align}\n\\]\nこのとき，\\(f^{(k)}(a) \\neq 0\\) より \\(g(a)\\neq 0\\). 以上より，十分性は示せた．\n ▶  必要性\n\\(f(x) = (x-a)^kg(x), g(a)\\neq 0\\) のとき，\\(f(a) = 0\\) は自明． この式を \\(m\\) 回微分するとライプニッツルールより\n\\[\n\\begin{aligned}\nf^{(m)}(x) =& (x-a)^kg^{(m)}(x) + \\left(\\begin{array}{c}m\\\\ 1\\end{array}\\right)k(x-a)^{k-1}g^{(m-1)}(x) \\\\\n            &+ \\cdots + \\left(\\begin{array}{c}m\\\\ m\\end{array}\\right)k(k-1)\\cdots(k-m+1)(x-a)^{k-m}g(x)\n\\end{aligned}\n\\]\n\\(m &lt; k\\) であるならば，\\(f^{(m)}(a) = 0\\)，また \\(m = k\\) であるならば\n\\[\nf^{(k)}(a) = k!g(a) \\neq 0\n\\]\n従って，必要性も示された．\n\n\n\n\nExample 4 \n\\[\nf(x) = x^4 + ax^2 + bx + c = 0\n\\]\nが \\(x=1\\) を３重解に持つようにするようにパラメータを定めたいとします．\n\\[\n\\begin{align}\nf(1) &= 1 + a + b + c = 0\\\\\nf^\\prime(1) &= 4 + 2a + b = 0\\\\\nf^{\\prime\\prime}(1) &= 12 + 2a = 0\\\\\nf^{(3)}(1) &= 24 \\neq 0\\\\\n\\end{align}\n\\]\nこれを解くと，\\((a, b, c) = (-6, 8, -3)\\)．これを用いて整理すると\n\\[\nf(x) = (x-1)^3(x+3)\n\\]\nとなります．\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\n\ndef func_x(x, a, b, c):\n    return x**4 + a*x**2 + b*x + c\n\nx_domain = np.linspace(-4, 4, 100)\n\nplt.plot(x_domain, func_x(x_domain, *(-6, 8, -3)), label='$f(x) = x^4 - 6x^2 + 8x - 3$')\nplt.plot(x_domain, func_x(x_domain, *(-8, 12, -5)), label='$f(x) = (x-1)^2(x^2+2x-5)$')\nplt.xlabel('X')\nplt.ylabel('y')\nplt.axhline(0, color='gray', linestyle='--', linewidth=0.7)\nplt.legend()\nplt.xlim(-4, 4)\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 1"
  },
  {
    "objectID": "posts/2025-07-09-set-operation/index.html",
    "href": "posts/2025-07-09-set-operation/index.html",
    "title": "集合列の和集合・直和・共通部分",
    "section": "",
    "text": "Definition 1 集合列\n集合 \\(\\Gamma\\) が \\(\\mathbb N\\) のとき，集合族 \\(\\{A_\\gamma\\}_{\\gamma\\in \\Gamma}\\) は\n\\[\n\\{A_1, A_2, \\cdots, A_n, \\cdots \\}\n\\]\nと表される．これを集合列という．\n\n集合列の和集合・直和・共通部分\n\\[\n\\begin{align}\n\\text{集合列の和集合:} \\ \\   & \\bigcup_{n=1}^\\infty A_n\\\\\n\\text{集合列の直和:} \\ \\    & \\bigsqcup_{n=1}^\\infty A_n\\\\\n\\text{集合列の共通部分:} \\ \\ & \\bigcap_{n=1}^\\infty A_n\n\\end{align}\n\\]\n\nDefinition 2 上極限集合\n\\[\n\\lim_{n\\to\\infty}\\sup A_n = \\bigcap_{n=1}^\\infty\\bigcup_{k=n}^\\infty A_k\n\\]\n\n\\(x\\in \\bigcap_{n=1}^\\infty\\bigcup_{k=n}^\\infty A_k\\) をまず考えます．これはすべての \\(n\\) に対して\n\\[\nx \\in \\bigcup_{k=n}^\\infty A_k\n\\]\nを意味します．一方，\\(x \\in \\bigcup_{k=n}^\\infty A_k\\) は \\(k\\geq n\\) を満たすある \\(k\\) に対して\n\\[\nx\\in A_k\n\\]\nこれらふたつをあわせると\n\\[\n\\bigcap_{n=1}^\\infty\\bigcup_{k=n}^\\infty A_k = \\{x | \\text{すべての n に対して，ある} k\\geq n \\text{が存在して} x \\in A_k\\}\n\\]\n上極限集合を無限に多くの \\(k\\) に対して \\(x\\in A_k\\) と解釈する\n\\(x\\in\\lim\\sup A_n\\) のとき，ある \\(k_1\\) に対して \\(x \\in A_{k_1}\\) となります．ここで\n\\[\n\\bigcap_{n=1}^\\infty\\bigcup_{k=n}^\\infty A_k = \\left(\\bigcap_{n=1}^{k_1}\\bigcup_{k=n}^{\\infty} A_k\\right) \\bigcap \\left(\\bigcap_{n&gt;k_1}^\\infty\\bigcup_{k=n}^\\infty\\right)\n\\]\nであることから，\\(k\\geq k_1 + 1\\) をみたすある \\(k_2\\) についても\n\\[\nx \\in A_{k_2}\n\\]\nとならなくてはいけません．これを繰り返していくと \\(k_1 &lt; k_2&lt; \\cdots &lt; k_n &lt; \\cdots\\) で\n\\[\nx \\in A_{k_1}, x \\in A_{k_2}, \\cdots, x \\in A_{k_n}, \\cdots\n\\]\nつまり，\\(x\\in\\lim\\sup A_n\\) であるならば，無限に多くの \\(k\\) に対して \\(x\\in A_k\\) ということになります．\n逆に，「無限に多くの \\(k\\) に対して \\(x\\in A_k\\)」であるならば，\n\\[\n\\text{任意の $n$ について $k\\geq n$ を満たす} \\ \\ x\\in A_{k} \\ \\ \\text{となるような $k$ が存在する}\n\\]\nであるので，\n\\[\n\\bigcap_{n=1}^\\infty\\bigcup_{k=n}^\\infty A_k = \\{x | \\text{すべての n に対して，ある} k\\geq n \\text{が存在して} x \\in A_k\\}\n\\]\nが成立します．\n\nDefinition 3 下極限集合\n\\[\n\\lim_{n\\to\\infty}\\inf A_n = \\bigcup_{n=1}^\\infty\\bigcap_{k=n}^\\infty A_k\n\\]\n\n下極限集合は，\n\\[\n\\lim_{n\\to\\infty}\\inf A_n = \\{x | \\text{ある $n$ が存在して，$k\\geq n$ となるようなすべての $k$ について $x \\in A_k$}\\}\n\\]\nと解釈できます\n\nExample 1 supとinfの関係\n\\(i \\in \\mathbb N\\) として，集合 \\(A_i\\) を以下のように定義します\n\\[\nA_i = \\left\\{(x, y) | t_i = 1 - \\frac{1}{i}, (x - t_i)^2 + y^2 &lt; 4\\right\\}\n\\]\nこのとき，\n\\[\n\\begin{align}\n\\lim_{n\\to\\infty} \\sup A_n &= \\text{青の境界を含まない開集合}\\\\\n\\lim_{n\\to\\infty} \\inf A_n &= \\text{黒斜線部のの境界を含まない開集合}\n\\end{align}\n\\]\nまた，\n\\[\n\\lim_{n\\to\\infty} \\inf A_n \\subseteq \\lim_{n\\to\\infty} \\sup A_n\n\\]\nであることがわかります．\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport matplotlib.patches as mpatches\n\nx = np.linspace(-2.5, 3, 1000)\ny = np.linspace(-3, 3, 1000)\nX, Y = np.meshgrid(x, y)\n\n# Intersection region\nregion1 = (X - 1)**2 + Y**2 &lt;= 4\nregion2 = X**2 + Y**2 &lt;= 4\nintersection_common = region1 & region2\n\n# Plot\nplt.figure(figsize=(8, 6))\nplt.contourf(X, Y, region1, levels=[0.5, 1], colors='#B4D7FF', alpha=0.6)\nplt.contour(X, Y, region2, levels=[0.5], colors='black')\nplt.contourf(X, Y, region1, levels=[0.5, 1], colors='none', hatches=['///'])\n\n# 凡例用パッチ作成\npatch_region_sup = mpatches.Patch(color='#B4D7FF', alpha=0.6, label='$\\lim\\sup A_n$')\npatch_region_inf = mpatches.Patch(facecolor='white', hatch='///', label='$\\lim\\inf A_n$', edgecolor='black')\n\nplt.legend(handles=[patch_region_sup, patch_region_inf])\n\nplt.xlabel('x')\nplt.ylabel('y')\nplt.axis('equal')\nplt.grid(True)\nplt.show()\n\n\n\n\n\n\n\n\nFigure 1"
  },
  {
    "objectID": "posts/2025-07-09-set-operation/index.html#上極限集合と下極限集合",
    "href": "posts/2025-07-09-set-operation/index.html#上極限集合と下極限集合",
    "title": "集合列の和集合・直和・共通部分",
    "section": "",
    "text": "Definition 1 集合列\n集合 \\(\\Gamma\\) が \\(\\mathbb N\\) のとき，集合族 \\(\\{A_\\gamma\\}_{\\gamma\\in \\Gamma}\\) は\n\\[\n\\{A_1, A_2, \\cdots, A_n, \\cdots \\}\n\\]\nと表される．これを集合列という．\n\n集合列の和集合・直和・共通部分\n\\[\n\\begin{align}\n\\text{集合列の和集合:} \\ \\   & \\bigcup_{n=1}^\\infty A_n\\\\\n\\text{集合列の直和:} \\ \\    & \\bigsqcup_{n=1}^\\infty A_n\\\\\n\\text{集合列の共通部分:} \\ \\ & \\bigcap_{n=1}^\\infty A_n\n\\end{align}\n\\]\n\nDefinition 2 上極限集合\n\\[\n\\lim_{n\\to\\infty}\\sup A_n = \\bigcap_{n=1}^\\infty\\bigcup_{k=n}^\\infty A_k\n\\]\n\n\\(x\\in \\bigcap_{n=1}^\\infty\\bigcup_{k=n}^\\infty A_k\\) をまず考えます．これはすべての \\(n\\) に対して\n\\[\nx \\in \\bigcup_{k=n}^\\infty A_k\n\\]\nを意味します．一方，\\(x \\in \\bigcup_{k=n}^\\infty A_k\\) は \\(k\\geq n\\) を満たすある \\(k\\) に対して\n\\[\nx\\in A_k\n\\]\nこれらふたつをあわせると\n\\[\n\\bigcap_{n=1}^\\infty\\bigcup_{k=n}^\\infty A_k = \\{x | \\text{すべての n に対して，ある} k\\geq n \\text{が存在して} x \\in A_k\\}\n\\]\n上極限集合を無限に多くの \\(k\\) に対して \\(x\\in A_k\\) と解釈する\n\\(x\\in\\lim\\sup A_n\\) のとき，ある \\(k_1\\) に対して \\(x \\in A_{k_1}\\) となります．ここで\n\\[\n\\bigcap_{n=1}^\\infty\\bigcup_{k=n}^\\infty A_k = \\left(\\bigcap_{n=1}^{k_1}\\bigcup_{k=n}^{\\infty} A_k\\right) \\bigcap \\left(\\bigcap_{n&gt;k_1}^\\infty\\bigcup_{k=n}^\\infty\\right)\n\\]\nであることから，\\(k\\geq k_1 + 1\\) をみたすある \\(k_2\\) についても\n\\[\nx \\in A_{k_2}\n\\]\nとならなくてはいけません．これを繰り返していくと \\(k_1 &lt; k_2&lt; \\cdots &lt; k_n &lt; \\cdots\\) で\n\\[\nx \\in A_{k_1}, x \\in A_{k_2}, \\cdots, x \\in A_{k_n}, \\cdots\n\\]\nつまり，\\(x\\in\\lim\\sup A_n\\) であるならば，無限に多くの \\(k\\) に対して \\(x\\in A_k\\) ということになります．\n逆に，「無限に多くの \\(k\\) に対して \\(x\\in A_k\\)」であるならば，\n\\[\n\\text{任意の $n$ について $k\\geq n$ を満たす} \\ \\ x\\in A_{k} \\ \\ \\text{となるような $k$ が存在する}\n\\]\nであるので，\n\\[\n\\bigcap_{n=1}^\\infty\\bigcup_{k=n}^\\infty A_k = \\{x | \\text{すべての n に対して，ある} k\\geq n \\text{が存在して} x \\in A_k\\}\n\\]\nが成立します．\n\nDefinition 3 下極限集合\n\\[\n\\lim_{n\\to\\infty}\\inf A_n = \\bigcup_{n=1}^\\infty\\bigcap_{k=n}^\\infty A_k\n\\]\n\n下極限集合は，\n\\[\n\\lim_{n\\to\\infty}\\inf A_n = \\{x | \\text{ある $n$ が存在して，$k\\geq n$ となるようなすべての $k$ について $x \\in A_k$}\\}\n\\]\nと解釈できます\n\nExample 1 supとinfの関係\n\\(i \\in \\mathbb N\\) として，集合 \\(A_i\\) を以下のように定義します\n\\[\nA_i = \\left\\{(x, y) | t_i = 1 - \\frac{1}{i}, (x - t_i)^2 + y^2 &lt; 4\\right\\}\n\\]\nこのとき，\n\\[\n\\begin{align}\n\\lim_{n\\to\\infty} \\sup A_n &= \\text{青の境界を含まない開集合}\\\\\n\\lim_{n\\to\\infty} \\inf A_n &= \\text{黒斜線部のの境界を含まない開集合}\n\\end{align}\n\\]\nまた，\n\\[\n\\lim_{n\\to\\infty} \\inf A_n \\subseteq \\lim_{n\\to\\infty} \\sup A_n\n\\]\nであることがわかります．\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport matplotlib.patches as mpatches\n\nx = np.linspace(-2.5, 3, 1000)\ny = np.linspace(-3, 3, 1000)\nX, Y = np.meshgrid(x, y)\n\n# Intersection region\nregion1 = (X - 1)**2 + Y**2 &lt;= 4\nregion2 = X**2 + Y**2 &lt;= 4\nintersection_common = region1 & region2\n\n# Plot\nplt.figure(figsize=(8, 6))\nplt.contourf(X, Y, region1, levels=[0.5, 1], colors='#B4D7FF', alpha=0.6)\nplt.contour(X, Y, region2, levels=[0.5], colors='black')\nplt.contourf(X, Y, region1, levels=[0.5, 1], colors='none', hatches=['///'])\n\n# 凡例用パッチ作成\npatch_region_sup = mpatches.Patch(color='#B4D7FF', alpha=0.6, label='$\\lim\\sup A_n$')\npatch_region_inf = mpatches.Patch(facecolor='white', hatch='///', label='$\\lim\\inf A_n$', edgecolor='black')\n\nplt.legend(handles=[patch_region_sup, patch_region_inf])\n\nplt.xlabel('x')\nplt.ylabel('y')\nplt.axis('equal')\nplt.grid(True)\nplt.show()\n\n\n\n\n\n\n\n\nFigure 1"
  },
  {
    "objectID": "posts/2025-07-09-set-operation/index.html#事象列の上極限集合と下極限集合",
    "href": "posts/2025-07-09-set-operation/index.html#事象列の上極限集合と下極限集合",
    "title": "集合列の和集合・直和・共通部分",
    "section": "事象列の上極限集合と下極限集合",
    "text": "事象列の上極限集合と下極限集合\n\\((\\Omega, \\mathcal{F}, P)\\) を確率空間とします．事象の列 \\(A_n \\in \\mathcal{F}\\) があったとして，\n\\[\n\\lim_{n\\to\\infty}\\sup A_n\n\\]\nを考えてみます．\n\\[\n\\omega \\in \\lim_{n\\to\\infty}\\sup A_n = \\bigcap_{k=1}^\\infty\\bigcup_{n=k}^\\infty A_n\n\\]\nとすれば，\\(\\omega\\) は どんなに大きな\\(k\\) をとってもそれ以降の \\(A_n\\) に必ず含まれることを意味しています．もし \\(\\omega\\) が有限個の \\(\\{A_{n_1}, \\cdots, A_{n_m}\\}\\) にのみ属するならば矛盾してしまうので，無限個の \\(A_n\\) に属していなくてはならないことになります．つまり，\n\n\\(\\mathbb P(\\lim\\sup A_n)\\) は「\\(\\omega \\in A_k\\) を満たすような事象が，たびたび，しかし何回でも起こる確率」と解釈できます\n\n次に，\n\\[\n\\lim_{n\\to\\infty}\\inf A_n\n\\]\nこれは，ある \\(n\\) 以降全ての \\(k\\geq n\\) で \\(\\omega \\in A_k\\) となっているので，\n\n「十分先では常に \\(A_k\\) が起こっているという事象」を意味します．\n\n\n\n\n\n\n\nNote上極限集合の別表記\n\n\n\n\\(\\mathbb P(\\lim\\sup A_n)\\) は「\\(\\omega \\in A_k\\) を満たすような事象が，たびたび，しかし何回でも起こる確率」と解釈できることから\n\\[\nP(A_k\\ , \\ \\text{i.o.})\n\\]\nと表記する場合もあります．i.o. は infinitely oftenの略です．"
  },
  {
    "objectID": "posts/2025-07-09-set-operation/index.html#references",
    "href": "posts/2025-07-09-set-operation/index.html#references",
    "title": "集合列の和集合・直和・共通部分",
    "section": "References",
    "text": "References\n\n統計学への確率論，その先へ: ゼロからの測度論的理解と漸近理論への架け橋"
  },
  {
    "objectID": "posts/2025-06-12-moles-and-gas-volume/index.html",
    "href": "posts/2025-06-12-moles-and-gas-volume/index.html",
    "title": "物質量と気体の体積",
    "section": "",
    "text": "物質の量を表すときには，質量や体積を用いることが多いです．しかし，物質が化学変化するときには，物質を構成する原子，分子，イオンなどの粒子の結合の組み合わせが変化 します．そのため，化学で物質の量を表すときには，その中に含まれる粒子の「個数」で考えると便利になります．この粒子の個数に着目して表した物質の量を「物質量」といい，モル (mol) という単位で 表します．\n\nDefinition 1 (アボガドロ定数) \n原子や分子 1 mol あたりの粒子の数を示す次元をもつ物理量で\n\\[\nN_A = 6.0 \\times 10^{23} \\text{/mol}\n\\]\n\n質量数 12 の炭素原子 \\(\\,^{12}\\text{C}\\) は \\(1.99 \\times 10^{-23}\\) g という決まった質量を持ちますがこのときの炭素原子の数は\n\\[\n\\frac{12\\text{g}}{1.99 \\times 10^{-23}} \\approx 6.0 \\times 10^{23}\n\\]\n計算でき，これをアボガドロ数といいます．アボガドロ数に \\(\\text{mol}^{-1}\\) の単位をつけたのがアボガドロ定数です．物質 \\(1\\) molあたりの質量を モル質量 [g/mol] と呼びます．\n\nExample 1 (実験でアボガドロ定数を求める) \n１円玉は1gのアルミニウムからできています．室温でのアルミニウム密度は2.7\\(\\text{g/cm}^3\\)なので体積は\n\\[\n\\text{1円玉体積} = \\frac{1\\text{g}}{2.7\\text{g/cm}^3} = 1/2.7\\text{cm}^3\n\\]\n金属の固体では，金属の原子が規則正しく配列して金属結晶をつくっていて，結晶中の規則的な粒子の配列を結晶格子といいますその中に現れる最小の繰り返し単位を「単位格子」といい，アルミニウムは 面心立方格子の構造で，1 辺の長さが \\(4.04 × 10^{-8}\\) cm の立方体（単位格子）中に原子が正味４個分，含まれています．\n以上より\n\\[\nN_A = \\frac{\\text{1円玉体積[cm]}^3}{\\text{単位格子体積[cm]}^3} \\times 4 \\times \\frac{\\text{アルミニウムモル質量[g/mol]}}{\\text{1円玉質量[g]}}\n\\]\nとなるはずなので\n\n\nCode\nimport numpy as np\n\ncoin_volumn = np.float64(1 / 2.7)\ngrid_length = np.float64(4.04 * 10 ** (-8))\nal_mol_mass = np.float64(27)\n\nnumber_of_molecules = coin_volumn / (grid_length ** 3) * 4 * al_mol_mass\n\nprint(f\"{{{number_of_molecules:.2e}}}\")\n\n\n{6.07e+23}\n\n\nよってアボガドロ定数が計算できました．\n\n\n\nDefinition 2 (アボガドロの法則) \n同温・同圧で同体積の気体の中には，気体の種類によらず，同数の分子が含まれる．\n\n実測によると [0℃, \\(1.013 \\times 10^5\\) Pa] において，多くの気体 \\(1\\) mol の体積は 22.4 Lになります． この物質 1 molあたりの体積をモル体積と呼び，標準気圧での気体のモル体積は 22.4L/mol になります．\n気体の物質量はこの関係式を用いると以下のように求めることができます\n\\[\n\\text{気体の物質量[mol]} = \\frac{\\text{標準状態での気体の体積[L]}}{22.4 \\text{L/mol}}\n\\]\n\nExample 2 (二酸化炭素の体積を求める) \n二酸化炭素の個体である「ドライアイス」が11g与えられているとき，これを [0℃, \\(1.013 \\times 10^5\\) Pa] のもとで気化させたときの二酸化炭素の体積を求めてみます．\nまず二酸化炭素 \\(\\text{CO}_2\\) は \\(44 \\text{g/mol} = 12 + 2\\times 16\\) とします．\n\n\n\n\n元素名\n元素記号\n原子番号\n原子量\n\n\n\n\n炭素\nC\n6\n12.0107\n\n\n酸素\nO\n8\n15.9994\n\n\n\n\n11.0gのドライアイスの物質量は\n\\[\n\\frac{11.0\\text{g}}{44 \\text{g/mol}} = 0.25\\text{mol}\n\\]\nアボガドロの法則より， [0℃, \\(1.013 \\times 10^5\\) Pa] において，気体 \\(1\\) mol の体積は 22.4 Lになるので，気化した二酸化炭素の体積は\n\\[\n22.4\\text{L/mol} \\times 0.25\\text{mol} = 5.6 \\text{L}\n\\]\nと推定することができます．室温（約23℃）でドライアイスを昇華させたとき，1 mol の二酸化炭素が占める体積は 22.4 L にはなりません．直感的イメージとして， ボイル・シャルルの法則より同じ気体のもとでは温度と体積は比例するので，もうすこし大きい体積となります．\n\n\n\nExample 3 (一般気体定数) \n1 molの気体は，アボガドロの法則より，気体の種類関係なく同温・同圧で同体積の気体の中に同数の分子が含まれます．ボイル=シャルルの法則という理想気体の性質に関する経験法則，及び \\(0 \\,^\\circ\\text{C}\\), 1気圧(\\(1.013\\times 10^5\\) [Pa]) の標準状態では22.4Lの体積の中に含まれることから気体定数を以下のように計算できます\n\\[\n\\begin{align}\nR_0\n  &= \\frac{pv}{T}\\\\\n  &= \\frac{1.013 \\times 10^5 \\times 22.4}{273 \\times 10^3}\\\\\n  &= 8.31 \\text{[J/mol}\\cdot\\text{K]}\n\\end{align}\n\\]\nこれを \\(n\\) モルの理想気体に当てはめると\n\\[\npv = nR_0T\n\\]\nという理想気体の状態方程式を得ます．\n\n\n\n密度は単位体積あたりの質量を表した物理量で，固体・液体の密度は [g/cm3]，気体の密度は体積１ L あたりの質量 [g/L] の単位で表します． つまり，気体 1L あたりの質量を「気体の密度」になります．\n\n\n\n\n\n\nNoteシャボン玉でガス缶の中身を調べる\n\n\n\n\n水素 \\(\\text{H}_2\\), 酸素 \\(\\text{O}_2\\), 二酸化炭素 \\(\\text{CO}_2\\) がそれぞれ充填された３つのガス缶がある\nどの缶にどの気体が入っているのかわからない\n\nこのとき，どの缶にどの気体が入っているか知りたいとします．調べる一つの方法として，各気体で同じ大きさくらいに膨らませたシャボン玉をつくり密度を比較する方法が有ります． 標準状態における気体の密度は\n\\[\n\\frac{\\text{分子量[g]}}{22.4\\text{L/mol}}\n\\]\nで計算できるので，\n\\[\n\\begin{align}\n\\text{H}_2\\text{の密度} &= \\frac{2.0}{22.4} \\approx 0.089\\text{g/L}\\\\\n\\text{O}_2\\text{の密度} &= \\frac{32}{22.4} \\approx 1.4\\text{g/L}\\\\\n\\text{CO}_2\\text{の密度} &= \\frac{44}{22.4} \\approx 2.0\\text{g/L}\n\\end{align}\n\\]\n密度が重いほど，同じ環境下では下降速度は速くなることから．同程度の大きさのシャボン玉で下降するとき速さを比較すれば，どの缶にどんな気体が入っているのか推測することができます．\nなお，空気の平均分子量は，空気の組成を \\(\\text{N}_2 : \\text{O}_2 = 4:1\\) とすると\n\\[\n\\text{空気の平均分子量} = 28 \\times 0.8 + 32 \\times 0.2 = 28.8 \\text{g/mol}\n\\]\nとなることから，各期待の密度を計算するまでもなく，水素が入ったシャボン玉は上昇し，酸素が入ったシャボン玉は比較的ゆっくり下降，二酸化炭素が入ったシャボン玉は酸素のシャボン玉より速く下降するとわかります．\n\n\n\n\n\n気体の内部エネルギーを，温度 \\(T\\) と体積 \\(V\\) を独立変数として，\\(U = U(T, V)\\) と表すと\n\\[\n\\operatorname{grad} U \\equiv \\left(\\left(\\frac{\\partial U}{\\partial T}\\right)_V, \\left(\\frac{\\partial U}{\\partial V}\\right)_T\\right)\n\\]\nこれをもちいて整理すると\n\\[\ndU = \\left(\\frac{\\partial U}{\\partial T}\\right)_VdT + \\left(\\frac{\\partial U}{\\partial V}\\right)_TdV\n\\]\n熱力学第一法則より 気体が外部になす微小仕事 \\(dW = PdV\\) より\n\\[\ndQ =  \\left(\\frac{\\partial U}{\\partial T}\\right)_VdT + \\left[ \\left(\\frac{\\partial U}{\\partial V}\\right)_T + P\\right]dV \\label{temp-vol-eq}\n\\]\n\n\n体積一定の容器に入れた気体に熱を加える場合を考えます．\\(\\eqref{temp-vol-eq}\\) で \\(dV = 0\\) とおけるので\n\\[\ndQ =  \\left(\\frac{\\partial U}{\\partial T}\\right)_VdT\n\\]\nここから体積一定のもとで，気体の温度を単位温度上げるのに必要な熱量は\n\\[\n\\frac{dQ}{dT} = \\left(\\frac{\\partial U}{\\partial T}\\right)_V\n\\]\nこれをモル数 \\(n\\) で割ると定積モル比熱になります．\n\nDefinition 3 定積モル比熱\n定積モル比熱 \\(C_v\\) [J/mol･K] は以下のように定義される\n\\[\nC_v = \\frac{1}{n} \\left(\\frac{\\partial Q}{\\partial T}\\right)_V = \\frac{1}{n} \\left(\\frac{\\partial U}{\\partial T}\\right)_V\n\\]\n\n圧力一定の条件下で1モルあたりの物質の温度を 1 K 上げるのに必要な熱量を考えます．これは定圧モル比熱 \\(C_p\\) と呼び，\n\\[\nC_p = C_v + \\left[ \\left(\\frac{\\partial U}{\\partial V}\\right)_T + P\\right]\\frac{1}{n}\\left(\\frac{\\partial V}{\\partial T}\\right)_P\n\\]\nマイヤーの関係式\n単原子分子理想気体では状態方程式\n\\[\n\\frac{PV}{T} = nR\n\\]\nが成立するので\n\\[\n\\left(\\frac{\\partial V}{\\partial T}\\right)_P = n\\frac{R}{P}\n\\]\nまた，内部エネルギーも\n\\[\nU = \\frac{3}{2}nRT\n\\]\nであるので \\(\\displaystyle  \\left(\\frac{\\partial U}{\\partial V}\\right)_T  = 0\\) より\n\\[\nC_p = C_v + R\n\\]\nというマイヤーの関係式が得られます．\n\n\n\n\n\nExercise 1 センター2016物理追試第５問「ぶら下がるシリンダーと熱力学第１法則」\n\n\nシリンダーが (a) の状態で静止しているとき，\\(P\\) を \\(P_0, M, g, S\\) の関数として表せ\nシリンダー内の気体を温めると，シリンダーはゆっくり下降し，(b) の状態で静止した．このとき，体積の変化 \\(\\Delta V\\) と 内部エネルギー \\(\\Delta U\\) は \\(\\Delta T\\) の関数としてどのように表せるか？\n\n\n\n\n\n\n\n\nNoteSolution\n\n\n\n\n\n1. シリンダーが (a) の状態で静止しているとき，\\(P\\) を \\(P_0, M, g, S\\) の関数として表せ\n下向きの力の一つとして\n\\[\n\\text{質量} \\times \\text{加速度} = \\text{力}\n\\]\nよって, \\(Mg\\) という力が下向きに働いています． また，シリンダー内部の圧力 \\(P\\) も下向きの力として働くので\n\\[\n\\text{下向きの力} = S\\times P + Mg\n\\]\n上向きの力として，\\(P_0\\times S\\) があり，初期状態では静止している = 上向きと下向きの力が均衡しているので\n\\[\nS\\times P + Mg = S\\times P_0\n\\]\nしたがって，\n\\[\nP = P_0 = \\frac{Mg}{S}\n\\]\n2. シリンダー内の気体を温めると，シリンダーはゆっくり下降し，(b) の状態で静止した．このとき，体積の変化 \\(\\Delta V\\) と 内部エネルギー \\(\\Delta U\\) は \\(\\Delta T\\) の関数としてどのように表せるか？\n単原子分子理想気体では内部エネルギーは\n\\[\nU = \\frac{3}{2}RT\n\\]\nしたがって\n\\[\n\\Delta U = \\frac{3}{2}R\\Delta T\n\\]\nまた，状態変化後も圧力は \\(P\\) で同じなので，理想気体の状態方程式より\n\\[\n\\frac{V}{T} = \\frac{V + \\Delta V}{T + \\Delta T}\n\\]\nしたがって，\n\\[\n\\Delta V = \\frac{V}{T}\\Delta T\n\\]\n\n\n\n\nExercise 2 運動エネルギーと温度と圧力\n密閉された炉に一箇所小さな孔が空いている．\n\n孔の厚さは0\n炉外の空気は温度が0℃で圧力は100kPa\n炉内の空気は温度調整して57℃で一定\n空気は理想気体とする\n\n十分時間が経った後は圧力が一定になるとして，この定常的な状態での炉内の圧力を求めよ．\nただし，分子の自乗平均速度は平均速度の自乗と一致するとする．\n\n\n\n\n\n\n\nNoteSolution\n\n\n\n\n\n炉内を1，炉外を2とすると，平衡状態では炉外へ出る分子と炉外から入る分子の数が等しいはずなので，\n\\[\nAv_1N_1t = Av_2N_2t\n\\]\n\n\\(v_i\\) 分子の平均速度\n\\(A\\): 孔の断面積\n\\(N_i\\): 個数密度\n\\(t\\): 単位時間\n\n理想気体においては\n\\[\n\\frac{3}{2}k_BT = \\frac{1}{2}m\\overline{v^2}\n\\]\nと温度は自乗平均速度に比例する．また理想気体の状態方程式より，個数密度は圧力 \\(P\\) に比例し，温度 \\(T\\) に反比例するので\n\\[\n\\begin{align}\n\\frac{v_1}{v_2} &= \\sqrt{\\frac{T_1}{T_2}}\\\\\n\\frac{N_1}{N_2} &= \\frac{P_1}{P_2}\\frac{T_2}{T_1}\n\\end{align}\n\\]\nしたがって，\n\\[\n\\begin{align}\np_1\n  &= p_2\\sqrt{\\frac{T_1}{T_2}}\\\\\n  &= 100\\text{kPa} \\times \\sqrt{\\frac{330.15}{273.15}}\\\\\n  &\\approx 110\\text{kPa}\n\\end{align}\n\\]"
  },
  {
    "objectID": "posts/2025-06-12-moles-and-gas-volume/index.html#物質量",
    "href": "posts/2025-06-12-moles-and-gas-volume/index.html#物質量",
    "title": "物質量と気体の体積",
    "section": "",
    "text": "物質の量を表すときには，質量や体積を用いることが多いです．しかし，物質が化学変化するときには，物質を構成する原子，分子，イオンなどの粒子の結合の組み合わせが変化 します．そのため，化学で物質の量を表すときには，その中に含まれる粒子の「個数」で考えると便利になります．この粒子の個数に着目して表した物質の量を「物質量」といい，モル (mol) という単位で 表します．\n\nDefinition 1 (アボガドロ定数) \n原子や分子 1 mol あたりの粒子の数を示す次元をもつ物理量で\n\\[\nN_A = 6.0 \\times 10^{23} \\text{/mol}\n\\]\n\n質量数 12 の炭素原子 \\(\\,^{12}\\text{C}\\) は \\(1.99 \\times 10^{-23}\\) g という決まった質量を持ちますがこのときの炭素原子の数は\n\\[\n\\frac{12\\text{g}}{1.99 \\times 10^{-23}} \\approx 6.0 \\times 10^{23}\n\\]\n計算でき，これをアボガドロ数といいます．アボガドロ数に \\(\\text{mol}^{-1}\\) の単位をつけたのがアボガドロ定数です．物質 \\(1\\) molあたりの質量を モル質量 [g/mol] と呼びます．\n\nExample 1 (実験でアボガドロ定数を求める) \n１円玉は1gのアルミニウムからできています．室温でのアルミニウム密度は2.7\\(\\text{g/cm}^3\\)なので体積は\n\\[\n\\text{1円玉体積} = \\frac{1\\text{g}}{2.7\\text{g/cm}^3} = 1/2.7\\text{cm}^3\n\\]\n金属の固体では，金属の原子が規則正しく配列して金属結晶をつくっていて，結晶中の規則的な粒子の配列を結晶格子といいますその中に現れる最小の繰り返し単位を「単位格子」といい，アルミニウムは 面心立方格子の構造で，1 辺の長さが \\(4.04 × 10^{-8}\\) cm の立方体（単位格子）中に原子が正味４個分，含まれています．\n以上より\n\\[\nN_A = \\frac{\\text{1円玉体積[cm]}^3}{\\text{単位格子体積[cm]}^3} \\times 4 \\times \\frac{\\text{アルミニウムモル質量[g/mol]}}{\\text{1円玉質量[g]}}\n\\]\nとなるはずなので\n\n\nCode\nimport numpy as np\n\ncoin_volumn = np.float64(1 / 2.7)\ngrid_length = np.float64(4.04 * 10 ** (-8))\nal_mol_mass = np.float64(27)\n\nnumber_of_molecules = coin_volumn / (grid_length ** 3) * 4 * al_mol_mass\n\nprint(f\"{{{number_of_molecules:.2e}}}\")\n\n\n{6.07e+23}\n\n\nよってアボガドロ定数が計算できました．\n\n\n\nDefinition 2 (アボガドロの法則) \n同温・同圧で同体積の気体の中には，気体の種類によらず，同数の分子が含まれる．\n\n実測によると [0℃, \\(1.013 \\times 10^5\\) Pa] において，多くの気体 \\(1\\) mol の体積は 22.4 Lになります． この物質 1 molあたりの体積をモル体積と呼び，標準気圧での気体のモル体積は 22.4L/mol になります．\n気体の物質量はこの関係式を用いると以下のように求めることができます\n\\[\n\\text{気体の物質量[mol]} = \\frac{\\text{標準状態での気体の体積[L]}}{22.4 \\text{L/mol}}\n\\]\n\nExample 2 (二酸化炭素の体積を求める) \n二酸化炭素の個体である「ドライアイス」が11g与えられているとき，これを [0℃, \\(1.013 \\times 10^5\\) Pa] のもとで気化させたときの二酸化炭素の体積を求めてみます．\nまず二酸化炭素 \\(\\text{CO}_2\\) は \\(44 \\text{g/mol} = 12 + 2\\times 16\\) とします．\n\n\n\n\n元素名\n元素記号\n原子番号\n原子量\n\n\n\n\n炭素\nC\n6\n12.0107\n\n\n酸素\nO\n8\n15.9994\n\n\n\n\n11.0gのドライアイスの物質量は\n\\[\n\\frac{11.0\\text{g}}{44 \\text{g/mol}} = 0.25\\text{mol}\n\\]\nアボガドロの法則より， [0℃, \\(1.013 \\times 10^5\\) Pa] において，気体 \\(1\\) mol の体積は 22.4 Lになるので，気化した二酸化炭素の体積は\n\\[\n22.4\\text{L/mol} \\times 0.25\\text{mol} = 5.6 \\text{L}\n\\]\nと推定することができます．室温（約23℃）でドライアイスを昇華させたとき，1 mol の二酸化炭素が占める体積は 22.4 L にはなりません．直感的イメージとして， ボイル・シャルルの法則より同じ気体のもとでは温度と体積は比例するので，もうすこし大きい体積となります．\n\n\n\nExample 3 (一般気体定数) \n1 molの気体は，アボガドロの法則より，気体の種類関係なく同温・同圧で同体積の気体の中に同数の分子が含まれます．ボイル=シャルルの法則という理想気体の性質に関する経験法則，及び \\(0 \\,^\\circ\\text{C}\\), 1気圧(\\(1.013\\times 10^5\\) [Pa]) の標準状態では22.4Lの体積の中に含まれることから気体定数を以下のように計算できます\n\\[\n\\begin{align}\nR_0\n  &= \\frac{pv}{T}\\\\\n  &= \\frac{1.013 \\times 10^5 \\times 22.4}{273 \\times 10^3}\\\\\n  &= 8.31 \\text{[J/mol}\\cdot\\text{K]}\n\\end{align}\n\\]\nこれを \\(n\\) モルの理想気体に当てはめると\n\\[\npv = nR_0T\n\\]\nという理想気体の状態方程式を得ます．\n\n\n\n密度は単位体積あたりの質量を表した物理量で，固体・液体の密度は [g/cm3]，気体の密度は体積１ L あたりの質量 [g/L] の単位で表します． つまり，気体 1L あたりの質量を「気体の密度」になります．\n\n\n\n\n\n\nNoteシャボン玉でガス缶の中身を調べる\n\n\n\n\n水素 \\(\\text{H}_2\\), 酸素 \\(\\text{O}_2\\), 二酸化炭素 \\(\\text{CO}_2\\) がそれぞれ充填された３つのガス缶がある\nどの缶にどの気体が入っているのかわからない\n\nこのとき，どの缶にどの気体が入っているか知りたいとします．調べる一つの方法として，各気体で同じ大きさくらいに膨らませたシャボン玉をつくり密度を比較する方法が有ります． 標準状態における気体の密度は\n\\[\n\\frac{\\text{分子量[g]}}{22.4\\text{L/mol}}\n\\]\nで計算できるので，\n\\[\n\\begin{align}\n\\text{H}_2\\text{の密度} &= \\frac{2.0}{22.4} \\approx 0.089\\text{g/L}\\\\\n\\text{O}_2\\text{の密度} &= \\frac{32}{22.4} \\approx 1.4\\text{g/L}\\\\\n\\text{CO}_2\\text{の密度} &= \\frac{44}{22.4} \\approx 2.0\\text{g/L}\n\\end{align}\n\\]\n密度が重いほど，同じ環境下では下降速度は速くなることから．同程度の大きさのシャボン玉で下降するとき速さを比較すれば，どの缶にどんな気体が入っているのか推測することができます．\nなお，空気の平均分子量は，空気の組成を \\(\\text{N}_2 : \\text{O}_2 = 4:1\\) とすると\n\\[\n\\text{空気の平均分子量} = 28 \\times 0.8 + 32 \\times 0.2 = 28.8 \\text{g/mol}\n\\]\nとなることから，各期待の密度を計算するまでもなく，水素が入ったシャボン玉は上昇し，酸素が入ったシャボン玉は比較的ゆっくり下降，二酸化炭素が入ったシャボン玉は酸素のシャボン玉より速く下降するとわかります．\n\n\n\n\n\n気体の内部エネルギーを，温度 \\(T\\) と体積 \\(V\\) を独立変数として，\\(U = U(T, V)\\) と表すと\n\\[\n\\operatorname{grad} U \\equiv \\left(\\left(\\frac{\\partial U}{\\partial T}\\right)_V, \\left(\\frac{\\partial U}{\\partial V}\\right)_T\\right)\n\\]\nこれをもちいて整理すると\n\\[\ndU = \\left(\\frac{\\partial U}{\\partial T}\\right)_VdT + \\left(\\frac{\\partial U}{\\partial V}\\right)_TdV\n\\]\n熱力学第一法則より 気体が外部になす微小仕事 \\(dW = PdV\\) より\n\\[\ndQ =  \\left(\\frac{\\partial U}{\\partial T}\\right)_VdT + \\left[ \\left(\\frac{\\partial U}{\\partial V}\\right)_T + P\\right]dV \\label{temp-vol-eq}\n\\]\n\n\n体積一定の容器に入れた気体に熱を加える場合を考えます．\\(\\eqref{temp-vol-eq}\\) で \\(dV = 0\\) とおけるので\n\\[\ndQ =  \\left(\\frac{\\partial U}{\\partial T}\\right)_VdT\n\\]\nここから体積一定のもとで，気体の温度を単位温度上げるのに必要な熱量は\n\\[\n\\frac{dQ}{dT} = \\left(\\frac{\\partial U}{\\partial T}\\right)_V\n\\]\nこれをモル数 \\(n\\) で割ると定積モル比熱になります．\n\nDefinition 3 定積モル比熱\n定積モル比熱 \\(C_v\\) [J/mol･K] は以下のように定義される\n\\[\nC_v = \\frac{1}{n} \\left(\\frac{\\partial Q}{\\partial T}\\right)_V = \\frac{1}{n} \\left(\\frac{\\partial U}{\\partial T}\\right)_V\n\\]\n\n圧力一定の条件下で1モルあたりの物質の温度を 1 K 上げるのに必要な熱量を考えます．これは定圧モル比熱 \\(C_p\\) と呼び，\n\\[\nC_p = C_v + \\left[ \\left(\\frac{\\partial U}{\\partial V}\\right)_T + P\\right]\\frac{1}{n}\\left(\\frac{\\partial V}{\\partial T}\\right)_P\n\\]\nマイヤーの関係式\n単原子分子理想気体では状態方程式\n\\[\n\\frac{PV}{T} = nR\n\\]\nが成立するので\n\\[\n\\left(\\frac{\\partial V}{\\partial T}\\right)_P = n\\frac{R}{P}\n\\]\nまた，内部エネルギーも\n\\[\nU = \\frac{3}{2}nRT\n\\]\nであるので \\(\\displaystyle  \\left(\\frac{\\partial U}{\\partial V}\\right)_T  = 0\\) より\n\\[\nC_p = C_v + R\n\\]\nというマイヤーの関係式が得られます．\n\n\n\n\n\nExercise 1 センター2016物理追試第５問「ぶら下がるシリンダーと熱力学第１法則」\n\n\nシリンダーが (a) の状態で静止しているとき，\\(P\\) を \\(P_0, M, g, S\\) の関数として表せ\nシリンダー内の気体を温めると，シリンダーはゆっくり下降し，(b) の状態で静止した．このとき，体積の変化 \\(\\Delta V\\) と 内部エネルギー \\(\\Delta U\\) は \\(\\Delta T\\) の関数としてどのように表せるか？\n\n\n\n\n\n\n\n\nNoteSolution\n\n\n\n\n\n1. シリンダーが (a) の状態で静止しているとき，\\(P\\) を \\(P_0, M, g, S\\) の関数として表せ\n下向きの力の一つとして\n\\[\n\\text{質量} \\times \\text{加速度} = \\text{力}\n\\]\nよって, \\(Mg\\) という力が下向きに働いています． また，シリンダー内部の圧力 \\(P\\) も下向きの力として働くので\n\\[\n\\text{下向きの力} = S\\times P + Mg\n\\]\n上向きの力として，\\(P_0\\times S\\) があり，初期状態では静止している = 上向きと下向きの力が均衡しているので\n\\[\nS\\times P + Mg = S\\times P_0\n\\]\nしたがって，\n\\[\nP = P_0 = \\frac{Mg}{S}\n\\]\n2. シリンダー内の気体を温めると，シリンダーはゆっくり下降し，(b) の状態で静止した．このとき，体積の変化 \\(\\Delta V\\) と 内部エネルギー \\(\\Delta U\\) は \\(\\Delta T\\) の関数としてどのように表せるか？\n単原子分子理想気体では内部エネルギーは\n\\[\nU = \\frac{3}{2}RT\n\\]\nしたがって\n\\[\n\\Delta U = \\frac{3}{2}R\\Delta T\n\\]\nまた，状態変化後も圧力は \\(P\\) で同じなので，理想気体の状態方程式より\n\\[\n\\frac{V}{T} = \\frac{V + \\Delta V}{T + \\Delta T}\n\\]\nしたがって，\n\\[\n\\Delta V = \\frac{V}{T}\\Delta T\n\\]\n\n\n\n\nExercise 2 運動エネルギーと温度と圧力\n密閉された炉に一箇所小さな孔が空いている．\n\n孔の厚さは0\n炉外の空気は温度が0℃で圧力は100kPa\n炉内の空気は温度調整して57℃で一定\n空気は理想気体とする\n\n十分時間が経った後は圧力が一定になるとして，この定常的な状態での炉内の圧力を求めよ．\nただし，分子の自乗平均速度は平均速度の自乗と一致するとする．\n\n\n\n\n\n\n\nNoteSolution\n\n\n\n\n\n炉内を1，炉外を2とすると，平衡状態では炉外へ出る分子と炉外から入る分子の数が等しいはずなので，\n\\[\nAv_1N_1t = Av_2N_2t\n\\]\n\n\\(v_i\\) 分子の平均速度\n\\(A\\): 孔の断面積\n\\(N_i\\): 個数密度\n\\(t\\): 単位時間\n\n理想気体においては\n\\[\n\\frac{3}{2}k_BT = \\frac{1}{2}m\\overline{v^2}\n\\]\nと温度は自乗平均速度に比例する．また理想気体の状態方程式より，個数密度は圧力 \\(P\\) に比例し，温度 \\(T\\) に反比例するので\n\\[\n\\begin{align}\n\\frac{v_1}{v_2} &= \\sqrt{\\frac{T_1}{T_2}}\\\\\n\\frac{N_1}{N_2} &= \\frac{P_1}{P_2}\\frac{T_2}{T_1}\n\\end{align}\n\\]\nしたがって，\n\\[\n\\begin{align}\np_1\n  &= p_2\\sqrt{\\frac{T_1}{T_2}}\\\\\n  &= 100\\text{kPa} \\times \\sqrt{\\frac{330.15}{273.15}}\\\\\n  &\\approx 110\\text{kPa}\n\\end{align}\n\\]"
  },
  {
    "objectID": "posts/2025-06-12-moles-and-gas-volume/index.html#気体の内部エネルギーとモル比熱",
    "href": "posts/2025-06-12-moles-and-gas-volume/index.html#気体の内部エネルギーとモル比熱",
    "title": "物質量と気体の体積",
    "section": "",
    "text": "気体の内部エネルギーを，温度 \\(T\\) と体積 \\(V\\) を独立変数として，\\(U = U(T, V)\\) と表すと\n\\[\n\\operatorname{grad} U \\equiv \\left(\\left(\\frac{\\partial U}{\\partial T}\\right)_V, \\left(\\frac{\\partial U}{\\partial V}\\right)_T\\right)\n\\]\nこれをもちいて整理すると\n\\[\ndU = \\left(\\frac{\\partial U}{\\partial T}\\right)_VdT + \\left(\\frac{\\partial U}{\\partial V}\\right)_TdV\n\\]\n熱力学第一法則より 気体が外部になす微小仕事 \\(dW = PdV\\) より\n\\[\ndQ =  \\left(\\frac{\\partial U}{\\partial T}\\right)_VdT + \\left[ \\left(\\frac{\\partial U}{\\partial V}\\right)_T + P\\right]dV \\label{temp-vol-eq}\n\\]\n\n\n体積一定の容器に入れた気体に熱を加える場合を考えます．\\(\\eqref{temp-vol-eq}\\) で \\(dV = 0\\) とおけるので\n\\[\ndQ =  \\left(\\frac{\\partial U}{\\partial T}\\right)_VdT\n\\]\nここから体積一定のもとで，気体の温度を単位温度上げるのに必要な熱量は\n\\[\n\\frac{dQ}{dT} = \\left(\\frac{\\partial U}{\\partial T}\\right)_V\n\\]\nこれをモル数 \\(n\\) で割ると定積モル比熱になります．\n\nDefinition 3 定積モル比熱\n定積モル比熱 \\(C_v\\) [J/mol･K] は以下のように定義される\n\\[\nC_v = \\frac{1}{n} \\left(\\frac{\\partial Q}{\\partial T}\\right)_V = \\frac{1}{n} \\left(\\frac{\\partial U}{\\partial T}\\right)_V\n\\]\n\n圧力一定の条件下で1モルあたりの物質の温度を 1 K 上げるのに必要な熱量を考えます．これは定圧モル比熱 \\(C_p\\) と呼び，\n\\[\nC_p = C_v + \\left[ \\left(\\frac{\\partial U}{\\partial V}\\right)_T + P\\right]\\frac{1}{n}\\left(\\frac{\\partial V}{\\partial T}\\right)_P\n\\]\nマイヤーの関係式\n単原子分子理想気体では状態方程式\n\\[\n\\frac{PV}{T} = nR\n\\]\nが成立するので\n\\[\n\\left(\\frac{\\partial V}{\\partial T}\\right)_P = n\\frac{R}{P}\n\\]\nまた，内部エネルギーも\n\\[\nU = \\frac{3}{2}nRT\n\\]\nであるので \\(\\displaystyle  \\left(\\frac{\\partial U}{\\partial V}\\right)_T  = 0\\) より\n\\[\nC_p = C_v + R\n\\]\nというマイヤーの関係式が得られます．"
  },
  {
    "objectID": "posts/2025-06-12-moles-and-gas-volume/index.html#理解度チェック",
    "href": "posts/2025-06-12-moles-and-gas-volume/index.html#理解度チェック",
    "title": "物質量と気体の体積",
    "section": "",
    "text": "Exercise 1 センター2016物理追試第５問「ぶら下がるシリンダーと熱力学第１法則」\n\n\nシリンダーが (a) の状態で静止しているとき，\\(P\\) を \\(P_0, M, g, S\\) の関数として表せ\nシリンダー内の気体を温めると，シリンダーはゆっくり下降し，(b) の状態で静止した．このとき，体積の変化 \\(\\Delta V\\) と 内部エネルギー \\(\\Delta U\\) は \\(\\Delta T\\) の関数としてどのように表せるか？\n\n\n\n\n\n\n\n\nNoteSolution\n\n\n\n\n\n1. シリンダーが (a) の状態で静止しているとき，\\(P\\) を \\(P_0, M, g, S\\) の関数として表せ\n下向きの力の一つとして\n\\[\n\\text{質量} \\times \\text{加速度} = \\text{力}\n\\]\nよって, \\(Mg\\) という力が下向きに働いています． また，シリンダー内部の圧力 \\(P\\) も下向きの力として働くので\n\\[\n\\text{下向きの力} = S\\times P + Mg\n\\]\n上向きの力として，\\(P_0\\times S\\) があり，初期状態では静止している = 上向きと下向きの力が均衡しているので\n\\[\nS\\times P + Mg = S\\times P_0\n\\]\nしたがって，\n\\[\nP = P_0 = \\frac{Mg}{S}\n\\]\n2. シリンダー内の気体を温めると，シリンダーはゆっくり下降し，(b) の状態で静止した．このとき，体積の変化 \\(\\Delta V\\) と 内部エネルギー \\(\\Delta U\\) は \\(\\Delta T\\) の関数としてどのように表せるか？\n単原子分子理想気体では内部エネルギーは\n\\[\nU = \\frac{3}{2}RT\n\\]\nしたがって\n\\[\n\\Delta U = \\frac{3}{2}R\\Delta T\n\\]\nまた，状態変化後も圧力は \\(P\\) で同じなので，理想気体の状態方程式より\n\\[\n\\frac{V}{T} = \\frac{V + \\Delta V}{T + \\Delta T}\n\\]\nしたがって，\n\\[\n\\Delta V = \\frac{V}{T}\\Delta T\n\\]\n\n\n\n\nExercise 2 運動エネルギーと温度と圧力\n密閉された炉に一箇所小さな孔が空いている．\n\n孔の厚さは0\n炉外の空気は温度が0℃で圧力は100kPa\n炉内の空気は温度調整して57℃で一定\n空気は理想気体とする\n\n十分時間が経った後は圧力が一定になるとして，この定常的な状態での炉内の圧力を求めよ．\nただし，分子の自乗平均速度は平均速度の自乗と一致するとする．\n\n\n\n\n\n\n\nNoteSolution\n\n\n\n\n\n炉内を1，炉外を2とすると，平衡状態では炉外へ出る分子と炉外から入る分子の数が等しいはずなので，\n\\[\nAv_1N_1t = Av_2N_2t\n\\]\n\n\\(v_i\\) 分子の平均速度\n\\(A\\): 孔の断面積\n\\(N_i\\): 個数密度\n\\(t\\): 単位時間\n\n理想気体においては\n\\[\n\\frac{3}{2}k_BT = \\frac{1}{2}m\\overline{v^2}\n\\]\nと温度は自乗平均速度に比例する．また理想気体の状態方程式より，個数密度は圧力 \\(P\\) に比例し，温度 \\(T\\) に反比例するので\n\\[\n\\begin{align}\n\\frac{v_1}{v_2} &= \\sqrt{\\frac{T_1}{T_2}}\\\\\n\\frac{N_1}{N_2} &= \\frac{P_1}{P_2}\\frac{T_2}{T_1}\n\\end{align}\n\\]\nしたがって，\n\\[\n\\begin{align}\np_1\n  &= p_2\\sqrt{\\frac{T_1}{T_2}}\\\\\n  &= 100\\text{kPa} \\times \\sqrt{\\frac{330.15}{273.15}}\\\\\n  &\\approx 110\\text{kPa}\n\\end{align}\n\\]"
  },
  {
    "objectID": "posts/2025-07-07-statistics-and-math-001/index.html",
    "href": "posts/2025-07-07-statistics-and-math-001/index.html",
    "title": "平方完成と確率密度関数",
    "section": "",
    "text": "Theorem 1 平方完成\n\\(a\\neq 0, b\\neq 0\\) のとき，\n\\[\n\\begin{align}\n&a(x-A)^2 + b(x - B)^2 = (a+b)(x-C)^2 + \\frac{ab}{a+b}(A-B)^2\\\\\n&C= \\frac{aA + bB}{a+b}\n\\end{align}\n\\]\n\n\n\nExample 1 正規分布の足し合わせ\n\\(X\\sim N(\\mu_x, \\sigma_x^2), Y\\sim N(\\mu_y, \\sigma_y^2)\\) として互いに独立であるとき，\\(Z = X + Y\\) の分布を考えてみます．\n\\[\n\\begin{align}\nh(z)\n  = \\frac{1}{\\sqrt{2\\pi\\sigma_x^2\\sigma_y^2}}\\int\\exp\\left(-\\frac{(x-\\mu_x)^2}{2\\sigma_x^2}\\right)\\exp\\left(-\\frac{(z - x - \\mu_y)^2}{2\\sigma_y^2}\\right)dx\n\\end{align}\n\\]\nここについて，\\(w = x - \\mu_x\\) とすると\n\\[\n\\begin{align}\nh(z) = \\frac{1}{2\\pi\\sqrt{\\sigma_x^2\\sigma_y^2}}\\int\\exp\\left(-\\frac{w^2}{2\\sigma_x^2}\\right)\\exp\\left(-\\frac{(z - w - \\mu_x - \\mu_y)^2}{2\\sigma_y^2}\\right)dw\n\\end{align}\n\\]\nTheorem 1 を用いて \\(\\exp(\\cdot)\\) の中を整理すると\n\\[\n\\begin{align}\n&\\left(\\frac{1}{2\\sigma_x^2} + \\frac{1}{2\\sigma_y^2}\\right)\\left(w - \\frac{\\frac{1}{2\\sigma_y^2}(z -(\\mu_x + \\mu_y))}{\\frac{1}{2\\sigma_x^2} + \\frac{1}{2\\sigma_y^2}}\\right)^2 + \\left(\\frac{1}{2\\sigma_x^2}\\frac{1}{2\\sigma_y^2}\\right)\\left(\\left(\\frac{1}{2\\sigma_x^2} + \\frac{1}{2\\sigma_y^2}\\right)\\right)^{-1}((z -(\\mu_x + \\mu_y)))^2\\\\\n&=\\left(\\frac{\\sigma_x^2 + \\sigma_y^2}{2\\sigma_x^2\\sigma_y^2}\\right)\\left(w - \\frac{\\frac{1}{2\\sigma_y^2}(z -(\\mu_x + \\mu_y))}{\\frac{1}{2\\sigma_x^2} + \\frac{1}{2\\sigma_y^2}}\\right)^2 + \\frac{1}{2(\\sigma_x^2 + \\sigma_y^2)}((z -(\\mu_x + \\mu_y)))^2\n\\end{align}\n\\]\n次に\n\\[\n\\begin{align}\n\\int\\exp\\left(-\\left(\\frac{\\sigma_x^2 + \\sigma_y^2}{2\\sigma_x^2\\sigma_y^2}\\right)\\left(w - \\frac{\\frac{1}{2\\sigma_y^2}(z -(\\mu_x + \\mu_y))}{\\frac{1}{2\\sigma_x^2} + \\frac{1}{2\\sigma_y^2}}\\right)^2\\right)dw\n  = \\sqrt{\\frac{2\\pi\\sigma_x^2\\sigma_y^2}{\\sigma_x^2 + \\sigma_y^2}}\n\\end{align}\n\\]\nであるので\n\\[\n\\begin{align}\nh(z)\n  &= \\frac{1}{2\\pi\\sqrt{\\sigma_x^2\\sigma_y^2}}\\exp\\left(-\\frac{1}{2(\\sigma_x^2 + \\sigma_y^2)}((z -(\\mu_x + \\mu_y)))^2\\right)\\int\\exp\\left(-\\left(\\frac{\\sigma_x^2 + \\sigma_y^2}{2\\sigma_x^2\\sigma_y^2}\\right)\\left(w - \\frac{\\frac{1}{2\\sigma_y^2}(z -(\\mu_x + \\mu_y))}{\\frac{1}{2\\sigma_x^2} + \\frac{1}{2\\sigma_y^2}}\\right)^2\\right)dw\\\\\n  &= \\frac{1}{2\\pi\\sqrt{\\sigma_x^2\\sigma_y^2}}\\exp\\left(-\\frac{1}{2(\\sigma_x^2 + \\sigma_y^2)}((z -(\\mu_x + \\mu_y)))^2\\right) \\times  \\sqrt{\\frac{2\\pi\\sigma_x^2\\sigma_y^2}{\\sigma_x^2 + \\sigma_y^2}}\\\\\n  &= \\frac{1}{\\sqrt{2\\pi(\\sigma_x^2+\\sigma^2_y)}}\\exp\\left(-\\frac{1}{2(\\sigma_x^2 + \\sigma_y^2)}((z -(\\mu_x + \\mu_y)))^2\\right)\n\\end{align}\n\\]\nこれは \\(N(\\mu_x + \\mu_y, \\sigma^2_x + \\sigma^2_y)\\) の確率密度関数と一致するので\n\\[\nZ \\sim N(\\mu_x + \\mu_y, \\sigma^2_x + \\sigma^2_y)\n\\]"
  },
  {
    "objectID": "posts/2025-07-29-update-quarto/index.html",
    "href": "posts/2025-07-29-update-quarto/index.html",
    "title": "Quarto Version更新用スクリプト",
    "section": "",
    "text": "現在インストールされているQuarto Versionを削除し，GitHubから対応する .deb ファイルをダウンロードして，指定したバージョンをインストールします\n実行前に，公式のQuartoダウンロードページで利用可能なQuarto Versionを確認してください\n実行の結果，/opt/quarto にQuartoがインストールされます\n\n\n\n\nDebian/Ubuntu-based Linux OS\ncurl, dpkg, gdebi-core, sudo\nインターネット接続環境\n管理者権限 27(sudo)"
  },
  {
    "objectID": "posts/2025-07-29-update-quarto/index.html#quarto-version-updateスクリプト",
    "href": "posts/2025-07-29-update-quarto/index.html#quarto-version-updateスクリプト",
    "title": "Quarto Version更新用スクリプト",
    "section": "",
    "text": "現在インストールされているQuarto Versionを削除し，GitHubから対応する .deb ファイルをダウンロードして，指定したバージョンをインストールします\n実行前に，公式のQuartoダウンロードページで利用可能なQuarto Versionを確認してください\n実行の結果，/opt/quarto にQuartoがインストールされます\n\n\n\n\nDebian/Ubuntu-based Linux OS\ncurl, dpkg, gdebi-core, sudo\nインターネット接続環境\n管理者権限 27(sudo)"
  },
  {
    "objectID": "posts/2025-07-29-update-quarto/index.html#メインスクリプト",
    "href": "posts/2025-07-29-update-quarto/index.html#メインスクリプト",
    "title": "Quarto Version更新用スクリプト",
    "section": "🔨 メインスクリプト",
    "text": "🔨 メインスクリプト\n#!/bin/bash\n# Note: please check https://quarto.org/docs/download/ before running this script\n\nset -euo pipefail\n\n# check for updates\nif ! command -v quarto &&gt; /dev/null; then\n    echo \"Quarto is not installed. Please install it first.\"\n    exit 1\nelse\n    echo \"Quarto version: $(quarto --version)\"\nfi\n\n# prompt for confirmation\nread -p \"Do you want to update Quarto? (y/n): \" confirm\nif [[ ! \"$confirm\" =~ ^[Yy]$ ]]; then\n    echo \"Update cancelled.\"\n    exit 0\nfi\n\n# Ask user for version\nread -p \"Enter the Quarto version you want to install (e.g., 1.7.32): \" QUARTO_VERSION\n\n# Confirm version input is non-empty\nif [[ -z \"$QUARTO_VERSION\" ]]; then\n    echo \"No version specified. Aborting.\"\n    exit 1\nfi\n\n# Define download URL and file name\nDEB_URL=\"https://github.com/quarto-dev/quarto-cli/releases/download/v${QUARTO_VERSION}/quarto-${QUARTO_VERSION}-linux-amd64.deb\"\nDEB_FILE=\"quarto-${QUARTO_VERSION}-linux-amd64.deb\"\n\n# Remove existing version\nif command -v quarto &&gt; /dev/null; then\n    echo \"Removing existing Quarto installation...\"\n    sudo dpkg -r quarto || echo \"Quarto was not fully removed, continuing...\"\nfi\n\n# Download and install the specified version\necho \"Downloading Quarto version ${QUARTO_VERSION}...\"\ncurl -L -o \"$DEB_FILE\" \"$DEB_URL\"\n\necho \"Installing Quarto...\"\nsudo gdebi \"$DEB_FILE\" || { echo \"Installation failed.\"; exit 1; }\n\necho \"Quarto updated successfully to version ${QUARTO_VERSION}.\"\n\n# Verify installation\nif command -v quarto &&gt; /dev/null; then\n    echo \"Quarto version: $(quarto --version)\"\n    quarto check\nelse\n    echo \"Quarto installation failed. Please check the logs.\"\n    exit 1\nfi\n\n\n# Clean up\nrm -f \"$DEB_FILE\"\necho \"Temporary files cleaned up.\"\n\nExample 1 実行例\n$ ./quarto-update.sh\nQuarto version: 1.4.550\nDo you want to update Quarto? (y/n): y\nEnter the Quarto version you want to install (e.g., 1.7.32): 1.7.32\nRemoving existing Quarto installation...\nDownloading Quarto version 1.7.32...\nInstalling Quarto...\nQuarto updated successfully to version 1.7.32.\nQuarto version: 1.7.32\n\n\n\n🔍 スクリプト解説\n初期設定部分\nset -euo pipefail\n\n\n\n\noption\n説明\n\n\n\n\n-e\nエラーが発生した時点でスクリプトを終了\n\n\n-u\n未定義の変数を使用した際にエラーを発生\n\n\n-o pipefail\nパイプラインの途中でエラーが発生した場合に検知\n\n\n\n\nユーザー確認と入力\nread -p \"Do you want to update Quarto? (y/n): \" confirm\nif [[ ! \"$confirm\" =~ ^[Yy]$ ]]; then\n    echo \"Update cancelled.\"\n    exit 0\nfi\n\nread -p \"Enter the Quarto version you want to install (e.g., 1.7.32): \" QUARTO_VERSION\n\nif [[ -z \"$QUARTO_VERSION\" ]]; then\n    echo \"No version specified. Aborting.\"\n    exit 1\nfi\n\nアップデートの実行確認をユーザーに求める\nインストールしたいQuartoのバージョンを入力させる\nバージョン番号が未入力の場合は，exit 1\n\nダウンロードとインストールの準備\nDEB_URL=\"https://github.com/quarto-dev/quarto-cli/releases/download/v${QUARTO_VERSION}/quarto-${QUARTO_VERSION}-linux-amd64.deb\"\nDEB_FILE=\"quarto-${QUARTO_VERSION}-linux-amd64.deb\"\n\nGitHubからダウンロードするdebパッケージのURLを構築\nローカルに保存するファイル名を設定\n\n既存のQuartoの削除\nif command -v quarto &&gt; /dev/null; then\n    echo \"Removing existing Quarto installation...\"\n    sudo dpkg -r quarto || echo \"Quarto was not fully removed, continuing...\"\nfi\n\n既存のQuartoインストールを検出して削除\n削除に失敗してもスクリプトは継続\n\n新バージョンのインストール\necho \"Downloading Quarto version ${QUARTO_VERSION}...\"\ncurl -L -o \"$DEB_FILE\" \"$DEB_URL\"\n\necho \"Installing Quarto...\"\nsudo gdebi \"$DEB_FILE\" || { echo \"Installation failed.\"; exit 1; }\n\ngdebi コマンドでインストールを実行\ndpkg -iでも良いが，gdebiは必要な依存関係を自動で解決してくれます\n\nインストール確認\nif command -v quarto &&gt; /dev/null; then\n    echo \"Quarto version: $(quarto --version)\"\n    quarto check\nelse\n    echo \"Quarto installation failed. Please check the logs.\"\n    exit 1\nfi\n\nインストールが成功したか確認\n新しいバージョンを表示\nquarto checkでシステム要件を確認\n\ncommand -v quarto &&gt; /dev/null コマンド\ncommand -v &lt;command-name&gt;\nシェルの組み込みコマンドで指定されたコマンドのパスを探索してくれます\n\n\n\n\n項目\n説明\n\n\n\n\ncommand\nシェルの組み込みコマンドで，指定されたコマンドのパスを探索\n\n\n-v\nコマンドのフルパスを表示\n\n\nquarto\nここでは検索対象のコマンド名\n\n\n&&gt;\n標準出力(stdout)と標準エラー出力(stderr)の両方をリダイレクト\n\n\n/dev/null\n全ての出力を破棄する特殊なデバイスファイル\n\n\n\n\n&&gt; /dev/null を設定することによって，\n\nコマンドが見つかった場合: パスの出力は/dev/nullに捨てた上で，exit 0（終了コード0）\nコマンドが見つからない場合: エラーメッセージは/dev/nullに捨てられるが，exit 1（終了コード1） 扱い\n\n不要な .deb ファイルの削除\nrm -f \"$DEB_FILE\"\necho \"Temporary files cleaned up.\"\n\nダウンロードした.debパッケージを削除"
  },
  {
    "objectID": "posts/2025-07-18-getting-started-with-google-cloud-storage/index.html",
    "href": "posts/2025-07-18-getting-started-with-google-cloud-storage/index.html",
    "title": "bq commandを用いたPatitioned BigQuery External Tableの作成",
    "section": "",
    "text": "以下の形式でparquet fileがGoogle Cloud Storageでgs://regression-monkey-data/pupupuland_store_pos/以下に保存されているとします．\npupupuland_store_pos\n├── partition_dt=2023-09-23\n│   └── part-0.parquet\n├── partition_dt=2023-09-24\n│   └── part-0.parquet\n└── partition_dt=2023-09-25\n    └── part-0.parquet"
  },
  {
    "objectID": "posts/2025-07-18-getting-started-with-google-cloud-storage/index.html#google-cloud-storageでの保存形式",
    "href": "posts/2025-07-18-getting-started-with-google-cloud-storage/index.html#google-cloud-storageでの保存形式",
    "title": "bq commandを用いたPatitioned BigQuery External Tableの作成",
    "section": "",
    "text": "以下の形式でparquet fileがGoogle Cloud Storageでgs://regression-monkey-data/pupupuland_store_pos/以下に保存されているとします．\npupupuland_store_pos\n├── partition_dt=2023-09-23\n│   └── part-0.parquet\n├── partition_dt=2023-09-24\n│   └── part-0.parquet\n└── partition_dt=2023-09-25\n    └── part-0.parquet"
  },
  {
    "objectID": "posts/2025-07-18-getting-started-with-google-cloud-storage/index.html#bq-command",
    "href": "posts/2025-07-18-getting-started-with-google-cloud-storage/index.html#bq-command",
    "title": "bq commandを用いたPatitioned BigQuery External Tableの作成",
    "section": "bq command",
    "text": "bq command\npartitiopn_dtをpartition columnとしたtableの作成\nbq_upload() {\n  local project_id='regression-monkey-data'\n  local dataset_id='pupupuland'\n  local table_name='pupupuland_store_pos'\n  local upload_target=\"${project_id}:${dataset_id}.${table_name}\"\n\n  bq mkdef \\\n  --source_format=PARQUET \\\n  --hive_partitioning_mode=AUTO \\\n  --hive_partitioning_source_uri_prefix=gs://regression-monkey-data/pupupuland_store_pos/ \\\n  --require_hive_partition_filter=false \\\n  'gs://regression-monkey-data/pupupuland_store_pos/*' \\\n  &gt; pupupuland_store_pos_external_def.json\n\n  bq mk --external_table_definition=pupupuland_store_pos_external_def.json \"${upload_target}\"\n\n}\n\n# main\nbq_upload\n\nbq mkdefの役割\n\nbq mkdefの役割\nGCS 上の Parquet ファイルを外部テーブルとして定義するための JSON 定義ファイルを作成\n\n\n\n\n\n\n\n\n\nオプション名\n意味\n\n\n\n\n--source_format=PARQUET\n読み込むファイル形式が Parquet であることを指定\n\n\n--hive_partitioning_mode=AUTO\nHive形式のディレクトリ構造（例：partition_month=2024-07/）からパーティション列を自動推定\n\n\n--hive_partitioning_source_uri_prefix=gs://...\nパーティション構造の共通プレフィックス（＝分岐が始まるルート）を指定\n\n\n--require_hive_partition_filter=false\nパーティション列によるフィルターを必須にしない（＝全体スキャンも可能）\n\n\n'gs://.../*'\n対象とするファイル群のパス\n\n\n&gt; pupupuland_store_pos_external_def.json\n結果として、外部テーブル定義を JSON ファイルに保存する"
  },
  {
    "objectID": "posts/2025-07-18-getting-started-with-google-cloud-storage/index.html#references",
    "href": "posts/2025-07-18-getting-started-with-google-cloud-storage/index.html#references",
    "title": "bq commandを用いたPatitioned BigQuery External Tableの作成",
    "section": "References",
    "text": "References\n\nCloud StorageからExternal Tableの作成"
  },
  {
    "objectID": "posts/2025-02-07-wget-vs-curl/index.html",
    "href": "posts/2025-02-07-wget-vs-curl/index.html",
    "title": "wget vs curl",
    "section": "",
    "text": "Key Takeaways\nwget と curl はどちらもコマンドラインで使える HTTP クライアントですが，シチュエーションに応じて以下のような使い分けがあります"
  },
  {
    "objectID": "posts/2025-02-07-wget-vs-curl/index.html#wget-コマンド",
    "href": "posts/2025-02-07-wget-vs-curl/index.html#wget-コマンド",
    "title": "wget vs curl",
    "section": "wget コマンド",
    "text": "wget コマンド\n\nDefinition 1 wgetコマンド\n\nwget コマンドは，WEBサーバーからコンテンツを取得するためのコマンド\nGUIを使わずにインターネットからファイルをダウンロードする際に使用される\n\n\noptions\n\n\n\n\n\n\n\n\n\nオプション\nSyntax 例\n動作\n\n\n\n\n-r (recursive)\nwget -r http://example.com\n再帰的ダウンロード\n\n\n-A (accept)\nwget -r -A pdf,jpg http://example.com\nダウンロード対象ファイルのホワイトリストを指定．指定された拡張子やキーワードを含むファイルのみをダウンロード対象．カンマ区切りで複数指定可能．\n\n\n-R (reject)\nwget -r -R gif,zip http://example.com\nダウンロード対象外ファイルのブラックリストを指定．指定された拡張子や文字列を含むファイルはダウンロードしない．こちらもカンマ区切りで複数指定可能．\n\n\n-O\nwget -O wp.zip http://example.com\nダウンロード対象ファイルの名前を指定\n\n\n-P\nwget -P /home/jay/Downloads http://example.com\nダウンロード先のディレクトリを指定\n\n\n-c\nwget -c https://example.com/largefile.zip\nダウンロードを途中から再開するオプション\n\n\n\n\nwget -cの注意点\n\nwget -cは不安定なネットワーク環境下での大容量ファイルのダウンロードのときに推奨\nサーバー側がRange リクエスト（部分的なダウンロード）に対応していない場合は無効"
  },
  {
    "objectID": "posts/2025-02-07-wget-vs-curl/index.html#curl-コマンド",
    "href": "posts/2025-02-07-wget-vs-curl/index.html#curl-コマンド",
    "title": "wget vs curl",
    "section": "curl コマンド",
    "text": "curl コマンド\n\nDefinition 2 curlコマンド\n\nさまざまなプロトコルに対応したデータを転送するためのコマンド\n\n\noptions\n\n\n\n\n\n\n\n\n\nオプション\nSyntax 例\n動作説明\n\n\n\n\n-X\ncurl -X POST https://example.com/api\nHTTPメソッドを明示的に指定（例: POST, PUT）\n\n\n-x\ncurl -x http://proxy.example.com:8080 URL\n指定したプロキシサーバーを経由してリクエストを送る\n\n\n-d\ncurl -d \"key1=value1&key2=value2\" URL\nHTTP POST リクエストのボディにデータを送信（デフォルトで Content-Type: application/x-www-form-urlencoded）\n\n\n-s\ncurl -s https://example.com\n進行状況やエラーメッセージなどの出力を抑制（“silent mode”）\n\n\n-o\ncurl -o myfile.html https://example.com\n出力内容を指定したファイル名で保存\n\n\n-O\ncurl -O https://example.com/index.html\nURL から取得したファイル名そのままで保存\n\n\n-L\ncurl -L https://example.com\nリダイレクトを自動で追跡\n\n\n\n\n\nExample 1 よく使う構文\n\n\n\n\n\n\n\n構文例\n説明\n\n\n\n\ncurl https://example.com\n指定したURLからデータを取得\n\n\ncurl -o file.html https://example.com\nファイルに保存してダウンロード\n\n\ncurl -I https://example.com\nHTTPヘッダーだけ取得\n\n\ncurl -X POST -d \"a=1&b=2\" https://api.example.com\nPOSTリクエスト送信\n\n\ncurl -H \"Authorization: Bearer TOKEN\" https://api.example.com\n認証付きリクエスト送信"
  },
  {
    "objectID": "posts/2025-02-07-wget-vs-curl/index.html#比較まとめ表",
    "href": "posts/2025-02-07-wget-vs-curl/index.html#比較まとめ表",
    "title": "wget vs curl",
    "section": "比較まとめ表",
    "text": "比較まとめ表\n\n\n\n\n\n\n\n\n\n項目\nwget\ncurl\n\n\n\n\n主な用途\nファイルのダウンロード\nデータの送受信（API など）\n\n\nサポートプロトコル\nHTTP, HTTPS, FTP など\nHTTP, HTTPS, FTP, SFTP, SCP, LDAP など\n\n\n再帰ダウンロード\n◯（Webサイトごとダウンロード可能）\n✕（スクリプトで再現は可能）\n\n\nアップロード\n✕（不可）\n〇(可能)\n\n\nレジューム（中断再開）\n◯（-c オプション）\n◯（-C - オプションなど）\n\n\nデフォルト出力\nファイル保存\n標準出力（ターミナルに出る）\n\n\nPOST リクエスト\n△（あまり使われない）\n◯（API テストなどに最適）"
  },
  {
    "objectID": "posts/2025-09-17-VDI/index.html",
    "href": "posts/2025-09-17-VDI/index.html",
    "title": "VDIとは？",
    "section": "",
    "text": "Definition 1 VDI(Virtual Desktop Infrastructure)\n\n仮想環境技術を用いて，デスクトップ環境をサーバー上で構築・集中管理し，ユーザーがリモートからアクセスできるようにする仕組み．\nサーバー上でユーザーごとに仮想デスクトップ（VM）を提供されるので，OSやアプリも個別に分離されている\n\n\n\n\n\n\n\n\n\n\ngraph TB\n    %% VDI型環境\n    subgraph VDI[VDI環境]\n    direction LR\n      %% サーバー側\n      subgraph Server[サーバー]\n          direction LR\n          HW[ハードウェア]\n          HV[ハイパーバイザ]\n          VM1[VM 1: OS + アプリ]\n          VM2[VM 2: OS + アプリ]\n          VM3[VM 3: OS + アプリ]\n          \n          HW --&gt; HV\n          HV --&gt; VM1\n          HV --&gt; VM2\n          HV --&gt; VM3\n      end\n\n      %% クライアント側\n      Client1[端末 1]\n      Client2[端末 2]\n      Client3[端末 3]\n      \n      VM1 --&gt;|画面転送| Client1\n      VM2 --&gt;|画面転送| Client2\n      VM3 --&gt;|画面転送| Client3\n    end\n\n\n\n\n\n\n\n\nFigure 1: VDI環境\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n種類\n概要\n特徴\n利点\n注意点\n\n\n\n\nサーバーベース型\n複数ユーザーが1台のサーバーOS環境を共有\nOSは1種類，セッションを共有\n導入コスト低，サーバー資源効率的\n個別カスタマイズ不可，安定性やセキュリティの制約\n\n\nVDI\nサーバー上でユーザーごとに独立した仮想マシンを提供\n個別OS環境，画面転送型\n個別カスタマイズ可能，柔軟でセキュア\nサーバー・ストレージ負荷高，導入コスト高\n\n\nブレードPC型\nサーバーラック内に物理PCを設置し，ネットワーク経由で利用\nフル物理PC環境をリモート利用\n高性能アプリ向き，互換性問題少\nハードウェアコスト高，管理・保守が物理的に大変\n\n\nパーソナルクラウド型（DaaS: Desktop as a Service）\nクラウド上で提供される仮想デスクトップ\nユーザーごとに独立OS，クラウド管理\n初期投資少，スケーラブル，場所を選ばず利用可能\nネットワーク依存，継続コストがかかる\n\n\nアプリケーション仮想化\nOSは端末に残し，アプリだけ仮想化して配信\nアプリ単位で配信・管理\nOSに依存せずアプリ更新容易\nOSやアプリ間互換性に注意\n\n\n\n\n\n\n\n\n\n\n\n\ngraph TB\n    %% ブレードPC型環境\n    subgraph Blade[ブレードPC環境]\n    direction LR\n      %% サーバー側（物理PC）\n      subgraph BladeServer[ブレードPCラック]\n          direction LR\n          PC1[PC 1]\n          PC2[PC 2]\n          PC3[PC 3]\n      end\n\n      %% クライアント側\n      Client1[端末 1]\n      Client2[端末 2]\n      Client3[端末 3]\n      \n      PC1 --&gt;|画面転送| Client1\n      PC2 --&gt;|画面転送| Client2\n      PC3 --&gt;|画面転送| Client3\n    end\n\n\n\n\n\n\n\n\nFigure 2: ブレードPC環境\n\n\n\n\n\n\n\n\n\n\n\ngraph TB\n    %% サーバーベース型環境\n    subgraph RDS[サーバーベース型環境]\n    direction LR\n      %% サーバー側\n      subgraph Server[サーバー]\n          direction LR\n          HW[ハードウェア]\n          OS[OS]\n          App[アプリ]\n      end\n\n      %% クライアント側\n      Client1[端末 1]\n      Client2[端末 2]\n      Client3[端末 3]\n      \n      Server --&gt;|画面転送（セッション共有）| Client1\n      Server --&gt;|画面転送（セッション共有）| Client2\n      Server --&gt;|画面転送（セッション共有）| Client3\n    end\n\n\n\n\n\n\n\n\nFigure 3: サーバーベース型環境\n\n\n\n\n\n\n\n\n\n\n\ngraph TB\n    %% パーソナルクラウド型環境\n    subgraph DaaS[パーソナルクラウド型環境]\n    direction LR\n      %% クラウド側サーバー\n      subgraph Cloud[クラウドサーバー]\n          direction LR\n          HW[ハードウェア]\n          HV[ハイパーバイザ]\n          VM1[VM 1: OS + アプリ]\n          VM2[VM 2: OS + アプリ]\n      end\n\n      %% クライアント側\n      Client1[端末 1]\n      Client2[端末 2]\n\n      VM1 --&gt;|画面転送 + データ保護| Client1\n      VM2 --&gt;|画面転送 + データ保護| Client2\n    end\n\n\n\n\n\n\n\n\nFigure 4: パーソナルクラウド型（DaaS）環境\n\n\n\n\n\n\n\n\n\n\n\ngraph TB\n    %% アプリケーション仮想化\n    subgraph AppVirt[アプリケーション仮想化]\n    direction LR\n      %% サーバー側\n      subgraph Server[サーバー]\n          direction LR\n          HW[ハードウェア]\n          AppServer[アプリケーションサーバー]\n      end\n\n      %% クライアント側\n      Client1[端末 1]\n      Client2[端末 2]\n\n      AppServer --&gt;|アプリ配信 + データ保護| Client1\n      AppServer --&gt;|アプリ配信 + データ保護| Client2\n    end\n\n\n\n\n\n\n\n\nFigure 5: アプリケーション仮想化環境\n\n\n\n\n\n\n\n\n\n\n\n\nNote(1) 集中管理\n\n\n\n\nOSやアプリケーションをサーバー上で集中管理するため，ソフトウェアの更新やパッチ適用を一元的に行える\nアクセス権限や暗号化を一元管理できる\n\n\n\n\n\n\n\n\n\nNote(2) 画面転送型アーキテクチャ\n\n\n\n\n実際の処理はサーバー上で行われ，端末には画面情報だけが転送される\nクライアント側の性能に大きく依存せず，高速な端末が不要\n端末が変わっても同じ仮想デスクトップ環境が使える\n\n\n\n\n\n\n\n\n\nNote(3) セキュリティの強化\n\n\n\n\nデータはサーバーに集中保存され，端末側には残らないため情報漏洩リスクが低い\n端末の紛失・盗難による情報漏洩の防止が期待できる"
  },
  {
    "objectID": "posts/2025-09-17-VDI/index.html#vdiとは",
    "href": "posts/2025-09-17-VDI/index.html#vdiとは",
    "title": "VDIとは？",
    "section": "",
    "text": "Definition 1 VDI(Virtual Desktop Infrastructure)\n\n仮想環境技術を用いて，デスクトップ環境をサーバー上で構築・集中管理し，ユーザーがリモートからアクセスできるようにする仕組み．\nサーバー上でユーザーごとに仮想デスクトップ（VM）を提供されるので，OSやアプリも個別に分離されている\n\n\n\n\n\n\n\n\n\n\ngraph TB\n    %% VDI型環境\n    subgraph VDI[VDI環境]\n    direction LR\n      %% サーバー側\n      subgraph Server[サーバー]\n          direction LR\n          HW[ハードウェア]\n          HV[ハイパーバイザ]\n          VM1[VM 1: OS + アプリ]\n          VM2[VM 2: OS + アプリ]\n          VM3[VM 3: OS + アプリ]\n          \n          HW --&gt; HV\n          HV --&gt; VM1\n          HV --&gt; VM2\n          HV --&gt; VM3\n      end\n\n      %% クライアント側\n      Client1[端末 1]\n      Client2[端末 2]\n      Client3[端末 3]\n      \n      VM1 --&gt;|画面転送| Client1\n      VM2 --&gt;|画面転送| Client2\n      VM3 --&gt;|画面転送| Client3\n    end\n\n\n\n\n\n\n\n\nFigure 1: VDI環境\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n種類\n概要\n特徴\n利点\n注意点\n\n\n\n\nサーバーベース型\n複数ユーザーが1台のサーバーOS環境を共有\nOSは1種類，セッションを共有\n導入コスト低，サーバー資源効率的\n個別カスタマイズ不可，安定性やセキュリティの制約\n\n\nVDI\nサーバー上でユーザーごとに独立した仮想マシンを提供\n個別OS環境，画面転送型\n個別カスタマイズ可能，柔軟でセキュア\nサーバー・ストレージ負荷高，導入コスト高\n\n\nブレードPC型\nサーバーラック内に物理PCを設置し，ネットワーク経由で利用\nフル物理PC環境をリモート利用\n高性能アプリ向き，互換性問題少\nハードウェアコスト高，管理・保守が物理的に大変\n\n\nパーソナルクラウド型（DaaS: Desktop as a Service）\nクラウド上で提供される仮想デスクトップ\nユーザーごとに独立OS，クラウド管理\n初期投資少，スケーラブル，場所を選ばず利用可能\nネットワーク依存，継続コストがかかる\n\n\nアプリケーション仮想化\nOSは端末に残し，アプリだけ仮想化して配信\nアプリ単位で配信・管理\nOSに依存せずアプリ更新容易\nOSやアプリ間互換性に注意\n\n\n\n\n\n\n\n\n\n\n\n\ngraph TB\n    %% ブレードPC型環境\n    subgraph Blade[ブレードPC環境]\n    direction LR\n      %% サーバー側（物理PC）\n      subgraph BladeServer[ブレードPCラック]\n          direction LR\n          PC1[PC 1]\n          PC2[PC 2]\n          PC3[PC 3]\n      end\n\n      %% クライアント側\n      Client1[端末 1]\n      Client2[端末 2]\n      Client3[端末 3]\n      \n      PC1 --&gt;|画面転送| Client1\n      PC2 --&gt;|画面転送| Client2\n      PC3 --&gt;|画面転送| Client3\n    end\n\n\n\n\n\n\n\n\nFigure 2: ブレードPC環境\n\n\n\n\n\n\n\n\n\n\n\ngraph TB\n    %% サーバーベース型環境\n    subgraph RDS[サーバーベース型環境]\n    direction LR\n      %% サーバー側\n      subgraph Server[サーバー]\n          direction LR\n          HW[ハードウェア]\n          OS[OS]\n          App[アプリ]\n      end\n\n      %% クライアント側\n      Client1[端末 1]\n      Client2[端末 2]\n      Client3[端末 3]\n      \n      Server --&gt;|画面転送（セッション共有）| Client1\n      Server --&gt;|画面転送（セッション共有）| Client2\n      Server --&gt;|画面転送（セッション共有）| Client3\n    end\n\n\n\n\n\n\n\n\nFigure 3: サーバーベース型環境\n\n\n\n\n\n\n\n\n\n\n\ngraph TB\n    %% パーソナルクラウド型環境\n    subgraph DaaS[パーソナルクラウド型環境]\n    direction LR\n      %% クラウド側サーバー\n      subgraph Cloud[クラウドサーバー]\n          direction LR\n          HW[ハードウェア]\n          HV[ハイパーバイザ]\n          VM1[VM 1: OS + アプリ]\n          VM2[VM 2: OS + アプリ]\n      end\n\n      %% クライアント側\n      Client1[端末 1]\n      Client2[端末 2]\n\n      VM1 --&gt;|画面転送 + データ保護| Client1\n      VM2 --&gt;|画面転送 + データ保護| Client2\n    end\n\n\n\n\n\n\n\n\nFigure 4: パーソナルクラウド型（DaaS）環境\n\n\n\n\n\n\n\n\n\n\n\ngraph TB\n    %% アプリケーション仮想化\n    subgraph AppVirt[アプリケーション仮想化]\n    direction LR\n      %% サーバー側\n      subgraph Server[サーバー]\n          direction LR\n          HW[ハードウェア]\n          AppServer[アプリケーションサーバー]\n      end\n\n      %% クライアント側\n      Client1[端末 1]\n      Client2[端末 2]\n\n      AppServer --&gt;|アプリ配信 + データ保護| Client1\n      AppServer --&gt;|アプリ配信 + データ保護| Client2\n    end\n\n\n\n\n\n\n\n\nFigure 5: アプリケーション仮想化環境\n\n\n\n\n\n\n\n\n\n\n\n\nNote(1) 集中管理\n\n\n\n\nOSやアプリケーションをサーバー上で集中管理するため，ソフトウェアの更新やパッチ適用を一元的に行える\nアクセス権限や暗号化を一元管理できる\n\n\n\n\n\n\n\n\n\nNote(2) 画面転送型アーキテクチャ\n\n\n\n\n実際の処理はサーバー上で行われ，端末には画面情報だけが転送される\nクライアント側の性能に大きく依存せず，高速な端末が不要\n端末が変わっても同じ仮想デスクトップ環境が使える\n\n\n\n\n\n\n\n\n\nNote(3) セキュリティの強化\n\n\n\n\nデータはサーバーに集中保存され，端末側には残らないため情報漏洩リスクが低い\n端末の紛失・盗難による情報漏洩の防止が期待できる"
  },
  {
    "objectID": "posts/2025-09-17-VDI/index.html#references",
    "href": "posts/2025-09-17-VDI/index.html#references",
    "title": "VDIとは？",
    "section": "References",
    "text": "References\n\n【5分で学べる】VDIとは？VDI導入による効果 | 情報処理安全確保支援士（登録セキスペ）"
  },
  {
    "objectID": "posts/2025-04-24-reciprocating-engine/index.html",
    "href": "posts/2025-04-24-reciprocating-engine/index.html",
    "title": "レシプロエンジンの仕組み",
    "section": "",
    "text": "レシプロエンジンは，ピストンが「吸気」「圧縮」「燃焼・膨張」「排気」という４行程（ピストンは２往復）で１サイクルの作用を完了するエンジンのことです． レシプロガソリンエンジンの場合，ガソリンを燃料とする混合気を燃焼させ，ピストンを往復させます．\n\n\n\n4 cycle engine\n\n\n吸気行程\n\nピストンが上死点から下死点に向かって下降し，シリンダー内が負圧になる\n負圧になることで吸気バルブが開き，燃料と空気の混合気が吸い込まれてくる(排気バルブは閉じられたまま)\n下死点までさがると吸気バルブが閉じる\n\n圧縮行程\n\nシリンダー内にある混合気をピストンが押上げ，圧縮していく（断熱圧縮）\n混合気中の燃料は完全に気化する\n\n燃焼・膨張行程\n\n点火プラグが点火\n圧縮された混合気が燃焼し，高温高圧のガスとなる\nガスが膨張しながらピストンを下死点まで押し下げる\nクランクシャフトが回転し動力が発生する\n\n排気行程\n\n排気バルブが開く\n下死点にあるピストンが再び上死点まで上昇し，燃焼ガスを排気バルブから外に放出\n1サイクルが完了→吸気行程へ"
  },
  {
    "objectID": "posts/2025-04-24-reciprocating-engine/index.html#レシプロエンジンの４行程",
    "href": "posts/2025-04-24-reciprocating-engine/index.html#レシプロエンジンの４行程",
    "title": "レシプロエンジンの仕組み",
    "section": "",
    "text": "レシプロエンジンは，ピストンが「吸気」「圧縮」「燃焼・膨張」「排気」という４行程（ピストンは２往復）で１サイクルの作用を完了するエンジンのことです． レシプロガソリンエンジンの場合，ガソリンを燃料とする混合気を燃焼させ，ピストンを往復させます．\n\n\n\n4 cycle engine\n\n\n吸気行程\n\nピストンが上死点から下死点に向かって下降し，シリンダー内が負圧になる\n負圧になることで吸気バルブが開き，燃料と空気の混合気が吸い込まれてくる(排気バルブは閉じられたまま)\n下死点までさがると吸気バルブが閉じる\n\n圧縮行程\n\nシリンダー内にある混合気をピストンが押上げ，圧縮していく（断熱圧縮）\n混合気中の燃料は完全に気化する\n\n燃焼・膨張行程\n\n点火プラグが点火\n圧縮された混合気が燃焼し，高温高圧のガスとなる\nガスが膨張しながらピストンを下死点まで押し下げる\nクランクシャフトが回転し動力が発生する\n\n排気行程\n\n排気バルブが開く\n下死点にあるピストンが再び上死点まで上昇し，燃焼ガスを排気バルブから外に放出\n1サイクルが完了→吸気行程へ"
  },
  {
    "objectID": "posts/2024-12-16-ssh-to-macos/index.html",
    "href": "posts/2024-12-16-ssh-to-macos/index.html",
    "title": "macOSへのssh接続",
    "section": "",
    "text": "Note同じprivate networkに属しているmacOS端末に対して公開鍵認証を用いてssh接続したい\n\n\n\n同じprovate networkに属している前提の端末へのsshになるので\nssh hoshinokirby@192.168.10.110\nのように自宅内のネットワークのみで有効なプライベートIPアドレス（クラスC 192.168.0.0 ~ 192.168.255.255）を指定してアクセスすることを想定しています．"
  },
  {
    "objectID": "posts/2024-12-16-ssh-to-macos/index.html#what-we-want-to-do",
    "href": "posts/2024-12-16-ssh-to-macos/index.html#what-we-want-to-do",
    "title": "macOSへのssh接続",
    "section": "",
    "text": "Note同じprivate networkに属しているmacOS端末に対して公開鍵認証を用いてssh接続したい\n\n\n\n同じprovate networkに属している前提の端末へのsshになるので\nssh hoshinokirby@192.168.10.110\nのように自宅内のネットワークのみで有効なプライベートIPアドレス（クラスC 192.168.0.0 ~ 192.168.255.255）を指定してアクセスすることを想定しています．"
  },
  {
    "objectID": "posts/2024-12-16-ssh-to-macos/index.html#how-to-set-up",
    "href": "posts/2024-12-16-ssh-to-macos/index.html#how-to-set-up",
    "title": "macOSへのssh接続",
    "section": "How to set up",
    "text": "How to set up\n ▶  Server側\nSSHサーバー側はopenssh-serverなりssh serverが動いている必要があります．\n\nSystem Preferences &gt; Sharingをクリック\nRemote Loginを有効化\n\n以上の2ステップで，macOS側のSSH serverをactive状態にすることができます．\n ▶  Client側\nパスワード認証の場合は\n\narpコマンドでアクセス先端末のプライベートIPアドレスを検索\nsshコマンドでアクセス\n\nで完了となりますが，今回は公開鍵認証手順を紹介します．公開鍵認証の場合は\n\nSSH Key Pair の作成\n公開鍵の登録(接続先のauthorized_keysファイル（~/.ssh/authorized_keys）に追加)\nsshコマンドでアクセスとなります\n\n\n\nSSH Key Pair の作成\n\nssh-keygen -t rsa -b 4096 -f ~/.ssh/pupupu_land\n\n\n-t rsa: key typeの指定\n-b 4096: key lengthの指定(長いほどsecurity強固になる)\n-f  ~/.ssh/pupupu_land: key pairの生成先とファイル名（今回はpupupu_land, pupupu_land.pubが生成される）\n\n\n\n公開鍵の登録\n\nssh-copy-id -i ~/.ssh/pupupu_land.pub username@&lt;target-ip&gt;\n\n\n-i ~/.ssh/pupupu_land.pub: コピーする公開鍵ファイルを指定\n\n公開鍵を登録するには，\n\n公開鍵のファイルをコピー\n接続先のauthorized_keysファイル（~/.ssh/authorized_keys）に追加\nauthorized_keysファイルがない場合は作成後に適切なパーミッションを設定\n\nが必要となりますが，ssh-copy-idコマンドですべて自動実行することができるというメリットがあります．\n ▶  ssh connection\n上記の設定後，sshコマンド実行することで，macOSへアクセスすることができます． 毎回プライベートIPアドレスを調べるのが億劫な場合，デバイスのMACアドレスがわかればarpコマンドで以下のように検索することもできます．\narp -a | grep &lt;MAC-address&gt; | awk -F'[()]' '{print $2}'"
  },
  {
    "objectID": "posts/2025-11-03-python-class-101/index.html",
    "href": "posts/2025-11-03-python-class-101/index.html",
    "title": "Pythonにおけるオブジェクトとクラス",
    "section": "",
    "text": "Definition 1 プログラミングにおけるオブジェクト\n\n「オブジェクト」はデータと，そのデータを操作する手続きをひとまとめにしたもの\nデータ部分は「属性（attribute）」または「データメンバー」と呼ばれる\n手続き部分は「メソッド」と呼ばれ，オブジェクトの状態を操作する\n\n\n上記の意味でのオブジェクトを作るための設計図がPythonにおける「クラス」です．クラスを基にしてオブジェクトが生成されますが， 実際にデータ値が格納されたオブジェクトのことをインスタンスといいます．\n\n\nCode\nclass Dog:\n    def __init__(self, name):\n        self.name = name\n\nmy_dog = Dog(\"Pochi\")  # ← これがインスタンス\n\n\nコード行 my_dog = Dog(\"Pochi\") の挙動は以下のように分解できます\n\nDog クラスの定義を探し出す\nメモリ内に新しい新しいオブジェクト（空のインスタンスを作成する\n新しく作ったオブジェクトを self，引数 Pochi を name として渡して，オブジェクトの __init__ を呼び出す\nname の値をインスタンスに格納する．\n初期化が完了したインスタンスを返し， そのインスタンスに対してmy_dog という名前を与える（変数 my_dog に格納する）\n\n\nExample 1 (メモリから見たクラスとインスタンスの違い) \n\n\nCode\nprint(Dog)\nprint(my_dog)\n\n\n&lt;class '__main__.Dog'&gt;\n&lt;__main__.Dog object at 0x7f0a1423c410&gt;\n\n\n\nDog は クラスオブジェクト（型そのもの）を指しており，&lt;class '__main__.Dog'&gt; のように表示される\nmy_dog は Dogクラスから生成されたインスタンス（具体的な値を持つ実体）を指しており，メモリアドレスを伴って表示される"
  },
  {
    "objectID": "posts/2025-11-03-python-class-101/index.html#オブジェクトとクラス",
    "href": "posts/2025-11-03-python-class-101/index.html#オブジェクトとクラス",
    "title": "Pythonにおけるオブジェクトとクラス",
    "section": "",
    "text": "Definition 1 プログラミングにおけるオブジェクト\n\n「オブジェクト」はデータと，そのデータを操作する手続きをひとまとめにしたもの\nデータ部分は「属性（attribute）」または「データメンバー」と呼ばれる\n手続き部分は「メソッド」と呼ばれ，オブジェクトの状態を操作する\n\n\n上記の意味でのオブジェクトを作るための設計図がPythonにおける「クラス」です．クラスを基にしてオブジェクトが生成されますが， 実際にデータ値が格納されたオブジェクトのことをインスタンスといいます．\n\n\nCode\nclass Dog:\n    def __init__(self, name):\n        self.name = name\n\nmy_dog = Dog(\"Pochi\")  # ← これがインスタンス\n\n\nコード行 my_dog = Dog(\"Pochi\") の挙動は以下のように分解できます\n\nDog クラスの定義を探し出す\nメモリ内に新しい新しいオブジェクト（空のインスタンスを作成する\n新しく作ったオブジェクトを self，引数 Pochi を name として渡して，オブジェクトの __init__ を呼び出す\nname の値をインスタンスに格納する．\n初期化が完了したインスタンスを返し， そのインスタンスに対してmy_dog という名前を与える（変数 my_dog に格納する）\n\n\nExample 1 (メモリから見たクラスとインスタンスの違い) \n\n\nCode\nprint(Dog)\nprint(my_dog)\n\n\n&lt;class '__main__.Dog'&gt;\n&lt;__main__.Dog object at 0x7f0a1423c410&gt;\n\n\n\nDog は クラスオブジェクト（型そのもの）を指しており，&lt;class '__main__.Dog'&gt; のように表示される\nmy_dog は Dogクラスから生成されたインスタンス（具体的な値を持つ実体）を指しており，メモリアドレスを伴って表示される"
  },
  {
    "objectID": "posts/2025-11-03-python-class-101/index.html#クラス属性とインスタンス属性",
    "href": "posts/2025-11-03-python-class-101/index.html#クラス属性とインスタンス属性",
    "title": "Pythonにおけるオブジェクトとクラス",
    "section": "クラス属性とインスタンス属性",
    "text": "クラス属性とインスタンス属性\n\nDefinition 2 クラス属性とインスタンス属性\n\nクラス属性（class attribute） は，クラスそのものに属する属性．すべてのインスタンスで共有される．\n\nインスタンス属性（instance attribute） は，各インスタンス固有の属性．インスタンスごとに異なる値を持つ．\n\n通常，インスタンス属性は __init__() メソッド内で self.xxx = ... の形で定義される．\n\nクラス属性は，クラス定義の直下（メソッドの外側）で定義される．\n\n\n\nExample 2 (dataclass とクラス変数) \n\ndataclass でクラス変数を作る場合は ClassVar を使う\ndataclassはインスタンス変数を自動的に __init__ 処理するための仕組みなので，ClassVar を付けないとクラス変数を用いるとき「インスタンス変数っぽく見える」という混乱が起こります\nインスタンスメソッドからクラス変数を操作する場合は self.__class__ を基本用いる\n\n\n\nCode\nfrom dataclasses import dataclass\nfrom typing import ClassVar\n\n@dataclass\nclass Person:\n    name: str                        # インスタンス属性\n    age: int                         # インスタンス属性\n    total_number_of_persons: ClassVar[int] = 0\n\n    def __post_init__(self):\n        # クラス属性\n        self.__class__.total_number_of_persons += 1\n\nadam = Person('Adam', 30)\njohn = Person('Jhon', 25)\n\nprint(Person.total_number_of_persons)\nprint(adam.total_number_of_persons)\nprint(john.total_number_of_persons)\n\n\n2\n2\n2\n\n\n\n\nCoding Style Guide\n\n\n\n\n\n\nNoteAvoid mutable global state.\n\n\n\n\nクラス変数は「全インスタンスで共有される共通定義」にのみ使用\nミュータブルなオブジェクトは避け，必要な場合は tuple や frozenset を使う\n外部アクセスはメソッド経由\n\n\n\n\nExample 3 \n\n\nCode\nfrom dataclasses import dataclass, field\nfrom typing import Tuple, ClassVar\n\n@dataclass\nclass Stats:\n    # 不変のクラス変数（mutable global state を避ける）\n    _ATTRIBS: ClassVar[Tuple[str, ...]] = ('strength', 'speed', 'intellect', 'tenacity')\n\n    # インスタンス属性\n    strength: int = 0\n    speed: int = 0\n    intellect: int = 0\n    tenacity: int = 0\n\n    # クラスメソッドで安全にアクセス\n    @classmethod\n    def attribs(cls) -&gt; Tuple[str, ...]:\n        \"\"\"Return the immutable tuple of attribute names.\"\"\"\n        return cls._ATTRIBS\n\n    # combine メソッドは staticmethod\n    @staticmethod\n    def combine(*args: 'Stats') -&gt; 'Stats':\n        \"\"\"\n        Combine multiple Stats objects into a new Stats instance.\n        Uses the class-level attribute names safely.\n        \"\"\"\n        assert all(isinstance(arg, Stats) for arg in args), \"All arguments must be Stats instances.\"\n        combined_values = {stat: 0 for stat in Stats.attribs()}\n        for stat in Stats.attribs():\n            for obj in args:\n                combined_values[stat] += getattr(obj, stat)\n        return Stats(**combined_values)\n\ns1 = Stats(strength=10, speed=5)\ns2 = Stats(intellect=7, tenacity=3)\n\ns_total = Stats.combine(s1, s2)\nprint(s_total)\n\n# クラス変数は不変なので安全\nprint(Stats.attribs())  # ('strength', 'speed', 'intellect', 'tenacity')\n\n\nStats(strength=10, speed=5, intellect=7, tenacity=3)\n('strength', 'speed', 'intellect', 'tenacity')"
  },
  {
    "objectID": "posts/2025-11-03-python-class-101/index.html#マングリング",
    "href": "posts/2025-11-03-python-class-101/index.html#マングリング",
    "title": "Pythonにおけるオブジェクトとクラス",
    "section": "マングリング",
    "text": "マングリング\n__ をメソッドや属性名の先頭に付与することで，クラス定義の外からは見えづらくする命名方法があります．\n\n\nCode\n@dataclass\nclass Cat:\n    __name: str\n\n    def say(self):\n        print(f\"{self.__name} says Meow!\")\n\nmy_cat = Cat('Tama')\nmy_cat.say()\n\n\nTama says Meow!\n\n\nこのように__name 属性は内部経由だと利用できますが，my_cat.__name だとエラーができます．ただし，\n\n\nCode\n## 外部access\nprint(my_cat._Cat__name)\n\n## 属性への直接write\nmy_cat._Cat__name = 'Tama2'\nprint(my_cat._Cat__name)\n\n\nTama\nTama2\n\n\nとすると一応アクセス(READ及びWRITE)が出来てしまいます．"
  },
  {
    "objectID": "posts/2025-11-03-python-class-101/index.html#インスタンス属性へのアクセス制御",
    "href": "posts/2025-11-03-python-class-101/index.html#インスタンス属性へのアクセス制御",
    "title": "Pythonにおけるオブジェクトとクラス",
    "section": "インスタンス属性へのアクセス制御",
    "text": "インスタンス属性へのアクセス制御\nゲッターとセッターを用いて，インスタンス属性へのアクセスを制御したい場合は @property, @&lt;property&gt;.setter デコレーターという仕組みを使います．\n\nExample 4 (トラファルガー・ローとマングリングとゲッターとセッター) \nワンピースのトラファルガー・ローを例にすると\n\nトラファルガー家は，他の「D」の一族と違い，外部にDを名乗ることを避けていた\n通称は本名から忌み名を除去したものを名乗っている\n通称は変わりうるが，本名は変わらない\n本名の外部アクセスは基本想定していない\n\nということを踏まえてClassを定義すると\n\n\nCode\nclass Waterloos:\n    def __init__(self, real_name):\n        self.__real_name = real_name\n        parts = self.__real_name.split(\"･\")\n        self._nickname = f\"{parts[0]}･{parts[-1]}\" if len(parts) &gt; 1 else self.__real_name\n\n    @property\n    def name(self):\n        \"\"\"通称（ニックネーム）を返す\"\"\"\n        return self._nickname\n\n    @name.setter\n    def name(self, value):\n        \"\"\"通称を更新\"\"\"\n        if not isinstance(value, str):\n            raise ValueError(\"Nickname must be a string\")\n        self._nickname = value\n\n# トラファルガー･ローの設定\np = Waterloos(real_name=\"トラファルガー･D･ワーテル･ロー\")\n\nprint(\"通称:\", p.name)       # → トラファルガー･ロー\nprint(\"本名:\", p._Waterloos__real_name)  # → トラファルガー･D･ワーテル･ロー\n# print(\"本名:\", p.__real_name)  # これではアクセスできない\n\n\n通称: トラファルガー･ロー\n本名: トラファルガー･D･ワーテル･ロー\n\n\nワノ国に入国した後に，ワノ国風名前にアレンジしたとすると\n\n\nCode\n# ワノ国に入国\np.name = \"トラ男\"\n\nprint(\"通称:\", p.name)       # → トラ男\nprint(\"本名:\", p._Waterloos__real_name)  # → トラファルガー･D･ワーテル･ロー\n\n\n通称: トラ男\n本名: トラファルガー･D･ワーテル･ロー"
  },
  {
    "objectID": "posts/2025-11-03-python-class-101/index.html#references",
    "href": "posts/2025-11-03-python-class-101/index.html#references",
    "title": "Pythonにおけるオブジェクトとクラス",
    "section": "References",
    "text": "References\n\nGoogle Python Style Guide"
  },
  {
    "objectID": "posts/2024-12-19-shortcuts/index.html",
    "href": "posts/2024-12-19-shortcuts/index.html",
    "title": "自分用ショートカットシート",
    "section": "",
    "text": "command\n動作\ncomment\n\n\n\n\nCtrl + Alt + F&lt;番号&gt;\nTTY切り替え\nGUIがクラッシュしたときに，TTYで原因調査 or reboot 操作が可能かもしれない\n\n\nAlt + F8\nResize Window\nVSCodeのViewProblemショートカットと衝突するので disable"
  },
  {
    "objectID": "posts/2024-12-19-shortcuts/index.html#ubuntu-shortcut-sheet",
    "href": "posts/2024-12-19-shortcuts/index.html#ubuntu-shortcut-sheet",
    "title": "自分用ショートカットシート",
    "section": "",
    "text": "command\n動作\ncomment\n\n\n\n\nCtrl + Alt + F&lt;番号&gt;\nTTY切り替え\nGUIがクラッシュしたときに，TTYで原因調査 or reboot 操作が可能かもしれない\n\n\nAlt + F8\nResize Window\nVSCodeのViewProblemショートカットと衝突するので disable"
  },
  {
    "objectID": "posts/2024-12-19-shortcuts/index.html#vscode-shortcut-sheet",
    "href": "posts/2024-12-19-shortcuts/index.html#vscode-shortcut-sheet",
    "title": "自分用ショートカットシート",
    "section": "VSCode Shortcut sheet",
    "text": "VSCode Shortcut sheet\nVSCodeの画面構成\n\n\n\nVSCode 画面構成例\n\n\n\n\n\n\n\n\n\n構成要素\n説明\n\n\n\n\nエディター\nファイル編集を行うエリア\n\n\nアクティビティバー\nサイドバーに表示する機能を切り替えるアイコン\n\n\nサイドバー\nファイルツリーやデバッグ時の変数などを表示するエリア\n\n\nパネル\n凛とエラーやコンソールログを表示するエリア\n\n\nステータスバー\nエディターで開いているファイルの情報などを端的に表示する\n\n\n\n\nGeneral\n\n\n\n\n\n\n\n\ncommand\n動作\ncomment\n\n\n\n\nF11\nフルスクリーンモード(toggle)\n\n\n\nctrl + B\nサイドバー(EXPLOER)のToggle\n\n\n\nCtrl + K Z\n禅モード\n集中作業や投影のときに使用, toggle\n\n\nCtrl + super + R\nVSCodeのReload\nフリーズしたときなどに有効\n\n\nCtrl + super + Q\nVSCodeの終了\n\n\n\nCtrl + Shift + T\n直前閉じたtabを再び開く\n\n\n\nCtrl + W\n現在フォーカスしているEditor上のファイルを閉じる\n\n\n\nCtrl + Super + W\nEditorで開かれているファイルをすべて閉じる\nデフォルトはCtrl + K Ctrl + W\n\n\nCtrl + +/-/0\nEditor画面のzoom in/out/reset\n\n\n\nCtrl + =\nEditor fontのサイズ拡大\n\n\n\nCtrl + -\nEditor fontのサイズ縮小\n\n\n\nCtrl + 0\nEditor fontのサイズリセット\n\n\n\nCtrl + Shift +=\nVSCode Window zoom 拡大\n\n\n\nCtrl + Shift +-\nVSCode Window zoom 縮小\n\n\n\nCtrl + Shift +0\nVSCode Window zoom リセット\n\n\n\n\n\n\nExplorer\n\n\n\n\n\n\n\n\ncommand\n動作\ncomment\n\n\n\n\nCtrl + shift + E\nExplorerへFocus toggle\n\n\n\n←/→\n選択したファイル/ディレクトリのfold/unfold\n\n\n\nCtrl + ←\nすべてのオブジェクトをworkspace rootまでfold\n\n\n\n\n\n\nEditing\n\n\n\n\n\n\n\n\ncommand\n動作\ncomment\n\n\n\n\nAlt + ↑/↓\nラインの入れ替え\nlogic変更に伴う行の順番入れ替えに便利\n\n\nCtrl + ]\nインデントの追加\n\n\n\nCtrl + [\nインデントの削除\n\n\n\nCtrl + /\nラインのコメントアウト(Toggle)\n言語に合わせてサーソル行のコメントアウト切り替えができる\n\n\nCtrl + Shift + A\nブロックコメントアウト(Toggle)\n\n\n\nCtrl + F\n検索\nShift + Enterでprevious mathch, Enterでnext match\n\n\nCtrl + D\n検索・置換用の文字ブロックが選択される\nCtrl+H or Ctrl+F と組み合わせて使うと便利\n\n\nCtrl + H\n置換モード\n正規表現モード Alt + R, 置換範囲を選択行に限定 Alt + L, 一括変換 Ctrl + Alt + Enter と組み合わせると便利．２階連続押すと Replace にフォーカスされる．キャンセルは Esc\n\n\nCtrl + L\n現在の行全体を選択\nCtrl +Shift + Lと組み合わせると便利\n\n\nCtrl + W\n開いているファイルを閉じる\n\n\n\nCtrl + super + I\nサジェスト機能\n\n\n\nCtrl + U\n選択範囲の大文字変換\n\n\n\nCtrl + super + U\n選択範囲の小文字変換\n\n\n\nCtrl + Shift + ↑\n現在位置からライン先頭までの選択(selection)\n\n\n\nCtrl + Shift + ↓\n現在位置からライン末尾までの選択(selection)\n\n\n\nCtrl + Shift + ←\n現在位置から現在位置のword block先頭までの選択(selection)\n\n\n\nCtrl + Shift + →\n現在位置から現在位置のword block末尾までの選択(selection)\n\n\n\nAlt + F8\n言語サーバーエラー・警告のインライン表示\n\n\n\nF12\n定義参照\n\n\n\nsuper + F12\n定義をサイドに表示\n定義を見ながら修正するときに便利\n\n\n\n\n\nEditing + formatting\n\n\n\n\n\n\n\n\ncommand\n動作\ncomment\n\n\n\n\nCtrl + Shift + I\nコード全体をformatting\neditorTextFocus && !editorHasDocumentFormattingProvider && !editorReadonly && !editor.hasSelection\n\n\nCtrl + Shift + I\n選択したコードをformatting\neditorHasDocumentSelectionFormattingProvider && editorTextFocus && !editorReadonly && editor.hasSelection\n\n\n\n\n\nBracket Editing\n\n\n\n\n\n\n\n\ncommand\n動作\ncomment\n\n\n\n\nCtrl + Alt + \\\nブラケットへの移動\nデフォルトではCtrl + Shift + \\\n\n\nCtrl + Alt + backspace\nブラケットの削除\n\n\n\n\n\n\nEditing + delete\n\n\n\n\n\n\n\n\ncommand\n動作\ncomment\n\n\n\n\nCtrl + Shift + K\nカーソル行の削除\n\n\n\nCtrl + backspace\nカーソルより左側の１単語削除\n\n\n\nCtrl + delete\nカーソルより右側の１単語削除\n\n\n\nCtrl + Super + backspace\nカーソルより左側のすべての単語削除\n\n\n\nCtrl + Super + delete\nカーソルより右側のすべての単語削除\n\n\n\n\n\n\nEditing + Multicursor\n\n\n\n\n\n\n\n\ncommand\n動作\ncomment\n\n\n\n\nCtrl +Shift + L\n選択箇所にマッチする箇所全てにカーソルを展開\nキャンセルしたい場合はEsc\n\n\nAlt +Shift + ↑/↓\nマルチカーソルを上下に展開\nキャンセルしたい場合はEsc\n\n\n\n\n\nEditing + 移動\n\n\n\n\n\n\n\n\ncommand\n動作\ncomment\n\n\n\n\nHome\n文頭まで移動\n\n\n\nEnd\n文末まで移動\n\n\n\nCtrl + Home\nファイル先頭まで移動\n\n\n\nCtrl + End\nファイル文末まで移動\n\n\n\nCtrl + G\n指定した行まで移動\n同僚から「xxx行目見て」って言われたときに便利\n\n\nCtrl + U\n直前までいたカーソル位置に戻る\nF12(定義参照)と組み合わせると便利\n\n\nCtrl + Shift + \\\n次の対応する括弧に移動\narrayやMathJax編集中に便利\n\n\nCtrl + Shift + pageup\n編集tab左移動\n\n\n\nCtrl + Shift + pagedown\n編集tab右移動\n\n\n\nCtrl + tab\n編集tabの選択移動． Ctrl + tab を押し続けて移動先を選択する\n\n\n\nCtrl + super + →\nActive Editorを右に移動する\n\n\n\nCtrl + super + ←\nActive Editorを左に移動する\n\n\n\n\n\n\n表示\n\n\n\n\n\n\n\n\ncommand\n動作\ncomment\n\n\n\n\nAlt + Z\noverflow textのwrap Toggle\n\n\n\nCtrl + Shift + ]\nブロックの展開\n\n\n\nCtrl + Shift + [\nブロックの折りたたみ\n\n\n\nCtrl + K Ctrl + 0\nすべて折りたたむ\n\n\n\nCtrl + K Ctrl + J\n折りたたみをすべて展開する\n\n\n\nCtrl + K Ctrl + 1~7\n指定したレベルに合わせて折りたたむ\n1が折りたたみレベル最上位\n\n\n\n\n\nGit\n\n\n\n\n\n\n\n\ncommand\n動作\ncomment\n\n\n\n\nCtrl + Super + ‘H’\nOpen Changes\ngit管理下のファイルを対象にHEADとの変更点を表示\n\n\n\n\n\nGitHub Copilot\n\n\n\n\n\n\n\n\ncommand\n動作\ncomment\n\n\n\n\nCtrl + i\nインラインGitHub Copilotの起動\nキャンセルはEsc\n\n\nCtrl + Alt + i\nGitHub Copilotの起動(Toggle)\n\n\n\nCtrl +Esc\nCopilotプロセスのキャンセル\n\n\n\n\n\n\nCSV\n ▶  条件\n\nEdit CSVがinstall済み\n\n\n\n\n\n\n\n\n\ncommand\n動作\ncomment\n\n\n\n\nCtrl + Enter\n現在開かれているcsvファイルをtable ui形式で表示\nデータサイズが重たいものについては使用注意"
  },
  {
    "objectID": "posts/2024-12-19-shortcuts/index.html#gnome-terminator-shortcut-sheet",
    "href": "posts/2024-12-19-shortcuts/index.html#gnome-terminator-shortcut-sheet",
    "title": "自分用ショートカットシート",
    "section": "Gnome Terminator Shortcut sheet",
    "text": "Gnome Terminator Shortcut sheet\n% terminator --version    \nterminator 2.1.1\n\nGeneral\n\n\n\n\n\n\n\n\ncommand\n動作\ncomment\n\n\n\n\nCtrl + Alt + T\n新規にgnome terminatorを起動\nUbuntu OS側で設定したショートカットコマンド\n\n\nSuper + B\nkey入力をgroupにbroadcast\ntab切り替え先にも適用される\n\n\nSuper + Shift + B\nBroadcast入力機能のoff\n\n\n\nShift + Ctrl + Q\nTerminal windowをクローズする\n右上の☓をクリックするのと同じ動き\n\n\nShift + Ctrl + F\nterminal上の出力結果の検索\nShift + tabと組み合わせて前方/後方検索可能\n\n\nCtrl + +\nzoom in\n\n\n\nCtrl + -\nzoom out\n\n\n\nCtrl + 0\nzoom reset\n\n\n\n\n\n\nCursor\n\n\n\n\n\n\n\n\ncommand\n動作\ncomment\n\n\n\n\nCtrl + A\n行頭への移動\nhomeでも同じ挙動\n\n\nCtrl + E\n行末に移動\nEndでも同じ挙動\n\n\nCtrl + U\n現在位置から行頭まで削除\n\n\n\nCtrl + K\n現在位置から行末まで削除\n\n\n\nCtrl + W\nワード単位で行頭方向の文字列を削除\n\n\n\n\n\n\nTab\n\n\n\n\n\n\n\n\ncommand\n動作\ncomment\n\n\n\n\nCtrl + Shift + T\n新規tab作成\n\n\n\nCtrl + Super + T\ntabのrename\ntabが作成されているときのみ有効\n\n\nCtrl + pageup\nnext tabへの移動\n\n\n\nCtrl + pageup\nprevious tabへの移動\n\n\n\nCtrl + Shift + W\ntabをクローズ\n\n\n\n\n\n\nPane\n\n\n\n\n\n\n\n\ncommand\n動作\ncomment\n\n\n\n\nShift + Ctrl + E\ncolumn方向に分割\n\n\n\nShift + Ctrl + O\nrow方向に分割\n\n\n\nAlt + ←\n左のpaneへ移動\n-\n\n\nAlt + →\n右のpaneへ移動\n-\n\n\nAlt + ↑\n上のpaneへ移動\n-\n\n\nAlt + ↓\n下のpaneへ移動\n-"
  },
  {
    "objectID": "posts/2024-12-19-shortcuts/index.html#byobu-shortcut-sheet",
    "href": "posts/2024-12-19-shortcuts/index.html#byobu-shortcut-sheet",
    "title": "自分用ショートカットシート",
    "section": "Byobu Shortcut sheet",
    "text": "Byobu Shortcut sheet\n% byobu --version\nbyobu version 5.133\ntmux 3.2a\nデフォルトのショートカットは /usr/share/byobu/keybindings/ にて定義されています．\n\nGeneral\n\n\n\n\n\n\n\n\ncommand\n動作\ncomment\n\n\n\n\nF1\nbyobu-config を新しいウィンドウで開く\n設定メニュー表示\n\n\nF9\n設定メニューを開く（再掲）\nbyobu-config\n\n\nShift + F1\nヘルプを表示\n$BYOBU_PREFIX/share/doc/byobu/help.tmux.txt をページャで表示\n\n\nF5\ntmuxrc を再読み込み\nsource $BYOBU_PREFIX/share/byobu/profiles/tmuxrc\n\n\nAlt + F5\nUTF-8 モードの切り替え\ntoggle-utf8 スクリプト\n\n\nCtrl + F5\nソケット再接続コマンド送信\nbyobu-reconnect-sockets\n\n\nF6\nlogoutしてdetach（セッションから離脱）\n-\n\n\nShift + F6\nlogout せず detach\ntouch no-logout\n\n\nShift + F12\nFキー バインディング無効化\nf-keys.tmux.disable\n\n\nAlt + F12\nマウス操作有効化\nmouse.tmux.enable\n\n\nAlt + Pageup\n現在のwindowの実行履歴をスクロールバック確認\n\n\n\nAlt + Pagedown\n現在のwindowの実行履歴をスクロールフォワード確認\n\n\n\n\n\n\nセッション操作\n\n\n\n\n\n\n\n\ncommand\n動作\ncomment\n\n\n\n\nbyobu new-session\n新規に新しいセッションでbyobuを起動\n同時に複数箇所から同じセッションに入るとバグってしまう\n\n\nCtrl + Shift + F2\n新しいセッションを開始\n\n\n\nCtrl + F8\nセッション名を変更\n-\n\n\n\n\n\nWindow操作\n\n\n\n\n\n\n\n\ncommand\n動作\ncomment\n\n\n\n\nF2\n新しいウィンドウを作成\nカレントディレクトリで作成\n\n\nCtrl + F2\n水平方向に分割\ndisplay-panes → split-window -h\n\n\nShift + F2\n垂直方向に分割\ndisplay-panes → split-window -v\n\n\nF3\n前のウィンドウへ移動\n-\n\n\nF4\n次のウィンドウへ移動\n-\n\n\nAlt + ←\n前のウィンドウへ移動\n-\n\n\nAlt + →\n次のウィンドウへ移動\n-\n\n\nAlt + ↑\n前のクライアントに切り替え\n-\n\n\nAlt + ↓\n次のクライアントに切り替え\n-\n\n\nCtrl + Shift + F3\nウィンドウを1つ前と入れ替え\nswap-window\n\n\nCtrl + Shift + F4\nウィンドウを1つ後と入れ替え\nswap-window\n\n\nF8\nウィンドウ名を変更\n-\n\n\nShift + F11\nsplitされた画面の一つにフォーカスToggle\ncopyコマンドを実行するときに便利\n\n\n\n\n\nPane操作\n\n\n\n\n\n\n\n\ncommand\n動作\ncomment\n\n\n\n\nShift + F3\n前のペインを選択\ndisplay-panes + select-pane\n\n\nShift + F4\n次のペインを選択\ndisplay-panes + select-pane\n\n\nShift + ↑\n上ペインを選択\ndisplay-panes + select-pane\n\n\nShift + ↓\n下ペインを選択\ndisplay-panes + select-pane\n\n\nShift + ←\n左ペインを選択\ndisplay-panes + select-pane\n\n\nShift + →\n右ペインを選択\ndisplay-panes + select-pane\n\n\nCtrl + F3\nペインを上と入れ替え\nswap-pane\n\n\nCtrl + F4\nペインを下と入れ替え\nswap-pane\n\n\nAlt + Shift + ↑\nペインサイズ拡大（上）\nresize-pane\n\n\nAlt + Shift + ↓\nペインサイズ縮小（下）\nresize-pane\n\n\nAlt + Shift + ←\nペインサイズ縮小（左）\nresize-pane\n\n\nAlt + Shift + →\nペインサイズ拡大（右）\nresize-pane\n\n\nCtrl + F6\n現在のペインを kill\n-\n\n\nShift + F11\nペインを一時拡大\nresize-pane -Z\n\n\n\n\n\ncopy-mode操作\n\n\n\n\n\n\n\n\ncommand\n動作\ncomment\n\n\n\n\nF7\ncopy-mode（バッファ選択）\n-\n\n\nShift + F7\n画面全体をキャプチャし新ウィンドウで表示\nPRINTSCREEN\n\n\nAlt + PageDown\ncopy-mode + ページダウン\n-\n\n\nAlt + PageUp\ncopy-mode + ページアップ\n-\n\n\n\n\n\nマルチ操作\n\n\n\n\n\n\n\n\ncommand\n動作\ncomment\n\n\n\n\nShift + F9\n全ペインにコマンド送信\n-\n\n\nCtrl + F9\n全ウィンドウにコマンド送信\n-\n\n\nAlt + F9\npane 同期モード表示\nsynchronize-panes\n\n\n\n\n\n注意が必要な操作\n\n\n\n\n\n\n\n\ncommand\n動作\ncomment\n\n\n\n\nShift + F5\nステータス表示切り替え用スクリプト実行\ncycle-status\n\n\nCtrl + Shift + F5\nプロファイル選択画面を開く\nbyobu-select-profile\n\n\nAlt + F6\n他のクライアントを全て切断\nexcept current\n\n\nAlt + F11\n現在のペインを分離\nbreak-pane\n\n\nCtrl + F11\n直前ウィンドウからペインを join\njoin-pane -h\n\n\nAlt + Insert\nクリップボードから貼り付け\npaste-buffer\n\n\nCtrl + a\nbyobu-ctrl-a 実行\nprefix 操作用の互換対応"
  },
  {
    "objectID": "FAQ/faq.html",
    "href": "FAQ/faq.html",
    "title": "FAQ",
    "section": "",
    "text": "Note統計スキル習得の５つの観点\n\n\n\n\n\n統計手法そのものの理解と，その背後にある数学を用いた理論の理解\n実際のデータに対して統計手法を用いた分析を実行するためのプログラミングスキル\nデータの前処理，環境構築，ソースコードのテストや管理，実装した推定量のデプロイなどのエンジニアリングスキル\n統計学の考え方や発想（例：データ分析のお作法や結果の解釈方法など）\nそもそも解くべきの問題の見つけ方とその問題を解くにあたっての方法論\n\n\n\n統計学の考え方や発想\n「統計学の考え方や発想」を身につけることは\n\nデータを取得したときに最初にすべきこと\nデータ解析で意識しておくべきこと\n結果を解釈するときに肝に銘じておきたいこと\n\nへ繋がってきます．"
  },
  {
    "objectID": "FAQ/faq.html#統計分析",
    "href": "FAQ/faq.html#統計分析",
    "title": "FAQ",
    "section": "",
    "text": "Note統計スキル習得の５つの観点\n\n\n\n\n\n統計手法そのものの理解と，その背後にある数学を用いた理論の理解\n実際のデータに対して統計手法を用いた分析を実行するためのプログラミングスキル\nデータの前処理，環境構築，ソースコードのテストや管理，実装した推定量のデプロイなどのエンジニアリングスキル\n統計学の考え方や発想（例：データ分析のお作法や結果の解釈方法など）\nそもそも解くべきの問題の見つけ方とその問題を解くにあたっての方法論\n\n\n\n統計学の考え方や発想\n「統計学の考え方や発想」を身につけることは\n\nデータを取得したときに最初にすべきこと\nデータ解析で意識しておくべきこと\n結果を解釈するときに肝に銘じておきたいこと\n\nへ繋がってきます．"
  },
  {
    "objectID": "FAQ/faq.html#linux",
    "href": "FAQ/faq.html#linux",
    "title": "FAQ",
    "section": "Linux",
    "text": "Linux\n\n\n\n\n\n\nNoteOSの役割\n\n\n\n\nOSは以下の役割を担う:\n\nユーザとのインタフェース機能（入力の受付・結果表示など）\n記憶装置（ハードディスク，テープ等）やプリンタなどへのデータ入出力の管理\nメモリの管理やリソースの割り当て\nアプリケーションソフトウェアの実行管理（OSが存在しないと，アプリケーションは動作できない）\nシステム全体を統括する中心部分としてカーネルを持ち，GNU/LinuxシステムではLinuxがそのカーネルにあたる\n\n\n\n\n\n\n\n\n\nNoteカーネル情報の確認\n\n\n\n\n% uname -a\nLinux kirby-Desktop 6.14.0-35-generic #35~24.04.1-Ubuntu SMP PREEMPT_DYNAMIC Tue Oct 14 13:55:17 UTC 2 x86_64 x86_64 x86_64 GNU/Linux\n表示フィールドは\nkernel-name nodename kernel-release kernel-version\nmachine processor hardware-platform operating-system\n\n\n\n\n\n\n\n\nフィールド\n例（あなたの環境）\n説明\n\n\n\n\nKernel name\nLinux\nカーネルの種類（通常 Linux）\n\n\nHostname\nryo-billiken-Desktop\nホスト名（マシン名）\n\n\nKernel release\n6.14.0-35-generic\nカーネルのリリースバージョン\n\n\nKernel version\n#35~24.04.1-Ubuntu\nカーネルのビルド番号＋ディストリビューション情報\n\n\nBuild date\nTue Oct 14 13:55:17 UTC\nカーネルがビルドされた日時\n\n\nBuild number / ABI\n2\nABI 番号や追加のビルドメタ情報\n\n\nMachine hardware name\nx86_64\nCPU アーキテクチャ（ハードウェア）\n\n\nProcessor type\nx86_64\nプロセッサタイプ（多くの Linux は machine と同じ値）\n\n\nHardware platform\nx86_64\nハードウェアプラットフォーム（多くの環境で machine と同じ）\n\n\nOperating system\nGNU/Linux\nOS 種別\n\n\n\n\n\n\n\n\n\n\n\nNoteLinuxを学ぶ意義は？\n\n\n\n\n\nLinuxは世界でもっとも使われているOSであり，サーバやクラウド環境で広く採用されている\nコンピューターはOS上で動作し，多くの機器がLinuxを搭載していることから，身の回りのコンピュータがどのような仕組みで動いているか理解する上でLinuxを学ぶ意義がある\nデータ分析実践の場面では，分析サーバやクラウド環境の多くがLinuxを基盤としており，操作や管理能力は実務上重要\nLinuxの知識を身につけることで，効率的なデータ処理，自動化，環境構築など幅広いタスクを自力で行えるようになる\n\n\n\n\n\n\n\n\n\nNoteUbuntuとは？\n\n\n\n\n\nDebian GNU/Linuxをベースとしたディストリビューション\nパッケージはDebianと同じく .deb 形式，パッケージマネージャも APT(Advanced Packaging Tool) を基本的には用いる\nCanonical社から支援を受けつつ，コミュニティーベースで開発\n\nUbuntuにもいろいろなバリエ＝ションがあり，代表例は以下\n\n\n\n\n\n\n\n\n\nバリエーション\n用途・特徴\nデスクトップ環境\nサポート期間\n\n\n\n\nUbuntu Desktop\n一般ユーザー向けデスクトップ\nGNOME\nLTS: 5年\n\n\nUbuntu Server\nサーバー向け，GUIなし\nなし（CLI中心）\nLTS: 5年\n\n\nUbuntu Cloud\nクラウド環境向け（AWS, Azure, OpenStackなど）\nなし\nLTS: 5年\n\n\nUbuntu Core\nIoT・組み込み向け，スナップ中心\nなし\nリリースによる\n\n\n\nLTS系を使うときは，初回リリースには「未知のバグやハードウェア非対応」がある場合があるので基本的には 22.04.2 のような .2 ポイントリリース以降を用いること\n\n\n\n\n\n\n\n\nNoteディレクトリ構造の理解が必須\n\n\n\n\n\nデータ取得・前処理・Notebookの配置・スクリプト実行など分析の中心はファイルやフォルダの操作\n\n\nCLI のほうが正確で速い\nCLI はパス指定で動くためディレクトリ構造の把握が必須\n\n\nサーバーやクラウドは GUI が使えない\n再現性と品質管理にディレクトリ設計が不可欠\nCLI コマンドはそのまま自動化できるが，GUI 操作はできない\nそもそもUnix / Linux システムでは，「UNIXがインストールされたコンピューター（ホスト）に，ネットワーク経由で複数の別のコンピューター（ターミナル）から接続して作業を行う」という利用方法が基本なので，CLI利用が基本\n\n\n\n\n\n\n\n\n\nNoteUbuntuセットアップ命名規則\n\n\n\n\n&lt;username&gt;@&lt;hostname&gt;\n\nusername: 小文字英数字, 先頭文字は英字, - は避ける，_ はOK\nhostname: アンダースコア _ は避ける，小文字英数字\n\n\n\n\n\n\n\n\n\nNoteUbuntu Hostname Guideline\n\n\n\n\n\n\n\n\n\n\n\n\nカテゴリー\n例\n特徴\n\n\n\n\n① 動物・神話生物\nryo-griffinryo-pegasusryo-dragon\n・印象に残る・長期運用向き\n\n\n② プロジェクト名\nryo-regmonkeyryo-digitaltwinryo-hvac\n・用途が明確・ワークスペースや実験環境に最適\n\n\n③ 英語の形容詞＋名詞\nryo-silverfoxryo-blueoak\n・自由度が高い\n\n\n\n\n\n\n\n\n\n\n\n\nNoteLinuxディストリビューションのインストール基本手順\n\n\n\n\n\nインストーラーの作成（USBメモリ等）\nインストーラーの起動（BIOS / UEFI 設定）\nインストール方法の選択（GUI / CLI、言語など）\nストレージ設定\n\nパーティション分割（必要に応じて LVM / 暗号化）\n\nネットワーク設定\n\nDHCP / 固定IP（※ディストリビューションにより前後する）\n\nキーボード配列・タイムゾーンの設定\n初期ユーザー設定\n\nroot パスワード\n\n一般ユーザー\n\nhostname\n\nインストールの実行\nシステムの起動（再起動）\n\n\n\n\n\n\n\n\n\nNoteアプリケーションの導入（ソースコードから）\n\n\n\n\n\nソースコードの入手\nソースコードの配置と展開\n\n一時ディレクトリ（/tmp など）に配置し，アーカイブを展開\n\n事前準備（依存関係の確認・導入）\n設定（./configure の実行）と Makefile の生成\nコンパイル（make）\nインストール（make install）\n動作確認"
  },
  {
    "objectID": "FAQ/faq.html#環境構築",
    "href": "FAQ/faq.html#環境構築",
    "title": "FAQ",
    "section": "環境構築",
    "text": "環境構築\n\n\n\n\n\n\nNoteなぜデータサイエンティストにとって，ネットワークやサーバーなどの基盤知識が必要なのか？\n\n\n\n\n\n自分で好きなように分析環境を整えられるようになる\nリソース不足時に，アルゴリズムの最適化のほか，スケールアップなどのインフラ計画まで踏み込んだ包括的な対応ができるようになる\nシステムトラブル時にどこに問題があるか，どのように対策すれば良いかが判断できるようになる\n\n\n\n\nPython分析環境\n\n\n\n\n\n\nNoteQuick setup for ad-hoc analysis\n\n\n\n\n\npytestやruffをこだわりなくクイックに用いたい場合は uvx(or uv tool run) を用いる\nPyproject.tomlで管理されていないディレクトリでもコマンド自体は利用可能"
  },
  {
    "objectID": "FAQ/faq.html#プログラミング",
    "href": "FAQ/faq.html#プログラミング",
    "title": "FAQ",
    "section": "プログラミング",
    "text": "プログラミング\n\n\n\n\n\n\nNote哲学としてのオブジェクト指向設計（OOD）\n\n\n\n\n\n解決しようとする現実の問題を上手く理解できる形に整理・表現（モデリング）した上で，自分の経験やベストプラクティスをパターンという形に結晶化し，それを再利用すること\n問題をどう捉え，どう構造化するかという思考法そのものを重視\n「オブジェクト指向設計」自体に拘るのではなく「問題解決に使えるオブジェクト指向設計」という考えが重要\n\n\n\n\n\n\n\n\n\nNoteCLIコマンドの引数とオプションの順番\n\n\n\n\n\n「通常は オプション → 引数 の順番」だが，あくまで慣習\nサブコマンド型CLIでは「コマンド → サブコマンド → オプション → 引数」とかもあり得る\n\ncommand [options] [arguments]\n\n\n\n\n\n\n\n\nNotePythonの特徴\n\n\n\n\n\nJavaのようにオブジェクト指向を全面に出さないため，クラスに属さない関数やグローバル変数が定義可能\n一方，データ型はすべてクラスであり，個々のデータ値はインスタンス\n\n\n\n\n\n\n\n\n\nNoteデーモンからのメール\n\n\n\n\nGmailを使用していると mailer-daemon@googlemail.com が差出人となっているメールが届くことがあります．大抵の場合， メールの送信にかんするエラーが発生し，メールサーバーがそのことを知らせるためにメールを送ってくれています．\nここでいう DAEMONは常駐プログラム的な意味のデーモンのことです．つまり，メールサーバーのプログラムが自動的に送信しているメールなので， DAEMONからのメールに返事を出しても意味がありません．"
  },
  {
    "objectID": "FAQ/faq.html#正規表現",
    "href": "FAQ/faq.html#正規表現",
    "title": "FAQ",
    "section": "正規表現",
    "text": "正規表現\n\n\n\n\nメタ文字\n意味\n記述例\nマッチする文字列例\n\n\n\n\n.\n任意の1文字\na.b\nacb, a9b\n\n\n^\n行頭\n^abc\nabcxxx\n\n\n$\n行末\nabc$\nxxxabc\n\n\n\\\nエスケープ\n\\.\n.\n\n\n|\nOR\ncat|dog\ncat, dog\n\n\n*\n0回以上\nab*\na, ab, abbb\n\n\n+\n1回以上\nab+\nab, abbb\n\n\n?\n0または1回\ncolou?r\ncolor, colour\n\n\n{n}\nn回\na{3}\naaa\n\n\n{n,}\nn回以上\na{2,}\naa, aaaa\n\n\n{n,m}\nn〜m回\na{2,4}\naa, aaa, aaaa\n\n\n[abc]\nいずれか1文字\nb[ae]t\nbat, bet\n\n\n[^abc]\n否定クラス\n[^0-9]\na, #\n\n\n[a-z]\n範囲指定\n[a-z]+\nhello\n\n\n[A-Z]\n英大文字\n[A-Z]{2}\nUS, JP\n\n\n[0-9]\n数字\n[0-9]+\n123\n\n\n\\d\n数字\n\\d{4}\n2026\n\n\n\\D\n数字以外\n\\D+\nabc\n\n\n\\w\n英数字＋_\n\\w+\nvar_1\n\n\n\\W\n\\w以外\n\\W+\n!!!\n\n\n\\s\n空白\n\\s+\n, \\t\n\n\n\\S\n非空白\n\\S+\ntext\n\n\n(…)\nグループ\n(ab)+\nab, abab\n\n\n^\n行の先頭\n^#\n# comment\n\n\n$\n行の末尾\n;$\nend;"
  },
  {
    "objectID": "FAQ/faq.html#シェル",
    "href": "FAQ/faq.html#シェル",
    "title": "FAQ",
    "section": "シェル",
    "text": "シェル\n\n\n\n\n\n\nNoteシェル特殊変数\n\n\n\n\n$ がつく特殊変数\n\n\n\n\n\n\n\n\n\n変数\n意味\nexample\n\n\n\n\n$0\n実行中のスクリプト名\necho $0\n\n\n$1〜$9\n位置パラメータ\n./script.sh foo → $1=foo\n\n\n$#\n引数の個数\necho $#\n\n\n$@\n全引数（配列的）\nfor a in \"$@\"; do echo $a; done\n\n\n$*\n全引数（1文字列）\necho \"$*\"\n\n\n$$\n自分のPID\necho $$\n\n\n$?\n直前コマンドの終了コード\nls /nope; echo $?\n\n\n$!\n直前バックグラウンドPID\nsleep 10 & echo $!\n\n\n$_\n直前コマンドの最後の引数\nls /tmp; echo $_\n\n\n\n\nbashの展開系\n\n\n\n\n変数\n意味\nexample\n\n\n\n\n$RANDOM\n乱数 (0–32767)\necho $RANDOM\n\n\n$SECONDS\nシェル起動後の秒数\nsleep 2; echo $SECONDS\n\n\n$LINENO\n現在の行番号\necho $LINENO\n\n\n$FUNCNAME\n関数名\n関数内で echo $FUNCNAME\n\n\n\n\n履歴展開\n\n\n\n\n\n\n\n\n\n書き方\n意味\nexample\n\n\n\n\n!^\n直前コマンドの 最初の引数\ncmd var1 var2 → echo !^ → var1\n\n\n!$\n直前コマンドの 最後の引数\ncmd var1 var2 → echo !$ → var2\n\n\n!*\n直前コマンドの 全引数\ncmd var1 var2 → echo !* → var1 var2\n\n\n!:n\nn番目の引数\ncmd var1 var2 var3 → echo !:2 → var2\n\n\n!:n-m\nn〜m番目\ncmd var1 var2 var3 → echo !:2-3 → var2 var3\n\n\n!:^\n最初の引数（!^ と同じ）\ncmd var1 var2 → echo !:^ → var1\n\n\n!:$\n最後の引数（!$ と同じ）\ncmd var1 var2 → echo !:$ → var2"
  },
  {
    "objectID": "FAQ/faq.html#ドキュメント",
    "href": "FAQ/faq.html#ドキュメント",
    "title": "FAQ",
    "section": "ドキュメント",
    "text": "ドキュメント\n\n\n\n\n\n\nNoteman ドキュメント\n\n\n\n\nman [section] [command/file name]\n\nデフォルトでは less を用いて表示される\npasswd コマンドと /etc/passwd ファイルなど，同じ名前のコマンドやファイルはセクションによって区別します\nコマンドやファイル名の一部しかわからない場合は，apropos コマンドを用いると見出し一部部分マッチで候補を検索することができる\n\n\n\n\n\n\n\n\n\n\nセクション番号\nセクション名\n内容\n\n\n\n\n1\nUser Commands\n一般ユーザ向けコマンド（例：ls, cat, grep）\n\n\n2\nSystem Calls\nカーネルが提供するシステムコール（例：open, read）\n\n\n3\nLibrary Calls\nライブラリ関数（例：printf, malloc）\n\n\n4\nSpecial Files\nデバイスファイル・特殊ファイル（例：/dev/null）\n\n\n5\nFile Formats\n設定ファイル・ファイル形式（例：passwd, fstab）\n\n\n6\nGames\nゲーム・娯楽プログラム\n\n\n7\nMiscellaneous\n規約・標準・マクロ・プロトコル等\n\n\n8\nSystem Administration\n管理者向けコマンド（例：mount, iptables）\n\n\n9\nKernel Routines\nカーネル内部 API（主に開発者向け）"
  },
  {
    "objectID": "FAQ/faq.html#business-communication-skill",
    "href": "FAQ/faq.html#business-communication-skill",
    "title": "FAQ",
    "section": "Business Communication Skill",
    "text": "Business Communication Skill\n\n\n\n\n\n\nNoteなぜWriting Skillsを学ぶ必要があるのか?\n\n\n\n\nwritingは重要なコミュニケーションツールの一つ\nwriting skillがなければどのような才能があっても，自分の考えはvoicelessになってしまう\n\n  It is important for you to recognize that academic success depends not only on the content of \n  your written work but also on the way you write your reports and papers.\n\n\n\n\n\n\n\n\nNote語彙の重要性\n\n\n\n\nword（語彙）は言語や文章，パラグラフの重要なbuilding blocks(構成要素)\nどのような語彙が適切かはどのような場面でのコミュニケーションを想定しているかに依存する"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Regmonkey Datascience Blog",
    "section": "",
    "text": "Order By\n      Default\n      \n        Date - Oldest\n      \n      \n        Date - Newest\n      \n      \n        Title\n      \n    \n  \n    \n      \n      \n    \n\n\n\n\n\n\nDate\n\n\n\nTitle\n\n\n\nCategories\n\n\n\nReading Time\n\n\n\n\n\n\n\n\n2026-01-21\n\n\nログインユーザーリストを確認する\n\n\nLinux\n\n\n11 min\n\n\n\n\n\n\n2026-01-18\n\n\nISOイメージをUSBデバイスに書き込むための dd コマンド\n\n\nLinux\n\n\n2 min\n\n\n\n\n\n\n2026-01-14\n\n\n半導体メーカーの事業形態\n\n\nbusiness\n\n\n14 min\n\n\n\n\n\n\n2026-01-02\n\n\nman ドキュメントの使い方メモ\n\n\n環境構築, Linux\n\n\n3 min\n\n\n\n\n\n\n2025-12-27\n\n\nparquet-toolsコマンド\n\n\n前処理, parquet\n\n\n32 min\n\n\n\n\n\n\n2025-12-24\n\n\n2つcsvファイルのカラムのsumをmarkdown形式で出力する\n\n\npython, 前処理\n\n\n7 min\n\n\n\n\n\n\n2025-12-23\n\n\nCPUとDRAMの「メモリチャネル」とは何か？\n\n\ncomputer\n\n\n6 min\n\n\n\n\n\n\n2025-12-19\n\n\nFisher’s Exact Test\n\n\n統計\n\n\n16 min\n\n\n\n\n\n\n2025-12-15\n\n\n中年男性の中性脂肪分布はLognormalで近似できるか？\n\n\n統計, python\n\n\n15 min\n\n\n\n\n\n\n2025-12-10\n\n\n自分用GitHub Repository作成時のメモ\n\n\n環境構築, github\n\n\n11 min\n\n\n\n\n\n\n2025-12-09\n\n\nISO 8601 カレンダーテーブルの作成\n\n\npython, SQL, shell\n\n\n10 min\n\n\n\n\n\n\n2025-12-05\n\n\nP-valueの考え方\n\n\n統計\n\n\n13 min\n\n\n\n\n\n\n2025-12-04\n\n\nNW Regressionのメモ\n\n\n統計\n\n\n2 min\n\n\n\n\n\n\n2025-12-03\n\n\nUTF-8 の BOM 付き vs BOM なし\n\n\n文字コード\n\n\n6 min\n\n\n\n\n\n\n2025-11-28\n\n\n乱数生成シェルスクリプト\n\n\nshell\n\n\n5 min\n\n\n\n\n\n\n2025-11-27\n\n\npaperless-ngxによるセルフホスティングドキュメント管理システム\n\n\n環境構築, paperless-ngx\n\n\n12 min\n\n\n\n\n\n\n2025-11-16\n\n\nCounterオブジェクト\n\n\npython\n\n\n4 min\n\n\n\n\n\n\n2025-11-15\n\n\nETLメモ\n\n\n前処理\n\n\n9 min\n\n\n\n\n\n\n2025-11-14\n\n\nwatchコマンドを用いてGPUリソースを確認する\n\n\nLinux, 監視\n\n\n6 min\n\n\n\n\n\n\n2025-11-11\n\n\n自分用VSCodeショートカットシート: Git Rebase Message\n\n\n環境構築, shortcuts\n\n\n6 min\n\n\n\n\n\n\n2025-11-04\n\n\n継承，メソッドオーバーライド，スーパーメソッドの呼び出し\n\n\npython\n\n\n12 min\n\n\n\n\n\n\n2025-11-03\n\n\nPythonにおけるオブジェクトとクラス\n\n\npython\n\n\n4 min\n\n\n\n\n\n\n2025-10-30\n\n\nGit Flow–based branch strategy\n\n\n環境構築, git\n\n\n9 min\n\n\n\n\n\n\n2025-10-10\n\n\nZshインタラクティブモードでコメントアウトを使用する\n\n\n環境構築, zsh, shell\n\n\n2 min\n\n\n\n\n\n\n2025-10-06\n\n\nGoogle Cloud Project命名規則\n\n\n環境構築, google cloud\n\n\n2 min\n\n\n\n\n\n\n2025-10-02\n\n\nResearch PapaerにおけるAbstractの書き方\n\n\n方法論\n\n\n4 min\n\n\n\n\n\n\n2025-10-01\n\n\nResearch Proposalの書き方\n\n\n方法論\n\n\n3 min\n\n\n\n\n\n\n2025-09-26\n\n\nネットワークトラブルの切り分け\n\n\nnetwork\n\n\n11 min\n\n\n\n\n\n\n2025-09-23\n\n\nQuartoコンテンツをTailnetで公開する\n\n\nquarto\n\n\n5 min\n\n\n\n\n\n\n2025-09-18\n\n\nSony WH-1000XM4をUbuntu 24.04 LTSで使う\n\n\nbluetooth\n\n\n26 min\n\n\n\n\n\n\n2025-09-17\n\n\nVDIとは？\n\n\n環境構築\n\n\n7 min\n\n\n\n\n\n\n2025-09-12\n\n\n代表的なカーネル関数\n\n\n統計\n\n\n3 min\n\n\n\n\n\n\n2025-09-05\n\n\nSambaの設定とiPad連携\n\n\n環境構築, Linux\n\n\n20 min\n\n\n\n\n\n\n2025-09-04\n\n\nシェルスクリプトにおけるAlias\n\n\nshell\n\n\n1 min\n\n\n\n\n\n\n2025-09-03\n\n\nBashscript Color Code\n\n\nshell\n\n\n1 min\n\n\n\n\n\n\n2025-09-02\n\n\nThesis Statementの書き方\n\n\n方法論\n\n\n5 min\n\n\n\n\n\n\n2025-08-31\n\n\nシェルスクリプトにおける標準出力・標準エラー出力\n\n\nshell\n\n\n4 min\n\n\n\n\n\n\n2025-08-27\n\n\nBias-Variance Tradeoff\n\n\n統計\n\n\n3 min\n\n\n\n\n\n\n2025-08-26\n\n\nシェルスクリプト用のUnit Testingフレームワーク: Bats\n\n\n環境構築, shell\n\n\n8 min\n\n\n\n\n\n\n2025-08-25\n\n\nColumnar Storageの特徴\n\n\nSQL\n\n\n2 min\n\n\n\n\n\n\n2025-08-18\n\n\nflatpak経由でMeldをインストール\n\n\n環境構築\n\n\n7 min\n\n\n\n\n\n\n2025-08-17\n\n\nclam antivirusの導入\n\n\n環境構築, Linux, security\n\n\n5 min\n\n\n\n\n\n\n2025-08-16\n\n\nUbuntu 24.04.3へのupgrade\n\n\n環境構築, Linux\n\n\n6 min\n\n\n\n\n\n\n2025-08-02\n\n\n環境変数 PYTHONSTARTUP の目的\n\n\n環境構築, python\n\n\n4 min\n\n\n\n\n\n\n2025-08-01\n\n\nUbuntu 22.04でのfirewall設定\n\n\n環境構築, Linux, firewall, network\n\n\n11 min\n\n\n\n\n\n\n2025-07-31\n\n\nQuarto Projectへのpseudocode extensions導入\n\n\npseudocode, quarto\n\n\n8 min\n\n\n\n\n\n\n2025-07-30\n\n\nなぜテキストファイルは改行で終わるべきなのか？\n\n\ncoding\n\n\n7 min\n\n\n\n\n\n\n2025-07-29\n\n\nQuarto Version更新用スクリプト\n\n\nquarto\n\n\n3 min\n\n\n\n\n\n\n2025-07-20\n\n\n実行時間計測デコレーター\n\n\n環境構築, python\n\n\n4 min\n\n\n\n\n\n\n2025-07-19\n\n\nNautilusからSSH先のファイルを操作する\n\n\n環境構築, Linux\n\n\n1 min\n\n\n\n\n\n\n2025-07-18\n\n\nbq commandを用いたPatitioned BigQuery External Tableの作成\n\n\n環境構築, gcloud, BigQuery\n\n\n2 min\n\n\n\n\n\n\n2025-07-17\n\n\nモデル管理プラットフォームMLflowの設定\n\n\n環境構築\n\n\n5 min\n\n\n\n\n\n\n2025-07-11\n\n\nGitHub OSS Contribution: ForkからPull Request\n\n\n方法論\n\n\n5 min\n\n\n\n\n\n\n2025-07-09\n\n\n集合列の和集合・直和・共通部分\n\n\n集合論\n\n\n2 min\n\n\n\n\n\n\n2025-07-08\n\n\nLaw of Large Numbers\n\n\n統計\n\n\n3 min\n\n\n\n\n\n\n2025-07-07\n\n\n平方完成と確率密度関数\n\n\n統計\n\n\n1 min\n\n\n\n\n\n\n2025-07-06\n\n\n統計学におけるBig OpとLittle Op\n\n\n統計\n\n\n10 min\n\n\n\n\n\n\n2025-07-05\n\n\n集合 \\((0,1)^N\\) の濃度\n\n\n集合論\n\n\n4 min\n\n\n\n\n\n\n2025-07-03\n\n\n理想気体の全微分\n\n\n解析, 熱力学\n\n\n2 min\n\n\n\n\n\n\n2025-07-02\n\n\n収束の条件とCauchyの判定法\n\n\n解析, 収束\n\n\n3 min\n\n\n\n\n\n\n2025-07-01\n\n\nある慣性系で２つの平行な軌道\n\n\n線形代数, physics\n\n\n1 min\n\n\n\n\n\n\n2025-06-28\n\n\nDatamart作成Tips\n\n\nSQL\n\n\n1 min\n\n\n\n\n\n\n2025-06-27\n\n\nWindowsライクなスナップ機能をUbuntuで使う\n\n\nLinux\n\n\n1 min\n\n\n\n\n\n\n2025-06-24\n\n\nCSVファイルの特定のカラムをawkで計算変換する\n\n\n前処理, shell, awk\n\n\n9 min\n\n\n\n\n\n\n2025-06-18\n\n\nカントールの対関数の全単射性の証明\n\n\n集合論\n\n\n5 min\n\n\n\n\n\n\n2025-06-17\n\n\n可算集合と濃度\n\n\n集合論\n\n\n2 min\n\n\n\n\n\n\n2025-06-16\n\n\n冷凍機油\n\n\n空調機\n\n\n7 min\n\n\n\n\n\n\n2025-06-15\n\n\n断熱圧縮とポリトロープ変化\n\n\n熱力学\n\n\n7 min\n\n\n\n\n\n\n2025-06-14\n\n\nPH線図: pressure-enthalpy chart\n\n\n熱力学\n\n\n9 min\n\n\n\n\n\n\n2025-06-13\n\n\nエントロピーとエンタルピー\n\n\n熱力学\n\n\n11 min\n\n\n\n\n\n\n2025-06-12\n\n\n物質量と気体の体積\n\n\n熱力学\n\n\n3 min\n\n\n\n\n\n\n2025-06-11\n\n\n冷凍サイクルとヒートポンプの基礎\n\n\n熱力学, 空調機\n\n\n9 min\n\n\n\n\n\n\n2025-06-03\n\n\n目標設定例および設定ガイドライン\n\n\n方法論\n\n\n2 min\n\n\n\n\n\n\n2025-06-02\n\n\nボイル=シャルルの法則の導出\n\n\n熱力学\n\n\n2 min\n\n\n\n\n\n\n2025-05-30\n\n\nドキュメントの書き方\n\n\n方法論\n\n\n2 min\n\n\n\n\n\n\n2025-05-23\n\n\nwikiにどのような情報をどのように残すか？\n\n\n方法論, 環境構築\n\n\n5 min\n\n\n\n\n\n\n2025-05-19\n\n\nRoo Code環境構築\n\n\n環境構築\n\n\n7 min\n\n\n\n\n\n\n2025-05-01\n\n\nCSSの組み込み方\n\n\nhtml, quarto\n\n\n1 min\n\n\n\n\n\n\n2025-04-30\n\n\nCSSで使う単位\n\n\nhtml, quarto\n\n\n4 min\n\n\n\n\n\n\n2025-04-29\n\n\nシェルコマンドTips\n\n\nshell\n\n\n3 min\n\n\n\n\n\n\n2025-04-24\n\n\nレシプロエンジンの仕組み\n\n\n製造業\n\n\n1 min\n\n\n\n\n\n\n2025-04-10\n\n\nD3を用いた散布図生成\n\n\nD3, EDA\n\n\n1 min\n\n\n\n\n\n\n2025-04-09\n\n\nベクトル空間における外積\n\n\n線形代数\n\n\n18 min\n\n\n\n\n\n\n2025-04-08\n\n\n確率行列と固有値\n\n\n線形代数, 統計\n\n\n2 min\n\n\n\n\n\n\n2025-04-07\n\n\nベクトル空間における内積\n\n\n線形代数, 複素数\n\n\n10 min\n\n\n\n\n\n\n2025-04-01\n\n\n地図と標準誤差\n\n\n統計, 地図\n\n\n1 min\n\n\n\n\n\n\n2025-03-05\n\n\n三角関数の加法定理\n\n\n三角関数\n\n\n7 min\n\n\n\n\n\n\n2025-03-03\n\n\nいろいろな三角不等式\n\n\n複素数, 幾何, 線形代数\n\n\n5 min\n\n\n\n\n\n\n2025-03-02\n\n\n敵の砲台の座標を探せ 1/N\n\n\n幾何\n\n\n9 min\n\n\n\n\n\n\n2025-03-01\n\n\nヘロンの公式の導出\n\n\n幾何\n\n\n2 min\n\n\n\n\n\n\n2025-02-28\n\n\nカバリエリの原理\n\n\n幾何\n\n\n14 min\n\n\n\n\n\n\n2025-02-27\n\n\ntangent 75°の図形的計算\n\n\n三角関数\n\n\n2 min\n\n\n\n\n\n\n2025-02-26\n\n\n余弦定理の考え方\n\n\n三角関数\n\n\n5 min\n\n\n\n\n\n\n2025-02-25\n\n\n正弦定理の考え方\n\n\n三角関数\n\n\n7 min\n\n\n\n\n\n\n2025-02-20\n\n\npivot tableのcolumn, rowのsort\n\n\npython, 前処理\n\n\n3 min\n\n\n\n\n\n\n2025-02-19\n\n\nGroup毎に定義されたラグ変数の作成\n\n\npython, 前処理\n\n\n9 min\n\n\n\n\n\n\n2025-02-14\n\n\n本日の詰将棋: Quiz 1~5\n\n\n将棋\n\n\n1 min\n\n\n\n\n\n\n2025-02-13\n\n\n複素平面と複素数による回転\n\n\n複素数\n\n\n12 min\n\n\n\n\n\n\n2025-02-07\n\n\nwget vs curl\n\n\nshell\n\n\n8 min\n\n\n\n\n\n\n2025-02-05\n\n\n測量法における測量の分類\n\n\n測量\n\n\n1 min\n\n\n\n\n\n\n2025-02-04\n\n\n単曲線と追加距離の計算\n\n\n三角関数, 測量\n\n\n4 min\n\n\n\n\n\n\n2025-02-03\n\n\n関数の連続性\n\n\n解析\n\n\n7 min\n\n\n\n\n\n\n2025-02-02\n\n\n有限個の多項式のテイラー展開\n\n\n解析\n\n\n4 min\n\n\n\n\n\n\n2025-02-01\n\n\n18世紀までの関数論とテイラー展開\n\n\n解析\n\n\n5 min\n\n\n\n\n\n\n2025-01-30\n\n\n微分方程式を用いたToy models\n\n\n微分方程式\n\n\n5 min\n\n\n\n\n\n\n2025-01-29\n\n\nフーリエ級数と積分理論再考\n\n\nフーリエ変換\n\n\n4 min\n\n\n\n\n\n\n2025-01-28\n\n\n数理モデルの作り方\n\n\n方法論\n\n\n1 min\n\n\n\n\n\n\n2025-01-27\n\n\n指数関数の微分\n\n\n解析\n\n\n2 min\n\n\n\n\n\n\n2025-01-10\n\n\nLinuxシステム上のユーザー一覧を条件に応じて表示する\n\n\nshell, Linux\n\n\n3 min\n\n\n\n\n\n\n2025-01-08\n\n\nBigQuery: TIME型カラムを指定したレベルで丸めて集計する\n\n\nSQL\n\n\n2 min\n\n\n\n\n\n\n2024-12-19\n\n\n自分用ショートカットシート\n\n\n環境構築, shortcuts\n\n\n37 min\n\n\n\n\n\n\n2024-12-18\n\n\nSecure Shellの仕組み\n\n\nssh\n\n\n7 min\n\n\n\n\n\n\n2024-12-17\n\n\nFirefoxを用いたsocks5 proxyブラウザアクセス設定\n\n\nfirefox, network\n\n\n2 min\n\n\n\n\n\n\n2024-12-16\n\n\nmacOSへのssh接続\n\n\nssh, 環境構築\n\n\n1 min\n\n\n\n\n\n\n2024-12-11\n\n\nCloud StorageからExternal Tableの作成\n\n\nBigQuery\n\n\n2 min\n\n\n\n\n\n\n2024-12-07\n\n\nIPアドレス 0.0.0.0\n\n\nnetwork, quarto\n\n\n3 min\n\n\n\n\n\n\n2024-06-07\n\n\n[過去記事の転記] Ubuntu Desktop Noble Numbatのインストール\n\n\n環境構築, Ubuntu\n\n\n2 min\n\n\n\n\n\n\n2022-08-11\n\n\n[過去ブログからの転記] Shebangにおける /bin/bash と /usr/bin/bash の違い\n\n\nLinux, shell\n\n\n2 min\n\n\n\n\n\n\n2021-05-07\n\n\n[過去ブログからの転記] Linuxにおける時刻管理\n\n\nLinux\n\n\n15 min\n\n\n\n\n\n\n2021-05-05\n\n\nLinuxにおけるパーミッション\n\n\nLinux\n\n\n7 min\n\n\n\n\n\n\n2021-01-16\n\n\n追加されたPersonal Package Archive(PPA)の管理\n\n\n環境構築, Linux\n\n\n7 min\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "dashboard/dashboard.html",
    "href": "dashboard/dashboard.html",
    "title": "regmonkey datascience blog",
    "section": "",
    "text": "Total Posts\n\n\n121\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPosts in This Month\n\n\n0\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLast Update\n\n\n\n\n2026-02-02"
  },
  {
    "objectID": "posts/2025-10-02-how-to-write-an-abstract/index.html",
    "href": "posts/2025-10-02-how-to-write-an-abstract/index.html",
    "title": "Research PapaerにおけるAbstractの書き方",
    "section": "",
    "text": "NoteAbstractとは分析レポートの簡潔なサマリー\n\n\n\n\nAbstractとは読者に「研究の全体像を理解」させるための簡潔なサマリー文章のこと．必要条件として以下の要件を満たす必要があります\n\n研究の目的・問い・方法・主要分析結果・意義を抑えていること\nself-contained(自己完結的)な文章であること(=本文を読まなくても，研究の目的・方法・結果・意義がわかる)\n\n\n\nDescriptive Abstract vs Informative Abstract\n状況に応じるが，基本的には分析レポートについてのAbstractはInformative Abstractであるべきとされます．\n\n\n\n\n\n\n\n\n\n種類\n特徴\n構成内容\n\n\n\n\nInformative Abstract\n研究の 目的・問い・方法・主要分析結果・意義 をすべて含み，論文のエッセンスを要約する\n背景・目的 / 問い / 方法 / 結果 / 結論（5要素すべて）\n\n\nDescriptive Abstract\n論文の主な構成やテーマの概要を述べるだけで，結果や結論を含まない\n研究の範囲・主題・目的・手法の概要のみ（具体的な結果・結論は書かない）\n\n\n\n\n\n論文の主な構成は「Introduction」で記載すれば良い\n後述の「Selection」「Indexing」機能を享受したいのであるならば， 目的・問い・方法・主要分析結果・意義 をすべて含むのが良い"
  },
  {
    "objectID": "posts/2025-10-02-how-to-write-an-abstract/index.html#abtractとは",
    "href": "posts/2025-10-02-how-to-write-an-abstract/index.html#abtractとは",
    "title": "Research PapaerにおけるAbstractの書き方",
    "section": "",
    "text": "NoteAbstractとは分析レポートの簡潔なサマリー\n\n\n\n\nAbstractとは読者に「研究の全体像を理解」させるための簡潔なサマリー文章のこと．必要条件として以下の要件を満たす必要があります\n\n研究の目的・問い・方法・主要分析結果・意義を抑えていること\nself-contained(自己完結的)な文章であること(=本文を読まなくても，研究の目的・方法・結果・意義がわかる)\n\n\n\nDescriptive Abstract vs Informative Abstract\n状況に応じるが，基本的には分析レポートについてのAbstractはInformative Abstractであるべきとされます．\n\n\n\n\n\n\n\n\n\n種類\n特徴\n構成内容\n\n\n\n\nInformative Abstract\n研究の 目的・問い・方法・主要分析結果・意義 をすべて含み，論文のエッセンスを要約する\n背景・目的 / 問い / 方法 / 結果 / 結論（5要素すべて）\n\n\nDescriptive Abstract\n論文の主な構成やテーマの概要を述べるだけで，結果や結論を含まない\n研究の範囲・主題・目的・手法の概要のみ（具体的な結果・結論は書かない）\n\n\n\n\n\n論文の主な構成は「Introduction」で記載すれば良い\n後述の「Selection」「Indexing」機能を享受したいのであるならば， 目的・問い・方法・主要分析結果・意義 をすべて含むのが良い"
  },
  {
    "objectID": "posts/2025-10-02-how-to-write-an-abstract/index.html#abtractの機能-selectionとindexing",
    "href": "posts/2025-10-02-how-to-write-an-abstract/index.html#abtractの機能-selectionとindexing",
    "title": "Research PapaerにおけるAbstractの書き方",
    "section": "Abtractの機能: SelectionとIndexing",
    "text": "Abtractの機能: SelectionとIndexing\n\n\n\n\n\n\n\n\n\n\n機能\n内容\n読者にとっての意味\n執筆者にとってのポイント\n\n\n\n\n1. Selection Function\n研究の目的・方法・主要結果・意義を簡潔に伝える\n- 論文を読む・引用する・購読するかを判断できる- 自分の研究テーマとの関連性を素早く評価できる\n- 読者に「読む理由」を与えるように設計する- 特徴的な結果や新規性を明確に打ち出す\n\n\n2. Indexing Function\n論文データベース（例：arXiv）などで論文が適切に検索・分類されるようにする\n- 検索キーワードや要約から論文を発見できる\n- 適切な専門用語・キーワードをAbstract内に自然に含める- 分野標準の表現・語彙を用いる"
  },
  {
    "objectID": "posts/2025-10-02-how-to-write-an-abstract/index.html#abtractの5つの構成要素",
    "href": "posts/2025-10-02-how-to-write-an-abstract/index.html#abtractの5つの構成要素",
    "title": "Research PapaerにおけるAbstractの書き方",
    "section": "✅ Abtractの5つの構成要素",
    "text": "✅ Abtractの5つの構成要素\n\n\n\n\n\n\nNote① Reason for writing（研究を行う理由）\n\n\n\n\nなぜこの研究が必要なのか（問題意識・背景・意義）を簡潔に述べる\n読者が「なぜこのテーマが重要か」を理解できるようにする\n\n\n\n\n\n\n\n\n\nNote② Problem / Research Question（研究課題・研究質問）\n\n\n\n\n解決すべき問題（gap），または検証すべき問い（question）を明示する\n「何を明らかにしようとしているのか」を一文で言い切る\n\n\n\n\n\n\n\n\n\nNote③ Method / Approach（方法・手法）\n\n\n\n\nどのようなデータ・モデル・実験・分析を用いたかを簡潔に説明する\n詳細よりも「方法の枠組み」を明確にする\n\n\n\n\n\n\n\n\n\nNote④ Results / Findings（結果）\n\n\n\n\n得られた成果・検証結果を簡潔にまとめる\nできるだけ具体的な改善・効果・発見を述べる\n\n\n\n\n\n\n\n\n\nNote⑤ Conclusion / Implication（結論・意義）\n\n\n\n\n得られた結果がどのような意義・貢献をもつかを示す\n結果を踏まえた上で，実証/理論分野における今後の展望などを1〜2文でまとめる\n\n\n\n\nstructured abstract: IMRaD ⽅式\n医学・生命科学系の論文では，IMRaD方式を用いたstructured abstractがよく使われます．\n\n\n\n\n\n\n\n\n\n\nセクション\n目的\nキーとなる質問\n含めるべき要素\n\n\n\n\nIntroduction\n研究の動機・背景を説明する\n「なぜこの研究を行うのか？」\n背景，先行研究の限界，研究目的（明確な仮説）\n\n\nMethods\n研究をどのように実施したか説明する\n「どのように研究を行ったのか？」\n研究デザイン，データ取得⽅法，主要評価アウトカム，統計解析\n\n\nResults\n研究で得られた結果を報告する\n「何が分かったのか？」\n主な結果（表・図・統計指標），頑健性check\n\n\nDiscussion\n結果をどのように解釈し，どのような意味があるかを論じる\n「この結果は何を意味するのか？」\n主な発見の解釈，先行研究との比較，限界，今後の展望"
  },
  {
    "objectID": "posts/2025-02-26-law-of-cosines/index.html",
    "href": "posts/2025-02-26-law-of-cosines/index.html",
    "title": "余弦定理の考え方",
    "section": "",
    "text": "Exercise 1 \n\\(AC = 30, BC = 26, \\angle C = 70^\\circ\\) となるような \\(\\triangle ABC\\) が与えられたとします．このとき，長さ \\(AB\\) を求めよ\n\n\n\nCode\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport matplotlib.patches as patches\n\n# 辺の長さと角度\nAC = 30\nBC = 26\nangle_C = 70\n\n# 角度をラジアンに変換\nangle_C_rad = np.radians(angle_C)\n\n# 点Aの座標\nA = (0, 0)\n\nAB = np.sqrt(30**2 + 26**2 - 2 * 30 * 26 * np.cos(np.radians(70)))\n\n# 点Bの座標\nB = (AB, 0)\n\n# 点Cの座標\ncos_A = (30**2 + AB**2 - 26**2) / (2 * 30 * AB)\nsin_A = np.sqrt(1 - cos_A**2)\nC = (30 * cos_A, 30 * sin_A)\n\nslope = - (C[0] - B[0])/(C[1] - B[1])\nH = (24.6, 24.6 * slope)\n\n\n# 座標をリストに変換\nfig, ax = plt.subplots(figsize=(6, 6))\n\nax.plot([A[0], H[0]], [A[1], H[1]], \"k\")  # Black line with circle markers\nax.plot([A[0], B[0]], [A[1], B[1]], \"ko-\")  # Black line with circle markers\nax.plot([B[0], C[0]], [B[1], C[1]], \"ko-\")  # Black line with circle markers\nax.plot([C[0], A[0]], [C[1], A[1]], \"ko-\")  # Black line with circle markers\n\n# 点のラベル\nplt.text(H[0]-2, H[1], \"H\")\nplt.text(A[0]-2, A[1], \"A\")\nplt.text(B[0]+1, B[1], \"B\")\nplt.text(C[0]+1, C[1], \"C\")\n\n# 軸の範囲を設定\nplt.xlim(-5, 35)\nplt.ylim(-5, 35)\n\n# 軸のラベルを設定\nplt.xlabel(\"X\")\nplt.ylabel(\"Y\")\n\n# タイトルを設定\nplt.title(\"Triangle ABC\")\n\n# Add angles as arcs\narc_radius = 5  # Radius for the arcs\n\n# Angle at B\nangle_C_arc = patches.Arc(C, arc_radius*0.8, arc_radius*0.8, angle=250, theta1=np.degrees(320), theta2=np.degrees(70), color='blue')\nax.add_patch(angle_C_arc)\nax.text(C[0]-1, C[1] - arc_radius*.8, f\"{70}°\", fontsize=12, color='blue')\n# ax.text(C[0] + arc_radius/2, B[1] + 1, f\"{70}°\", fontsize=12, color='blue')\nax.text(5, 10, \"AC = 30\", fontsize=12, color='black', horizontalalignment='center')\nax.text(30, 10, \"BC = 26\", fontsize=12, color='black', horizontalalignment='center')\n\n# 図の表示\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 1\n\n\n\nこのとき，点 \\(A\\) から \\(BC\\) に対して垂線を下ろし，その交点を \\(H\\) とします．このとき\n\\[\n\\begin{align}\nCH &= AC * \\cos(C)\\\\\nBH &= BC - AC * \\cos(C)\\\\\nAH& = AC * \\sin(C)\n\\end{align}\n\\]\nピタゴラスの定理より\n\\[\nAB^2 = AH^2 + BH^2\n\\]\nなので\n\\[\n\\begin{align}\nAB^2 &= (BC - AC * \\cos(C))^2 + (AC * \\sin(C))^2\\\\\n     &= BC^2 + AC^2 - 2\\cdot BC\\cdot AC \\cos(C)\n\\end{align}\n\\]\n従って，\n\n\nCode\nprint(f\"AB = {AB:.2f}\")\n\n\nAB = 32.29\n\n\n ▶  ベクトルを用いた直感的理解\nベクトルの内積は \\(\\vec a \\cdot \\vec b = \\lvert a \\rvert \\lvert b \\rvert \\cos \\theta\\) で定義されることを利用すると，\n\\[\n\\begin{aligned}\nAB^2\n    &= \\left\\lvert \\overrightarrow{CA} - \\overrightarrow{CB} \\right\\rvert^2 \\\\\n    &= (\\overrightarrow{CA} - \\overrightarrow{CB}) \\cdot (\\overrightarrow{CA} - \\overrightarrow{CB}) \\\\\n    &= \\left\\lvert \\overrightarrow{CA} \\right\\rvert^2 + \\left\\lvert \\overrightarrow{CB} \\right\\rvert^2\n    - 2 \\overrightarrow{CA} \\cdot \\overrightarrow{CB} \\\\\n    &= \\left\\lvert \\overrightarrow{CA} \\right\\rvert^2 + \\left\\lvert \\overrightarrow{CB} \\right\\rvert^2\n    - 2 \\left\\lvert \\overrightarrow{CA} \\right\\rvert \\left\\lvert \\overrightarrow{CB} \\right\\rvert \\cos(\\angle ACB) \\\\\n    &= AC^2 + BC^2  - 2\\cdot AC\\cdot BC \\cos(C)\n\\end{aligned}\n\\]\n\n\n\n\nExercise 2 \n四角形PABQ が以下のように与えられている\n\n\\(AB = 10\\)\n\\(\\angle PAB = {75}^\\circ\\)\n\\(\\angle PBA = {50}^\\circ\\)\n\\(\\angle PAQ = {40}^\\circ\\)\n\\(\\angle QAB = {35}^\\circ\\)\n\\(\\angle PBQ = {70}^\\circ\\)\n\nこのとき，PQの距離を求めよ．\n\nCode\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport matplotlib.patches as patches\n\n# 辺の長さと角度\nAB = 10\nangle_PAB = np.radians(75)\nangle_PBA = np.radians(50)\nangle_QAB = np.radians(35)\nangle_AQB = np.radians(25)\nangle_QBA = np.radians(120)\nangle_APB = np.radians(55)\n\n\n# 点Aの座標\nA = (0, 0)\n\n# 点Bの座標\nB = (AB, 0)\n\n# 点Pの座標\nPA = AB / np.sin(angle_APB) * np.sin(angle_PBA)\nP = ((np.cos(angle_PAB)) * PA, (np.sin(angle_PAB)) * PA)\n\n# 点Qの座標\nQA = AB / np.sin(angle_AQB) * np.sin(angle_QBA)\nQ = ((np.cos(angle_QAB)) * QA, (np.sin(angle_QAB)) * QA)\n\n\n# 座標をリストに変換\nfig, ax = plt.subplots(figsize=(6, 6))\n\nax.plot([A[0], P[0]], [A[1], P[1]], \"k\")  # Black line with circle markers\nax.plot([A[0], B[0]], [A[1], B[1]], \"ko-\")  # Black line with circle markers\nax.plot([B[0], P[0]], [B[1], P[1]], \"ko-\")  # Black line with circle markers\nax.plot([Q[0], A[0]], [Q[1], A[1]], \"ko-\")  # Black line with circle markers\nax.plot([Q[0], B[0]], [Q[1], B[1]], \"ko-\")  # Black line with circle markers\nax.plot([Q[0], P[0]], [Q[1], P[1]], \"ko-\")  # Black line with circle markers\n\n# 点のラベル\nplt.text(A[0] - 1, A[1], \"A\")\nplt.text(B[0] + 1, B[1], \"B\")\nplt.text(P[0], P[1] + 1, \"P\")\nplt.text(Q[0] + 1, Q[1], \"Q\")\n\n# 軸の範囲を設定\nplt.xlim(-2, 20)\nplt.ylim(-2, 20)\n\n# 軸のラベルを設定\nplt.xlabel(\"X\")\nplt.ylabel(\"Y\")\n\n# タイトルを設定\nplt.title(\"How far is the distance between P and Q\")\n\n# Add angles as arcs\narc_radius = 5  # Radius for the arcs\n\n# Angle at B\nax.text(A[0] + 1, A[1] + 1.8, f\"{40}°\", fontsize=10, color=\"blue\")\nax.text(A[0] + 1, A[1] + 0.2, f\"{35}°\", fontsize=10, color=\"blue\")\nax.text(B[0] - 2, B[1] + 0.2, f\"{50}°\", fontsize=10, color=\"blue\")\nax.text(B[0] - 0.5, B[1] + 1, f\"{70}°\", fontsize=10, color=\"blue\")\n# ax.text(C[0] + arc_radius/2, B[1] + 1, f\"{70}°\", fontsize=12, color='blue')\nax.text(5, -1, \"AB = 10\", fontsize=12, color=\"black\", horizontalalignment=\"center\")\nax.text(\n    (P[0] + Q[0]) / 2,\n    (P[1] + Q[1]) / 2 + 1,\n    \"PQ = ???\",\n    fontsize=12,\n    color=\"black\",\n    horizontalalignment=\"center\",\n)\n\n\n# 図の表示\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 2\n\n\n\n\n\n\n\n\n\n\n\n\nNoteSolution 1: 余弦定理を用いて解く\n\n\n\n\n\n\\(\\angle PAQ = {40}^\\circ\\) と問題分よりわかるので，\\(PA, QA\\) の長さがわかれば余弦定理より \\(PQ\\) が導出できます．\n正弦定理を用いて\n\\[\n\\begin{align}\nPA &= \\frac{AB}{\\sin({55}^\\circ)}\\times \\sin({50}^\\circ)\\\\\nQA &= \\frac{AB}{\\sin({25}^\\circ)}\\times \\sin({120}^\\circ)\n\\end{align}\n\\]\n余弦定理を用いると\n\\[\nPQ^2 = QA^2 + PA^2 - 2(PA)(QA)\\cos({40}^\\circ)\n\\]\nよって，\n\n\nCode\n# set variables\nAB = 10\nangle_APB = np.radians(55)\nangle_AQB = np.radians(25)\nangle_PBA = np.radians(50)\nangle_QBA = np.radians(120)\nangle_PAQ = np.radians(40)\n\n\n# compute PA and QA\nPA = AB / np.sin(angle_APB) * np.sin(angle_PBA)\nQA = AB / np.sin(angle_AQB) * np.sin(angle_QBA)\n\n\n# comnpute PQ using laws of cosines\nPQ = np.sqrt(PA ** 2 + QA **2 - 2 * PA * QA * np.cos(angle_PAQ))\n\nprint(f\"PQ = {PQ:.2f}\")\n\n\nPQ = 14.62\n\n\n\n\n\n\n\n\n\n\n\n\nNoteSolution 2: 座標を用いて解く\n\n\n\n\n\n各点を \\(XY\\) 平明座標に以下のように置き換えます\n\n\\(A\\) = (0, 0)\n\\(B\\) = (0, 10)\n\nこのとき，点 \\(P\\) の座標 \\((P_X, P_Y)\\) は\n\\[\n\\begin{align}\nP_X & = PA \\cdot \\cos({75}^\\circ)\\\\\nP_Y & = PA \\cdot \\sin({75}^\\circ)\n\\end{align}\n\\]\n同様に点 \\(Q\\) の座標 \\((Q_X, Q_Y)\\) は\n\\[\n\\begin{align}\nQ_X & = QA \\cdot \\cos({35}^\\circ)\\\\\nQ_Y & = QA \\cdot \\sin({35}^\\circ)\n\\end{align}\n\\]\nこのとき，長さ \\(PQ\\) は点 \\(P, Q\\) の距離と表せるので\n\\[\n\\begin{align}\nPQ &= \\lVert P - Q \\rVert\\\\\n   &= \\sqrt{(P_X - Q_X)^2 + (P_Y - Q_Y)^2}\\\\\n   &= \\sqrt{(AQ^2 + PA^2 - 2(PA)(QA)(\\cos({35}^\\circ)\\cos({75}^\\circ) + \\sin({35}^\\circ)\\sin({75}^\\circ)))}\n\\end{align}\n\\]\n加法定理より\n\\[\n\\cos (A \\pm B) = \\cos A \\cos B \\mp \\sin A \\sin B\n\\]\nなので\n\\[\n\\cos({35}^\\circ)\\cos({75}^\\circ) + \\sin({35}^\\circ)\\sin({75}^\\circ) = \\cos({40}^\\circ)\n\\]\n従って，\n\\[\nPQ^2 = QA^2 + PA^2 - 2(PA)(QA)\\cos({40}^\\circ)\n\\]"
  },
  {
    "objectID": "posts/2025-02-26-law-of-cosines/index.html#余弦定理の考え方",
    "href": "posts/2025-02-26-law-of-cosines/index.html#余弦定理の考え方",
    "title": "余弦定理の考え方",
    "section": "",
    "text": "Exercise 1 \n\\(AC = 30, BC = 26, \\angle C = 70^\\circ\\) となるような \\(\\triangle ABC\\) が与えられたとします．このとき，長さ \\(AB\\) を求めよ\n\n\n\nCode\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport matplotlib.patches as patches\n\n# 辺の長さと角度\nAC = 30\nBC = 26\nangle_C = 70\n\n# 角度をラジアンに変換\nangle_C_rad = np.radians(angle_C)\n\n# 点Aの座標\nA = (0, 0)\n\nAB = np.sqrt(30**2 + 26**2 - 2 * 30 * 26 * np.cos(np.radians(70)))\n\n# 点Bの座標\nB = (AB, 0)\n\n# 点Cの座標\ncos_A = (30**2 + AB**2 - 26**2) / (2 * 30 * AB)\nsin_A = np.sqrt(1 - cos_A**2)\nC = (30 * cos_A, 30 * sin_A)\n\nslope = - (C[0] - B[0])/(C[1] - B[1])\nH = (24.6, 24.6 * slope)\n\n\n# 座標をリストに変換\nfig, ax = plt.subplots(figsize=(6, 6))\n\nax.plot([A[0], H[0]], [A[1], H[1]], \"k\")  # Black line with circle markers\nax.plot([A[0], B[0]], [A[1], B[1]], \"ko-\")  # Black line with circle markers\nax.plot([B[0], C[0]], [B[1], C[1]], \"ko-\")  # Black line with circle markers\nax.plot([C[0], A[0]], [C[1], A[1]], \"ko-\")  # Black line with circle markers\n\n# 点のラベル\nplt.text(H[0]-2, H[1], \"H\")\nplt.text(A[0]-2, A[1], \"A\")\nplt.text(B[0]+1, B[1], \"B\")\nplt.text(C[0]+1, C[1], \"C\")\n\n# 軸の範囲を設定\nplt.xlim(-5, 35)\nplt.ylim(-5, 35)\n\n# 軸のラベルを設定\nplt.xlabel(\"X\")\nplt.ylabel(\"Y\")\n\n# タイトルを設定\nplt.title(\"Triangle ABC\")\n\n# Add angles as arcs\narc_radius = 5  # Radius for the arcs\n\n# Angle at B\nangle_C_arc = patches.Arc(C, arc_radius*0.8, arc_radius*0.8, angle=250, theta1=np.degrees(320), theta2=np.degrees(70), color='blue')\nax.add_patch(angle_C_arc)\nax.text(C[0]-1, C[1] - arc_radius*.8, f\"{70}°\", fontsize=12, color='blue')\n# ax.text(C[0] + arc_radius/2, B[1] + 1, f\"{70}°\", fontsize=12, color='blue')\nax.text(5, 10, \"AC = 30\", fontsize=12, color='black', horizontalalignment='center')\nax.text(30, 10, \"BC = 26\", fontsize=12, color='black', horizontalalignment='center')\n\n# 図の表示\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 1\n\n\n\nこのとき，点 \\(A\\) から \\(BC\\) に対して垂線を下ろし，その交点を \\(H\\) とします．このとき\n\\[\n\\begin{align}\nCH &= AC * \\cos(C)\\\\\nBH &= BC - AC * \\cos(C)\\\\\nAH& = AC * \\sin(C)\n\\end{align}\n\\]\nピタゴラスの定理より\n\\[\nAB^2 = AH^2 + BH^2\n\\]\nなので\n\\[\n\\begin{align}\nAB^2 &= (BC - AC * \\cos(C))^2 + (AC * \\sin(C))^2\\\\\n     &= BC^2 + AC^2 - 2\\cdot BC\\cdot AC \\cos(C)\n\\end{align}\n\\]\n従って，\n\n\nCode\nprint(f\"AB = {AB:.2f}\")\n\n\nAB = 32.29\n\n\n ▶  ベクトルを用いた直感的理解\nベクトルの内積は \\(\\vec a \\cdot \\vec b = \\lvert a \\rvert \\lvert b \\rvert \\cos \\theta\\) で定義されることを利用すると，\n\\[\n\\begin{aligned}\nAB^2\n    &= \\left\\lvert \\overrightarrow{CA} - \\overrightarrow{CB} \\right\\rvert^2 \\\\\n    &= (\\overrightarrow{CA} - \\overrightarrow{CB}) \\cdot (\\overrightarrow{CA} - \\overrightarrow{CB}) \\\\\n    &= \\left\\lvert \\overrightarrow{CA} \\right\\rvert^2 + \\left\\lvert \\overrightarrow{CB} \\right\\rvert^2\n    - 2 \\overrightarrow{CA} \\cdot \\overrightarrow{CB} \\\\\n    &= \\left\\lvert \\overrightarrow{CA} \\right\\rvert^2 + \\left\\lvert \\overrightarrow{CB} \\right\\rvert^2\n    - 2 \\left\\lvert \\overrightarrow{CA} \\right\\rvert \\left\\lvert \\overrightarrow{CB} \\right\\rvert \\cos(\\angle ACB) \\\\\n    &= AC^2 + BC^2  - 2\\cdot AC\\cdot BC \\cos(C)\n\\end{aligned}\n\\]\n\n\n\n\nExercise 2 \n四角形PABQ が以下のように与えられている\n\n\\(AB = 10\\)\n\\(\\angle PAB = {75}^\\circ\\)\n\\(\\angle PBA = {50}^\\circ\\)\n\\(\\angle PAQ = {40}^\\circ\\)\n\\(\\angle QAB = {35}^\\circ\\)\n\\(\\angle PBQ = {70}^\\circ\\)\n\nこのとき，PQの距離を求めよ．\n\nCode\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport matplotlib.patches as patches\n\n# 辺の長さと角度\nAB = 10\nangle_PAB = np.radians(75)\nangle_PBA = np.radians(50)\nangle_QAB = np.radians(35)\nangle_AQB = np.radians(25)\nangle_QBA = np.radians(120)\nangle_APB = np.radians(55)\n\n\n# 点Aの座標\nA = (0, 0)\n\n# 点Bの座標\nB = (AB, 0)\n\n# 点Pの座標\nPA = AB / np.sin(angle_APB) * np.sin(angle_PBA)\nP = ((np.cos(angle_PAB)) * PA, (np.sin(angle_PAB)) * PA)\n\n# 点Qの座標\nQA = AB / np.sin(angle_AQB) * np.sin(angle_QBA)\nQ = ((np.cos(angle_QAB)) * QA, (np.sin(angle_QAB)) * QA)\n\n\n# 座標をリストに変換\nfig, ax = plt.subplots(figsize=(6, 6))\n\nax.plot([A[0], P[0]], [A[1], P[1]], \"k\")  # Black line with circle markers\nax.plot([A[0], B[0]], [A[1], B[1]], \"ko-\")  # Black line with circle markers\nax.plot([B[0], P[0]], [B[1], P[1]], \"ko-\")  # Black line with circle markers\nax.plot([Q[0], A[0]], [Q[1], A[1]], \"ko-\")  # Black line with circle markers\nax.plot([Q[0], B[0]], [Q[1], B[1]], \"ko-\")  # Black line with circle markers\nax.plot([Q[0], P[0]], [Q[1], P[1]], \"ko-\")  # Black line with circle markers\n\n# 点のラベル\nplt.text(A[0] - 1, A[1], \"A\")\nplt.text(B[0] + 1, B[1], \"B\")\nplt.text(P[0], P[1] + 1, \"P\")\nplt.text(Q[0] + 1, Q[1], \"Q\")\n\n# 軸の範囲を設定\nplt.xlim(-2, 20)\nplt.ylim(-2, 20)\n\n# 軸のラベルを設定\nplt.xlabel(\"X\")\nplt.ylabel(\"Y\")\n\n# タイトルを設定\nplt.title(\"How far is the distance between P and Q\")\n\n# Add angles as arcs\narc_radius = 5  # Radius for the arcs\n\n# Angle at B\nax.text(A[0] + 1, A[1] + 1.8, f\"{40}°\", fontsize=10, color=\"blue\")\nax.text(A[0] + 1, A[1] + 0.2, f\"{35}°\", fontsize=10, color=\"blue\")\nax.text(B[0] - 2, B[1] + 0.2, f\"{50}°\", fontsize=10, color=\"blue\")\nax.text(B[0] - 0.5, B[1] + 1, f\"{70}°\", fontsize=10, color=\"blue\")\n# ax.text(C[0] + arc_radius/2, B[1] + 1, f\"{70}°\", fontsize=12, color='blue')\nax.text(5, -1, \"AB = 10\", fontsize=12, color=\"black\", horizontalalignment=\"center\")\nax.text(\n    (P[0] + Q[0]) / 2,\n    (P[1] + Q[1]) / 2 + 1,\n    \"PQ = ???\",\n    fontsize=12,\n    color=\"black\",\n    horizontalalignment=\"center\",\n)\n\n\n# 図の表示\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 2\n\n\n\n\n\n\n\n\n\n\n\n\nNoteSolution 1: 余弦定理を用いて解く\n\n\n\n\n\n\\(\\angle PAQ = {40}^\\circ\\) と問題分よりわかるので，\\(PA, QA\\) の長さがわかれば余弦定理より \\(PQ\\) が導出できます．\n正弦定理を用いて\n\\[\n\\begin{align}\nPA &= \\frac{AB}{\\sin({55}^\\circ)}\\times \\sin({50}^\\circ)\\\\\nQA &= \\frac{AB}{\\sin({25}^\\circ)}\\times \\sin({120}^\\circ)\n\\end{align}\n\\]\n余弦定理を用いると\n\\[\nPQ^2 = QA^2 + PA^2 - 2(PA)(QA)\\cos({40}^\\circ)\n\\]\nよって，\n\n\nCode\n# set variables\nAB = 10\nangle_APB = np.radians(55)\nangle_AQB = np.radians(25)\nangle_PBA = np.radians(50)\nangle_QBA = np.radians(120)\nangle_PAQ = np.radians(40)\n\n\n# compute PA and QA\nPA = AB / np.sin(angle_APB) * np.sin(angle_PBA)\nQA = AB / np.sin(angle_AQB) * np.sin(angle_QBA)\n\n\n# comnpute PQ using laws of cosines\nPQ = np.sqrt(PA ** 2 + QA **2 - 2 * PA * QA * np.cos(angle_PAQ))\n\nprint(f\"PQ = {PQ:.2f}\")\n\n\nPQ = 14.62\n\n\n\n\n\n\n\n\n\n\n\n\nNoteSolution 2: 座標を用いて解く\n\n\n\n\n\n各点を \\(XY\\) 平明座標に以下のように置き換えます\n\n\\(A\\) = (0, 0)\n\\(B\\) = (0, 10)\n\nこのとき，点 \\(P\\) の座標 \\((P_X, P_Y)\\) は\n\\[\n\\begin{align}\nP_X & = PA \\cdot \\cos({75}^\\circ)\\\\\nP_Y & = PA \\cdot \\sin({75}^\\circ)\n\\end{align}\n\\]\n同様に点 \\(Q\\) の座標 \\((Q_X, Q_Y)\\) は\n\\[\n\\begin{align}\nQ_X & = QA \\cdot \\cos({35}^\\circ)\\\\\nQ_Y & = QA \\cdot \\sin({35}^\\circ)\n\\end{align}\n\\]\nこのとき，長さ \\(PQ\\) は点 \\(P, Q\\) の距離と表せるので\n\\[\n\\begin{align}\nPQ &= \\lVert P - Q \\rVert\\\\\n   &= \\sqrt{(P_X - Q_X)^2 + (P_Y - Q_Y)^2}\\\\\n   &= \\sqrt{(AQ^2 + PA^2 - 2(PA)(QA)(\\cos({35}^\\circ)\\cos({75}^\\circ) + \\sin({35}^\\circ)\\sin({75}^\\circ)))}\n\\end{align}\n\\]\n加法定理より\n\\[\n\\cos (A \\pm B) = \\cos A \\cos B \\mp \\sin A \\sin B\n\\]\nなので\n\\[\n\\cos({35}^\\circ)\\cos({75}^\\circ) + \\sin({35}^\\circ)\\sin({75}^\\circ) = \\cos({40}^\\circ)\n\\]\n従って，\n\\[\nPQ^2 = QA^2 + PA^2 - 2(PA)(QA)\\cos({40}^\\circ)\n\\]"
  },
  {
    "objectID": "posts/2025-07-06-big-op-little-op/index.html",
    "href": "posts/2025-07-06-big-op-little-op/index.html",
    "title": "統計学におけるBig OpとLittle Op",
    "section": "",
    "text": "Definition 1 無限小\n独立変数のある一定の変動に伴って0に収束する変数を無限性という．\n\\[\n\\lim_{x\\to a}f(x) = 0\n\\]\nのとき，\\(f(x)\\) は \\(x\\to a\\) のとき無限小である．\n\n\nExample 1 無限小\n\\[\n\\begin{align}\n\\sin x & \\ \\ \\text{ as } \\ \\ x\\to 0\\\\\n\\sqrt{1-x^2} & \\ \\ \\text{ as } \\ \\ x\\to 1-0\\\\\n\\exp(-x) & \\ \\ \\text{ as } \\ \\ x\\to \\infty\\\\\n\\sqrt{(x-a)^2 + (y-b)^2} & \\ \\ \\text{ as } \\ \\ x\\to a, y\\to b\n\\end{align}\n\\]\n\n\n\n\nDefinition 2 高位・同位の無限小\n\\(\\lim_{x\\to a}f(x) = 0, \\lim_{x\\to a}g(x) = 0\\) とする\n高位の無限小\n\\[\n\\lim_{x\\to a} \\frac{f(x)}{g(x)} = 0\n\\]\nが成り立つとき，\\(f(x)\\) は \\(g(x)\\) より高位の無限小であるという．定義より \\(f(x)\\) は \\(g(x)\\) より速くゼロに近づくことになります．このとき次のように表します\n\\[\nf(x) =  \\omicron(g(x))\n\\]\n同位の無限小\n\\[\n\\lim_{x\\to a} \\frac{f(x)}{g(x)} = \\alpha(\\neq 0)\n\\]\nが成り立つとき，\\(f(x)\\) は \\(g(x)\\) と同位の無限小であるという．\nラージ・オーダー\n\\(|f(x)/g(x)|\\) が \\(a\\) を含むある開集合で有界のとき，次のように表す\n\\[\nf(x) = \\mathcal{O}(g(x))\n\\]\n\\(f(x) = \\omicron(g(x))\\) ならば \\(f(x) = \\mathcal{O}(g(x))\\) です．\n\n\nExample 2 ランダウの記号\n\\[\n\\begin{align}\n\\lim_{x\\to 0}\\frac{x^2}{x} = 0 &\\Longrightarrow x^2 = \\omicron(x) \\ \\ (x \\to 0)\\\\\n\\lim_{x\\to 0}\\frac{x^2 + x^3 + x^4}{x} = 0 &\\Longrightarrow x^2 + x^3 + x^4 = \\omicron(x) \\ \\ (x \\to 0)\\\\\n\\lim_{x\\to 0}\\frac{x + x^2}{x} = 1 &\\Longrightarrow x + x^2 = \\mathcal{O}(x) \\ \\ (x \\to 0)\\\\\n\\lim_{x\\to \\infty}\\frac{\\exp(-x)}{1/x} = 0 &\\Longrightarrow \\exp(-x) = \\omicron(1/x) \\ \\ (x \\to \\infty)\\\\\n\\lim_{x\\to \\infty}\\frac{\\exp(-x)}{1/x^k} = 0 &\\Longrightarrow \\exp(-x) = \\omicron(1/x^k) \\ \\ (x \\to \\infty)\\\\\n\\lim_{x\\to \\infty}\\frac{1 - \\exp(x)}{x} = 1 &\\Longrightarrow 1 - \\exp(x) = \\mathcal{O}(x) \\ \\ (x \\to 0)\n\\end{align}\n\\]\n\n\nExample 3 \\[\nf(x) = \\frac{\\exp(x) - (1 + x)}{x^2}\n\\]\nについて考えてみます．\\(x=0\\) のときは \\(f(x)\\) はそのまま評価できませんが，ロピタルの定理を用いると\n\\[\n\\lim_{x\\to 0}\\frac{\\exp(x) - (1 + x)}{x^2} = \\frac{1}{2}\n\\]\nつまり，\\(\\exp(x) - (1 + x) = \\mathcal{O}(x^2) \\ \\ (x\\to 0)\\) ということになります．Plotlyで確認したのが以下：\n\n\nCode\nimport numpy as np\nimport plotly.graph_objects as go\n\n# Define x values, avoiding x=0 to prevent division by zero\nx = np.linspace(-2, 2, 1000)\nx = x[x != 0]  # remove x=0\n\n# Define the function\ny = (np.exp(x) - (1 + x)) / x**2\n\n# Create the plot\nfig = go.Figure()\n\nfig.add_trace(\n    go.Scatter(\n        x=x, y=y, mode=\"lines\", name=\"(exp(x) - (1 + x)) / x²\", line=dict(color=\"blue\")\n    )\n)\n\n# Optionally add the limit as x -&gt; 0\nfig.add_trace(\n    go.Scatter(\n        x=[0],\n        y=[0.5],  # limit is 0.5\n        mode=\"markers\",\n        name=\"Limit at x=0\",\n        marker=dict(size=8, color=\"red\", symbol=\"circle\"),\n    )\n)\n\n# Customize layout\nfig.update_layout(\n    title=\"Plot of (exp(x) - (1 + x)) / x²\",\n    xaxis_title=\"x\",\n    yaxis_title=\"f(x)\",\n    template=\"plotly_white\",\n    showlegend=True,\n    width=800,\n    height=500,  # &lt;-- Set figure size here\n)\n\nfig.show()\n\n\n                            \n                                            \n\n\n\n\nTheorem 1 正弦関数とラージオーダー\n\\[\nn\\sin(n) = \\mathcal{O}(n) \\, \\ (n\\to\\infty)\n\\]\n\n\n\n\n\n\n\nNoteProof\n\n\n\n\n\n\\(\\sin(n) \\leq 1 \\, \\ \\forall n\\) より \\(n\\sin(n) \\leq n \\, \\ \\forall n\\)．\nつまり，\n\\[\n\\lim_{n\\to \\infty} \\left|\\frac{n\\sin(n)}{n}\\right| \\leq 1\n\\]\n従って，\\(n\\sin(n) = \\mathcal{O}(n) \\, \\ (n\\to\\infty)\\)\n\n\n\n\n\n\n\nDefinition 3  \n\n\\(N = 1, 2, 3, \\cdots\\) として，数列 \\(\\{a_N\\}\\) について \\(N^{-\\lambda}a_N\\) が有界のとき，\\(\\{a_N\\}\\) は \\(\\mathcal{O}(N^\\lambda)\\) であると表記する\n数列 \\(\\{a_N\\}\\) について \\(N^{-\\lambda}a_N \\to 0\\)のとき，\\(\\{a_N\\}\\) は \\(\\omicron(N^\\lambda)\\) であると表記する\n\n\n\n定義より \\(\\lim_{N\\to\\infty} a_N = 0\\) であるならば, \\(a_N = \\omicron(1)\\)\n\\(a_n = \\log(N)\\) であるならば，任意の \\(\\lambda  &gt; 0\\) について \\(a_N = \\omicron(N^\\lambda)\\)\n\\(a_n = 10 +\\sqrt{N}\\) であるならば，\\(a_N = \\mathcal{O}(N^{1/2})\\)\n\\(a_n = 10 +\\sqrt{N}\\) であるならば，任意の \\(\\lambda  &gt; 0\\) について \\(a_N = \\omicron(N^{1/2+\\lambda})\\)"
  },
  {
    "objectID": "posts/2025-07-06-big-op-little-op/index.html#無限小の比較",
    "href": "posts/2025-07-06-big-op-little-op/index.html#無限小の比較",
    "title": "統計学におけるBig OpとLittle Op",
    "section": "",
    "text": "Definition 1 無限小\n独立変数のある一定の変動に伴って0に収束する変数を無限性という．\n\\[\n\\lim_{x\\to a}f(x) = 0\n\\]\nのとき，\\(f(x)\\) は \\(x\\to a\\) のとき無限小である．\n\n\nExample 1 無限小\n\\[\n\\begin{align}\n\\sin x & \\ \\ \\text{ as } \\ \\ x\\to 0\\\\\n\\sqrt{1-x^2} & \\ \\ \\text{ as } \\ \\ x\\to 1-0\\\\\n\\exp(-x) & \\ \\ \\text{ as } \\ \\ x\\to \\infty\\\\\n\\sqrt{(x-a)^2 + (y-b)^2} & \\ \\ \\text{ as } \\ \\ x\\to a, y\\to b\n\\end{align}\n\\]\n\n\n\n\nDefinition 2 高位・同位の無限小\n\\(\\lim_{x\\to a}f(x) = 0, \\lim_{x\\to a}g(x) = 0\\) とする\n高位の無限小\n\\[\n\\lim_{x\\to a} \\frac{f(x)}{g(x)} = 0\n\\]\nが成り立つとき，\\(f(x)\\) は \\(g(x)\\) より高位の無限小であるという．定義より \\(f(x)\\) は \\(g(x)\\) より速くゼロに近づくことになります．このとき次のように表します\n\\[\nf(x) =  \\omicron(g(x))\n\\]\n同位の無限小\n\\[\n\\lim_{x\\to a} \\frac{f(x)}{g(x)} = \\alpha(\\neq 0)\n\\]\nが成り立つとき，\\(f(x)\\) は \\(g(x)\\) と同位の無限小であるという．\nラージ・オーダー\n\\(|f(x)/g(x)|\\) が \\(a\\) を含むある開集合で有界のとき，次のように表す\n\\[\nf(x) = \\mathcal{O}(g(x))\n\\]\n\\(f(x) = \\omicron(g(x))\\) ならば \\(f(x) = \\mathcal{O}(g(x))\\) です．\n\n\nExample 2 ランダウの記号\n\\[\n\\begin{align}\n\\lim_{x\\to 0}\\frac{x^2}{x} = 0 &\\Longrightarrow x^2 = \\omicron(x) \\ \\ (x \\to 0)\\\\\n\\lim_{x\\to 0}\\frac{x^2 + x^3 + x^4}{x} = 0 &\\Longrightarrow x^2 + x^3 + x^4 = \\omicron(x) \\ \\ (x \\to 0)\\\\\n\\lim_{x\\to 0}\\frac{x + x^2}{x} = 1 &\\Longrightarrow x + x^2 = \\mathcal{O}(x) \\ \\ (x \\to 0)\\\\\n\\lim_{x\\to \\infty}\\frac{\\exp(-x)}{1/x} = 0 &\\Longrightarrow \\exp(-x) = \\omicron(1/x) \\ \\ (x \\to \\infty)\\\\\n\\lim_{x\\to \\infty}\\frac{\\exp(-x)}{1/x^k} = 0 &\\Longrightarrow \\exp(-x) = \\omicron(1/x^k) \\ \\ (x \\to \\infty)\\\\\n\\lim_{x\\to \\infty}\\frac{1 - \\exp(x)}{x} = 1 &\\Longrightarrow 1 - \\exp(x) = \\mathcal{O}(x) \\ \\ (x \\to 0)\n\\end{align}\n\\]\n\n\nExample 3 \\[\nf(x) = \\frac{\\exp(x) - (1 + x)}{x^2}\n\\]\nについて考えてみます．\\(x=0\\) のときは \\(f(x)\\) はそのまま評価できませんが，ロピタルの定理を用いると\n\\[\n\\lim_{x\\to 0}\\frac{\\exp(x) - (1 + x)}{x^2} = \\frac{1}{2}\n\\]\nつまり，\\(\\exp(x) - (1 + x) = \\mathcal{O}(x^2) \\ \\ (x\\to 0)\\) ということになります．Plotlyで確認したのが以下：\n\n\nCode\nimport numpy as np\nimport plotly.graph_objects as go\n\n# Define x values, avoiding x=0 to prevent division by zero\nx = np.linspace(-2, 2, 1000)\nx = x[x != 0]  # remove x=0\n\n# Define the function\ny = (np.exp(x) - (1 + x)) / x**2\n\n# Create the plot\nfig = go.Figure()\n\nfig.add_trace(\n    go.Scatter(\n        x=x, y=y, mode=\"lines\", name=\"(exp(x) - (1 + x)) / x²\", line=dict(color=\"blue\")\n    )\n)\n\n# Optionally add the limit as x -&gt; 0\nfig.add_trace(\n    go.Scatter(\n        x=[0],\n        y=[0.5],  # limit is 0.5\n        mode=\"markers\",\n        name=\"Limit at x=0\",\n        marker=dict(size=8, color=\"red\", symbol=\"circle\"),\n    )\n)\n\n# Customize layout\nfig.update_layout(\n    title=\"Plot of (exp(x) - (1 + x)) / x²\",\n    xaxis_title=\"x\",\n    yaxis_title=\"f(x)\",\n    template=\"plotly_white\",\n    showlegend=True,\n    width=800,\n    height=500,  # &lt;-- Set figure size here\n)\n\nfig.show()\n\n\n                            \n                                            \n\n\n\n\nTheorem 1 正弦関数とラージオーダー\n\\[\nn\\sin(n) = \\mathcal{O}(n) \\, \\ (n\\to\\infty)\n\\]\n\n\n\n\n\n\n\nNoteProof\n\n\n\n\n\n\\(\\sin(n) \\leq 1 \\, \\ \\forall n\\) より \\(n\\sin(n) \\leq n \\, \\ \\forall n\\)．\nつまり，\n\\[\n\\lim_{n\\to \\infty} \\left|\\frac{n\\sin(n)}{n}\\right| \\leq 1\n\\]\n従って，\\(n\\sin(n) = \\mathcal{O}(n) \\, \\ (n\\to\\infty)\\)\n\n\n\n\n\n\n\nDefinition 3  \n\n\\(N = 1, 2, 3, \\cdots\\) として，数列 \\(\\{a_N\\}\\) について \\(N^{-\\lambda}a_N\\) が有界のとき，\\(\\{a_N\\}\\) は \\(\\mathcal{O}(N^\\lambda)\\) であると表記する\n数列 \\(\\{a_N\\}\\) について \\(N^{-\\lambda}a_N \\to 0\\)のとき，\\(\\{a_N\\}\\) は \\(\\omicron(N^\\lambda)\\) であると表記する\n\n\n\n定義より \\(\\lim_{N\\to\\infty} a_N = 0\\) であるならば, \\(a_N = \\omicron(1)\\)\n\\(a_n = \\log(N)\\) であるならば，任意の \\(\\lambda  &gt; 0\\) について \\(a_N = \\omicron(N^\\lambda)\\)\n\\(a_n = 10 +\\sqrt{N}\\) であるならば，\\(a_N = \\mathcal{O}(N^{1/2})\\)\n\\(a_n = 10 +\\sqrt{N}\\) であるならば，任意の \\(\\lambda  &gt; 0\\) について \\(a_N = \\omicron(N^{1/2+\\lambda})\\)"
  },
  {
    "objectID": "posts/2025-07-06-big-op-little-op/index.html#big-opとlittle-op",
    "href": "posts/2025-07-06-big-op-little-op/index.html#big-opとlittle-op",
    "title": "統計学におけるBig OpとLittle Op",
    "section": "Big OpとLittle Op",
    "text": "Big OpとLittle Op\nBig OpとLittle Opは，ある確率変数が（ある上限やゼロに）どのように収束するかの表記表現です．\n\nDefinition 4 probability limitとLittle Op\n確率変数列 \\(\\{x_N\\}\\) が定数 \\(a\\) に確率収束するとは, 任意の \\(\\epsilon &gt;0\\) に対して\n\\[\nP[|x_N - a|&gt;\\epsilon] \\to 0 \\  \\ \\text{as } \\  \\ N \\to \\infty\n\\]\nが成立することである．これを以下のように表記する\n\\[\n\\begin{align}\nx_N & \\overset{p}{\\to}a\\\\\n\\mathrm{plim}\\,\\ x_N &= a\n\\end{align}\n\\]\nとくに，\\(a = 0\\) のとき，\n\\[\nx_n = \\omicron_p(1)\n\\]\nと表記する．\n\n確率収束は次のようにリフレーズすることができます:\n\\[\n\\forall \\epsilon &gt;0, \\forall \\delta &gt;0 , \\exists n_0 \\in \\mathbb N [n\\geq n_0 \\Rightarrow P(|X_n - \\alpha| &gt; \\epsilon) &lt; \\delta]\n\\]\n\n\\(\\epsilon\\): accuracy level\n\\(\\delta\\): confidence level\n任意に与えられたaccuracyとconfidenceの水準に対して，\\(n\\) が十分大きければ \\(X_n\\) は指定した精度と信頼度の範囲内で \\(\\alpha\\) に等しくなる\n確率収束は \\(N\\) が十分大きければ \\(X_N\\) は \\(\\alpha\\) 近傍にほぼ確実に存在すると解釈できる\n\n\nExample 4 \n\\(X_1, \\cdots, X_n, \\cdots\\) を互いに独立な確率変数として，それらの確率関数を\n\\[\nX_n = \\left\\{\\begin{array}{c}\n0 & \\text{with probability} \\ \\ 1 - \\frac{1}{n}\\\\\nn & \\text{with probability} \\ \\ \\frac{1}{n}\n\\end{array}\\right.\n\\]\nとします．このとき，\n\\[\nP[|X_n| &gt; \\epsilon] = P[X_n &gt; \\epsilon] = \\frac{1}{n} \\to 0 \\  \\ (n\\to \\infty)\n\\]\nであるので，\\(X_n\\) は0に確率収束 \\(X_n = \\omicron_p(1)\\) することがわかります．\n\n\n確率収束と二乗収束\n確率変数 \\(X_n\\) が二乗収束するとします．つまり，\n\\[\n\\lim_{n\\to N}\\mathbb E[(X_n - X)^2] = 0\n\\]\n\\(X_n\\) が確率収束するならば，確率収束の定義とマルコフ不等式より\n\\[\n\\begin{align}\nP[|X_n - X| &gt; \\epsilon]\n  &= P[(X_n - X)^2 &gt; \\epsilon^2]\\\\\n  &\\leq \\frac{E[(X_n - X)^2]}{\\epsilon^2}\n\\end{align}\n\\]\n従って，\\(X_n\\overset{m.s.}{\\to} X \\Longrightarrow X_n\\overset{p}{\\to} X\\) が成立します． 一方，逆は成立しません．\nExample 4 は確率収束の例でしたが，\n\\[\n\\begin{align}\nE[(X_n)^2] = \\frac{1}{n}n^2 = n \\to\\infty \\text{ as } \\ \\ n\\to\\infty\n\\end{align}\n\\]\n\n\n\n\n\n\nNote統計学における収束の関係性\n\n\n\n\n\n\n\n\ngraph LR\n  A[Almost Sure Convergence] --&gt; B[Convergence in Probability]\n  B --&gt; C[Convergence in Distribution]\n  D[Lᵖ Convergence] --&gt; B\n\n\n\n\n\n\n\n\n\nDefinition 5 Big Op\n確率変数列 \\(\\{x_N\\}\\) が bounded in probability であるとは，任意の \\(\\epsilon &gt;0\\) について，\n\\[\n\\exists b_\\epsilon &gt; 0, N_\\epsilon \\Longrightarrow P(|x_N| \\geq b_\\epsilon) &lt; \\epsilon \\, \\ \\forall N\\geq N_{\\epsilon}\n\\]\nが成立することである．これを \\(x_N = \\mathcal{O}_p(1)\\) と表記する．\n\nスモールオーダーとラージオーダーとOp\n\\(C_N\\) を非確率変数数列とします．このとき，\n\\[\n\\begin{align}\nC_N = \\mathcal{O}_p(1) \\  \\ & \\text{if and only if} \\  \\ C_N = \\mathcal{O}(1)\\\\\nC_N = \\omicron_p(1) \\  \\ & \\text{if and only if} \\  \\ C_N = \\omicron(1)\n\\end{align}\n\\]\n\nTheorem 2 Probability limit and Big Op\n\\(x_N \\overset{p}{\\to} a\\) が成立するならば \\(x_N = \\mathcal{O}_p(1)\\)\n\n\n\n\n\n\n\nNoteProof\n\n\n\n\n\n\\(x_N \\overset{p}{\\to} a\\) より\n\\[\n\\forall \\epsilon, \\delta &gt; 0, \\exists N_\\epsilon, N \\geq N_\\epsilon\\Rightarrow P(|x_N - \\alpha| &gt; \\delta) &lt; \\epsilon\n\\]\n次に \\(|X_n|\\) について考えると\n\\[\n\\begin{align}\n&|X_n| = |X_n - \\alpha + \\alpha| \\leq |X_n - \\alpha| + |\\alpha| \\because{三角不等式}\\\\\n&\\Rightarrow |X_n| - |\\alpha| \\leq |X_n - \\alpha|\n\\end{align}\n\\]\n従って，\\(\\forall \\epsilon, \\delta &gt; 0, \\exists N_\\epsilon, N \\geq N_\\epsilon\\) について\n\\[\n\\begin{align}\n&P(|x_N - \\alpha| &gt; \\delta) &lt; \\epsilon\\\\\n&\\Rightarrow P(|X_n| - |\\alpha| &gt; \\delta) &lt; \\epsilon\\\\\n&\\Rightarrow P(|X_n| &gt; |\\alpha| + \\delta) &lt; \\epsilon\n\\end{align}\n\\]\n任意の \\(\\delta &gt; 0\\) について成立するので，\\(b_\\epsilon = |\\alpha| + 1\\) とすれば \\(X_n=\\mathcal{O}_p(1)\\) が成立する．\n\n\n\n\nDefinition 6 確率収束オーダー\n\n確率変数列 \\(X_N\\) と非確率変数列 \\(a_N &gt;0\\) について \\(X_N/a_N = \\omicron_p(1)\\) であるとき，\\(X_n = \\omicron_p(a_N)\\) であるという\n確率変数列 \\(X_N\\) と非確率変数列 \\(a_N &gt;0\\) について \\(X_N/a_N = \\mathcal{O}_p(1)\\) であるとき，\\(X_n = \\mathcal{O}_p(a_N)\\) であるという\n\n\nDefinition 6 より，確率変数列 \\(x_n = \\omicron_p(N^\\delta)\\), \\(\\delta \\in\\mathbb R\\) とき，\n\\[\n\\begin{align}\nN^{-\\delta}x_n \\overset{p}{\\to}0\n\\end{align}\n\\]\nとなります．\n\n\n\n\n\n\nNote\n\n\n\nTheorem 2 を用いると，\\(X_N = \\omicron_p(a_n)\\) が成立するならば \\(\\mathcal{O}_p(a_n)\\) が成立します．\n\n\n\nExample 5 \n\\(z\\) を確率変数としたとき，\\(x_N \\equiv \\sqrt{N}z\\) とていぎします．このとき，以下が成立します\n\\[\n\\begin{align}\nx_n &= \\mathcal{O}_p(N^{1/2})\\\\\nx_n &= \\omicron_p(N^{\\delta}) \\  \\ \\forall \\delta &gt; \\frac{1}{2}\n\\end{align}\n\\]\n\n\n\n\n\n\n\nNoteProperty\n\n\n\n\\[\n\\begin{align}\n\\omicron_p(1) + \\omicron_p(1) &= \\omicron_p(1) \\because{\\text{Continuous Mapping Theorem}}\\\\\n\\mathcal{O}_p(1) + \\omicron_p(1) &= \\mathcal{O}_p(1)\\\\\n\\mathcal{O}_p(1)\\omicron_p(1) &=\\omicron_p(1)\\\\\nR_n\\times\\omicron_p(1) &= \\omicron_p(R_n)\n\\end{align}\n\\]\n\n\n\nExample 6 sum of \\(\\omicron_p(1)\\) not necessarily equals \\(\\omicron_p(1)\\)\n\\(X_{ni} = \\frac{1}{n}\\) という確率変数を考えます．\n定義より\n\\[\n\\operatorname{plim} X_{ni} = 0\n\\]\nつまり，\\(X_{ni} = \\omicron_p(1)\\) です．ここで\n\\[\nY_n = \\frac{1}{n}\\sum_{i=1}^nX_{ni}\n\\]\nを考えます．このとき，\n\\[\n\\begin{align}\nY_n\n  &= \\frac{1}{n}\\sum_{i=1}^nX_{ni}\\\\\n  &= \\frac{n(n+1)}{2n^{2}}\\\\\n  &\\to \\frac{1}{2}\n\\end{align}\n\\]\n従って，\\(Y_n \\neq \\omicron_p(1)\\) となります．\n\n\n上記の Example 6 の関連として \\(n\\) 応じて大きくなる \\(M(N)\\) 個(例として \\(M(N) = \\frac{N}{2}\\))の \\(X_{ni}\\) の合計でも考えることができます．\\(X_{ni} = 1\\) を考えると， \\(X_{ni} = \\mathcal{O}_p(1)\\) は自明ですが\n\\[\n\\sum_{i=1}^{M(N)}X_{ni} = \\sum_{i=1}^{M(N)}1 = M(N)\\to \\infty\n\\]\nまた，\\(X_{ni} = 1/n\\) を考えると，\\(X_{ni} = \\omicron_p(1)\\) は自明ですが\n\\[\n\\sum_{i=1}^{M(N)}X_{ni} = \\sum_{i=1}^{M(N)}\\frac{1}{N} = \\frac{M(N)}{N}\n\\]\nとなり，\\(M(N) = \\frac{N}{2}\\) であるならば \\(\\frac{1}{2}\\) に収束してしまい，\\(\\sum_{i=1}^{M(N)}X_{ni}\\neq \\omicron_p(1)\\) となってしまいます．\n\n収束レート\n\n\n\n\n\n\n\n\n\n表記\nゼロへの収束速度\n説明\n\n\n\n\n\\(\\mathcal{O}_p(1)\\)\n遅い\n確率的に有界だが、ゼロに収束とは限らない\n\n\n\\(\\mathcal{O}_p(1/\\log(n))\\)\nちょっと速い\nゼロに \\(\\log(n)\\) の速さで近づく\n\n\n\\(\\mathcal{O}_p(1/\\sqrt(n))\\)\nもうちょっと速い\nゼロに \\(\\sqrt(n)\\) の速さで近づく\n\n\n\\(\\mathcal{O}_p(1/n)\\)\n速い\nゼロに \\(n\\) の速さで近づく\n\n\n\\(\\mathcal{O}_p(1/n^2)\\)\nもっと速い\n\\(n^2\\) の速さでゼロに近づく\n\n\n\n\n２つのレートを考えます\n\\[\n\\begin{align}\nR^{(1)} &= \\frac{1}{n^{1/2}}\\\\\nR^{(2)} &= \\frac{1}{n^{1/3}}\n\\end{align}\n\\]\nそして，ある確率変数 \\(Y_n = \\omicron_p(1)\\) とします．ここで，次のように変数を定義します\n\\[\n\\begin{align}\nX_n^{(1)} &= \\frac{1}{n^{1/2}}Y_n = \\omicron_p(R^{(1)})\\\\\nX_n^{(2)} &= \\frac{1}{n^{1/3}}Y_n = \\omicron_p(R^{(2)})\n\\end{align}\n\\]\nこのとき，\\(n\\to\\infty\\) における各 \\(Y_n\\) の値を所与とすると，\\(X_n^{(2)}\\) の方が \\(X_n^{(1)}\\) よりも大きくなります． つまり，\\(X_n^{(1)}\\) の方が確率的にゼロへ速く収束します．\n\n\n\n\n\n\nNote次元の呪い\n\n\n\n\\(d\\) 次元確率ベクトル \\(\\pmb{X}_i\\) の密度関数 \\(f(\\pmb{x})\\) を多変量カーネル推定量を用いて推定する場合を考えます．\n\\[\n\\hat{f}(\\pmb{x}) \\frac{1}{|\\pmb{H}|}\\sum_{i=1}^nK(\\pmb{H}^{-1}(\\pmb{X}_i - \\pmb{x}))\n\\]\n多変量カーネルのAMISE(Asymptotic Mean Integrated Squared Error)は\n\\[\n\\operatorname{AMISE}(\\hat{f}(\\pmb{x})) = \\omicron_p(n^{-4/(d+4)})\n\\]\nとなりますが，\n\n\\(d=1\\) のときは \\(n^{-4/5}\\) の速さで0に収束\n\\(d=2\\) のときは \\(n^{-2/3}\\) の速さで0に収束\n\\(d=3\\) のときは \\(n^{-4/7}\\) の速さで0に収束\n\nと \\(d\\) が大きくなるについて遅くなります．これを次元の呪い(curse of dimensionality)と呼びます．\n\n\n\nExample 7 \n\\(X_n \\sim N(0, n)\\) という確率変数を考えます．変数変換を行うと\n\\[\n\\frac{X_n}{\\sqrt{n}}\\sim N(0, 1)\n\\]\n標準正規分布の性質より \\(Z\\sim N(0, 1)\\) のとき，任意の \\(\\epsilon &gt; 0\\) について \\(P(|Z| &gt; M) &lt; \\epsilon\\) を満たすような \\(M\\) が存在するので\n\\[\nX_n = \\mathcal{O}_p(\\sqrt{n})\n\\]\n上記より \\(X_n\\) はBig OpとLittle Opの関係より \\(X_n = \\omicron_p(n)\\) であることはわかりますが，ちゃんと確認してみたいと思います．\n\\[\n\\begin{align}\n\\frac{X_n}{n}\\sim N\\left(0, \\frac{1}{n}\\right)\n\\end{align}\n\\]\n\\(\\alpha \\sim N\\left(0, \\frac{1}{n}\\right)\\) とすると，\n\\[\n\\begin{align}\nP(|\\alpha| &gt; \\epsilon)\n  &= P(\\frac{1}{\\sqrt{n}}|Z| &gt; \\epsilon)\\\\\n  &=  P(|Z| &gt; \\sqrt{n}\\epsilon)\\\\\n  &\\overset{p}{\\to}0\n\\end{align}\n\\]\n従って，\\(X_n = \\omicron_p(n)\\) が示せました．\n\n\n\nrate of convergence: mean vs median\n正規分布に従う確率変数 \\(X_i \\sim N(\\theta, \\sigma^2)\\) について考えます．\n\n\\(\\overline{X}_N\\): sample mean\n\\(\\hat M_N\\): sample median, \\(\\hat M_N = \\operatorname{Med}(X_1, \\cdots, X_N)\\)\n\nとすると，それぞれの漸近分布は\n\\[\n\\begin{align}\n\\overline{X}_N &\\sim N\\left(\\theta, \\frac{\\sigma^2}{N}\\right)\\\\\n\\hat M_N &\\sim N\\left(\\theta, \\frac{\\pi\\sigma^2}{2N}\\right)\n\\end{align}\n\\]\n収束スピードイメージの確認\n\nsample meanのほうがsample medianと比べてより効率的と一見見える（分散が小さい）\n\\(\\theta\\) を中心に分布している = unbiased\n\\(n\\) が大きくなるにつれて，\\(x = \\theta\\) のprobability densityが大きくなっている = consistency\n\n\n\nCode\nimport numpy as np\nimport pandas as pd\nimport plotly.express as px\n\n\n# サンプル平均・中央値を1000回計算\ndef rep_sample(N, reps=1000):\n    data = {\"N\": [], \"Estimator\": [], \"estimate\": []}\n    for _ in range(reps):\n        sample = np.random.normal(loc=0, scale=1, size=N)\n        data[\"N\"].append(N)\n        data[\"Estimator\"].append(\"Mean\")\n        data[\"estimate\"].append(np.mean(sample))\n        data[\"N\"].append(N)\n        data[\"Estimator\"].append(\"Median\")\n        data[\"estimate\"].append(np.median(sample))\n    return pd.DataFrame(data)\n\n\n# サンプルサイズのリスト\nnp.random.seed(89)\nNs = [5] + list(range(50, 251, 50))\ndf_all = pd.concat([rep_sample(N) for N in Ns], ignore_index=True)\n\n# Plotlyでヒストグラム描画（facet by N）\nfig = px.histogram(\n    df_all,\n    x=\"estimate\",\n    color=\"Estimator\",\n    facet_col=\"N\",\n    facet_col_wrap=2,\n    histnorm=\"probability density\",  # Rと同様の密度\n    opacity=0.6,\n    nbins=50,\n    labels={\"estimate\": \"Value\", \"N\": \"Sample Size\"},\n)\n\n# オーバーレイ + サイズ変更\nfig.update_layout(\n    barmode=\"overlay\",  # オーバーレイ表示\n    bargap=0.1,\n    width=1000,  # ← 横幅（px）\n    height=800,  # ← 高さ（px）\n    legend=dict(orientation=\"h\", y=-0.1),\n    title=dict(\n        text=\"Sampling Distributions of Mean vs Median by Sample Size (Overlayed)\",\n        y=0.95,  # ← タイトルをより上に配置\n        x=0.5,  # 中央に配置（オプション）\n        xanchor=\"center\",\n        yanchor=\"bottom\",\n    ),\n)\n\nfig.update_layout(\n    margin=dict(t=100),  # 上側余白を増やす\n    title_font_size=20\n)\n\n# ラベルの整形（例: \"N=50\" → \"N = 50\"）\nfig.for_each_annotation(lambda a: a.update(text=a.text.replace(\"N=\", \"N = \")))\n\nfig.show()\n\n\n                            \n                                            \n\n\nOp表記を用いた収束レートの確認\nOp表記を用いてsample meanとsample medianの収束レートを確認してみます．まず，以下のような変換を実施します\n\\[\n\\begin{aligned}\n\\psi_\\text{Mean} &= \\hat{\\theta} - \\theta \\\\\n&= \\mathcal{N}(\\theta, \\frac{\\sigma^2}{N}) - \\mathcal{N}(\\theta,0) \\\\\n&= \\mathcal{N}(0,\\frac{\\sigma^2}{N})\\\\\n&= \\frac{1}{\\sqrt{N}}\\mathcal{N}(0,\\sigma^2)\n\\end{aligned}\n\\]\n\\[\n\\begin{aligned}\n\\psi_\\text{Med.} &= \\mathcal{N}(\\theta, \\frac{\\pi\\sigma^2}{2N}) - \\mathcal{N}(\\theta,0)  \\\\\n& = \\mathcal{N}(0, \\frac{\\pi\\sigma^2}{2N})\\\\\n&= \\frac{\\sqrt{\\pi}}{\\sqrt{2N}}\\mathcal{N}(0,\\sigma^2)\n\\end{aligned}\n\\]\n従って，\n\\[\n\\begin{align}\n\\psi_\\text{Mean} = \\mathcal{O}_p\\left(\\frac{1}{\\sqrt{N}}\\right).\\\\\n\\psi_\\text{Med.} = \\mathcal{O}_p\\left(\\frac{\\pi}{\\sqrt{2N}}\\right).\n\\end{align}\n\\]\n\\(\\frac{1}{\\sqrt{N}} &lt; \\frac{\\pi}{\\sqrt{2N}}\\) であるので，sample medianのほうが収束レートが遅いことがわかります．\n\n\nCode\nimport numpy as np\nimport pandas as pd\nimport plotly.express as px\n\n# Nの範囲を定義（0.01 から 100、ステップ 0.01）\nN = np.arange(0.01, 100.01, 0.01)\n\n# 平均と中央値の収束速度\nmean_convergence = 1 / np.sqrt(N)\nmedian_convergence = np.sqrt(np.pi) / np.sqrt(2 * N)\n\n# データフレームに変換して tidy 形式に変換\ndf = pd.DataFrame({\n    \"N\": N,\n    \"Mean\": mean_convergence,\n    \"Median\": median_convergence\n})\ndf_melted = df.melt(id_vars=\"N\", var_name=\"Estimator\", value_name=\"Rate\")\n\n# Plotly で線グラフ描画\nfig = px.line(df_melted, x=\"N\", y=\"Rate\", color=\"Estimator\",\n              title=\"Asymptotic Convergence Rate: Mean vs Median\",\n              labels={\"Rate\": \"Convergence Rate\", \"N\": \"Sample Size\"})\n\nfig.update_layout(\n    yaxis=dict(range=[0, 1]),\n    legend=dict(orientation=\"h\", y=-0.2)\n)\n\nfig.show()"
  },
  {
    "objectID": "posts/2025-07-06-big-op-little-op/index.html#appendix-連続確率分布における中央値の漸近分布",
    "href": "posts/2025-07-06-big-op-little-op/index.html#appendix-連続確率分布における中央値の漸近分布",
    "title": "統計学におけるBig OpとLittle Op",
    "section": "Appendix: 連続確率分布における中央値の漸近分布",
    "text": "Appendix: 連続確率分布における中央値の漸近分布\n連続確率分布に従う \\(\\{X_1, \\cdots, X_n\\} \\overset{\\mathrm{iid}}{\\sim} F\\) を考えます．\n\nCDF: \\(F_X(x) = P(X_i \\leq x)\\)\ninverse CDF: \\(F^{-1}_X(t)\\)\npdf: \\(f_X(x) = F^\\prime_X(x)\\)\nBernoulli r.v.: \\(Z_i(x) \\equiv I\\{X_i \\leq x\\}\\)\n\n\\(Z_i\\) についてはBernoulli r.v. であるので\n\\[\n\\begin{gather}\n\\mathbb E(Z_i(x)) =  \\mathbb E\\left(I\\{X_i\\le x\\}\\right) = P(X_i\\le x)=F_X(x)\\\\\n\\operatorname{Var}(Z_i(x)) = F_X(x)[1-F_X(x)]\n\\end{gather}\n\\]\n次に \\(Z_i((x))\\) のsample meanの変数として \\(Y_n(x)\\) を以下のように定義します\n\\[\nY_n(x) = \\frac{1}{n}\\sum_{i=1}^nZ_i(x) = \\hat F_n(x)\n\\]\n\n\\(\\hat F_n(x)\\): 経験分布関数\n\nこのとき，\n\\[\n\\begin{align}\n\\mathbb E[Y_n(x)] &= F_X(x)\\\\\n\\operatorname{Var}(Y_n(x)) &= \\frac{1}{n}F_X(x)[1-F_X(x)]\n\\end{align}\n\\]\nここで，CLTを用いると\n\\[\n\\begin{align}\n\\sqrt n\\Big(Y_n(x) - F_X(x)\\Big)\n  &= \\sqrt n\\Big(\\hat F_X(x) - F_X(x)\\Big)\\\\\n  &\\overset{d}{\\rightarrow} N\\left(0,F_X(x)[1-F_X(x)]\\right)\n\\end{align}\n\\]\n\\(F^{-1}_X(\\cdot)\\) という変数変換とDelta methodを組み合わせると\n\\[\n\\sqrt n\\Big(F^{-1}_X(\\hat F_n(x)) - F^{-1}_X(F_X(x))\\Big) \\overset{d}{\\rightarrow} N\\left(0,\\frac {F_X(x)[1-F_X(x)]}{\\left[f_x\\left(F^{-1}_X(F_X(x))\\right)\\right]^2} \\right)\n\\]\ntrue median \\(x = m\\) で評価すると\n\\[\n\\sqrt n\\Big(F^{-1}_X(\\hat F_n(m)) - m\\Big) \\overset{d}{\\rightarrow} N\\left(0,\\frac {1}{\\left[2f_x(m)\\right]^2} \\right)\n\\]\n\\(F^{-1}_X(\\hat F_n(m))\\) は sample median \\(\\hat m\\) に収束するので\n\\[\n\\sqrt n\\Big(\\hat m - m\\Big)\\overset{d}{\\rightarrow} N\\left(0,\\frac {1}{\\left[2f_x(m)\\right]^2} \\right)\n\\]\n正規分布 \\(X_i\\sim N(0, \\sigma^2)\\) の場合を考えると\n\\[\n\\sqrt n\\Big(\\hat m - m\\Big)\\overset{d}{\\rightarrow} N\\left(0,\\frac {\\pi\\sigma^2}{2} \\right)\n\\]"
  },
  {
    "objectID": "posts/2025-07-06-big-op-little-op/index.html#references",
    "href": "posts/2025-07-06-big-op-little-op/index.html#references",
    "title": "統計学におけるBig OpとLittle Op",
    "section": "References",
    "text": "References\n\nEconometric Analysis of Cross Section and Panel Data, 2010 &gt; Ch3. Basic Asymptotitc Theory p37\nIntroduction to Probability, Dimitri P. Bertsekas and John N. Tsitsiklis\nMa, Y., Genton, M. G., & Parzen, E. (2011). Asymptotic properties of sample quantiles of discrete distributions. Annals of the Institute of Statistical Mathematics, 63(2), 227-243.\nStatistics for Regression Monkeys &gt; マルコフ不等式"
  },
  {
    "objectID": "posts/2025-11-27-paperless-ngx/index.html",
    "href": "posts/2025-11-27-paperless-ngx/index.html",
    "title": "paperless-ngxによるセルフホスティングドキュメント管理システム",
    "section": "",
    "text": "Caution想定環境\n\n\n\n\n実行環境は基本的に Ubuntu 24.04 LTSを想定\nDocker engineは利用可能\nport 8888 でホスト\nTailscaleは導入済み\ntailnet serveはhttpsを用いてserve"
  },
  {
    "objectID": "posts/2025-11-27-paperless-ngx/index.html#paperless-ngxとは",
    "href": "posts/2025-11-27-paperless-ngx/index.html#paperless-ngxとは",
    "title": "paperless-ngxによるセルフホスティングドキュメント管理システム",
    "section": "Paperless-ngxとは？",
    "text": "Paperless-ngxとは？\n\n\n\n\n\n\nNoteTL;DRs\n\n\n\n\nPaperless-ngxは，PDF 論文やレポートを自前サーバで全文検索付きライブラリ化するためのツール\n「引用管理」「文献リスト生成」などの機能も欲しいなら，文献管理専用ソフトを使うのが無難\n\n\n\n\nDefinition 1 Paperless-ngx\n\npdf, txtなどのドキュメントを検索可能なオンラインアーカイブとして管理できるオープンソースのセルフホスティング文書管理システム\nサーバーサイドでPaperless-ngxを構築し，クライアント端末からアクセスしたり，コンテンツをダウンロードすることが可能\nバックエンドはDjango\n\n\nFeatures\n\nタグ・差出人(Correspondence)・文書タイプ・カスタムフィールドでドキュメントを整理可能\nアップロードしたドキュメントに対してOCRを用いた全文検索が可能\n機械学習でタグ・差出人・文書タイプを 自動分類\nPDF，画像，テキスト，Word/Excel/PowerPoint，LibreOffice など多くの形式に対応\nWeb UI を通じて，複数ユーザーでのアクセス管理，共有リンク発行が可能\n文書ごとに権限管理設定可能\nワークフロー機能による自動処理\n\n\n\n\n\n\n\nCaution文書管理システムであって文献管理ソフトではない\n\n\n\n\nZoteroと違い学術論文データベースではないです\n文献の著者情報，出版年，ジャーナル名，引用数，参照関係，BibTex形式でのメタ情報出力は標準では備わっていない\nPaperless-ngxはファイルを独自フォルダ構成で管理するため，「元のファイルツリー構造をそのまま索引化だけしたい」という用途には向かない"
  },
  {
    "objectID": "posts/2025-11-27-paperless-ngx/index.html#paperless-ngxの設定",
    "href": "posts/2025-11-27-paperless-ngx/index.html#paperless-ngxの設定",
    "title": "paperless-ngxによるセルフホスティングドキュメント管理システム",
    "section": "Paperless-ngxの設定",
    "text": "Paperless-ngxの設定\nPaperless-ngxは Dockerベースで構築することが可能です．構築にあたって\n\nシェルスクリプトを用いて，対話式でセットアップする\n自分で docker-compose.yml を定義し，公式Paperless-ngx Docker imageを運用する\n\n\nパターン１: シェルスクリプトを用いて，対話式でセットアップする\nbash -c \"$(curl --location --silent --show-error https://raw.githubusercontent.com/paperless-ngx/paperless-ngx/main/install-paperless-ngx.sh)\"\nを実行することで対話式でセットアップできます．また，Paperless-ngxの中で用いるrootアカウントの設定まで行ってくれます．\n\n\nパターン２：自分で docker-compose.yml を定義\n作業手順として\n\n利用可能UID, GIDの確認\nGIDの作成\nUIDの作成\nDocker設定用のdirectoryを作成(= volumn, 設定ファイルの管理用ディレクトリ)\ndocker-compose.env の作成\ndocker-compose.yml の作成\nコンテナを起動\n\nです．\nStep 1: paperless-ngx用UIDの作成\nUbuntuサーバー側でPaperless-ngxをホスティングするので，まずPaperless-ngx用non-humanアカウントを作成します． UIDとGIDは同じIDで基本的には作成されますが，連番の関係が崩れると違ったIDが割り当てられてしまう可能性があるので，利用可能なIDを確認します．\n\n\n\n\n\n\n\n\nコマンド\n挙動\n\n\n\n\ngetent passwd\nUID一覧の確認コマンド\n\n\ngetent group\nGID一覧の確認コマンド\n\n\n\n\n上記のコマンドを叩いて目星をつけたならば(例として120が空いていたとする)\ngetent passwd 120\ngetent group 120\n両方のコマンドを叩いて何も返ってこないことを確認します．\nStep 2: GIDの作成\nGIDの作成は groupadd コマンドを以下のように用います\nsudo groupadd --gid 120 paperless-ngx\nGID作成後，意図した通りにGIDが作成されているか確認します\n$ getent group 120\npaperless-ngx:x:120:\nもし間違ったGIDで作成してしまった場合は\nsudo groupdel &lt;group-name&gt;\nStep 3: UIDの作成\npaperless-ngx ユーザーを作成します． 不特定多数が利用するサーバーでホスティングするので特定のhumanユーザーではなく， サービス専用のシステム用アカウント(ログイン不可のユーザー)として運用したいのが理由となります．\nユーザー作成コマンドは以下です\nsudo useradd \\\n  --system \\\n  --no-create-home \\\n  --uid 120 \\\n  --gid 120 \\\n  paperless-ngx\n\n\n\n\n\n\n\n\nオプション\n意味\n\n\n\n\nuseradd\n新しいユーザーを作成するコマンド\n\n\n--system\nシステム専用ユーザーとして作成（ログイン不可，通常 UID 100 未満を使う場合もある）\n\n\n--no-create-home\nホームディレクトリを作らない\n\n\n--uid 120\n作成するユーザーの UID を 120 に指定\n\n\n--gid 120\n作成するユーザーの プライマリグループ を GID 120 に指定\n\n\n\n\n上記のコマンド実行後，home directoryを持たない paperless-ngx が作成されますが\n$ getent passwd 120\npaperless-ngx:x:120:120::/home/paperless-ngx:/bin/sh\nとなってると思います．ログインシェルと存在しないhome directoryが指定されているのは気持ち悪いので\n\n/nonexisent ディレクトリをhome directoryとする\n/usr/sbin/nologin でログイン不可\n\nという設定更新をします．\nsudo usermod -d /nonexistent paperless-ngx\nsudo usermod -s /usr/sbin/nologin paperless-ngx\n上記のコマンド実行後は\n$ getent passwd 120\npaperless-ngx:x:120:120::/nonexistent:/usr/sbin/nologin\nとなっているはずです．\nStep 4: Docker設定用のdirectoryを作成\npaperless-ngxサービス用のディレクトリを /srv 以下に以下のように作成します\nsudo mkdir -p /srv/paperless-ngx\n作成後，所有権を以下のように変更しときます\nsudo chown -R paperless-ngx:paperless-ngx /srv/paperless-ngx\nまた，サーバーサイドでの設定なのでパーミッションも以下のように変更しときます\nsudo chmod 770 /srv/paperless-ngx\n\n\n\n\n\n\nNote/srv/paperless-ngx に構築する理由\n\n\n\nPaperless-ngx が管理するファイル・設定・ボリューム用ディレクトリを一目でわかる場所で管理するのが望ましいですが，どこで管理するのかが問題となります． Ubuntuでは用途ごとに次のようなディレクトリが一般的に用いられます：\n\n\n\n\n\n\n\n\n\nディレクトリ\n用途\nコメント\n\n\n\n\n/srv\nサービス専用データ\n標準的でわかりやすい\n\n\n/opt\nサードパーティソフトのインストール先\nバイナリやパッケージ向けでデータ管理向きではない\n\n\n/var/lib\n可変データ（ログ，DB，キャッシュ）\n物理的に動的なデータ向け，サービスデータ全般にも可\n\n\n\n\nPaperless-ngx のデータをどこに置くかは最終的に任意ですが，サービス専用ユーザーに所有権を割り当てやすく，管理もしやすいという点から， /srv 配下にディレクトリを作成する方針にしました．\n\n\nその後，Paperless-ngx用のexportとupload用ボリュームとして export, consume ディレクトリが必要となるのでそれぞれを作成します．\nStep 5: docker-compose.env の作成\nDockerコンテナ用の環境変数を定義する docker-compose.env を /srv/paperless-ngx 以下に作成します\nUSERMAP_UID=120\nUSERMAP_GID=120\nPAPERLESS_TIME_ZONE=Asia/Tokyo\nPAPERLESS_OCR_LANGUAGE=eng\nPAPERLESS_SECRET_KEY='&lt;適当な文字列&gt;'\nPAPERLESS_OCR_OUTPUT_TYPE=pdf\n\n\n\n\n\n\n\n\n変数名\n説明\n備考（今回の重要ポイントを踏まえた補足）\n\n\n\n\nUSERMAP_UID=120\nPaperless コンテナ内部で使用するユーザーID（UID）をホスト側 UID に合わせるための設定\nホスト側のユーザー権限と揃えることで，生成ファイルの所有権が一致し，権限問題が発生しにくくなる\n\n\nUSERMAP_GID=120\nPaperless コンテナ内部で使用するグループID（GID）をホスト側 GID に合わせる設定\nUID と同様，ホスト側のグループ権限と一致させることで，ファイルアクセスの整合性が取れる．\n\n\nPAPERLESS_TIME_ZONE=Asia/Tokyo\nPaperless 内部で使用するタイムゾーンを指定．\nログ，OCR のタイムスタンプ，タスクの実行時間管理に使用されるため，日本で利用するなら Asia/Tokyo が最適\n\n\nPAPERLESS_OCR_LANGUAGE=eng\nOCR に使用する言語を指定する．複数指定も可能（例: eng+jpn）．\n日本語を扱う場合は jpn の追加を推奨．英語のみなら eng のままでOK．\n\n\nPAPERLESS_SECRET_KEY='&lt;適当な文字列&gt;'\nセッションを保護する秘密鍵（ユーザー認証に不可欠）．ランダムで長い文字列に必ず変更する必要がある．\nPaperless がインターネットに公開される場合，デフォルトの SECRET_KEY は広く知られているため危険．キーボードを適当に叩いた文字列でOK．覚える必要はない．長いほど安全．例: a9$FJ!p92jaf(3)sa0fjasdf02398\n\n\nPAPERLESS_OCR_OUTPUT_TYPE=&lt;type&gt;\nOCR 後に生成する PDF の種類を指定\n- pdf : 元の PDF を極力変更せずに OCR を追加- pdfa : PDF/A-2b に変換（長期保存向け）- pdfa-1, pdfa-2, pdfa-3 : PDF/A のバージョン指定※ 指定しない場合は pdfa がデフォルト\n\n\n\n\n\n\n\n\n\nNotePAPERLESS_OCR_LANGUAGE設定の注意点\n\n\n\nPaperless-ngxはOCR機能としてTesseractを利用しますが，デフォルトでインストールされていない言語を指定すると，\nThe selected ocr language jpn is not installed. Paperless cannot OCR your documents without it. Please fix PAPERLESS_OCR_LANGUAGE.\nというエラーを吐きます．日本語対応を含めるため eng+jpn を設定する場合は Dockerfile を設定して\nRUN apt-get update \\\n    && apt-get install -y tesseract-ocr-jpn \\\n    && rm -rf /var/lib/apt/lists/*\nというラインを加えた上でビルドの必要があります．\n\n\nStep 6: docker-compose.yml の作成\n/srv/paperless-ngx にて docker-compose.yml を以下のように作成します\nservices:\n  broker:\n    image: docker.io/library/redis:8\n    restart: unless-stopped\n    volumes:\n      - paperless-redisdata:/data\n  \n  db:\n    image: docker.io/library/postgres:18\n    restart: unless-stopped\n    volumes:\n      - paperless-pgdata:/var/lib/postgresql\n    environment:\n      POSTGRES_DB: paperless\n      POSTGRES_USER: paperless\n      POSTGRES_PASSWORD: paperless\n  \n  webserver:\n    image: ghcr.io/paperless-ngx/paperless-ngx:latest\n    restart: unless-stopped\n    depends_on:\n      - db\n      - broker\n    ports:\n      - \"8888:8000\"\n    volumes:\n      - paperless-data:/usr/src/paperless/data\n      - paperless-media:/usr/src/paperless/media\n      - ./export:/usr/src/paperless/export\n      - ./consume:/usr/src/paperless/consume\n    env_file: docker-compose.env\n    environment:\n      PAPERLESS_REDIS: redis://broker:6379\n      PAPERLESS_DBHOST: db\n\nvolumes:\n  paperless-data:\n  paperless-media:\n  paperless-pgdata:\n  paperless-redisdata:\nStep 7: コンテナを起動\nコンテナは以下の手順で起動します\nsudo docker compose up -d\nsudo docker compose ps\nエラーが発生した場合は\nsudo docker compose logs -f webserver\nでログを確認できます．\n\n\n\n\n\n\nNoteuploadしたドキュメントのバックアップを取る\n\n\n\nPaperless-ngx コンテナ内の export ディレクトリにあるドキュメントをバックアップする場合\ndocker exec -it $(docker ps -aqf \"name=paperless-ngx-webserver-1\") document_exporter ../export\n\n../export はコンテナ内の相対パス\nホスト側ボリューム /srv/paperless-ngx/export にマウントしていれば，ホスト側からも直接アクセス可能"
  },
  {
    "objectID": "posts/2025-11-27-paperless-ngx/index.html#tailnet-serve設定",
    "href": "posts/2025-11-27-paperless-ngx/index.html#tailnet-serve設定",
    "title": "paperless-ngxによるセルフホスティングドキュメント管理システム",
    "section": "Tailnet serve設定",
    "text": "Tailnet serve設定\n設定手順は\n\ndocker-compose.env の設定とコンテナの再起動\ntailnet serve設定\n\nとなります\nStep 1: docker-compose.env の設定\nTailscale 経由で Paperless-ngx にアクセスする場合，Djangoにホスト名とプロトコル（HTTPS）を正しく伝えることが重要です． 設定項目としては\n\nPAPERLESS_URL: Django の CSRF / CORS / ALLOWED_HOSTS を自動設定するための環境変数．末尾スラッシュなし\n\n今回は Port 8888 経由で公開するので\nPAPERLESS_URL=https://hogehoge.tail8ada9.ts.net:8888\nと設定します．https://hogehoge.tail8ada9.ts.net:8888 はtailscale serve statusで確認できるものにします．\n上記を踏まえると以下のような docker-compose.env となります\nUSERMAP_UID=120\nUSERMAP_GID=120\nPAPERLESS_TIME_ZONE=Asia/Tokyo\nPAPERLESS_OCR_LANGUAGE=eng+jpn\nPAPERLESS_SECRET_KEY='hogehogehgoehgoeghoeh'\nPAPERLESS_URL=https://hogehoge.tail8ada9.ts.net:8888\nStep 2: tailnet serve設定 の設定\nTailscale の HTTP/HTTPS リバースプロキシ機能をつかってローカルサービスをTailnet上で公開します．\nサーバー側で以下のコマンドを実行します\nsudo tailscale serve --bg --https=8888 8888\n\n\n\n\n\n\n\n\nコマンド部分\n説明\nポイント / 注意点\n\n\n\n\ntailscale serve\nローカルの HTTP/HTTPS サービスを Tailscale ネットワーク上で公開するリバースプロキシ機能\nTailscale 1.36 以降で利用可能\n\n\n--bg\nバックグラウンドで実行\nターミナルを閉じてもプロセスは継続。デーモン的に動作\n\n\n--https=8888\nTailscale 側で HTTPS を提供するポート番号\n自動生成証明書で TLS 保護された HTTPS アクセスが可能\n\n\n8888 (最後の引数)\nローカルサービスのポート番号\nローカルの localhost:8888 にあるサービスを Tailscale HTTPS ポートに接続\n\n\n\n上記コマンドの実行後， Tailscale 内から https://&lt;tailscale-node&gt;:8888 でローカルサービスとしてのpaperless-ngxへアクセス可能となります．\n\n\n\n\n\n\nNoteサービスを非公開にしたい場合\n\n\n\nTailscale 内から Paperless-ngx にHTTPSでアクセス負荷にしたい場合は\nsudo tailscale serve --bg --https=8888 off\nポートは8888想定ですが，sudo tailscale serve --bg --https=&lt;port&gt; 8888 の &lt;port&gt; に応じて変更して下さい．"
  },
  {
    "objectID": "posts/2025-11-27-paperless-ngx/index.html#appendix-1-グループからユーザーを削除する方法",
    "href": "posts/2025-11-27-paperless-ngx/index.html#appendix-1-グループからユーザーを削除する方法",
    "title": "paperless-ngxによるセルフホスティングドキュメント管理システム",
    "section": "Appendix 1: グループからユーザーを削除する方法",
    "text": "Appendix 1: グループからユーザーを削除する方法\n特定のユーザーをグループから削除するには gpasswd or deluser コマンドを使用します\ngpasswdコマンド\n## long option\nsudo gpasswd --delete user1 papaerless-ngx\n\n## short option\nsudo gpasswd -d user1 papaerless-ngx\n\n# 現在のユーザーをpaperless-ngxから除去\nsudo gpasswd -d $(whoami) paperless-ngx\ndeluserコマンド\n## syntax\nsudo deluser user1 paperless-ngx\n\n# 現在のユーザーをpaperless-ngxから除去\nsudo deluser $(whoami) paperless-ngx"
  },
  {
    "objectID": "posts/2025-11-27-paperless-ngx/index.html#appendix-2-zoteroとの併用方法",
    "href": "posts/2025-11-27-paperless-ngx/index.html#appendix-2-zoteroとの併用方法",
    "title": "paperless-ngxによるセルフホスティングドキュメント管理システム",
    "section": "Appendix 2: Zoteroとの併用方法",
    "text": "Appendix 2: Zoteroとの併用方法\n基本コンセプトは，Paperless-ngxを原本置き場，Zotero はメタデータ管理だけ\n\nPDF ファイルを Zotero に保存しない\nPDF の原本はすべて Paperless に一元管理\nZotero は「文献管理ソフト」として最小限データだけ持つ\nZotero 内では Linked Attachment（リンクされた添付ファイル）を使い，Paperless の PDF を参照する\n\n\n\n\n\n\n\n\n\n\n役割\n担当\n説明\n\n\n\n\nPaperless-ngx\n原本保管庫（PDF の全保管・OCR・タグ）\nすべての PDF ファイルの実体を保管する（NAS代わり）\n\n\nZotero\n文献リスト＋引用情報\nメタデータだけを管理し，PDF本体は保存しない\n\n\n\n\n運用イメージ\n\nPDF を Paperless-ngx に入れる\nPaperless-ngx が OCR＋タグ整理\n必要に応じて Zotero に 文献情報（DOI など）を登録\n添付ファイルとして Paperless-ngx の PDF パスを貼る（手動 or 自動スクリプト）"
  },
  {
    "objectID": "posts/2025-11-27-paperless-ngx/index.html#references",
    "href": "posts/2025-11-27-paperless-ngx/index.html#references",
    "title": "paperless-ngxによるセルフホスティングドキュメント管理システム",
    "section": "References",
    "text": "References\n\nPaperless-ngx公式ドキュメント\nPackage: tesseract-ocr-jpn-vert"
  },
  {
    "objectID": "posts/2025-03-03-triangle-inequality/index.html",
    "href": "posts/2025-03-03-triangle-inequality/index.html",
    "title": "いろいろな三角不等式",
    "section": "",
    "text": "Theorem 1 : シュワルツの不等式 \n任意の２つのベクトル \\(\\pmb{a}, \\pmb{b}\\) に対して，\n\\[\n\\vert (\\pmb{a}, \\pmb{b})\\vert \\leq ||\\pmb{a}||\\,||\\pmb{b}||\n\\]\n等号が成り立つのは \\(\\pmb a = k\\pmb b\\) または, \\(\\pmb b = k^\\prime\\pmb a\\) が成り立つ場合に限る(\\(k,k^\\prime \\in \\mathbf R\\))．\n\n\n\n\n\n\n\n\n\nNoteProof\n\n\n\n\n\n ▶  \\(\\pmb b = \\pmb 0\\) のとき\n\\(\\pmb b = \\pmb 0\\) のときは等号が成り立つことは自明．\n ▶  \\(\\pmb b \\neq \\pmb 0\\) のとき\n\\(\\displaystyle k = \\frac{(\\pmb a, \\pmb b)}{||\\pmb b||^2}\\) とおくと，\n\\[\n\\begin{align}\n||\\pmb a - k\\pmb b||^2\n    &= ||\\pmb a||^2 - 2k(\\pmb a, \\pmb b) + k^2 ||\\pmb b||^2\\\\\n    &= ||\\pmb a||^2 - 2\\frac{(\\pmb a, \\pmb b)^2}{||\\pmb b||^2} + \\frac{(\\pmb a, \\pmb b)^2}{||\\pmb b||^2}\\\\\n    &= ||\\pmb a||^2 - \\frac{(\\pmb a, \\pmb b)^2}{||\\pmb b||^2}\n\\end{align}\n\\]\nここで，\\(||\\pmb a - k\\pmb b||^2 \\geq 0\\) であるので\n\\[\n||\\pmb a||^2 \\geq \\frac{(\\pmb a, \\pmb b)^2}{||\\pmb b||^2}\n\\]\nこれを整理すると\n\\[\n||\\pmb a||^2||\\pmb b||^2 \\geq (\\pmb a, \\pmb b)^2 \\Rightarrow ||\\pmb a||\\,||\\pmb b|| \\geq |(\\pmb a, \\pmb b)|\n\\]\n等号成立が成立するとき \\(||\\pmb a - k\\pmb b||^2 = 0\\) であるので，\\(\\pmb a = k\\pmb b\\) が必要条件であることがわかります．\n ▶  \\(\\pmb a = k\\pmb b\\) の十分条件性 \n\\[\n\\begin{align}\n||\\pmb a||\\,||\\pmb b||\n    &= |k|||\\pmb b||\\,||\\pmb b||\\\\\n    &= |k|||\\pmb b||^2\n\\end{align}\n\\]\nまた\n\\[\n\\begin{align}\n|(\\pmb a, \\pmb b)|\n    &= |k|(\\pmb b, \\pmb b)\\\\\n    &= |k|||\\pmb b||^2\n\\end{align}\n\\]\nしたがって，\\(|\\pmb a||\\,||\\pmb b|| = |(\\pmb a, \\pmb b)|\\) が成り立つことがわかります．\n\n\n\n\n\nTheorem 2 : シュワルツの不等式と三角不等式 \n任意の２つのベクトル \\(\\pmb{a}, \\pmb{b}\\) に対して，\n\\[\n||\\pmb{a} + \\pmb{b}|| \\leq ||\\pmb{a}||\\, ||\\pmb{b}||\n\\]\n等号が成り立つのは \\(\\pmb a = k\\pmb b, k\\geq 0\\) または, \\(\\pmb b = k^\\prime\\pmb a, k^\\prime\\geq 0\\) が成り立つ場合に限る．\n\n\n\n\n\n\n\n\n\nNoteProof\n\n\n\n\n\nシュワルツの不等式を用いると\n\\[\n\\begin{align}\n||\\pmb{a} + \\pmb{b}||^2\n    &= ||\\pmb{a}||^2 + 2(\\pmb{a},\\pmb{b}) + ||\\pmb{b}||^2\\\\\n    &\\leq ||\\pmb{a}||^2 + 2||\\pmb{a}||\\,||\\pmb{b}|| + ||\\pmb{b}||^2\\\\\n    &= (||\\pmb{a}|| + ||\\pmb{b}||)^2\n\\end{align}\n\\]\nしたがって，\n\\[\n||\\pmb{a} + \\pmb{b}|| \\leq ||\\pmb{a}||\\, ||\\pmb{b}||\n\\]\n等号成立はシュワルツの不等式の等号が成立し，かつ\n\\[\n(\\pmb{a},\\pmb{b}) \\geq 0\n\\]\nが成立するときとなるので， \\(\\pmb a = k\\pmb b, k\\geq 0\\) または, \\(\\pmb b = k^\\prime\\pmb a, k^\\prime\\geq 0\\) が成り立つ場合に限ることがわかる．"
  },
  {
    "objectID": "posts/2025-03-03-triangle-inequality/index.html#シュワルツの不等式と三角不等式",
    "href": "posts/2025-03-03-triangle-inequality/index.html#シュワルツの不等式と三角不等式",
    "title": "いろいろな三角不等式",
    "section": "",
    "text": "Theorem 1 : シュワルツの不等式 \n任意の２つのベクトル \\(\\pmb{a}, \\pmb{b}\\) に対して，\n\\[\n\\vert (\\pmb{a}, \\pmb{b})\\vert \\leq ||\\pmb{a}||\\,||\\pmb{b}||\n\\]\n等号が成り立つのは \\(\\pmb a = k\\pmb b\\) または, \\(\\pmb b = k^\\prime\\pmb a\\) が成り立つ場合に限る(\\(k,k^\\prime \\in \\mathbf R\\))．\n\n\n\n\n\n\n\n\n\nNoteProof\n\n\n\n\n\n ▶  \\(\\pmb b = \\pmb 0\\) のとき\n\\(\\pmb b = \\pmb 0\\) のときは等号が成り立つことは自明．\n ▶  \\(\\pmb b \\neq \\pmb 0\\) のとき\n\\(\\displaystyle k = \\frac{(\\pmb a, \\pmb b)}{||\\pmb b||^2}\\) とおくと，\n\\[\n\\begin{align}\n||\\pmb a - k\\pmb b||^2\n    &= ||\\pmb a||^2 - 2k(\\pmb a, \\pmb b) + k^2 ||\\pmb b||^2\\\\\n    &= ||\\pmb a||^2 - 2\\frac{(\\pmb a, \\pmb b)^2}{||\\pmb b||^2} + \\frac{(\\pmb a, \\pmb b)^2}{||\\pmb b||^2}\\\\\n    &= ||\\pmb a||^2 - \\frac{(\\pmb a, \\pmb b)^2}{||\\pmb b||^2}\n\\end{align}\n\\]\nここで，\\(||\\pmb a - k\\pmb b||^2 \\geq 0\\) であるので\n\\[\n||\\pmb a||^2 \\geq \\frac{(\\pmb a, \\pmb b)^2}{||\\pmb b||^2}\n\\]\nこれを整理すると\n\\[\n||\\pmb a||^2||\\pmb b||^2 \\geq (\\pmb a, \\pmb b)^2 \\Rightarrow ||\\pmb a||\\,||\\pmb b|| \\geq |(\\pmb a, \\pmb b)|\n\\]\n等号成立が成立するとき \\(||\\pmb a - k\\pmb b||^2 = 0\\) であるので，\\(\\pmb a = k\\pmb b\\) が必要条件であることがわかります．\n ▶  \\(\\pmb a = k\\pmb b\\) の十分条件性 \n\\[\n\\begin{align}\n||\\pmb a||\\,||\\pmb b||\n    &= |k|||\\pmb b||\\,||\\pmb b||\\\\\n    &= |k|||\\pmb b||^2\n\\end{align}\n\\]\nまた\n\\[\n\\begin{align}\n|(\\pmb a, \\pmb b)|\n    &= |k|(\\pmb b, \\pmb b)\\\\\n    &= |k|||\\pmb b||^2\n\\end{align}\n\\]\nしたがって，\\(|\\pmb a||\\,||\\pmb b|| = |(\\pmb a, \\pmb b)|\\) が成り立つことがわかります．\n\n\n\n\n\nTheorem 2 : シュワルツの不等式と三角不等式 \n任意の２つのベクトル \\(\\pmb{a}, \\pmb{b}\\) に対して，\n\\[\n||\\pmb{a} + \\pmb{b}|| \\leq ||\\pmb{a}||\\, ||\\pmb{b}||\n\\]\n等号が成り立つのは \\(\\pmb a = k\\pmb b, k\\geq 0\\) または, \\(\\pmb b = k^\\prime\\pmb a, k^\\prime\\geq 0\\) が成り立つ場合に限る．\n\n\n\n\n\n\n\n\n\nNoteProof\n\n\n\n\n\nシュワルツの不等式を用いると\n\\[\n\\begin{align}\n||\\pmb{a} + \\pmb{b}||^2\n    &= ||\\pmb{a}||^2 + 2(\\pmb{a},\\pmb{b}) + ||\\pmb{b}||^2\\\\\n    &\\leq ||\\pmb{a}||^2 + 2||\\pmb{a}||\\,||\\pmb{b}|| + ||\\pmb{b}||^2\\\\\n    &= (||\\pmb{a}|| + ||\\pmb{b}||)^2\n\\end{align}\n\\]\nしたがって，\n\\[\n||\\pmb{a} + \\pmb{b}|| \\leq ||\\pmb{a}||\\, ||\\pmb{b}||\n\\]\n等号成立はシュワルツの不等式の等号が成立し，かつ\n\\[\n(\\pmb{a},\\pmb{b}) \\geq 0\n\\]\nが成立するときとなるので， \\(\\pmb a = k\\pmb b, k\\geq 0\\) または, \\(\\pmb b = k^\\prime\\pmb a, k^\\prime\\geq 0\\) が成り立つ場合に限ることがわかる．"
  },
  {
    "objectID": "posts/2025-03-03-triangle-inequality/index.html#複素数と三角不等式",
    "href": "posts/2025-03-03-triangle-inequality/index.html#複素数と三角不等式",
    "title": "いろいろな三角不等式",
    "section": "複素数と三角不等式",
    "text": "複素数と三角不等式\n\n\nTheorem 3 \n複素平面上に2点 \\(z = a_1 + b_1i, w = a_2 + b_2i\\) をとったとき，次の不等式が成立する\n\\[\n\\begin{gather}\n\\vert z + w \\vert \\leq \\vert z\\vert + \\vert w \\vert\\\\\n\\vert z\\vert - \\vert w \\vert \\leq \\vert z - w \\vert\n\\end{gather}\n\\]\nこれを三角不等式と呼ぶ．\n\n\n\n\n\n\n\n\n\nNoteProof 1\n\n\n\n\n\n注意: この証明は平面空間における三角不等式を前提にしているのでトートロジー疑惑が有ります\n\n\nCode\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Define the complex numbers\nalpha1 = 3 + 4j\nalpha2 = 5 + 2j\nalpha3 = alpha1 + alpha2\nalpha4 = alpha1 - alpha2\n\n# Extract the real and imaginary parts\na1_real, a1_imag = alpha1.real, alpha1.imag\na2_real, a2_imag = alpha2.real, alpha2.imag\na3_real, a3_imag = alpha3.real, alpha3.imag\na4_real, a4_imag = alpha4.real, alpha4.imag\n\n# Create the plot\nfig, ax = plt.subplots()\n\n# Plot the vectors\nax.quiver(0, 0, a1_real, a1_imag, angles=\"xy\", scale_units=\"xy\", scale=1, color=\"k\")\nax.quiver(0, 0, a2_real, a2_imag, angles=\"xy\", scale_units=\"xy\", scale=1, color=\"k\")\nax.quiver(\n    a1_real,\n    a1_imag,\n    a2_real,\n    a2_imag,\n    angles=\"xy\",\n    scale_units=\"xy\",\n    linewidth=1,\n    scale=1,\n    edgecolor=\"gray\",\n    color=\"gray\",\n)\nax.quiver(0, 0, a3_real, a3_imag, angles=\"xy\", scale_units=\"xy\", scale=1, color=\"k\")\nax.quiver(0, 0, a4_real, a4_imag, angles=\"xy\", scale_units=\"xy\", scale=1, color=\"k\")\nax.quiver(\n    a1_real,\n    a1_imag,\n    -a2_real,\n    -a2_imag,\n    angles=\"xy\",\n    scale_units=\"xy\",\n    linewidth=1,\n    scale=1,\n    edgecolor=\"gray\",\n    color=\"gray\",\n)\n\n\n# add point\nax.text(a1_real, a1_imag * 1.1, \"$z$\")\nax.text(a2_real, a2_imag, \"$w$\")\nax.text(a3_real, a3_imag, \"$z+w$\")\nax.text(a4_real, a4_imag + 0.5, \"$z-w$\")\n\n\n# Set the plot limits\nax.set_xlim(a4_real - 1, max(a1_real, a3_real) + 3)\nax.set_ylim(-1, max(a1_imag, a3_imag) + 3)\n\n# Add grid, labels, and legend\nax.grid()\nax.set_aspect(\"equal\")\nax.set_xlabel(\"Real Part\")\nax.set_ylabel(\"Imaginary Part\")\n\n# Add title\nax.set_title(\"Complex Number Vectors\")\n\n# Show the plot\nplt.show()\n\n\n\n\n\n\n\n\n\n原点と \\(z, z+w\\) を頂点とする三角形を考えます．このときそれぞれの辺の長さは \\(\\vert z\\vert, \\vert w\\vert, \\vert z + w\\vert\\) となります．\n三角形の二辺の和は他の１辺の長さより長いので\n\\[\n\\vert z + w \\vert \\leq \\vert z\\vert + \\vert w \\vert\n\\]\nが成立する．\n同様に\\(z, z-w\\) を頂点とする三角形についても\n\\[\n\\vert z \\vert \\leq \\vert z + w \\vert + \\vert w \\vert\n\\]\nが成り立つので，これを整理すると\n\\[\n\\vert z\\vert - \\vert w \\vert \\leq \\vert z - w \\vert\n\\]\n\n\n\n\n\n\n\n\n\n\nNoteProof 2\n\n\n\n\n\n複素数の絶対値と共役複素数の関係より\n\\[\n\\begin{align}\n\\vert  z + w \\vert^2\n    &= (z + w)(\\bar z + \\bar w)\\\\\n    &= z\\bar z + w\\bar w + w\\bar z + z\\bar w\\\\\n    &= \\vert z\\vert^2 + \\vert w\\vert^2 + w \\overline z + z \\overline w\\\\\n    &= \\vert z\\vert^2 + \\vert w\\vert^2 + w \\overline z + \\overline{\\overline z w}\\\\\n    &= \\vert z\\vert^2 + \\vert w\\vert^2 + 2\\operatorname{Re}w \\overline z\\\\\n    &\\leq \\vert z\\vert^2 + \\vert w\\vert^2 + 2\\vert w \\overline z\\vert\\\\\n    &= \\vert z\\vert^2 + \\vert w\\vert^2 + 2\\vert w\\vert \\vert\\overline z\\vert\\\\\n    &= \\vert z\\vert^2 + \\vert w\\vert^2 + 2\\vert w\\vert \\vert z\\vert\\\\\n    &= (\\vert z \\vert + \\vert w \\vert)^2\n\\end{align}\n\\]\nしたがって，\n\\[\n\\vert  z + w \\vert \\leq \\vert z \\vert + \\vert w \\vert\n\\]\n\n\n\n\n\nTheorem 4 \n\\(\\mathbb C^n\\) の任意のベクトル \\(\\pmb a, \\pmb b\\) に対し，次が成立する\n\\[\n||\\pmb a + \\pmb b|| \\leq ||\\pmb a|| + ||\\pmb b||\n\\]\n\n\n\n\n\n\n\n\n\nNoteProof\n\n\n\n\n\n\\[\n\\begin{align}\n||\\pmb a + \\pmb b||^2\n    &= (\\pmb a + \\pmb b, \\pmb a + \\pmb b)\\\\\n    &= ||\\pmb a||^2 + ||\\pmb b||^2 + (\\pmb a, \\pmb b) + (\\pmb b, \\pmb a)\n\\end{align}\n\\]\nここでシュワルツの不等式より\n\\[\n\\begin{align}\n|(\\pmb a, \\pmb b)| &\\leq ||\\pmb a||\\,||\\pmb b||\\\\\n|(\\pmb b, \\pmb a)| &\\leq ||\\pmb b||\\,||\\pmb a|| = ||\\pmb a||\\,||\\pmb b||\n\\end{align}\n\\]\n従って，\n\\[\n\\begin{align}\n||\\pmb a||^2 + ||\\pmb b||^2 + (\\pmb a, \\pmb b) + (\\pmb b, \\pmb a)\n    &\\leq ||\\pmb a||^2 + ||\\pmb b||^2  + 2 ||\\pmb a||\\,||\\pmb b||\\\\\n    &= (||\\pmb a|| + ||\\pmb b||)^2\n\\end{align}\n\\]\nよって，\n\\[\n\\begin{gather}\n||\\pmb a + \\pmb b||^2 \\leq (||\\pmb a|| + ||\\pmb b||)^2\\\\\n\\Rightarrow ||\\pmb a + \\pmb b|| \\leq ||\\pmb a|| + ||\\pmb b||\n\\end{gather}\n\\]"
  },
  {
    "objectID": "posts/2025-02-03-continuous-function/index.html",
    "href": "posts/2025-02-03-continuous-function/index.html",
    "title": "関数の連続性",
    "section": "",
    "text": "変数 \\(x\\) が限りなく \\(a\\) に近づくとき，\\(f(x)\\) も \\(f(a)\\) に近づくならば，\\(f(x)\\) は \\(x=a\\) において連続である，といいます．つまり，\n\\[\nx\\to a \\text{ ならば } f(x) \\to f(a)\n\\]\n\nDef: \\(\\epsilon\\)-\\(\\delta\\) 論法的連続性 \n任意の \\(\\epsilon &gt;0\\) に対して，ある \\(\\delta &gt; 0\\) が存在して，\n\\[\n\\vert x - a \\vert &lt; \\delta \\Rightarrow \\vert f(x) - f(a)\\vert &lt; \\epsilon\n\\]\nを満たすとき，\\(x=a\\) において \\(f(x)\\) は連続であるという．\n\n\nExample 1 \n\\(f(x) = \\sqrt{x}\\) について，\\(a &gt; 0\\) で連続であることを以下示します．\n\\[\n\\begin{align}\n\\vert \\sqrt{x} - \\sqrt{a} \\vert\n    &= \\left\\vert\\frac{(\\sqrt{x} - \\sqrt{a})(\\sqrt{x} + \\sqrt{a})}{\\sqrt{x}+\\sqrt{a}}\\right\\vert\\\\\n    &= \\left\\vert\\frac{x - a}{\\sqrt{x}+\\sqrt{a}}\\right\\vert\\\\\n    &\\leq \\left\\vert\\frac{x - a}{\\sqrt{a}}\\right\\vert\n\\end{align}\n\\]\nここで，\\(\\vert x - a\\vert &lt; \\delta(\\epsilon) = \\epsilon\\sqrt{a}\\) と定めると\n\\[\n\\vert x - a\\vert &lt; \\delta(\\epsilon) \\Rightarrow \\vert \\sqrt{x} - \\sqrt{a}\\vert &lt; \\epsilon\n\\]\n\n\n\nExample 2 : 三角関数の連続性 \n\\(x = a + h\\) とおくと，和積の公式を用いて\n\\[\n\\begin{align}\n\\vert \\sin(x) - \\sin(a) \\vert\n    &= 2\\left\\vert \\cos\\frac{x+a}{2}\\sin\\frac{x-a}{2} \\right\\vert\\\\\n    &= 2\\left\\vert \\cos\\left(a + \\frac{h}{2}\\right)\\sin\\frac{h}{2} \\right\\vert\\\\\n    &\\leq 2\\left\\vert\\frac{h}{2}\\right\\vert \\cdot 1\\\\\n    &=\\vert h \\vert\n\\end{align}\n\\]\n\\(\\cos x = \\sin\\left(x + \\frac{\\pi}{2}\\right)\\) であるので，\\(\\sin x\\) が連続であるならば, \\(\\cos x\\) も連続．\n\n\n\n\nTheorem 1  : 連続関数の定数倍\n\\(f(x)\\) は \\(x=a\\) で連続であるとします．このとき，定数 \\(c\\) を用いた \\(cf(x)\\) も \\(x=a\\) にて連続となります．\n\n\n\n\n\n\n\n\n\nNoteProof\n\n\n\n\n\n仮定より\n\\[\n\\forall \\eta &gt; 0, \\exists \\delta(\\eta) &gt; 0, \\vert x - a\\vert &lt; \\delta(\\eta)\\Rightarrow\\vert f(x) - f(a)\\vert &lt; \\eta\n\\]\nこのとき，任意の \\(\\epsilon &gt; 0\\) に対して，\n\\[\n\\eta = \\frac{\\epsilon}{\\vert c \\vert} &gt;0\n\\]\nと対応させると，\n\\[\n\\forall \\epsilon &gt; 0, \\exists \\delta(\\epsilon) &gt; 0, \\vert x - a\\vert &lt; \\delta(\\epsilon)\\Rightarrow\\vert f(x) - f(a)\\vert &lt; \\frac{\\epsilon}{\\vert c \\vert }\n\\]\nつまり，\n\\[\n\\forall \\epsilon &gt; 0, \\exists \\delta(\\epsilon) &gt; 0, \\vert x - a\\vert &lt; \\delta(\\epsilon)\\Rightarrow \\vert c\\vert\\vert f(x) - f(a)\\vert &lt; \\epsilon\n\\]\nこれを変形すると\n\\[\n\\forall \\epsilon &gt; 0, \\exists \\delta(\\epsilon) &gt; 0, \\vert x - a\\vert &lt; \\delta(\\epsilon)\\Rightarrow \\vert cf(x) - cf(a)\\vert &lt; \\epsilon\n\\]\n\n\n\n\n\nTheorem 2 : 連続関数の和\n\n\\(f(x), g(x)\\) は \\(x=a\\) で連続であるとします．このとき，\\(f(x) + g(x)\\) も \\(x=a\\) にて連続となります．\n\n\n\n\n\n\n\n\n\nNoteProof\n\n\n\n\n\n仮定より\n\\[\n\\begin{align}\n\\vert x - a \\vert &lt; \\delta&\\Rightarrow \\vert f(x) - f(a)\\vert &lt; \\epsilon/2\\\\\n\\vert x - a \\vert &lt; \\eta&\\Rightarrow \\vert g(x) - g(a)\\vert &lt; \\epsilon/2\n\\end{align}\n\\]\nここで，\\(M = \\min(\\delta, \\eta)\\) とすると，\n\\[\n\\begin{align}\n\\vert x - a \\vert &lt; M&\\Rightarrow \\vert f(x) - f(a)\\vert &lt; \\epsilon/2\\\\\n\\vert x - a \\vert &lt; M&\\Rightarrow \\vert g(x) - g(a)\\vert &lt; \\epsilon/2\n\\end{align}\n\\]\nまた\n\\[\n\\begin{align}\n\\vert(f(x) - g(x)) - (f(a) + g(a))\n    &= \\vert(f(x) - f(a)) + (g(x) + g(a))\\vert\\\\\n    &\\leq \\vert(f(x) - f(a))\\vert + \\vert (g(x) + g(a))\\vert\n\\end{align}\n\\]\n従って，\\(\\vert x - a \\vert &lt; M\\) であるならば\n\\[\n\\begin{align}\n\\vert (g(x) + f(x)) - (g(a) + f(a))\\vert \\leq \\vert(f(x) - f(a))\\vert + \\vert (g(x) + g(a))\\vert &lt; \\epsilon\n\\end{align}\n\\]\n\n\n\n\n\nTheorem 3  : 連続関数の線型結合\n\\(f(x), g(x)\\) は \\(x=a\\) で連続であるとします．このとき，定数 \\(c_1, c_2\\)に対して \\(c_1f(x) + c_2g(x)\\) も \\(x=a\\) にて連続となります．\n\n\n\n\n\n\n\n\n\nNoteProof\n\n\n\n\n\n\\[\n\\begin{align}\n\\vert x - a \\vert &lt; \\delta&\\Rightarrow \\vert f(x) - f(a)\\vert &lt; \\frac{\\epsilon}{2\\vert c_1\\vert}\\\\\n\\vert x - a \\vert &lt; \\eta&\\Rightarrow \\vert g(x) - g(a)\\vert &lt; \\frac{\\epsilon}{2\\vert c_2\\vert}\n\\end{align}\n\\]\nとして，\\(M = \\min(\\delta, \\eta)\\) とすれば，上記と同様に連続性を示すことができます．\n\n\n\n\n\nTheorem 4  : 連続関数の積\n\\(f(x), g(x)\\) は \\(x=a\\) で連続であるとします．このとき，\\(f(x)g(x)\\) も \\(x=a\\) にて連続となります．\n\n\n\n\n\n\n\n\n\nNoteProof\n\n\n\n\n\n\\[\n\\vert x - a \\vert &lt; \\delta(1) \\Rightarrow \\vert f(x) - f(a)\\vert &lt; 1\n\\]\nとすると，\n\\[\n\\vert x - a \\vert &lt; \\delta(1) \\Rightarrow \\vert f(x) \\vert &lt; 1 + \\vert f(a) \\vert\n\\]\n\\(\\delta, \\eta\\) を以下のように定め，\n\\[\n\\begin{align}\n\\vert x - a \\vert &lt; \\delta &\\Rightarrow \\vert f(x) - f(a)\\vert &lt; \\frac{\\epsilon}{2(1 + \\vert f(a) \\vert + \\vert g(a) \\vert)}\\\\\n\\vert x - a \\vert &lt; \\eta &\\Rightarrow \\vert g(x) - g(a)\\vert &lt; \\frac{\\epsilon}{2(1 + \\vert f(a) \\vert + \\vert g(a) \\vert)}\n\\end{align}\n\\]\n\\[\n\\delta(\\epsilon) = \\min (\\delta(1), \\delta, \\eta)\n\\]\nとすると，\n\\[\n\\begin{align}\n\\vert x - a \\vert &lt; \\delta(\\epsilon)\n    \\Rightarrow &\\vert f(x)g(x) - f(a)g(a)\\vert\\\\[5pt]\n    &= \\vert f(x)(g(x) - g(a)) + g(a)(f(x) - f(a))\\vert\\\\[5pt]\n    &\\leq \\vert f(x)\\vert \\vert(g(x) - g(a))\\vert + \\vert g(a)\\vert\\vert(f(x) - f(a))\\vert\\\\[5pt]\n    &&lt; (1 + \\vert f(a) \\vert)\\frac{\\epsilon}{2(1 + \\vert f(a) \\vert + \\vert g(a) \\vert)} + \\vert g(a)\\vert \\frac{\\epsilon}{2(1 + \\vert f(a) \\vert + \\vert g(a) \\vert)}\\\\\n    &= \\epsilon\n\\end{align}\n\\]\nよって，連続性が示された．\n\n\n\n\n\nTheorem 5  連続関数の逆数 \n\\(f(x)\\) は \\(x=a\\) で連続であるとします．このとき，\\(f(a)\\neq 0\\) であるならば \\(1/f(x)\\) も \\(x=a\\) にて連続となります．\n\n\n\n\n\n\n\n\n\nNoteProof\n\n\n\n\n\n連続性の仮定より\n\\[\n\\vert x - a \\vert &lt; \\delta(\\vert f(a)/2\\vert) \\Rightarrow \\vert f(x) - f(a)\\vert &lt; \\frac{\\vert f(a)\\vert}{2}\n\\]\nとすると，\n\\[\n\\vert x - a \\vert &lt; \\delta(\\vert f(a)/2\\vert) \\Rightarrow \\frac{\\vert f(a)\\vert}{2} &lt; \\vert f(x)\\vert\n\\]\nこのとき，\n\\[\n\\begin{align}\n\\left\\vert \\frac{1}{f(x)} - \\frac{1}{f(a)} \\right\\vert\n    &= \\left\\vert \\frac{f(x) - f(a)}{f(x)f(a)} \\right\\vert\\\\\n    &&lt; \\left\\vert \\frac{f(x) - f(a)}{(f(a))^2 / 2} \\right\\vert\n\\end{align}\n\\]\n従って，\\(\\vert x - a \\vert &lt; \\eta \\Rightarrow \\vert f(x) - f(a)\\vert &lt; \\displaystyle\\frac{\\epsilon\\vert (f(a))^2\\vert}{2}\\) となるような \\(\\eta\\) を用いて，\n\\[\n\\delta(\\epsilon) = \\min(\\delta(\\vert f(a)/2\\vert), \\eta)\n\\]\nとすれば\n\\[\n\\vert x - a \\vert &lt; \\delta(\\epsilon) \\Rightarrow \\left\\vert \\frac{1}{f(x)} - \\frac{1}{f(a)} \\right\\vert &lt; \\epsilon\n\\]\n\n\n\n\n\n点 \\(a\\) における極限を考えるとき，\n\n\\(x\\) が増大しつつ \\(a\\) に（左側から）近づく, \\(\\lim_{x\\to a-0}\\)\n\\(x\\) が減少しつつ \\(a\\) に（右側から）近づく, \\(\\lim_{x\\to a+0}\\)\n\nそれぞれの場合を分けて取り扱うことがあります．\n\nExample 3 \n\\(f(x) = \\tan x\\) について，\\(x = \\pi/2\\) における極限を考えてみます．\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport sympy as sy\n\nx = sy.Symbol('x')\nf = sy.tan(x)\n\nx_vals = np.linspace(-np.pi/2+1e-6, np.pi, 400)\ny_vals = np.tan(x_vals)\n\nplt.figure(figsize=(8, 6))\nplt.plot(x_vals, y_vals, label=r'$f(x) = \\tan(x)$')\nplt.ylim(-10, 10)\nplt.xticks([-np.pi/2, 0, np.pi/2, np.pi], [r'$-\\frac{\\pi}{2}$', '0', r'$\\frac{\\pi}{2}$', r'$\\pi$'])\nplt.axvline(np.pi/2, color='r', linestyle='--', label=r'$x = \\frac{\\pi}{2}$')\nplt.axhline(0, color='black',linewidth=0.5)\nplt.axvline(0, color='black',linewidth=0.5)\nplt.title(r'Plot of $f(x) = \\tan(x)$ around $x = \\frac{\\pi}{2}$')\nplt.xlabel('x')\nplt.ylabel('f(x)')\nplt.legend()\nplt.grid(True)\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 1\n\n\n\n上記の図のように，\n\\[\n\\begin{align}\n\\lim_{x\\to \\pi/2+0} \\tan x &= -\\infty\\\\\n\\lim_{x\\to \\pi/2-0} \\tan x &= \\infty\n\\end{align}\n\\]\n実際に，sympy で確認してみると\n\n# DO NOT USE np.pi\nprint(f\"左極限: {sy.limit(sy.tan(x), x, sy.pi/2, '-')}\")\nprint(f\"右極限: {sy.limit(sy.tan(x), x, sy.pi/2, '+')}\")\n\n左極限: oo\n右極限: -oo\n\n\n\n\n ▶  右連続と左連続\n\\[\n\\begin{align}\nf(a) &= \\alpha\\\\[5pt]\n\\lim_{x\\to a-0} f(x) &= \\alpha\\\\\n\\lim_{x\\to a+0} f(x) &= \\beta \\neq \\alpha\n\\end{align}\n\\]\nのとき，\\(f(x)\\) は \\(x = a\\) において左連続といいます．\n\\(f(x)\\) が閉区間 \\([a, b]\\) において定義されているとき，\n\n\\(x=a\\) においては右連続\n\\(x=b\\) においては左連続\n\nであることを意味します．開区間 \\((a, b)\\) において定義されているとき，\\(f(a+0)\\) が確定ならば，それを \\(f(a)\\) として定義域を \\([a, b)\\) 区間に拡張すると \\(f(x)\\) は \\(x=a\\) において右連続になります．\n一方，\\((0, \\infty)\\) 区間で定義された関数 \\(\\displaystyle f(x) = \\frac{1}{x}\\) は開区間では連続ですが，\\(x = 0\\) のときは定義されません．このとき，\\(f(0) = 0\\) として定義域を \\([0, \\infty)\\) に拡張すると，\\(x=0\\) で連続な関数にはなりませんし，\\(f(0)\\) をどんな値にしたとしても，\\(x=0\\) の近傍において, \\(f(x)\\) はいくらでも大きくなってしまうので，連続な関数にはなりません．\n\n📘 REMARKS \n\n開区間 \\((a, b)\\) で定義された連続な関数が，開区間 \\([a, b]\\) の連続な関数に拡張できるとは限らない\n\n\n\nExample 4  : 右連続関数と累積分布関数 \n離散確率変数 \\(X\\sim\\operatorname{Bin}(5, 1/3)\\) を考えます．離散確率変数の累積分布関数 \\(F(x)\\) は\n\\[\nF(x) = \\operatorname{P}(X \\leq x) = \\sum_{y\\leq x}p(y) \\qquad p(y): \\text{確率関数}\n\\]\nと定義されるので，\\(F(x)\\) は右側連続となります．実際に\n\nCode\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom scipy.stats import binom\n\nn, p = 5, 1 / 3\nx = np.arange(0, 6)\ncdf = binom.cdf(x, n, p)\n\nfig, ax = plt.subplots(1, 1)\nax.hlines(cdf, x, x + 1, color=\"gray\")\nax.step(x, cdf, where=\"post\", color=\"gray\", linestyle=\"dotted\")\nax.plot(x, cdf, \"o\", color=\"gray\")\nax.scatter(x[:-1] + 1, cdf[:-1], marker=\"$\\u25EF$\", alpha=0.5, color=\"gray\")\nax.set_xlabel(\"x\")\nax.set_ylabel(\"F(x)\")\nax.set_title(\"CDF of Binomial Distribution (n=5, p=1/3)\")\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 2\n\n\n\nこのとき，確率関数は\n\\[\np(x) = F(x) - \\lim_{x_n\\to x-0}F(x_n)\n\\]\nとすることで計算することが出来ます．一方，\\(F(x) = \\operatorname{P}(X &lt; x)\\) と定義すると左連続となります．\n\n\n\n\n\n\\[\nf(x) = \\frac{\\sin x}{x}\n\\]\nを考えます．この関数は \\(x - 0\\) で定義されていないですが\n\\[\n\\begin{align}\nf(x) = \\left\\{\\begin{array}{c}\n\\frac{\\sin x}{x} & (x\\neq 0)\\\\\n1 & (x = 0)\n\\end{array}\\right.\n\\end{align}\n\\]\nと \\(x = 0\\) で連続かつ微分可能になるように拡張することが出来ます．この拡張された関数を特にsinc関数と呼びます．\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Define the sinc function\ndef sinc(x):\n    return np.sinc(x / np.pi)\n\ndef inverse_x(x):\n    return 1/x\n\n# Generate x values\nx_vals = np.linspace(-10*np.pi, 10*np.pi, 400)\ny_vals = sinc(x_vals)\n\n# Plot the sinc function\nplt.figure(figsize=(8, 6))\nplt.plot(x_vals, y_vals, label=r'$f(x) = \\frac{\\sin(x)}{x}$')\nplt.plot(x_vals, inverse_x(x_vals), label=r'$f(x) = \\frac{1}{x}$')\nplt.xticks(np.arange(-10*np.pi, 11*np.pi, np.pi), \n           [r'$-10\\pi$', r'$-9\\pi$', r'$-8\\pi$', r'$-7\\pi$', r'$-6\\pi$', r'$-5\\pi$', r'$-4\\pi$', r'$-3\\pi$', r'$-2\\pi$', r'$-\\pi$', '0', r'$\\pi$', r'$2\\pi$', r'$3\\pi$', r'$4\\pi$', r'$5\\pi$', r'$6\\pi$', r'$7\\pi$', r'$8\\pi$', r'$9\\pi$', r'$10\\pi$'])\nplt.axhline(0, color='black',linewidth=0.5)\nplt.axvline(0, color='black',linewidth=0.5)\nplt.title(r'Plot of $f(x) = \\frac{\\sin(x)}{x}$')\nplt.xlabel('x')\nplt.ylabel('f(x)')\nplt.ylim(-1.1, 1.1)\nplt.legend()\nplt.grid(True)\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 3\n\n\n\n ▶  \\(x = 0\\)における連続性の証明\n\n\n\n\n\n\n\nNoteProof\n\n\n\n\n\n偶関数の性質\n\\[\n\\frac{\\sin x}{x} = \\frac{\\sin -x}{-x}\n\\]\nより \\(0 &lt; x \\to +0\\) の場合を考えます．xy座標上に \\(O = (0, 0)，A = (1, 0)，B = (\\cos x, \\sin x)，C = (1, \\tan x)\\) という点をとったとき，\n\\[\n\\text{三角形}OAB \\subset \\text{扇形}OAB \\subset \\text{三角形}OAC\n\\]\nつまり\n\\[\n\\text{三角形}OAB\\text{の面積} \\leq \\text{扇形}OAB\\text{の面積} \\leq  \\text{三角形}OAC\n\\]\n従って，\n\\[\n\\begin{align}\n\\frac{\\sin x}{2} \\leq \\frac{x}{2} &lt; \\frac{\\tan x}{2}\n\\end{align}\n\\]\n両辺 を \\(\\sin ⁡x\\) で割って逆数をとると\n\\[\n\\begin{align}\n\\cos x \\leq \\frac{x\\sin x}{x} &lt; 1\n\\end{align}\n\\]\nここで，\\(x\\to +0\\) とすると，\\(\\cos x \\to 1\\) となり，はさみうちの原理より\n\\[\n\\lim_{x\\to+0}\\frac{\\sin x}{x} = 1\n\\]\n\n\n\n ▶  \\(x = 0\\)における微分可能性の証明\n\n\n\n\n\n\n\nNoteProof\n\n\n\n\n\n\\[\n\\begin{align}\n\\cos x \\leq \\frac{x\\sin x}{x} &lt; 1\n\\end{align}\n\\]\nが \\(-\\frac{\\pi}{2} \\leq x \\leq \\frac{\\pi}{2}\\) で成り立つので\n\\[\n0=\\lim_{x\\to0}\\frac{\\cos(x)-1}{x}\\le\\lim_{x\\to0}\\frac{\\frac{\\sin(x)}x-1}{x-0}\\le0\n\\]\n\\[\n\\begin{align}\n\\lim_{x\\to0}\\frac{1-\\cos(x)}x\n&=\\lim_{x\\to0}\\frac1x\\frac{\\sin^2(x)}{1+\\cos(x)}\\\\\n&=\\lim_{x\\to0}\\frac{\\sin(x)}x\\lim_{x\\to0}\\frac{\\sin(x)}{1+\\cos(x)}\\\\[6pt]\n&=1\\cdot0 = 0\n\\end{align}\n\\]\n従って，はさみうちの原理より \\(f^\\prime(0) = 0\\)"
  },
  {
    "objectID": "posts/2025-02-03-continuous-function/index.html#連続関数",
    "href": "posts/2025-02-03-continuous-function/index.html#連続関数",
    "title": "関数の連続性",
    "section": "",
    "text": "変数 \\(x\\) が限りなく \\(a\\) に近づくとき，\\(f(x)\\) も \\(f(a)\\) に近づくならば，\\(f(x)\\) は \\(x=a\\) において連続である，といいます．つまり，\n\\[\nx\\to a \\text{ ならば } f(x) \\to f(a)\n\\]\n\nDef: \\(\\epsilon\\)-\\(\\delta\\) 論法的連続性 \n任意の \\(\\epsilon &gt;0\\) に対して，ある \\(\\delta &gt; 0\\) が存在して，\n\\[\n\\vert x - a \\vert &lt; \\delta \\Rightarrow \\vert f(x) - f(a)\\vert &lt; \\epsilon\n\\]\nを満たすとき，\\(x=a\\) において \\(f(x)\\) は連続であるという．\n\n\nExample 1 \n\\(f(x) = \\sqrt{x}\\) について，\\(a &gt; 0\\) で連続であることを以下示します．\n\\[\n\\begin{align}\n\\vert \\sqrt{x} - \\sqrt{a} \\vert\n    &= \\left\\vert\\frac{(\\sqrt{x} - \\sqrt{a})(\\sqrt{x} + \\sqrt{a})}{\\sqrt{x}+\\sqrt{a}}\\right\\vert\\\\\n    &= \\left\\vert\\frac{x - a}{\\sqrt{x}+\\sqrt{a}}\\right\\vert\\\\\n    &\\leq \\left\\vert\\frac{x - a}{\\sqrt{a}}\\right\\vert\n\\end{align}\n\\]\nここで，\\(\\vert x - a\\vert &lt; \\delta(\\epsilon) = \\epsilon\\sqrt{a}\\) と定めると\n\\[\n\\vert x - a\\vert &lt; \\delta(\\epsilon) \\Rightarrow \\vert \\sqrt{x} - \\sqrt{a}\\vert &lt; \\epsilon\n\\]\n\n\n\nExample 2 : 三角関数の連続性 \n\\(x = a + h\\) とおくと，和積の公式を用いて\n\\[\n\\begin{align}\n\\vert \\sin(x) - \\sin(a) \\vert\n    &= 2\\left\\vert \\cos\\frac{x+a}{2}\\sin\\frac{x-a}{2} \\right\\vert\\\\\n    &= 2\\left\\vert \\cos\\left(a + \\frac{h}{2}\\right)\\sin\\frac{h}{2} \\right\\vert\\\\\n    &\\leq 2\\left\\vert\\frac{h}{2}\\right\\vert \\cdot 1\\\\\n    &=\\vert h \\vert\n\\end{align}\n\\]\n\\(\\cos x = \\sin\\left(x + \\frac{\\pi}{2}\\right)\\) であるので，\\(\\sin x\\) が連続であるならば, \\(\\cos x\\) も連続．\n\n\n\n\nTheorem 1  : 連続関数の定数倍\n\\(f(x)\\) は \\(x=a\\) で連続であるとします．このとき，定数 \\(c\\) を用いた \\(cf(x)\\) も \\(x=a\\) にて連続となります．\n\n\n\n\n\n\n\n\n\nNoteProof\n\n\n\n\n\n仮定より\n\\[\n\\forall \\eta &gt; 0, \\exists \\delta(\\eta) &gt; 0, \\vert x - a\\vert &lt; \\delta(\\eta)\\Rightarrow\\vert f(x) - f(a)\\vert &lt; \\eta\n\\]\nこのとき，任意の \\(\\epsilon &gt; 0\\) に対して，\n\\[\n\\eta = \\frac{\\epsilon}{\\vert c \\vert} &gt;0\n\\]\nと対応させると，\n\\[\n\\forall \\epsilon &gt; 0, \\exists \\delta(\\epsilon) &gt; 0, \\vert x - a\\vert &lt; \\delta(\\epsilon)\\Rightarrow\\vert f(x) - f(a)\\vert &lt; \\frac{\\epsilon}{\\vert c \\vert }\n\\]\nつまり，\n\\[\n\\forall \\epsilon &gt; 0, \\exists \\delta(\\epsilon) &gt; 0, \\vert x - a\\vert &lt; \\delta(\\epsilon)\\Rightarrow \\vert c\\vert\\vert f(x) - f(a)\\vert &lt; \\epsilon\n\\]\nこれを変形すると\n\\[\n\\forall \\epsilon &gt; 0, \\exists \\delta(\\epsilon) &gt; 0, \\vert x - a\\vert &lt; \\delta(\\epsilon)\\Rightarrow \\vert cf(x) - cf(a)\\vert &lt; \\epsilon\n\\]\n\n\n\n\n\nTheorem 2 : 連続関数の和\n\n\\(f(x), g(x)\\) は \\(x=a\\) で連続であるとします．このとき，\\(f(x) + g(x)\\) も \\(x=a\\) にて連続となります．\n\n\n\n\n\n\n\n\n\nNoteProof\n\n\n\n\n\n仮定より\n\\[\n\\begin{align}\n\\vert x - a \\vert &lt; \\delta&\\Rightarrow \\vert f(x) - f(a)\\vert &lt; \\epsilon/2\\\\\n\\vert x - a \\vert &lt; \\eta&\\Rightarrow \\vert g(x) - g(a)\\vert &lt; \\epsilon/2\n\\end{align}\n\\]\nここで，\\(M = \\min(\\delta, \\eta)\\) とすると，\n\\[\n\\begin{align}\n\\vert x - a \\vert &lt; M&\\Rightarrow \\vert f(x) - f(a)\\vert &lt; \\epsilon/2\\\\\n\\vert x - a \\vert &lt; M&\\Rightarrow \\vert g(x) - g(a)\\vert &lt; \\epsilon/2\n\\end{align}\n\\]\nまた\n\\[\n\\begin{align}\n\\vert(f(x) - g(x)) - (f(a) + g(a))\n    &= \\vert(f(x) - f(a)) + (g(x) + g(a))\\vert\\\\\n    &\\leq \\vert(f(x) - f(a))\\vert + \\vert (g(x) + g(a))\\vert\n\\end{align}\n\\]\n従って，\\(\\vert x - a \\vert &lt; M\\) であるならば\n\\[\n\\begin{align}\n\\vert (g(x) + f(x)) - (g(a) + f(a))\\vert \\leq \\vert(f(x) - f(a))\\vert + \\vert (g(x) + g(a))\\vert &lt; \\epsilon\n\\end{align}\n\\]\n\n\n\n\n\nTheorem 3  : 連続関数の線型結合\n\\(f(x), g(x)\\) は \\(x=a\\) で連続であるとします．このとき，定数 \\(c_1, c_2\\)に対して \\(c_1f(x) + c_2g(x)\\) も \\(x=a\\) にて連続となります．\n\n\n\n\n\n\n\n\n\nNoteProof\n\n\n\n\n\n\\[\n\\begin{align}\n\\vert x - a \\vert &lt; \\delta&\\Rightarrow \\vert f(x) - f(a)\\vert &lt; \\frac{\\epsilon}{2\\vert c_1\\vert}\\\\\n\\vert x - a \\vert &lt; \\eta&\\Rightarrow \\vert g(x) - g(a)\\vert &lt; \\frac{\\epsilon}{2\\vert c_2\\vert}\n\\end{align}\n\\]\nとして，\\(M = \\min(\\delta, \\eta)\\) とすれば，上記と同様に連続性を示すことができます．\n\n\n\n\n\nTheorem 4  : 連続関数の積\n\\(f(x), g(x)\\) は \\(x=a\\) で連続であるとします．このとき，\\(f(x)g(x)\\) も \\(x=a\\) にて連続となります．\n\n\n\n\n\n\n\n\n\nNoteProof\n\n\n\n\n\n\\[\n\\vert x - a \\vert &lt; \\delta(1) \\Rightarrow \\vert f(x) - f(a)\\vert &lt; 1\n\\]\nとすると，\n\\[\n\\vert x - a \\vert &lt; \\delta(1) \\Rightarrow \\vert f(x) \\vert &lt; 1 + \\vert f(a) \\vert\n\\]\n\\(\\delta, \\eta\\) を以下のように定め，\n\\[\n\\begin{align}\n\\vert x - a \\vert &lt; \\delta &\\Rightarrow \\vert f(x) - f(a)\\vert &lt; \\frac{\\epsilon}{2(1 + \\vert f(a) \\vert + \\vert g(a) \\vert)}\\\\\n\\vert x - a \\vert &lt; \\eta &\\Rightarrow \\vert g(x) - g(a)\\vert &lt; \\frac{\\epsilon}{2(1 + \\vert f(a) \\vert + \\vert g(a) \\vert)}\n\\end{align}\n\\]\n\\[\n\\delta(\\epsilon) = \\min (\\delta(1), \\delta, \\eta)\n\\]\nとすると，\n\\[\n\\begin{align}\n\\vert x - a \\vert &lt; \\delta(\\epsilon)\n    \\Rightarrow &\\vert f(x)g(x) - f(a)g(a)\\vert\\\\[5pt]\n    &= \\vert f(x)(g(x) - g(a)) + g(a)(f(x) - f(a))\\vert\\\\[5pt]\n    &\\leq \\vert f(x)\\vert \\vert(g(x) - g(a))\\vert + \\vert g(a)\\vert\\vert(f(x) - f(a))\\vert\\\\[5pt]\n    &&lt; (1 + \\vert f(a) \\vert)\\frac{\\epsilon}{2(1 + \\vert f(a) \\vert + \\vert g(a) \\vert)} + \\vert g(a)\\vert \\frac{\\epsilon}{2(1 + \\vert f(a) \\vert + \\vert g(a) \\vert)}\\\\\n    &= \\epsilon\n\\end{align}\n\\]\nよって，連続性が示された．\n\n\n\n\n\nTheorem 5  連続関数の逆数 \n\\(f(x)\\) は \\(x=a\\) で連続であるとします．このとき，\\(f(a)\\neq 0\\) であるならば \\(1/f(x)\\) も \\(x=a\\) にて連続となります．\n\n\n\n\n\n\n\n\n\nNoteProof\n\n\n\n\n\n連続性の仮定より\n\\[\n\\vert x - a \\vert &lt; \\delta(\\vert f(a)/2\\vert) \\Rightarrow \\vert f(x) - f(a)\\vert &lt; \\frac{\\vert f(a)\\vert}{2}\n\\]\nとすると，\n\\[\n\\vert x - a \\vert &lt; \\delta(\\vert f(a)/2\\vert) \\Rightarrow \\frac{\\vert f(a)\\vert}{2} &lt; \\vert f(x)\\vert\n\\]\nこのとき，\n\\[\n\\begin{align}\n\\left\\vert \\frac{1}{f(x)} - \\frac{1}{f(a)} \\right\\vert\n    &= \\left\\vert \\frac{f(x) - f(a)}{f(x)f(a)} \\right\\vert\\\\\n    &&lt; \\left\\vert \\frac{f(x) - f(a)}{(f(a))^2 / 2} \\right\\vert\n\\end{align}\n\\]\n従って，\\(\\vert x - a \\vert &lt; \\eta \\Rightarrow \\vert f(x) - f(a)\\vert &lt; \\displaystyle\\frac{\\epsilon\\vert (f(a))^2\\vert}{2}\\) となるような \\(\\eta\\) を用いて，\n\\[\n\\delta(\\epsilon) = \\min(\\delta(\\vert f(a)/2\\vert), \\eta)\n\\]\nとすれば\n\\[\n\\vert x - a \\vert &lt; \\delta(\\epsilon) \\Rightarrow \\left\\vert \\frac{1}{f(x)} - \\frac{1}{f(a)} \\right\\vert &lt; \\epsilon\n\\]\n\n\n\n\n\n点 \\(a\\) における極限を考えるとき，\n\n\\(x\\) が増大しつつ \\(a\\) に（左側から）近づく, \\(\\lim_{x\\to a-0}\\)\n\\(x\\) が減少しつつ \\(a\\) に（右側から）近づく, \\(\\lim_{x\\to a+0}\\)\n\nそれぞれの場合を分けて取り扱うことがあります．\n\nExample 3 \n\\(f(x) = \\tan x\\) について，\\(x = \\pi/2\\) における極限を考えてみます．\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport sympy as sy\n\nx = sy.Symbol('x')\nf = sy.tan(x)\n\nx_vals = np.linspace(-np.pi/2+1e-6, np.pi, 400)\ny_vals = np.tan(x_vals)\n\nplt.figure(figsize=(8, 6))\nplt.plot(x_vals, y_vals, label=r'$f(x) = \\tan(x)$')\nplt.ylim(-10, 10)\nplt.xticks([-np.pi/2, 0, np.pi/2, np.pi], [r'$-\\frac{\\pi}{2}$', '0', r'$\\frac{\\pi}{2}$', r'$\\pi$'])\nplt.axvline(np.pi/2, color='r', linestyle='--', label=r'$x = \\frac{\\pi}{2}$')\nplt.axhline(0, color='black',linewidth=0.5)\nplt.axvline(0, color='black',linewidth=0.5)\nplt.title(r'Plot of $f(x) = \\tan(x)$ around $x = \\frac{\\pi}{2}$')\nplt.xlabel('x')\nplt.ylabel('f(x)')\nplt.legend()\nplt.grid(True)\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 1\n\n\n\n上記の図のように，\n\\[\n\\begin{align}\n\\lim_{x\\to \\pi/2+0} \\tan x &= -\\infty\\\\\n\\lim_{x\\to \\pi/2-0} \\tan x &= \\infty\n\\end{align}\n\\]\n実際に，sympy で確認してみると\n\n# DO NOT USE np.pi\nprint(f\"左極限: {sy.limit(sy.tan(x), x, sy.pi/2, '-')}\")\nprint(f\"右極限: {sy.limit(sy.tan(x), x, sy.pi/2, '+')}\")\n\n左極限: oo\n右極限: -oo\n\n\n\n\n ▶  右連続と左連続\n\\[\n\\begin{align}\nf(a) &= \\alpha\\\\[5pt]\n\\lim_{x\\to a-0} f(x) &= \\alpha\\\\\n\\lim_{x\\to a+0} f(x) &= \\beta \\neq \\alpha\n\\end{align}\n\\]\nのとき，\\(f(x)\\) は \\(x = a\\) において左連続といいます．\n\\(f(x)\\) が閉区間 \\([a, b]\\) において定義されているとき，\n\n\\(x=a\\) においては右連続\n\\(x=b\\) においては左連続\n\nであることを意味します．開区間 \\((a, b)\\) において定義されているとき，\\(f(a+0)\\) が確定ならば，それを \\(f(a)\\) として定義域を \\([a, b)\\) 区間に拡張すると \\(f(x)\\) は \\(x=a\\) において右連続になります．\n一方，\\((0, \\infty)\\) 区間で定義された関数 \\(\\displaystyle f(x) = \\frac{1}{x}\\) は開区間では連続ですが，\\(x = 0\\) のときは定義されません．このとき，\\(f(0) = 0\\) として定義域を \\([0, \\infty)\\) に拡張すると，\\(x=0\\) で連続な関数にはなりませんし，\\(f(0)\\) をどんな値にしたとしても，\\(x=0\\) の近傍において, \\(f(x)\\) はいくらでも大きくなってしまうので，連続な関数にはなりません．\n\n📘 REMARKS \n\n開区間 \\((a, b)\\) で定義された連続な関数が，開区間 \\([a, b]\\) の連続な関数に拡張できるとは限らない\n\n\n\nExample 4  : 右連続関数と累積分布関数 \n離散確率変数 \\(X\\sim\\operatorname{Bin}(5, 1/3)\\) を考えます．離散確率変数の累積分布関数 \\(F(x)\\) は\n\\[\nF(x) = \\operatorname{P}(X \\leq x) = \\sum_{y\\leq x}p(y) \\qquad p(y): \\text{確率関数}\n\\]\nと定義されるので，\\(F(x)\\) は右側連続となります．実際に\n\nCode\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom scipy.stats import binom\n\nn, p = 5, 1 / 3\nx = np.arange(0, 6)\ncdf = binom.cdf(x, n, p)\n\nfig, ax = plt.subplots(1, 1)\nax.hlines(cdf, x, x + 1, color=\"gray\")\nax.step(x, cdf, where=\"post\", color=\"gray\", linestyle=\"dotted\")\nax.plot(x, cdf, \"o\", color=\"gray\")\nax.scatter(x[:-1] + 1, cdf[:-1], marker=\"$\\u25EF$\", alpha=0.5, color=\"gray\")\nax.set_xlabel(\"x\")\nax.set_ylabel(\"F(x)\")\nax.set_title(\"CDF of Binomial Distribution (n=5, p=1/3)\")\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 2\n\n\n\nこのとき，確率関数は\n\\[\np(x) = F(x) - \\lim_{x_n\\to x-0}F(x_n)\n\\]\nとすることで計算することが出来ます．一方，\\(F(x) = \\operatorname{P}(X &lt; x)\\) と定義すると左連続となります．\n\n\n\n\n\n\\[\nf(x) = \\frac{\\sin x}{x}\n\\]\nを考えます．この関数は \\(x - 0\\) で定義されていないですが\n\\[\n\\begin{align}\nf(x) = \\left\\{\\begin{array}{c}\n\\frac{\\sin x}{x} & (x\\neq 0)\\\\\n1 & (x = 0)\n\\end{array}\\right.\n\\end{align}\n\\]\nと \\(x = 0\\) で連続かつ微分可能になるように拡張することが出来ます．この拡張された関数を特にsinc関数と呼びます．\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Define the sinc function\ndef sinc(x):\n    return np.sinc(x / np.pi)\n\ndef inverse_x(x):\n    return 1/x\n\n# Generate x values\nx_vals = np.linspace(-10*np.pi, 10*np.pi, 400)\ny_vals = sinc(x_vals)\n\n# Plot the sinc function\nplt.figure(figsize=(8, 6))\nplt.plot(x_vals, y_vals, label=r'$f(x) = \\frac{\\sin(x)}{x}$')\nplt.plot(x_vals, inverse_x(x_vals), label=r'$f(x) = \\frac{1}{x}$')\nplt.xticks(np.arange(-10*np.pi, 11*np.pi, np.pi), \n           [r'$-10\\pi$', r'$-9\\pi$', r'$-8\\pi$', r'$-7\\pi$', r'$-6\\pi$', r'$-5\\pi$', r'$-4\\pi$', r'$-3\\pi$', r'$-2\\pi$', r'$-\\pi$', '0', r'$\\pi$', r'$2\\pi$', r'$3\\pi$', r'$4\\pi$', r'$5\\pi$', r'$6\\pi$', r'$7\\pi$', r'$8\\pi$', r'$9\\pi$', r'$10\\pi$'])\nplt.axhline(0, color='black',linewidth=0.5)\nplt.axvline(0, color='black',linewidth=0.5)\nplt.title(r'Plot of $f(x) = \\frac{\\sin(x)}{x}$')\nplt.xlabel('x')\nplt.ylabel('f(x)')\nplt.ylim(-1.1, 1.1)\nplt.legend()\nplt.grid(True)\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 3\n\n\n\n ▶  \\(x = 0\\)における連続性の証明\n\n\n\n\n\n\n\nNoteProof\n\n\n\n\n\n偶関数の性質\n\\[\n\\frac{\\sin x}{x} = \\frac{\\sin -x}{-x}\n\\]\nより \\(0 &lt; x \\to +0\\) の場合を考えます．xy座標上に \\(O = (0, 0)，A = (1, 0)，B = (\\cos x, \\sin x)，C = (1, \\tan x)\\) という点をとったとき，\n\\[\n\\text{三角形}OAB \\subset \\text{扇形}OAB \\subset \\text{三角形}OAC\n\\]\nつまり\n\\[\n\\text{三角形}OAB\\text{の面積} \\leq \\text{扇形}OAB\\text{の面積} \\leq  \\text{三角形}OAC\n\\]\n従って，\n\\[\n\\begin{align}\n\\frac{\\sin x}{2} \\leq \\frac{x}{2} &lt; \\frac{\\tan x}{2}\n\\end{align}\n\\]\n両辺 を \\(\\sin ⁡x\\) で割って逆数をとると\n\\[\n\\begin{align}\n\\cos x \\leq \\frac{x\\sin x}{x} &lt; 1\n\\end{align}\n\\]\nここで，\\(x\\to +0\\) とすると，\\(\\cos x \\to 1\\) となり，はさみうちの原理より\n\\[\n\\lim_{x\\to+0}\\frac{\\sin x}{x} = 1\n\\]\n\n\n\n ▶  \\(x = 0\\)における微分可能性の証明\n\n\n\n\n\n\n\nNoteProof\n\n\n\n\n\n\\[\n\\begin{align}\n\\cos x \\leq \\frac{x\\sin x}{x} &lt; 1\n\\end{align}\n\\]\nが \\(-\\frac{\\pi}{2} \\leq x \\leq \\frac{\\pi}{2}\\) で成り立つので\n\\[\n0=\\lim_{x\\to0}\\frac{\\cos(x)-1}{x}\\le\\lim_{x\\to0}\\frac{\\frac{\\sin(x)}x-1}{x-0}\\le0\n\\]\n\\[\n\\begin{align}\n\\lim_{x\\to0}\\frac{1-\\cos(x)}x\n&=\\lim_{x\\to0}\\frac1x\\frac{\\sin^2(x)}{1+\\cos(x)}\\\\\n&=\\lim_{x\\to0}\\frac{\\sin(x)}x\\lim_{x\\to0}\\frac{\\sin(x)}{1+\\cos(x)}\\\\[6pt]\n&=1\\cdot0 = 0\n\\end{align}\n\\]\n従って，はさみうちの原理より \\(f^\\prime(0) = 0\\)"
  },
  {
    "objectID": "posts/2025-09-05-samba/index.html",
    "href": "posts/2025-09-05-samba/index.html",
    "title": "Sambaの設定とiPad連携",
    "section": "",
    "text": "Definition 1 Samba\n\nLinuxホストをMicrosoftネットワークに参加できるようにするソフトウェア\n\n\nSambaを使うことで，次のような機能が実現できます．\n\n\n\n\n\n\n\n\n\nカテゴリ\n機能\n説明\n\n\n\n\nファイル共有\nディレクトリ共有\nWindows から Linux/Unix のディレクトリにアクセス可能．読み取り専用／書き込み可の権限設定が可能・\n\n\n\nファイルアクセス制御\nユーザー・グループごとのアクセス権を設定可能。\n\n\nプリンタ共有\nプリンタ共有\nLinux/Unix に接続されたプリンタを Windows から利用可能．\n\n\n\n複数ユーザー対応\n複数ユーザーでの共有プリンタ環境を構築可能．\n\n\n\nプリンタドライバーの配布\nSamba サーバに Windows 用プリンタドライバーを置いておくと，クライアント側で共有プリンタに接続するだけで自動インストールできる\n\n\nADメンバーサーバー\nドメイン参加\nActive Directoryを構成するメンバーサーバーになることが可能\n\n\n\nドメインコントローラ\nSamba を AD 互換ドメインコントローラとして利用可能．ユーザー認証・グループ管理・ポリシー管理が可能．\n\n\n\nKerberos 認証対応\nシングルサインオン（SSO）で共有アクセスが可能\n\n\nバックアップ・サーバ\nファイルサーバ機能\nネットワーク経由でバックアップやファイル共有が可能．\n\n\n\n自動バックアップ\nrsync や cron と組み合わせて自動バックアップが可能．\n\n\nホームディレクトリ提供\nユーザーごとのホームディレクトリ\nWindows ユーザーごとに自動マウント可能．\n\n\nアクセスログ・監査\nログ取得\nどのユーザーがいつアクセスしたかのログを取得可能。監査やセキュリティ対策に活用可能。"
  },
  {
    "objectID": "posts/2025-09-05-samba/index.html#sambaでできること",
    "href": "posts/2025-09-05-samba/index.html#sambaでできること",
    "title": "Sambaの設定とiPad連携",
    "section": "",
    "text": "Definition 1 Samba\n\nLinuxホストをMicrosoftネットワークに参加できるようにするソフトウェア\n\n\nSambaを使うことで，次のような機能が実現できます．\n\n\n\n\n\n\n\n\n\nカテゴリ\n機能\n説明\n\n\n\n\nファイル共有\nディレクトリ共有\nWindows から Linux/Unix のディレクトリにアクセス可能．読み取り専用／書き込み可の権限設定が可能・\n\n\n\nファイルアクセス制御\nユーザー・グループごとのアクセス権を設定可能。\n\n\nプリンタ共有\nプリンタ共有\nLinux/Unix に接続されたプリンタを Windows から利用可能．\n\n\n\n複数ユーザー対応\n複数ユーザーでの共有プリンタ環境を構築可能．\n\n\n\nプリンタドライバーの配布\nSamba サーバに Windows 用プリンタドライバーを置いておくと，クライアント側で共有プリンタに接続するだけで自動インストールできる\n\n\nADメンバーサーバー\nドメイン参加\nActive Directoryを構成するメンバーサーバーになることが可能\n\n\n\nドメインコントローラ\nSamba を AD 互換ドメインコントローラとして利用可能．ユーザー認証・グループ管理・ポリシー管理が可能．\n\n\n\nKerberos 認証対応\nシングルサインオン（SSO）で共有アクセスが可能\n\n\nバックアップ・サーバ\nファイルサーバ機能\nネットワーク経由でバックアップやファイル共有が可能．\n\n\n\n自動バックアップ\nrsync や cron と組み合わせて自動バックアップが可能．\n\n\nホームディレクトリ提供\nユーザーごとのホームディレクトリ\nWindows ユーザーごとに自動マウント可能．\n\n\nアクセスログ・監査\nログ取得\nどのユーザーがいつアクセスしたかのログを取得可能。監査やセキュリティ対策に活用可能。"
  },
  {
    "objectID": "posts/2025-09-05-samba/index.html#sambaのインストール",
    "href": "posts/2025-09-05-samba/index.html#sambaのインストール",
    "title": "Sambaの設定とiPad連携",
    "section": "Sambaのインストール",
    "text": "Sambaのインストール\napt経由で samba パッケージをインストールします\n# install\n% sudo apt install -y samba\n\n# version check\n% samba --version\nVersion 4.19.5-Ubuntu\nsamba は，ファイルサーバー，プリントサーバー，ユーザー管理を担うsmbdデーモン，名前解決を担うnmbdデーモンから構成されます． ファイヤーウォールを使っている場合は，Sambaを利用できるように次のような設定をします\n% sudo ufw allow samba\nRule added\nRule added (v6)\ntailscaleを導入している場合は，tailscaleについてのファイヤーウォールを実施するだけでOKです．\n% sudo ufw allow in on tailscale0\n\n\n\n\n\n\nNoteSamba運用上の注意\n\n\n\n\nSamba サーバーは基本的に LAN 内での運用を前提(=企業や家庭内ネットワークなど，閉じたネットワークでの利用が基本)\nインターネットサーバー上での動作は推奨されない\nADが使えるとはいえ，Windows Serverで実現できるすべての機能が実装されているわけではない\n\n\n\n各デーモンに対応する systemctl サービス\n\n\n\n\n\n\n\n\n\n構成要素\n担当機能\nsystemctl サービス名\n\n\n\n\nsmbd\nファイル共有・プリント共有・ユーザー認証\nsmbd\n\n\nnmbd\n名前解決\nnmbd"
  },
  {
    "objectID": "posts/2025-09-05-samba/index.html#sambaの制御",
    "href": "posts/2025-09-05-samba/index.html#sambaの制御",
    "title": "Sambaの設定とiPad連携",
    "section": "Sambaの制御",
    "text": "Sambaの制御\n\n\n\n\n\n\n\n\n\nサービス / デーモン\n役割\nコマンド\n\n\n\n\nsmbd\nファイル共有・プリンタ共有・ユーザー認証\n起動: sudo systemctl start smbd\n\n\n\n\n停止: sudo systemctl stop smbd\n\n\n\n\n再起動: sudo systemctl restart smbd\n\n\n\n\n自動起動有効: sudo systemctl enable smbd\n\n\n\n\n自動起動無効: sudo systemctl disable smbd\n\n\n\n\n状態確認: sudo systemctl status smbd\n\n\nnmbd\n名前解決\n起動: sudo systemctl start nmbd\n\n\n\n\n停止: sudo systemctl stop nmbd\n\n\n\n\n再起動: sudo systemctl restart nmbd\n\n\n\n\n自動起動有効: sudo systemctl enable nmbd\n\n\n\n\n自動起動無効: sudo systemctl disable nmbd\n\n\n\n\n状態確認: sudo systemctl status nmbd\n\n\nsamba\nSamba AD DC サービス（AD ドメインコントローラ運用時）\n起動: sudo systemctl start samba\n\n\n\n\n停止: sudo systemctl stop samba\n\n\n\n\n再起動: sudo systemctl restart samba\n\n\n\n\n自動起動有効: sudo systemctl enable samba\n\n\n\n\n自動起動無効: sudo systemctl disable samba\n\n\n\n\n状態確認: sudo systemctl status samba"
  },
  {
    "objectID": "posts/2025-09-05-samba/index.html#sambaの設定",
    "href": "posts/2025-09-05-samba/index.html#sambaの設定",
    "title": "Sambaの設定とiPad連携",
    "section": "Sambaの設定",
    "text": "Sambaの設定\n\n\n\n\n\n\nNoteSamba設定の基本\n\n\n\n\nSambaの主な設定は /etc/samba/smb.conf に記述する\nsmb.conf は大きく分けて [Global Settings] と [Share Definitions] の２つから構成される\n[Global Settings]: Sambaサーバーの全般的な設定をする部分．この部分を変更した場合はSambaサーバーの再起動が必要\n[Share Definitions]: ファイル共有やプリンター共有を設定する部分\n\n\n\n/etc/samba/smb.conf を編集するときは sudo cp -a smb.conf smb.conf.default なり .bak 拡張子を用いてバックアップをしておくと安全です．\nsmb.conf Syntax\nparameter = value\n# commentout line begins with # or ;\nglobalの設定項目\n\n\n\n\n\n\n\n\n\n項目\n説明\n例\n\n\n\n\nworkgroup\nWindows ネットワーク上のワークグループ名を指定\nWORKGROUP\n\n\nserver string\nサーバーの説明文（ネットワークブラウザに表示される）\nSamba Server\n\n\nlog file\nログファイルの出力場所\n/var/log/samba/log.%m\n\n\nmax log size\nログファイルの最大サイズ (KB)\n1000\n\n\nserver role\nサーバーの役割．ファイルサーバーとして使う場合はstandalone server\nstandalone server / member server / active directory domain controller\n\n\npassdb backend\nユーザー認証DBの指定\ntdbsam / ldapsam\n\n\nunix password sync\nSambaユーザーアカウントのpassword変更をLinuxユーザーアカウントのpasswordにも反映\nyes / no\n\n\npasswd program\nSamba がパスワード変更要求を受けた際に，実行するコマンドを指定する\n/usr/bin/passwd %u\n\n\npasswd chat\npasswd program とやり取りする際の「対話プロンプトと応答パターン」を定義する\n*New*password* %n\\n *Retype*new*password* %n\\n *password*updated*successfully*\n\n\npam password change\n有効にすると，password変更にpasswd program に指定したコマンドではなくPAMを利用する\nyes / no\n\n\n\n\nShare Deinitionの設定項目\n\n\n\n\n\n\n\n\n\n項目\n説明\n例\n\n\n\n\npath\n実際に公開するディレクトリの絶対パス\n/srv/samba/public\n\n\ncomment\nネットワークブラウザに表示される説明文\nPublic Share\n\n\nbrowseable\nネットワークブラウザに表示するか\nyes / no\n\n\nread only\n読み取り専用にするか\nyes / no\n\n\nwritable\nread only の逆指定（同義語）\nyes\n\n\nguest ok\n認証なしでアクセスできるか\nyes / no\n\n\nvalid users\nアクセスを許可するユーザー/グループ\n%S とすればhome directoryのユーザーのみが自身のhome directoryにアクセスできる\n\n\ninvalid users\nアクセスを拒否するユーザー/グループ\n@nogroup user2\n\n\ncreate mask\n新規ファイル作成時のパーミッションマスク\n0644\n\n\ndirectory mask\n新規ディレクトリ作成時のパーミッションマスク\n0755\n\n\npublic\nguest ok の別名\nyes / no\n\n\nlocking\nファイルロックの使用有無\nyes\n\n\nprintable\nプリンタ共有として扱うか\nno（通常のフォルダ共有なら）\n\n\n\n\n構文チェック\ntestparm コマンドを用いることでconfigファイルの構文チェックをすることができます\n% testparm -s\nLoad smb config files from /etc/samba/smb.conf\nLoaded services file OK.\n...\n\n\n\n\n\n\n\n\n\nオプション\n説明\n例 / 補足\n\n\n\n\n-s\n短い形式で表示（冗長な情報を省略し、主要な設定のみを出力）\ntestparm -s\n\n\n-v\n詳細表示（全設定、コメントやデフォルト値も含む）\ntestparm -v"
  },
  {
    "objectID": "posts/2025-09-05-samba/index.html#共有の作成",
    "href": "posts/2025-09-05-samba/index.html#共有の作成",
    "title": "Sambaの設定とiPad連携",
    "section": "共有の作成",
    "text": "共有の作成\niPadからtailscale経由でアクセス可能な共有ディレクトリを指定したいと思います．\n[server-hdd]\ncomment = 2TB sized hdd\npath = /media/kirby/DATA/\nbrowsable = yes\nwritable = yes\nguest ok = no\nprintable = no\nvalid users = dedede kirby\nと指定すると server-hdd を共有名として path を公開することができます．設定が完了したら\n% sudo systemctl restart smbd\nを実施します．\niPadからのアクセス設定\nTailscaleをつないでいるならば自動的に名前解決してくれます．手順は以下です．\n\nTailscale管理画面から共有設定したサーバーの名前を調べる(例: dsserver)\nファイル から右上の３点マークの設定を開く\n「サーバーへ接続」を開き以下の書式で入力する\n\nsmb://dsserver/\nその後，Sambaユーザー名とSambaパスワード等が要求されますが，それは smb.conf の設定に合わせて入力してください．\nonly readable errorが出る場合\n原因としてストーレージのフォーマットにiOSが対応していないことが考えられます． iOSの標準ファイルシステムサポートは APFS / HFS+ / FAT32 / exFAT に限られ，NTFSは基本的には読み取り専用になってしまいます．\nマウントしてもread-onlyの場合は，ファイルシステムのフォーマットを確認してみてください． もし，NTFSであるならば中身を退避して，サーバー側でフォーマットを以下のコマンドで書き換えてしまいます\n$ sudo mkfs.exfat -n &lt;任意の名前&gt; /dev/sda1\nその後，サーバー側で再度以下のコマンドでmountを実施し，sambaの設定をすればOKです\nsudo mount -t exfat -o uid=1000,gid=1000,fmask=000,dmask=000 /dev/sda1 &lt;mount-point-path&gt;\n\n\n\n\n\n\nWarningexfatの問題点\n\n\n\n\nモバイルを含む複数のOSでreadable and writableで使用するならexFAT のほうが取り回しは効きます\n一方，ジャーナル機能やファイル圧縮，暗号化への対応はされていないので，セキュリティ面を重視するならば利用は控えたほうが良いです"
  },
  {
    "objectID": "posts/2025-09-05-samba/index.html#nautilusでsamba共有フォルダをmountする",
    "href": "posts/2025-09-05-samba/index.html#nautilusでsamba共有フォルダをmountする",
    "title": "Sambaの設定とiPad連携",
    "section": "NautilusでSamba共有フォルダをmountする",
    "text": "NautilusでSamba共有フォルダをmountする\n基本的にはiPadでの設定と同じ手順です\nsection\nTailscaleをつないでいるならば自動的に名前解決してくれます．手順は以下です．\n\nTailscale管理画面から共有設定したサーバーの名前を調べる(例: dsserver)\nNautilusを開く\n+ Other Locations をクリックし，以下の書式でconnection設定を行う\n\nsmb://dsserver/\nその後，Sambaユーザー名とSambaパスワード等が要求されますが，それは smb.conf の設定に合わせて入力する．\n\nVSCodeでフォルダの中身を編集する\n一度，Nautilus経由でSamba共有フォルダへのアクセス設定すると，GVfs が /run/user/&lt;userid&gt;/gvfs/ 以下に次のような仮想ディレクトリを作成します：\n/run/user/1000/gvfs/smb-share:server=&lt;server-name&gt;,share=&lt;share-folder-name&gt;/\nこれはFUSE(Filesystem in Userspace)経由のマウントなので，GVfsに非対応のコマンドラインツールでは直接編集できない場合があります． Samba共有フォルダを対象にCLI操作なり開発をしたい場合は ~/Desktop/ などの通常のマウントポイントにマウントするか シンボリックリンク（ln -s） で操作できるようにするという選択肢があります．\nGVfsのマウントはセッションごとに作られるため，シンボリックリンクでは動作が不安定になる可能性がありますが，一時的なそうなの場合は十分です．\nシンボリックリンクの作り方\nデスクトップの project フォルダをクリックすると Samba 共有へ飛ぶようするには以下のスクリプトを実行します：\nln -s /run/user/1000/gvfs/smb-share:server=fileserver,share=project ~/Desktop/project\ncifs mountの実施\nとあるPATH上に credential情報を格納したファイル(例: .cifs-credentials)を以下のように設定します\nusername=hoshino-kirby\npassword=pupupuland\n上記はSambaで設定したユーザー情報です．これを/etc/.cifs-credentials に格納した場合， 以下のコマンドでSamba共有フォルダを通常のマウントポイント(例: ~/Desktop/sandbox/)にマウントすることができます\n$ sudo mount -t cifs //&lt;server-global-ip&gt;/&lt;samba foldaname&gt;/&lt;path&gt; ~/Desktop/sandbox/ \\\n-o credentials=/etc/.cifs-credentials,iocharset=utf8,uid=&lt;uid&gt;,gid=&lt;gid&gt;,vers=3.0\n\n\n\n\n\n\nNoteRemarks\n\n\n\n\nuidとgidはクライアント側のvalueを入力します．確認したい場合は id コマンドを活用してください．\n-13 エラーコードを履く場合，sudo apt install cifs-utils を実行してから再度試してください"
  },
  {
    "objectID": "posts/2025-09-05-samba/index.html#appendix-microsoftネットワーク",
    "href": "posts/2025-09-05-samba/index.html#appendix-microsoftネットワーク",
    "title": "Sambaの設定とiPad連携",
    "section": "Appendix: Microsoftネットワーク",
    "text": "Appendix: Microsoftネットワーク\nMicrosoftネットワークは「ワークグループ」という基本単位でネットワークに参加するPCを論理的にまとめて管理しています． Windowsコンピューターでは，所属するワークグループ名を設定するだけで，そのワークグループへ参加することができます．\nワークグループの管理方式\nワークグループ自体は分散型管理が基本で，ユーザーアカウントやパスワードをそれぞれのコンピューターで管理します．もう一つの方法として， ドメインネットワークを利用したドメインコントローラーというサーバーによる集中管理する方法もあります．\n\n\n\n\n\n\n\n\n\n項目\nワークグループ（分散型）\nドメイン（中央管理）\n\n\n\n\n管理方式\n分散型\n集中管理型\n\n\nユーザー管理\n各PCごと\nドメインコントローラー(DC)で一元管理\n\n\n規模\n小規模\n中～大規模\n\n\n必要設備\nPCのみ\nDCサーバー必要\n\n\n\n\nドメインネットワークを利用する場合は以下の手順で認証が行われます\n\nユーザーのPCがシステム起動するとき「ドメインログイン」を行い，その認証情報がDCに送られる\nDCがユーザー名とパスワードを照合し，認証を行う\nDCによる認証をパスすると，ドメインネットワークへのアクセスが許可される\n\nドメインネットワークでは，一度認証をパスすれば，ドメイン内のサーバーへアクセスする際，個々に認証をする必要はありません．そのため，大規模なネットワークを運用する場合に便利な機能です．\n\n\n\n\n\n%%{init: {\"theme\":\"default\"}}%%\narchitecture-beta\n    group wg(cloud)[Workgroup]\n\n    service pc1(server)[PC1] in wg\n    service pc2(server)[PC2] in wg\n    service pc3(server)[PC3] in wg\n    service pc4(server)[PC4] in wg\n\n    pc1:B -- T:pc2\n    pc2:L -- R:pc3\n    pc1:R -- L:pc3\n    pc3:T -- B:pc4\n    pc4:R -- L:pc1\n    pc4:B -- T:pc2\n\n    group domain(cloud)[Domain]\n\n    service dc(database)[Domain Controller] in domain\n    service dpc1(server)[PC5] in domain\n    service dpc2(server)[PC6] in domain\n    service dpc3(server)[PC7] in domain\n\n    dpc1:B -- T:dc\n    dpc2:L -- R:dc\n    dpc3:T -- B:dc\n\n\n\n\n\n\nアクティブディレクトリ（Active Directory, AD）\n\nDefinition 2 アクティブディレクトリ\n\nユーザーやグループなどのリソースを一元管理するディレクトリサービス\nディレクトリアクセスプロトコルとしてLDAPを利用\nホスト名の名前解決にDNSを利用\n認証システムにKerberosを利用"
  },
  {
    "objectID": "posts/2025-03-05-addition-theorem/index.html",
    "href": "posts/2025-03-05-addition-theorem/index.html",
    "title": "三角関数の加法定理",
    "section": "",
    "text": "Theorem 1 : 加法定理 \n\\[\n\\begin{align}\n\\sin (\\alpha + \\beta) &= \\sin \\alpha \\cos \\beta + \\cos \\alpha \\sin \\beta\\\\\n\\cos (\\alpha + \\beta) &= \\cos \\alpha \\cos \\beta - \\sin \\alpha \\sin \\beta\n\\end{align}\n\\]\n\n\n「咲いたコスモス，コスモス咲いた」なり「しこってこすってこすってしこって」と語呂合わせで加法定理を覚えたりしますが，ここでは加法定理を図形的に考えてみたいと思います．\n\n\n\n\n\n\nFigure 1\n\n\n\nFigure 1 のように半径 \\(1\\) の単位円周上に \\(\\angle DOB = \\alpha + \\beta\\) となる点 \\(B\\) をとります． 同じく \\(\\angle AOD = \\alpha\\) となるように点をとると，\\(\\angle BOA = \\beta\\) となります．このとき，点 \\(B\\) の \\(y\\) 成分は \\(\\sin(\\alpha + \\beta)\\) となります．\n点 \\(B\\) から直線 \\(OA\\) 上に垂線を下ろし，その交点を \\(C\\) とすると \\(OB = 1\\) より\n\\[\n\\begin{align}\nBC & = \\sin\\beta\\\\\nOC &= \\cos\\beta\n\\end{align}\n\\]\nとなることがわかります．点 \\(C\\) から垂線を下ろし，\\(x\\) 軸との交点を \\(E\\), \\(B\\) から直線 \\(CE\\) との交点を \\(F\\) とすると\n\\[\n\\begin{align}\nCE &= \\sin \\alpha\\cos\\beta\\\\\nCF &= \\cos\\alpha\\sin\\beta\n\\end{align}\n\\]\nしたがって，\\(CE + CF = \\sin(\\alpha + \\beta)\\) となることから\n\\[\n\\sin (\\alpha + \\beta) = \\sin \\alpha \\cos \\beta + \\cos \\alpha \\sin \\beta\n\\]\nとなることが図形的にわかります．同様に\n\\[\n\\begin{align}\nOE &= \\cos\\alpha\\cos\\beta\\\\\nBF&= \\sin\\alpha\\sin\\beta\n\\end{align}\n\\]\nより\n\\[\n\\cos(\\alpha + \\beta) = OE - BF = \\cos\\alpha\\cos\\beta - \\sin\\alpha\\sin\\beta\n\\]\n ▶  ２角の差 \\(\\alpha - \\beta\\) の場合\n\\(\\sin(-\\beta) = -\\sin(\\beta)\\) および \\(\\cos(-\\beta) = \\cos\\beta\\) より\n\\[\n\\begin{align}\n\\sin (\\alpha - \\beta)\n    &= \\sin (\\alpha  + (-\\beta))\\\\\n    &= \\sin \\alpha \\cos (-\\beta) + \\cos \\alpha \\sin (-\\beta)\\\\\n    &= \\sin \\alpha \\cos \\beta - \\cos \\alpha \\sin \\beta\n\\end{align}\n\\]\n同様に\n\\[\n\\begin{align}\n\\cos (\\alpha - \\beta)\n    &= \\cos (\\alpha  + (-\\beta))\\\\\n    &= \\cos \\alpha \\cos (-\\beta) - \\sin \\alpha \\sin (-\\beta)\\\\\n    &= \\cos \\alpha \\cos \\beta + \\sin \\alpha \\sin \\beta\n\\end{align}\n\\]\n以上より\n\\[\n\\begin{align}\n\\sin (\\alpha \\pm \\beta) &= \\sin \\alpha \\cos \\beta \\pm \\cos \\alpha \\sin \\beta\\\\\n\\cos (\\alpha \\pm \\beta) &= \\cos \\alpha \\cos \\beta \\mp \\sin \\alpha \\sin \\beta\n\\end{align}\n\\]\n\n📘 REMARKS \n\\(\\sin \\theta\\) は奇関数，\\(\\cos \\theta\\) は偶関数であることに留意すると\n\\[\n\\begin{align}\n\\text{奇関数} \\times \\text{偶関数} &= \\text{奇関数}\\\\\n\\text{偶関数} \\times \\text{偶関数} &= \\text{偶関数}\\\\\n\\text{偶関数} + \\text{偶関数} &= \\text{偶関数}\\\\\n\\text{奇関数} + \\text{奇関数} &= \\text{奇関数}\n\\end{align}\n\\]\nであるので，加法定理のRHSとLHSがそれぞれ対応していることがわかります．\n\n\n\n\n\nTheorem 2 : オイラーの公式 \n\\[\n\\exp(i\\theta) = \\cos\\theta + i\\sin\\theta\n\\]\n\n\n\n\n\n\n\n\n\nNoteオイラーの公式を用いた加法定理の導出\n\n\n\n\n\n\\[\n\\begin{align}\n\\exp(i(\\alpha + \\beta))\n    &= \\exp(i\\alpha)\\exp(i\\beta)\\\\\n    &= (\\cos\\alpha + i\\sin\\alpha)(\\cos\\beta + i\\sin\\beta)\\\\\n    &= \\cos\\alpha\\cos\\beta - \\sin\\alpha\\sin\\beta + i(\\sin\\alpha\\cos\\beta + \\cos\\alpha\\sin\\beta)\n\\end{align}\n\\]\n\\(\\exp(i(\\alpha + \\beta)) = \\cos(\\alpha + \\beta) + i\\sin(\\alpha + \\beta)\\) であることから実部と虚部の比較より\n\\[\n\\begin{align}\n\\sin (\\alpha + \\beta) &= \\sin \\alpha \\cos \\beta + \\cos \\alpha \\sin \\beta\\\\\n\\cos (\\alpha + \\beta) &= \\cos \\alpha \\cos \\beta - \\sin \\alpha \\sin \\beta\n\\end{align}\n\\]\n二角の差の場合は\n\\[\n\\exp(i(\\alpha - \\beta))= \\exp(i\\alpha)\\exp(-i\\beta)\n\\]\nから同様に示すことが出来ます．\n\n\n\n\n\n\n\n\n\n\n\n\n\nNoteProof\n\n\n\n\n\n正弦と余弦の加法定理より\n\\[\n\\begin{align}\n\\tan(\\alpha \\pm \\beta)\n    &= \\frac{\\sin(\\alpha \\pm \\beta)}{\\cos(\\alpha \\pm \\beta)}\\\\\n    &= \\frac{\\sin \\alpha \\cos \\beta \\pm \\cos \\alpha \\sin \\beta}{\\cos \\alpha \\cos \\beta \\mp \\sin \\alpha \\sin \\beta}\n\\end{align}\n\\]\n分子と分母を \\(\\cos \\alpha \\cos \\beta\\) で割ると\n\\[\n\\begin{align}\n\\tan(\\alpha \\pm \\beta) = \\frac{\\tan \\alpha \\pm \\tan \\beta}{1 \\mp \\tan \\alpha \\tan \\beta}\n\\end{align}\n\\]\n\n\n\n\n\nExercise 1 \n\\(\\tan 1^\\circ\\) が無理数であることを示せ\n\n\n\n\n\n\n\n\n\nNoteSolution\n\n\n\n\n\n\\(\\tan 1^\\circ\\) がとある有理数 \\(a\\) であると仮定すると，加法定理より\n\\[\n\\tan 2^\\circ = \\frac{2a}{1 - a^2}\n\\]\nとなり，有理数の四則演算は有理数で閉じていることから \\(\\tan 2^\\circ\\) も有理数であることがわかる．同様に \\(4^\\circ, 8^\\circ, 16^\\circ, 32^\\circ\\) も有理数であることがわかる．\nここで，\n\\[\n\\tan 30^\\circ = \\frac{\\sqrt{3}}{3}\n\\]\nより \\(\\tan 30^\\circ\\) は無理数であることに着目する．一方，\\(\\tan 30^\\circ\\) は加法定理より\n\\[\n\\begin{align}\n\\tan 30^\\circ\n    &= \\tan (32^\\circ - 2^\\circ)\\\\\n    &= \\frac{\\tan 32^\\circ + \\tan 2^\\circ}{1 + \\tan 32^\\circ\\tan 2^\\circ}\n\\end{align}\n\\]\nこのとき，\\(\\tan 32^\\circ, \\tan 2^\\circ\\) はともに有理数であるので， \\(\\tan 30^\\circ\\) は無理数であることと矛盾． したがって，\\(\\tan 1^\\circ\\) は無理数である．"
  },
  {
    "objectID": "posts/2025-03-05-addition-theorem/index.html#加法定理",
    "href": "posts/2025-03-05-addition-theorem/index.html#加法定理",
    "title": "三角関数の加法定理",
    "section": "",
    "text": "Theorem 1 : 加法定理 \n\\[\n\\begin{align}\n\\sin (\\alpha + \\beta) &= \\sin \\alpha \\cos \\beta + \\cos \\alpha \\sin \\beta\\\\\n\\cos (\\alpha + \\beta) &= \\cos \\alpha \\cos \\beta - \\sin \\alpha \\sin \\beta\n\\end{align}\n\\]\n\n\n「咲いたコスモス，コスモス咲いた」なり「しこってこすってこすってしこって」と語呂合わせで加法定理を覚えたりしますが，ここでは加法定理を図形的に考えてみたいと思います．\n\n\n\n\n\n\nFigure 1\n\n\n\nFigure 1 のように半径 \\(1\\) の単位円周上に \\(\\angle DOB = \\alpha + \\beta\\) となる点 \\(B\\) をとります． 同じく \\(\\angle AOD = \\alpha\\) となるように点をとると，\\(\\angle BOA = \\beta\\) となります．このとき，点 \\(B\\) の \\(y\\) 成分は \\(\\sin(\\alpha + \\beta)\\) となります．\n点 \\(B\\) から直線 \\(OA\\) 上に垂線を下ろし，その交点を \\(C\\) とすると \\(OB = 1\\) より\n\\[\n\\begin{align}\nBC & = \\sin\\beta\\\\\nOC &= \\cos\\beta\n\\end{align}\n\\]\nとなることがわかります．点 \\(C\\) から垂線を下ろし，\\(x\\) 軸との交点を \\(E\\), \\(B\\) から直線 \\(CE\\) との交点を \\(F\\) とすると\n\\[\n\\begin{align}\nCE &= \\sin \\alpha\\cos\\beta\\\\\nCF &= \\cos\\alpha\\sin\\beta\n\\end{align}\n\\]\nしたがって，\\(CE + CF = \\sin(\\alpha + \\beta)\\) となることから\n\\[\n\\sin (\\alpha + \\beta) = \\sin \\alpha \\cos \\beta + \\cos \\alpha \\sin \\beta\n\\]\nとなることが図形的にわかります．同様に\n\\[\n\\begin{align}\nOE &= \\cos\\alpha\\cos\\beta\\\\\nBF&= \\sin\\alpha\\sin\\beta\n\\end{align}\n\\]\nより\n\\[\n\\cos(\\alpha + \\beta) = OE - BF = \\cos\\alpha\\cos\\beta - \\sin\\alpha\\sin\\beta\n\\]\n ▶  ２角の差 \\(\\alpha - \\beta\\) の場合\n\\(\\sin(-\\beta) = -\\sin(\\beta)\\) および \\(\\cos(-\\beta) = \\cos\\beta\\) より\n\\[\n\\begin{align}\n\\sin (\\alpha - \\beta)\n    &= \\sin (\\alpha  + (-\\beta))\\\\\n    &= \\sin \\alpha \\cos (-\\beta) + \\cos \\alpha \\sin (-\\beta)\\\\\n    &= \\sin \\alpha \\cos \\beta - \\cos \\alpha \\sin \\beta\n\\end{align}\n\\]\n同様に\n\\[\n\\begin{align}\n\\cos (\\alpha - \\beta)\n    &= \\cos (\\alpha  + (-\\beta))\\\\\n    &= \\cos \\alpha \\cos (-\\beta) - \\sin \\alpha \\sin (-\\beta)\\\\\n    &= \\cos \\alpha \\cos \\beta + \\sin \\alpha \\sin \\beta\n\\end{align}\n\\]\n以上より\n\\[\n\\begin{align}\n\\sin (\\alpha \\pm \\beta) &= \\sin \\alpha \\cos \\beta \\pm \\cos \\alpha \\sin \\beta\\\\\n\\cos (\\alpha \\pm \\beta) &= \\cos \\alpha \\cos \\beta \\mp \\sin \\alpha \\sin \\beta\n\\end{align}\n\\]\n\n📘 REMARKS \n\\(\\sin \\theta\\) は奇関数，\\(\\cos \\theta\\) は偶関数であることに留意すると\n\\[\n\\begin{align}\n\\text{奇関数} \\times \\text{偶関数} &= \\text{奇関数}\\\\\n\\text{偶関数} \\times \\text{偶関数} &= \\text{偶関数}\\\\\n\\text{偶関数} + \\text{偶関数} &= \\text{偶関数}\\\\\n\\text{奇関数} + \\text{奇関数} &= \\text{奇関数}\n\\end{align}\n\\]\nであるので，加法定理のRHSとLHSがそれぞれ対応していることがわかります．\n\n\n\n\n\nTheorem 2 : オイラーの公式 \n\\[\n\\exp(i\\theta) = \\cos\\theta + i\\sin\\theta\n\\]\n\n\n\n\n\n\n\n\n\nNoteオイラーの公式を用いた加法定理の導出\n\n\n\n\n\n\\[\n\\begin{align}\n\\exp(i(\\alpha + \\beta))\n    &= \\exp(i\\alpha)\\exp(i\\beta)\\\\\n    &= (\\cos\\alpha + i\\sin\\alpha)(\\cos\\beta + i\\sin\\beta)\\\\\n    &= \\cos\\alpha\\cos\\beta - \\sin\\alpha\\sin\\beta + i(\\sin\\alpha\\cos\\beta + \\cos\\alpha\\sin\\beta)\n\\end{align}\n\\]\n\\(\\exp(i(\\alpha + \\beta)) = \\cos(\\alpha + \\beta) + i\\sin(\\alpha + \\beta)\\) であることから実部と虚部の比較より\n\\[\n\\begin{align}\n\\sin (\\alpha + \\beta) &= \\sin \\alpha \\cos \\beta + \\cos \\alpha \\sin \\beta\\\\\n\\cos (\\alpha + \\beta) &= \\cos \\alpha \\cos \\beta - \\sin \\alpha \\sin \\beta\n\\end{align}\n\\]\n二角の差の場合は\n\\[\n\\exp(i(\\alpha - \\beta))= \\exp(i\\alpha)\\exp(-i\\beta)\n\\]\nから同様に示すことが出来ます．\n\n\n\n\n\n\n\n\n\n\n\n\n\nNoteProof\n\n\n\n\n\n正弦と余弦の加法定理より\n\\[\n\\begin{align}\n\\tan(\\alpha \\pm \\beta)\n    &= \\frac{\\sin(\\alpha \\pm \\beta)}{\\cos(\\alpha \\pm \\beta)}\\\\\n    &= \\frac{\\sin \\alpha \\cos \\beta \\pm \\cos \\alpha \\sin \\beta}{\\cos \\alpha \\cos \\beta \\mp \\sin \\alpha \\sin \\beta}\n\\end{align}\n\\]\n分子と分母を \\(\\cos \\alpha \\cos \\beta\\) で割ると\n\\[\n\\begin{align}\n\\tan(\\alpha \\pm \\beta) = \\frac{\\tan \\alpha \\pm \\tan \\beta}{1 \\mp \\tan \\alpha \\tan \\beta}\n\\end{align}\n\\]\n\n\n\n\n\nExercise 1 \n\\(\\tan 1^\\circ\\) が無理数であることを示せ\n\n\n\n\n\n\n\n\n\nNoteSolution\n\n\n\n\n\n\\(\\tan 1^\\circ\\) がとある有理数 \\(a\\) であると仮定すると，加法定理より\n\\[\n\\tan 2^\\circ = \\frac{2a}{1 - a^2}\n\\]\nとなり，有理数の四則演算は有理数で閉じていることから \\(\\tan 2^\\circ\\) も有理数であることがわかる．同様に \\(4^\\circ, 8^\\circ, 16^\\circ, 32^\\circ\\) も有理数であることがわかる．\nここで，\n\\[\n\\tan 30^\\circ = \\frac{\\sqrt{3}}{3}\n\\]\nより \\(\\tan 30^\\circ\\) は無理数であることに着目する．一方，\\(\\tan 30^\\circ\\) は加法定理より\n\\[\n\\begin{align}\n\\tan 30^\\circ\n    &= \\tan (32^\\circ - 2^\\circ)\\\\\n    &= \\frac{\\tan 32^\\circ + \\tan 2^\\circ}{1 + \\tan 32^\\circ\\tan 2^\\circ}\n\\end{align}\n\\]\nこのとき，\\(\\tan 32^\\circ, \\tan 2^\\circ\\) はともに有理数であるので， \\(\\tan 30^\\circ\\) は無理数であることと矛盾． したがって，\\(\\tan 1^\\circ\\) は無理数である．"
  },
  {
    "objectID": "posts/2025-03-05-addition-theorem/index.html#倍角の公式とサインカーブ",
    "href": "posts/2025-03-05-addition-theorem/index.html#倍角の公式とサインカーブ",
    "title": "三角関数の加法定理",
    "section": "倍角の公式とサインカーブ",
    "text": "倍角の公式とサインカーブ\n\n\nTheorem 3 : 倍角の公式 \n\\[\n\\begin{align}\n\\sin 2\\theta &= 2\\sin\\theta\\cos\\theta\\\\\n\\cos 2\\theta &= \\cos^2\\theta - \\sin^2\\theta\\\\\n             &= 1 - 2\\sin^2\\theta = 2\\cos^2\\theta - 1\\\\\n\\tan 2\\theta &= \\frac{2\\tan\\theta}{1 - \\tan^2\\theta}\n\\end{align}\n\\]\n\n\n\\(y = \\sin x\\) は振幅 \\(1\\) で周期 \\(2\\pi\\) の周期関数ですが，\n\\[\ny = \\alpha\\sin \\beta x \\quad \\alpha &gt; 0, \\beta &gt; 0\n\\]\nと変形すると，振幅 \\(\\alpha\\) で周期 \\(\\displaystyle \\frac{2\\pi}{\\beta}\\) の周期関数となります．\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport matplotlib.ticker as ticker\n\n# Define the x values\nx = np.linspace(-2 * np.pi, 2 * np.pi, 400)\n\n# Define the y values for both functions\ny1 = np.sin(x)\ny2 = np.sin(x / 2)\ny3 = 3 * np.sin(2 * x)\n\n# Create the plot\nplt.figure(figsize=(10, 6))\nplt.plot(x, y1, label=r\"$y = \\sin(x)$\", color=\"b\")\nplt.plot(x, y2, label=r\"$y = \\sin(x/2)$\", color=\"r\", linestyle=\"--\")\nplt.plot(x, y3, label=r\"$y = 3\\sin(2x)$\", color=\"gray\", linestyle=\"--\")\n\n# Add labels, title, and legend\nplt.xlabel(\"x\")\nplt.ylabel(\"y\")\nplt.title(\"Comparison of $y = \\sin(x)$ and $y = \\sin(x/2)$, $y = 3\\sin(2x)$\")\nplt.axhline(0, color=\"black\", linewidth=0.5)\nplt.axvline(0, color=\"black\", linewidth=0.5)\nplt.legend()\nplt.grid(True)\n\n# Set x-ticks to multiples of pi\nxticks = np.arange(-2 * np.pi, 2.5 * np.pi, np.pi / 2)\nxtick_labels = [\n    r\"$-2\\pi$\",\n    r\"$-\\frac{3\\pi}{2}$\",\n    r\"$-\\pi$\",\n    r\"$-\\frac{\\pi}{2}$\",\n    \"0\",\n    r\"$\\frac{\\pi}{2}$\",\n    r\"$\\pi$\",\n    r\"$\\frac{3\\pi}{2}$\",\n    r\"$2\\pi$\",\n]\nplt.xticks(xticks, xtick_labels)\n\n# Show the plot\nplt.show()\n\n\n\n\n\n\n\n\n\n次に，\\(y = \\sin x \\cos x\\) のグラフを考えてみます．加法定理より\n\\[\n\\begin{align}\n\\sin 2x\n    &= \\sin (x + x)\\\\\n    &= 2\\sin x\\cos x\n\\end{align}\n\\]\nであることから\n\\[\n\\sin x \\cos x = \\frac{1}{2}\\sin 2x\n\\]\nつまり，\\(y = \\sin x \\cos x\\) のグラフは振幅 \\(\\displaystyle \\frac{1}{2}\\)，周期 \\(\\pi\\) のサインカーブとなることがわかります．\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport matplotlib.ticker as ticker\n\n# Define the x values\nx = np.linspace(-2 * np.pi, 2 * np.pi, 400)\n\n# Define the y values for both functions\ny1 = np.sin(x) * np.cos(x)\ny2 = np.sin(2 * x) /2\n\n# Create the plot\nplt.figure(figsize=(10, 6))\nplt.plot(x, y1, label=r\"$y = \\sin(x)$\", color=\"b\")\nplt.plot(x, y2, label=r\"$y = \\frac{1}{2}\\sin(2x)$\", color=\"gray\", linestyle=\"--\")\n\n# Add labels, title, and legend\nplt.xlabel(\"x\")\nplt.ylabel(\"y\")\nplt.axhline(0, color=\"black\", linewidth=0.5)\nplt.axvline(0, color=\"black\", linewidth=0.5)\nplt.legend()\nplt.grid(True)\n\n# Set x-ticks to multiples of pi\nxticks = np.arange(-2 * np.pi, 2.5 * np.pi, np.pi / 2)\nxtick_labels = [\n    r\"$-2\\pi$\",\n    r\"$-\\frac{3\\pi}{2}$\",\n    r\"$-\\pi$\",\n    r\"$-\\frac{\\pi}{2}$\",\n    \"0\",\n    r\"$\\frac{\\pi}{2}$\",\n    r\"$\\pi$\",\n    r\"$\\frac{3\\pi}{2}$\",\n    r\"$2\\pi$\",\n]\nplt.xticks(xticks, xtick_labels)\n\n# Show the plot\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\nTheorem 4 : 半角の公式 \n\\[\n\\begin{align}\n\\sin^2 \\frac{\\theta}{2} &= \\frac{1 - \\cos\\theta}{2}\\\\\n\\cos^2 \\frac{\\theta}{2} &= \\frac{1 + \\cos\\theta}{2}\\\\\n\\tan^2 \\frac{\\theta}{2} &= \\frac{1 - \\cos\\theta}{1 + \\cos\\theta}\n\\end{align}\n\\]\n\n\n\nExample 1 \n\\(y = \\sin^2 x\\) について考えてみます．正弦関数は奇関数であるので，\\(\\sin^2 x\\) は偶関数になるはずです．半角の公式を用いると\n\\[\n\\sin^2 x = \\frac{1 - \\cos 2x}{2}\n\\]\nとなるので，振幅 \\(\\displaystyle\\frac{1}{2}\\), 周期 \\(\\pi\\) のコサインカーブを \\(\\displaystyle\\frac{1}{2}\\) 平行移動したものであることがわかります．\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport matplotlib.ticker as ticker\n\n# Define the x values\nx = np.linspace(-2 * np.pi, 2 * np.pi, 400)\n\n# Define the y values for both functions\ny1 = (1 - np.cos(2 * x))/2\ny2 = np.cos(2 * x)\n\n# Create the plot\nplt.figure(figsize=(8, 6))\nplt.plot(x, y1, label=r\"$y = \\sin^2(x)$\", color=\"b\")\nplt.plot(x, y2, label=r\"$y = \\cos(x)$\", color=\"gray\", linestyle=\"--\")\n\n# Add labels, title, and legend\nplt.xlabel(\"x\")\nplt.ylabel(\"y\")\nplt.axhline(0, color=\"black\", linewidth=0.5)\nplt.axvline(0, color=\"black\", linewidth=0.5)\nplt.legend( loc='lower right',)\nplt.grid(True)\n\n# Set x-ticks to multiples of pi\nxticks = np.arange(-2 * np.pi, 2.5 * np.pi, np.pi / 2)\nxtick_labels = [\n    r\"$-2\\pi$\",\n    r\"$-\\frac{3\\pi}{2}$\",\n    r\"$-\\pi$\",\n    r\"$-\\frac{\\pi}{2}$\",\n    \"0\",\n    r\"$\\frac{\\pi}{2}$\",\n    r\"$\\pi$\",\n    r\"$\\frac{3\\pi}{2}$\",\n    r\"$2\\pi$\",\n]\nplt.xticks(xticks, xtick_labels)\n\n\n# Show the plot\nplt.show()"
  },
  {
    "objectID": "posts/2025-03-05-addition-theorem/index.html#和積の公式",
    "href": "posts/2025-03-05-addition-theorem/index.html#和積の公式",
    "title": "三角関数の加法定理",
    "section": "和積の公式",
    "text": "和積の公式\n\n\nTheorem 5 : 正弦関数の和積の公式 \n\\[\n\\begin{align}\n\\sin \\alpha + \\sin\\beta &= 2 \\sin \\frac{\\alpha+\\beta}{2}\\cos \\frac{\\alpha-\\beta}{2}\\\\\n\\sin \\alpha - \\sin\\beta &= 2 \\cos \\frac{\\alpha+\\beta}{2}\\sin \\frac{\\alpha-\\beta}{2}\\\\\n\\cos \\alpha + \\cos\\beta &= 2 \\cos \\frac{\\alpha+\\beta}{2}\\cos \\frac{\\alpha-\\beta}{2}\\\\\n\\cos \\alpha - \\cos\\beta &= -2 \\sin \\frac{\\alpha+\\beta}{2}\\sin \\frac{\\alpha-\\beta}{2}\n\\end{align}\n\\]\n\n\n\n\n\n\n\n\n\nNoteProof\n\n\n\n\n\n加法定理より\n\\[\n\\begin{align}\n\\sin (\\gamma + \\delta)\n    &= \\sin\\gamma \\cos\\delta + \\cos\\gamma \\sin\\delta\\\\\n\\sin (\\gamma - \\delta)\n    &= \\sin\\gamma \\cos\\delta - \\cos\\gamma \\sin\\delta\n\\end{align}\n\\]\nこれを整理すると\n\\[\n\\begin{align}\n\\sin (\\gamma + \\delta) + \\sin (\\gamma - \\delta) &= 2\\sin\\gamma \\cos\\delta\\\\\n\\sin (\\gamma + \\delta) - \\sin (\\gamma - \\delta) &= 2\\cos\\gamma \\sin\\delta\n\\end{align}\n\\]\nここで，\\(\\gamma + \\delta = \\alpha, \\gamma - \\delta = \\beta\\) とおくと\n\\[\n\\begin{gather}\n\\gamma = \\frac{ \\alpha + \\beta}{2}, \\quad \\delta = \\frac{\\alpha - \\beta}{2}\n\\end{gather}\n\\]\nとなるので\n\\[\n\\begin{align}\n\\sin \\alpha + \\sin\\beta &= 2 \\sin \\frac{\\alpha+\\beta}{2}\\cos \\frac{\\alpha-\\beta}{2}\\\\\n\\sin \\alpha - \\sin\\beta &= 2 \\cos \\frac{\\alpha+\\beta}{2}\\sin \\frac{\\alpha-\\beta}{2}\n\\end{align}\n\\]\n余弦関数も同様に\n\\[\n\\begin{align}\n\\cos (\\gamma + \\delta)\n    &= \\cos\\gamma \\cos\\delta - \\sin\\gamma \\sin\\delta\\\\\n\\cos (\\gamma - \\delta)\n    &= \\cos\\gamma \\cos\\delta + \\sin\\gamma \\sin\\delta\n\\end{align}\n\\]\nであるので\n\\[\n\\begin{align}\n\\cos (\\gamma + \\delta) + \\cos (\\gamma - \\delta) &= 2\\cos\\gamma \\cos\\delta\\\\\n\\cos (\\gamma + \\delta) - \\cos (\\gamma - \\delta) &= -2\\sin\\gamma \\sin\\delta\n\\end{align}\n\\]\nから導くことができます．\n\n\n\n\nExample 2 \n\\(x + y + z = \\pi\\) を満たす実数 \\(x, y, z\\) について\n\\[\n\\sin x + \\sin y + \\sin z = 4 \\cos\\frac{x}{2}\\cos\\frac{y}{2}\\cos\\frac{z}{2}\n\\]\nが成り立ちます．LHSを式変形すると\n\\[\n\\begin{align}\n\\sin x + \\sin y + \\sin z\n    &= \\sin x + \\sin y + \\sin (\\pi - (x + y))\\\\\n    &= \\sin x + \\sin y + \\sin (x + y)\\\\\n    &= 2\\sin\\frac{x+y}{2}\\cos\\frac{x-y}{2} + 2\\sin\\frac{x+y}{2}\\cos\\frac{x+y}{2}\\\\\n    &= 2\\sin\\frac{x+y}{2}\\left(\\cos\\frac{x-y}{2} + \\cos\\frac{x+y}{2}\\right)\\\\\n    &= 2\\sin\\frac{x+y}{2}\\times 2\\cos\\frac{\\frac{x-y}{2} + \\frac{x-y}{2}}{2}\\cos\\frac{\\frac{x-y}{2} - \\frac{x-y}{2}}{2}\\\\\n    &=4\\sin\\frac{x+y}{2}\\cos\\frac{x}{2}\\cos\\frac{-y}{2}\\\\\n    &=4\\sin\\frac{\\pi-z}{2}\\cos\\frac{x}{2}\\cos\\frac{y}{2}\\\\\n    &=4\\cos\\frac{z}{2}\\cos\\frac{x}{2}\\cos\\frac{y}{2}\n\\end{align}\n\\]"
  },
  {
    "objectID": "posts/2025-03-05-addition-theorem/index.html#references",
    "href": "posts/2025-03-05-addition-theorem/index.html#references",
    "title": "三角関数の加法定理",
    "section": "References",
    "text": "References\n\nRegmonkey Datascience Blog &gt; tangent 75°の図形的計算\nRegmonkey Datascience Blog &gt; 三角形の内接円"
  },
  {
    "objectID": "posts/2025-07-01-physics-exercise-001/index.html",
    "href": "posts/2025-07-01-physics-exercise-001/index.html",
    "title": "ある慣性系で２つの平行な軌道",
    "section": "",
    "text": "Definition 1 慣性の法則\n\n質点が何の力も受けないとき，その質点は静止たままか，一定の速度で運動する\n運動の第一法則とも呼ぶ\n\n\n慣性の法則が成り立つ座標系を慣性系といいます．ある座標系が慣性系であれば，それに対して静止しているか等速直線運動をする座標系はすべて慣性系です．"
  },
  {
    "objectID": "posts/2025-07-01-physics-exercise-001/index.html#慣性の法則と慣性系",
    "href": "posts/2025-07-01-physics-exercise-001/index.html#慣性の法則と慣性系",
    "title": "ある慣性系で２つの平行な軌道",
    "section": "",
    "text": "Definition 1 慣性の法則\n\n質点が何の力も受けないとき，その質点は静止たままか，一定の速度で運動する\n運動の第一法則とも呼ぶ\n\n\n慣性の法則が成り立つ座標系を慣性系といいます．ある座標系が慣性系であれば，それに対して静止しているか等速直線運動をする座標系はすべて慣性系です．"
  },
  {
    "objectID": "posts/2025-07-01-physics-exercise-001/index.html#exercise",
    "href": "posts/2025-07-01-physics-exercise-001/index.html#exercise",
    "title": "ある慣性系で２つの平行な軌道",
    "section": "Exercise",
    "text": "Exercise\n\nExercise 1 \n非相対論的(=ニュートン力学で十分に正確に記述できる)な一定の速さで運動する２つの物体の軌道を，ある慣性系で観測したところ平行だった．\n\n別の関係性を選んで，その系では２つの軌道が互いに交差するというのはあり得るか？\n(a)を満たす座標系があったとして，適当な初期条件のもとに物体が動き始めて，それらが同時に交差する点へ到達することはあり得るか？\n\n\n\n\n\n\n\n\nNoteSolution (a)\n\n\n\n\n\nもとの座標系 \\(K\\) で，２つの物体の速度ベクトルを \\(\\pmb{v}_1, \\pmb{v}_2\\) とする．これらは仮定より平行なので\n\\[\n\\pmb{v}_1\\times\\pmb{v}_2 = \\pmb{0}\n\\]\n\\(K\\) に対して，速度 \\(\\pmb v_0\\) で動いている座標系 \\(K^\\prime\\) で，２つの軌道が互いに交差するならば\n\\[\n\\begin{align}\n(\\pmb v_1 - \\pmb v_0) \\times (\\pmb v_2 - \\pmb v_0)\n  &= (\\pmb v_1 - \\pmb v_2) \\times \\pmb v_0\\\\\n  &\\neq \\pmb{0}\n\\end{align}\n\\]\nこの条件が満たされるには\n\n2つの \\(\\pmb{v}_1, \\pmb{v}_2\\) の速度の大きさが異なっている\n2つの \\(\\pmb{v}_1, \\pmb{v}_2\\) の速度差ベクトルが \\(\\pmb{v}_0\\) と平行ではない\n\nが必要となります．\n\n\n\n\n\n\n\n\n\nNoteSolution (b)\n\n\n\n\n\n物体１の \\(t=0\\) における位置を座標系 \\(K\\) の原点にとると，時刻 \\(t\\) における２つの物体の位置ベクトルは，\\(t=0\\) における２つの物体の相対位置ベクトルを \\(\\pmb{d}\\) とすると\n\\[\n\\begin{align}\n\\pmb{r}_1(t) &= \\pmb{v}_1t\\\\\n\\pmb{r}_2(t) &= \\pmb{v}_2t + \\pmb{d}\n\\end{align}\n\\]\nこれを座標 \\(K^\\prime\\) での位置ベクトルになおすと\n\\[\n\\begin{align}\n\\pmb{r}_1^\\prime(t) &= (\\pmb{v}_1 - \\pmb{v}_0)t\\\\\n\\pmb{r}_2^\\prime(t) &= (\\pmb{v}_2 - \\pmb{v}_0)t + \\pmb{d}\n\\end{align}\n\\]\nもし２つの物体が時刻 \\(t_0\\) にある点で出会うならば\n\\[\n\\pmb{r}_1^\\prime(t_0) = \\pmb{r}_2^\\prime(t_0)\n\\]\nつまり，\n\\[\n(\\pmb{v}_1 - \\pmb{v}_2) t_0 = \\pmb{d}\n\\]\nこの条件が満たされるには\n\n\\(\\pmb{d}\\) が２つの物体の軌道に平行であればよい\n\nつまり，物体２の出発地点が物体１の直線経路上にあれば良いことになります．言い換えると，座標系 \\(K^\\prime\\) で観測したときに， ２つの物体が同じ時刻に同じ場所にいるとすれば，座標系 \\(K\\) で観測しても，同じように出会うはずである．"
  },
  {
    "objectID": "posts/2025-07-01-physics-exercise-001/index.html#refereneces",
    "href": "posts/2025-07-01-physics-exercise-001/index.html#refereneces",
    "title": "ある慣性系で２つの平行な軌道",
    "section": "Refereneces",
    "text": "Refereneces\n\nベクトル空間における外積"
  },
  {
    "objectID": "posts/2025-06-02-combined-gas-law/index.html",
    "href": "posts/2025-06-02-combined-gas-law/index.html",
    "title": "ボイル=シャルルの法則の導出",
    "section": "",
    "text": "Theorem 1 ボイルの法則\n温度 \\(T\\) が一定のとき，圧力 \\(p\\) と体積 \\(V\\) は反比例する．つまり，\n\\[\npV = \\text{constant}\n\\]\n\nある一定の温度 \\(T\\) の下では，\n\n圧力 \\(p\\) を上げれば，それに反比例して体積 \\(V\\) は収縮\n圧力 \\(p\\) を下げれば，それに反比例して体積 \\(V\\) は膨張\n\n\nTheorem 2 シャルルの法則\n圧力 \\(p\\) が一定のとき，温度 \\(T\\) と体積 \\(V\\) は比例する\n\\[\n\\frac{V}{T} = \\text{constant}\n\\]\n\n圧力 \\(p\\) が一定のとき\n\n温度 \\(T\\) を上げれば，それに比例して体積 \\(V\\) は膨張\n温度 \\(T\\) を下げれば，それに比例して体積 \\(V\\) は収縮"
  },
  {
    "objectID": "posts/2025-06-02-combined-gas-law/index.html#ボイルの法則とシャルルの法則",
    "href": "posts/2025-06-02-combined-gas-law/index.html#ボイルの法則とシャルルの法則",
    "title": "ボイル=シャルルの法則の導出",
    "section": "",
    "text": "Theorem 1 ボイルの法則\n温度 \\(T\\) が一定のとき，圧力 \\(p\\) と体積 \\(V\\) は反比例する．つまり，\n\\[\npV = \\text{constant}\n\\]\n\nある一定の温度 \\(T\\) の下では，\n\n圧力 \\(p\\) を上げれば，それに反比例して体積 \\(V\\) は収縮\n圧力 \\(p\\) を下げれば，それに反比例して体積 \\(V\\) は膨張\n\n\nTheorem 2 シャルルの法則\n圧力 \\(p\\) が一定のとき，温度 \\(T\\) と体積 \\(V\\) は比例する\n\\[\n\\frac{V}{T} = \\text{constant}\n\\]\n\n圧力 \\(p\\) が一定のとき\n\n温度 \\(T\\) を上げれば，それに比例して体積 \\(V\\) は膨張\n温度 \\(T\\) を下げれば，それに比例して体積 \\(V\\) は収縮"
  },
  {
    "objectID": "posts/2025-06-02-combined-gas-law/index.html#ボイルシャルルの法則",
    "href": "posts/2025-06-02-combined-gas-law/index.html#ボイルシャルルの法則",
    "title": "ボイル=シャルルの法則の導出",
    "section": "ボイル=シャルルの法則",
    "text": "ボイル=シャルルの法則\n\nTheorem 3 ボイル=シャルルの法則\nボイルの法則とシャルルの法則が成立するとき，\n\\[\n\\frac{pV}{T} = \\text{constant}\n\\]\nこれをボイル=シャルルの法則と呼ぶ\n\n\n\n\n\n\n\nNoteProof 1: 単射仮定\n\n\n\n\n\nボイルの法則より温度 \\(T\\) が一定のとき \\(pV = \\text{constant}\\)，つまり\n\\[\n\\begin{align}\npV = f(T) \\label{eq-base}\n\\end{align}\n\\]\n同様に，シャルルの法則より\n\\[\n\\frac{V}{T} = g(p)\n\\]\nここで関数 \\(g(\\cdot)\\) を単射と仮定すると\n\\[\nh\\left(\\frac{V}{T}\\right) = p\n\\]\n従って，\n\\[\nh\\left(\\frac{V}{T}\\right) = \\frac{f(T)}{v} \\ \\ \\forall v, T\n\\]\nここで，\\(\\displaystyle\\frac{V}{T} = x\\) とすると\n\\[\nh(x) = \\frac{f(T)}{x\\cdot T}\n\\]\nLHSは \\(x\\) の関数であることから，\n\\[\nh(x) = \\frac{f(T_1)}{x\\cdot T_1} = \\frac{f(T_2)}{x\\cdot T_2}\n\\]\n\\(\\displaystyle \\frac{f(T)}{T} = \\lambda\\)(定数) とおくと\n\\[\nh(x) = \\frac{\\lambda}{x}\n\\]\n従って，\\(f(T) = \\lambda T\\). これを \\(\\eqref{eq-base}\\) に代入すると\n\\[\npV = \\lambda T\n\\]\n\\(T &gt; 0\\) より\n\\[\n\\frac{pV}{T} = \\lambda\n\\]\n\n\n\n\n\n\n\n\n\nNoteProof: 独立変数\n\n\n\n\n\nボイルの法則とシャルルの法則より\n\\[\n\\begin{align}\npV &= f(T)\\\\\n\\frac{V}{T} &= g(p)\n\\end{align}\n\\]\nこれを \\(V\\) について解いて整理すると\n\\[\n\\frac{f(T)}{T} = pg(p)\n\\]\nこの式において，左辺は温度のみの関数，右辺は圧力のみの関数．圧力と温度は互いに独立しているため，この式が常に成り立つためには，両辺がそれぞれ定数でなければならない．つまり，\n\\[\n\\lambda = \\frac{f(T)}{T} = pg(p)\n\\]\n従って，\n\\[\n\\begin{align}\nf(T) &= \\lambda T\n\\end{align}\n\\]\nよって，\n\\[\n\\frac{pV}{T} = \\lambda\n\\]\n\n\n\n\n物理的現象としてボイル=シャルルの法則を見てみる\n\n\n\n\n\n\nsequenceDiagram\n    participant A as p₀, V₀, T₀\n    participant B as p₁, V', T₀\n    participant C as p₁, V₁, T₁\n    A-&gt;&gt;B: T₀一定&lt;br&gt;p₀V₀=p₁V'\n    B-&gt;&gt;C: p₁一定&lt;br&gt;V'/T₀ = V₁/T₁\n\n\n\n\n\n\n\nまず，\\(p_0, V_0, T_0\\) の１つの熱力学的な系を，温度 \\(T_0\\) のまま圧力を \\(p_1, V'\\) に変化させると，ボイルの法則より\n\\[\np_0V_0 = p_1V'\n\\]\nつぎに \\(p_1\\) を一定の下，\\(V_1, T_1\\) へ系を変化させると，シャルルの法則より\n\\[\n\\frac{V'}{T_0} = \\frac{V_1}{T_1}\n\\]\nここから\n\\[\nV' = T_0\\cdot\\frac{V_1}{T_1}\n\\]\nよって\n\\[\n\\frac{p_0V_0}{T_0} = \\frac{p_1V_1}{T_1} = \\text{constant}\n\\]\nを得る．\n\n\nボイル=シャルルの法則から理想気体の状態方程式を導く\n1 molの気体は 0℃, 1 atm の条件下で気体の種類によらず体積は 22.41 l になります．ここから\n\\[\n\\begin{align}\n\\frac{pV}{T}\n  &= \\frac{1.013 \\times 10^5 \\times 22.41 \\times 10^{-3}}{273.15}\\\\\n  &\\approx 8.31 \\text{[J/mol K]}\n\\end{align}\n\\]\n\n\\(pV\\) の単位あh [Pa･m³] = [Nm] = [J] つまり，エネルギーの単位となる\n\nこの定数を \\(R\\) とおくと \\(R \\approx 8.31 \\text{[J/mol K]}\\)．この定数 \\(R\\) を気体定数と呼ぶ．\\(n\\) molの気体に対しては\n\\[\n\\frac{pV}{T} = nR\n\\]\n\nExample 1 空気中の分子数\n20℃，1atmの空気 1cm³の質量と，それに含まれる分子数を求めてみます．条件として\n\n空気は酸素と窒素が1:4の比率として，1molあたり質量は28.8とする\nアボガドロ数 \\(N_a = 6.02 \\times 10^{23}\\)\n\n理想気体の状態方程式より\n\\[\n\\frac{22.41}{273.15} = \\frac{V}{293.15}\n\\]\n従って，\\(V = 24.05 \\text{[l]} = 24.05 \\times 10^3 \\text{[cm³]}\\)．1cm³あたり質量は\n\\[\n\\frac{28.8}{24.05 \\times 10^3 } \\approx 1.20 \\times 10^{-3} \\text{[g/cm³]}\n\\]\nこの空気1cm³あたり分子数は\n\\[\n\\frac{N_A}{24.05 \\times 10^3} \\approx 2.50 \\times 10^{19} \\text{[個/cm³]}\n\\]"
  },
  {
    "objectID": "posts/2025-01-27-differentiation_of_exponential_function/index.html",
    "href": "posts/2025-01-27-differentiation_of_exponential_function/index.html",
    "title": "指数関数の微分",
    "section": "",
    "text": "底 \\(a&gt;1\\) のとき，\n\n指数関数 \\(y = a^x\\) は区間 \\(-\\infty &lt; x &lt; \\infty\\) において連続かつ単調増大で, \\(y \\in (0, \\infty)\\)\n対数関数 \\(y = \\log_a x\\) は \\(y = a^x\\) の逆関数で，区間 \\(0 &lt; x &lt; \\infty\\) において連続かつ単調増大で, \\(y \\in (\\infty, \\infty)\\)\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# PARAMS\nbase = 2\nN = 1000 # data points\nmin_lim = -2\nmax_lim = 5\nx = np.linspace(min_lim, max_lim, N)\n\n# exponential\ny_exp = base ** x\n\n# logarithm\ny_log = np.log(x[x&gt;0]) / np.log(base) \n\n# plot\nfig, ax = plt.subplots(ncols=1)\nax.plot(x, y_exp, label='$ y = a^x$')\nax.plot(x[x&gt;0], y_log, label='$y = \\log_a x$')\nax.plot(x*0.8, x*0.8, label='45 Degree Line', linestyle='--', color='gray')\nax.axhline(0, color='black', linewidth=0.5)\nax.axvline(0, color='black', linewidth=0.5)\nax.set_xlim(min_lim, max_lim)\nax.set_xticks([])\nax.set_yticks([])\nax.text(0, 0, 'O', fontsize=12, ha='right')\nax.text(1, -0.5, '1', fontsize=12, ha='right')\nax.text(0, 1, '1', fontsize=12, ha='right')\nax.set_ylim(min_lim, max_lim)\nax.set_xlabel('$x$')\nax.set_ylabel('$y$')\nfor spine in ax.spines.values():\n    spine.set_visible(False)\nax.legend()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 1: 指数関数と対数関数\n\n\n\n\n\nTheorem 1 \n任意の \\(a &gt; 0\\) に対して，\\(y = a^x\\) の導関数は\n\\[\n\\frac{d(a^x)}{dx} = a^x\\log a\n\\]\n\n\n\n\n\n\n\n\n\nNoteProof\n\n\n\n\n\n\\(a &gt; 1\\) のケースを考える\n\\[\n\\begin{align}\n\\frac{d(a^x)}{dx}\n    &= \\lim_{h\\to 0}\\frac{a^{x+h} - a^x}{h}\\\\\n    &= a^x\\lim_{h\\to 0}\\frac{a^{h} - 1}{h}\\label{base-eq}\n\\end{align}\n\\]\n ▶  \\(h &gt; 0\\)の場合\n\\(h &gt; 0\\) であるならば，\\(a^h &gt; 1\\)．よって\n\\[\na^h = 1 + \\frac{1}{t}\n\\]\nとおくと，\\(t &gt; 0\\)．指数関数の連続性より，\\(h\\to 0\\) のとき，\\(a^h\\to 1\\). 従って，\\(t\\to\\infty\\)．\nここで，\\(\\displaystyle h = \\log_a\\left(1 + \\frac{1}{t}\\right)\\) より\n\\[\n\\begin{align}\n\\frac{a^{h} - 1}{h}\n    & = \\frac{1/t}{\\log_a\\left(1 + \\frac{1}{t}\\right)}\\\\\n    &= \\frac{1}{\\log_a\\left(1 + \\frac{1}{t}\\right)^t}\n\\end{align}\n\\]\n\\[\n\\lim_{t\\to\\infty}\\left(1 + \\frac{1}{t}\\right)^t = e\n\\]\n対数関数 \\(\\log_a(x)\\) は連続関数なので，\\(h\\to 0\\) のとき，\\(\\log_a\\left(1 + \\frac{1}{t}\\right)^t\\to \\log_a e\\)．従って，\n\\[\n\\begin{align}\n\\lim_{h\\to 0}\\frac{a^{h} - 1}{h}\n    &= \\frac{1}{\\log_a e}\\\\\n    &= \\log a\n\\end{align}\n\\]\n ▶  \\(h &lt; 0\\)の場合\n\\(h = -z\\) を満たす \\(z&gt;0\\) を考える．このとき，\n\\[\n\\begin{align}\n\\frac{a^h - 1}{h}\n    &= \\frac{a^{-z} - 1}{-z}\\\\\n    &= \\frac{1 - a^z}{-z}\\frac{1}{a^z}\\\\\n    &= \\frac{a^z - 1}{z}\\frac{1}{a^z}\n\\end{align}\n\\]\n\\(z\\to 0\\) のとき，\\(a^z \\to 1\\) なので\n\\[\n\\frac{a^h - 1}{h}\\to \\log a\n\\]\n従って，\\(a &gt; 1\\) のとき，\\(\\displaystyle \\frac{d(a^x)}{dx} = a^x \\log a\\)\n ▶  \\(0 &lt; a &lt; 1\\) の場合 \n\\(\\eqref{base-eq}\\) と展開したとき，\\(h&gt;0\\) のとき \\(a^h &lt; 1\\) となるので\n\\[\na^h = 1 - \\frac{1}{t}\\qquad(t&gt;0)\n\\]\n指数関数の連続性より, \\(h\\to 0\\) のとき，\\(a^h\\to 0\\)，従って，\\(t\\to\\infty\\)．\n\\[\n\\begin{align}\n\\frac{a^h-1}{h}\n    &= \\frac{-\\frac{1}{t}}{\\log_a(1 - \\frac{1}{t})}\\\\\n    &= -\\frac{1}{\\log_a(1 - \\frac{1}{t})^{t}}\n\\end{align}\n\\]\nここで\n\\[\n\\lim_{t\\to\\infty} (1 - \\frac{1}{t})^{t} = \\frac{1}{e}\n\\]\nであるので，対数関数の連続性より，\\(h\\to 0\\) のとき \\(h\\to\\infty\\) だから\n\\[\n\\log_a\\left(1 - \\frac{1}{t}\\right)^{t}\\to \\log_a\\frac{1}{e} = -\\log_a e\n\\]\n従って，\n\\[\n\\lim_{h\\to 0}\\frac{a^h-1}{h} = \\log a\n\\]\n\\(h&lt;0\\) の場合も同様に示せるので，以上より\n任意の \\(a &gt; 0\\) に対して，\\(y = a^x\\) の導関数は\n\\[\n\\frac{d(a^x)}{dx} = a^x\\log a\n\\]\nが成立する．\n\n\n\n\n\n\\(a &gt; 0\\) としたとき，\n\\[\n\\log a^x = x\\log a\n\\]\nこのとき，両辺を \\(x\\) で微分すると\n\\[\n\\frac{D(a^x)}{a^x} = \\log a\n\\]\n従って，\n\\[\nD(a^x) = a^x\\log a\n\\]\nを得る．"
  },
  {
    "objectID": "posts/2025-01-27-differentiation_of_exponential_function/index.html#指数関数の微分",
    "href": "posts/2025-01-27-differentiation_of_exponential_function/index.html#指数関数の微分",
    "title": "指数関数の微分",
    "section": "",
    "text": "底 \\(a&gt;1\\) のとき，\n\n指数関数 \\(y = a^x\\) は区間 \\(-\\infty &lt; x &lt; \\infty\\) において連続かつ単調増大で, \\(y \\in (0, \\infty)\\)\n対数関数 \\(y = \\log_a x\\) は \\(y = a^x\\) の逆関数で，区間 \\(0 &lt; x &lt; \\infty\\) において連続かつ単調増大で, \\(y \\in (\\infty, \\infty)\\)\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# PARAMS\nbase = 2\nN = 1000 # data points\nmin_lim = -2\nmax_lim = 5\nx = np.linspace(min_lim, max_lim, N)\n\n# exponential\ny_exp = base ** x\n\n# logarithm\ny_log = np.log(x[x&gt;0]) / np.log(base) \n\n# plot\nfig, ax = plt.subplots(ncols=1)\nax.plot(x, y_exp, label='$ y = a^x$')\nax.plot(x[x&gt;0], y_log, label='$y = \\log_a x$')\nax.plot(x*0.8, x*0.8, label='45 Degree Line', linestyle='--', color='gray')\nax.axhline(0, color='black', linewidth=0.5)\nax.axvline(0, color='black', linewidth=0.5)\nax.set_xlim(min_lim, max_lim)\nax.set_xticks([])\nax.set_yticks([])\nax.text(0, 0, 'O', fontsize=12, ha='right')\nax.text(1, -0.5, '1', fontsize=12, ha='right')\nax.text(0, 1, '1', fontsize=12, ha='right')\nax.set_ylim(min_lim, max_lim)\nax.set_xlabel('$x$')\nax.set_ylabel('$y$')\nfor spine in ax.spines.values():\n    spine.set_visible(False)\nax.legend()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 1: 指数関数と対数関数\n\n\n\n\n\nTheorem 1 \n任意の \\(a &gt; 0\\) に対して，\\(y = a^x\\) の導関数は\n\\[\n\\frac{d(a^x)}{dx} = a^x\\log a\n\\]\n\n\n\n\n\n\n\n\n\nNoteProof\n\n\n\n\n\n\\(a &gt; 1\\) のケースを考える\n\\[\n\\begin{align}\n\\frac{d(a^x)}{dx}\n    &= \\lim_{h\\to 0}\\frac{a^{x+h} - a^x}{h}\\\\\n    &= a^x\\lim_{h\\to 0}\\frac{a^{h} - 1}{h}\\label{base-eq}\n\\end{align}\n\\]\n ▶  \\(h &gt; 0\\)の場合\n\\(h &gt; 0\\) であるならば，\\(a^h &gt; 1\\)．よって\n\\[\na^h = 1 + \\frac{1}{t}\n\\]\nとおくと，\\(t &gt; 0\\)．指数関数の連続性より，\\(h\\to 0\\) のとき，\\(a^h\\to 1\\). 従って，\\(t\\to\\infty\\)．\nここで，\\(\\displaystyle h = \\log_a\\left(1 + \\frac{1}{t}\\right)\\) より\n\\[\n\\begin{align}\n\\frac{a^{h} - 1}{h}\n    & = \\frac{1/t}{\\log_a\\left(1 + \\frac{1}{t}\\right)}\\\\\n    &= \\frac{1}{\\log_a\\left(1 + \\frac{1}{t}\\right)^t}\n\\end{align}\n\\]\n\\[\n\\lim_{t\\to\\infty}\\left(1 + \\frac{1}{t}\\right)^t = e\n\\]\n対数関数 \\(\\log_a(x)\\) は連続関数なので，\\(h\\to 0\\) のとき，\\(\\log_a\\left(1 + \\frac{1}{t}\\right)^t\\to \\log_a e\\)．従って，\n\\[\n\\begin{align}\n\\lim_{h\\to 0}\\frac{a^{h} - 1}{h}\n    &= \\frac{1}{\\log_a e}\\\\\n    &= \\log a\n\\end{align}\n\\]\n ▶  \\(h &lt; 0\\)の場合\n\\(h = -z\\) を満たす \\(z&gt;0\\) を考える．このとき，\n\\[\n\\begin{align}\n\\frac{a^h - 1}{h}\n    &= \\frac{a^{-z} - 1}{-z}\\\\\n    &= \\frac{1 - a^z}{-z}\\frac{1}{a^z}\\\\\n    &= \\frac{a^z - 1}{z}\\frac{1}{a^z}\n\\end{align}\n\\]\n\\(z\\to 0\\) のとき，\\(a^z \\to 1\\) なので\n\\[\n\\frac{a^h - 1}{h}\\to \\log a\n\\]\n従って，\\(a &gt; 1\\) のとき，\\(\\displaystyle \\frac{d(a^x)}{dx} = a^x \\log a\\)\n ▶  \\(0 &lt; a &lt; 1\\) の場合 \n\\(\\eqref{base-eq}\\) と展開したとき，\\(h&gt;0\\) のとき \\(a^h &lt; 1\\) となるので\n\\[\na^h = 1 - \\frac{1}{t}\\qquad(t&gt;0)\n\\]\n指数関数の連続性より, \\(h\\to 0\\) のとき，\\(a^h\\to 0\\)，従って，\\(t\\to\\infty\\)．\n\\[\n\\begin{align}\n\\frac{a^h-1}{h}\n    &= \\frac{-\\frac{1}{t}}{\\log_a(1 - \\frac{1}{t})}\\\\\n    &= -\\frac{1}{\\log_a(1 - \\frac{1}{t})^{t}}\n\\end{align}\n\\]\nここで\n\\[\n\\lim_{t\\to\\infty} (1 - \\frac{1}{t})^{t} = \\frac{1}{e}\n\\]\nであるので，対数関数の連続性より，\\(h\\to 0\\) のとき \\(h\\to\\infty\\) だから\n\\[\n\\log_a\\left(1 - \\frac{1}{t}\\right)^{t}\\to \\log_a\\frac{1}{e} = -\\log_a e\n\\]\n従って，\n\\[\n\\lim_{h\\to 0}\\frac{a^h-1}{h} = \\log a\n\\]\n\\(h&lt;0\\) の場合も同様に示せるので，以上より\n任意の \\(a &gt; 0\\) に対して，\\(y = a^x\\) の導関数は\n\\[\n\\frac{d(a^x)}{dx} = a^x\\log a\n\\]\nが成立する．\n\n\n\n\n\n\\(a &gt; 0\\) としたとき，\n\\[\n\\log a^x = x\\log a\n\\]\nこのとき，両辺を \\(x\\) で微分すると\n\\[\n\\frac{D(a^x)}{a^x} = \\log a\n\\]\n従って，\n\\[\nD(a^x) = a^x\\log a\n\\]\nを得る．"
  },
  {
    "objectID": "posts/2025-04-01-how-to-read-map/index.html",
    "href": "posts/2025-04-01-how-to-read-map/index.html",
    "title": "地図と標準誤差",
    "section": "",
    "text": "すべての地物は地図上で正しい位置に表現されるのが理想ですが，縮尺化して表される性質上，表現が細かくなりすぎて見えなくなる地物があります． このような場合，以下のような処理がなされる場合があります：\n\n\n\n\n\n\n\n\n\n処理\n内容\nコメント\n\n\n\n\n取捨選択\n描ききれない地物を間引く\n目的の地図に建物を描く必要がなければ取捨選択によって省略される\n\n\n総描\n地形の形状を誇張・省略する\n河川や登山道などは曲がっていることを地図上では示していて，どのように曲がっているかは示さない\n\n\n転位\n地物を元の位置からずらして表現する\n一般道の上を走っている高架道路は，そのまま描くと一般道と重なってしまうので転位によって意図的にずらして両方を地図上に表示させる\n\n\n\n\n\n\n\n\n\n\nNote基本ルール\n\n\n\n\n取捨選択に当たっては，表示対象物は縮尺に応じて適切に取捨選択し，かつ正確に表示する。また，重要度の高い対象物を省略することのないようにする\n総描に当たっては，現地の形状と相似性を保ち，形状の特徴を失わないようにする。必要に応じて形状を多少修飾して現状を理解しやすく総描する\n公共測量において，地図情報レベル2500の数値地形図に表示する地物の水平位置の転位は，原則として行わない\n\n\n\n\n\n\n\n\n\n取捨選択\n\n\n\n\n\n\n\n総描\n\n\n\n\n\n\n\n転位\n\n\n\n\n\n\nExample 1 幅1m未満の徒歩道と理由のある嘘\n「幅員 1.0m 未満の道路として、道路中心線が取得されている道路」がいわゆる幅1m未満の徒歩道ですが，平成２５年２万５千分１地形図図式（標準基準）では 0.2mmの線幅として表現されます．\n一方，２万５千分１であるので\n\n\nCode\nprint(f\"地図上0.2mm相当の実際の幅: {0.2 / 1000 * 25000} m\")\nprint(f\"1mの縮尺幅: {1/ 25000 * 1000} mm\")\n\n\n地図上0.2mm相当の実際の幅: 5.0 m\n1mの縮尺幅: 0.04 mm\n\n\nとなります．0.04 mmとして地図で表現してしまうと，そもそも徒歩道がどこにあるのか地図上での判別が難しくなってしまうので，「徒歩道がこのあたりに存在しますよ」という情報を伝えるのが目的であるならば， 太さを誇張して表記するのも理由があるとわかります．"
  },
  {
    "objectID": "posts/2025-04-01-how-to-read-map/index.html#地図上でのオブジェクトの位置表現",
    "href": "posts/2025-04-01-how-to-read-map/index.html#地図上でのオブジェクトの位置表現",
    "title": "地図と標準誤差",
    "section": "",
    "text": "すべての地物は地図上で正しい位置に表現されるのが理想ですが，縮尺化して表される性質上，表現が細かくなりすぎて見えなくなる地物があります． このような場合，以下のような処理がなされる場合があります：\n\n\n\n\n\n\n\n\n\n処理\n内容\nコメント\n\n\n\n\n取捨選択\n描ききれない地物を間引く\n目的の地図に建物を描く必要がなければ取捨選択によって省略される\n\n\n総描\n地形の形状を誇張・省略する\n河川や登山道などは曲がっていることを地図上では示していて，どのように曲がっているかは示さない\n\n\n転位\n地物を元の位置からずらして表現する\n一般道の上を走っている高架道路は，そのまま描くと一般道と重なってしまうので転位によって意図的にずらして両方を地図上に表示させる\n\n\n\n\n\n\n\n\n\n\nNote基本ルール\n\n\n\n\n取捨選択に当たっては，表示対象物は縮尺に応じて適切に取捨選択し，かつ正確に表示する。また，重要度の高い対象物を省略することのないようにする\n総描に当たっては，現地の形状と相似性を保ち，形状の特徴を失わないようにする。必要に応じて形状を多少修飾して現状を理解しやすく総描する\n公共測量において，地図情報レベル2500の数値地形図に表示する地物の水平位置の転位は，原則として行わない\n\n\n\n\n\n\n\n\n\n取捨選択\n\n\n\n\n\n\n\n総描\n\n\n\n\n\n\n\n転位\n\n\n\n\n\n\nExample 1 幅1m未満の徒歩道と理由のある嘘\n「幅員 1.0m 未満の道路として、道路中心線が取得されている道路」がいわゆる幅1m未満の徒歩道ですが，平成２５年２万５千分１地形図図式（標準基準）では 0.2mmの線幅として表現されます．\n一方，２万５千分１であるので\n\n\nCode\nprint(f\"地図上0.2mm相当の実際の幅: {0.2 / 1000 * 25000} m\")\nprint(f\"1mの縮尺幅: {1/ 25000 * 1000} mm\")\n\n\n地図上0.2mm相当の実際の幅: 5.0 m\n1mの縮尺幅: 0.04 mm\n\n\nとなります．0.04 mmとして地図で表現してしまうと，そもそも徒歩道がどこにあるのか地図上での判別が難しくなってしまうので，「徒歩道がこのあたりに存在しますよ」という情報を伝えるのが目的であるならば， 太さを誇張して表記するのも理由があるとわかります．"
  },
  {
    "objectID": "posts/2025-04-01-how-to-read-map/index.html#ボーリング調査でトンネル貫通",
    "href": "posts/2025-04-01-how-to-read-map/index.html#ボーリング調査でトンネル貫通",
    "title": "地図と標準誤差",
    "section": "ボーリング調査でトンネル貫通",
    "text": "ボーリング調査でトンネル貫通\n\n\n\n\n\n\nNote事実\n\n\n\n2019年7月11日に午前10時25分ごろ，長崎発博多行きの特急「かもめ16号」が，トンネルの天井を貫通した掘削機に接触． 異音を聞いた乗務員が列車を緊急停車させ，先頭車両の前面左側などに損傷があるのを確認した．\n\n\n上記の事故原因としてに鉄道・運輸機構から以下のように発表されています\n\nボーリング工事発注の際に国土地理院の地図（2万5千分の1地形図）に基づき作成した発注図面において JR 長崎本線長崎トンネルの位置が、実際の位置と異なっていた．\n長崎トンネルとボーリング工事の位置が図面上で約 80ｍ離れていたため，ボーリング工事による長崎トンネルへの影響はないものと判断し，ボーリング工事前に現地で十分な確認を行っていなかった\n\n\n80m の誤差の程度\n「図面上で約 80ｍ離れていた」とありますが，2万5千分の1地形図だと80mのずれは髪の紙面上で\n\n\nCode\nerror_mm = 80 / 25000 * 1000\nprint(f\"{error_mm} mm誤差\")\n\n\n3.2 mm誤差\n\n\nとなります．また，国土地理院の地理院地図では，建物の形状が見える地図の拡大率における水平精度は原則として「17.5m(標準誤差)」となっており，地図が現実世界のすべてを精確に表現している訳ではありません． そのため，\n\n\n\n\n\n\n\n理由\nコメント\n\n\n\n\nボーリング工事発注の際に国土地理院の地図（2万5千分の1地形図）に基づき作成した発注図面において JR 長崎本線長崎トンネルの位置が、実際の位置と異なっていた．\n実際の位置と異なるのは想定の範囲内であるべき\n\n\n長崎トンネルとボーリング工事の位置が図面上で約 80ｍ離れていたため，ボーリング工事による長崎トンネルへの影響はないものと判断し，ボーリング工事前に現地で十分な確認を行っていなかった\n2万5千分の1地形図のような中縮尺地図で，構造物の精確な位置を判断するのが間違っている\n\n\n\nと考えるべきだと思います．"
  },
  {
    "objectID": "posts/2025-04-01-how-to-read-map/index.html#references",
    "href": "posts/2025-04-01-how-to-read-map/index.html#references",
    "title": "地図と標準誤差",
    "section": "References",
    "text": "References\n\n報道発表資料 JR 長崎本線長崎トンネル内で発生させた重大事故（渇水対策を目的とした試掘ボーリングによる走行車両との接触）の原因と対策について"
  },
  {
    "objectID": "posts/2025-09-02-thesis-statement/index.html",
    "href": "posts/2025-09-02-thesis-statement/index.html",
    "title": "Thesis Statementの書き方",
    "section": "",
    "text": "Definition 1 論文ステートメント(Thesis Statement)\n\n分析プロジェクトにおいて，ベースとなる主張(Argument)/立場(Position)を簡潔に示したもの\n単なる事実の記述ではなく，反論可能（arguable / contestable）な主張であること\n\n\nThesis Statement と 研究計画書 の違い\n\n\n\n\n\n\n\n\n\n項目\nThesis Statement\n研究計画書 (Research Proposal)\n\n\n\n\n目的\n分析プロジェクトにおける 中心的な主張を提示\n研究を実施するための 背景・目的・方法・意義を説明\n\n\n長さ\n1〜2文\n数ページ〜十数ページ\n\n\n位置づけ\n論文本文の冒頭に配置し，論理展開の「背骨」になる\nプロジェクトの開始前に提出される「実行計画書」\n\n\n内容\n- テーマに対する立場（position）- 主張の根拠の方向性（x, y, z）\n- 研究背景・問題設定- 先行研究レビュー- 研究課題・仮説- 方法・データ- 期待される成果・貢献- 研究スケジュール\n\n\n性質\n宣言的（「私はこう主張する」）\n計画的（「私はこう研究する予定だ」）\n\n\n\n\n\n\n\n読者に対して「論文が何を主張するか」「なぜ重要か」を示す\n論文や研究が何にフォーカスしているのかを示す\n主張を証明するにあたって，研究がどのようなロジック・構成となるのかを示す"
  },
  {
    "objectID": "posts/2025-09-02-thesis-statement/index.html#thesis-statementとは",
    "href": "posts/2025-09-02-thesis-statement/index.html#thesis-statementとは",
    "title": "Thesis Statementの書き方",
    "section": "",
    "text": "Definition 1 論文ステートメント(Thesis Statement)\n\n分析プロジェクトにおいて，ベースとなる主張(Argument)/立場(Position)を簡潔に示したもの\n単なる事実の記述ではなく，反論可能（arguable / contestable）な主張であること\n\n\nThesis Statement と 研究計画書 の違い\n\n\n\n\n\n\n\n\n\n項目\nThesis Statement\n研究計画書 (Research Proposal)\n\n\n\n\n目的\n分析プロジェクトにおける 中心的な主張を提示\n研究を実施するための 背景・目的・方法・意義を説明\n\n\n長さ\n1〜2文\n数ページ〜十数ページ\n\n\n位置づけ\n論文本文の冒頭に配置し，論理展開の「背骨」になる\nプロジェクトの開始前に提出される「実行計画書」\n\n\n内容\n- テーマに対する立場（position）- 主張の根拠の方向性（x, y, z）\n- 研究背景・問題設定- 先行研究レビュー- 研究課題・仮説- 方法・データ- 期待される成果・貢献- 研究スケジュール\n\n\n性質\n宣言的（「私はこう主張する」）\n計画的（「私はこう研究する予定だ」）\n\n\n\n\n\n\n\n読者に対して「論文が何を主張するか」「なぜ重要か」を示す\n論文や研究が何にフォーカスしているのかを示す\n主張を証明するにあたって，研究がどのようなロジック・構成となるのかを示す"
  },
  {
    "objectID": "posts/2025-09-02-thesis-statement/index.html#thesis-statementの書き方",
    "href": "posts/2025-09-02-thesis-statement/index.html#thesis-statementの書き方",
    "title": "Thesis Statementの書き方",
    "section": "Thesis Statementの書き方",
    "text": "Thesis Statementの書き方\n\n\n\n\n\n\nNote(1) Research Questionから始める\n\n\n\n\nまず，自分が明らかにしたい問い（Research Question）を定める\nRQは「Yes/No」で答えられる形，あるいは「AとBの関係はどうか？」という形式が望ましい\nなぜ定義したResearch Questionが重要なのか？どのような貢献があるのか？を記述する\n\n\n\n\nExample 1 Research Question例\n\n例（経済学）: Does an increase in minimum wage reduce employment in the service sector?\n例（ML）: Can Physics-Informed ML outperform black-box ML under small sample regimes?\n\n\n\n\n\n\n\n\n\nNote(2) 立場（Position）を明確にする\n\n\n\n\nその問いに対して自分はどの立場を取るのかを一文で表現する\n「私の仮説は〜である」よりも，「〜である」と断定的に書く方がThesis Statementらしい\n形式や文字数よりも 主張の明確さと論理的整合性が重要\n\n\n\n\nExample 2 記述とポジショニングの違い\n\n\n\n\n\n\n\n\n❌ Not a thesis（事実や説明だけ）\n✅ Possible thesis（主張・立場がある）\n\n\n\n\n空は青い．\n空が青く見えるのは，大気上層における光と化学的相互作用の複雑な影響によるものである．\n\n\nハリー・ポッターはJ.K.ローリングによって書かれた本である．\n『ハリー・ポッター』は，マグルと魔法界の関係性を通じて偏見の理解に影響を与え，一世代の価値観を形成した本である．\n\n\nテリー・フォックスはカナダ史において重要な人物である．\nテリー・フォックスは，他のどのカナダ人よりも医学研究に大きな影響を与えてきた．\n\n\n\n\n\n\n\n\n\n\n\n\nNote(3) 主張の根拠の方向性を示す\n\n\n\n\n「なぜその主張を支持できるのか」の論拠を簡潔に述べる\nどのようなロジックを用いる予定なのか，読者にイメージを与える\n\n\n\n\n\n\n\n\n\nNote(4) Statementの記述タイミング\n\n\n\n\nThesis Statement は柔軟で分析や思考の過程に合わせて発展させるもの\n執筆中に修正しても構わない，むしろ推奨される\n\n\n\n\nThesis Statement チェックリスト\n\n1. Arguable（論争可能か） : 主張が単なる事実ではなく、読者が賛否を考えられる内容か\n2. Specific（具体性） : 主張が抽象的すぎず、論文内で十分に証明可能な焦点を持っている\n3. Constructs / Variables（構成要素の明確化） : 研究対象や変数、概念が明確に示されているか\n4. Relationship / Claim（関係・主張の明確化） : 構成要素間の関係や立場が具体的に述べられているか\n5. Scope（論文の範囲に適合しているか） : 論文の長さ・範囲内で十分に議論・証明可能か\n6. Significance / “So what?”（意義が示されているか） : なぜこの主張が重要なのか、読者が関心を持つ理由が示されている\n7. Roadmap（論文の展開を予告しているか） : サブポイントや分析の方向性が簡単に示されているか\n8. Clarity / Precision（明確さと正確さ） : キーワード・動詞・文の構造が明確で理解しやすいか\n9. Tentative / Flexible（暫定的に作成しているか） : 初稿で完璧でなくてもよい。執筆中に修正可能か\n10. Length（長さの適切さ） : 1〜2文、または複雑な場合は段落で表現可能か"
  },
  {
    "objectID": "posts/2025-09-02-thesis-statement/index.html#references",
    "href": "posts/2025-09-02-thesis-statement/index.html#references",
    "title": "Thesis Statementの書き方",
    "section": "References",
    "text": "References\n\nSimon Fraser University &gt; Writing thesis statements"
  },
  {
    "objectID": "posts/2025-12-09-create-calendar-table/index.html",
    "href": "posts/2025-12-09-create-calendar-table/index.html",
    "title": "ISO 8601 カレンダーテーブルの作成",
    "section": "",
    "text": "Definition 1 ISO 8601\n\n日付と時刻の表現形式に関する ISO の国際標準\nグレゴリオ暦の西暦2016年3月25日は 2016-03-25 と表記する\n\n\n日付を 01/05/22 と数字で表す場合，\n\n2022-01-05\n2022-05-01\n\nのどちらでも解釈できてしまいます．ISO 8601 は，このような混乱を解消するために日付の国際的な表記方法を定めた規格です． 日本では日本産業規格の JIS X 0301 にて，ISO 8601 と同等の内容が採用されています．\n\n\n\nDefinition 2 日付表記\n\nISO 8601 では，日付は 年・月・日を左から順に並べる形式とし，半角数字・ハイフン区切りで表す\n\n\nYYYY-MM-DD\n\nYYYY：西暦年（4桁．年の表記は 0000年～9999年 を想定）\nMM：月（2桁．1桁の場合は先頭に 0 を付与）\nDD：日（2桁．1桁の場合は先頭に 0 を付与）\n\n\n\n\n\n\n\nNote\n\n\n\n\n0000年より前または9999年より後の年を表記する場合には，事前に通信の送信側と受信側との間での合意が必要\nYYYYMMDD という表記もあり得る\n\n\n\n\n\n\n\nDefinition 3 曜日表記\n\nISO 8601 では，週の始まりは月曜日（=1） と定められており，曜日は 1〜7 の整数値で表される\n日本の商習慣では「日曜始まり」のカレンダーが多い点に注意\n\n\n\n\n\n数値\n曜日\n\n\n\n\n1\n月曜日\n\n\n2\n火曜日\n\n\n3\n水曜日\n\n\n4\n木曜日\n\n\n5\n金曜日\n\n\n6\n土曜日\n\n\n7\n日曜日\n\n\n\n\n\n\n\nDefinition 4 時刻表記\n\nISO 8601 の時刻は 24 時間制で，コロン区切りとする\n\n\nhh:mm:ss\n\nhh：時（00–24）\nmm：分（00–59）\nss：秒（00–59，必要に応じて小数も可）\n\n\nExample 1 (ミリ秒とマイクロ秒) \n14:30:00.123   （ミリ秒）\n14:30:00.123456（マイクロ秒）\n\n\n\n\n\n\nDefinition 5 Datetime\n\nISO 8601 では，日付と時刻を組み合わせる場合 T を連結文字として使用する\n必要に応じて UTC との時差（オフセット）を付与する\n\nYYYY-MM-DDThh:mm:ss[±hh:mm]\n\nタイムゾーン省略時は「ローカル時刻」とみなされるため，システム間連携ではオフセット付与版が望ましいとされます． というかプログラミングで扱うときは，基本的にはオフセット付与版を用いましょう．\n\nExample 2 \n2025-12-09T14:30:00+09:00   # 日本標準時 (JST)\n2025-12-09T05:30:00Z        # UTC（Z は +00:00 と等価）\n\n\n\n\n\n\nDefinition 6 ISOWEEK\n\nISO-8601 という国際標準で定められた「週番号」の体系\n\nDate                2025-12-08\nWeek                2025-W50\nWeek with weekday   2025-W50-1\n\nISOWEEK計算アルゴリズム\n\n年初からの通算日（day of year）から，その日の ISO 曜日番号を引く\nその結果に 10 を加える\n7 で割り，余りを切り捨てる\n\nその後，次の判定を行う\n\n計算結果が 0 の場合: この日付は 前年の最終週（週番号 52 または 53）\n計算結果が 53 の場合:\n\nその年に ISO 週 53 が存在するか確認\n存在しない年の場合，この日付は 翌年の週 1\n\n\n\n\n\\begin{algorithm} \\caption{ISO Week Number Calculation} \\begin{algorithmic} \\Procedure{WeekdayOfDec31}{$y$} \\State $p = (\\, y + \\lfloor y/4 \\rfloor - \\lfloor y/100 \\rfloor + \\lfloor y/400 \\rfloor \\,) \\bmod 7$ \\Return $p$ \\EndProcedure \\State \\Procedure{WeeksInYear}{$y$} \\State $p_y$ = \\Call{WeekdayOfDec31}{$y$} \\State $p_{y-1}$ = \\Call{WeekdayOfDec31}{$y-1$} \\If{$p_y = 4 \\ OR \\ p_{y-1} = 3$} \\Return $53$ \\Else \\Return $52$ \\EndIf \\EndProcedure \\State \\Procedure{ISOWeek}{$date$} \\State $y = year(date)$ \\State $doy = doy(date)$ $\\,\\,\\,\\,\\,$ \\Comment{ day of year} \\State $dow = dow(date)$ $\\,\\,\\,\\,\\,$\\Comment{ISO weekday: 1=Mon,...,7=Sun} \\State $w = \\left\\lfloor \\dfrac{10 + doy - dow}{7} \\right\\rfloor$ \\If{$w &lt; 1$} \\Return \\Call{WeeksInYear}{$y-1$} \\ElsIf{$w$ &gt; \\Call{WeeksInYear}{$y$}} \\Return $1$ \\Else \\Return $w$ \\EndIf \\EndProcedure \\end{algorithmic} \\end{algorithm}"
  },
  {
    "objectID": "posts/2025-12-09-create-calendar-table/index.html#iso-8601-とは",
    "href": "posts/2025-12-09-create-calendar-table/index.html#iso-8601-とは",
    "title": "ISO 8601 カレンダーテーブルの作成",
    "section": "",
    "text": "Definition 1 ISO 8601\n\n日付と時刻の表現形式に関する ISO の国際標準\nグレゴリオ暦の西暦2016年3月25日は 2016-03-25 と表記する\n\n\n日付を 01/05/22 と数字で表す場合，\n\n2022-01-05\n2022-05-01\n\nのどちらでも解釈できてしまいます．ISO 8601 は，このような混乱を解消するために日付の国際的な表記方法を定めた規格です． 日本では日本産業規格の JIS X 0301 にて，ISO 8601 と同等の内容が採用されています．\n\n\n\nDefinition 2 日付表記\n\nISO 8601 では，日付は 年・月・日を左から順に並べる形式とし，半角数字・ハイフン区切りで表す\n\n\nYYYY-MM-DD\n\nYYYY：西暦年（4桁．年の表記は 0000年～9999年 を想定）\nMM：月（2桁．1桁の場合は先頭に 0 を付与）\nDD：日（2桁．1桁の場合は先頭に 0 を付与）\n\n\n\n\n\n\n\nNote\n\n\n\n\n0000年より前または9999年より後の年を表記する場合には，事前に通信の送信側と受信側との間での合意が必要\nYYYYMMDD という表記もあり得る\n\n\n\n\n\n\n\nDefinition 3 曜日表記\n\nISO 8601 では，週の始まりは月曜日（=1） と定められており，曜日は 1〜7 の整数値で表される\n日本の商習慣では「日曜始まり」のカレンダーが多い点に注意\n\n\n\n\n\n数値\n曜日\n\n\n\n\n1\n月曜日\n\n\n2\n火曜日\n\n\n3\n水曜日\n\n\n4\n木曜日\n\n\n5\n金曜日\n\n\n6\n土曜日\n\n\n7\n日曜日\n\n\n\n\n\n\n\nDefinition 4 時刻表記\n\nISO 8601 の時刻は 24 時間制で，コロン区切りとする\n\n\nhh:mm:ss\n\nhh：時（00–24）\nmm：分（00–59）\nss：秒（00–59，必要に応じて小数も可）\n\n\nExample 1 (ミリ秒とマイクロ秒) \n14:30:00.123   （ミリ秒）\n14:30:00.123456（マイクロ秒）\n\n\n\n\n\n\nDefinition 5 Datetime\n\nISO 8601 では，日付と時刻を組み合わせる場合 T を連結文字として使用する\n必要に応じて UTC との時差（オフセット）を付与する\n\nYYYY-MM-DDThh:mm:ss[±hh:mm]\n\nタイムゾーン省略時は「ローカル時刻」とみなされるため，システム間連携ではオフセット付与版が望ましいとされます． というかプログラミングで扱うときは，基本的にはオフセット付与版を用いましょう．\n\nExample 2 \n2025-12-09T14:30:00+09:00   # 日本標準時 (JST)\n2025-12-09T05:30:00Z        # UTC（Z は +00:00 と等価）\n\n\n\n\n\n\nDefinition 6 ISOWEEK\n\nISO-8601 という国際標準で定められた「週番号」の体系\n\nDate                2025-12-08\nWeek                2025-W50\nWeek with weekday   2025-W50-1\n\nISOWEEK計算アルゴリズム\n\n年初からの通算日（day of year）から，その日の ISO 曜日番号を引く\nその結果に 10 を加える\n7 で割り，余りを切り捨てる\n\nその後，次の判定を行う\n\n計算結果が 0 の場合: この日付は 前年の最終週（週番号 52 または 53）\n計算結果が 53 の場合:\n\nその年に ISO 週 53 が存在するか確認\n存在しない年の場合，この日付は 翌年の週 1\n\n\n\n\n\\begin{algorithm} \\caption{ISO Week Number Calculation} \\begin{algorithmic} \\Procedure{WeekdayOfDec31}{$y$} \\State $p = (\\, y + \\lfloor y/4 \\rfloor - \\lfloor y/100 \\rfloor + \\lfloor y/400 \\rfloor \\,) \\bmod 7$ \\Return $p$ \\EndProcedure \\State \\Procedure{WeeksInYear}{$y$} \\State $p_y$ = \\Call{WeekdayOfDec31}{$y$} \\State $p_{y-1}$ = \\Call{WeekdayOfDec31}{$y-1$} \\If{$p_y = 4 \\ OR \\ p_{y-1} = 3$} \\Return $53$ \\Else \\Return $52$ \\EndIf \\EndProcedure \\State \\Procedure{ISOWeek}{$date$} \\State $y = year(date)$ \\State $doy = doy(date)$ $\\,\\,\\,\\,\\,$ \\Comment{ day of year} \\State $dow = dow(date)$ $\\,\\,\\,\\,\\,$\\Comment{ISO weekday: 1=Mon,...,7=Sun} \\State $w = \\left\\lfloor \\dfrac{10 + doy - dow}{7} \\right\\rfloor$ \\If{$w &lt; 1$} \\Return \\Call{WeeksInYear}{$y-1$} \\ElsIf{$w$ &gt; \\Call{WeeksInYear}{$y$}} \\Return $1$ \\Else \\Return $w$ \\EndIf \\EndProcedure \\end{algorithmic} \\end{algorithm}"
  },
  {
    "objectID": "posts/2025-12-09-create-calendar-table/index.html#カレンダーとプログラミング",
    "href": "posts/2025-12-09-create-calendar-table/index.html#カレンダーとプログラミング",
    "title": "ISO 8601 カレンダーテーブルの作成",
    "section": "カレンダーとプログラミング",
    "text": "カレンダーとプログラミング\n\nシェルでISOWEEK計算\n\nDefinition 7 date コマンド\ndate +%V\nを実行すると，現在時刻のISO WEEKが表示される\n\n関連オプション\n\n\n\n\nフォーマット\n意味\n\n\n\n\n%V\nISO 8601 週番号（01–53）\n\n\n%G\nISO 年（week-based year）\n\n\n%g\nISO 年（下2桁）\n\n\n%u\nISO 曜日（1=Mon〜7=Sun）\n\n\n%a\n曜日名（Mon, Tue, …）\n\n\n\n\n\nExample 3 (UTC vs Asia/Tokyo) \n$ date +%V -d '2024-12-30T08:00:00.123213+09:00' -u\n52\n\n$ date +%V -d '2024-12-30T08:00:00.123213+00:00' -u\n01\n\n\n\n\n日付レンジからカレンダーテーブルの作成\n\n\n\n\n\n\nNoteGoal\n\n\n\n\nYYYY-MM-DD 形式の２つの引数を入力すると，指定した開始日から終了日までの日付範囲を1日ずつ列挙したテーブル形式で出力する関数を作成\n\n$ date-table 2020-01-01 2020-01-10   \n\ndate,weekday,iso_day_of_week,isoweek,day_of_year\n2020-01-01,Wed,3,01,001\n2020-01-02,Thu,4,01,002\n2020-01-03,Fri,5,01,003\n2020-01-04,Sat,6,01,004\n2020-01-05,Sun,7,01,005\n2020-01-06,Mon,1,02,006\n2020-01-07,Tue,2,02,007\n2020-01-08,Wed,3,02,008\n2020-01-09,Thu,4,02,009\n2020-01-10,Fri,5,02,010\n\n\n実装例\n\nBashPython + datetimeモジュールPandasPolarsBigQuery with UDF Table\n\n\n#!/bin/bash\n# -----------------------------------------------------------------------------\n# Author: Ryo Nakagami\n# Revised: 2025-12-09\n# Script: date-table\n# Description:\n#   Generates a CSV table of dates and their properties for a given date range.\n#   Outputs columns for date, weekday, ISO day of week, ISO week number, and\n#   day of year, with options to select which columns to display.\n#\n#   Steps:\n#     1. Parse and validate command-line options and arguments.\n#     2. Validate input dates (format and calendar existence).\n#     3. Set output columns based on options (default: all columns).\n#     4. Print CSV header.\n#     5. Iterate from start to end date, printing each row with selected fields.\n#\n# Options:\n#    -a    Show weekday column\n#    -u    Show ISO day of week column\n#    -V    Show ISO week number column\n#    -j    Show day of year column\n#    -h    Show this help message\n#\n# Usage:\n#   ./date-table [-a] [-u] [-V] [-j] &lt;start-date&gt; &lt;end-date&gt;\n#     # Outputs a CSV table for the date range, with selected columns.\n#\n# Notes:\n#   - Requires bash, GNU date, and coreutils installed.\n#   - Dates must be in YYYY-MM-DD format.\n#   - Exits with error if dates are invalid or out of order.\n# -----------------------------------------------------------------------------\nset -euo pipefail\n\n# --- Validate YYYY-MM-DD ---\nvalidate_ymd() {\n    local d=\"$1\"\n\n    # Format check\n    if [[ ! $d =~ ^[0-9]{4}-[0-9]{2}-[0-9]{2}$ ]]; then\n        echo \"Error: Invalid format '$d'. Expected YYYY-MM-DD.\" &gt;&2\n        exit 1\n    fi\n\n    # Calendar existence check\n    local norm\n    if ! norm=$(date -d \"$d\" +%Y-%m-%d 2&gt;/dev/null); then\n        echo \"Error: '$d' is not a real date.\" &gt;&2\n        exit 1\n    fi\n\n    # Reject auto-corrected dates (e.g., 2025-02-30 → 2025-03-02)\n    if [[ \"$norm\" != \"$d\" ]]; then\n        echo \"Error: '$d' is not a valid calendar date.\" &gt;&2\n        exit 1\n    fi\n}\n\n# --- Option parsing ---\nshow_weekday=false\nshow_iso_day=false\nshow_isoweek=false\nshow_day_of_year=false\nopt_specified=false\n\nwhile getopts \"auVj\" opt; do\n    opt_specified=true\n    case $opt in\n        a) show_weekday=true ;;\n        u) show_iso_day=true ;;\n        V) show_isoweek=true ;;\n        j) show_day_of_year=true ;;\n    esac\ndone\n \nshift $((OPTIND - 1))\n\nif [[ $# -ne 2 ]]; then\n    echo \"Usage: $0 [-a] [-u] [-V] [-j] &lt;start-date&gt; &lt;end-date&gt;\" &gt;&2\n    exit 1\nfi\n\nstart_date=\"$1\"\nend_date=\"$2\"\n\nvalidate_ymd \"$start_date\"\nvalidate_ymd \"$end_date\"\n\n# Ensure start &lt;= end\nif [[ \"$start_date\" &gt; \"$end_date\" ]]; then\n    echo \"Error: start_date &gt; end_date\" &gt;&2\n    exit 1\nfi\n\n# If no options specified → output all\nif ! $opt_specified; then\n    show_weekday=true\n    show_iso_day=true\n    show_isoweek=true\n    show_day_of_year=true\nfi\n\n# --- Print header ---\nprintf \"date\"\n$show_weekday    && printf \",weekday\"\n$show_iso_day    && printf \",iso_day_of_week\"\n$show_isoweek    && printf \",isoweek\"\n$show_day_of_year && printf \",day_of_year\"\nprintf \"\\n\"\n\n# --- Generate rows ---\ncurrent=\"$start_date\"\nwhile true; do\n\n    weekday=$(date -d \"$current\" +%a)\n    iso_day=$(date -d \"$current\" +%u)\n    isoweek=$(date -d \"$current\" +%V)\n    doy=$(date -d \"$current\" +%j)\n\n    printf \"%s\" \"$current\"\n    $show_weekday     && printf \",%s\" \"$weekday\"\n    $show_iso_day     && printf \",%s\" \"$iso_day\"\n    $show_isoweek     && printf \",%s\" \"$isoweek\"\n    $show_day_of_year && printf \",%s\" \"$doy\"\n\n    printf \"\\n\"\n\n    [[ \"$current\" == \"$end_date\" ]] && break\n\n    current=$(date -d \"$current +1 day\" +%Y-%m-%d)\ndone\n\n\nfrom datetime import datetime, timedelta\n\ndef date_table(start_date: str, end_date: str):\n    start = datetime.fromisoformat(start_date).date()\n    end = datetime.fromisoformat(end_date).date()\n\n    delta = end - start\n\n    result = []\n    for i in range(delta.days + 1):\n        d = start + timedelta(days=i)\n        result.append(\n            {\n                \"date\": d,\n                \"date_str\": d.isoformat(),\n                \"weekday\": d.strftime(\"%a\"),  # Mon, Tue ...\n                \"iso_day_of_week\": d.isoweekday(),  # 1=Mon ... 7=Sun\n                \"isoweek\": d.isocalendar()[1],  # ISO week number\n                \"day_of_year\": d.timetuple().tm_yday,  # 1〜365/366\n            }\n        )\n    return result\n\n\nimport pandas as pd\n\n\ndef date_table_pd(start_date: str, end_date: str) -&gt; pd.DataFrame:\n    # date range\n    dates = pd.date_range(start=start_date, end=end_date, freq=\"D\")\n\n    df = pd.DataFrame(\n        {\n            \"date\": dates.date,  # date object\n            \"date_str\": dates.strftime(\"%Y-%m-%d\"),\n            \"weekday\": dates.strftime(\"%a\"),  # Mon, Tue, ...\n            \"iso_day_of_week\": dates.isocalendar().day.values.astype(int),  # 1–7\n            \"isoweek\": dates.isocalendar().week.values.astype(int),  # ISO week number\n            \"day_of_year\": dates.dayofyear.values.astype(int),  # 1–366\n        }\n    )\n\n    return df\n\ndates.isocalendar().day などは Date Index付 pandas.core.series.Series で返してしまうので .values を使用\n\n\n\nimport polars as pl\nfrom datetime import date\n\n\ndef date_table_pl(start_date: str, end_date: str) -&gt; pl.DataFrame:\n    # reformat to date object\n    start = date.fromisoformat(start_date)\n    end = date.fromisoformat(end_date)\n\n    # date range\n    dates = pl.date_range(start=start, end=end, interval=\"1d\", eager=True)\n\n    df = pl.DataFrame({\"date\": dates}).with_columns(\n        [\n            pl.col(\"date\").dt.to_string(\"%Y-%m-%d\").alias(\"date_str\"),\n            pl.col(\"date\").dt.strftime(\"%a\").alias(\"weekday\"),\n            pl.col(\"date\").dt.weekday().alias(\"iso_day_of_week\"),\n            pl.col(\"date\").dt.week().alias(\"isoweek\"),\n            pl.col(\"date\").dt.ordinal_day().alias(\"day_of_year\"),\n        ]\n    )\n\n    return df\n\n\n\nテーブル関数用のData setの作成\n\nCREATE SCHEMA `hogehoge-project.utility_table`\nOPTIONS (location=\"asia-northeast1\");\n\nテーブル関数作成 (CREATE TABLE FUNCTION)\n\nBigQuery の DAYOFWEEK が Sunday=1 であるのでISO8601形式に変換\nCREATE OR REPLACE TABLE FUNCTION\n  `hogehoge-project.utility_table.date_table`(start_date DATE, end_date DATE)\nAS (\n  SELECT\n    d AS date,\n    FORMAT_DATE('%Y-%m-%d', d) AS date_str,\n    FORMAT_DATE('%a', d) AS weekday,\n    MOD(EXTRACT(DAYOFWEEK FROM d) + 5, 7) + 1 AS iso_day_of_week,\n    EXTRACT(ISOWEEK FROM d) AS isoweek,\n    EXTRACT(DAYOFYEAR FROM d) AS day_of_year\n  FROM\n    UNNEST(GENERATE_DATE_ARRAY(start_date, end_date, INTERVAL 1 DAY)) AS d\n);\n\n実行\n\nSELECT *\nFROM \n  `hogehoge-project.utility_table.date_table`('2025-02-01', '2025-02-10');"
  },
  {
    "objectID": "posts/2025-12-09-create-calendar-table/index.html#references",
    "href": "posts/2025-12-09-create-calendar-table/index.html#references",
    "title": "ISO 8601 カレンダーテーブルの作成",
    "section": "References",
    "text": "References\n\nPython Documentation &gt; datetime — 基本的な日付と時間の型"
  },
  {
    "objectID": "posts/2025-10-30-branch-strategy/index.html",
    "href": "posts/2025-10-30-branch-strategy/index.html",
    "title": "Git Flow–based branch strategy",
    "section": "",
    "text": "Git Flow をベースにしたブランチ戦略を採用\nリリース系列ブランチ，developを統合ブランチとするが，Issue規模・リリース運用の実態に合わせて，Issue用の統合ブランチを活用\n\n\n\n\n\n\n%%{ init: {\n    'theme': 'default',\n    'themeVariables': {\n        'fontFamily': 'Meiryo'\n    },\n    'gitGraph': {\n        'orientation': 'LR',\n        'nodeSpacing': 150,\n        'mainBranchName': 'main'\n    }\n} }%%\n\ngitGraph\n   commit id: \"\" tag: \"v1.0.0\"\n\n   branch hotfix\n   checkout hotfix\n   commit id: \"BUGFIX\"\n\n   checkout main\n   branch develop\n   checkout develop\n   commit id: \"開発開始\"\n\n   branch feature/0001/login\n   checkout feature/0001/login\n   commit id: \"\"\n\n   checkout main\n   merge hotfix tag: \"v1.0.1\"\n\n   checkout develop\n   merge hotfix\n   commit id: \"incorporate hotfix\"\n\n   checkout develop\n   merge feature/0001/login\n   commit id: \"ログイン機能実装\"\n\n   branch release/1.1.x\n   checkout release/1.1.x\n   commit id: \"リリース準備\"\n   commit id: \"bugfix\"\n\n   checkout develop\n   merge release/1.1.x\n\n   checkout main\n   merge release/1.1.x  tag: \"v1.1.0\"\n\n   checkout develop\n   commit id: \"FEATURE\""
  },
  {
    "objectID": "posts/2025-10-30-branch-strategy/index.html#branch-strategy",
    "href": "posts/2025-10-30-branch-strategy/index.html#branch-strategy",
    "title": "Git Flow–based branch strategy",
    "section": "",
    "text": "Git Flow をベースにしたブランチ戦略を採用\nリリース系列ブランチ，developを統合ブランチとするが，Issue規模・リリース運用の実態に合わせて，Issue用の統合ブランチを活用\n\n\n\n\n\n\n%%{ init: {\n    'theme': 'default',\n    'themeVariables': {\n        'fontFamily': 'Meiryo'\n    },\n    'gitGraph': {\n        'orientation': 'LR',\n        'nodeSpacing': 150,\n        'mainBranchName': 'main'\n    }\n} }%%\n\ngitGraph\n   commit id: \"\" tag: \"v1.0.0\"\n\n   branch hotfix\n   checkout hotfix\n   commit id: \"BUGFIX\"\n\n   checkout main\n   branch develop\n   checkout develop\n   commit id: \"開発開始\"\n\n   branch feature/0001/login\n   checkout feature/0001/login\n   commit id: \"\"\n\n   checkout main\n   merge hotfix tag: \"v1.0.1\"\n\n   checkout develop\n   merge hotfix\n   commit id: \"incorporate hotfix\"\n\n   checkout develop\n   merge feature/0001/login\n   commit id: \"ログイン機能実装\"\n\n   branch release/1.1.x\n   checkout release/1.1.x\n   commit id: \"リリース準備\"\n   commit id: \"bugfix\"\n\n   checkout develop\n   merge release/1.1.x\n\n   checkout main\n   merge release/1.1.x  tag: \"v1.1.0\"\n\n   checkout develop\n   commit id: \"FEATURE\""
  },
  {
    "objectID": "posts/2025-10-30-branch-strategy/index.html#ブランチの種類",
    "href": "posts/2025-10-30-branch-strategy/index.html#ブランチの種類",
    "title": "Git Flow–based branch strategy",
    "section": "2. ブランチの種類",
    "text": "2. ブランチの種類\n\nBasic Syntax\n&lt;branch-type&gt;/&lt;issue-number&gt;/&lt;task-description&gt;\nrelease 系列ブランチや hotfix ブランチなど，Issue番号を含まない場合もあります．その場合は\nrelease/&lt;major&gt;.&lt;minor&gt;.&lt;patch&gt;\nhotfix/&lt;task-description&gt;\n\n\n命名規則\n\n\n\n\n\n\n\n\n\nブランチ種別\n命名規則\n目的\n\n\n\n\n本番用\nmain\n本番デプロイ可能な安定版コード．常にリリース済みの状態を保持\n\n\n開発用\ndevelop\n全機能・修正の統合先（メイン開発ブランチ）\n\n\n機能追加\nfeature/&lt;issue番号&gt;/&lt;タスク&gt;\n新機能開発や改善タスク．小規模IssueはこのままdevelopへPR\n\n\n機能改善\nenhancement/&lt;issue番号&gt;/&lt;タスク&gt;\n既存機能の改善タスク．UX改善・処理最適化など\n\n\nバグ修正\nbugfix/&lt;issue番号&gt;/&lt;タスク&gt;\n不具合修正用ブランチ．テスト後developへ統合\n\n\nIssue統合\nissue/&lt;issue番号&gt;\n中〜大規模Issueの場合のみ作成．複数サブタスクを統合するための統合ブランチ\n\n\nリリース系列\nrelease/&lt;major&gt;.&lt;minor&gt;.x\n特定マイナー系列（例: 1.1.x）の安定維持・軽微修正対応用（長寿命）\n\n\nリリース準備\nrelease/&lt;version&gt;/create-release-note\nリリースノート作成・バージョン確定・タグ準備用（短命）\n\n\n緊急修正\nhotfix/&lt;issue番号&gt;\n本番環境向けの即時修正．修正後 main / develop 両方に反映\n\n\nテスト検証用\ntest/&lt;issue番号&gt;/&lt;タスク&gt;\n一時的なテストコード・検証用ブランチ．検証完了後削除\n\n\nドキュメント整備\ndocs/&lt;issue番号&gt;/&lt;タスク&gt;\nドキュメント・ガイド・README更新などのためのブランチ\n\n\nリファクタリング\nrefactor/&lt;issue番号&gt;/&lt;タスク&gt;\n挙動を変えずに内部構造を改善するためのブランチ\n\n\n検証・試作用\nsandbox/&lt;タスク&gt;\n新しいアイデアやPoCを試すための実験的ブランチ（非公式）．安定版にマージしない前提\n\n\n\n\n\n\n命名例\n\n\n\n\n\n\n\n\nブランチ名\n用途\n\n\n\n\nfeature/0123-add-login\n新機能\n\n\nbugfix/0123-fix-login-error\n修正\n\n\nissue/0123\n複数サブタスクを含むIssue統合\n\n\nrelease/1.1.x\n1.1 系列のリリース維持\n\n\nrelease/1.1.1/create-release-note\n1.1.1 リリース準備\n\n\nhotfix/0145-critical-fix\n緊急対応"
  },
  {
    "objectID": "posts/2025-10-30-branch-strategy/index.html#開発フロー",
    "href": "posts/2025-10-30-branch-strategy/index.html#開発フロー",
    "title": "Git Flow–based branch strategy",
    "section": "3. 開発フロー",
    "text": "3. 開発フロー\n\nStep 1. サブタスク開発\n各Issueに対して、必要なサブタスクごとにブランチを切ります．\ngit switch develop\ngit switch -c feature/0123/add-login\ngit switch -c bugfix/0123/fix-login-error\n\n小規模Issueなら、このまま develop に直接PR(Step3へ)\n中〜大規模Issueなら，Issue統合ブランチを作成し，サブタスクをまとめる (Step 2へ)\n\n\n\nStep 2. 中〜大規模Issueの統合ブランチ（任意）\n複数のサブタスクをまとめてレビューしたい場合にのみ作成します．\ngit switch develop\ngit switch -c issue/0123\ngit merge feature/0123/add-login\ngit merge bugfix/0123/fix-login-error\ngit push -u origin issue/0123\n\n統合PRを作成：issue/0123 → develop\nチーム単位でまとめてレビュー／テストを実施\n\n\n\nStep 3. developへの統合\n\nIssue単位またはサブタスク単位で develop にPR作成\nローカルで実行する場合は git merge --no-ff で対応\n\n\n\nStep 4. リリース系列ブランチ作成\n\n開発が安定したタイミングでマイナー系列ブランチを作成\nブランチ作成は開発規模に応じて，git switch -c または GitHub Actionsで実施\n\ngit switch develop\ngit switch -c release/1.1.x\ngit push -u origin release/1.1.x\n\n\nStep 5. リリース準備ブランチ\ngit switch release/1.1.x\ngit switch -c release/1.1.1/0130/create-release-note\n\n作業内容例:\n\nリリースノート更新\nバージョン番号更新 (__version__.py など)\n最終テスト、修正\n\nPR作成：release/1.1.1/create-release-note → release/1.1.x\n\n\n\nStep 6. リリース確定\n\nGitHub Release ページに正式リリースノートを公開\ngit タグを付与し，main ブランチにマージ\n\n\n\nStep 7. main / develop への反映\n# 本番用\ngit switch main\ngit merge --ff release/1.1.x\ngit push origin main\n\n# 開発用\ngit switch develop\ngit merge --ff release/1.1.x\ngit push origin develop\n\n\n\n\n\n\nNote運用ポイント\n\n\n\n\n\n\n\n\n\n\n\n\n\n対象\nブランチ命名規則\n用途・対象範囲\n運用方針\n\n\n\n\n小規模 Issue\nfeature/&lt;issue番号&gt;-&lt;タスク&gt;\n小規模な新機能・修正  develop に直接 PR\n単一タスク・軽微修正に適用\n\n\n中〜大規模 Issue\nissue/&lt;issue番号&gt;\n複数サブタスクを統合\nサブタスクを統合して develop に PR  feature / bugfix をまとめてレビュー\n\n\nリリース系列ブランチ\nrelease/&lt;major&gt;.&lt;minor&gt;.x\n特定マイナー系列（例: 1.1.x）\n安定版維持・軽微修正対応  長寿命ブランチ．保守・検証に利用\n\n\nリリース準備ブランチ\nrelease/&lt;version&gt;/&lt;subtask&gt;\n各パッチリリース（例: 1.1.1）\nリリースノート作成・バージョン確定・PR作成など  短命ブランチ．完了後削除"
  },
  {
    "objectID": "posts/2025-10-30-branch-strategy/index.html#ブランチ削除ポリシー",
    "href": "posts/2025-10-30-branch-strategy/index.html#ブランチ削除ポリシー",
    "title": "Git Flow–based branch strategy",
    "section": "4. ブランチ削除ポリシー",
    "text": "4. ブランチ削除ポリシー\n\n\n\n\n\n\n\n\n\nブランチ種別\n削除タイミング\n備考\n\n\n\n\nfeature / bugfix / issue\ndevelop マージ後\n即削除（必要ならタグで履歴追跡）\n\n\nrelease/&lt;version&gt;/&lt;subtask&gt;\nmain・develop 反映後\n削除\n\n\nrelease/&lt;series&gt;.x\n次マイナー系列発足時\n継続保守中は残す"
  },
  {
    "objectID": "posts/2025-10-30-branch-strategy/index.html#注意事項",
    "href": "posts/2025-10-30-branch-strategy/index.html#注意事項",
    "title": "Git Flow–based branch strategy",
    "section": "5. 注意事項",
    "text": "5. 注意事項\n\n\n\n\n\n\nImportantRule 1: 小文字とハイフンを使用する\n\n\n\n\nブランチ名は常に小文字で記述\n大文字を含めると，ファイルシステムが大文字・小文字を区別する環境がある\n単語の区切りにはハイフン（-）を使用\n\n\n\n📘 Example\n\n✅ Good: feature/user-login\n❌ Avoid: Feature_UserLogin, FeatUserLogin\n\n\n\n\n\n\n\nImportantRule 2: 明確なトークンからブランチ名を開始する\n\n\n\n\n各ブランチ名は、目的を示すカテゴリトークンから始めます。\nトークンの例：\n\nfeature（新機能開発）\nbugfix（バグ修正）\ndocs（ドキュメント更新）\n\nトークンと説明文はスラッシュ（/）で区切る\n\n\n\n📘 Example\n\n✅ Example: bugfix/payment-timeout\n❌ Avoid: payment-timeout (purpose unclear)\n\n活用例\n# Listing branches by token\n$ git branch --list \"feature/*\"\n\n# Pushing or mapping branches with tokens\n$ git push origin 'refs/heads/feature/*'\n\n# Deleting multiple branches by token\n$ git branch -D $(git branch --list \"feature/*\")\n\n\n\n\n\n\nImportantRule 3: ブランチ名は簡潔・明確に\n\n\n\n\n意図を説明できる範囲で，長すぎる名前は避ける\n長すぎるブランチ名は，ログ表示の一行に収まらず，可視性が下がるため\n\n\n\n📘 Example\n\n✅ 良い例: refactor/api-headers\n❌ 悪い例: refactor/update-the-way-we-handle-request-headers-in-api\n\n\n\n\n\n\n\nImportantRule 4: 衝突を生む可能性のあるブランチは作らない\n\n\n\n\ngit switch -c feature のように意図が不明瞭な名前や既存ブランチと衝突する可能性のある名前は避ける\nGitは内部的に ブランチ名をパス（ディレクトリ構造）として管理しているため，feature が作成されていると feature/login-v2 が名前衝突して作成できなくなってしまう\n\n同じ階層にファイルとディレクトリを同時に作れないため\n\n\n\n\n📘 Example\n$ git switch -c bugfix/0123/fix-login-error\nSwitched to a new branch 'bugfix/0123/fix-login-error'\n\n$ ls .git/refs/heads/bugfix/0123\nfix-login-error"
  },
  {
    "objectID": "posts/2025-10-30-branch-strategy/index.html#appendix-なぜbranchは名前衝突するのか",
    "href": "posts/2025-10-30-branch-strategy/index.html#appendix-なぜbranchは名前衝突するのか",
    "title": "Git Flow–based branch strategy",
    "section": "Appendix: なぜbranchは名前衝突するのか？",
    "text": "Appendix: なぜbranchは名前衝突するのか？\nCommit Object\nGitのコアの部分はシンプルなキー・バリュー型データストアです．Gitで追跡されているファイル(blob)はディレクトリの状態（ツリー）と合わせて圧縮された .git/objects にオブジェクトファイルとして保存されます． git commit を実行すると，commit時点でのその状態をスナップショットとして\n\n誰が(user.name, user.email)\nいつ(現在のタイムスタンプ)\nどんなメッセージを残して\nどのcommitのあとに（=親コミット情報）\nコミットが作成された時点のスナップショットのトップレベルのツリー\n\nを記録します．これがコミットオブジェクトです．このコミットオブジェクトをvalueとすると，それに対応するSHA-1ハッシュ値がキーとなります．\n.git/HEAD\n    │\n    └─ ref: refs/heads/main\n           │\n           └─ SHA-1 commit object (latest commit)\n                  │\n                  ├─ tree object\n                  │     ├─ blob (file1)\n                  │     └─ blob (file2)\n                  └─ parent commit(s)\nブランチはポインター\n各ブランチはブランチ自体が実体を持っているのではなく，どのcommit objectを参照しているか？で状態が管理されています．ここで登場するのが refs/heads/&lt;branch-name&gt; です． main ブランチが参照するCommit Objectは .git/refs/heads/main に記録されており\n% cat .git/refs/heads/main\n35f61422e59fb8b34bf3a85f82a71669c1eeec30\ngit add & git commit を実行すると，この値が新たなCommit Objectへの参照へと書き換わります．\nなぜブランチは名前衝突するのか？\n上記のようにブランチの情報は .git/refs/heads/&lt;branch-name&gt; で管理されています．git switch -c develop とすると\n% git switch -c develop\nSwitched to a new branch 'develop'\n\n% cat .git/refs/heads/develop\n35f61422e59fb8b34bf3a85f82a71669c1eeec30\nとファイルが生成されます．しかし，ブランチ名に / を含む場合だと\n% git switch -c bugfix/0001/test\nSwitched to a new branch 'bugfix/0001/test'\n\n% tree .git/refs/heads/\n.git/refs/heads/\n├── bugfix\n│   └── 0001\n│       └── test\n├── develop\n└── main\nと bugfix/0001/test の/(スラッシュ)がディレクトリ区切りと解釈されてしまします．developブランチがある状態で develop/test を作成しようとすると， .git/refs/heads/develop/ ディレクトリを作成してから，その下に test ファイルを作成しようとしますが，すでにdevelop ファイルが存在する = 同姓同名のディレクトリを同じ層では作成できないという状態が発生します\nそのため，\n% git switch -c develop/test\nfatal: cannot lock ref 'refs/heads/develop/test': 'refs/heads/develop' exists; cannot create 'refs/heads/develop/test'\nというエラーが発生します．"
  },
  {
    "objectID": "posts/2025-10-30-branch-strategy/index.html#references",
    "href": "posts/2025-10-30-branch-strategy/index.html#references",
    "title": "Git Flow–based branch strategy",
    "section": "References",
    "text": "References\n\n10.2 Gitの内側 - Gitオブジェクト"
  },
  {
    "objectID": "posts/2025-02-01-function-and-taylor-expansion/index.html",
    "href": "posts/2025-02-01-function-and-taylor-expansion/index.html",
    "title": "18世紀までの関数論とテイラー展開",
    "section": "",
    "text": "Def: 関数 \n\\(X \\subset \\mathbb R^n, Y\\subset \\mathbb R^n\\) とする．\\(X\\) から \\(Y\\) への関数（実関数）とは，\\(X\\) の任意の元 \\(x\\) に対して，\\(Y\\) の１つの元を対応させる規則をいう． このような \\(X\\) から \\(Y\\) への関数を\n\\[\nf: X\\to Y\n\\]\nを記述し，集合 \\(X\\) を関数 \\(f\\) の定義域(domain)，\\(Y\\) を値域(range) という．\n\n\\(y = x^2\\) としたとき，\\(y\\) は区間 \\((-\\infty, \\infty)\\) における \\(x\\) の関数と呼ばれます．関数の例としては以下，\n\nCode\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nx = np.linspace(-1, 1, 100)\n\nplt.plot(x, x**2)\nplt.gca().set_aspect('equal', adjustable='box')\nplt.show()\n\nplt.plot(x , np.sqrt(1 - x**2))\nplt.gca().set_aspect('equal', adjustable='box')\nplt.show()\n\n\n\n\n\n\n\n\\(y = x^2\\)\n\n\n\n\n\n\n\n\\(y = \\sqrt{1 - x^2}\\)\n\n\n\n\n\n ▶  古典的な関数\n歴史的に関数はまず，\n\n四則演算で表される代数式（\\(x^2 + 2x +1\\), \\(x + \\frac{1}{x}\\), \\(x + \\sqrt{4x^2 + 1}\\)）\n独立変数の代数式で表せない超越関数（\\(a^x, \\log x, \\sin x, \\arctan x\\)）\n\nに限られていました．これら関数は，各点周りでテイラー展開ができるという特徴があります．"
  },
  {
    "objectID": "posts/2025-02-01-function-and-taylor-expansion/index.html#関数",
    "href": "posts/2025-02-01-function-and-taylor-expansion/index.html#関数",
    "title": "18世紀までの関数論とテイラー展開",
    "section": "",
    "text": "Def: 関数 \n\\(X \\subset \\mathbb R^n, Y\\subset \\mathbb R^n\\) とする．\\(X\\) から \\(Y\\) への関数（実関数）とは，\\(X\\) の任意の元 \\(x\\) に対して，\\(Y\\) の１つの元を対応させる規則をいう． このような \\(X\\) から \\(Y\\) への関数を\n\\[\nf: X\\to Y\n\\]\nを記述し，集合 \\(X\\) を関数 \\(f\\) の定義域(domain)，\\(Y\\) を値域(range) という．\n\n\\(y = x^2\\) としたとき，\\(y\\) は区間 \\((-\\infty, \\infty)\\) における \\(x\\) の関数と呼ばれます．関数の例としては以下，\n\nCode\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nx = np.linspace(-1, 1, 100)\n\nplt.plot(x, x**2)\nplt.gca().set_aspect('equal', adjustable='box')\nplt.show()\n\nplt.plot(x , np.sqrt(1 - x**2))\nplt.gca().set_aspect('equal', adjustable='box')\nplt.show()\n\n\n\n\n\n\n\n\\(y = x^2\\)\n\n\n\n\n\n\n\n\\(y = \\sqrt{1 - x^2}\\)\n\n\n\n\n\n ▶  古典的な関数\n歴史的に関数はまず，\n\n四則演算で表される代数式（\\(x^2 + 2x +1\\), \\(x + \\frac{1}{x}\\), \\(x + \\sqrt{4x^2 + 1}\\)）\n独立変数の代数式で表せない超越関数（\\(a^x, \\log x, \\sin x, \\arctan x\\)）\n\nに限られていました．これら関数は，各点周りでテイラー展開ができるという特徴があります．"
  },
  {
    "objectID": "posts/2025-02-01-function-and-taylor-expansion/index.html#平均値の定理からtaylorの公式へ",
    "href": "posts/2025-02-01-function-and-taylor-expansion/index.html#平均値の定理からtaylorの公式へ",
    "title": "18世紀までの関数論とテイラー展開",
    "section": "平均値の定理からTaylorの公式へ",
    "text": "平均値の定理からTaylorの公式へ\n\n\nTheorem 1 : 平均値の定理 \n区間 \\([a, b]\\) において，\\(f(x), g(x)\\) は連続で, \\((a, b)\\) において微分可能とする．このとき，ある点 \\(\\xi \\in (a, b)\\) において，\n\\[\n\\frac{f(b) - f(a)}{g(b) - g(a)} = \\frac{f^\\prime(\\xi)}{g^\\prime(\\xi)}\\label{eq-mean-value}\n\\]\nただし，\\(g(a)\\neq g(b)\\)．\\(f^\\prime(x), g^\\prime(x)\\) は区間内で同時に \\(0\\) にならないと仮定する．\n\n\n\n\n\n\n\n\n\nNoteProof\n\n\n\n\n\n\\(F(x) - \\mu f(x) - \\lambda g(x)\\) とおき，\\(F(a) = F(b) = k\\) となるように適当に \\(\\lambda:\\mu\\) を定める．\nこのとき，\n\\[\n\\begin{gather}\n\\mu f(a) - \\lambda g(a) = \\mu f(b) - \\lambda g(b)\\\\\n\\Rightarrow \\mu (f(b) - f(a)) = \\lambda (g(b) - g(a))\\\\\n\\Rightarrow \\mu (f(b) - f(a)) = \\lambda (g(b) - g(a))\\\\\n\\Rightarrow \\mu = g(b) - g(a), \\lambda = f(b) - f(a)\n\\end{gather}\n\\]\nとして，\n\\[\nF(x) = \\{g(b)-g(a)\\}f(x) - \\{f(b)-f(a)\\}g(x)\n\\]\nここで，\\(G(x) = F(x) - k\\) を考える．有界閉区間 \\([a, b]\\) において \\(f(x), g(x)\\) は連続であるので，有界閉区間 \\([a, b]\\) において \\(F(x)\\) および \\(G(x)\\) も連続関数である．関数の連続性より， とある \\(\\xi \\in [a, b]\\) で \\(G(x)\\) は最大値 \\(G(\\xi) = M &lt; \\infty\\) をとる．\n\\(M &gt; 0\\) のとき，\n\\(x = \\xi\\) において \\(\\Delta G \\leq 0\\). 故に\n\n\\(\\Delta x &gt; 0\\) とすれば \\(\\displaystyle\\frac{\\Delta G}{\\Delta x} \\leq 0\\), 従って，\\(G^\\prime(\\xi)\\leq 0\\)\n\\(\\Delta x &lt; 0\\) とすれば \\(\\displaystyle\\frac{\\Delta G}{\\Delta x} \\geq 0\\), 従って，\\(G^\\prime(\\xi)\\geq 0\\)\n\n従って，\\(G^\\prime(\\xi) = 0\\). \\(M = 0\\) のときは，同様に最小値 \\(G(\\xi) = M &gt; -\\infty\\) を考えると \\(G^\\prime(\\xi)\\geq 0\\) を得る．最小値と最大値が \\(0\\) の場合は \\(G(x)\\) が常に \\(0\\) であるので，\\(x \\in (a, b)\\) において \\(G^\\prime(x) = 0\\) は自明．\nこのとき，\\(F(x) - k = G(x)\\) より\n\\[\n\\begin{align}\nF^\\prime(\\xi) =  \\{g(b)-g(a)\\}f^\\prime(\\xi) - \\{f(b)-f(a)\\}g^\\prime(\\xi) = 0\n\\end{align}\n\\]\nよって，\n\\[\n\\frac{f(b) - f(a)}{g(b) - g(a)} = \\frac{f^\\prime(\\xi)}{g^\\prime(\\xi)}\n\\]\nが成立する．\n\n\n\n平均値の定理を幾何学的に考察してみます．独立変数 \\(t\\) について，曲線\n\\[\nx = f(t), y=g(t)\\qquad t \\in [a. b]\n\\]\nを考えます．このとき，\\(t=a, t=b\\) に対応する \\((x, y)\\) をそれぞれ \\(A, B\\) とすると，\\(\\eqref{eq-mean-value}\\) のLHSが弦ABの勾配に対応します． このとき，\\(x = f(t), y=g(t)\\) の曲線上のとある点 \\(P: t= \\xi\\) の接線が弦ABの勾配と平行になることを定理は示しています．\\(f^\\prime(x), g^\\prime(x)\\) は区間内で同時に \\(0\\) にならないと仮定は，曲線が各点において 確定の接線を有することを意味します．\n\nCode\ndef func_x(x):\n    return np.sin(x) + x\n\ndef func_y(x):\n    return x * np.log(x) ** 2\n\ndef tangent(x, x_0):\n    return func_y(x_0) + (x- func_x(x_0)) * (np.log(np.pi/2) ** 2.5)\n\n\nt = np.linspace(1e-18, np.pi/2, 1000)\nt2 = np.linspace(1.8, 2.6, 100)\nx, y = func_x(t), func_y(t)\nt_0 = 1.11\n\n# plot\nplt.plot(x, y, linewidth=2)\n\n# # add line\nplt.plot([0, func_x(np.pi/2)], [0, func_y(np.pi/2)], color=\"gray\")\nplt.text(-0.01, -0.03, \"A\")\nplt.text(2.55, 0.33, \"B\")\n\n# # add tangent\n# plt.text(x_0, sample_func(x_0)+1e-4, \"P: x = $\\exp(-2)$\")\nplt.scatter(func_x(t_0), func_y(t_0), color=\"gray\", linestyle=\"dotted\")\nplt.text(func_x(t_0), -0.02, \"P\")\nplt.plot(t2, tangent(t2, t_0))\n\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 1: \\(t\\in [0,\\pi/2]\\) 区間で定義された \\(x = \\sin(t) +t, y = \\begin{cases}t(\\log(t))^2  & (t\\in(0, \\pi/2))\\\\0 & t = 0\\end{cases}\\)\n\n\n\n\n\n\n\n\n\nTip🍵 Green Tea Break\n\n\n\n実数空間 \\(\\mathbb R\\) の部分集合 \\(I\\) で定義された関数 \\(f(x)\\) が区間 \\(I\\) の点 \\(a\\) において連続であるとは\n\\[\n\\lim_{x\\to a}f(x) = f(a)\n\\]\nが成り立つことをいいます．\n\\[\nf(t) = \\begin{cases}t(\\log(t))^2  & (t\\in(0, \\pi/2))\\\\0 & t = 0\\end{cases}\n\\]\nはロピタルの定理を用いると，\n\\[\n\\begin{align}\n\\lim_{t\\to 0} t(\\log(t))^2\n    &= \\lim_{t\\to 0} \\frac{(\\log(t))^2}{t^{-1}}\\\\\n    &= \\lim_{t\\to 0} \\frac{2(\\log(t))\\frac{1}{t}}{-t^{-2}}\\\\\n    &= \\lim_{t\\to 0} \\frac{2(\\log(t))}{-t^{-1}}\\\\\n    &= \\lim_{t\\to 0} \\frac{2t^{-1}}{t^{-2}}\\\\\n    &= \\lim_{t\\to 0} 2t = 0\n\\end{align}\n\\]\n以上のように連続性を示すことが出来ます．\n\n\n\nTaylorの公式\n\n\nTheorem 2 \nある区間において．\\(f(x)\\) は第 \\(n\\) 階まで微分可能とする．このときその区間において，\\(a\\) は定点，\\(x\\) を任意の点とするとき\n\\[\n\\begin{gather}\nf(x) = f(a) + \\frac{f^\\prime(a)}{1!}(x-a) + \\frac{f^{\\prime\\prime}(a)}{2!}(x-a)^2 + \\cdots + \\frac{f^{(n-1)}(a)}{(n-1)!}(x-a)^{n-1} + \\frac{f^{(n)}(\\xi)}{(n)!}(x-a)^{n}\\label{eq-taylor}\\\\\n\\text{s.t } \\quad \\xi = a + \\theta(x-a), \\qquad 0 &lt;\\theta&lt;1\n\\end{gather}\n\\]\n\n\n\\(\\frac{f^{(n)}(\\xi)}{(n)!}(x-a)^{n}\\) は \\(R_n\\) と表されることもあり，剰余項とよびます．\n\n\n\n\n\n\n\nNoteProof\n\n\n\n\n\n\\[\nF(x) = f(x) - \\{f(a) + \\frac{f^\\prime(a)}{1!}(x-a) + \\frac{f^{\\prime\\prime}(a)}{2!}(x-a)^2 + \\cdots + \\frac{f^{(n-1)}(a)}{(n-1)!}(x-a)^{n-1}\\}\\label{eq-residual}\n\\]\nとおく．このとき，定義より\n\\[\nF(a) = F^{\\prime}(a) = F^{\\prime\\prime}(a) = \\cdots = F^{n-1}(a) = 0\n\\]\nここで，\n\\[\nG(x) = (x - a)^n\n\\]\nと定義すると第 \\(n\\) 階まで微分可能であり，また \\(G(a) = 0\\)．このとき，中間値の定理より\n\\[\n\\begin{align}\n\\frac{F(x) - F(a)}{G(x) - G(a)}\n    &= \\frac{F(x)}{G(x)}\\\\\n    &= \\frac{F(x)}{(x-a)^n}\\\\\n    &= \\frac{F^\\prime(x_1)}{n(x_1-a)^{n-1}} \\qquad x_1 \\in (a, x)\n\\end{align}\n\\]\n同様に\n\\[\n\\frac{F^\\prime(x_1)}{n(x_1-a)^{n-1}} = \\frac{F^{\\prime\\prime}(x_2)}{n(n-1)(x_2-a)^{n-2}} \\qquad x_2 \\in (a, x_1)\n\\]\n\\(f(x)\\) は第 \\(n\\) 階まで微分可能であるので，\\(F(x)\\) も第 \\(n\\) 階まで微分可能．従って，\n\\[\n\\frac{F(x)}{(x-1)^n} = \\frac{F^{n}(\\xi)}{n!} \\qquad \\exists\\xi \\in (a, x)\n\\]\nつまり\n\\[\nF(x) = \\frac{F^{n}(\\xi)}{n!}(x-a)^n\n\\]\nこれを \\(\\eqref{eq-residual}\\) に代入して整理すると \\(\\eqref{eq-taylor}\\) を得る．\n\n\n\n整式はそれ自身が有限個の項で完結したテイラー展開のしていますし，無限等比級数の公式\n\\[\n\\frac{1}{1 + r} = 1 - r + r^2 - r^3 + \\cdots = \\sum_{i=0}(-r)^i \\qquad (-1 &lt; r &lt; 1)\n\\]\nは \\(x = 1\\) 周りでの関数 \\(f(x) = 1/ x\\) のテイラー展開となっており，\\(x = 1 + r\\) とすると\n\\[\n\\begin{align}\n\\frac{1}{1+r}\n    &= 1 + \\frac{(-1)}{1!}r + \\frac{(-1)\\times(-2)}{2!}r^2 + \\frac{(-1)\\times(-2)\\times(-3)}{3!}r^3 + \\cdots\\\\\n    &= 1 - r + r^2 - r^3 + \\cdots\n\\end{align}\n\\]\nと確認することが出来ます．三角関数も\n\\[\n\\begin{align}\n\\cos x &= 1 - \\frac{1}{2}x^2 + \\frac{1}{24}x^4 - \\cdots\\\\\n\\sin x &= x - \\frac{1}{6}x^3 + \\frac{1}{120}x^5 - \\cdots\n\\end{align}\n\\]\nとテイラー展開することが出来ます．そのため，18世紀までの数学界では，関数は各点周りで冪級数にテイラー展開できるので，微分や積分もテイラー展開を応用して形式的な代数的計算で十分と考えられてました． 19世紀になると任意の関数 \\(f(x)\\) は\n\\[\nf(x) \\sim \\frac{a_0}{2} + \\sum_{n=1}^\\infty(a_n\\cos nx + b_n \\sin nx)\n\\]\nで表すことができるのではないか？という主張が登場し，関数，微分，積分の理論の見直しの必要性が認識されるようになりました．\n\nExample 1 : テイラー展開の例 \n次の関数の点 \\(a\\) のまわりのテイラー展開を剰余項を含めて \\(h^3\\) まで書き下すと以下のようになります\n\\[\n\\begin{align}\n\\log(a+h) &= \\log(a) + \\frac{h}{a} - \\frac{1}{2}\\frac{h^2}{a^2} + \\frac{1}{3}\\frac{h^3}{(a+\\theta h)^3}\\\\\n(a+h)^\\beta &= a^\\beta + \\beta a^{\\beta-1}h + \\frac{\\beta(\\beta-1)}{2!}a^{\\beta-2}h^2+ \\frac{\\beta(\\beta-1)(\\beta-2)}{3!}(a+\\theta h)^{\\beta-3}h^3\n\\end{align}\n\\]\nただし，\\(0 &lt; \\theta &lt; 1\\) とします．\n\n\n\nTaylor展開の応用: \\(e\\) が無理数であることの証明\n\\(f(x) = \\exp(x)\\) を マクローリン展開すると\n\\[\n\\exp(x) = 1 + \\frac{x}{1!} + \\frac{x^2}{2!} + \\frac{x^3}{3!} + \\cdots + \\frac{x^n}{n!} + R_{n+1}\n\\]\n\\(x = 1\\) としたとき，\n\\[\ne =  1 + \\frac{1}{1!} + \\frac{1}{2!} + \\frac{1}{3!} + \\cdots + \\frac{1}{n!} + R_{n+1}\n\\]\n剰余項 \\(R_{n+1}0\\) は\n\\[\nR_{n+1} = \\frac{\\exp(\\theta)}{(n+1)!} &gt; 0 \\quad \\exists\\theta \\in (0, 1)\n\\]\nつまり，\n\\[\nR_{n+1} = \\frac{\\exp(\\theta)}{(n+1)!} &lt; \\frac{3}{(n+1)!}\n\\]\nここで，\\(e\\) を有理数として \\(e = m/n\\) と既約分数で表せると仮定する．このとき，\\(n!e\\) は仮定より整数となるので\n\\[\n1 \\leq n!R_{n+1} = \\frac{\\exp(\\theta)}{n+1} &lt; \\frac{3}{n+1}\n\\]\n従って，\\(n+1 &lt;3\\) つまり \\(n &lt; 2\\)，従って，\\(n = 1\\) を得る．このとき，\\(m\\) は整数なので \\(e = m\\) となるが \\(2 &lt; e &lt; 3\\) より矛盾．従って，\\(e\\) は無理数となる．"
  },
  {
    "objectID": "posts/2025-06-13-heat-and-work/index.html",
    "href": "posts/2025-06-13-heat-and-work/index.html",
    "title": "エントロピーとエンタルピー",
    "section": "",
    "text": "熱は，冷媒などの物質が保有しているエネルギーの１つの形態\n仕事もエネルギーの一つの形態\n\nそのため，熱と仕事は相互に変換することが可能です．\n\n\n仕事⇒発熱\n\n\n\n仕事による摩擦熱の発生\n\n\n\n発熱⇒仕事\n\n\n\n\n加熱時の気体の膨張による仕事\n\n\n\n\n\n流体（特に気体）を加熱すると，体積膨張を通して外部に対して仕事をするようになります． 右上図が示すようにシリンダとピストンに閉じ込められた空間内の気体（閉鎖系）に熱を加えると，\n\n気体は温度が上昇（=内部エネルギーの増加）\n気体は膨張することによって，ピストンを押し下げ，外部に対して仕事する\n\nという状態の変化が生じます．シリンダ内の1kgあたりの気体について考えると\n\\[\nq_{12} = u_2 - u_1 + w_{12} \\label{first-law}\n\\]\n\n\\(q_{12}\\): 気体に加えられた熱量 [kJ/kg]\n\\(u_i\\): 状態 \\(i\\) の内部エネルギーの変化\n\\(w_{12}\\): 状態変化に伴って発生する外部になす仕事\n状態1: 変化前の状態\n状態2: 変化後の状態\n\n\\(\\eqref{first-law}\\) を閉鎖系の熱力学第一法則（エネルギー保存則）といいます．これを微小な変化に対して表すと\n\\[\ndq = du + dw \\label{first-law-2}\n\\]\n\n\n\nシリンダは閉鎖系\nシリンダは断熱素材でできている(断熱変化)\nシリンダとピストンの間の摩擦および気体の流動摩擦は発生しない\nピストンに作用する圧力は空間内の圧力に等しい\n\nと仮定します．系が外部にする仕事は，系が膨張することを通して行われます．またピストンの観点からみると\n\\[\n\\text{仕事 [J]} = \\text{力 [N]}\\times\\text{移動距離 [m]}\n\\]\nです．ピストンの断面積にかかる力は \\(\\text{圧力}\\times \\text{断面積}\\) で表せるので\n\\[\ndw = pAdx = pdv \\label{absolute-work}\n\\]\n\n\\(A\\): ピストンの断面積 [\\(\\text{m}^2\\)]\n\\(p\\): シリンダ内圧力 [kPa]\n\\(x\\): 気体膨張に伴うピストン上昇距離 [m]\n\\(v\\): 気体の比体積 [\\(\\text{m}^3\\)/kg]\n\n\\(\\eqref{absolute-work}\\) より気体がなす仕事 \\(w_{12}\\) は\n\\[\nw_{12} = \\int^2_1 p dv\n\\]\nと計算できます．\n\n\nCode\nimport matplotlib.pyplot as plt\nimport numpy as np\n\ndef plot_pv_diagram():\n    # 理想気体の比熱比 (γ) を設定\n    # 断熱変化は PV^γ = const で表される\n    gamma = 1.4  # 単原子分子理想気体の場合 5/3 = 1.67, 二原子分子理想気体の場合 7/5 = 1.4\n\n    # 点 A の状態量\n    PA = 4.0  # P軸のスケールに合わせて適当な値に調整\n    VA = 1.0  # V軸のスケールに合わせて適当な値に調整\n    TA = PA * VA # PV = nRT なので，T は PV に比例すると考えられる\n\n    # 点 B の状態量 (断熱変化による)\n    # PB * VB^gamma = PA * VA^gamma\n    # ここでは，VB を仮定して PB を計算する\n    VB = 5.0 # VAより大きい値で，グラフに収まるように適当に設定\n    PB = PA * (VA / VB)**gamma\n\n    # 等温変化の計算 (PV = const)\n    # T = TA の等温線\n    V_iso_TA = np.linspace(0.5, 7.0, 100) # 広めの範囲でプロット\n    V_iso_TB = np.linspace(0.5, 7.0, 100) # 広めの範囲でプロット\n    P_iso_TA = (PA * VA) / V_iso_TA\n    P_iso_TB = (PA * VB) / V_iso_TB\n\n    # T = TB の等温線\n    # TB = PB * VB\n    P_iso_TB = (PB * VB) / V_iso_TA # 同じV範囲で計算\n\n    # 断熱変化の計算 (PV^gamma = const)\n    V_adiabatic = np.linspace(VA, VB, 100) # AからBまでの範囲\n    P_adiabatic = PA * (VA / V_adiabatic)**gamma\n\n    # Matplotlibでプロット\n    plt.figure(figsize=(8, 6))\n\n    # 断熱変化の曲線 (AからB)\n    plt.plot(V_adiabatic, P_adiabatic, color='blue', linewidth=2, label='断熱変化')\n    plt.plot([VA, VA], [0, PA], 'k:', linewidth=0.8) # 垂直な点線\n    plt.plot([0, VA], [PA, PA], 'k:', linewidth=0.8) # 水平な点線\n    plt.plot([VB, VB], [0, PB], 'k:', linewidth=0.8) # 垂直な点線\n    plt.plot([0, VB], [PB, PB], 'k:', linewidth=0.8) # 水平な点線\n\n    # 等温変化の曲線\n    plt.plot(V_iso_TA, P_iso_TA, 'k--', linewidth=0.8, label='等温変化')\n    plt.text(V_iso_TA[-1] * 0.9, P_iso_TA[-1] * 1.1, f'T = TA', fontsize=10, ha='right', va='bottom',\n             bbox=dict(boxstyle=\"round,pad=0.3\", fc=\"white\", ec=\"gray\", lw=0.5))\n\n    plt.plot(V_iso_TB, P_iso_TB, 'k--', linewidth=0.8)\n    plt.text(V_iso_TB[20] * 0.8, P_iso_TB[20] * 0.8, f'T = TB', fontsize=10, ha='left', va='top',\n             bbox=dict(boxstyle=\"round,pad=0.3\", fc=\"white\", ec=\"gray\", lw=0.5))\n\n\n    # 点 A と 点 B のプロット\n    plt.plot(VA, PA, 'ko', markersize=6)\n    plt.text(VA * 0.95, PA * 1.05, 'A', fontsize=12, ha='right')\n\n    plt.plot(VB, PB, 'ko', markersize=6)\n    plt.text(VB * 1.02, PB * 0.9, 'B', fontsize=12, ha='left')\n\n    # 軸ラベルとタイトル\n    plt.xlabel('v')\n    plt.ylabel('p')\n    plt.title('PV plot')\n\n    # 軸の範囲を設定\n    plt.xlim(0, 7.5)\n    plt.ylim(0, 5.0)\n\n    # 凡例\n    # plt.legend() # 等温変化と断熱変化の凡例は曲線上に直接記述した方が見やすいかも\n\n    # グリッド\n    plt.grid(True, linestyle=':', alpha=0.6)\n\n    # 軸の目盛りとラベル\n    plt.xticks([VA, VB], [f'$v_1$', f'$v_2$'])\n    plt.yticks([PB, PA], [f'$p_2$', f'$p_1$'])\n\n    plt.tight_layout()\n    plt.show()\n\n# 関数を呼び出してグラフを表示\nplot_pv_diagram()\n\n\n\n\n\n\n\n\nFigure 1\n\n\n\n\n\n圧力一定のもとで熱を加える\n圧力一定のもとで熱を加える場合，\\(\\eqref{first-law-2}\\) は定圧比熱 \\(c_p\\) [kJ/kg･K] を用いると\n\\[\n\\begin{align}\ndq\n  &= c_pdT\\\\\n  &= du + pdv\n\\end{align}\n\\]\n容積一定のもとで熱を加える\nふたや壁が動かなくて外に膨張できない状況で気体を加熱すると，\\(dv = dw = 0\\) とみなせるので，定容比熱 \\(c_v\\) [kJ/kg･K] を用いると\n\\[\ndq = c_vdT = du\n\\]\n断熱圧縮時の内部エネルギー増大\n\\(\\eqref{first-law}\\) において，状態1から状態2 へ変化するとき熱の授受のない断熱圧縮を考えます．このとき，\n\\[\ndq = 0\n\\]\nであり，圧縮仮定で気体の定容比熱が変わらないとすると\n\n\nCode\nimport matplotlib.pyplot as plt\nimport numpy as np\n\ndef plot_pv_diagram():\n    # 理想気体の比熱比 (γ) を設定\n    # 断熱変化は PV^γ = const で表される\n    gamma = 1.4  # 単原子分子理想気体の場合 5/3 = 1.67, 二原子分子理想気体の場合 7/5 = 1.4\n\n    # 点 A の状態量\n    PA = 4.0  # P軸のスケールに合わせて適当な値に調整\n    VA = 1.0  # V軸のスケールに合わせて適当な値に調整\n    TA = PA * VA # PV = nRT なので，T は PV に比例すると考えられる\n\n    # 点 B の状態量 (断熱変化による)\n    # PB * VB^gamma = PA * VA^gamma\n    # ここでは，VB を仮定して PB を計算する\n    VB = 5.0 # VAより大きい値で，グラフに収まるように適当に設定\n    PB = PA * (VA / VB)**gamma\n\n    # 等温変化の計算 (PV = const)\n    # T = TA の等温線\n    V_iso_TA = np.linspace(0.5, 7.0, 100) # 広めの範囲でプロット\n    V_iso_TB = np.linspace(0.5, 7.0, 100) # 広めの範囲でプロット\n    P_iso_TA = (PA * VA) / V_iso_TA\n    P_iso_TB = (PA * VB) / V_iso_TB\n\n    # T = TB の等温線\n    # TB = PB * VB\n    P_iso_TB = (PB * VB) / V_iso_TA # 同じV範囲で計算\n\n    # 断熱変化の計算 (PV^gamma = const)\n    V_adiabatic = np.linspace(VA, VB, 100) # AからBまでの範囲\n    P_adiabatic = PA * (VA / V_adiabatic)**gamma\n\n    # Matplotlibでプロット\n    plt.figure(figsize=(8, 6))\n\n    # 断熱変化の曲線 (AからB)\n    plt.plot(V_adiabatic, P_adiabatic, color='blue', linewidth=2, label='断熱変化')\n    plt.plot([VA, VA], [0, PA], 'k:', linewidth=0.8) # 垂直な点線\n    plt.plot([0, VA], [PA, PA], 'k:', linewidth=0.8) # 水平な点線\n    plt.plot([VB, VB], [0, PB], 'k:', linewidth=0.8) # 垂直な点線\n    plt.plot([0, VB], [PB, PB], 'k:', linewidth=0.8) # 水平な点線\n\n    # 等温変化の曲線\n    plt.plot(V_iso_TA, P_iso_TA, 'k--', linewidth=0.8, label='等温変化')\n    plt.text(V_iso_TA[-1] * 0.9, P_iso_TA[-1] * 1.1, f'T = TA', fontsize=10, ha='right', va='bottom',\n             bbox=dict(boxstyle=\"round,pad=0.3\", fc=\"white\", ec=\"gray\", lw=0.5))\n\n    plt.plot(V_iso_TB, P_iso_TB, 'k--', linewidth=0.8)\n    plt.text(V_iso_TB[20] * 0.8, P_iso_TB[20] * 0.8, f'T = TB', fontsize=10, ha='left', va='top',\n             bbox=dict(boxstyle=\"round,pad=0.3\", fc=\"white\", ec=\"gray\", lw=0.5))\n\n\n    # 点 A と 点 B のプロット\n    plt.plot(VA, PA, 'ko', markersize=6)\n    plt.text(VA * 0.95, PA * 1.05, 'A', fontsize=12, ha='right')\n\n    plt.plot(VB, PB, 'ko', markersize=6)\n    plt.text(VB * 1.02, PB * 0.9, 'B', fontsize=12, ha='left')\n\n    # 軸ラベルとタイトル\n    plt.xlabel('v')\n    plt.ylabel('p')\n    plt.title('PV plot')\n\n    # 軸の範囲を設定\n    plt.xlim(0, 7.5)\n    plt.ylim(0, 5.0)\n\n    # 凡例\n    # plt.legend() # 等温変化と断熱変化の凡例は曲線上に直接記述した方が見やすいかも\n\n    # グリッド\n    plt.grid(True, linestyle=':', alpha=0.6)\n\n    # 軸の目盛りとラベル\n    plt.xticks([VA, VB], [f'$v_2$', f'$v_1$'])\n    plt.yticks([PB, PA], [f'$p_1$', f'$p_2$'])\n\n    plt.tight_layout()\n    plt.show()\n\n# 関数を呼び出してグラフを表示\nplot_pv_diagram()\n\n\n\n\n\n\n\n\nFigure 2\n\n\n\n\n\n\\[\n\\begin{align}\nc_vdT &= -p dv\\\\\n\\int_{\\text{state 1}}^{\\text{state 2}}c_vdT\n  &= u_2 - u_1\\\\\n  &= -\\int_{v1}^{v2}p dv\n\\end{align}\n\\]\n圧縮の場合 \\(\\int_{v1}^{v2}p dv\\) は負となります．これは外部から仕事がなされることを意味します．熱力学第一法則法則より，外部からの仕事は比内部エネルギー \\(u\\) の増加に使われることになります．"
  },
  {
    "objectID": "posts/2025-06-13-heat-and-work/index.html#熱と仕事の基礎事項",
    "href": "posts/2025-06-13-heat-and-work/index.html#熱と仕事の基礎事項",
    "title": "エントロピーとエンタルピー",
    "section": "",
    "text": "熱は，冷媒などの物質が保有しているエネルギーの１つの形態\n仕事もエネルギーの一つの形態\n\nそのため，熱と仕事は相互に変換することが可能です．\n\n\n仕事⇒発熱\n\n\n\n仕事による摩擦熱の発生\n\n\n\n発熱⇒仕事\n\n\n\n\n加熱時の気体の膨張による仕事\n\n\n\n\n\n流体（特に気体）を加熱すると，体積膨張を通して外部に対して仕事をするようになります． 右上図が示すようにシリンダとピストンに閉じ込められた空間内の気体（閉鎖系）に熱を加えると，\n\n気体は温度が上昇（=内部エネルギーの増加）\n気体は膨張することによって，ピストンを押し下げ，外部に対して仕事する\n\nという状態の変化が生じます．シリンダ内の1kgあたりの気体について考えると\n\\[\nq_{12} = u_2 - u_1 + w_{12} \\label{first-law}\n\\]\n\n\\(q_{12}\\): 気体に加えられた熱量 [kJ/kg]\n\\(u_i\\): 状態 \\(i\\) の内部エネルギーの変化\n\\(w_{12}\\): 状態変化に伴って発生する外部になす仕事\n状態1: 変化前の状態\n状態2: 変化後の状態\n\n\\(\\eqref{first-law}\\) を閉鎖系の熱力学第一法則（エネルギー保存則）といいます．これを微小な変化に対して表すと\n\\[\ndq = du + dw \\label{first-law-2}\n\\]\n\n\n\nシリンダは閉鎖系\nシリンダは断熱素材でできている(断熱変化)\nシリンダとピストンの間の摩擦および気体の流動摩擦は発生しない\nピストンに作用する圧力は空間内の圧力に等しい\n\nと仮定します．系が外部にする仕事は，系が膨張することを通して行われます．またピストンの観点からみると\n\\[\n\\text{仕事 [J]} = \\text{力 [N]}\\times\\text{移動距離 [m]}\n\\]\nです．ピストンの断面積にかかる力は \\(\\text{圧力}\\times \\text{断面積}\\) で表せるので\n\\[\ndw = pAdx = pdv \\label{absolute-work}\n\\]\n\n\\(A\\): ピストンの断面積 [\\(\\text{m}^2\\)]\n\\(p\\): シリンダ内圧力 [kPa]\n\\(x\\): 気体膨張に伴うピストン上昇距離 [m]\n\\(v\\): 気体の比体積 [\\(\\text{m}^3\\)/kg]\n\n\\(\\eqref{absolute-work}\\) より気体がなす仕事 \\(w_{12}\\) は\n\\[\nw_{12} = \\int^2_1 p dv\n\\]\nと計算できます．\n\n\nCode\nimport matplotlib.pyplot as plt\nimport numpy as np\n\ndef plot_pv_diagram():\n    # 理想気体の比熱比 (γ) を設定\n    # 断熱変化は PV^γ = const で表される\n    gamma = 1.4  # 単原子分子理想気体の場合 5/3 = 1.67, 二原子分子理想気体の場合 7/5 = 1.4\n\n    # 点 A の状態量\n    PA = 4.0  # P軸のスケールに合わせて適当な値に調整\n    VA = 1.0  # V軸のスケールに合わせて適当な値に調整\n    TA = PA * VA # PV = nRT なので，T は PV に比例すると考えられる\n\n    # 点 B の状態量 (断熱変化による)\n    # PB * VB^gamma = PA * VA^gamma\n    # ここでは，VB を仮定して PB を計算する\n    VB = 5.0 # VAより大きい値で，グラフに収まるように適当に設定\n    PB = PA * (VA / VB)**gamma\n\n    # 等温変化の計算 (PV = const)\n    # T = TA の等温線\n    V_iso_TA = np.linspace(0.5, 7.0, 100) # 広めの範囲でプロット\n    V_iso_TB = np.linspace(0.5, 7.0, 100) # 広めの範囲でプロット\n    P_iso_TA = (PA * VA) / V_iso_TA\n    P_iso_TB = (PA * VB) / V_iso_TB\n\n    # T = TB の等温線\n    # TB = PB * VB\n    P_iso_TB = (PB * VB) / V_iso_TA # 同じV範囲で計算\n\n    # 断熱変化の計算 (PV^gamma = const)\n    V_adiabatic = np.linspace(VA, VB, 100) # AからBまでの範囲\n    P_adiabatic = PA * (VA / V_adiabatic)**gamma\n\n    # Matplotlibでプロット\n    plt.figure(figsize=(8, 6))\n\n    # 断熱変化の曲線 (AからB)\n    plt.plot(V_adiabatic, P_adiabatic, color='blue', linewidth=2, label='断熱変化')\n    plt.plot([VA, VA], [0, PA], 'k:', linewidth=0.8) # 垂直な点線\n    plt.plot([0, VA], [PA, PA], 'k:', linewidth=0.8) # 水平な点線\n    plt.plot([VB, VB], [0, PB], 'k:', linewidth=0.8) # 垂直な点線\n    plt.plot([0, VB], [PB, PB], 'k:', linewidth=0.8) # 水平な点線\n\n    # 等温変化の曲線\n    plt.plot(V_iso_TA, P_iso_TA, 'k--', linewidth=0.8, label='等温変化')\n    plt.text(V_iso_TA[-1] * 0.9, P_iso_TA[-1] * 1.1, f'T = TA', fontsize=10, ha='right', va='bottom',\n             bbox=dict(boxstyle=\"round,pad=0.3\", fc=\"white\", ec=\"gray\", lw=0.5))\n\n    plt.plot(V_iso_TB, P_iso_TB, 'k--', linewidth=0.8)\n    plt.text(V_iso_TB[20] * 0.8, P_iso_TB[20] * 0.8, f'T = TB', fontsize=10, ha='left', va='top',\n             bbox=dict(boxstyle=\"round,pad=0.3\", fc=\"white\", ec=\"gray\", lw=0.5))\n\n\n    # 点 A と 点 B のプロット\n    plt.plot(VA, PA, 'ko', markersize=6)\n    plt.text(VA * 0.95, PA * 1.05, 'A', fontsize=12, ha='right')\n\n    plt.plot(VB, PB, 'ko', markersize=6)\n    plt.text(VB * 1.02, PB * 0.9, 'B', fontsize=12, ha='left')\n\n    # 軸ラベルとタイトル\n    plt.xlabel('v')\n    plt.ylabel('p')\n    plt.title('PV plot')\n\n    # 軸の範囲を設定\n    plt.xlim(0, 7.5)\n    plt.ylim(0, 5.0)\n\n    # 凡例\n    # plt.legend() # 等温変化と断熱変化の凡例は曲線上に直接記述した方が見やすいかも\n\n    # グリッド\n    plt.grid(True, linestyle=':', alpha=0.6)\n\n    # 軸の目盛りとラベル\n    plt.xticks([VA, VB], [f'$v_1$', f'$v_2$'])\n    plt.yticks([PB, PA], [f'$p_2$', f'$p_1$'])\n\n    plt.tight_layout()\n    plt.show()\n\n# 関数を呼び出してグラフを表示\nplot_pv_diagram()\n\n\n\n\n\n\n\n\nFigure 1\n\n\n\n\n\n圧力一定のもとで熱を加える\n圧力一定のもとで熱を加える場合，\\(\\eqref{first-law-2}\\) は定圧比熱 \\(c_p\\) [kJ/kg･K] を用いると\n\\[\n\\begin{align}\ndq\n  &= c_pdT\\\\\n  &= du + pdv\n\\end{align}\n\\]\n容積一定のもとで熱を加える\nふたや壁が動かなくて外に膨張できない状況で気体を加熱すると，\\(dv = dw = 0\\) とみなせるので，定容比熱 \\(c_v\\) [kJ/kg･K] を用いると\n\\[\ndq = c_vdT = du\n\\]\n断熱圧縮時の内部エネルギー増大\n\\(\\eqref{first-law}\\) において，状態1から状態2 へ変化するとき熱の授受のない断熱圧縮を考えます．このとき，\n\\[\ndq = 0\n\\]\nであり，圧縮仮定で気体の定容比熱が変わらないとすると\n\n\nCode\nimport matplotlib.pyplot as plt\nimport numpy as np\n\ndef plot_pv_diagram():\n    # 理想気体の比熱比 (γ) を設定\n    # 断熱変化は PV^γ = const で表される\n    gamma = 1.4  # 単原子分子理想気体の場合 5/3 = 1.67, 二原子分子理想気体の場合 7/5 = 1.4\n\n    # 点 A の状態量\n    PA = 4.0  # P軸のスケールに合わせて適当な値に調整\n    VA = 1.0  # V軸のスケールに合わせて適当な値に調整\n    TA = PA * VA # PV = nRT なので，T は PV に比例すると考えられる\n\n    # 点 B の状態量 (断熱変化による)\n    # PB * VB^gamma = PA * VA^gamma\n    # ここでは，VB を仮定して PB を計算する\n    VB = 5.0 # VAより大きい値で，グラフに収まるように適当に設定\n    PB = PA * (VA / VB)**gamma\n\n    # 等温変化の計算 (PV = const)\n    # T = TA の等温線\n    V_iso_TA = np.linspace(0.5, 7.0, 100) # 広めの範囲でプロット\n    V_iso_TB = np.linspace(0.5, 7.0, 100) # 広めの範囲でプロット\n    P_iso_TA = (PA * VA) / V_iso_TA\n    P_iso_TB = (PA * VB) / V_iso_TB\n\n    # T = TB の等温線\n    # TB = PB * VB\n    P_iso_TB = (PB * VB) / V_iso_TA # 同じV範囲で計算\n\n    # 断熱変化の計算 (PV^gamma = const)\n    V_adiabatic = np.linspace(VA, VB, 100) # AからBまでの範囲\n    P_adiabatic = PA * (VA / V_adiabatic)**gamma\n\n    # Matplotlibでプロット\n    plt.figure(figsize=(8, 6))\n\n    # 断熱変化の曲線 (AからB)\n    plt.plot(V_adiabatic, P_adiabatic, color='blue', linewidth=2, label='断熱変化')\n    plt.plot([VA, VA], [0, PA], 'k:', linewidth=0.8) # 垂直な点線\n    plt.plot([0, VA], [PA, PA], 'k:', linewidth=0.8) # 水平な点線\n    plt.plot([VB, VB], [0, PB], 'k:', linewidth=0.8) # 垂直な点線\n    plt.plot([0, VB], [PB, PB], 'k:', linewidth=0.8) # 水平な点線\n\n    # 等温変化の曲線\n    plt.plot(V_iso_TA, P_iso_TA, 'k--', linewidth=0.8, label='等温変化')\n    plt.text(V_iso_TA[-1] * 0.9, P_iso_TA[-1] * 1.1, f'T = TA', fontsize=10, ha='right', va='bottom',\n             bbox=dict(boxstyle=\"round,pad=0.3\", fc=\"white\", ec=\"gray\", lw=0.5))\n\n    plt.plot(V_iso_TB, P_iso_TB, 'k--', linewidth=0.8)\n    plt.text(V_iso_TB[20] * 0.8, P_iso_TB[20] * 0.8, f'T = TB', fontsize=10, ha='left', va='top',\n             bbox=dict(boxstyle=\"round,pad=0.3\", fc=\"white\", ec=\"gray\", lw=0.5))\n\n\n    # 点 A と 点 B のプロット\n    plt.plot(VA, PA, 'ko', markersize=6)\n    plt.text(VA * 0.95, PA * 1.05, 'A', fontsize=12, ha='right')\n\n    plt.plot(VB, PB, 'ko', markersize=6)\n    plt.text(VB * 1.02, PB * 0.9, 'B', fontsize=12, ha='left')\n\n    # 軸ラベルとタイトル\n    plt.xlabel('v')\n    plt.ylabel('p')\n    plt.title('PV plot')\n\n    # 軸の範囲を設定\n    plt.xlim(0, 7.5)\n    plt.ylim(0, 5.0)\n\n    # 凡例\n    # plt.legend() # 等温変化と断熱変化の凡例は曲線上に直接記述した方が見やすいかも\n\n    # グリッド\n    plt.grid(True, linestyle=':', alpha=0.6)\n\n    # 軸の目盛りとラベル\n    plt.xticks([VA, VB], [f'$v_2$', f'$v_1$'])\n    plt.yticks([PB, PA], [f'$p_1$', f'$p_2$'])\n\n    plt.tight_layout()\n    plt.show()\n\n# 関数を呼び出してグラフを表示\nplot_pv_diagram()\n\n\n\n\n\n\n\n\nFigure 2\n\n\n\n\n\n\\[\n\\begin{align}\nc_vdT &= -p dv\\\\\n\\int_{\\text{state 1}}^{\\text{state 2}}c_vdT\n  &= u_2 - u_1\\\\\n  &= -\\int_{v1}^{v2}p dv\n\\end{align}\n\\]\n圧縮の場合 \\(\\int_{v1}^{v2}p dv\\) は負となります．これは外部から仕事がなされることを意味します．熱力学第一法則法則より，外部からの仕事は比内部エネルギー \\(u\\) の増加に使われることになります．"
  },
  {
    "objectID": "posts/2025-06-13-heat-and-work/index.html#エンタルピー",
    "href": "posts/2025-06-13-heat-and-work/index.html#エンタルピー",
    "title": "エントロピーとエンタルピー",
    "section": "エンタルピー",
    "text": "エンタルピー\n\nDefinition 1 エンタルピー\n流動過程にある気体/流体が保有する状態量としてのエネルギーは，運動エネルギーや位置エネルギーが無視できる場合には，エンタルピー \\(H\\) [kJ] で表される． 質量 1kg あたりのエンタルピーを比エンタルピー \\(h\\) [kJ/kg] という．\n比エンタルピー \\(h\\) は比内部エネルギー \\(u\\), 流動仕事 \\(pv\\) との和で以下のように表せる：\n\\[\nh = u + pv\n\\]\n\n全微分の公式を用いると比エンタルピーの変化は\n\\[\ndh = du + pdv + vdp\n\\]\nここで \\(\\eqref{first-law-2}\\) を用いて再整理すると\n\\[\ndh = dq + vdp\n\\]\nしたがって，状態1から状態2へ変化する場合\n\\[\n\\begin{align}\nh_2 - h_1\n  &= q_{12} + \\int^2_1vdp \\label{enthalpy-diff}\n\\end{align}\n\\]\n流動系において，運動エネルギーや位置エネルギーが無視できる場合には\n\\[\nq_{12} - l_{12} = h_2 - h_1\n\\]\nこの \\(l_{12}\\) を工業仕事 といい，流動過程において流体と外部の間で実際に授受される仕事です．\n\\(\\eqref{enthalpy-diff}\\) より\n\\[\nl_{12} = -\\int^2_1vdp\n\\]\n圧縮の場合，RHSは負の値になります．\n断熱圧縮の場合\n断熱圧縮の場合，外から受け取る熱量はないので \\(dq = 0\\) つまり，\n\\[\nh_2 - h_1 = \\int^2_1 vdp\n\\]\nこのとき，\\(h_2 - h_1\\) は下のp-v線図上で 1-2-3-4-1 で囲まれた面積で表されます．\n\n\nCode\nimport matplotlib.pyplot as plt\nimport numpy as np\n\ndef plot_pv_diagram():\n    # 理想気体の比熱比 (γ) を設定\n    # 断熱変化は PV^γ = const で表される\n    gamma = 1.4  # 単原子分子理想気体の場合 5/3 = 1.67, 二原子分子理想気体の場合 7/5 = 1.4\n\n    # 点 A の状態量\n    PA = 4.0  # P軸のスケールに合わせて適当な値に調整\n    VA = 1.0  # V軸のスケールに合わせて適当な値に調整\n    TA = PA * VA # PV = nRT なので，T は PV に比例すると考えられる\n\n    # 点 B の状態量 (断熱変化による)\n    # PB * VB^gamma = PA * VA^gamma\n    # ここでは，VB を仮定して PB を計算する\n    VB = 5.0 # VAより大きい値で，グラフに収まるように適当に設定\n    PB = PA * (VA / VB)**gamma\n\n    # 等温変化の計算 (PV = const)\n    # T = TA の等温線\n    V_iso_TA = np.linspace(0.5, 7.0, 100) # 広めの範囲でプロット\n    V_iso_TB = np.linspace(0.5, 7.0, 100) # 広めの範囲でプロット\n    P_iso_TA = (PA * VA) / V_iso_TA\n    P_iso_TB = (PA * VB) / V_iso_TB\n\n    # T = TB の等温線\n    # TB = PB * VB\n    P_iso_TB = (PB * VB) / V_iso_TA # 同じV範囲で計算\n\n    # 断熱変化の計算 (PV^gamma = const)\n    V_adiabatic = np.linspace(VA, VB, 100) # AからBまでの範囲\n    P_adiabatic = PA * (VA / V_adiabatic)**gamma\n\n    # Matplotlibでプロット\n    plt.figure(figsize=(8, 6))\n\n    # 断熱変化の曲線 (AからB)\n    plt.plot(V_adiabatic, P_adiabatic, color='blue', linewidth=2, label='断熱変化')\n    plt.plot([VA, VA], [0, PA], 'k:', linewidth=0.8) # 垂直な点線\n    plt.plot([0, VA], [PA, PA], 'k:', linewidth=0.8) # 水平な点線\n    plt.plot([VB, VB], [0, PB], 'k:', linewidth=0.8) # 垂直な点線\n    plt.plot([0, VB], [PB, PB], 'k:', linewidth=0.8) # 水平な点線\n\n\n    # 点 A と 点 B のプロット\n    plt.plot(VA, PA, 'ko', markersize=6)\n    plt.text(VA * 0.95, PA * 1.05, '2', fontsize=12, ha='right')\n    plt.text(0, -0.25, '0', fontsize=12, ha='center')\n\n    plt.plot(VB, PB, 'ko', markersize=6)\n    plt.text(VB * 1.02, PB * 0.9, '1', fontsize=12, ha='left')\n\n    # 軸ラベルとタイトル\n    plt.xlabel('v')\n    plt.ylabel('p')\n    plt.title('Enthalpy increase during adiabatic compression')\n\n    # 軸の範囲を設定\n    plt.xlim(0, 7.5)\n    plt.ylim(0, 5.0)\n\n    # 凡例\n    # plt.legend() # 等温変化と断熱変化の凡例は曲線上に直接記述した方が見やすいかも\n\n    # グリッド\n    plt.grid(True, linestyle=':', alpha=0.6)\n\n    # 軸の目盛りとラベル\n    plt.xticks([VA, VB], [f'2\\'', f'1\\''], fontsize=12)\n    plt.yticks([PB, PA], [f'4', f'3'], fontsize=12)\n\n    plt.tight_layout()\n    plt.show()\n\n# 関数を呼び出してグラフを表示\nplot_pv_diagram()\n\n\n\n\n\n\n\n\nFigure 3: Adiabatic compression process shown on a PV diagram\n\n\n\n\n\n\n工業仕事\n\n\n\n\n\n\n\n\n\n\n左図のような流動系の往復圧縮機での圧縮を考えます．プロセスは\n\n上死点から下死点までピストンが下がったとき，Figure 3 の状態1に相当する空気をを吸い込みます（\\(p_1v_1\\) の外部から流入する仕事）\nその後，ピストンを２の地点まで動かして断熱圧縮 = 状態1→状態2へ断熱圧縮\nピストンが2から上死点の間は吐出し弁が開き，気体を流出させることで \\(p_2v_2\\) の仕事を流出\n\n\n\n\n流体の吐出しによる外部への仕事\n吐出し弁から流体を流出させることで外部になす仕事は Figure 3 の 2'-2-3-0 の面積に相当するので\n\\[\n\\text{流体の吐出しによる外部への仕事} = p_2v_2\n\\]\n流体の吸込みによる外部からの仕事\nピストンの下降の家庭で吸込み弁からシリンダ内に流入する気体が，シリンダ内の期待に対してする仕事は Figure 3 の 1'-1-4-0 の面積に相当するので\n\\[\n\\text{流体の吸込みによる外部からの仕事} = p_1v_1\n\\]\n流体圧縮に要する絶対仕事\nシリンダ内の気体の圧縮に必要な仕事は Figure 3 の 1'-1-2-2' の面積に相当するので\n\\[\n\\text{流体圧縮に要する絶対仕事} = \\int_1^2 pdv\n\\]\n断熱の流動系が外部になす仕事\n断熱の流動系が外部になす仕事は，絶対仕事 \\(w_{12}\\) より流動仕事を引けば良いので\n\\[\n\\begin{align}\nw_{12} - (p_2v_2 - p_1v_1)\n  &= - \\int^2_1vdp\\\\\n  &= l_{12}\n\\end{align}\n\\]\n圧縮の場合は，仕事が入ってくるので右辺の値は負の値になります．断熱圧縮では加わった仕事に相当するだけ圧縮気体の比エンタルピーは増大することになります．\n\\(\\eqref{enthalpy-diff}\\) と照らし合わせると，熱交換がある場合の圧縮では，出入りした熱量 \\(q_{12}\\) に相当するだけd比エンタルピーが増減することがわかります．"
  },
  {
    "objectID": "posts/2025-06-13-heat-and-work/index.html#エントロピー",
    "href": "posts/2025-06-13-heat-and-work/index.html#エントロピー",
    "title": "エントロピーとエンタルピー",
    "section": "エントロピー",
    "text": "エントロピー\n\nDefinition 2 エントロピー\nエントロピーとは，ある変化が可逆変化とどの程度違うかを示す状態量のこと．単位質量の流体にある絶対温度 \\(T(K)\\) で熱量 \\(dq\\) が加えられた場合， \\(dq/T\\) を比エントロピー増加量 \\(ds\\) [J/kg･K] で表現される．\n\n可逆変化かつ断熱 → \\(ds = 0\\)\n不可逆変化では \\(ds &gt; 0\\)\n\n\n可逆断熱変化とエントロピー変化\n可逆断熱変化では \\(dq = 0\\) となるので定義より\n\\[\nds = 0\n\\]\nしたがって，可逆断熱変化は等比エントロピー変化であることがわかります．\n\n\n\n\n\n\nTip冷凍サイクルにおける断熱膨張\n\n\n\n断熱圧縮のコンプレッサーを冷媒で駆動すると原理的には断熱膨張エンジンになります． 理想の圧縮工程では，冷媒とシリンダとの間に熱の出入りの無い断熱圧縮をし，エントロピー変化もゼロです（=可逆変化）．ただし，断熱変化は必ずしも可逆変化ではありません．\n例えば，膨張弁は断熱変化ですが可逆変化ではありません．「熱力学の第二法則より物質は高圧から低圧に流れ，逆には流れない」のが直感的説明です． また，凝縮，蒸発の行程は全て不可逆変化で，エントロピーは増加します。\n\n\n等圧変化とエントロピー変化\n等圧変化を考えると，\n\\[\ndq = c_p dT\n\\]\nより\n\\[\nds = c_p \\frac{dT}{T}\n\\]\nしたがって，熱交換器のような等圧変化において，絶対温度 \\(T_1\\) の流体が熱量を受けて \\(T_2\\) となった場合，定圧比熱 \\(c_p\\) が一定であれば，エントロピー変化量 \\(s_2 - s_1\\) は\n\\[\n\\begin{align}\ns_2 - s_1\n  &= \\int^2_1 ds \\\\\n  &= c_p \\int^2_1\\frac{dT}{T}\\\\\n  &= c_p\\log\\left(\\frac{T_2}{T_1}\\right)\n\\end{align}\n\\]\nとなり，Ts線図を使用すると温度上昇曲線は指数曲線となります．また定義より\n\\[\ndq = Tds\n\\]\nなので，状態1から状態2への変化に要する熱量 \\(q_{12}\\) は\n\\[\nq_{12} = \\int^2_1 T ds\n\\]\nと積分に対応 = Ts線図の\\(s_1\\), \\(s_2\\)区間の曲線面積に対応して理解することができます．\n\n可逆過程（＝平衡状態の空間）の熱力学\n可逆変化においては \\(dq = Tds\\) が成立します．また，熱力学第一法則より\n\\[\ndu = dq - pdv\n\\]\nであるので，可逆過程における流体の内部エネルギーの微小変化は\n\\[\ndu = Tds - pdv\n\\]\nとなります．これらを整理すると\n\\[\n\\begin{align}\n\\left(\\frac{\\partial u}{\\partial s}\\right)_v &= T\\\\\n\\left(\\frac{\\partial u}{\\partial v}\\right)_s &= -p\\\\\n\\left(\\frac{\\partial s}{\\partial u}\\right)_v &= \\frac{1}{T}\\\\\n\\left(\\frac{\\partial s}{\\partial v}\\right)_u &= \\frac{p}{T}\n\\end{align}\n\\]\n\n\nMaxwellの関係式: エントロピー変化と全微分\n\\(s = s(T, v)\\) とみると，熱力学第一法則から\n\\[\n\\begin{align}\nds\n  &= \\frac{dq}{T}\\\\\n  &= \\frac{1}{T}(du + pdv)\\\\\n  &= \\frac{1}{T}\\left[\\left(\\frac{\\partial u}{\\partial T}\\right)_vdT + \\left(\\frac{\\partial u}{\\partial v}\\right)_Tdv + pdv\\right]\\\\\n  &= \\frac{1}{T}\\left(\\frac{\\partial u}{\\partial T}\\right)_vdT + \\frac{1}{T}\\left[\\left(\\frac{\\partial u}{\\partial v}\\right)_T + p\\right]dv\n\\end{align}\n\\]\n全微分を整理すると\n\\[\n\\frac{\\partial}{\\partial v}\\left[\\frac{1}{T}\\left(\\frac{\\partial u}{\\partial T}\\right)_v\\right] = \\frac{\\partial}{\\partial T}\\left[\\frac{1}{T}\\left(\\left(\\frac{\\partial u}{\\partial v}\\right)_T + p\\right)\\right]\n\\]\nつまり\n\\[\n\\begin{align}\n\\text{RHS}&=\\frac{1}{T}\\frac{\\partial^2u}{\\partial v\\partial T}\\\\\n\\text{LHS}&=-\\frac{1}{T^2}\\left[\\left(\\frac{\\partial u}{\\partial v}\\right)_T + p\\right] + \\frac{1}{T}\\frac{\\partial^2 u}{\\partial T \\partial v} + \\frac{1}{T}\\left(\\frac{\\partial P}{\\partial T}\\right)_v\n\\end{align}\n\\]\nこれらを整理すると次の関係式が導出できます\n\\[\n\\begin{align}\n\\left(\\frac{\\partial u}{\\partial v}\\right)_T\n  &= T\\left(\\frac{\\partial p}{\\partial T}\\right)_v - p\\\\\n  &= T^2\\frac{\\partial}{\\partial T}\\left(\\frac{p}{T}\\right)\n\\end{align}\n\\]\n単原子理想気体では \\(u = u(T)\\) であるので\n\\[\n\\frac{\\partial}{\\partial T}\\left(\\frac{p}{T}\\right) = 0 \\label{eq-ideal}\n\\]\nまた，\\(\\eqref{eq-ideal}\\) が成立するということは \\(p/T\\) が \\(v\\) のみの関数であることを意味するので\n\\[\np = f(v)T\n\\]\nと成ることがわかります．"
  },
  {
    "objectID": "posts/2025-06-13-heat-and-work/index.html#理解度チェック",
    "href": "posts/2025-06-13-heat-and-work/index.html#理解度チェック",
    "title": "エントロピーとエンタルピー",
    "section": "📘 理解度チェック",
    "text": "📘 理解度チェック\n\nExercise 1 熱力学エネルギー\n熱力学エネルギーを簡潔に説明せよ\n\n\n\n\n\n\n\nNoteSolution\n\n\n\n\n\n物体を構成する原子や分子の，熱運動による運動エネルギーと位置エネルギーの総和を，その熱力学エネルギーという\n\n\n\n\nExercise 2 熱力学第一法則\n次の記述のうち正しいものはどれか？\n\n一定容積（定積）で熱を加えると，体積が変わらないため外部に対して仕事をしない．そのため，その熱量はすべて内部エネルギーの変化に等しい，\n\n\n\n\n\n\n\n\nNoteSolution\n\n\n\n\n\na,\n\n\n\n\nExercise 3 熱力学第二法則\n次の記述のうち正しいものはどれか？\n\n熱は高温の物体から低温の物体にしか移動しない．このように，自然には逆向きの変化が発生しないことを不可逆変化という\n\n\n\n\n\n\n\n\nNoteSolution\n\n\n\n\n\na,\n\n\n\n\nExercise 4 エントロピーの基礎\n熱量とエンタルピーの違いを説明せよ\n\n\n\n\n\n\n\nNoteSolution\n\n\n\n\n\n\n熱量とはある物質から外部へ放出した（または外部から取込んだ）熱エネルギーのこと（外部エネルギー）\nエンタルピーはある物質が持っているエネルギー（熱＋圧力Energy）のこと\n\nある物質のエンタルピーが変化すると，その分だけ外部と熱や動力を出し入れします．水１kgの温度が１℃下がるのは，4.186kJの熱量で冷却されたからですが，4.186kJの熱量は外部エネルギーとなります．冷却の結果として１℃当り4.186kJ/kgだけ比エンタルピー（or内部エネルギー）が低いと表現する場合は状態量としての記述になります．\n\n\n\n\nExercise 5 冷凍サイクルと熱力学性質\n次の記述のうち正しいものはどれか？\n\n冷媒の熱力学性質を表にした飽和表から，飽和液及び飽和蒸気の比体積，比エンタルピー，比エントロピーなどを読み取ることができる．そして，飽和蒸気の比エンタルピーと飽和液の比エンタルピーの差が蒸発潜熱となる．\n圧縮機の圧力比が大きいほど，圧縮前後の比エンタルピー差は大きくなる．その結果，単位冷媒循環量あたりの理論断熱圧縮動力も大きくなる\n\n\n\n\n\n\n\n\nNoteSolution\n\n\n\n\n\na, b\n\n\n\n\nExercise 6 エントロピー\n閉じた系内の物質について\n\\[\n\\begin{align}\nT &= \\frac{u}{c}\\\\\np &= \\frac{RT}{v}\n\\end{align}\n\\]\nが成立するとします．\\(c\\) は定数，\\(R\\) は気体定数．基準状態のエントロピーを \\(s_0 = s(u_0, v_0)\\) として，ここから \\(s(u, v)\\) の状態までのエントロピー変化を \\(s(u, v) - s_0\\) とする．\\(s(u, v)\\) を求めよ\n\n\n\n\n\n\n\nNoteSolution\n\n\n\n\n\n熱力学第一法則より\n\\[\n\\begin{align}\nds\n  &= \\frac{dq}{T}\\\\\n  &= \\frac{1}{T}(du + pdv)\\\\\n  &= \\frac{c}{u}du + \\frac{R}{v}dv\n\\end{align}\n\\]\nこれを積分すれば \\(s = s(u, v)\\) が得られるので\n\\[\ns(u, v) = c\\log(u) + R\\log(v) + \\text{constant}\n\\]\n\\(s_0 = s(u_0, v_0)\\) であるので\n\\[\ns = c\\log(u/u_0) + R\\log(v/v_0) + s_0\n\\]"
  },
  {
    "objectID": "posts/2025-06-13-heat-and-work/index.html#appendix-圧力の公式",
    "href": "posts/2025-06-13-heat-and-work/index.html#appendix-圧力の公式",
    "title": "エントロピーとエンタルピー",
    "section": "Appendix: 圧力の公式",
    "text": "Appendix: 圧力の公式\n圧力とは \\(1\\text{m}^2\\) あたりに働く力のことをいいます．力との関係は以下のように表せます\n\\[\n\\text{圧力[Pa]} = \\frac{\\text{加えた力[N]}}{\\text{その力が加わっている面積}[\\text{m}^2]}\n\\]\n圧力の組立単位は \\(\\text{N}/\\text{m}^2\\) となりますが，通常は \\(1 \\text{N}/\\text{m}^2 = 1\\text{Pa}\\) としてPaを用いて表します．"
  },
  {
    "objectID": "posts/2025-04-08-probability-matrix-exercise/index.html",
    "href": "posts/2025-04-08-probability-matrix-exercise/index.html",
    "title": "確率行列と固有値",
    "section": "",
    "text": "Exercise 1 \n\\(n\\) 次非負実行列 \\(A = (a_{ij})\\) が\n\\[\n\\sum_{j=1}^n a_{ij} = 1\n\\]\nを満たすとき，\\(A\\) を確率行列と呼ぶ． このとき，以下が成立することを示せ\n\\[\nA\\pmb f = \\pmb f\n\\]\nただし，\\(\\pmb f = (1, \\cdots 1)^T\\)， つまり \\(\\pmb f\\) はすべての成分が1であるような \\(n\\)項列ベクトルであるとする．\n\n\n\n\n\n\n\n\n\nNoteProof\n\n\n\n\n\n\\(A\\pmb f\\) は \\(n\\) 項列ベクトルとなるので，その第 \\(i\\) 項成分を \\(b_i\\) とすると\n\\[\n\\begin{align}\nb_i\n    &= \\sum_{j=1}^n a_{ij}f_j\\\\\n    &= \\sum_{j=1}^n a_{ij} \\quad (\\because f_j = 1)\\\\\n    &= 1\n\\end{align}\n\\]\n従って，\n\\[\nA\\pmb f = (1, \\cdots, 1)^T = \\pmb f\n\\]\n\n\n\n\n\nExercise 2 \n\\(A, B\\) が \\(n\\) 次確率行列であるとき，\\(AB\\) も確率行列であることを示せ\n\n\n\n\n\n\n\n\n\nNoteProof\n\n\n\n\n\n\\(AB = (c_{ij})\\) とするとき，\n\\[\n\\begin{align}\nc_{ij} = \\sum_{k=1}^n a_{ik}b_{kj}\n\\end{align}\n\\]\nとなります．このとき\n\\[\n\\begin{align}\n\\sum_{j=1}^n c_{ij}\n    &= \\sum_{j=1}^n\\sum_{k=1}^n a_{ik}b_{kj}\\\\\n    &= \\sum_{k=1}^n\\sum_{j=1}^n a_{ik}b_{kj}\\\\\n    &= \\sum_{k=1}^n a_{ik}(\\sum_{j=1}^n b_{kj})\\\\\n    &= \\sum_{k=1}^n a_{ik} \\quad (\\because \\sum_{j=1}^n b_{kj} = 1)\\\\\n    &= 1\n\\end{align}\n\\]\n従って，\\(A, B\\) が \\(n\\) 次確率行列であるとき，\\(AB\\) も確率行列である．\n\n\n\n\n\nExercise 3 \n\\(A\\) が確率行列のとき，複素数 \\(\\lambda\\) に対して \\(A\\pmb x = \\lambda \\pmb x\\) となるような列ベクトル \\(\\pmb x \\neq \\pmb 0\\) が存在すれば\n\\[\n|\\lambda| \\leq 1\n\\]\nとなることを示せ．\n\n\n\n\n\n\n\n\n\nNoteProof\n\n\n\n\n\n\\(\\pmb x\\) の成分のうち絶対値が最大となるような成分を \\(|x_p|\\) とすると\n\\[\n\\begin{align}\n\\lambda x_p = \\sum_{i=1}^n a_{pi} x_i\n\\end{align}\n\\]\nここで，両辺について絶対値を取ると\n\\[\n\\begin{align}\n|\\lambda x_p | &= |\\lambda|\\,|x_p|\\\\\n\\left|\\sum_{i=1}^n a_{pi} x_i\\right|\n    & \\leq \\sum_{i=1}^n a_{pi} |x_i| \\quad (\\because\\text{三角不等式})\\\\\n    & \\leq  \\sum_{i=1}^n a_{pi} |x_p|\\\\\n    &= |x_p| \\quad(\\because \\sum_{i=1}^n a_{pi} = 1)\n\\end{align}\n\\]\n従って，\n\\[\n|\\lambda|\\,|x_p| \\leq |x_p| \\Rightarrow |\\lambda|\\leq 1\n\\]"
  },
  {
    "objectID": "posts/2025-04-08-probability-matrix-exercise/index.html#problem",
    "href": "posts/2025-04-08-probability-matrix-exercise/index.html#problem",
    "title": "確率行列と固有値",
    "section": "",
    "text": "Exercise 1 \n\\(n\\) 次非負実行列 \\(A = (a_{ij})\\) が\n\\[\n\\sum_{j=1}^n a_{ij} = 1\n\\]\nを満たすとき，\\(A\\) を確率行列と呼ぶ． このとき，以下が成立することを示せ\n\\[\nA\\pmb f = \\pmb f\n\\]\nただし，\\(\\pmb f = (1, \\cdots 1)^T\\)， つまり \\(\\pmb f\\) はすべての成分が1であるような \\(n\\)項列ベクトルであるとする．\n\n\n\n\n\n\n\n\n\nNoteProof\n\n\n\n\n\n\\(A\\pmb f\\) は \\(n\\) 項列ベクトルとなるので，その第 \\(i\\) 項成分を \\(b_i\\) とすると\n\\[\n\\begin{align}\nb_i\n    &= \\sum_{j=1}^n a_{ij}f_j\\\\\n    &= \\sum_{j=1}^n a_{ij} \\quad (\\because f_j = 1)\\\\\n    &= 1\n\\end{align}\n\\]\n従って，\n\\[\nA\\pmb f = (1, \\cdots, 1)^T = \\pmb f\n\\]\n\n\n\n\n\nExercise 2 \n\\(A, B\\) が \\(n\\) 次確率行列であるとき，\\(AB\\) も確率行列であることを示せ\n\n\n\n\n\n\n\n\n\nNoteProof\n\n\n\n\n\n\\(AB = (c_{ij})\\) とするとき，\n\\[\n\\begin{align}\nc_{ij} = \\sum_{k=1}^n a_{ik}b_{kj}\n\\end{align}\n\\]\nとなります．このとき\n\\[\n\\begin{align}\n\\sum_{j=1}^n c_{ij}\n    &= \\sum_{j=1}^n\\sum_{k=1}^n a_{ik}b_{kj}\\\\\n    &= \\sum_{k=1}^n\\sum_{j=1}^n a_{ik}b_{kj}\\\\\n    &= \\sum_{k=1}^n a_{ik}(\\sum_{j=1}^n b_{kj})\\\\\n    &= \\sum_{k=1}^n a_{ik} \\quad (\\because \\sum_{j=1}^n b_{kj} = 1)\\\\\n    &= 1\n\\end{align}\n\\]\n従って，\\(A, B\\) が \\(n\\) 次確率行列であるとき，\\(AB\\) も確率行列である．\n\n\n\n\n\nExercise 3 \n\\(A\\) が確率行列のとき，複素数 \\(\\lambda\\) に対して \\(A\\pmb x = \\lambda \\pmb x\\) となるような列ベクトル \\(\\pmb x \\neq \\pmb 0\\) が存在すれば\n\\[\n|\\lambda| \\leq 1\n\\]\nとなることを示せ．\n\n\n\n\n\n\n\n\n\nNoteProof\n\n\n\n\n\n\\(\\pmb x\\) の成分のうち絶対値が最大となるような成分を \\(|x_p|\\) とすると\n\\[\n\\begin{align}\n\\lambda x_p = \\sum_{i=1}^n a_{pi} x_i\n\\end{align}\n\\]\nここで，両辺について絶対値を取ると\n\\[\n\\begin{align}\n|\\lambda x_p | &= |\\lambda|\\,|x_p|\\\\\n\\left|\\sum_{i=1}^n a_{pi} x_i\\right|\n    & \\leq \\sum_{i=1}^n a_{pi} |x_i| \\quad (\\because\\text{三角不等式})\\\\\n    & \\leq  \\sum_{i=1}^n a_{pi} |x_p|\\\\\n    &= |x_p| \\quad(\\because \\sum_{i=1}^n a_{pi} = 1)\n\\end{align}\n\\]\n従って，\n\\[\n|\\lambda|\\,|x_p| \\leq |x_p| \\Rightarrow |\\lambda|\\leq 1\n\\]"
  },
  {
    "objectID": "posts/2025-04-08-probability-matrix-exercise/index.html#appendix",
    "href": "posts/2025-04-08-probability-matrix-exercise/index.html#appendix",
    "title": "確率行列と固有値",
    "section": "Appendix",
    "text": "Appendix\n\n\nTheorem 1 : 転置行列の固有値 \n任意の \\(n\\) 次正方行列 \\(A\\) に対して，\\(A\\) の固有値と \\(A^T\\) の固有値は等しい\n\n\n\n\n\n\n\n\n\nNoteProof\n\n\n\n\n\n\\(A\\) の固有値を \\(\\lambda\\) とすると，\\(\\lambda\\) は次の固有方程式の解と対応します．\n\\[\n|\\lambda \\pmb I - A| = 0\n\\]\n行列式は転置不変性，つまり\n\\[\n|\\lambda \\pmb I - A| = |(\\lambda \\pmb I - A)^T|\n\\]\nという性質を持つので\n\\[\n\\begin{align}\n|(\\lambda \\pmb I - A)^T|\n    &= |(\\lambda \\pmb I^T - A^T)|\\\\\n    &= |(\\lambda \\pmb I - A^T)|\\\\\n    &= 0\n\\end{align}\n\\]\n従って，\\(\\lambda\\) は \\(A^T\\) の固有方程式の解となることがわかるので，\\(A\\) の固有値と \\(A^T\\) の固有値は等しいことがわかる．"
  },
  {
    "objectID": "posts/2025-10-01-how-to-write-a-research-proposal/index.html",
    "href": "posts/2025-10-01-how-to-write-a-research-proposal/index.html",
    "title": "Research Proposalの書き方",
    "section": "",
    "text": "分析アイデア概要を記述する\nResearch Questionを定義する\nResearch Questionの重要性 / 分析のAim（目的）を記述する\n\n可能であれば，今回の分析提案が既存の既存研究のどこに位置づくのかを示す\n独自性がどこにあるかを過去の知識の積み重ねの中で示す\n\n期待される成果物を記述する\n分析アプローチと手法を記述する\n分析に必要なリソースについて記述する\n分析の実現可能性について記述する\n分析タイムラインを記述する"
  },
  {
    "objectID": "posts/2025-10-01-how-to-write-a-research-proposal/index.html#tldr",
    "href": "posts/2025-10-01-how-to-write-a-research-proposal/index.html#tldr",
    "title": "Research Proposalの書き方",
    "section": "",
    "text": "分析アイデア概要を記述する\nResearch Questionを定義する\nResearch Questionの重要性 / 分析のAim（目的）を記述する\n\n可能であれば，今回の分析提案が既存の既存研究のどこに位置づくのかを示す\n独自性がどこにあるかを過去の知識の積み重ねの中で示す\n\n期待される成果物を記述する\n分析アプローチと手法を記述する\n分析に必要なリソースについて記述する\n分析の実現可能性について記述する\n分析タイムラインを記述する"
  },
  {
    "objectID": "posts/2025-10-01-how-to-write-a-research-proposal/index.html#research-proposalとは",
    "href": "posts/2025-10-01-how-to-write-a-research-proposal/index.html#research-proposalとは",
    "title": "Research Proposalの書き方",
    "section": "📘 Research Proposalとは？",
    "text": "📘 Research Proposalとは？\n\nDefinition 1 Research Proposal\nResearch Proposalとは，分析におけるWhatとWhyとWhenとHowを明確に示す文書:\n\n\n\n\n\n\n\n項目\n説明\n\n\n\n\nWhat\n研究アイデアやResearch Question，期待される成果物を明確かつ具体的に提示する\n\n\nWhy\n提示したResearch Questionがなぜ重要なのか？どのような価値をもたらすのか？分析のAim（目的）はなにか？を記載する\n\n\nWhen\n分析スケジュールやタイムラインを明示する\n\n\nHow\n分析アプローチ，研究手法，必要なリソースや実現可能性について記載する\n\n\n\n\nQuestionに対するAnswerはResearch Proposalには記載しません．記載できるということは，すでに答えが分かっている問いになってしまうので，解く価値がないResearch Questionになってしまいます．\n分析の目的(Aim)の記述\n\nDefinition 2 Aim\nAimとは，研究が最終的に目指す目的を明確に述べるもの．例として以下，\n\n既存の分析に存在するギャップに取り組むのか？\nある理論を深く検証するのか，\n何かを証明／反証しようとしているのか\n研究が成功した場合に得られる成果を記述する\n\n\n記述にあたって，焦点を絞った簡潔なステートメントであることが求められます．\n分析アプローチとObjectives(目標)\nObjectives（目標）とは，Aimを達成するための具体的なステップを示すものとここでは定義します．その上で，分析アプローチはObjectivesベースでまず言語化することを目指します．\n\n\n\n\n\n\nNoteObjectivesベースでの分析アプローチ言語化観点例\n\n\n\n\nAimと照らし合わせて，何をどのような順序で達成すべきなのかを整理する\n各Objectiveに対して適切な手法や分析手順を対応させる\nデータ収集や前処理，モデル構築・評価などの具体的タスクを明示する\nObjectiveの達成順序に従い，分析のフローやスケジュールを設計する\n可能なリスクや実現可能性についても併せて検討する\n\n\n\n分析方法の記述の観点\n\n\n\n\n\n\nNote分析手法(methodology)の検討項目\n\n\n\n\nなぜその特定の方法論を選んだのか？\nなぜ他の方法が適さないのか？\n予想される制約や限界はなにか？\n\nというポイントを抑えとくことが重要です．\n\n\nPrimary/Secondary Endpointsの事前定義\n研究開始前にprimary endpoint（主要評価項目）とsecondary endpoint（副次評価項目）を明確に定義することが重要です．\n\n\n\n\n\n\n\n\n項目\n説明\n\n\n\n\nPrimary Endpoint\n研究の主目的に直接対応する最も重要な評価指標．仮説検証の中心となる\n\n\nSecondary Endpoint\n主要評価項目を補完する追加的な評価指標．探索的な分析や副次的な効果の検証に用いる\n\n\n\n\n\n\n\n\n\n\nNoteClarity at the start prevents bias at the end\n\n\n\n\nバイアスの防止: 結果を見てから評価指標を選ぶと，都合の良い結果を「主要な発見」として報告するcherry-pickingが起こりうる\n統計的妥当性の確保: 多重比較の問題を適切に扱うため，事前に検定の優先順位を決めておく必要がある\n研究の透明性: 事前登録（pre-registration）により，研究の信頼性と再現性が向上する\n\n\n\n\nExample 1 RCTにおける評価指標の例\nRCTでは，処置群（Treatment）と対照群（Control）の平均値の差を用いて処置効果の有無を統計的に検定することが一般的です．\n\\[\n\\text{処置効果} = \\bar{Y}_{\\text{Treatment}} - \\bar{Y}_{\\text{Control}}\n\\]\n\nPrimary Endpoint: 新薬の臨床試験において，投与12週後の血圧低下量（mmHg）の群間差\nSecondary Endpoint: 副作用発生率，QOLスコアの変化，治療継続率など\n\n帰無仮説 \\(H_0: \\mu_T - \\mu_C = 0\\)（処置効果なし）に対して，\\(t\\)検定やANCOVAなどを用いて統計的有意性を判定します．\n\n\n分析リソースの記述\n\n\n\n\n\n\nNote必要なリソースの内容例\n\n\n\n\n\n\n\n\n\n\n\nカテゴリ\n内容例\n\n\n\n\n1. データ関連\n- 利用可能なデータセット（一次データ or 二次データ）- データの量・質（サンプルサイズ，欠損の有無，信頼性）- データ取得方法（センサー，API，公開DB，実験・調査）\n\n\n2. 計算環境\n- 計算リソース（PC，GPU，クラウド環境）- 必要なストレージ容量- ソフトウェア環境（Python, R, SQL, TensorFlow, PyTorchなど）\n\n\n3. 人的リソース\n- 分析を行う研究者・データサイエンティスト- ドメイン知識を持つ専門家（例：HVACなら熱工学や設備の専門家）- コラボレーターや分析メンター\n\n\n4. 時間的リソース\n- データ収集にかかる時間- モデル開発・実験・検証に必要な期間- 論文や報告書執筆のための期間\n\n\n\n\n\n\n参考文献整理のすすめ\nビジネス提案書では参考文献を明示することは少ないかもしれないですが，社内内部的になぜこの提案に至ったのか？を上長へ説得するする際や引きスムーズな継ぎ時を実現するために整理することは有用です． クライアント向けに提示する際と合わせて，参考文献整理のメリットを以下で整理します\n\n\n\n\n\n\n\n\n\nポイント\n内容\n具体例・補足\n\n\n\n\n1. 研究・分析の背景を示す\n過去の分析や公開データ，既存の手法・モデルに基づき，自分の分析の位置付けを示す\n「なぜこの問題を解く必要があるか」「既存研究では何が不十分か」を裏付ける\n\n\n2. 信頼性の担保\nデータや手法の選定理由を文献に基づき説明することで，提案内容の説得力を増す\n評価者に「検討や調査に基づいている」と安心感を与える\n\n\n3. 方法論の妥当性を示す\n過去に用いられた分析手法やモデルの参考文献を挙げ，方法論の正当性を示す\n比較研究や改善の視点で，手法選定の根拠を示す\n\n\n4. 独自性・新規性の強調\n既存分析との差分やギャップを示すことで，自分の分析の新規性・意義を明確にする\n研究の独自性や学問的貢献を評価者に伝える"
  },
  {
    "objectID": "posts/2025-10-01-how-to-write-a-research-proposal/index.html#references",
    "href": "posts/2025-10-01-how-to-write-a-research-proposal/index.html#references",
    "title": "Research Proposalの書き方",
    "section": "References",
    "text": "References\n\nHow to write a research proposal &gt; A guide to preparing a strong research proposal."
  },
  {
    "objectID": "posts/2025-02-14-shogi-getting-started/index.html",
    "href": "posts/2025-02-14-shogi-getting-started/index.html",
    "title": "本日の詰将棋: Quiz 1~5",
    "section": "",
    "text": "Figure 1\n\n\n\n\n📘 KeyPoints \n\n初手に５二銀と捨てて，馬の利きを確保するのがポイント"
  },
  {
    "objectID": "posts/2025-02-14-shogi-getting-started/index.html#quiz-1-馬の利き",
    "href": "posts/2025-02-14-shogi-getting-started/index.html#quiz-1-馬の利き",
    "title": "本日の詰将棋: Quiz 1~5",
    "section": "",
    "text": "Figure 1\n\n\n\n\n📘 KeyPoints \n\n初手に５二銀と捨てて，馬の利きを確保するのがポイント"
  },
  {
    "objectID": "posts/2025-02-14-shogi-getting-started/index.html#quiz-2-角よりも銀",
    "href": "posts/2025-02-14-shogi-getting-started/index.html#quiz-2-角よりも銀",
    "title": "本日の詰将棋: Quiz 1~5",
    "section": "Quiz 2: 角よりも銀",
    "text": "Quiz 2: 角よりも銀"
  },
  {
    "objectID": "posts/2025-02-14-shogi-getting-started/index.html#quiz-3-金頭桂",
    "href": "posts/2025-02-14-shogi-getting-started/index.html#quiz-3-金頭桂",
    "title": "本日の詰将棋: Quiz 1~5",
    "section": "Quiz 3: 金頭桂",
    "text": "Quiz 3: 金頭桂\n\n\n\n\n\n\nFigure 2\n\n\n\n\n📘 KeyPoints \n\n竜を切ってからの金頭桂"
  },
  {
    "objectID": "posts/2025-02-14-shogi-getting-started/index.html#quiz-4",
    "href": "posts/2025-02-14-shogi-getting-started/index.html#quiz-4",
    "title": "本日の詰将棋: Quiz 1~5",
    "section": "Quiz 4",
    "text": "Quiz 4\n\n\n\n\n\n\n\n\n\n\n\n派生：５三に歩が存在する場合\n相手玉の逃げ道が少なくなるので，一手早く積ませることが出来ます\n\n\n\n\n\n\nFigure 3"
  },
  {
    "objectID": "posts/2025-02-14-shogi-getting-started/index.html#quiz5-飛車を切る",
    "href": "posts/2025-02-14-shogi-getting-started/index.html#quiz5-飛車を切る",
    "title": "本日の詰将棋: Quiz 1~5",
    "section": "Quiz5: 飛車を切る",
    "text": "Quiz5: 飛車を切る\n\n\n\n\n\n\n\n\n\n\n\n📘 KeyPoints \n\n馬の利きを通すためあえて竜を切る\n金２枚の代わりに斜めのコマ一つ（金一 & 角 or 銀一）の場合でも詰むことができる"
  },
  {
    "objectID": "posts/2025-11-15-ETL-note/index.html",
    "href": "posts/2025-11-15-ETL-note/index.html",
    "title": "ETLメモ",
    "section": "",
    "text": "Definition 1 ETL\n\nExtract（抽出）・Transform（変換）・Load（格納） の略\n要件として\n\n自動化されていること\n再現性があること\nデータがどのように加工されか追跡しやすいこと\n\n\n\nPythonでETL toolを作成する場面\n\nETL要件がシンプルなとき\n既存ツールでは満たせない特殊要件があるとき"
  },
  {
    "objectID": "posts/2025-11-15-ETL-note/index.html#etlとは",
    "href": "posts/2025-11-15-ETL-note/index.html#etlとは",
    "title": "ETLメモ",
    "section": "",
    "text": "Definition 1 ETL\n\nExtract（抽出）・Transform（変換）・Load（格納） の略\n要件として\n\n自動化されていること\n再現性があること\nデータがどのように加工されか追跡しやすいこと\n\n\n\nPythonでETL toolを作成する場面\n\nETL要件がシンプルなとき\n既存ツールでは満たせない特殊要件があるとき"
  },
  {
    "objectID": "posts/2025-11-15-ETL-note/index.html#etl作業フロー",
    "href": "posts/2025-11-15-ETL-note/index.html#etl作業フロー",
    "title": "ETLメモ",
    "section": "ETL作業フロー",
    "text": "ETL作業フロー\n作業フロー\n\n構造化されていないケースが多いファイル群からデータを抽出する\nデータクレンジングを実施\nあるべきデータフォーマットに従うように型を付与する\nデータをDBなどに格納する"
  },
  {
    "objectID": "posts/2025-11-15-ETL-note/index.html#代表的なetl-tool",
    "href": "posts/2025-11-15-ETL-note/index.html#代表的なetl-tool",
    "title": "ETLメモ",
    "section": "代表的なETL tool",
    "text": "代表的なETL tool\n\n\n\n\n\n\n\n\n\n\n\n\n\n項目\nApache Airflow\nLuigi\npandas\npetl\nBonobo\nBubbles\n\n\n\n\n種類\nワークフローオーケストレーション\nパイプラインのタスクオーケストレーション\nデータ分析・変換ライブラリ\n軽量ETLフレームワーク\n軽量ETLフレームワーク\nメタデータ駆動型ETLフレームワーク\n\n\n変換機能\nPythonオペレーター経由で間接的\nあり（カスタムタスク）\n豊富なDataFrame変換\n基本的な行単位変換\nあり（ノードによる変換）\n限定的\n\n\nリアルタイム対応\nなし\nなし\nなし\nなし\nなし\nなし\n\n\nコネクタ\nPython/コミュニティ製プラグイン\nファイルシステム、DB（拡張可能）\nCSV, Excel, SQL, JSON など\nCSV, Excel, JSON, SQL, XML\nファイル、API、DB\nCSV, SQL, JSON, HTTP\n\n\nスケジューリング\nあり（リトライ・アラート対応）\nあり（内部スケジューラ）\nなし\nなし\nなし\nなし\n\n\n並列処理\nあり（Celery, Kubernetes など）\nあり\nPandas の並列オプション程度\nなし\nあり（マルチスレッド）\n限定的\n\n\n適している用途\n複雑なパイプラインのオーケストレーション\n依存関係のあるタスク管理\nデータクリーニング・分析・整形\n軽量のETL作業\n小規模ETL・パイプライン可視化\n学術用途・プロトタイプETL\n\n\n制限\n学習コスト高い、リアルタイム不可\nUIが基本的、スケールに制限\nメモリ内のみで大規模データは難しい\nスケジューラ・オーケストレーションなし\nエコシステム小、コミュニティ少\nメンテナンスされておらず更新ほぼなし\n\n\nサポート\n活発なコミュニティ、商用サポートあり\nコミュニティサポート\n大規模コミュニティ、豊富なエコシステム\n小規模コミュニティ\nニッチなコミュニティ\n最小限のコミュニティ、更新もほぼなし"
  },
  {
    "objectID": "posts/2025-09-23-quarto-preview-with-tailscale/index.html",
    "href": "posts/2025-09-23-quarto-preview-with-tailscale/index.html",
    "title": "QuartoコンテンツをTailnetで公開する",
    "section": "",
    "text": "Note📘 解説内容\n\n\n\n\nquarto preview をバックグラウンドプロセスとして実行する方法\nquarto preview の内容をtailnet内で公開する方法"
  },
  {
    "objectID": "posts/2025-09-23-quarto-preview-with-tailscale/index.html#quarto-preview-as-background-process",
    "href": "posts/2025-09-23-quarto-preview-with-tailscale/index.html#quarto-preview-as-background-process",
    "title": "QuartoコンテンツをTailnetで公開する",
    "section": "Quarto Preview as background process",
    "text": "Quarto Preview as background process\nバックグラウンドでquarto previewを実行する場合は以下のコマンドとなります\nnohup quarto preview &gt; ~/.var/quarto.log  2&gt;&1 &\n\n\n\n\n\n\n\n\n要素\n意味\n\n\n\n\nnohup\nターミナルを閉じてもプロセスを終了させない\n\n\nquarto preview\nQuarto プロジェクトをプレビューするコマンド\n\n\n&gt;\n標準出力 (stdout) のリダイレクト\n\n\n~/.var/quarto.log\nログ出力先ファイル\n\n\n2&gt;&1\n標準エラー (stderr) を標準出力に結合(=stdout と stderr を同じファイルにまとめる)\n\n\n&\nコマンドをバックグラウンドで実行\n\n\n\n\n\nバックグラウンドプロセスをkillする\n\n① 起動シェルと同じシェルでkillする場合\nバックグラウンドジョブを起動したシェルと同じシェルでジョブをkillしたい場合は jobs コマンドで該当ジョブを検索することができます\n$ jobs\n[1]  + running    nohup quarto preview &gt; ~/.var/quarto.log 2&gt;&1\nこのプロセスをkillする場合は\n$ kill %1\n\n② 別のシェルでkillする場合\nps auxで該当プロセスを検索して，killという手順になりjます．実行すると\n$ ps aux | grep \"quarto\"\nkirby+ 1710278  0.0  0.0   9940  3608 pts/8    SN   19:57   0:00 bash /usr/local/bin/quarto preview\nkirby+ 1710301 14.3  0.5 46064208 164504 pts/8 SNl  19:57   0:02 /opt/quarto/bin/tools/x86_64/deno run --unstable-ffi --unstable-kv --no-config --no-lock --cached-only --allow-all --no-check --v8-flags=--enable-experimental-regexp-engine,--max-old-space-size=8192,--max-heap-size=8192 /opt/quarto/bin/quarto.js preview\nとなりますが，このとき kill するのは後者となります．つまり，\n$ kill 1710301\nnohup quarto preview &gt; ~/.var/quarto.log  2&gt;&1 & を実施すると\n[1] 1710278\nのようにジョブ番号に対応したPIDが表示されますが，この番号は quarto preview ラッパーのPIDであって，実際に止めるべきは /opt/quarto/bin/tools/x86_64/deno の方となります．"
  },
  {
    "objectID": "posts/2025-09-23-quarto-preview-with-tailscale/index.html#tailscale-serve-を使ったローカルサービス公開",
    "href": "posts/2025-09-23-quarto-preview-with-tailscale/index.html#tailscale-serve-を使ったローカルサービス公開",
    "title": "QuartoコンテンツをTailnetで公開する",
    "section": "Tailscale Serve を使ったローカルサービス公開",
    "text": "Tailscale Serve を使ったローカルサービス公開\ntailscale serve を用いることでlocalhostで動いているサービスを自分の Tailnet内（Tailscale VPN 内）のみでアクセスできるように公開できます． Tailscale アカウントで認証した端末だけアクセス可能なので，セキュアなサービス公開となります．\nTCPフォワーディングを用いて，外部からのアクセスをlocalの8998 Portへ転送しています．クライアントとサーバーが直接 TCP で通信する形になり，セキュリティや暗号化はサービス側に任すことになります．\n ▶  実行例\n# ポート4200のサービスを公開\n$ sudo tailscale serve 4200\nAvailable within your tailnet:\n\nhttps://xxxxxx.tailxxxxx.ts.net/\n|-- proxy http://127.0.0.1:4200\n\nPress Ctrl+C to exit.\n\n\n\n\n\n\n\n\n項目\n意味\n\n\n\n\ntailscale serve 4200\nローカルマシンの 127.0.0.1:4200 で動いているサービスを Tailscale 経由で公開するコマンド．\n\n\nhttps://xxxxxx.tailxxxxx.ts.net/\nTailscale が自動で割り当てた対象端末専用のサブドメイン．Tailnet 内の認証済みデバイスからのみアクセス可能．\n\n\n\n\n\nServing in Background\nbackgroundプロセスでserviceをtailnet内で公開したい場合は --bg フラグを付与してtailscale serveを実行します．\n# 現在の公開状況を確認\nsudo tailscale serve status\n\n# ポート4200のサービスを公開\nsudo tailscale serve --bg 4200\n公開を停止したい場合は\nsudo tailscale serve off\n\n\nHTTPS リバースプロキシ経由公開する\nsudo tailscale serve --bg --https=4200 4200\nとすると，外部から https://&lt;マシン名&gt;.&lt;tailnet&gt;.ts.net:4200 にアクセスするとローカルの http://127.0.0.1:4200 に転送されます．\n\nHTTPS (TLS) が自動で有効\n複数のサービスをポートを分けて同時に公開することができる\n\nというメリットがあります．Killしたい場合は\nsudo tailscale serve --https=4200 off\nで完了です．"
  },
  {
    "objectID": "posts/2025-09-23-quarto-preview-with-tailscale/index.html#appendix-ポート番号の範囲",
    "href": "posts/2025-09-23-quarto-preview-with-tailscale/index.html#appendix-ポート番号の範囲",
    "title": "QuartoコンテンツをTailnetで公開する",
    "section": "Appendix: ポート番号の範囲",
    "text": "Appendix: ポート番号の範囲\n\n\n\n\n\n\n\n\n\n範囲\n用途\n備考\n\n\n\n\n0〜1023\nWell Known Ports（HTTP, SSH, FTP など）\n特権ポート：ルート権限（特権ユーザー）のみがバインド可能\n\n\n1024〜49151\nRegistered Ports / User Ports\n一般ユーザーも使用可能．IANA に登録されたサービス向け\n\n\n49152〜65535\n動的／プライベートポート（クライアント通信用）\n一時的に割り当てられるポート．一般ユーザー使用可\n\n\n\n\n\nRegistered Portsの範囲はRFC1700(Oct 1994)では1024~65535とされているが，RFC6335(Aug 2011)では1024〜49151"
  },
  {
    "objectID": "posts/2025-09-23-quarto-preview-with-tailscale/index.html#references",
    "href": "posts/2025-09-23-quarto-preview-with-tailscale/index.html#references",
    "title": "QuartoコンテンツをTailnetで公開する",
    "section": "References",
    "text": "References\n\nFunnel serve multiple ports?"
  },
  {
    "objectID": "posts/2025-06-27-ubuntu-snap-assistant/index.html",
    "href": "posts/2025-06-27-ubuntu-snap-assistant/index.html",
    "title": "Windowsライクなスナップ機能をUbuntuで使う",
    "section": "",
    "text": "デスクトップ上でウィンドウを簡単に配置できるようにする\n左右半分，上下半分という配置をキーボードショートカットで操作可能にする"
  },
  {
    "objectID": "posts/2025-06-27-ubuntu-snap-assistant/index.html#goal",
    "href": "posts/2025-06-27-ubuntu-snap-assistant/index.html#goal",
    "title": "Windowsライクなスナップ機能をUbuntuで使う",
    "section": "",
    "text": "デスクトップ上でウィンドウを簡単に配置できるようにする\n左右半分，上下半分という配置をキーボードショートカットで操作可能にする"
  },
  {
    "objectID": "posts/2025-06-27-ubuntu-snap-assistant/index.html#拡張機能-tilting-assistantのインストール",
    "href": "posts/2025-06-27-ubuntu-snap-assistant/index.html#拡張機能-tilting-assistantのインストール",
    "title": "Windowsライクなスナップ機能をUbuntuで使う",
    "section": "✅ 拡張機能 Tilting Assistantのインストール",
    "text": "✅ 拡張機能 Tilting Assistantのインストール\n\nsudo apt install gnome-shell-extension-manager でextension managerをインストールする\nFirefoxでGnome Extensions &gt; Tiling Assistantを開き，インストールする"
  },
  {
    "objectID": "posts/2025-06-27-ubuntu-snap-assistant/index.html#設定",
    "href": "posts/2025-06-27-ubuntu-snap-assistant/index.html#設定",
    "title": "Windowsライクなスナップ機能をUbuntuで使う",
    "section": "🔨 設定",
    "text": "🔨 設定\n挙動一般\n\nデフォルトではTilingした直後にアプリ一覧(Tiling Popup)が空きスペースに表示されるが，その機能をOffにする\n\n\nコマンド操作\n\n\n\n\nコマンド\n挙動\n\n\n\n\nSuper + Up\nWindowをモニターの上半分に移動するToggle\n\n\nSuper + Down\nWindowをモニターの下半分に移動するToggle\n\n\nSuper + Left\nWindowをモニターの左半分に移動するToggle\n\n\nSuper + Right\nWindowをモニターの右半分に移動するToggle\n\n\nSuper + F11\nWindowを最大サイズにするToggle\n\n\n\n\n\n設定実装\n\nExtension ManageをDesktop環境から開く\ntiling assistantを開き以下の画像のような設定にする\n\n\n\n\n\n\n\nGeneral設定\n\n\n\n\n\n\n\nKeybindings設定"
  },
  {
    "objectID": "posts/2025-06-27-ubuntu-snap-assistant/index.html#references",
    "href": "posts/2025-06-27-ubuntu-snap-assistant/index.html#references",
    "title": "Windowsライクなスナップ機能をUbuntuで使う",
    "section": "References",
    "text": "References\n\nTiling-Assistant Repository"
  },
  {
    "objectID": "posts/2025-02-27-how-to-compute-tan75/index.html",
    "href": "posts/2025-02-27-how-to-compute-tan75/index.html",
    "title": "tangent 75°の図形的計算",
    "section": "",
    "text": "Exercise 1 \n\\(\\tan {75}^\\circ\\) を求めよ\n\n\n\n\n\n\n\n\n\nNote解1: 加法定理を用いる場合\n\n\n\n\n\n\\[\n\\begin{align}\n\\tan {45}^\\circ &= 1\\\\\n\\tan {30}^\\circ &= \\frac{\\sqrt{3}}{3}\n\\end{align}\n\\]\nより，加法定理を用いて\n\\[\n\\begin{align}\n\\tan {75}^\\circ\n    &= \\frac{\\tan{30}^\\circ + \\tan{45}^\\circ}{1 - \\tan{30}^\\circ\\tan{45}^\\circ}\\\\\n    &= \\frac{1 + \\frac{\\sqrt{3}}{3}}{1 - \\frac{\\sqrt{3}}{3}}\\\\\n    &= 2 + \\sqrt{3}\n\\end{align}\n\\]\n\n\n\n\n\n\n\n\n\n\nNote解2: 平面幾何的に求める場合\n\n\n\n\n\n\\(\\angle A = {30}^\\circ, \\angle B = {90}^\\circ, \\angle C = {60}^\\circ\\) の \\(\\triangle ABC\\) を考えたとき，\\(\\angle A\\) の斜辺 \\(AC\\) を用いて 直角二等辺三角形 \\(\\triangle ACD\\) をまず作成します．\nこの点 \\(D\\) を通るように \\(AB\\) と平行な線を引き，長方形 \\(AEFB\\) を以下のように作成します．\n\nCode\nimport shapely.plotting\nimport matplotlib.pyplot as plt\nfrom shapely.geometry import Polygon\nimport numpy as np\n\nA = (0, 0)\nB = (1, 0)\nC = (1, np.sin(np.radians(30)))\nD = (np.sqrt(2) * np.cos(np.radians(75)), np.sqrt(2) * np.sin(np.radians(75)))\nE = (0, np.sqrt(2) * np.sin(np.radians(75)))\nF = (1, np.sqrt(2) * np.sin(np.radians(75)))\n\npolygon1 = Polygon([A, B, C])\npolygon2 = Polygon([A, C, D])\npolygon3 = Polygon([A, E, D])\npolygon4 = Polygon([C, D, F])\n\nfig, ax = plt.subplots(figsize=(6, 6))\n\nshapely.plotting.plot_polygon(polygon1, ax=ax)\nshapely.plotting.plot_polygon(polygon2, alpha=0.5, facecolor='none', ax=ax)\nshapely.plotting.plot_polygon(polygon3, alpha=0.5, facecolor='red', ax=ax)\nshapely.plotting.plot_polygon(polygon4, ax=ax)\n\n# 軸の範囲を設定\nplt.xlim(-0.1, 1.45)\nplt.ylim(-0.1, 1.45)\n\n# add label\nplt.text(A[0], A[1] - 0.05, 'A')\nplt.text(B[0]+0.02, B[1] - 0.05, 'B')\nplt.text(C[0]+0.02, C[1], 'C')\nplt.text(D[0], D[1] + 0.02, 'D')\nplt.text(E[0], E[1] + 0.02, 'E')\nplt.text(F[0], F[1] + 0.02, 'F')\n\n# Add Angles\nax.text(A[0] + 0.06, A[1], f\"{30}°\", fontsize=10)\nax.text(A[0] + 0.06, A[1] + 0.1, f\"{45}°\", fontsize=10)\nax.text(B[0] - 0.09, B[1], f\"{90}°\", fontsize=10)\nax.text(C[0] - 0.1, C[1], f\"{90}°\", fontsize=10)\nax.text(C[0] - 0.1, C[1] + 0.14, f\"{30}°\", fontsize=10)\nax.text(C[0] - 0.1, C[1] - 0.1, f\"{60}°\", fontsize=10)\n\n# Add length\nax.text(0.5, -0.08, \"$\\sqrt{3}$\", fontsize=12, color=\"black\", horizontalalignment=\"center\")\nax.text(0.5, 0.3, \"2\", fontsize=12, color=\"black\", horizontalalignment=\"center\")\nax.text(0.5, 1.0, \"2\", fontsize=12, color=\"black\", horizontalalignment=\"center\")\nax.text(1.05, 0.2, \"1\", fontsize=12, color=\"black\", horizontalalignment=\"left\")\nax.text(1.05, 1.0, \"$\\sqrt{3}$\", fontsize=12, color=\"black\", horizontalalignment=\"left\")\nax.text((D[0] + F[0])/2, 1.37,  \"1\", fontsize=12, color=\"black\", horizontalalignment=\"center\")\nax.text((D[0] + E[0])/2, 1.37,  \"$\\sqrt{3} - 1$\", fontsize=12, color=\"black\", horizontalalignment=\"center\")\n\n\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 1\n\n\n\nこのとき， \\(\\triangle CFD  \\equiv \\triangle ABC\\) なので\n\n\\(AE = 1 + \\sqrt{3}\\)\n\\(DE = \\sqrt{3} - 1\\)\n\nであることがわかります．\\(\\triangle ACD\\) は直角二等辺三角形なので \\(\\angle ADC = {45}^\\circ\\)．従って，\n\\[\n\\angle ADE = {75}^\\circ\n\\]\nよって，\n\\[\n\\begin{align}\n\\tan{75}^\\circ\n    &= \\frac{1 + \\sqrt{3}}{\\sqrt{3} - 1} \\\\\n    &= \\frac{4 + 2\\sqrt{3}}{2}\\\\\n    &= 2 + \\sqrt{3}\n\\end{align}\n\\]"
  },
  {
    "objectID": "posts/2025-08-26-bats-core/index.html",
    "href": "posts/2025-08-26-bats-core/index.html",
    "title": "シェルスクリプト用のUnit Testingフレームワーク: Bats",
    "section": "",
    "text": "Batsとは，TAP準拠のBash用テストフレームワーク\nBash 3.2以上をカバー\n\n\n\n# Run a single test file\nbats test.bats\n\n# Run all tests in a directory\nbats test/\n\n# Run tests recursively\nbats -r test/\n\n# Run tests in parallel (requires GNU parallel)\nbats --jobs 4 test/"
  },
  {
    "objectID": "posts/2025-08-26-bats-core/index.html#batsとは",
    "href": "posts/2025-08-26-bats-core/index.html#batsとは",
    "title": "シェルスクリプト用のUnit Testingフレームワーク: Bats",
    "section": "",
    "text": "Batsとは，TAP準拠のBash用テストフレームワーク\nBash 3.2以上をカバー\n\n\n\n# Run a single test file\nbats test.bats\n\n# Run all tests in a directory\nbats test/\n\n# Run tests recursively\nbats -r test/\n\n# Run tests in parallel (requires GNU parallel)\nbats --jobs 4 test/"
  },
  {
    "objectID": "posts/2025-08-26-bats-core/index.html#installation-via-git-submodule-add",
    "href": "posts/2025-08-26-bats-core/index.html#installation-via-git-submodule-add",
    "title": "シェルスクリプト用のUnit Testingフレームワーク: Bats",
    "section": "Installation via git submodule add",
    "text": "Installation via git submodule add\n\n\n\n\n\n\nNoteBats Version\n\n\n\n2025-08-28時点で下記の方法でインストールすると Bats 1.12.0 がインストールされます\n% bats --version\nBats 1.12.0\n\n\nRepository Rootで以下のコマンドを実行します\ngit submodule add https://github.com/bats-core/bats-core.git test/bats\ngit submodule add https://github.com/bats-core/bats-support.git test/test_helper/bats-support\ngit submodule add https://github.com/bats-core/bats-assert.git test/test_helper/bats-assert\n結果として以下のような構成になります\nscript/\n    bazaar_zen.sh\n    ...\ntest/\n    bats/               &lt;- submodule\n    test_helper/\n        bats-support/   &lt;- submodule\n        bats-assert/    &lt;- submodule\n    test.bats\nユニットテスト用のファイルは上記の例では test.bats にあります． このファイルを編集することでユニットテストケースを設定していきます．\nOptional: パラレル処理\nBatsはデフォルトではシリアルにテストを実行していきますが，--jobs を指定することでパラレル処理も実行可能です． ただし，パラレル処理のときはテストの実行順番は保証されないことに注意が必要です．\nこの処理を実現するためには GNU parallel が必要です．\nsudo apt-get install -y parallel"
  },
  {
    "objectID": "posts/2025-08-26-bats-core/index.html#bats-unit-testing",
    "href": "posts/2025-08-26-bats-core/index.html#bats-unit-testing",
    "title": "シェルスクリプト用のUnit Testingフレームワーク: Bats",
    "section": "Bats Unit Testing",
    "text": "Bats Unit Testing\n\n\n\n\n\n\nNoteKey Points\n\n\n\n\nテストファイルのshebangは #!/usr/bin/env bats と設定すること\nテストファイルは .bats 拡張子で終わること\nテストが return 0 で終了するとそのテストは成功と扱われる．それ以外(return 1)は失敗\ntest descriptionは絶対記載すること\nヘルパー関数を除いて，基本的には標準的なshell syntaxに従って記述すること\nテスト用環境の構築と削除に対応する関数 setup, teardownは活用すること\nsetup, teardownはテストの前に呼ばれる必要がある\n$BATS_TEST_FILENAME変数はテストファイル名を格納した変数\n\n\n\n例として，シェルスクリプトレポジトリに次のような bazaar_zen.sh があるとします\n#!/bin/bash\n\nset -euo pipefail\n\n# error if any arguments are passed\nif [ \"$#\" -ne 0 ]; then\n  echo \"Usage: no arguments allowed\" &gt;&2\n  exit 1\nfi\n\ncat &lt;&lt;EOF\n1. Every good work of software starts by scratching a developer's personal itch.\n2. Good programmers know what to write. Great ones know what to rewrite (and reuse).\n3. Plan to throw one away; you will, anyhow.\n4. If you have the right attitude, interesting problems will find you.\n5. When you lose interest in a program, your last duty to it is to hand it off to a competent successor.\n6. Treating your users as co-developers is your least-hassle route to rapid code improvement and effective debugging.\n7. Release early. Release often. And listen to your customers.\n8. Given a large enough beta-tester and co-developer base, almost every problem will be characterized quickly and the fix obvious to someone.\n9. Smart data structures and dumb code works a lot better than the other way around.\n10. If you treat your beta-testers as if they're your most valuable resource, they will respond by becoming your most valuable resource.\n11. The next best thing to having good ideas is recognizing good ideas from your users. Sometimes the latter is better.\n12. Often, the most striking and innovative solutions come from realizing that your concept of the problem was wrong.\n13. Perfection (in design) is achieved not when there is nothing more to add, but rather when there is nothing more to take away.\n14. Any tool should be useful in the expected way, but a truly great tool lends itself to uses you never expected.\n15. When writing gateway software of any kind, take pains to disturb the data stream as little as possible and never throw away information unless the recipient forces you to!\n16. When your language is nowhere near Turing-complete, syntactic sugar can be your friend.\n17. A security system is only as secure as its secret. Beware of pseudo-secrets.\n18. To solve an interesting problem, start by finding a problem that is interesting to you.\n19. Provided the development coordinator has a communications medium at least as good as the Internet, and knows how to lead without coercion, many heads are inevitably better than one.\nEOF\nこれは，プログラミング哲学を標準出力するだけのスクリプトです．\nUnit Test方針\n\n\n\n\n\n\n\n\n\n\nTest No\n確認観点\n方法・コマンド例\n意図・理由\n\n\n\n\n1\n基本動作の確認\nrun ./script.sh → status -eq 0\nスクリプトが正常終了するか（最低限の「実行可能性」の担保）\n\n\n2\n行数の検証\nwc -l &lt;&lt;&lt; \"$output\" → -eq 19\n出力が仕様通りの行数（19行）か確認し，欠落や余分な行がないことを保証\n\n\n3\n先頭行の確認\nhead -n 1 &lt;&lt;&lt; \"$output\" → 部分一致\n最初の行が期待通り始まっているかを確認し，仕様崩れを防止\n\n\n4\n末尾行の確認\ntail -n 1 &lt;&lt;&lt; \"$output\" → 部分一致\n最後の行が期待通り終わっているかを確認し，途中での欠落や追加を防止\n\n\n5\n引数エラーの確認\nrun ./script.sh unexpected_arg → status -ne 0\n不正な引数が与えられたときにエラー終了することを確認し，誤用を防止\n\n\n\n\nUnit Testの実装\n\n\n\n\n\n\nNoteKey Points\n\n\n\n\nsetup() にて，各テストケースに共通の設定を実施．今回は，スクリプトのPATHを通したのみ\n@test グループの記述が個別のテストケースに相当\n\n\n\nテストファイル test_bazaar_zen.bats の実装場所は以下を想定しています\nrepository root\n├── script\n│   └── bazaar_zen.sh\n└── test\n    ├── bats\n    ├── test_for_script\n    │   └── test_bazaar_zen.bats\n    └── test_helper\nこの構成の下，テストファイルを以下のように定義します\n#!/usr/bin/env bats\n\nsetup() {\n  load '../test_helper/bats-support/load'\n  load '../test_helper/bats-assert/load'\n  # get the containing directory of this file\n  # use $BATS_TEST_FILENAME instead of ${BASH_SOURCE[0]} or $0,\n  # as those will point to the bats executable's location or the preprocessed file respectively\n  DIR=\"$(cd \"$(dirname \"$BATS_TEST_FILENAME\")\" &gt;/dev/null 2&gt;&1 && pwd)\"\n  \n  # make executables in script/ visible to PATH\n  OLD_PATH=$PATH\n  PATH=\"$DIR/../../script:$PATH\"\n}\n\nteardown() {\n  # PATHを元に戻す\n  PATH=$OLD_PATH\n}\n\n\n@test \"bazaar_zen.sh runs successfully\" {\n  run bazaar_zen.sh\n  assert_success\n}\n\n@test \"outputs 19 lines\" {\n  run bazaar_zen.sh\n  line_count=$(echo \"$output\" | wc -l)\n  [ \"$line_count\" -eq 19 ] || { \n      echo \"FAILED: Expected 19 lines but got $line_count\" &gt;&2\n      return 1\n  }\n}\n\n@test \"first line is correct\" {\n  run bazaar_zen.sh\n  assert_line --index 0 --partial \"1. Every good work of software starts\"\n}\n\n@test \"last line is correct\" {\n  run bazaar_zen.sh\n  assert_line --index -1 --partial \"many heads are inevitably better than one\"\n}\n\n@test \"rules.sh fails with unexpected args\" {\n  run bazaar_zen.sh unexpected_arg\n  assert_failure\n  assert_output --partial \"Usage: no arguments allowed\"\n}\nUnit testの実行\n% bats test/test_for_script\ntest_bazaar_zen.bats\n ✓ bazaar_zen.sh runs successfully\n ✓ outputs 19 lines\n ✓ first line is correct\n ✓ last line is correct\n一つ以上のテストがFAILEDの場合は以下のような出力になります\n% bats test/test_for_script\ntest_bazaar_zen.bats\n ✓ bazaar-zen runs successfully\n ✗ outputs 19 lines\n   (in test file test/test_for_script/test_bazaar-zen.bats, line 33)\n     `return 1' failed\n   FAILED: Expected 19 lines but got 18\n ✓ first line is correct\n ✓ last line is correct\n ✓ rules.sh fails with unexpected args\n\n5 tests, 1 failure\n\nsetup 関数とteardown関数\n\n\n\n\n\n\nNote目的\n\n\n\n\nassert_successなどのヘルパー関数のload\nテストしたいシェルスクリプト bazaar_zen.sh へのPATHをbatsテスト環境用に定義する\nテスト終了後に環境用に定義した設定を破棄する\n\n\n\nsetup() {\n  load '../test_helper/bats-support/load'\n  load '../test_helper/bats-assert/load'\n  # get the containing directory of this file\n  # use $BATS_TEST_FILENAME instead of ${BASH_SOURCE[0]} or $0,\n  # as those will point to the bats executable's location or the preprocessed file respectively\n  DIR=\"$(cd \"$(dirname \"$BATS_TEST_FILENAME\")\" &gt;/dev/null 2&gt;&1 && pwd)\"\n\n  # make executables in script/ visible to PATH\n  OLD_PATH=$PATH\n  PATH=\"$DIR/../../script:$PATH\"\n}\n\nteardown() {\n  # PATHを元に戻す\n  PATH=$OLD_PATH\n}\nすべての関数が終わったタイミングで，その実行ステータスに関わらずteardown関数は実行されます．\n\n\n各テストケース\n1: スクリプトが正常終了するか（最低限の「実行可能性」の担保）\n@test \"bazaar-zen runs successfully\" {\n  run bazaar_zen.sh\n  assert_success\n}\n\n@test 以下の\"bazaar-zen runs successfully\" がtest description\nassert_successはrunコマンドが成功したときのステータスが0かどうかを検証\n\n2: 出力が仕様通りの行数（19行）か確認し，欠落や余分な行がないことを保証\n@test \"outputs 19 lines\" {\n  run bazaar_zen.sh_\n  line_count=$(echo \"$output\" | wc -l)\n  [ \"$line_count\" -eq 19 ] || { \n      echo \"FAILED: Expected 19 lines but got $line_count\" &gt;&2\n      return 1\n  }\n}\n\nrun commandの実行結果は $output 変数に格納されます\n$outputに対して，通常のshell操作で露わに変数を作り，その変数をベースにテストを実行することができます\n\n\n\n\n\n\n\nNoterun コマンドに生成される変数\n\n\n\n\n\n\n\n\n\n\n\n\n変数名\n説明\n例・用途\n\n\n\n\n$status\n実行したコマンドの 終了ステータス（整数）\nassert_success → $status -eq 0 の確認に利用\n\n\n$output\n実行したコマンドの 標準出力＋標準エラー出力を文字列で保持\n出力全体を一括で検証するときに使用（例：assert_output \"OK\"）\n\n\n$lines\n$output を 改行ごとに分割した配列\n個別行を確認するときに使用（例：assert_equal \"${lines[0]}\" \"header\"）\n\n\n\n\n\n\n3: 先頭行の確認\n@test \"first line is correct\" {\n  run bazaar_zen.sh\n  assert_line --index 0 --partial \"1. Every good work of software starts\"\n}\n\nassert_line --index 0で$output変数の1行目について，assert検証が実行できる\n--partialは部分一致の意味\n\n4: 末尾行の確認\n@test \"last line is correct\" {\n  run bazaar_zen.sh\n  assert_line --index -1 --partial \"many heads are inevitably better than one\"\n}\n\nassert_line --index -1で$output変数の最終行目について，assert検証が実行できる\n\n5: 引数エラーの確認\n@test \"rules.sh fails with unexpected args\" {\n  run bazaar_zen.sh unexpected_arg\n  assert_failure\n  assert_output --partial \"Usage: no arguments allowed\"\n}\n\nassert_failure で$statusが0意外であるかどうかを検証\nassert_outputは$output変数全体について，assert検証"
  },
  {
    "objectID": "posts/2025-08-26-bats-core/index.html#個人用セットアップ",
    "href": "posts/2025-08-26-bats-core/index.html#個人用セットアップ",
    "title": "シェルスクリプト用のUnit Testingフレームワーク: Bats",
    "section": "個人用セットアップ",
    "text": "個人用セットアップ\nAliasの設定\n基本的にgit submodule経由で使用することを想定しているので，.zshrc に以下のようなAliasを設定します\nalias bats='$(git rev-parse --show-toplevel)/test/bats/bin/bats'"
  },
  {
    "objectID": "posts/2025-08-26-bats-core/index.html#references",
    "href": "posts/2025-08-26-bats-core/index.html#references",
    "title": "シェルスクリプト用のUnit Testingフレームワーク: Bats",
    "section": "References",
    "text": "References\n\nbats-core"
  },
  {
    "objectID": "posts/2025-01-28-mathmatical-modelling/index.html",
    "href": "posts/2025-01-28-mathmatical-modelling/index.html",
    "title": "数理モデルの作り方",
    "section": "",
    "text": "モデリングとは，現実の事象を説明するために実施するプロセスです．モデリングを通じて，これまで未知であった自然現象を解明したり，または解明を通じて将来の予測や，モデルに基づく意思決定を行ったりします．\nモデリングの流れとしては，\n\n単純化した仮定をたくさん立てる\n重要な変数が何であるのか明らかにする\n変数間の関係性について何かしらの仮定を考える\n\nこれらのステップを行いながら，現実の問題を数理モデルの問題に置き換えます．その後，適切な手法を用いて，モデルを解きます．解が出てきたならば，\n\nその解を現実の問題の文脈に翻訳し解釈\nモデルの解が現実のデータと一致しているかの妥当性検証\n\nを行いモデルを評価します．もしモデルの妥当性に疑念が認められたならば，仮定や変数の見直しなど定式化をやり直します．もしモデルが現実の事象に対して良い適合を示していたならば，意思決定目的関数に従ってモデル予測に基づく決定を行います．この一連の流れを表したのが (Figure 1) となります．\n\n\n\n\n\n\n\n\nflowchart BT\n    problem_setup[\"1: 解きたい現象の選択\"]\n    assumption[\"2: 仮説 & 仮定立案\"]\n    define_objective[\"3: 数理問題のモデル定式化\"]\n    solve[\"4: 数理問題を解く\"]\n    analysis[\"5: 解の意味を解釈する\"]\n    validation[\"6: モデル妥当性検証\"]\n    decision[\"7: モデルを用いた意思決定\"]\n    \n\n    subgraph problem-framing-phase[\"**phase 1: モデル定式化**\"]\n        direction TB\n        problem_setup --&gt; assumption\n        assumption --&gt; define_objective\n    end\n\n    subgraph analysis-phase[\"**phase 2: モデルを解く**\"]\n        direction LR\n        solve --&gt; analysis\n        analysis --&gt; validation\n    end\n\n    subgraph decision-phase[\"**phase 3: 意思決定**\"]\n        decision\n    end\n\n    analysis-phase --仮定/変数/モデル&lt;br&gt;の見直し--&gt; problem-framing-phase\n    problem-framing-phase ----&gt; analysis-phase\n    analysis-phase ----&gt; decision-phase\n\n\n\n\n\n\n\n\nFigure 1\n\n\n\n注意点として，なにを解きたいか？・知りたいか？がすでに決定されている状況からモデリングへというステップに入ります．なにを解くべきか？は意思決定問題の定式化や文脈に依存します．「解くべきもの・解く価値のあるもの」の議論を実施した上で，モデリングという過程に入ることを意識することが重要です．"
  },
  {
    "objectID": "posts/2025-01-28-mathmatical-modelling/index.html#モデリングのステップ",
    "href": "posts/2025-01-28-mathmatical-modelling/index.html#モデリングのステップ",
    "title": "数理モデルの作り方",
    "section": "",
    "text": "モデリングとは，現実の事象を説明するために実施するプロセスです．モデリングを通じて，これまで未知であった自然現象を解明したり，または解明を通じて将来の予測や，モデルに基づく意思決定を行ったりします．\nモデリングの流れとしては，\n\n単純化した仮定をたくさん立てる\n重要な変数が何であるのか明らかにする\n変数間の関係性について何かしらの仮定を考える\n\nこれらのステップを行いながら，現実の問題を数理モデルの問題に置き換えます．その後，適切な手法を用いて，モデルを解きます．解が出てきたならば，\n\nその解を現実の問題の文脈に翻訳し解釈\nモデルの解が現実のデータと一致しているかの妥当性検証\n\nを行いモデルを評価します．もしモデルの妥当性に疑念が認められたならば，仮定や変数の見直しなど定式化をやり直します．もしモデルが現実の事象に対して良い適合を示していたならば，意思決定目的関数に従ってモデル予測に基づく決定を行います．この一連の流れを表したのが (Figure 1) となります．\n\n\n\n\n\n\n\n\nflowchart BT\n    problem_setup[\"1: 解きたい現象の選択\"]\n    assumption[\"2: 仮説 & 仮定立案\"]\n    define_objective[\"3: 数理問題のモデル定式化\"]\n    solve[\"4: 数理問題を解く\"]\n    analysis[\"5: 解の意味を解釈する\"]\n    validation[\"6: モデル妥当性検証\"]\n    decision[\"7: モデルを用いた意思決定\"]\n    \n\n    subgraph problem-framing-phase[\"**phase 1: モデル定式化**\"]\n        direction TB\n        problem_setup --&gt; assumption\n        assumption --&gt; define_objective\n    end\n\n    subgraph analysis-phase[\"**phase 2: モデルを解く**\"]\n        direction LR\n        solve --&gt; analysis\n        analysis --&gt; validation\n    end\n\n    subgraph decision-phase[\"**phase 3: 意思決定**\"]\n        decision\n    end\n\n    analysis-phase --仮定/変数/モデル&lt;br&gt;の見直し--&gt; problem-framing-phase\n    problem-framing-phase ----&gt; analysis-phase\n    analysis-phase ----&gt; decision-phase\n\n\n\n\n\n\n\n\nFigure 1\n\n\n\n注意点として，なにを解きたいか？・知りたいか？がすでに決定されている状況からモデリングへというステップに入ります．なにを解くべきか？は意思決定問題の定式化や文脈に依存します．「解くべきもの・解く価値のあるもの」の議論を実施した上で，モデリングという過程に入ることを意識することが重要です．"
  },
  {
    "objectID": "posts/2025-08-17-clam-antivirus/index.html",
    "href": "posts/2025-08-17-clam-antivirus/index.html",
    "title": "clam antivirusの導入",
    "section": "",
    "text": "Linux系でも利用できるウイルス対策ソフトウェアとして ClamAV があります．ウイルス定義データベースに登録してあるパターンに従ってウイルスをスキャンしてくれます． ClamAV の利用形態は以下の２つが存在します．\n\nclamscam: ユーザーが実行可能なコマンド，adhoc用途\nclamav-daemon.service: systemctlで管理可能なclamscan daemon service, ただし常時動いている関係でメモリを多く消費する\n\n今回は，前者のインストールと設定について紹介します．\n\n\n\n\n\n\nNoteFalse Positive Risk\n\n\n\nClamAVはトロイの木馬やMirai, BASHLITEといったLinuxワームを検出してくれますが，Slack snap versionのケース のようにFalse Positive Reportを上げる可能性もあります．"
  },
  {
    "objectID": "posts/2025-08-17-clam-antivirus/index.html#clam-antivirusの導入",
    "href": "posts/2025-08-17-clam-antivirus/index.html#clam-antivirusの導入",
    "title": "clam antivirusの導入",
    "section": "",
    "text": "Linux系でも利用できるウイルス対策ソフトウェアとして ClamAV があります．ウイルス定義データベースに登録してあるパターンに従ってウイルスをスキャンしてくれます． ClamAV の利用形態は以下の２つが存在します．\n\nclamscam: ユーザーが実行可能なコマンド，adhoc用途\nclamav-daemon.service: systemctlで管理可能なclamscan daemon service, ただし常時動いている関係でメモリを多く消費する\n\n今回は，前者のインストールと設定について紹介します．\n\n\n\n\n\n\nNoteFalse Positive Risk\n\n\n\nClamAVはトロイの木馬やMirai, BASHLITEといったLinuxワームを検出してくれますが，Slack snap versionのケース のようにFalse Positive Reportを上げる可能性もあります．"
  },
  {
    "objectID": "posts/2025-08-17-clam-antivirus/index.html#clamavのインストール",
    "href": "posts/2025-08-17-clam-antivirus/index.html#clamavのインストール",
    "title": "clam antivirusの導入",
    "section": "clamavのインストール",
    "text": "clamavのインストール\n% sudo apt install clamav\n\n% clamscan --version\nClamAV 1.4.3/27737/Tue Aug 19 17:27:27 2025"
  },
  {
    "objectID": "posts/2025-08-17-clam-antivirus/index.html#clamav-freshclamの設定",
    "href": "posts/2025-08-17-clam-antivirus/index.html#clamav-freshclamの設定",
    "title": "clam antivirusの導入",
    "section": "clamav-freshclamの設定",
    "text": "clamav-freshclamの設定\nClamAVがウイルス検知に利用するウイルス定義データベースの更新方法は\n\nfreshclamコマンド\nsystemctl serviceとしてのclamav-freshclam\n\nの２つの方法があります．基本的には後者の方法で運用しますが，インストール直後に念の為手動で freshclam コマンドを実行しておきます．\n% sudo freshclam\nERROR: Failed to lock the log file /var/log/clamav/freshclam.log: Resource temporarily unavailable\nERROR: Problem with internal logger (UpdateLogFile = /var/log/clamav/freshclam.log).\nERROR: initialize: libfreshclam init failed.\nERROR: Initialization error!\nインストール直後に実行すると上記のようなエラーが発生します．clamav-freshclam.service がenabledだと sudo freshclam の手動実行ができなくなってしまうためです． なので一時的にstopして更新します．\n# service statusの確認\n% sudo systemctl status clamav-freshclam\n● clamav-freshclam.service - ClamAV virus database updater\n     Loaded: loaded (/usr/lib/systemd/system/clamav-freshclam.service; disabled; preset: enabled)\n     Active: active (running) since Wed 2025-08-20 12:05:21 JST; 44s ago\n       Docs: man:freshclam(1)\n             man:freshclam.conf(5)\n             https://docs.clamav.net/\n   Main PID: 43196 (freshclam)\n      Tasks: 1 (limit: 75871)\n     Memory: 235.9M (peak: 849.9M)\n        CPU: 7.825s\n     CGroup: /system.slice/clamav-freshclam.service\n             └─43196 /usr/bin/freshclam -d --foreground=true\n\n# serviceのstop\n% sudo systemctl stop clamav-freshclam.service\n\n# 手動更新\n% sudo freshclam\nClamAV update process started at Wed Aug 20 12:07:24 2025\nWed Aug 20 12:07:24 2025 -&gt; daily.cvd database is up-to-date (version: 27737, sigs: 2076445, f-level: 90, builder: raynman)\nWed Aug 20 12:07:24 2025 -&gt; main.cvd database is up-to-date (version: 62, sigs: 6647427, f-level: 90, builder: sigmgr)\nWed Aug 20 12:07:24 2025 -&gt; bytecode.cvd database is up-to-date (version: 336, sigs: 83, f-level: 90, builder: nrandolp)\nウイルス情報データベースのディレクトリは，デフォルトなら/var/lib/clamavになっているはずです． 次に，clamav-freshclam をenableして，restartしておきます\n# enable設定\n% sudo systemctl enable clamav-freshclam\nSynchronizing state of clamav-freshclam.service with SysV service script with /usr/lib/systemd/systemd-sysv-install.\nExecuting: /usr/lib/systemd/systemd-sysv-install enable clamav-freshclam\nCreated symlink /etc/systemd/system/multi-user.target.wants/clamav-freshclam.service → /usr/lib/systemd/system/clamav-freshclam.service.\n\n# restart設定\n% sudo systemctl restart clamav-freshclam\n\n# status確認\n% sudo systemctl status clamav-freshclam\n● clamav-freshclam.service - ClamAV virus database updater\n     Loaded: loaded (/usr/lib/systemd/system/clamav-freshclam.service; enabled; preset: enabled)\n     Active: active (running) since Wed 2025-08-20 12:07:40 JST; 2s ago\n       Docs: man:freshclam(1)\n             man:freshclam.conf(5)\n             https://docs.clamav.net/\n   Main PID: 48177 (freshclam)\n      Tasks: 1 (limit: 75871)\n     Memory: 2.4M (peak: 3.2M)\n        CPU: 6ms\n     CGroup: /system.slice/clamav-freshclam.service\n             └─48177 /usr/bin/freshclam -d --foreground=true"
  },
  {
    "objectID": "posts/2025-08-17-clam-antivirus/index.html#freshclamの設定ファイルの編集",
    "href": "posts/2025-08-17-clam-antivirus/index.html#freshclamの設定ファイルの編集",
    "title": "clam antivirusの導入",
    "section": "freshclamの設定ファイルの編集",
    "text": "freshclamの設定ファイルの編集\nfreshclamの設定ファイルは/etc/clamav/freshclam.confにあります．\n\n\n\n\n項目\n説明\n\n\n\n\nChecks\nデータベース更新頻度\n\n\nDatabaseOwner\nデータベースファイルの所有者ユーザー\n\n\nDatabaseDirectory\nデータベースディレクトリ\n\n\nUpdateLogFile\n更新のログの出力先\n\n\nLogTime\nログにタイムスタンプを付与\n\n\nNotifyClamd\nclamd デーモンに更新通知を送る\n\n\nForeground\nデーモンをフォアグラウンドで実行するか\n\n\n\n\n編集する場合は vim とかで直接編集しちゃいます．\nsudo vim /etc/clamav/freshclam.conf\n設定変更後はサービスの再起動をしときます\n% sudo systemctl restart clamav-freshclam"
  },
  {
    "objectID": "posts/2025-08-17-clam-antivirus/index.html#clamscanコマンドの使い方",
    "href": "posts/2025-08-17-clam-antivirus/index.html#clamscanコマンドの使い方",
    "title": "clam antivirusの導入",
    "section": "clamscanコマンドの使い方",
    "text": "clamscanコマンドの使い方\nデーモンを起動していないと，clamscanコマンドはシングルスレッド(--multiscanオプションが利用できない)の動作となるので， 基本的にはスキャンするターゲットをしっかり事前に決めて検査することが良いと思います．\n実行例\n% sudo clamscan -i --max-filesize=100M -r ~/Downloads\n\n----------- SCAN SUMMARY -----------\nKnown viruses: 8708210\nEngine version: 1.4.3\nScanned directories: 1\nScanned files: 20\nInfected files: 0\nData scanned: 114.28 MB\nData read: 32.92 MB (ratio 3.47:1)\nTime: 14.845 sec (0 m 14 s)\nStart Date: 2025:08:20 12:24:37\nEnd Date:   2025:08:20 12:24:52\noptions\n\n\n\n\n\n\n\n\n\nオプション\n説明\n推奨 / 補足\n\n\n\n\n-r, --recursive\nディレクトリを再帰的にスキャン\nディレクトリ全体をスキャンする場合は必須\n\n\n-i, --infected\n感染ファイルのみ表示\nレポートを簡潔にしたい場合に便利\n\n\n-l &lt;ファイル&gt;\nスキャンログを指定ファイルに出力\n例：-l /var/log/clamav/scan.log\n\n\n--bell\n感染ファイル検出時にベル音を鳴らす\nターミナルで確認しやすい\n\n\n--remove\n感染ファイルを自動削除\nFalse Positive Riskがあるので基本的には使用しない\n\n\n--max-filesize=&lt;SIZE&gt;\nスキャンする最大ファイルサイズを指定\n大きなファイルを除外して高速化\n\n\n--max-scansize=&lt;SIZE&gt;\nスキャンする最大アーカイブサイズを指定\n大規模アーカイブの処理制限\n\n\n--quiet\n通常メッセージを抑制\n感染ファイルのみ出力したい場合\n\n\n--no-summary\nスキャン終了時のサマリ表示を抑制\n自動スクリプトでの利用時に便利\n\n\n\n\n強引にマルチスレッドでスキャン\n\nホームディレクトリ直下のファイルを対象に ClamAV で並列スキャン\nlogファイルは実行時間のタイムスタンプ付きファイル\n--quietで非感染ファイルは表示しない\n-iで感染ファイルのみ表示\n\nfind ~/ -mindepth 1 -maxdepth 1 -type f \\\n  | xargs -P 8 -I {} bash -c 'sudo clamscan --quiet -i --no-summary {}' &gt;&gt; ~/Documents/clamav_log/clamscam_$(date +%Y%m%d_%H%M%S).log 2&gt;&1"
  },
  {
    "objectID": "posts/2025-08-17-clam-antivirus/index.html#references",
    "href": "posts/2025-08-17-clam-antivirus/index.html#references",
    "title": "clam antivirusの導入",
    "section": "References",
    "text": "References\n\nClamAV Documentation\nSlack snap versionのケース"
  },
  {
    "objectID": "posts/2021-05-05-ubuntu-permission/index.html",
    "href": "posts/2021-05-05-ubuntu-permission/index.html",
    "title": "Linuxにおけるパーミッション",
    "section": "",
    "text": "Definition 1 パーミッション\n\nパーミッションとは，ファイルやディクトリに対して持つユーザーやグループの権利を管理する仕組みのこと\nREAD(4), WRITE(2), EXECUTE(1) の３つの属性を指定することができる\n各ファイルやディレクトリのパーミッション内容の確認は ls -l で可能\n\n\nLinux環境では複数のユーザーで利用することが前提となっています．このようなシステム設計思想をマルチユーザーといいます． 複数のユーザーが一つのコンピューター上に存在し得る以上，どのユーザーがどのディレクトリ, ファイルに対して所有権やアクセス権を有しているのか？定義する必要があります． この「(ユーザー, ファイル)ごとのアクセス権の管理」という概念がPermissionで，Linuxでは許可されたユーザーのみがファイルにアクセスできる「アクセス制御」が実装されています．\n\nExample 1 (/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2とパーミッション) \n/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2 は実行バイナルファイル(ELF)をメモリにロードし，必要な共有ライブラリを解決してからプログラムを起動する 動的リンカプログラムです．これはOSの核となるプログラムなので，システムのとあるユーザーがうっかり削除してしまうとかはあってはならないです．つまり，\n\n/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2: 所有者以外は編集できない but 実行できるようにする\n\nというアクセス制御が必要になります．適切なパーミッション設定がマルチユーザーシステムの安全性・安定性に必要であることがわかります．\n\n\nアクセス権の種類\n\n\n\n\n\n\n\n\n\n\n種類\n意味\nファイルの場合\nディレクトリの場合\n\n\n\n\nr\nReadable(4)\nファイルの内容を読むことができる\nディレクトリの内容を一覧表示できる（ls が使える）\n\n\nw\nWritable(2)\nファイルを編集・上書きできる\nディレクトリ内のファイルやディレクトリを作成・削除できる（touch, rm, mkdir などが可能）\n\n\nx\neXecutable(1)\n実行ファイルとして実行できる\nディレクトリに移動できる・中にアクセスできる（cd やパス指定が可能）\n\n\n-\n不許可\n読み・書き・実行のいずれも不可\n一覧表示・作成削除・移動のいずれも不可\n\n\n\n\n\n\nLinuxでは，「グループ」というカテゴリでPermissionを管理することができます．このグループとは「ユーザーの集合」のことです． Linuxではユーザー作成時に，ユーザー名と同名の新しいグループが作られ，それが新規作成したユーザーに割り当てられます． ユーザー名と同じ名前のグループが設定される管理方式をユーザープライベートグループ（UPG）と呼びます.\n一つのLinuxコンピューターにユーザーが100人とかいるケースでは，１人づつリソース管理するよりもグループ単位で管理したほうが簡単なケースは多々あります．\n\nExample 2 (グループ単位での権限管理のメリット) \n会社で一つのLinuxサーバーを共有している時，\n\n管理職グループには売上帳票関連ディレクトリのアクセス権を付与\nそれ以外のユーザーにはアクセスを禁じたい\n\nというルールを実現したいとします．\nこの時，一人ひとりのユーザーにディレクトリのアクセス権を設定すると，管理職人数のオーダーで設定工数が発生します． 一方，一旦管理職グループを定義して管理職グループのみにディレクトリのアクセス権を付与するという形にすると工数のオーダーが \\(\\mathcal{O}(1)\\) になります\nsudo chgrp -R 管理職グループ &lt;directory-path&gt;\nsudo chmod 770 -R &lt;directory-path&gt;\n-R オプションは，指定したディレクトリ以下すべてのファイルの設定を一度に変更するオプションです．-R を付与しないと，ディレクトリのアクセス権を変更しても， ディレクトリ内のアクセス権は変更されません．\n\n\n\n\n\n\n\n\nNote昔のUNIXとユーザーグループ\n\n\n\n昔のUNIXではユーザー作成時のとき，各ユーザーは users という共通グループが割り当てられる仕組みでした． ユーザー数が少なく，コンピューターを共同作業の場として利用する状況では，この方式でも良いですが，\n\n共有は「明示的に」グループを作って行う\n\nという方針へ変更する場合，UPGのほうが安心してシステムを運用できます．つまり，明示的に共有設定をしない限り，他のユーザーからはアクセスできない(=ゼロトラスト運用)．"
  },
  {
    "objectID": "posts/2021-05-05-ubuntu-permission/index.html#パーミッションの管理",
    "href": "posts/2021-05-05-ubuntu-permission/index.html#パーミッションの管理",
    "title": "Linuxにおけるパーミッション",
    "section": "",
    "text": "Definition 1 パーミッション\n\nパーミッションとは，ファイルやディクトリに対して持つユーザーやグループの権利を管理する仕組みのこと\nREAD(4), WRITE(2), EXECUTE(1) の３つの属性を指定することができる\n各ファイルやディレクトリのパーミッション内容の確認は ls -l で可能\n\n\nLinux環境では複数のユーザーで利用することが前提となっています．このようなシステム設計思想をマルチユーザーといいます． 複数のユーザーが一つのコンピューター上に存在し得る以上，どのユーザーがどのディレクトリ, ファイルに対して所有権やアクセス権を有しているのか？定義する必要があります． この「(ユーザー, ファイル)ごとのアクセス権の管理」という概念がPermissionで，Linuxでは許可されたユーザーのみがファイルにアクセスできる「アクセス制御」が実装されています．\n\nExample 1 (/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2とパーミッション) \n/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2 は実行バイナルファイル(ELF)をメモリにロードし，必要な共有ライブラリを解決してからプログラムを起動する 動的リンカプログラムです．これはOSの核となるプログラムなので，システムのとあるユーザーがうっかり削除してしまうとかはあってはならないです．つまり，\n\n/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2: 所有者以外は編集できない but 実行できるようにする\n\nというアクセス制御が必要になります．適切なパーミッション設定がマルチユーザーシステムの安全性・安定性に必要であることがわかります．\n\n\nアクセス権の種類\n\n\n\n\n\n\n\n\n\n\n種類\n意味\nファイルの場合\nディレクトリの場合\n\n\n\n\nr\nReadable(4)\nファイルの内容を読むことができる\nディレクトリの内容を一覧表示できる（ls が使える）\n\n\nw\nWritable(2)\nファイルを編集・上書きできる\nディレクトリ内のファイルやディレクトリを作成・削除できる（touch, rm, mkdir などが可能）\n\n\nx\neXecutable(1)\n実行ファイルとして実行できる\nディレクトリに移動できる・中にアクセスできる（cd やパス指定が可能）\n\n\n-\n不許可\n読み・書き・実行のいずれも不可\n一覧表示・作成削除・移動のいずれも不可\n\n\n\n\n\n\nLinuxでは，「グループ」というカテゴリでPermissionを管理することができます．このグループとは「ユーザーの集合」のことです． Linuxではユーザー作成時に，ユーザー名と同名の新しいグループが作られ，それが新規作成したユーザーに割り当てられます． ユーザー名と同じ名前のグループが設定される管理方式をユーザープライベートグループ（UPG）と呼びます.\n一つのLinuxコンピューターにユーザーが100人とかいるケースでは，１人づつリソース管理するよりもグループ単位で管理したほうが簡単なケースは多々あります．\n\nExample 2 (グループ単位での権限管理のメリット) \n会社で一つのLinuxサーバーを共有している時，\n\n管理職グループには売上帳票関連ディレクトリのアクセス権を付与\nそれ以外のユーザーにはアクセスを禁じたい\n\nというルールを実現したいとします．\nこの時，一人ひとりのユーザーにディレクトリのアクセス権を設定すると，管理職人数のオーダーで設定工数が発生します． 一方，一旦管理職グループを定義して管理職グループのみにディレクトリのアクセス権を付与するという形にすると工数のオーダーが \\(\\mathcal{O}(1)\\) になります\nsudo chgrp -R 管理職グループ &lt;directory-path&gt;\nsudo chmod 770 -R &lt;directory-path&gt;\n-R オプションは，指定したディレクトリ以下すべてのファイルの設定を一度に変更するオプションです．-R を付与しないと，ディレクトリのアクセス権を変更しても， ディレクトリ内のアクセス権は変更されません．\n\n\n\n\n\n\n\n\nNote昔のUNIXとユーザーグループ\n\n\n\n昔のUNIXではユーザー作成時のとき，各ユーザーは users という共通グループが割り当てられる仕組みでした． ユーザー数が少なく，コンピューターを共同作業の場として利用する状況では，この方式でも良いですが，\n\n共有は「明示的に」グループを作って行う\n\nという方針へ変更する場合，UPGのほうが安心してシステムを運用できます．つまり，明示的に共有設定をしない限り，他のユーザーからはアクセスできない(=ゼロトラスト運用)．"
  },
  {
    "objectID": "posts/2021-05-05-ubuntu-permission/index.html#パーミッションの変更",
    "href": "posts/2021-05-05-ubuntu-permission/index.html#パーミッションの変更",
    "title": "Linuxにおけるパーミッション",
    "section": "パーミッションの変更",
    "text": "パーミッションの変更\nファイルやディレクトリを作成すると，作成したユーザーがその所有者となります．また，所有グループは，その作成したユーザーが所属するプライマリーグループが所有グループとなります．\n$ touch index.qmd\n$ ls -l ./index.qmd                                                                                                \n-rw-r--r-- 1 ryo ryo 428 Jan 13 14:38 ./index.qmd\nこのアクセス権を変更するには chmod コマンドを用います．\n\nDefinition 2 chmod\nファイルやディレクトリのパーミッションはrootと対象オブジェクトに対して所有権を持っているユーザーとrootユーザーがPermission設定・変更が可能\nchmod [option] access-mode file\n\nユーザーのカテゴリ\n\n\n\n\n対象\n説明\n\n\n\n\nu\n所有者\n\n\ng\n所有グループ\n\n\no\nその他のユーザー\n\n\na\nすべてのユーザー\n\n\n\n\n設定の種類\n\n\n\n\n対象\n説明\n\n\n\n\n+\n権限の追加\n\n\n-\n権限の削除\n\n\n=\n権限の指定\n\n\n\n\n\nExample 3 (chmod コマンドの実行例) \n# sampleファイルの所有グループとその他ユーザーに書き込み権を追加\n$ chmod uo+w sample\n\n# sampleファイルへのその他ユーザーの書き込み権を削除\n$ chmod o-w sample"
  },
  {
    "objectID": "posts/2021-05-05-ubuntu-permission/index.html#所有者と所有グループの変更",
    "href": "posts/2021-05-05-ubuntu-permission/index.html#所有者と所有グループの変更",
    "title": "Linuxにおけるパーミッション",
    "section": "所有者と所有グループの変更",
    "text": "所有者と所有グループの変更\nすべてのファ入りやディレクトリには，所有者と所有グループが設定されています．所有者と所有グループの変更するには\n\nchown: 所有者の変更\nchgrp: 所有グループの変更\n\nコマンドを用います．基本的には，変更できるのは root ユーザーのみです．\n\nDefinition 3 chown コマンド\n\n指定されたファイルやディレクトの所有者とグループを変更する\nグループも合わせて変更する場合はグループ名の前に.または : を指定する\nこのコマンドを実行できるのは root ユーザーのみ\n\nchown [option] user-name[:group-name] file-name\n\n変更前と変更後の所有者に対する権限が必要なので，所有者を変更できるのは rootユーザーのみになります． 一方，chgrp は，root 以外に変更前と変更後の両方に属しているユーザーであれば変更できます．\n\nExample 4 (ファイルの所有者とグループを一括でまとめて変更する) \n# コロンを用いる\nchown user:group file-name\n\n# ピリオドを用いる\nchown user.group file-name\n\n\n\nDefinition 4 chgrp コマンド\n\nファイルの所有グループ（グループ名）を変更するコマンド\nroot 以外に変更前と変更後の両方に属しているユーザーであれば変更できる\n\nchgrp [option] group-name file-name"
  },
  {
    "objectID": "posts/2021-05-05-ubuntu-permission/index.html#デフォルトのアクセス権の設定",
    "href": "posts/2021-05-05-ubuntu-permission/index.html#デフォルトのアクセス権の設定",
    "title": "Linuxにおけるパーミッション",
    "section": "デフォルトのアクセス権の設定",
    "text": "デフォルトのアクセス権の設定\n\nDefinition 5 umask\n\n新しいファイルやディレクトリを作成する際に，デフォルトで付与しないパーミッションを指定するもの\n「マスク」 = 「隠すもの」の意味\n新規ファイル作成時に，umaskで指定したビットがオフになる（=権限が削除される）\nopen や mkdir などのシステムコールで使用される\n\n\nファイルを作成すると\n$ touch index.qmd\n$ ls -l ./index.qmd                                                                                                \n-rw-r--r-- 1 ryo ryo 428 Jan 13 14:38 ./index.qmd\nのようにパーミッション値が定まりますが，この値は umask の値から定まります．umask の値はbashだと\n$ umask\n0022\nzshだと\n% umask\n022\nです．表示形式が3桁 or 4桁の違いはありますが本質的には同じ設定です．この値を用いてデフォルトのアクセス権は以下のように定まります\n\nデイレクトリの場合は 777 - umask value\nファイルの場合は 666 - umask value\n\n\nExample 5 (計算例1) \nデフォルトのumask値は 022（8進数）の場合：\nファイル作成時の要求: 0666 (rw-rw-rw-)\numask:             0022 (----w--w-)\n─────────────────────────────────────\n実際のパーミッション: 0644 (rw-r--r--)\n計算式: 0666 & ~0022 = 0644\n\n\n\nExample 6 (計算例2) \nファイル作成時に\nrw-------\nがデフォルトとなるようなumaskの設定値の例は\n# pattern 1\numask 0067\n\n# pattern 2\numask 0066\nとなります．他にも 0166 とかもありえます．\n\n\n\n\n\n\n\n\nNoteumaskの設定はどこで行うべきか？\n\n\n\numaskの値の変更を行いたいときは，どのログインシェルを用いるかによって変わりますが，基本的には\n\n\n\n設定場所\nGUI\nSSH\n\n\n\n\n~/.zprofile\n❌\n✅\n\n\n~/.profile\n❌\n✅\n\n\n\nとなります．CLI操作が基本の場合はbash, zshそれぞれに対応した設定ファイルを変更すればよいですが，GUIの場合は少し厄介です． なおumaskの値は，親プロセスから子プロセスに引き継がれます．"
  },
  {
    "objectID": "posts/2021-05-05-ubuntu-permission/index.html#特殊なパーミッション",
    "href": "posts/2021-05-05-ubuntu-permission/index.html#特殊なパーミッション",
    "title": "Linuxにおけるパーミッション",
    "section": "特殊なパーミッション",
    "text": "特殊なパーミッション\n特殊なパーミッションとして\n\nSUID(Set User ID)\nSGID(Set Group ID)\nスティッキービット\n\nがあります．\n\nSUID\n\nDefinition 6 SUID\n\n一時的にファイルの実行権限を別のUIDのユーザに変更できる機能のこと\nSUIDが付与されたファイルは実行時にそのファイルの所有者の権限で実行される\nLinuxのファイルシステム上では，ディレクトリに対して設定しても効果はない(see SUID has no effect on directories with Linux)\n\n\nプロセスには実ユーザーID(real user ID)と実効ユーザーID(effective user ID)が設定されています．\n\n実ユーザーID(real user ID): プロセスを起動したユーザー(=プロセスの所有者)\n実効ユーザーID(effective user ID): プロセスが実行されるときの権限を持つユーザー\n\nSUIDを設定することで，実ユーザーが一般ユーザーでも実効ユーザーIDがroot権限を持つなどの設定が可能になります．\nSUIDの活用例\n「セキュリティ的に一般ユーザーの書き込み権限などは絞っておきたいが，利便性を考えると root ユーザーでなくても更新させたい」というファイルがあるとき， SUID をうまく使うことで用途を限定した上で，セキュアなファイルの実効を一般ユーザーにも許可できるというメリットがあります．\nSUIDの使用例として，passwdコマンドがあります．Linuxではパスワードのデータを/etc/shadowで管理しています．\n$ ls -l /etc/shadow \n-rw-r----- 1 root shadow 9812 Jul 15 19:03 /etc/shadow\nPermissionを確認すると，root以外は読み取れない(= 暗号化パスワード解読を防ぐため)設定になっています．パスワードを変更するときは passwd を用いますが， 一般ユーザーでも自分自身のパスワードは sudo なしで実行できます．ではどうやって /etc/shadow に書き込んでいるかというとSUIDが設定されているからが答えになります．\n$ ls -l  $(which passwd)\n-rwsr-xr-x 1 root root 64152 May 30  2024 /usr/bin/passwd*\nSUIDが設定されているファイル（プログラム）においては所有者の実行権限が s と表記されます． そのため，passwd コマンドは一般ユーザが実行した場合においても，passwd コマンドの所有者である root 権限で実行できます．\nSUIDの設定方法\nSUIDを設定する場合は，chmod コマンドを用いて\n\nオクタルモード: 4000 を加算\nシンボリックモード: u+s を付与\n\n## オクタルモードで755に加えて設定したい場合\n$ sudo chmod 4755 test.sh\n\n## シンボリックモード\n$ sudo chmod u+s test.sh\n\n\nSGID\n\nDefinition 7 SGID\n\nファイルのグループIDが実効グループIDとして設定される仕組みのこと\nGIDではグループの実行権限が s となる\nディレクトリに対してSGIDが設定された場合，そのディレクトリ以下において作成したファイルやサブディレクトリの所有グループには，自動的にディレクトリ自体の所有グループが適用される\n新規作成の場合も，自動的にSGIDのグループが所有グループとなる\n\n\nSGIDが設定されているディレクトリ例は以下があります\n$ find /usr/bin/ -perm -g+s\n/usr/bin/chage\n/usr/bin/expiry\n/usr/bin/crontab\n/usr/bin/ssh-agent\nSGIDの設定方法\nSGIDを設定する場合は，chmod コマンドを用いて\n\nオクタルモード: 2000 を加算\nシンボリックモード: g+s を付与\n\n## オクタルモードで755に加えて設定したい場合\n$ sudo chmod 2755 test.sh\n\n## シンボリックモード\n$ sudo chmod g+s test.sh\n\n\nスティッキービット\n\nDefinition 8 スティッキービット\n\nスティッキービットが設定されたディレクトリ以下のファイルとディレクトリは，実際に設定したアクセス権に関係なく，ファイルのファイル名変更や削除は所有者とrootユーザしかできなくなる\nPermissionではその他グループの実行権限が t と表示される\n\n\n/tmp では多くのユーザーが作業できるようにアクセス権がすべて許可されていますが，あるユーザーが作成したファイルを他のユーザーが消してしまうことを防ぐためにスティッキービットが設定されています．\n$ ls -ld /tmp\ndrwxrwxrwt 32 root root 4096 Aug 16 12:46 /tmp/\nスティッキービットの設定方法\nスティッキービットを設定する場合は，chmod コマンドを用いて\n\nオクタルモード: 1000 を加算\nシンボリックモード: o+t を付与\n\n## オクタルモードで755に加えて設定したい場合\n$ sudo chmod 1755 test.sh\n\n## シンボリックモード\n$ sudo chmod o+t test.sh"
  },
  {
    "objectID": "posts/2021-05-05-ubuntu-permission/index.html#appendix-ls--l-コマンド",
    "href": "posts/2021-05-05-ubuntu-permission/index.html#appendix-ls--l-コマンド",
    "title": "Linuxにおけるパーミッション",
    "section": "Appendix: ls -l コマンド",
    "text": "Appendix: ls -l コマンド\n「カーネルが提供する仮想デバイス」の一つである /dev/null を確認してみます\n% ls -l /dev/null\ncrw-rw-rw- 1 root root 1, 3 Jan 13 10:24 /dev/null\nls -l の表示\ncrw-rw-rw-  1  root  root  1, 3  Jan 10 12:00  /dev/null\n│           │   │     │     │      │            │\n│           │   │     │     │      │            └─ ファイル名\n│           │   │     │     │      └─ 更新日時\n│           │   │     │     └─ サイズ または (major,minor)\n│           │   │     └─ グループ\n│           │   └─ 所有者\n│           └─ ハードリンク数\n└─ ファイル種別 + パーミッション\nファイルの種類\n\n\n\n\n文字\n意味\n\n\n\n\n-\n普通のファイル\n\n\nd\nディレクトリ\n\n\nl\nシンボリックリンク\n\n\nc\nキャラクタデバイス\n\n\nb\nブロックデバイス\n\n\ns\nUNIXソケット\n\n\np\n名前付きパイプ"
  },
  {
    "objectID": "posts/2021-05-05-ubuntu-permission/index.html#references",
    "href": "posts/2021-05-05-ubuntu-permission/index.html#references",
    "title": "Linuxにおけるパーミッション",
    "section": "References",
    "text": "References\n\nRyo’s Tech Blog &gt; 権限管理入門"
  },
  {
    "objectID": "posts/2025-02-20-sort-pivot-table/index.html",
    "href": "posts/2025-02-20-sort-pivot-table/index.html",
    "title": "pivot tableのcolumn, rowのsort",
    "section": "",
    "text": "Exercise 1 \n\n\nCode\nimport numpy as np\nimport pandas as pd\n\nnp.random.seed(42)\n\ndef random_choice_from_list(\n    candidate: list | np.ndarray,\n    sampling_size: int,\n    p: list | tuple | np.ndarray = None,\n):\n    if sampling_size &lt;= 0:\n        raise ValueError(\"sampling_size must be greater than 0.\")\n\n    if p is None:\n        p = np.repeat(1 / len(candidate), sampling_size)\n\n    if min(p) &lt; 0 or max(p) &gt; 1:\n        raise ValueError(\"All probabilities in 'p' must be between 0 and 1 inclusive.\")\n\n    if not np.isclose(sum(p), 1):\n        raise ValueError(\"The probabilities in 'p' must sum to 1.\")\n\n    return np.random.choice(candidate, size=sampling_size, p=p)\n\n\n# Params\nN = 100\nA_list = [\"H\", \"He\", \"Li\", \"Be\", \"B\", \"C\", \"N\", \"O\", \"F\", \"Ne\"]\nA_prob = np.array([1, 4, 3, 4, 1, 6, 7, 8, 9, 10])\nA_prob = A_prob / sum(A_prob)\n\nB_list = [\"one\", \"two\", \"three\", \"four\"]\nB_prob = np.array([7, 8, 6, 1])\nB_prob = B_prob / sum(B_prob)\n\n\n# DGP\ndf = pd.DataFrame(\n    {\n        \"element\": random_choice_from_list(A_list, N, A_prob),\n        \"class\": random_choice_from_list(B_list, N, B_prob),\n        \"density\": np.random.uniform(0, 1, N),\n    }\n)\n\ndf.head()\n\n\n\n\n\n\n\n\n\nelement\nclass\ndensity\n\n\n\n\n0\nN\none\n0.642032\n\n\n1\nNe\ntwo\n0.084140\n\n\n2\nF\none\n0.161629\n\n\n3\nO\ntwo\n0.898554\n\n\n4\nBe\nthree\n0.606429\n\n\n\n\n\n\n\n ▶  問題設定\n\n上記のデータについて (element, class) をkey，frequencyをvalueとした二次元分割表を作成する\n二次元分割表をcolumn, rowそれぞれの方向について，合計frequencyに基づいたsortを行う"
  },
  {
    "objectID": "posts/2025-02-20-sort-pivot-table/index.html#問題設定",
    "href": "posts/2025-02-20-sort-pivot-table/index.html#問題設定",
    "title": "pivot tableのcolumn, rowのsort",
    "section": "",
    "text": "Exercise 1 \n\n\nCode\nimport numpy as np\nimport pandas as pd\n\nnp.random.seed(42)\n\ndef random_choice_from_list(\n    candidate: list | np.ndarray,\n    sampling_size: int,\n    p: list | tuple | np.ndarray = None,\n):\n    if sampling_size &lt;= 0:\n        raise ValueError(\"sampling_size must be greater than 0.\")\n\n    if p is None:\n        p = np.repeat(1 / len(candidate), sampling_size)\n\n    if min(p) &lt; 0 or max(p) &gt; 1:\n        raise ValueError(\"All probabilities in 'p' must be between 0 and 1 inclusive.\")\n\n    if not np.isclose(sum(p), 1):\n        raise ValueError(\"The probabilities in 'p' must sum to 1.\")\n\n    return np.random.choice(candidate, size=sampling_size, p=p)\n\n\n# Params\nN = 100\nA_list = [\"H\", \"He\", \"Li\", \"Be\", \"B\", \"C\", \"N\", \"O\", \"F\", \"Ne\"]\nA_prob = np.array([1, 4, 3, 4, 1, 6, 7, 8, 9, 10])\nA_prob = A_prob / sum(A_prob)\n\nB_list = [\"one\", \"two\", \"three\", \"four\"]\nB_prob = np.array([7, 8, 6, 1])\nB_prob = B_prob / sum(B_prob)\n\n\n# DGP\ndf = pd.DataFrame(\n    {\n        \"element\": random_choice_from_list(A_list, N, A_prob),\n        \"class\": random_choice_from_list(B_list, N, B_prob),\n        \"density\": np.random.uniform(0, 1, N),\n    }\n)\n\ndf.head()\n\n\n\n\n\n\n\n\n\nelement\nclass\ndensity\n\n\n\n\n0\nN\none\n0.642032\n\n\n1\nNe\ntwo\n0.084140\n\n\n2\nF\none\n0.161629\n\n\n3\nO\ntwo\n0.898554\n\n\n4\nBe\nthree\n0.606429\n\n\n\n\n\n\n\n ▶  問題設定\n\n上記のデータについて (element, class) をkey，frequencyをvalueとした二次元分割表を作成する\n二次元分割表をcolumn, rowそれぞれの方向について，合計frequencyに基づいたsortを行う"
  },
  {
    "objectID": "posts/2025-02-20-sort-pivot-table/index.html#solution-with-pandas",
    "href": "posts/2025-02-20-sort-pivot-table/index.html#solution-with-pandas",
    "title": "pivot tableのcolumn, rowのsort",
    "section": "Solution with pandas",
    "text": "Solution with pandas\n\n\n\n\n\n\n\nNoteTask 1: (element, class) をkey，frequencyをvalueとした二次元分割表を作成する\n\n\n\n\n\npandas.pivot_tableを用いればかんたんに実行できます．\n\n\nCode\n# Compute the pivot table\npivot_table = pd.pivot_table(\n    df,\n    index=\"element\",  # Rows\n    columns=\"class\",  # Columns\n    aggfunc=\"size\",  # Frequency count\n    fill_value=0,  # Fill missing values with 0\n)\n\npivot_table\n\n\n\n\n\n\n\n\nclass\nfour\none\nthree\ntwo\n\n\nelement\n\n\n\n\n\n\n\n\nBe\n0\n4\n5\n1\n\n\nC\n0\n4\n4\n6\n\n\nF\n0\n6\n4\n6\n\n\nH\n0\n0\n0\n1\n\n\nHe\n0\n4\n2\n5\n\n\nLi\n1\n2\n3\n1\n\n\nN\n1\n4\n2\n1\n\n\nNe\n0\n5\n4\n7\n\n\nO\n1\n6\n4\n6\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNoteTask 2: 二次元分割表をcolumn, rowそれぞれの方向について，合計frequencyに基づいたsortを行う\n\n\n\n\n\npivot table化された pandas.DataFrame に対するソート操作は\n\nrow操作 ; .loc のindexの操作\ncolumn操作: .loc のcolumnの操作\n\nとなります．\n ▶  rowのsort\n\n\nCode\npivot_table = pivot_table.loc[\n    pivot_table.sum(axis=1).sort_values(ascending=False).index\n]\npivot_table\n\n\n\n\n\n\n\n\nclass\nfour\none\nthree\ntwo\n\n\nelement\n\n\n\n\n\n\n\n\nO\n1\n6\n4\n6\n\n\nNe\n0\n5\n4\n7\n\n\nF\n0\n6\n4\n6\n\n\nC\n0\n4\n4\n6\n\n\nHe\n0\n4\n2\n5\n\n\nBe\n0\n4\n5\n1\n\n\nN\n1\n4\n2\n1\n\n\nLi\n1\n2\n3\n1\n\n\nH\n0\n0\n0\n1\n\n\n\n\n\n\n\n ▶  columnのsort\n\n\nCode\npivot_table = pivot_table.loc[:, pivot_table.sum(axis=0).sort_values(ascending=False).index]\npivot_table\n\n\n\n\n\n\n\n\nclass\none\ntwo\nthree\nfour\n\n\nelement\n\n\n\n\n\n\n\n\nO\n6\n6\n4\n1\n\n\nNe\n5\n7\n4\n0\n\n\nF\n6\n6\n4\n0\n\n\nC\n4\n6\n4\n0\n\n\nHe\n4\n5\n2\n0\n\n\nBe\n4\n1\n5\n0\n\n\nN\n4\n1\n2\n1\n\n\nLi\n2\n1\n3\n1\n\n\nH\n0\n1\n0\n0\n\n\n\n\n\n\n\n ▶  検証\n\n\nCode\npivot_table_total = pivot_table.copy()\n\n# row sum\npivot_table_total['total'] = pivot_table_total.sum(axis=1)\n\n# column sum\npivot_table_total.loc['column_sum'] =  pivot_table_total.sum(axis=0)\n\n# 検証\npivot_table_total\n\n\n\n\n\n\n\n\nclass\none\ntwo\nthree\nfour\ntotal\n\n\nelement\n\n\n\n\n\n\n\n\n\nO\n6\n6\n4\n1\n17\n\n\nNe\n5\n7\n4\n0\n16\n\n\nF\n6\n6\n4\n0\n16\n\n\nC\n4\n6\n4\n0\n14\n\n\nHe\n4\n5\n2\n0\n11\n\n\nBe\n4\n1\n5\n0\n10\n\n\nN\n4\n1\n2\n1\n8\n\n\nLi\n2\n1\n3\n1\n7\n\n\nH\n0\n1\n0\n0\n1\n\n\ncolumn_sum\n35\n34\n28\n3\n100"
  },
  {
    "objectID": "posts/2025-02-20-sort-pivot-table/index.html#visualization",
    "href": "posts/2025-02-20-sort-pivot-table/index.html#visualization",
    "title": "pivot tableのcolumn, rowのsort",
    "section": "Visualization",
    "text": "Visualization\n\n可視化方針 \n\nclass出現割合はelement毎に大きく異なるのかみたい\nfrequencyそのままで比較すると出現割合比較にならないので，axis = 1の方向で割合として計算する(以後，normalized_pivotと呼ぶ)\nnormalized_pivotをheatmapで可視化する，可視化の際に出現頻度を右側に参照できるようにする(sample sizeが小さいところは無視したい)\n\n\n ▶  normalized_pivot の作成\n\n\nCode\nnormalized_pivot = pivot_table.div(pivot_table.sum(axis=1), axis=0)\nnormalized_pivot\n\n\n\n\n\n\n\n\nclass\none\ntwo\nthree\nfour\n\n\nelement\n\n\n\n\n\n\n\n\nO\n0.352941\n0.352941\n0.235294\n0.058824\n\n\nNe\n0.312500\n0.437500\n0.250000\n0.000000\n\n\nF\n0.375000\n0.375000\n0.250000\n0.000000\n\n\nC\n0.285714\n0.428571\n0.285714\n0.000000\n\n\nHe\n0.363636\n0.454545\n0.181818\n0.000000\n\n\nBe\n0.400000\n0.100000\n0.500000\n0.000000\n\n\nN\n0.500000\n0.125000\n0.250000\n0.125000\n\n\nLi\n0.285714\n0.142857\n0.428571\n0.142857\n\n\nH\n0.000000\n1.000000\n0.000000\n0.000000\n\n\n\n\n\n\n\n ▶  可視化コード\n\n\nCode\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n\n# Plot heatmap\nfig, ax = plt.subplots(1, 2, figsize=(10, 6), gridspec_kw={\"width_ratios\": [3, 1]})\n\nsns.heatmap(normalized_pivot, annot=True, fmt=\".2f\", cmap=\"PuBu\", ax=ax[0])\nax[0].set_title(\"Heatmap of Normalized Pivot Table\")\nax[0].set_ylabel(\"Element\")\nax[0].set_xlabel(\"Class\")\n\nsns.barplot(\n    y=pivot_table.index,\n    x=pivot_table.sum(axis=1),\n    alpha=0.8,\n    color=\"#0047AB\",\n    orient=\"h\",\n    ax=ax[1],\n)\nax[1].set_title(\"Element Frequency Barplot\")\nax[1].set_xlabel(\"Frequency\")\n\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTip🍵 color mapのカスタマイズ\n\n\n\ncolor sequenceをlightcoral, ivory, Dodgersblue という順番にしたい場合は\n\n\nCode\nfrom matplotlib.colors import LinearSegmentedColormap\n\ncustom_cpam = LinearSegmentedColormap.from_list(\"lightcoral_ivory_blue\", [\"#F08080\", \"#FFFFF0\", \"#1E90FF\"])\n\n\nとすることで自分好みにカスタマイズすることができます．\n\n\nCode\n# Plot heatmap\nfig, ax = plt.subplots(1, 2, figsize=(10, 6), gridspec_kw={\"width_ratios\": [3, 1]})\n\nsns.heatmap(normalized_pivot, annot=True, fmt=\".2f\", cmap=custom_cpam , ax=ax[0])\nax[0].set_title(\"Heatmap of Normalized Pivot Table\")\nax[0].set_ylabel(\"Element\")\nax[0].set_xlabel(\"Class\")\n\nsns.barplot(\n    y=pivot_table.index,\n    x=pivot_table.sum(axis=1),\n    alpha=1,\n    color=\"#6699CC\",\n    orient=\"h\",\n    ax=ax[1],\n)\nax[1].set_title(\"Element Frequency Barplot\")\nax[1].set_xlabel(\"Frequency\")\n\nplt.tight_layout()\nplt.show()"
  },
  {
    "objectID": "posts/2025-01-29-set-and-topology-series/index.html",
    "href": "posts/2025-01-29-set-and-topology-series/index.html",
    "title": "フーリエ級数と積分理論再考",
    "section": "",
    "text": "フーリエが熱伝導方程式の解をどのように求めたのか？\nどのような流れで積分の定義の再考につながったのか？\n\nを紹介します．"
  },
  {
    "objectID": "posts/2025-01-29-set-and-topology-series/index.html#このノートのスコープ",
    "href": "posts/2025-01-29-set-and-topology-series/index.html#このノートのスコープ",
    "title": "フーリエ級数と積分理論再考",
    "section": "",
    "text": "フーリエが熱伝導方程式の解をどのように求めたのか？\nどのような流れで積分の定義の再考につながったのか？\n\nを紹介します．"
  },
  {
    "objectID": "posts/2025-01-29-set-and-topology-series/index.html#熱伝導方程式",
    "href": "posts/2025-01-29-set-and-topology-series/index.html#熱伝導方程式",
    "title": "フーリエ級数と積分理論再考",
    "section": "熱伝導方程式",
    "text": "熱伝導方程式\n物体内に温度勾配が存在すると，高温部から低温部へ熱伝導（Heat conduction）により熱エネルギーが伝わります．\n\n\n\n\n\n\nFigure 1: 長さ\\(\\pi\\)の密度が一様な棒\n\n\n\nFigure 1 のような細長い密度が一定の棒が与えられたとします．\n\n左端を 0 として，ある点の位置を左端からの距離 \\(x\\) で表す\nある点 \\(x\\) における時刻 \\(t\\) での温度を \\(T(x, t)\\) で表す\n単位断面積を単位時間に通過する熱エネルギーを \\(q(x, t)\\) とする(=熱流密度)\n\nフーリエの法則より，熱流密度 \\(q(x, t)\\) は温度勾配 \\(\\displaystyle{\\frac{\\partial T(x, t)}{\\partial x}}\\) に比例するので\n\\[\nq(x, t) = -\\lambda \\frac{\\partial T(x, t)}{\\partial x} \\label{eq-fourier-law}\n\\]\n\n\\(\\lambda  &gt; 0\\): 熱伝導率，RHSに符号マイナスがついているのは，高温から低音へ熱が流れることを表してる\n熱伝導率: 物質によって定まる物性値, 熱伝導率が大きいと熱エネルギーがよく伝わり，熱伝導率が小さいと熱エネルギーを伝えにくい\n\n\\(\\eqref{eq-fourier-law}\\) で表される熱の流入から，比熱 \\(c &gt; 0\\), 密度 \\(\\rho  &gt; 0\\) を用いると温度変化 \\(\\Delta T(x, t)\\) は熱の流入と流出２要素から以下のように表されます\n\\[\n\\begin{align}\n\\Delta T(x, t) &= \\frac{1}{c\\rho\\Delta x}(q(x, t) - q(x + \\Delta x, t))\\Delta t\\\\\n\\Rightarrow \\frac{\\Delta T(x, t)}{\\Delta t} &= \\frac{1}{c\\rho\\Delta x}(q(x, t) - q(x + \\Delta x, t))\n\\end{align}\n\\]\nここで，\\(\\Delta t\\to 0, \\Delta x\\to 0\\) とすると\n\\[\n\\frac{\\partial T(x, t)}{\\partial t} = -\\frac{1}{c\\rho}\\frac{\\partial q(x, t)}{\\partial x} \\label{eq-heat-balance}\n\\]\n\\(\\eqref{eq-fourier-law}\\), \\(\\eqref{eq-heat-balance}\\) より\n\\[\n\\begin{align}\n\\frac{\\partial T(x, t)}{\\partial t}\n    &= -\\frac{1}{c\\rho}\\frac{\\partial}{\\partial x}\\left(-\\lambda \\frac{\\partial T(x, t)}{\\partial x} \\right)\\\\\n    &= \\frac{\\lambda}{c\\rho}\\frac{\\partial^2 T(x, t)}{\\partial x^2} \\label{eq-hce}\n\\end{align}\n\\tag{1}\\]\nこれを熱伝導方程式と呼びます．\\(\\displaystyle\\frac{\\lambda}{c\\rho}\\) は温度伝導率（温度拡散率）と呼ばれます．\n\n\n\n\n\n\nTip🍵 Green Tea Break: 比熱\n\n\n\n\n比熱とは 1kg の物質の温度を 1K （＝1℃）上げるのに必要な熱量のこと\n「温まりやすさ」 「冷めにくさ」 を表す物理量と理解できる\n\n例えば，水1kgの場合，1K 上げるのに必要な熱量は4186J"
  },
  {
    "objectID": "posts/2025-01-29-set-and-topology-series/index.html#熱伝導方程式とフーリエ級数",
    "href": "posts/2025-01-29-set-and-topology-series/index.html#熱伝導方程式とフーリエ級数",
    "title": "フーリエ級数と積分理論再考",
    "section": "熱伝導方程式とフーリエ級数",
    "text": "熱伝導方程式とフーリエ級数\n\n方程式: 熱伝導方程式\n境界条件: 棒の両端の温度を 0 に保つ\n初期条件: 初期状態(\\(t=0\\))における位置 \\(x\\) の温度が \\(f(x)\\) で与えられている\n\nという設定の下，温度 \\(T\\) の時間変化を求める問題を考えます．\n ▶  境界条件\n\\[\nT(0, t) = T(\\pi, t) = 0 \\qquad (t\\geq 0) \\label{eq-boundary}\n\\]\n ▶  初期条件\n\\[\nT(x, 0) = f(x) \\qquad (0 \\leq x \\leq \\pi) \\label{eq-init}\n\\]\n\n ▶  重ね合わせの原理\n熱伝導方程式は次のような性質があります\n\n\\(T_1, T_2\\) が \\(\\eqref{eq-hce}\\), \\(\\eqref{eq-boundary}\\) を満たすとき，\\(T_1 + T_2\\) も\\(\\eqref{eq-hce}\\), \\(\\eqref{eq-boundary}\\) を満たす\n\\(T\\) が \\(\\eqref{eq-hce}\\), \\(\\eqref{eq-boundary}\\) を満たすとき，その任意の定数倍 \\(kT\\) も\\(\\eqref{eq-hce}\\), \\(\\eqref{eq-boundary}\\) を満たす\n\nこれを重ね合わせの原理と呼びます．\n\n温度 \\(T\\) の時間変化を求める問題を解くにあたって，フーリエは重ね合わせの原理を活用して\n\n\\(\\eqref{eq-hce}\\), \\(\\eqref{eq-boundary}\\) を満たす関数の条件のうち，なるべく簡単な形のものを求める\n得られた簡単な形の関数を足し合わせることで，初期条件 \\(\\eqref{eq-init}\\) を満たす関数を作る\n\nという二段構えで解くことを考えました．簡単な形の関数としてフーリエが考えたのは変数分離型の関数です．\n\n変数分離\n変数分離型関数とは，位置 \\(x\\) 飲みの関数 \\(v(x)\\) と時刻 \\(t\\) のみの関数 \\(w(t)\\) の積\n\\[\nT(x, t) = v(x)w(t)\n\\]\nの形で表させる関数のことです．変数分離型を仮定すると熱伝導方程式は常微分方程式を用いて以下のように表せます\n\\[\n\\begin{align}\n\\frac{c\\rho}{\\lambda}\\frac{w^\\prime(t)}{w(t)} = \\frac{v^{\\prime\\prime}(x)}{v(x)}\n\\end{align}\n\\]\nLHSは\\(t\\)のみの関数，RHSは\\(x\\)飲みの関数であるので，方程式が恒等的に成り立つためには，両辺は定数でなければなりません．定数を \\(k\\) と表すと\n\\[\n\\begin{align}\nw^\\prime(t) &= k Aw(t)\\\\\nv^{\\prime\\prime}(t) &= k v(x)\n\\end{align}\n\\]\nなお \\(A = \\displaystyle\\frac{\\lambda}{c\\rho}\\) としています．\n ▶  \\(w(t)\\) について解く\n\\[\n\\begin{align}\n\\frac{dw(t)}{w(t)} &= k A dt\\\\\n\\int \\frac{dw(t)}{w(t)}dt &= \\int k A dt \\label{eq-cond}\\\\\n\\log(\\vert w(t)\\vert) &= k A t + C \\qquad (C\\text{: constant})\\\\\nw(t) &= \\alpha \\exp(k At)\\qquad (\\alpha = \\exp(C))\n\\end{align}\n\\]\n従って，\n\\[\n\\begin{align}\nw(t) = \\left\\{\\begin{array}{c}\n\\alpha\\exp(kAt) & (k \\neq 0)\\\\\n\\alpha & (k = 0)\n\\end{array}\\right.\n\\end{align}\n\\]\n ▶  \\(v(x)\\) について解く\n2次線形微分方程式において，\\(p, q\\) が定数のとき\n\\[\ny^{\\prime\\prime} + py^{\\prime} + q = 0\n\\]\nの一般解は特定方程式 \\(a^2 + pa + q =0\\) の解によって以下のように定まります\ncase 1: ２つの実数解 \\(\\hat a_1, \\hat a_2\\) を持つ場合\n\\[\ny = A\\exp(\\hat a_1 x) + B\\exp(\\hat a_2 x)\n\\]\ncase 2: ２つの虚数解 \\(\\hat a \\pm \\hat b i\\) を持つ場合\n\\[\ny = \\exp(\\hat a x)(A\\cos(\\hat b x) + B \\sin(\\hat b x))\n\\]\ncase 3: 重解 \\(\\hat a\\) を持つ場合\n\\[\ny = (Ax + B)\\exp(\\hat a x)\n\\]\n以上より，\n\\[\n\\begin{align}\nv(x) = \\left\\{\\begin{array}{c}\n\\beta \\exp(\\sqrt{k}x) + \\gamma \\exp(-\\sqrt{k}x) & \\text{if } k &gt; 0\\\\\n\\beta x + \\gamma & \\text{if } k = 0 \\\\\n\\beta\\cos(\\sqrt{\\vert k\\vert}x) + \\gamma\\sin(\\sqrt{\\vert k\\vert}x) & \\text{if } k &lt;0\n\\end{array}\\right.\n\\end{align}\n\\]\n境界条件および初期条件を満たすように係数 \\(\\alpha, \\beta, \\gamma\\) を定めれば，解が求まることになります．\n\n\nフーリエ級数の登場\n ▶  \\(k &gt; 0\\) のケース\n\\(\\eqref{eq-cond}\\) より，時間の経過とともに温度が無限大に大きくなることはないので \\(k&gt; 0\\) はありえないことが直感的に分かりますが，\\(k&gt; 0\\) と仮定したとき 境界条件を満たす \\(\\alpha, \\beta, \\gamma\\) が存在しないことを確認します．\n\\[\n\\begin{align}\nw(t) &= \\alpha\\exp(kAt) \\\\\nv(x) &= \\beta \\exp(\\sqrt{k}x) + \\gamma \\exp(-\\sqrt{k}x)\n\\end{align}\n\\]\n境界条件より\n\\[\n\\begin{align}\nv(0) &= \\beta + \\gamma = 0\\\\\nv(\\pi) &= \\beta\\exp(\\sqrt{k}\\pi) + \\gamma\\exp(-\\sqrt{k}\\pi) = 0\n\\end{align}\n\\]\nここから\n\\[\n\\beta(\\exp(\\sqrt{k}\\pi) - \\exp(-\\sqrt{k}\\pi)) = 0\n\\]\n従って，\n\\[\n\\begin{align}\n&\\beta = \\gamma = 0\\\\\n\\Rightarrow& v(x) =  0\n\\end{align}\n\\]\nこれは \\(f(x) = 0 \\ \\ \\forall x \\in [0, \\pi]\\) 以外の場合は初期条件を満たすことがない．\n ▶  \\(k = 0\\) のケース\n\\[\n\\begin{align}\nw(t) &= \\alpha\\\\\nv(x) &= \\beta x + \\gamma\n\\end{align}\n\\]\n境界条件を満たすためには \\(\\beta = \\gamma = 0\\) が必要になるが，\\(f(x) = 0 \\ \\ \\forall x \\in [0, \\pi]\\) 以外の場合は初期条件を満たすことがない．\n ▶  \\(k &lt; 0\\) のケース\n\\[\n\\begin{align}\nw(t) &= \\alpha\\exp(kAt) \\\\\nv(x) &= \\beta\\cos(\\sqrt{\\vert k\\vert}x) + \\gamma\\sin(\\sqrt{\\vert k\\vert}x)\n\\end{align}\n\\]\n境界条件より\n\\[\n\\begin{align}\n\\beta &= 0\\\\\n\\gamma\\sin(\\sqrt{\\vert k\\vert}\\pi) &= 0\n\\end{align}\n\\]\n\\(\\gamma= 0\\) だと初期条件を満たすことができないので，\\(\\gamma \\neq 0\\). このとき，\\(\\sqrt{\\vert k\\vert} \\in \\mathbb Z\\) が解の必要条件となることが分かる． ここで，\\(k = -n^2\\) と書き直すと\n\\[\n\\begin{align}\nT(x, t) = \\alpha\\exp(-n^2At) \\cdot \\gamma\\sin(n\\pi) \\label{eq-sol-candidate}\n\\end{align}\n\\]\nが境界条件を満たす変数分離型の解となるとこが分かります．重ね合わせの原理より \\(\\eqref{eq-sol-candidate}\\) の定数倍も境界条件と熱伝導方程式を満たす関数となります．\n重ね合わせの原理より \\(1 \\leq n \\leq N\\) の範囲で\n\\[\n\\sum_{n=1}^N a_n \\alpha\\exp(-n^2At) \\cdot \\gamma\\sin(n\\pi)\n\\]\nも境界条件と熱伝導方程式を満たす関数となります．ここでフーリエは次のような主張をしました：\n\n\\[\n\\sum_{n=1}^\\infty a_n \\alpha\\exp(-n^2At) \\cdot \\gamma\\sin(n\\pi)\n\\]\nも境界条件と熱伝導方程式を満たす関数となりえる\n\nここから初期条件を満たす関数を求めたいので, \\(t=0\\) とすると\n\\[\nf(x) = \\sum_{n=1}^\\infty b_n \\sin(n\\pi)\n\\]\nが成り立つように \\(\\{b_n\\}_{n=1}^\\infty\\) を定めれば良いとなります．このとき，正弦関数の積の積分公式\n\\[\n\\begin{align}\n\\int^{\\pi}_0\\sin nx \\sin mx dx =\\begin{cases}\n\\displaystyle 0 & (m\\neq n)\\\\[4pt]\n\\displaystyle \\frac{\\pi}{2} & (m = n)\n\\end{cases}\n\\end{align}\n\\]\n従って，\n\\[\n\\begin{align}\n\\int^{\\pi}_0f(x)\\sin mx\\ dx\n& = \\int^\\pi_0 \\sum_{n=1}^\\infty b_n \\sin(n\\pi) \\sin(m\\pi) dx\\\\\n&= \\sum_{n=1}^\\infty \\int^\\pi_0b_n \\sin(n\\pi) \\sin(m\\pi) dx\\\\\n&= \\frac{\\pi}{2}b_m\n\\end{align}\n\\]\nとなり，\n\\[\nb_n = \\frac{2}{\\pi}\\int^{\\pi}_0f(x)\\sin nx \\ dx\n\\]\nこのように求めた級数関数が変数分離型を仮定したときの熱伝導方程式の解となりうるとフーリエは主張しました． これがフーリエ級数の誕生です.\n\n\nフーリエ級数の問題点と積分理論再考へ\nフーリエ級数が登場初期には以下のような批判にさらされました:\n\nフーリエ級数が収束する保証はどこにあるのか？\n\\(0\\)から\\(\\pi\\)までの特定の一個の\\(x\\)について\\(f(x)\\)の値を変更しても積分の値には影響しないので異なる関数が同じフーリエ級数で表現されてしまうのではないか？\n無限級数の項別積分(無限和と積分の順序交換)ができる保証はどこにあるのか？\n\n無限和と積分の順序交換の批判とは，仮に熱分布関数\\(T(x, t)\\)がフーリエ級数の形式で表せることができたとしても\n\\[\n\\begin{align*}\n&\\int^\\pi_{-\\pi}\\sum_{k=1}^\\infty (a_k \\cos kx + b_k \\sin kx)\\cos nx\\ dx \\\\\n&=\\sum_{k=1}^\\infty \\left(a_k \\int^\\pi_{-\\pi}\\cos kx \\cos nx\\ dx + b_k \\int^\\pi_{-\\pi}\\sin kx \\cos nx\\ dx\\right)\n\\end{align*}\n\\]\nができる保証がないというものです. これはフーリエ級数のそれ自体の問題というよりかは\n\nどんな関数が積分可能か？\nどのようなときに項別積分ができるのか？\n\nという積分の定義・理論の問題です．フーリエの時代では積分の理論が十分なものではなく，微分の逆として積分が捉えられており，上記の問題に答えることができませんでした． 以上が，熱の変化という自然科学現象の解明のため提案されたフーリエ級数が数学理論，特に積分理論の再整備の必要性を促した流れとなります．"
  },
  {
    "objectID": "posts/2025-01-29-set-and-topology-series/index.html#appendix-正弦関数の積の積分公式の証明",
    "href": "posts/2025-01-29-set-and-topology-series/index.html#appendix-正弦関数の積の積分公式の証明",
    "title": "フーリエ級数と積分理論再考",
    "section": "Appendix: 正弦関数の積の積分公式の証明",
    "text": "Appendix: 正弦関数の積の積分公式の証明\n\n\nExercise 1 \n\\(n,k\\)をそれぞれ自然数としたとき\n\\[\n\\begin{align}\n\\int^{\\pi}_0\\sin nx \\sin kx dx =\\begin{cases}\n\\displaystyle 0 & (k\\neq n)\\\\[4pt]\n\\displaystyle \\frac{\\pi}{2} & (k = n)\n\\end{cases}\n\\end{align}\n\\]\n\n\n\n\n\n\n\n\n\nNoteProof\n\n\n\n\n\n積和の公式より\n\\[\n\\sin \\alpha\\sin \\beta=-\\frac{1}{2} \\left\\{\\cos(\\alpha+\\beta)-\\cos(\\alpha-\\beta)\\right\\}\n\\]\nこの積和の公式を用いると\n\\[\n\\begin{align}\n&\\int^{\\pi}_0\\sin nx \\sin kx\\ dx \\\\\n&= -\\frac{1}{2}\\int^{\\pi}_0 \\left\\{\\cos(n+k)x-\\cos(n-k)x\\right\\} dx \\\\\n&= -\\frac{1}{2}\\left\\{\\int^{\\pi}_0\\cos(n+k)x\\ dx- \\int^{\\pi}_0\\cos(n-k)x\\ dx\\right\\}\n\\end{align}\n\\]\nつぎに以下のケースを考えます\n\n\\(n=k\\)のとき\n\\(n\\neq k\\)のとき\n\n\n\\(n=k\\)のとき\n\n\\[\n-\\frac{1}{2}\\left\\{\\int^{\\pi}_0\\cos(n+k)x\\ dx- \\int^{\\pi}_0\\cos(n-k)x\\ dx\\right\\}\n\\]\nの第二項は\\(\\pi\\)となる一方, 第一項は\n\\[\n\\begin{align}\n\\int^{\\pi}_0\\cos(n+k)x dx &= -\\left[\\sin(n+k)x\\right]^{\\pi}_0\\\\\n&= 0\n\\end{align}\n\\]\n従って,\n\\[\n-\\frac{1}{2}\\left\\{\\int^{\\pi}_0\\cos(n+k)x\\ dx- \\int^{\\pi}_0\\cos(n-k)x\\ dx\\right\\} = \\frac{\\pi}{2}\n\\]\n\n\\(n\\neq k\\)のとき\n\n\\[\n\\begin{align}\n\\int^{\\pi}_0\\cos(n-k)x\\ dx &= -\\left[\\sin(n-k)x\\right]^{\\pi}_0 = 0\\\\[3pt]\n\\int^{\\pi}_0\\cos(n+k)x\\ dx &= -\\left[\\sin(n+k)x\\right]^{\\pi}_0 = 0\n\\end{align}\n\\]\nより\n\\[\n-\\frac{1}{2}\\left\\{\\int^{\\pi}_0\\cos(n+k)x\\ dx- \\int^{\\pi}_0\\cos(n-k)x\\ dx\\right\\} = 0\n\\]"
  },
  {
    "objectID": "posts/2025-06-03-goal-setting-template/index.html",
    "href": "posts/2025-06-03-goal-setting-template/index.html",
    "title": "目標設定例および設定ガイドライン",
    "section": "",
    "text": "項目\n内容記入例\n\n\n\n\n目標① 事業数値目標\nグローバル事業利益目標（◯◯億円）・店舗売上目標（△△△億円）達成\n\n\n達成水準\n確定した目標に対する達成率で評価する．\n\n\n\n\n評価基準設定例\n\n\n\n\n\n\n\n\n\n評価レベル\n達成率条件\n説明\n\n\n\n\n評価 1\n達成率 110%以上\n高業績を達成し，好転を活かした成果\n\n\n評価 2\n達成率 105%以上\n目標を超えた成果\n\n\n評価 3\n達成率 100%以上\n目標通りの達成\n\n\n評価 4\n達成率 90%以上（※Break-even基準）\n損益分岐点レベル（最低限の達成）\n\n\n評価 5\n達成率 90%未満（※赤字の可能性あり）\n赤字リスクあり，持続可能性のない成果水準と判断\n\n\n\n\n\n\n\n\n\n\n\n\nNoteTip 1: 評価1,2は「簡単には達成できない目標」として設計する\n\n\n\n\n評価1,2は，単なる目標達成ではなく，「チームの工夫」「機会の最大活用」などによって初めて達成できる水準に設計するべき\nストレッチ目標（Stretch Goal）として取り扱う\n\n\n\n\n\n\n\n\n\nNoteTip 2: 評価は目標達成率で行う\n\n\n\n\n金額そのものではなく，確定目標に対する比率で評価\n柔軟性を持たせ，実態に応じて評価可能にする\n絶対金額で設定してしまうと，期中修正が難しくなる\n\n\n\n\n\n\n\n\n\nNoteTip 3: 達成水準の考え方を言語化する\n\n\n\n\n「なぜその評価レベルを○○％に設定したのか」という背景や理由を明示すること\n例：評価4（90%）を損益分岐点とした場合、「事業として利益を維持できる最低ラインであるため」といった説明を添える\n評価1・2の高い目標水準に対しては，「在庫過剰の状況を逆手に取り，特別販促で売上を押し上げた場合の想定水準」など，チャレンジの意味づけを言語化する\n\n\n\n\n\n\n\n\n\nNoteTip 4: 状況に応じて目標は期中に修正する\n\n\n\n\n目標は，期初に設定したまま固定する必要はない\n個人の生産性評価が目的なので，経済状況の悪化（例：パンデミック，為替変動）や，業績改善の兆し（例：売上回復、販促効果）に応じて、**目標を途中で引き上げ・引き下げること\n目標修正時には，関係者の合意と透明性のある記録が重要\n\n\n\n\n\n\n\n\n\nNoteTip 5: 数値の根拠 or いつの数値を利用したのか記載する\n\n\n\n\n目標に用いた金額・数値については，どのタイミングの、どの資料に基づいた数値かを明示する\n例：「2025年4月3日時点売上予算に基づく」などと記載しておくことで，評価時に「前提条件の認識違い」による混乱を防ぐ。\n複数の候補値が存在する場合もあるので，「なぜこの数値を基準としたか」の選定理由も言及することが推奨"
  },
  {
    "objectID": "posts/2025-06-03-goal-setting-template/index.html#目標設定例",
    "href": "posts/2025-06-03-goal-setting-template/index.html#目標設定例",
    "title": "目標設定例および設定ガイドライン",
    "section": "",
    "text": "項目\n内容記入例\n\n\n\n\n目標① 事業数値目標\nグローバル事業利益目標（◯◯億円）・店舗売上目標（△△△億円）達成\n\n\n達成水準\n確定した目標に対する達成率で評価する．\n\n\n\n\n評価基準設定例\n\n\n\n\n\n\n\n\n\n評価レベル\n達成率条件\n説明\n\n\n\n\n評価 1\n達成率 110%以上\n高業績を達成し，好転を活かした成果\n\n\n評価 2\n達成率 105%以上\n目標を超えた成果\n\n\n評価 3\n達成率 100%以上\n目標通りの達成\n\n\n評価 4\n達成率 90%以上（※Break-even基準）\n損益分岐点レベル（最低限の達成）\n\n\n評価 5\n達成率 90%未満（※赤字の可能性あり）\n赤字リスクあり，持続可能性のない成果水準と判断\n\n\n\n\n\n\n\n\n\n\n\n\nNoteTip 1: 評価1,2は「簡単には達成できない目標」として設計する\n\n\n\n\n評価1,2は，単なる目標達成ではなく，「チームの工夫」「機会の最大活用」などによって初めて達成できる水準に設計するべき\nストレッチ目標（Stretch Goal）として取り扱う\n\n\n\n\n\n\n\n\n\nNoteTip 2: 評価は目標達成率で行う\n\n\n\n\n金額そのものではなく，確定目標に対する比率で評価\n柔軟性を持たせ，実態に応じて評価可能にする\n絶対金額で設定してしまうと，期中修正が難しくなる\n\n\n\n\n\n\n\n\n\nNoteTip 3: 達成水準の考え方を言語化する\n\n\n\n\n「なぜその評価レベルを○○％に設定したのか」という背景や理由を明示すること\n例：評価4（90%）を損益分岐点とした場合、「事業として利益を維持できる最低ラインであるため」といった説明を添える\n評価1・2の高い目標水準に対しては，「在庫過剰の状況を逆手に取り，特別販促で売上を押し上げた場合の想定水準」など，チャレンジの意味づけを言語化する\n\n\n\n\n\n\n\n\n\nNoteTip 4: 状況に応じて目標は期中に修正する\n\n\n\n\n目標は，期初に設定したまま固定する必要はない\n個人の生産性評価が目的なので，経済状況の悪化（例：パンデミック，為替変動）や，業績改善の兆し（例：売上回復、販促効果）に応じて、**目標を途中で引き上げ・引き下げること\n目標修正時には，関係者の合意と透明性のある記録が重要\n\n\n\n\n\n\n\n\n\nNoteTip 5: 数値の根拠 or いつの数値を利用したのか記載する\n\n\n\n\n目標に用いた金額・数値については，どのタイミングの、どの資料に基づいた数値かを明示する\n例：「2025年4月3日時点売上予算に基づく」などと記載しておくことで，評価時に「前提条件の認識違い」による混乱を防ぐ。\n複数の候補値が存在する場合もあるので，「なぜこの数値を基準としたか」の選定理由も言及することが推奨"
  },
  {
    "objectID": "posts/2025-12-24-compare-two-csv/index.html",
    "href": "posts/2025-12-24-compare-two-csv/index.html",
    "title": "2つcsvファイルのカラムのsumをmarkdown形式で出力する",
    "section": "",
    "text": "verify_diff.py は，2つのCSVファイルを比較して差分を表示するPythonスクリプトです． グループ別に集計したデータ同士を比較し，マークダウンテーブルまたはCSV形式で出力します．"
  },
  {
    "objectID": "posts/2025-12-24-compare-two-csv/index.html#概要",
    "href": "posts/2025-12-24-compare-two-csv/index.html#概要",
    "title": "2つcsvファイルのカラムのsumをmarkdown形式で出力する",
    "section": "",
    "text": "verify_diff.py は，2つのCSVファイルを比較して差分を表示するPythonスクリプトです． グループ別に集計したデータ同士を比較し，マークダウンテーブルまたはCSV形式で出力します．"
  },
  {
    "objectID": "posts/2025-12-24-compare-two-csv/index.html#使い方",
    "href": "posts/2025-12-24-compare-two-csv/index.html#使い方",
    "title": "2つcsvファイルのカラムのsumをmarkdown形式で出力する",
    "section": "使い方",
    "text": "使い方\n# 基本的な使い方（マークダウン出力）\nuv run python verify_diff.py file1.csv file2.csv\n\n# CSV出力\nuv run python verify_diff.py file1.csv file2.csv -o output.csv\n\n# カラム指定\nuv run python verify_diff.py file1.csv file2.csv \\\n  --group-col1 group_col1 \\\n  --value-col1 value_col1 \\\n  --group-col2 group_col2 \\\n  --value-col2 value_col2"
  },
  {
    "objectID": "posts/2025-12-24-compare-two-csv/index.html#コマンドライン引数",
    "href": "posts/2025-12-24-compare-two-csv/index.html#コマンドライン引数",
    "title": "2つcsvファイルのカラムのsumをmarkdown形式で出力する",
    "section": "コマンドライン引数",
    "text": "コマンドライン引数\n\n\n\n\n\n\n\n\n\n引数\n説明\nデフォルト値\n\n\n\n\nfile1\n1つ目のCSVファイル（詳細データ）\n必須\n\n\nfile2\n2つ目のCSVファイル（集計データ）\n必須\n\n\n--group-col1\nfile1のグループカラム名\ngroup_col1\n\n\n--value-col1\nfile1の値カラム名\nvalue_col1\n\n\n--group-col2\nfile2のグループカラム名\n1列目\n\n\n--value-col2\nfile2の値カラム名\n2列目\n\n\n--output, -o\n出力ファイルパス（CSV形式）\nなし（マークダウン出力）"
  },
  {
    "objectID": "posts/2025-12-24-compare-two-csv/index.html#コード解説",
    "href": "posts/2025-12-24-compare-two-csv/index.html#コード解説",
    "title": "2つcsvファイルのカラムのsumをmarkdown形式で出力する",
    "section": "コード解説",
    "text": "コード解説\n\n1. インポート\nimport argparse\nimport csv\nfrom collections import defaultdict\n\nargparse: コマンドライン引数処理\ncsv: CSV読み書き\ndefaultdict: 存在しないキーにデフォルト値を返す辞書\n\n\n\n2. マークダウンテーブル生成\ndef to_markdown_table(headers, rows):\n    lines = []\n    lines.append(\"| \" + \" | \".join(str(h) for h in headers) + \" |\")\n    lines.append(\"| \" + \" | \".join(\"---\" for _ in headers) + \" |\")\n    for row in rows:\n        lines.append(\"| \" + \" | \".join(str(v) for v in row) + \" |\")\n    return \"\\n\".join(lines)\n出力例:\n| グループ | file1 | file2 | 差分 |\n| --- | --- | --- | --- |\n| ウエルシア薬局 | 2497 | 2487 | -10 |\n\n\n3. CSV読み込み\ndef read_csv(filepath):\n    with open(filepath, encoding=\"utf-8\") as f:\n        reader = csv.DictReader(f)\n        return list(reader), reader.fieldnames\n\ncsv.DictReader: 各行を辞書として読み込み（キー=ヘッダー名）\n戻り値: (行リスト, カラム名リスト)\n\n\n\n4. file1の読み込みと集計\nrows1, cols1 = read_csv(args.file1)\nfile1_sum = defaultdict(int)\nfor row in rows1:\n    group = row[args.group_col1]\n    value = int(float(row[args.value_col1]))\n    file1_sum[group] += value\n処理:\n\nCSVを読み込み\ndefaultdict(int): 未登録キーは0を返す\nグループごとに値を合計\n\nなぜ int(float(...))?\n\nCSVの値が \"123.0\" の場合、直接 int() はエラー\nfloat() で一度変換してから int() に\n\n\n\n5. file2の読み込み\nrows2, cols2 = read_csv(args.file2)\ngroup_col2 = args.group_col2 if args.group_col2 else cols2[0]\nvalue_col2 = args.value_col2 if args.value_col2 else cols2[1]\nfile2_data = {}\nfor row in rows2:\n    group = row[group_col2]\n    value = int(float(row[value_col2]))\n    file2_data[group] = value\n\nカラム未指定時は1列目・2列目を使用\nfile2は集計済みデータなので単純な辞書に格納\n\n\n\n6. マージと差分計算\nall_groups = set(file1_sum.keys()) | set(file2_data.keys())\n\nmerged = []\nfor group in all_groups:\n    v1 = file1_sum.get(group)\n    v2 = file2_data.get(group)\n    diff = (v2 or 0) - (v1 or 0)\n    merged.append((group, v1, v2, diff))\n処理:\n\n両ファイルの全グループを集合演算で取得\n各グループの値を取得（存在しなければ None）\n差分計算: None は 0 として扱う\n\n\n\n7. ソート\nmerged.sort(key=lambda x: (x[1] is None, -(x[1] or 0)))\nソートキー:\n\nx[1] is None: True=1, False=0 → Noneは後ろへ\n-(x[1] or 0): 値の降順\n\n\n\n8. データ分類\nboth = [(g, v1, v2, d) for g, v1, v2, d in merged\n        if v1 is not None and v2 is not None]\nonly_file1 = [(g, v1) for g, v1, v2, d in merged if v2 is None]\nonly_file2 = [(g, v2) for g, v1, v2, d in merged if v1 is None]\ndiff_only = [(g, v1, v2, d) for g, v1, v2, d in both if d != 0]\n\n\n\n変数\n内容\n\n\n\n\nboth\n両方に存在\n\n\nonly_file1\nfile1のみに存在\n\n\nonly_file2\nfile2のみに存在\n\n\ndiff_only\n差分があるもの\n\n\n\n\n\n9. 出力\nif args.output:\n    # CSV出力\n    with open(args.output, \"w\", encoding=\"utf-8\", newline=\"\") as f:\n        writer = csv.writer(f)\n        writer.writerow([\"グループ\", \"file1\", \"file2\", \"差分\"])\n        for g, v1, v2, d in merged:\n            writer.writerow([g, v1 or \"\", v2 or \"\", d])\nelse:\n    # マークダウン出力\n    print(\"## 両方のファイルに存在するグループ\\n\")\n    print(to_markdown_table([\"グループ\", \"file1\", \"file2\", \"差分\"], both))\n    # ..."
  },
  {
    "objectID": "posts/2025-12-24-compare-two-csv/index.html#使用している標準ライブラリの機能",
    "href": "posts/2025-12-24-compare-two-csv/index.html#使用している標準ライブラリの機能",
    "title": "2つcsvファイルのカラムのsumをmarkdown形式で出力する",
    "section": "使用している標準ライブラリの機能",
    "text": "使用している標準ライブラリの機能\n\n\n\n機能\n説明\n\n\n\n\ncsv.DictReader\nCSVをヘッダー付き辞書として読み込み\n\n\ncsv.writer\nCSVファイルへの書き込み\n\n\ndefaultdict(int)\n未登録キーに0を返す辞書\n\n\nset() の \\|\n和集合（両方のキーを取得）\n\n\ndict.get()\nキーがなければNoneを返す"
  },
  {
    "objectID": "posts/2025-12-24-compare-two-csv/index.html#コード",
    "href": "posts/2025-12-24-compare-two-csv/index.html#コード",
    "title": "2つcsvファイルのカラムのsumをmarkdown形式で出力する",
    "section": "コード",
    "text": "コード\nimport argparse\nimport csv\nfrom collections import defaultdict\n\n\ndef to_markdown_table(headers, rows):\n    lines = []\n    lines.append(\"| \" + \" | \".join(str(h) for h in headers) + \" |\")\n    lines.append(\"| \" + \" | \".join(\"---\" for _ in headers) + \" |\")\n    for row in rows:\n        lines.append(\"| \" + \" | \".join(str(v) for v in row) + \" |\")\n    return \"\\n\".join(lines)\n\n\ndef read_csv(filepath):\n    with open(filepath, encoding=\"utf-8\") as f:\n        reader = csv.DictReader(f)\n        return list(reader), reader.fieldnames\n\n\ndef main():\n    parser = argparse.ArgumentParser(description=\"2つのCSVファイルを比較して差分を表示します\")\n    parser.add_argument(\"file1\", help=\"1つ目のCSVファイル（詳細データ）\")\n    parser.add_argument(\"file2\", help=\"2つ目のCSVファイル（集計データ）\")\n    parser.add_argument(\"--group-col1\", default=\"group_col1\", help=\"file1のグループカラム名\")\n    parser.add_argument(\"--value-col1\", default=\"value_col1\", help=\"file1の値カラム名\")\n    parser.add_argument(\"--group-col2\", default=None, help=\"file2のグループカラム名 (default: 1列目)\")\n    parser.add_argument(\"--value-col2\", default=None, help=\"file2の値カラム名 (default: 2列目)\")\n    parser.add_argument(\"--output\", \"-o\", default=None, help=\"出力ファイルパス（CSV形式）\")\n    args = parser.parse_args()\n\n    # file1 を読み込み・グループ別に集計\n    rows1, cols1 = read_csv(args.file1)\n    file1_sum = defaultdict(int)\n    for row in rows1:\n        group = row[args.group_col1]\n        value = int(float(row[args.value_col1]))\n        file1_sum[group] += value\n\n    # file2 を読み込み\n    rows2, cols2 = read_csv(args.file2)\n    group_col2 = args.group_col2 if args.group_col2 else cols2[0]\n    value_col2 = args.value_col2 if args.value_col2 else cols2[1]\n    file2_data = {}\n    for row in rows2:\n        group = row[group_col2]\n        value = int(float(row[value_col2]))\n        file2_data[group] = value\n\n    # 全グループを取得\n    all_groups = set(file1_sum.keys()) | set(file2_data.keys())\n\n    # マージして差分計算\n    merged = []\n    for group in all_groups:\n        v1 = file1_sum.get(group)\n        v2 = file2_data.get(group)\n        diff = (v2 or 0) - (v1 or 0)\n        merged.append((group, v1, v2, diff))\n\n    # file1の値で降順ソート（Noneは末尾）\n    merged.sort(key=lambda x: (x[1] is None, -(x[1] or 0)))\n\n    # 分類\n    both = [(g, v1, v2, d) for g, v1, v2, d in merged if v1 is not None and v2 is not None]\n    only_file1 = [(g, v1) for g, v1, v2, d in merged if v2 is None]\n    only_file2 = [(g, v2) for g, v1, v2, d in merged if v1 is None]\n    diff_only = [(g, v1, v2, d) for g, v1, v2, d in both if d != 0]\n\n    # CSV出力\n    if args.output:\n        with open(args.output, \"w\", encoding=\"utf-8\", newline=\"\") as f:\n            writer = csv.writer(f)\n            writer.writerow([\"グループ\", \"file1\", \"file2\", \"差分\"])\n            for g, v1, v2, d in merged:\n                writer.writerow([g, v1 or \"\", v2 or \"\", d])\n        print(f\"CSVファイルを出力しました: {args.output}\")\n    else:\n        # マークダウンテーブル生成\n        print(\"## 両方のファイルに存在するグループ\\n\")\n        print(to_markdown_table([\"グループ\", \"file1\", \"file2\", \"差分\"], both))\n\n        if only_file1:\n            print(f\"\\n## {args.file1}にのみ存在するグループ\\n\")\n            print(to_markdown_table([\"グループ\", \"file1\"], only_file1))\n\n        if only_file2:\n            print(f\"\\n## {args.file2}にのみ存在するグループ\\n\")\n            print(to_markdown_table([\"グループ\", \"file2\"], only_file2))\n\n        if diff_only:\n            print(\"\\n## 差分があるグループのみ\\n\")\n            print(to_markdown_table([\"グループ\", \"file1\", \"file2\", \"差分\"], diff_only))\n\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "objectID": "posts/2025-10-06-google-project-name/index.html",
    "href": "posts/2025-10-06-google-project-name/index.html",
    "title": "Google Cloud Project命名規則",
    "section": "",
    "text": "Google Cloud Projectの識別子は以下の３つがあります\n\n\n\n\n\n\n\n\n\n\n\n識別子\n説明\n形式\n事後編集可能性\n重複可能性\n\n\n\n\nProject Name\n人が読めるプロジェクト名\nalphanumeric\n✅\n✅\n\n\nProject ID\nグローバルに一意のプロジェクト ID\nalphanumeric\n❌\n❌\n\n\nProject Number\n自動生成される一意のプロジェクト識別子\ndigits\n❌\n❌\n\n\n\n\n確認方法\n$ gcloud projects list\nPROJECT_ID               NAME                    PROJECT_NUMBER\ndigital-twin-2025        Digital Twin            104567892123\nregmonkey-blog           regmonkey-blog          103998721045\ntest-lab-ml              ML Experiment Sandbox   105432109876\nold-project              Old Internal Tool       101234567890\nProject IDは公開されるのか？\n\nAnswer\n\nプロジェクトや関連するリソースを参照すると、プロジェクト ID とリソース名が公開されます\n例: URL(https://console.cloud.google.com/bigquery?project=regmonkey-blogdata)\n\n\nProjectの削除\n$ gcloud projects delete &lt;project ID&gt;\nYour project will be deleted.\n\nDo you want to continue (Y/n)?  y\n\nDeleted [https://cloudresourcemanager.googleapis.com/v1/projects/&lt;project ID&gt;].\n\nYou can undo this operation for a limited period by running the command below.\n    $ gcloud projects undelete &lt;project ID&gt;\n\nSee https://cloud.google.com/resource-manager/docs/creating-managing-projects for information on shutting down projects."
  },
  {
    "objectID": "posts/2025-10-06-google-project-name/index.html#project識別子",
    "href": "posts/2025-10-06-google-project-name/index.html#project識別子",
    "title": "Google Cloud Project命名規則",
    "section": "",
    "text": "Google Cloud Projectの識別子は以下の３つがあります\n\n\n\n\n\n\n\n\n\n\n\n識別子\n説明\n形式\n事後編集可能性\n重複可能性\n\n\n\n\nProject Name\n人が読めるプロジェクト名\nalphanumeric\n✅\n✅\n\n\nProject ID\nグローバルに一意のプロジェクト ID\nalphanumeric\n❌\n❌\n\n\nProject Number\n自動生成される一意のプロジェクト識別子\ndigits\n❌\n❌\n\n\n\n\n確認方法\n$ gcloud projects list\nPROJECT_ID               NAME                    PROJECT_NUMBER\ndigital-twin-2025        Digital Twin            104567892123\nregmonkey-blog           regmonkey-blog          103998721045\ntest-lab-ml              ML Experiment Sandbox   105432109876\nold-project              Old Internal Tool       101234567890\nProject IDは公開されるのか？\n\nAnswer\n\nプロジェクトや関連するリソースを参照すると、プロジェクト ID とリソース名が公開されます\n例: URL(https://console.cloud.google.com/bigquery?project=regmonkey-blogdata)\n\n\nProjectの削除\n$ gcloud projects delete &lt;project ID&gt;\nYour project will be deleted.\n\nDo you want to continue (Y/n)?  y\n\nDeleted [https://cloudresourcemanager.googleapis.com/v1/projects/&lt;project ID&gt;].\n\nYou can undo this operation for a limited period by running the command below.\n    $ gcloud projects undelete &lt;project ID&gt;\n\nSee https://cloud.google.com/resource-manager/docs/creating-managing-projects for information on shutting down projects."
  },
  {
    "objectID": "posts/2025-10-06-google-project-name/index.html#google-cloud-naming-convention",
    "href": "posts/2025-10-06-google-project-name/index.html#google-cloud-naming-convention",
    "title": "Google Cloud Project命名規則",
    "section": "Google Cloud Naming Convention",
    "text": "Google Cloud Naming Convention\n\n❓ 編集ルールFAQ\n\nProject Name/ID/Numberは設定時に編集可能か？\n\nAnswer:\n\nProject Name: 編集可能\nProject ID: 編集可能\nProject Number: 編集不可\n\n\nProject Name作成要件\n\n4~30文字にする必要があり\n大文字を含めた英数字，シングルクォート，ハイフン，スペース，! が使用可能\n\nProject ID作成要件\n\n6～30 文字にする必要があり\n小文字、数字、ハイフンのみ\n先頭は英文字でなければならない\n末尾にハイフンは使用できない\n使用中または以前に使用された ID は指定できない（削除済みのプロジェクトも含む）\ngoogle や ssl などの制限付き文字列を含めることはできない\n\n\n\n\nProjectの新規作成例\n\n\n\n\n📘 Tips\n\n\n\n\n\n\n\nNote① Project Nameの可読性\n\n\n\n\n誰でも理解できる短く分かりやすい名前\n個人情報（PII）や機密情報を含めない\n\n\n\n\n\n\n\n\n\nNote② Project IDとProject Nameのアライン\n\n\n\n\nProject IDとProject Nameは異なっていてもよいが，管理容易性の観点からは似たような名前であることが望ましい\nProject IDとProject Name共通の命名規則持つのが良い\n\n参考例として\n{サービス識別子}-{環境識別子(staging / production)}-{企業識別子} \n\n\n## simple\n$ gcloud projects create scm-staging-regmonkey\n\n## 別にProject Nameをつける場合\n$ gcloud projects create scm-staging-regmonkey --name unko\nとgcloudコマンドベースでProjectを作成するとき create scm-staging-regmonkey は Project IDとなります．--name オプションを利用することでProject Nameも別に指定することができますが， デフォルトでは Google Project ID = Project Nameという処理が実行されます．\n\n\n\n\n\n\nNote③ 環境識別子の明示\n\n\n\n\nstaging/dev/productionを明示することで，誤操作リスクを減らす\n\n\n\n\n\n\n\n\n\nNote④ インデックスを使う場合はゼロ埋めする\n\n\n\n\n数値・インデックスを使う場合はゼロ埋め(001, 002)するとソートしやすくなる"
  },
  {
    "objectID": "posts/2025-10-06-google-project-name/index.html#refereneces",
    "href": "posts/2025-10-06-google-project-name/index.html#refereneces",
    "title": "Google Cloud Project命名規則",
    "section": "Refereneces",
    "text": "Refereneces\n\nGoogle Cloud Document &gt; プロジェクトの作成と管理"
  },
  {
    "objectID": "posts/2025-04-07-inner-product/index.html",
    "href": "posts/2025-04-07-inner-product/index.html",
    "title": "ベクトル空間における内積",
    "section": "",
    "text": "\\(\\pmb{a}, \\pmb{b} \\in \\mathbb R^2\\) を空間内の２つのベクトルでいずれもゼロベクトルではないとします．原点 \\(O\\) を始点として\n\\[\n\\begin{gather}\n\\pmb{a} = \\overrightarrow{OA}\\\\\n\\pmb{b} = \\overrightarrow{OB}\n\\end{gather}\n\\]\nとなる点 \\(A, B\\) をとります．このとき，\n\\[\n\\theta = \\angle AOB\n\\]\nを ベクトル \\(\\pmb{a}, \\pmb{b}\\) の成す角 といいいます．ただし，\\(0 \\leq \\theta \\leq \\pi\\) とします．\n\n\nDefinition 1 : ベクトルの内積 \n\\[\n\\|\\pmb{a}\\|\\,\\|\\pmb{b}\\| \\cos \\theta\n\\]\nを \\(\\pmb{a}\\) と \\(\\pmb{b}\\) の内積，またはスカラー積といい，\\((\\pmb{a}, \\pmb{b})\\) や \\(\\pmb{a} \\cdot \\pmb{b}\\) で表す．\\(\\pmb{a}, \\pmb{b}\\) のいずれかがゼロベクトルの場合は\n\\[\n(\\pmb{a}, \\pmb{b}) = 0\n\\]\nとする．\n\n\n ▶  シュワルツの不等式\n内積の定義\n\\[\n(\\pmb{a}, \\pmb{b}) = \\|\\pmb{a}\\|\\,\\|\\pmb{b}\\| \\cos \\theta\n\\]\nより， \\(-1 \\leq \\cos\\theta \\leq 1\\) であるから\n\\[\n\\vert(\\pmb{a}, \\pmb{b})\\vert \\leq \\|\\pmb{a}\\|\\,\\|\\pmb{b}\\|\n\\]\nであることがわかります．証明は いろいろな三角不等式 &gt; シュワルツの不等式と三角不等式 を参考にしてください．\n ▶  直交(orthogonal)\nベクトル \\(\\pmb{a}, \\pmb{b}\\) の成す角が直角のとき，ベクトル \\(\\pmb{a}, \\pmb{b}\\) は直交すると呼びます．このとき，\\(\\cos\\theta = 0\\) であることから\n\\[\n\\pmb{a} \\perp \\pmb{b} \\Longleftrightarrow (\\pmb{a}, \\pmb{b}) = 0\n\\]\n ▶  ベクトルの角度と幾何学的理解\nベクトルの成す角の定義より\n\\[\n\\theta = \\arccos \\frac{(\\pmb a, \\pmb b)}{\\|\\pmb a\\|\\,\\|\\pmb b\\|}\n\\]\nこの定義が幾何学的に見て妥当なものかどうかを以下確認します．\nFigure 1 のように \\(\\pmb{a}, \\pmb{b}\\) を考えたとき，\\(\\pmb{b}\\) の先端から \\(\\pmb{a}\\) に対して垂線を下ろします．その足 \\(B'\\) のベクトルを \\(k\\pmb a\\) とおくと，２つのベクトルが直交 \\(\\displaystyle\\theta = \\frac{\\pi}{2}\\)するとき，その内積は \\(0\\) になることから\n\\[\n(\\pmb {b} - k\\pmb {a}, \\pmb {a}) = 0\n\\]\n内積演算の性質より\n\\[\n\\begin{align}\n&(\\pmb {a}, \\pmb {b}) = k \\|\\pmb {a}\\|^2\\\\\n&\\Rightarrow k = \\frac{(\\pmb {a}, \\pmb {b})}{\\|\\pmb {a}\\|^2} \\label{#eq-inner-angle}\n\\end{align}\n\\]\n\\(\\triangle BOB'\\) は直角三角形なので \\(\\angle BOB'\\) に対応する \\(\\cos \\theta\\) は\n\\[\n\\cos \\theta = \\frac{k\\|\\pmb a\\|}{\\|\\pmb b\\|}\n\\]\n\\(\\eqref{#eq-inner-angle}\\) をもちいると\n\\[\n\\begin{align}\n\\cos \\theta\n    &= \\frac{k\\|\\pmb a\\|}{\\|\\pmb b\\|}\\\\\n    &= \\frac{(\\pmb {a}, \\pmb {b})}{\\|\\pmb {a}\\|^2}\\frac{\\|\\pmb a\\|}{\\|\\pmb b\\|}\\\\\n    &= \\frac{(\\pmb {a}, \\pmb {b})}{\\|\\pmb a\\|\\,\\|\\pmb b\\|}\n\\end{align}\n\\]\nと整理することができ，これは Definition 1 と一致することがわかります．\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport matplotlib.patches as patches\nimport cmath\n\n\n# Define two vectors\nv0 = np.array([1, 0])\nv1 = np.array([3, 1])\nv2 = np.array([1, 3])\n\n# Calculate the angle using the dot product\ndot_product = np.dot(v1, v2)\nnorm_v1 = np.linalg.norm(v1)\nnorm_v2 = np.linalg.norm(v2)\ncos_theta_0 = np.dot(v0, v1) / (norm_v1)\ncos_theta = dot_product / (norm_v1 * norm_v2)\ntheta_rad_0 = np.arccos(cos_theta_0)\ntheta_rad = np.arccos(cos_theta)\ntheta_deg = np.degrees(theta_rad)\n\n# define projection of B into A\nv3 =  v1 * norm_v2 * cos_theta / norm_v1\n\n\n# Plot the vectors\nfig, ax = plt.subplots(figsize=(6,6))\nax.grid(True)\n\norigin = np.array([0, 0])\nax.quiver(*origin, *v1, color='r', scale=1, scale_units='xy', angles='xy')\nax.quiver(*origin, *v2, color='b', scale=1, scale_units='xy', angles='xy')\n\n# Add angle arc using a circle segment\nangle_range = np.linspace(np.arccos(cos_theta_0), theta_rad + np.arccos(cos_theta_0), 100)\narc_radius = 0.5\narc_x = arc_radius * np.cos(angle_range)\narc_y = arc_radius * np.sin(angle_range)\nax.plot(arc_x, arc_y, 'k--', linewidth=1)\nax.plot((v2[0], v3[0]), (v2[1], v3[1]), 'k--', linewidth=1)\n\n# add square box at B'\ntheta = np.angle(complex(v3[0], v3[1]))  # 60 degrees\northogonal_theta = theta + np.pi / 2  # 90° 直交\noffset = np.linalg.norm(v3)\nsize = 0.15\n# 直角マークの位置を作成（60°方向に少し移動 → 90°方向に正方形を描く）\nbase_x = offset * np.cos(theta)\nbase_y = offset * np.sin(theta)\nrect_dx = size * np.cos(orthogonal_theta)\nrect_dy = size * np.sin(orthogonal_theta)\n\n\n# 小さな直角マーク（平行四辺形を回転して表現）\nright_angle = patches.Polygon(\n    [\n        (base_x, base_y),\n        (base_x + rect_dx, base_y + rect_dy),\n        (\n            base_x + rect_dx + size * np.cos(theta),\n            base_y + rect_dy + size * np.sin(theta),\n        ),\n        (base_x + size * np.cos(theta), base_y + size * np.sin(theta)),\n    ],\n    closed=True,\n    edgecolor=\"black\",\n    facecolor=\"none\",\n)\n\nax.add_patch(right_angle)\n\n# Annotate angle\nax.text(np.median(arc_x), np.median(arc_y), f\"{theta_deg:.1f}°\", fontsize=12)\nax.text(*origin-0.1, f\"O\", fontsize=12)\nax.text(*v1, f\"A\", fontsize=12)\nax.text(*v2, f\"B\", fontsize=12)\nax.text(*v3*0.9, f\"B'\", fontsize=12)\n\n# Plot settings\nax.set_xlim(-1, 3.5)\nax.set_ylim(-1, 3.5)\nax.set_aspect('equal')\n\nax.set_title(\"Angle Between Vectors Using Inner Product\")\nax.set_xlabel(\"X\")\nax.set_ylabel(\"Y\")\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 1\n\n\n\n\n\nTheorem 1 \n２つのベクトル \\(\\pmb a, \\pmb b\\) の成分表示を \\(\\pmb a = (a_1, \\cdots, a_n), \\pmb b = (b_1, \\cdots, b_n)\\) とするとき\n\\[\n(\\pmb a, \\pmb b) = \\sum_{i=1}^n a_ib_i\n\\]\nが成り立つ．ただし，証明にあたってノルムの定義は与えられているものとする\n\\[\n\\|\\pmb a\\| = \\sqrt{a_1^2 + \\cdots + a_n^2}\n\\]\n\n\n\n\n\n\n\n\n\nNoteProof\n\n\n\n\n\n\\(\\pmb a, \\pmb b\\) のなす角を \\(\\theta\\) とすると，余弦定理より\n\\[\n\\begin{align}\n\\|\\pmb a\\|^2 + \\|\\pmb b\\|^2 - \\|\\pmb a - \\pmb b\\|^2 = 2 \\|\\pmb a\\| \\, \\|\\pmb b\\| \\cos\\theta\n\\end{align}\n\\]\nノルムの定義より\n\\[\n\\begin{gather}\n\\|\\pmb a\\|^2 = a_1^2 + \\cdots + a_n^2\\\\\n\\|\\pmb b\\|^2 = b_1^2 + \\cdots + b_n^2\\\\\n\\|\\pmb a - \\pmb b\\|^2 = (a_1 - b_1)^2 + \\cdots + (a_n - b_n)^2\n\\end{gather}\n\\]\nまた，内積の定義より\n\\[\n\\|\\pmb a\\| \\, \\|\\pmb b\\| \\cos\\theta = \\|\\pmb a\\| \\, \\|\\pmb b\\|\\frac{(\\pmb a, \\pmb b)}{\\|\\pmb a\\| \\, \\|\\pmb b\\|} = (\\pmb a, \\pmb b)\n\\]\n従って，\n\\[\n\\begin{align}\n\\|\\pmb a\\|^2 + \\|\\pmb b\\|^2 - \\|\\pmb a - \\pmb b\\|^2\n    &= 2\\sum_i a_ib_i\\\\\n    &= 2(\\pmb a, \\pmb b)\n\\end{align}\n\\]\nよって，\n\\[\n(\\pmb a, \\pmb b) = \\sum_{i=1}^n a_ib_i\n\\]\n\n\n\n\n\n\\(\\mathbb R^n\\) の属する\\(n\\)次元実ベクトル \\(\\pmb a = (a_1, \\cdots, a_n)^T, \\pmb b = (b_1, \\cdots, b_n)^T\\) を考えます．この２つのベクトルの内積は上で確認したように\n\\[\n(\\pmb a, \\pmb b) = \\sum_{i=1}^n a_ib_i\n\\]\nとなります．ここで，\\(\\pmb a, \\pmb b\\) を \\((n \\times 1)\\) 行列とみなすと\n\\[\n(\\pmb a, \\pmb b) = \\pmb a^T\\pmb b\n\\]\nと一致します．ここから\\(n\\)次元実ベクトルの内積について次の演算性質を確認することができます．\n\n\nTheorem 2 \n\\(h, k \\in \\mathbb R\\) とすると\n\\[\n\\begin{align}\n\\text{対称性:} \\quad& (\\pmb a, \\pmb b)  = (\\pmb b, \\pmb a)\\\\\n\\text{線形性:} \\quad& (h\\pmb a + k\\pmb a^\\prime, \\pmb b)  = h(\\pmb a, \\pmb b) + k(\\pmb a^\\prime, \\pmb b)\\\\\n& (\\pmb a, h\\pmb b + k\\pmb b^\\prime)  = h(\\pmb a, \\pmb b) + k(\\pmb a, \\pmb b^\\prime)\\\\\n\\label{#eq-positivity}\\text{正値性:} \\quad& (\\pmb a, \\pmb a)  \\geq 0\n\\end{align}\n\\]\n\n\n\n\n\n\n\n\n\nNoteProof\n\n\n\n\n\n ▶  対称性\n\\[\n\\begin{align}\n(\\pmb a, \\pmb b)\n    &= \\pmb a^T\\pmb b\\\\\n    &= (\\pmb a^T\\pmb b)^T\\\\\n    &= (\\pmb b^T\\pmb a)\\\\\n    &= (\\pmb b, \\pmb a)\n\\end{align}\n\\]\n ▶  線形性 \n\\[\n\\begin{align}\n(h\\pmb a + k\\pmb a^\\prime, \\pmb b)\n    &= (h\\pmb a + k\\pmb a^\\prime)^T\\pmb b\\\\\n    &= h\\pmb a^T \\pmb b + k{\\pmb a^\\prime}^T \\pmb b\\\\\n    &= h(\\pmb a^T \\pmb b) + k({\\pmb a^\\prime}^T \\pmb b)\\\\\n    &= h(\\pmb a, \\pmb b) + k(\\pmb a^\\prime, \\pmb b)\n\\end{align}\n\\]\n ▶  正値性\n\\[\n\\begin{align}\n(\\pmb a, \\pmb a)\n    &= \\pmb a^T\\pmb a\\\\\n    &= \\sum_i a_i^2\n\\end{align}\n\\]\n\\(a_i^2 \\geq 0 \\, (\\forall i \\in (1, \\cdots, n))\\) であるので \\((\\pmb a, \\pmb a) \\geq 0\\) が成立します．また等号成立条件は\n\\[\na_i^2 = 0 \\, (\\forall i \\in (1, \\cdots, n)) \\Leftrightarrow a_i = 0 \\, (\\forall i \\in (1, \\cdots, n))\n\\]\n従って，\n\\[\n(\\pmb a, \\pmb a) = 0 \\Leftrightarrow \\pmb a = \\pmb 0\n\\]\n\n\n\n\n\n\n\n\n\nTip🍵 計量ベクトル空間\n\n\n\n\n内積の定義されたベクトル空間を計量ベクトル空間といいます．\n\n\n\n\n\n\n\n\nDefinition 2 : ノルム \n計量ベクトル空間 \\(V\\) の任意のベクトル \\(\\pmb a\\) に対して，\\(\\sqrt{(\\pmb a, \\pmb a)}\\) をベクトル \\(\\pmb a\\) の長さ, またはL2ノルムといい，\\(\\|\\pmb a\\|\\) と表す．\n\n\n内積の正値性 \\(\\eqref{#eq-positivity}\\) より \\(\\|\\pmb a\\| \\geq 0\\) が成り立ち，長さ の概念（長さが負にならない）と対応していることがわかります．\n\n\nTheorem 3 \n計量ベクトル空間 \\(V\\) の内積と長さについて，\\(\\pmb a, \\pmb b \\in V, k\\in \\mathbb R\\) としたとき以下が成り立つ\n\\[\n\\begin{align}\n&\\|\\pmb a\\| \\geq 0\\\\\n&\\|k\\pmb a\\| = |k\\||\\pmb a\\|\\\\\n&(\\pmb a,\\pmb b) = \\frac{1}{2}\\{\\|\\pmb a + \\pmb b\\|^2 - \\|\\pmb a\\|^2 - \\|\\pmb b\\|^2\\} = \\frac{1}{2}\\{\\|\\pmb a\\|^2 + \\|\\pmb b\\|^2 - \\|\\pmb a - \\pmb b\\|^2 \\}\\\\\n&\\|\\pmb a + \\pmb b\\|^2 + \\|\\pmb a - \\pmb b\\|^2 = 2(\\|\\pmb a\\|^2 + \\|\\pmb b\\|^2)\n\\end{align}\n\\]\n\n\n\n\n\n\n\n\n\nNoteProof\n\n\n\n\n\n ▶  \\(\\|k\\pmb a\\| = |k\\||\\pmb a\\|\\)\n\\[\n\\begin{align}\n\\|k\\pmb a\\|^2\n    &= (k\\pmb a, k\\pmb a)\\\\\n    &= k^2 (\\pmb a, \\pmb a)\\\\\n    &= k^2 \\|\\pmb a\\|^2\n\\end{align}\n\\]\n従って，\n\\[\n\\begin{align}\n\\|k\\pmb a\\|\n    &= \\sqrt{\\|k\\pmb a\\|^2}\\\\\n    &= \\sqrt{k^2 \\|\\pmb a\\|^2}\\\\\n    &= |k\\||\\pmb a\\|\n\\end{align}\n\\]\n ▶  \\((\\pmb a,\\pmb b) = \\frac{1}{2}\\{\\|\\pmb a + \\pmb b\\|^2 - \\|\\pmb a\\|^2 - \\|\\pmb b\\|^2\\}\\)\n\\[\n\\begin{align}\n\\|\\pmb a + \\pmb b\\|^2\n    &= (\\pmb a + \\pmb b, \\pmb a + \\pmb b)\\\\\n    &= (\\pmb a, \\pmb a) + 2(\\pmb a, \\pmb b) + (\\pmb b, \\pmb b)\\\\\n    &= \\|\\pmb a\\|^2 + \\|\\pmb b\\|^2 + 2(\\pmb a, \\pmb b)\n\\end{align}\n\\]\n従って，\n\\[\n(\\pmb a,\\pmb b) = \\frac{1}{2}\\{\\|\\pmb a + \\pmb b\\|^2 - \\|\\pmb a\\|^2 - \\|\\pmb b\\|^2\\}\n\\]\n ▶  \\((\\pmb a,\\pmb b) = \\frac{1}{2}\\{\\|\\pmb a\\|^2 + \\|\\pmb b\\|^2 - \\|\\pmb a - \\pmb b\\|^2 \\}\\)\n\\[\n\\begin{align}\n\\|\\pmb a - \\pmb b\\|^2\n    &= (\\pmb a - \\pmb b, \\pmb a - \\pmb b)\\\\\n    &= \\|\\pmb a\\|^2 + \\|\\pmb b\\|^2 -2(\\pmb a, \\pmb b)\n\\end{align}\n\\]\n従って，\n\\[\n(\\pmb a,\\pmb b) = \\frac{1}{2}\\{\\|\\pmb a\\|^2 + \\|\\pmb b\\|^2 - \\|\\pmb a - \\pmb b\\|^2 \\}\n\\]\n ▶  \\(\\|\\pmb a + \\pmb b\\|^2 + \\|\\pmb a - \\pmb b\\|^2 = 2(\\|\\pmb a\\|^2 + \\|\\pmb b\\|^2)\\)\n\\[\n\\begin{align}\n\\|\\pmb a + \\pmb b\\|^2 & = \\|\\pmb a\\|^2 + \\|\\pmb b\\|^2  + 2(\\pmb a, \\pmb b)\\\\\n\\|\\pmb a - \\pmb b\\|^2 & = \\|\\pmb a\\|^2 + \\|\\pmb b\\|^2 - 2(\\pmb a, \\pmb b)\n\\end{align}\n\\]\n両辺を足し合わせると\n\\[\n\\|\\pmb a + \\pmb b\\|^2 + \\|\\pmb a - \\pmb b\\|^2 = 2(\\|\\pmb a\\|^2 + \\|\\pmb b\\|^2)\n\\]\n\n\n\n ▶  ピタゴラスの定理\n\\(n\\) 次元実ベクトル空間 \\(V\\) に対して，\\(\\pmb a, \\pmb b \\in V\\) を考えます．\\(\\pmb a\\perp \\pmb b\\) が成立する場合，\n\\[\n\\begin{align}\n\\|\\pmb a + \\pmb b\\|^2\n    &= (\\pmb a + \\pmb b, \\pmb a + \\pmb b)\\\\\n    &= \\|\\pmb a\\|^2 + \\|\\pmb b\\|^2 + 2(\\pmb a, \\pmb b)\\\\\n    &= \\|\\pmb a\\|^2 + \\|\\pmb b\\|^2\n\\end{align}\n\\]\nこれは \\(\\pmb a\\perp \\pmb b \\Leftrightarrow (\\pmb a, \\pmb b) = 0\\) であることからわかります．\n ▶  一般化されたピタゴラスの定理\n\\(\\pmb a_1, \\cdots, \\pmb a_n \\in V\\) が互いに直交している場合，\n\\[\n\\|\\pmb a_1 + \\cdots + \\pmb a_n \\|^2 = \\|\\pmb a_1 \\|^2 + \\cdots + \\|\\pmb a_n \\|^2\n\\]"
  },
  {
    "objectID": "posts/2025-04-07-inner-product/index.html#ベクトルの成す角と内積",
    "href": "posts/2025-04-07-inner-product/index.html#ベクトルの成す角と内積",
    "title": "ベクトル空間における内積",
    "section": "",
    "text": "\\(\\pmb{a}, \\pmb{b} \\in \\mathbb R^2\\) を空間内の２つのベクトルでいずれもゼロベクトルではないとします．原点 \\(O\\) を始点として\n\\[\n\\begin{gather}\n\\pmb{a} = \\overrightarrow{OA}\\\\\n\\pmb{b} = \\overrightarrow{OB}\n\\end{gather}\n\\]\nとなる点 \\(A, B\\) をとります．このとき，\n\\[\n\\theta = \\angle AOB\n\\]\nを ベクトル \\(\\pmb{a}, \\pmb{b}\\) の成す角 といいいます．ただし，\\(0 \\leq \\theta \\leq \\pi\\) とします．\n\n\nDefinition 1 : ベクトルの内積 \n\\[\n\\|\\pmb{a}\\|\\,\\|\\pmb{b}\\| \\cos \\theta\n\\]\nを \\(\\pmb{a}\\) と \\(\\pmb{b}\\) の内積，またはスカラー積といい，\\((\\pmb{a}, \\pmb{b})\\) や \\(\\pmb{a} \\cdot \\pmb{b}\\) で表す．\\(\\pmb{a}, \\pmb{b}\\) のいずれかがゼロベクトルの場合は\n\\[\n(\\pmb{a}, \\pmb{b}) = 0\n\\]\nとする．\n\n\n ▶  シュワルツの不等式\n内積の定義\n\\[\n(\\pmb{a}, \\pmb{b}) = \\|\\pmb{a}\\|\\,\\|\\pmb{b}\\| \\cos \\theta\n\\]\nより， \\(-1 \\leq \\cos\\theta \\leq 1\\) であるから\n\\[\n\\vert(\\pmb{a}, \\pmb{b})\\vert \\leq \\|\\pmb{a}\\|\\,\\|\\pmb{b}\\|\n\\]\nであることがわかります．証明は いろいろな三角不等式 &gt; シュワルツの不等式と三角不等式 を参考にしてください．\n ▶  直交(orthogonal)\nベクトル \\(\\pmb{a}, \\pmb{b}\\) の成す角が直角のとき，ベクトル \\(\\pmb{a}, \\pmb{b}\\) は直交すると呼びます．このとき，\\(\\cos\\theta = 0\\) であることから\n\\[\n\\pmb{a} \\perp \\pmb{b} \\Longleftrightarrow (\\pmb{a}, \\pmb{b}) = 0\n\\]\n ▶  ベクトルの角度と幾何学的理解\nベクトルの成す角の定義より\n\\[\n\\theta = \\arccos \\frac{(\\pmb a, \\pmb b)}{\\|\\pmb a\\|\\,\\|\\pmb b\\|}\n\\]\nこの定義が幾何学的に見て妥当なものかどうかを以下確認します．\nFigure 1 のように \\(\\pmb{a}, \\pmb{b}\\) を考えたとき，\\(\\pmb{b}\\) の先端から \\(\\pmb{a}\\) に対して垂線を下ろします．その足 \\(B'\\) のベクトルを \\(k\\pmb a\\) とおくと，２つのベクトルが直交 \\(\\displaystyle\\theta = \\frac{\\pi}{2}\\)するとき，その内積は \\(0\\) になることから\n\\[\n(\\pmb {b} - k\\pmb {a}, \\pmb {a}) = 0\n\\]\n内積演算の性質より\n\\[\n\\begin{align}\n&(\\pmb {a}, \\pmb {b}) = k \\|\\pmb {a}\\|^2\\\\\n&\\Rightarrow k = \\frac{(\\pmb {a}, \\pmb {b})}{\\|\\pmb {a}\\|^2} \\label{#eq-inner-angle}\n\\end{align}\n\\]\n\\(\\triangle BOB'\\) は直角三角形なので \\(\\angle BOB'\\) に対応する \\(\\cos \\theta\\) は\n\\[\n\\cos \\theta = \\frac{k\\|\\pmb a\\|}{\\|\\pmb b\\|}\n\\]\n\\(\\eqref{#eq-inner-angle}\\) をもちいると\n\\[\n\\begin{align}\n\\cos \\theta\n    &= \\frac{k\\|\\pmb a\\|}{\\|\\pmb b\\|}\\\\\n    &= \\frac{(\\pmb {a}, \\pmb {b})}{\\|\\pmb {a}\\|^2}\\frac{\\|\\pmb a\\|}{\\|\\pmb b\\|}\\\\\n    &= \\frac{(\\pmb {a}, \\pmb {b})}{\\|\\pmb a\\|\\,\\|\\pmb b\\|}\n\\end{align}\n\\]\nと整理することができ，これは Definition 1 と一致することがわかります．\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport matplotlib.patches as patches\nimport cmath\n\n\n# Define two vectors\nv0 = np.array([1, 0])\nv1 = np.array([3, 1])\nv2 = np.array([1, 3])\n\n# Calculate the angle using the dot product\ndot_product = np.dot(v1, v2)\nnorm_v1 = np.linalg.norm(v1)\nnorm_v2 = np.linalg.norm(v2)\ncos_theta_0 = np.dot(v0, v1) / (norm_v1)\ncos_theta = dot_product / (norm_v1 * norm_v2)\ntheta_rad_0 = np.arccos(cos_theta_0)\ntheta_rad = np.arccos(cos_theta)\ntheta_deg = np.degrees(theta_rad)\n\n# define projection of B into A\nv3 =  v1 * norm_v2 * cos_theta / norm_v1\n\n\n# Plot the vectors\nfig, ax = plt.subplots(figsize=(6,6))\nax.grid(True)\n\norigin = np.array([0, 0])\nax.quiver(*origin, *v1, color='r', scale=1, scale_units='xy', angles='xy')\nax.quiver(*origin, *v2, color='b', scale=1, scale_units='xy', angles='xy')\n\n# Add angle arc using a circle segment\nangle_range = np.linspace(np.arccos(cos_theta_0), theta_rad + np.arccos(cos_theta_0), 100)\narc_radius = 0.5\narc_x = arc_radius * np.cos(angle_range)\narc_y = arc_radius * np.sin(angle_range)\nax.plot(arc_x, arc_y, 'k--', linewidth=1)\nax.plot((v2[0], v3[0]), (v2[1], v3[1]), 'k--', linewidth=1)\n\n# add square box at B'\ntheta = np.angle(complex(v3[0], v3[1]))  # 60 degrees\northogonal_theta = theta + np.pi / 2  # 90° 直交\noffset = np.linalg.norm(v3)\nsize = 0.15\n# 直角マークの位置を作成（60°方向に少し移動 → 90°方向に正方形を描く）\nbase_x = offset * np.cos(theta)\nbase_y = offset * np.sin(theta)\nrect_dx = size * np.cos(orthogonal_theta)\nrect_dy = size * np.sin(orthogonal_theta)\n\n\n# 小さな直角マーク（平行四辺形を回転して表現）\nright_angle = patches.Polygon(\n    [\n        (base_x, base_y),\n        (base_x + rect_dx, base_y + rect_dy),\n        (\n            base_x + rect_dx + size * np.cos(theta),\n            base_y + rect_dy + size * np.sin(theta),\n        ),\n        (base_x + size * np.cos(theta), base_y + size * np.sin(theta)),\n    ],\n    closed=True,\n    edgecolor=\"black\",\n    facecolor=\"none\",\n)\n\nax.add_patch(right_angle)\n\n# Annotate angle\nax.text(np.median(arc_x), np.median(arc_y), f\"{theta_deg:.1f}°\", fontsize=12)\nax.text(*origin-0.1, f\"O\", fontsize=12)\nax.text(*v1, f\"A\", fontsize=12)\nax.text(*v2, f\"B\", fontsize=12)\nax.text(*v3*0.9, f\"B'\", fontsize=12)\n\n# Plot settings\nax.set_xlim(-1, 3.5)\nax.set_ylim(-1, 3.5)\nax.set_aspect('equal')\n\nax.set_title(\"Angle Between Vectors Using Inner Product\")\nax.set_xlabel(\"X\")\nax.set_ylabel(\"Y\")\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 1\n\n\n\n\n\nTheorem 1 \n２つのベクトル \\(\\pmb a, \\pmb b\\) の成分表示を \\(\\pmb a = (a_1, \\cdots, a_n), \\pmb b = (b_1, \\cdots, b_n)\\) とするとき\n\\[\n(\\pmb a, \\pmb b) = \\sum_{i=1}^n a_ib_i\n\\]\nが成り立つ．ただし，証明にあたってノルムの定義は与えられているものとする\n\\[\n\\|\\pmb a\\| = \\sqrt{a_1^2 + \\cdots + a_n^2}\n\\]\n\n\n\n\n\n\n\n\n\nNoteProof\n\n\n\n\n\n\\(\\pmb a, \\pmb b\\) のなす角を \\(\\theta\\) とすると，余弦定理より\n\\[\n\\begin{align}\n\\|\\pmb a\\|^2 + \\|\\pmb b\\|^2 - \\|\\pmb a - \\pmb b\\|^2 = 2 \\|\\pmb a\\| \\, \\|\\pmb b\\| \\cos\\theta\n\\end{align}\n\\]\nノルムの定義より\n\\[\n\\begin{gather}\n\\|\\pmb a\\|^2 = a_1^2 + \\cdots + a_n^2\\\\\n\\|\\pmb b\\|^2 = b_1^2 + \\cdots + b_n^2\\\\\n\\|\\pmb a - \\pmb b\\|^2 = (a_1 - b_1)^2 + \\cdots + (a_n - b_n)^2\n\\end{gather}\n\\]\nまた，内積の定義より\n\\[\n\\|\\pmb a\\| \\, \\|\\pmb b\\| \\cos\\theta = \\|\\pmb a\\| \\, \\|\\pmb b\\|\\frac{(\\pmb a, \\pmb b)}{\\|\\pmb a\\| \\, \\|\\pmb b\\|} = (\\pmb a, \\pmb b)\n\\]\n従って，\n\\[\n\\begin{align}\n\\|\\pmb a\\|^2 + \\|\\pmb b\\|^2 - \\|\\pmb a - \\pmb b\\|^2\n    &= 2\\sum_i a_ib_i\\\\\n    &= 2(\\pmb a, \\pmb b)\n\\end{align}\n\\]\nよって，\n\\[\n(\\pmb a, \\pmb b) = \\sum_{i=1}^n a_ib_i\n\\]\n\n\n\n\n\n\\(\\mathbb R^n\\) の属する\\(n\\)次元実ベクトル \\(\\pmb a = (a_1, \\cdots, a_n)^T, \\pmb b = (b_1, \\cdots, b_n)^T\\) を考えます．この２つのベクトルの内積は上で確認したように\n\\[\n(\\pmb a, \\pmb b) = \\sum_{i=1}^n a_ib_i\n\\]\nとなります．ここで，\\(\\pmb a, \\pmb b\\) を \\((n \\times 1)\\) 行列とみなすと\n\\[\n(\\pmb a, \\pmb b) = \\pmb a^T\\pmb b\n\\]\nと一致します．ここから\\(n\\)次元実ベクトルの内積について次の演算性質を確認することができます．\n\n\nTheorem 2 \n\\(h, k \\in \\mathbb R\\) とすると\n\\[\n\\begin{align}\n\\text{対称性:} \\quad& (\\pmb a, \\pmb b)  = (\\pmb b, \\pmb a)\\\\\n\\text{線形性:} \\quad& (h\\pmb a + k\\pmb a^\\prime, \\pmb b)  = h(\\pmb a, \\pmb b) + k(\\pmb a^\\prime, \\pmb b)\\\\\n& (\\pmb a, h\\pmb b + k\\pmb b^\\prime)  = h(\\pmb a, \\pmb b) + k(\\pmb a, \\pmb b^\\prime)\\\\\n\\label{#eq-positivity}\\text{正値性:} \\quad& (\\pmb a, \\pmb a)  \\geq 0\n\\end{align}\n\\]\n\n\n\n\n\n\n\n\n\nNoteProof\n\n\n\n\n\n ▶  対称性\n\\[\n\\begin{align}\n(\\pmb a, \\pmb b)\n    &= \\pmb a^T\\pmb b\\\\\n    &= (\\pmb a^T\\pmb b)^T\\\\\n    &= (\\pmb b^T\\pmb a)\\\\\n    &= (\\pmb b, \\pmb a)\n\\end{align}\n\\]\n ▶  線形性 \n\\[\n\\begin{align}\n(h\\pmb a + k\\pmb a^\\prime, \\pmb b)\n    &= (h\\pmb a + k\\pmb a^\\prime)^T\\pmb b\\\\\n    &= h\\pmb a^T \\pmb b + k{\\pmb a^\\prime}^T \\pmb b\\\\\n    &= h(\\pmb a^T \\pmb b) + k({\\pmb a^\\prime}^T \\pmb b)\\\\\n    &= h(\\pmb a, \\pmb b) + k(\\pmb a^\\prime, \\pmb b)\n\\end{align}\n\\]\n ▶  正値性\n\\[\n\\begin{align}\n(\\pmb a, \\pmb a)\n    &= \\pmb a^T\\pmb a\\\\\n    &= \\sum_i a_i^2\n\\end{align}\n\\]\n\\(a_i^2 \\geq 0 \\, (\\forall i \\in (1, \\cdots, n))\\) であるので \\((\\pmb a, \\pmb a) \\geq 0\\) が成立します．また等号成立条件は\n\\[\na_i^2 = 0 \\, (\\forall i \\in (1, \\cdots, n)) \\Leftrightarrow a_i = 0 \\, (\\forall i \\in (1, \\cdots, n))\n\\]\n従って，\n\\[\n(\\pmb a, \\pmb a) = 0 \\Leftrightarrow \\pmb a = \\pmb 0\n\\]\n\n\n\n\n\n\n\n\n\nTip🍵 計量ベクトル空間\n\n\n\n\n内積の定義されたベクトル空間を計量ベクトル空間といいます．\n\n\n\n\n\n\n\n\nDefinition 2 : ノルム \n計量ベクトル空間 \\(V\\) の任意のベクトル \\(\\pmb a\\) に対して，\\(\\sqrt{(\\pmb a, \\pmb a)}\\) をベクトル \\(\\pmb a\\) の長さ, またはL2ノルムといい，\\(\\|\\pmb a\\|\\) と表す．\n\n\n内積の正値性 \\(\\eqref{#eq-positivity}\\) より \\(\\|\\pmb a\\| \\geq 0\\) が成り立ち，長さ の概念（長さが負にならない）と対応していることがわかります．\n\n\nTheorem 3 \n計量ベクトル空間 \\(V\\) の内積と長さについて，\\(\\pmb a, \\pmb b \\in V, k\\in \\mathbb R\\) としたとき以下が成り立つ\n\\[\n\\begin{align}\n&\\|\\pmb a\\| \\geq 0\\\\\n&\\|k\\pmb a\\| = |k\\||\\pmb a\\|\\\\\n&(\\pmb a,\\pmb b) = \\frac{1}{2}\\{\\|\\pmb a + \\pmb b\\|^2 - \\|\\pmb a\\|^2 - \\|\\pmb b\\|^2\\} = \\frac{1}{2}\\{\\|\\pmb a\\|^2 + \\|\\pmb b\\|^2 - \\|\\pmb a - \\pmb b\\|^2 \\}\\\\\n&\\|\\pmb a + \\pmb b\\|^2 + \\|\\pmb a - \\pmb b\\|^2 = 2(\\|\\pmb a\\|^2 + \\|\\pmb b\\|^2)\n\\end{align}\n\\]\n\n\n\n\n\n\n\n\n\nNoteProof\n\n\n\n\n\n ▶  \\(\\|k\\pmb a\\| = |k\\||\\pmb a\\|\\)\n\\[\n\\begin{align}\n\\|k\\pmb a\\|^2\n    &= (k\\pmb a, k\\pmb a)\\\\\n    &= k^2 (\\pmb a, \\pmb a)\\\\\n    &= k^2 \\|\\pmb a\\|^2\n\\end{align}\n\\]\n従って，\n\\[\n\\begin{align}\n\\|k\\pmb a\\|\n    &= \\sqrt{\\|k\\pmb a\\|^2}\\\\\n    &= \\sqrt{k^2 \\|\\pmb a\\|^2}\\\\\n    &= |k\\||\\pmb a\\|\n\\end{align}\n\\]\n ▶  \\((\\pmb a,\\pmb b) = \\frac{1}{2}\\{\\|\\pmb a + \\pmb b\\|^2 - \\|\\pmb a\\|^2 - \\|\\pmb b\\|^2\\}\\)\n\\[\n\\begin{align}\n\\|\\pmb a + \\pmb b\\|^2\n    &= (\\pmb a + \\pmb b, \\pmb a + \\pmb b)\\\\\n    &= (\\pmb a, \\pmb a) + 2(\\pmb a, \\pmb b) + (\\pmb b, \\pmb b)\\\\\n    &= \\|\\pmb a\\|^2 + \\|\\pmb b\\|^2 + 2(\\pmb a, \\pmb b)\n\\end{align}\n\\]\n従って，\n\\[\n(\\pmb a,\\pmb b) = \\frac{1}{2}\\{\\|\\pmb a + \\pmb b\\|^2 - \\|\\pmb a\\|^2 - \\|\\pmb b\\|^2\\}\n\\]\n ▶  \\((\\pmb a,\\pmb b) = \\frac{1}{2}\\{\\|\\pmb a\\|^2 + \\|\\pmb b\\|^2 - \\|\\pmb a - \\pmb b\\|^2 \\}\\)\n\\[\n\\begin{align}\n\\|\\pmb a - \\pmb b\\|^2\n    &= (\\pmb a - \\pmb b, \\pmb a - \\pmb b)\\\\\n    &= \\|\\pmb a\\|^2 + \\|\\pmb b\\|^2 -2(\\pmb a, \\pmb b)\n\\end{align}\n\\]\n従って，\n\\[\n(\\pmb a,\\pmb b) = \\frac{1}{2}\\{\\|\\pmb a\\|^2 + \\|\\pmb b\\|^2 - \\|\\pmb a - \\pmb b\\|^2 \\}\n\\]\n ▶  \\(\\|\\pmb a + \\pmb b\\|^2 + \\|\\pmb a - \\pmb b\\|^2 = 2(\\|\\pmb a\\|^2 + \\|\\pmb b\\|^2)\\)\n\\[\n\\begin{align}\n\\|\\pmb a + \\pmb b\\|^2 & = \\|\\pmb a\\|^2 + \\|\\pmb b\\|^2  + 2(\\pmb a, \\pmb b)\\\\\n\\|\\pmb a - \\pmb b\\|^2 & = \\|\\pmb a\\|^2 + \\|\\pmb b\\|^2 - 2(\\pmb a, \\pmb b)\n\\end{align}\n\\]\n両辺を足し合わせると\n\\[\n\\|\\pmb a + \\pmb b\\|^2 + \\|\\pmb a - \\pmb b\\|^2 = 2(\\|\\pmb a\\|^2 + \\|\\pmb b\\|^2)\n\\]\n\n\n\n ▶  ピタゴラスの定理\n\\(n\\) 次元実ベクトル空間 \\(V\\) に対して，\\(\\pmb a, \\pmb b \\in V\\) を考えます．\\(\\pmb a\\perp \\pmb b\\) が成立する場合，\n\\[\n\\begin{align}\n\\|\\pmb a + \\pmb b\\|^2\n    &= (\\pmb a + \\pmb b, \\pmb a + \\pmb b)\\\\\n    &= \\|\\pmb a\\|^2 + \\|\\pmb b\\|^2 + 2(\\pmb a, \\pmb b)\\\\\n    &= \\|\\pmb a\\|^2 + \\|\\pmb b\\|^2\n\\end{align}\n\\]\nこれは \\(\\pmb a\\perp \\pmb b \\Leftrightarrow (\\pmb a, \\pmb b) = 0\\) であることからわかります．\n ▶  一般化されたピタゴラスの定理\n\\(\\pmb a_1, \\cdots, \\pmb a_n \\in V\\) が互いに直交している場合，\n\\[\n\\|\\pmb a_1 + \\cdots + \\pmb a_n \\|^2 = \\|\\pmb a_1 \\|^2 + \\cdots + \\|\\pmb a_n \\|^2\n\\]"
  },
  {
    "objectID": "posts/2025-04-07-inner-product/index.html#エルミート内積",
    "href": "posts/2025-04-07-inner-product/index.html#エルミート内積",
    "title": "ベクトル空間における内積",
    "section": "エルミート内積",
    "text": "エルミート内積\n実数上のベクトル空間の内積に相当するものを複素数上のベクトル空間で考えます．\\(\\pmb a \\in \\mathbb C^2\\) について実数上のベクトル空間の内積と同じように考えると\n\\[\n\\begin{align}\n\\pmb a &= (1 + 2i, 0)\\\\\n(\\pmb a, \\pmb a) &= 1 - 4 + 4i = -3 + 4i\n\\end{align}\n\\]\nとなり，正値性 \\((\\pmb a, \\pmb a)\\geq 0\\) が崩れてしまい，長さが定義できなくなるという問題が発生してしまいます．そこで \\(\\mathbb C^n\\) 上のベクトル空間についての内積は\n\\[\n(\\pmb a, \\pmb b) = \\pmb a^T\\overline{\\pmb b} =  a_1\\overline{b_1} + a_2\\overline{b_2} + \\cdots + a_n\\overline{b_n}\n\\]\nによって定義します(\\(\\overline b_j\\) は \\(b_j\\) の共役複素数)．このように定義した場合\n\n\n\n\n\n\nNoteProperty: エルミート内積の性質\n\n\n\n\\(\\pmb a, \\pmb b, \\pmb c\\in V\\), \\(k\\in C\\) のとき，\n\\[\n\\begin{align}\n&(\\pmb a, \\pmb b) = \\overline{(\\pmb b, \\pmb a)}\\\\\n&(\\pmb a + \\pmb b, \\pmb c) = (\\pmb a, \\pmb c) + (\\pmb b, \\pmb c)\\\\\n&(\\pmb a, \\pmb b + \\pmb c) = (\\pmb a, \\pmb b) + (\\pmb a, \\pmb c)\\\\\n&(k\\pmb a, \\pmb b) = k(\\pmb a, \\pmb b)\\\\\n&(\\pmb a, k\\pmb b) = \\overline k(\\pmb a, \\pmb b)\\\\\n&(\\pmb a, \\pmb a) \\in \\mathbb R \\text{ であり } (\\pmb a, \\pmb a) \\geq 0, (\\pmb a, \\pmb a) = 0 \\Leftrightarrow \\pmb a = \\pmb 0\n\\end{align}\n\\]\n\n\n１つ目の性質はエルミート性や共役対称性と呼ばれますが，以下のように確認することができます\n\\[\n\\begin{align}\n\\overline{(\\pmb b, \\pmb a)}\n    &= \\sum_i \\overline{b_i \\overline{a_i}}\\\\\n    &= \\sum_i \\overline{b_i} a_i\\\\\n    &= \\sum_i a_i\\overline{b_i} \\\\\n    &= (\\pmb a, \\pmb b)\n\\end{align}\n\\]\n ▶  \\(\\mathbb C^n\\) における直交\n\\(\\mathbb C^n\\) の場合，内積 \\((\\pmb a, \\pmb b)\\) は一般に複素数であって実数とは限りません．そのため，ベクトルの成す角は \\(\\mathbb R^n\\) のようには定義できません． しかし，\\((\\pmb a, \\pmb b) = 0\\) のとき，\\(\\pmb a\\perp \\pmb b\\) ということにすれば，直交という概念だけは定義できます．\n\n\nTheorem 4 : シュワルツの不等式 \n\\(\\mathbb C^n\\) の任意のベクトル \\(\\pmb a, \\pmb b\\) に対し，次が成り立つ．\n\\[\n\\|(\\pmb a, \\pmb b)\\| \\leq \\|\\pmb a\\|\\|\\pmb b\\|\n\\]\n\n\n\n\n\n\n\n\n\nNoteProof\n\n\n\n\n\n\\(x, y \\in \\mathbb C\\) とすると，エルミート内積の正値性より\n\\[\n\\begin{align}\n0\n    &\\leq (x\\pmb a + y\\pmb b, x\\pmb a + y\\pmb b)\\\\\n    &= |x|^2(\\pmb a, \\pmb a) + x \\overline y (\\pmb a, \\pmb b) + \\overline x y (\\pmb b, \\pmb a) + |y|^2(\\pmb b, \\pmb b)\n\\end{align}\n\\]\nここで，\\(x = (\\pmb b, \\pmb b), y = - (\\pmb a, \\pmb b)\\) とすると，\n\\[\n\\begin{align}\n&|x|^2(\\pmb a, \\pmb a) + x \\overline y (\\pmb a, \\pmb b) + \\overline x y (\\pmb b, \\pmb a) + |y|^2(\\pmb b, \\pmb b)\\\\\n    &= (\\pmb b, \\pmb b)\\overline{(\\pmb b, \\pmb b)}(\\pmb a, \\pmb a) - (\\pmb b, \\pmb b)\\overline{(\\pmb a, \\pmb b)}(\\pmb a, \\pmb b) - \\overline{(\\pmb b, \\pmb b)}(\\pmb a, \\pmb b)(\\pmb b, \\pmb a) + (\\pmb a, \\pmb b)\\overline{(\\pmb a, \\pmb b)}(\\pmb b, \\pmb b)\\\\\\\n    &= (\\pmb b, \\pmb b)(\\pmb b, \\pmb b)(\\pmb a, \\pmb a) - (\\pmb b, \\pmb b)\\|(\\pmb a, \\pmb b)\\|^2 - (\\pmb b, \\pmb b)\\|(\\pmb a, \\pmb b)\\|^2 + (\\pmb b, \\pmb b)\\|(\\pmb a, \\pmb b)\\|^2\\\\\n    &= 2((\\pmb b, \\pmb b)(\\pmb b, \\pmb b)(\\pmb a, \\pmb a) - (\\pmb b, \\pmb b)\\|(\\pmb a, \\pmb b)\\|^2)\n\\end{align}\n\\]\n従って，\n\\[\n0 \\leq (\\pmb b, \\pmb b) \\{(\\pmb b, \\pmb b)(\\pmb a, \\pmb a) - \\|(\\pmb a, \\pmb b)\\|^2\\}\n\\]\n\\(\\pmb b \\neq \\pmb 0\\) なら \\((\\pmb b, \\pmb b) &gt; 0\\) であるので\n\\[\n\\|(\\pmb a, \\pmb b)\\|^2 \\leq \\|\\pmb a \\|^2\\|\\pmb b \\|^2 \\Rightarrow \\|(\\pmb a, \\pmb b)\\| \\leq \\|\\pmb a\\|\\|\\pmb b\\|\n\\]\n\n\n\n\nExample 1 : 関数空間 \n実数の区間 \\([a, b]\\) で定義され，\\(K\\) の値を取る連続関数全体の空間 \\(U\\) において，\\(f, g\\in U\\) に対し，\n\\[\n(f, g) = \\int^b_a f(x) \\overline{g(x)} dx\n\\]\nと定めると，これは内積となる．内積となることからSchwarzの不等式が適応できるので，次の不等式を得ることができます\n\\[\n\\begin{align}\n\\|(f, g)\\| &\\leq \\sqrt{(f, f)}\\sqrt{(g, g)}\\\\[5pt]\n\\Rightarrow \\left\\|\\int^b_a f(x) \\overline{g(x)} dx\\right\\|\n    &\\leq \\sqrt{\\int^b_a f(x) \\overline{f(x)} dx}\\sqrt{\\int^b_a g(x) \\overline{g(x)} dx}\\\\[5pt]\n    &= \\sqrt{\\int^b_a \\|f(x)\\|^2 dx}\\sqrt{\\int^b_a \\|g(x)\\|^2 dx}\\\\\n\\end{align}\n\\]"
  },
  {
    "objectID": "posts/2025-06-24-awk-preprocess-with-calculation/index.html",
    "href": "posts/2025-06-24-awk-preprocess-with-calculation/index.html",
    "title": "CSVファイルの特定のカラムをawkで計算変換する",
    "section": "",
    "text": "CSV ファイル内の第2列の値を線形変換を通して別の単位に変換すること"
  },
  {
    "objectID": "posts/2025-06-24-awk-preprocess-with-calculation/index.html#goal",
    "href": "posts/2025-06-24-awk-preprocess-with-calculation/index.html#goal",
    "title": "CSVファイルの特定のカラムをawkで計算変換する",
    "section": "",
    "text": "CSV ファイル内の第2列の値を線形変換を通して別の単位に変換すること"
  },
  {
    "objectID": "posts/2025-06-24-awk-preprocess-with-calculation/index.html#full-command",
    "href": "posts/2025-06-24-awk-preprocess-with-calculation/index.html#full-command",
    "title": "CSVファイルの特定のカラムをawkで計算変換する",
    "section": "Full Command",
    "text": "Full Command\nワンライナースタイル\nawk -F',' 'BEGIN{OFS=\",\"; a = 0;  b = 101325 / 760} NR==1 {print $0} NR&gt;1 {if ($2 ~ /^[0-9.]+$/) {$2 = sprintf(\"%.3f\", a * $2 + b)} print $0}' input.csv\n改行有りスタイル\nawk -F',' '\nBEGIN {\n    OFS = \",\";\n    a = 2.5;          # 傾き（倍率）\n    b = 10;           # 切片（加算値）\n}\nNR == 1 {\n    print $0;         # ヘッダーはそのまま\n}\nNR &gt; 1 {\n    if ($2 ~ /^[0-9.]+$/) {\n        $2 = sprintf(\"%.3f\", a * $2 + b);  # 線形変換\n    }\n    print $0;\n}\n' input.csv\n\n改行有りスタイルでは line seperator ; は使用しなくても大丈夫です"
  },
  {
    "objectID": "posts/2025-06-24-awk-preprocess-with-calculation/index.html#explanation",
    "href": "posts/2025-06-24-awk-preprocess-with-calculation/index.html#explanation",
    "title": "CSVファイルの特定のカラムをawkで計算変換する",
    "section": "🔍 Explanation",
    "text": "🔍 Explanation\n\n\n\n\n\n\n\n\n構成要素\n内容\n\n\n\n\nawk\nAWK インタープリタを起動\n\n\n-F','\n入力のフィールド区切り文字をカンマに設定します．これにより、AWK が入力を CSV ファイルとして扱います\n\n\n'BEGIN{}\nBEGIN ブロックは、データ処理の前に一度だけ実行．{} 内部で処理を設定\n\n\nOFS=\",\";\nOFS=\",\" で出力の区切り文字をカンマに設定，CSV 形式で出力されるようにする\n\n\na = 0\na は 変数変換のための切片係数\n\n\nb = 101325 / 760\nb は 変数変換のための傾き係数\n\n\nNR==1 {print $0}\n最初の行（NR==1）の場合は，行全体（$0）をそのまま出力．これによりヘッダー行が変更されずに保持\n\n\nNR&gt;1 { ... }\n2行目以降の処理を指定\n\n\nif ($2 ~ /^[0-9.]+$/)\n第2列（圧力）が数値（正の小数や整数）であるかを確認．数値以外の場合はスキップ\n\n\n$2 = sprintf(\"%.3f\", $2 * conversion)\n第2列を変換係数で掛け算し，小数第3位で丸めて文字列に整形\n\n\nprint $0 (最後)\n変換後の行を出力\n\n\n\n\n\nExample 1  \n\n\n\n\n\n\n\n\n\n変換内容\na\nb\n説明\n\n\n\n\nmmHg → Pa\n133.322\n0\nmmHg → Paの圧力変換\n\n\n華氏 (°F) → 摂氏 (°C)\n5/9\n-32×5/9\n温度変換\n\n\nセンサー電圧 → 実測値\n任意\n任意\n校正式に応じて設定\n\n\n線形スケーリング (例: 0~1)\n任意\n任意\n最小-最大正規化などに応用可能"
  },
  {
    "objectID": "posts/2025-06-24-awk-preprocess-with-calculation/index.html#カスタムシェルスクリプト-linear_convert",
    "href": "posts/2025-06-24-awk-preprocess-with-calculation/index.html#カスタムシェルスクリプト-linear_convert",
    "title": "CSVファイルの特定のカラムをawkで計算変換する",
    "section": "📜 カスタムシェルスクリプト linear_convert",
    "text": "📜 カスタムシェルスクリプト linear_convert\n\n\nCSVファイルの指定列を線形変換し出力するスクリプト\n線形変換の式は以下\n\n\\[\ny = a\\times x + b\n\\]\n\n対象列の値が数値でない場合は、指定した文字列に置換するか，もしくは元の値を保持\n対象列は1から始まる番号で指定\n\n\n仕様\n\n入力CSVはカンマ区切りである必要があり\n\nDefintion\n#!/bin/bash\n: '\nlinear_convert - CSVファイルの指定列を線形変換し出力するスクリプト\n\nUsage:\n  ./linear_convert &lt;a: slope&gt; &lt;b: intercept&gt; &lt;column_num&gt; &lt;precision&gt; &lt;input_csv_file&gt; [na_replacement|keep]\n\nArguments:\n  a               傾き（線形変換の倍率）\n  b               切片（線形変換の加算値）\n  column_num      変換対象の列番号（1始まり）\n  precision       出力する小数点以下の桁数\n  input_csv_file  入力CSVファイルのパス\n  na_replacement  欠損値・非数値の置換文字列または\"keep\"（省略時は\"keep\"）\n\nDescription:\n  指定したCSVファイルの指定列の値に対して、線形変換 y = a * x + b を適用します。\n  欠損値や数値でない値は、指定した文字列に置換するか、\"keep\"指定であればそのまま保持します。\n\nExample:\n  # 第3列を y=2.5*x + 10 に変換し、小数点2桁で出力。欠損値はそのまま保持。\n  ./linear_convert.sh 2.5 10 3 2 input.csv\n\n  # 欠損値を\"Missing\"に置換する場合\n  ./linear_convert.sh 2.5 10 3 2 input.csv Missing\n'\n\n# --- 引数チェック ---\nif [ \"$#\" -lt 5 ] || [ \"$#\" -gt 6 ]; then\n  echo \"Usage: $0 &lt;a: slope&gt; &lt;b: intercept&gt; &lt;column_num&gt; &lt;precision&gt; &lt;input_csv_file&gt; [na_replacement|keep]\"\n  echo \"Example: $0 2.5 10 3 2 input.csv Missing\"\n  echo \"na_replacement options: NA, Missing, 0, or keep (default: keep)\"\n  exit 1\nfi\n\n# --- 引数を変数に代入 ---\na=\"$1\"\nb=\"$2\"\ncol=\"$3\"\nprecision=\"$4\"\ninput_file=\"$5\"\nna_replacement=\"${6:-keep}\"   # 6番目の引数がなければ keep をデフォルトに\n\nawk -F',' -v a=\"$a\" -v b=\"$b\" -v col=\"$col\" -v prec=\"$precision\" -v na=\"$na_replacement\" '\nBEGIN {\n    OFS = \",\";\n    format = \"%.\" prec \"f\";\n}\nNR == 1 {\n    print $0;\n}\nNR &gt; 1 {\n    val = $col;\n    if (val ~ /^[0-9.]+$/) {\n        $col = sprintf(format, a * val + b);\n    } else {\n        if (na == \"keep\") {\n            $col = val;   # 欠損・非数値はそのまま保持\n        } else {\n            $col = na;    # na_replacement で置換\n        }\n    }\n    print $0;\n}\n' \"$input_file\"\nUsage\nlinear_convert &lt;a: slope&gt; &lt;b: intercept&gt; &lt;column_num&gt; &lt;precision&gt; &lt;input_csv_file&gt; [na_replacement|keep]\nInputs\n\n\n\n\n\n\n\n引数名\n説明\n\n\n\n\na\n線形変換の傾き（倍率）\n\n\nb\n線形変換の切片（加算値）\n\n\ncolumn_num\n変換対象の列番号（1始まり）\n\n\nprecision\n出力する小数点以下の桁数\n\n\ninput_csv_file\n入力CSVファイルのパス\n\n\nna_replacement\n欠損値・非数値の置換文字列 または \"keep\"（省略時は \"keep\"）\n\n\n\n\nExample 2 第3列に対し y = 2.5 * x + 10 の変換を適用し，小数点以下2桁で表示\n./linear_convert 2.5 10 3 2 input.csv\n\n\n\nExample 3 欠損値を “Missing” に置換する場合\n./linear_convert 2.5 10 3 2 input.csv Missing\n\n\n\nExample 4 欠損値を 0 に置換する場合\n./linear_convert 2.5 10 3 2 input.csv 0"
  },
  {
    "objectID": "posts/2025-07-31-how-to-write-pseudocode-in-quarto/index.html",
    "href": "posts/2025-07-31-how-to-write-pseudocode-in-quarto/index.html",
    "title": "Quarto Projectへのpseudocode extensions導入",
    "section": "",
    "text": "Quarto PropjectのHTMLレンダリングでPseudocodeを利用可能にする\n\n\n\n\nQuarto がインストール済み\nQuarto プロジェクト（blogやbook）を作成済み"
  },
  {
    "objectID": "posts/2025-07-31-how-to-write-pseudocode-in-quarto/index.html#ゴール",
    "href": "posts/2025-07-31-how-to-write-pseudocode-in-quarto/index.html#ゴール",
    "title": "Quarto Projectへのpseudocode extensions導入",
    "section": "",
    "text": "Quarto PropjectのHTMLレンダリングでPseudocodeを利用可能にする\n\n\n\n\nQuarto がインストール済み\nQuarto プロジェクト（blogやbook）を作成済み"
  },
  {
    "objectID": "posts/2025-07-31-how-to-write-pseudocode-in-quarto/index.html#拡張機能のインストール",
    "href": "posts/2025-07-31-how-to-write-pseudocode-in-quarto/index.html#拡張機能のインストール",
    "title": "Quarto Projectへのpseudocode extensions導入",
    "section": "✅ 拡張機能のインストール",
    "text": "✅ 拡張機能のインストール\nQuarto Pseudocode ExtensionをQuarto Projectにquartoコマンドでインストールします:\nquarto add leovan/quarto-pseudocode\n/_extensions\n└── leovan\n    └── pseudocode\n        ├── _extension.yml\n        ├── pseudocode.lua\n        ├── pseudocode.min.css\n        └── pseudocode.min.js\n\n\n\n\n\n\nNoteREMARKS\n\n\n\n\nProject単位でのインストールとなります"
  },
  {
    "objectID": "posts/2025-07-31-how-to-write-pseudocode-in-quarto/index.html#拡張機能利用のための設定",
    "href": "posts/2025-07-31-how-to-write-pseudocode-in-quarto/index.html#拡張機能利用のための設定",
    "title": "Quarto Projectへのpseudocode extensions導入",
    "section": "🔨 拡張機能利用のための設定",
    "text": "🔨 拡張機能利用のための設定\n_quarto.yml に対して filters項目を以下のように追加します:\n\n\n_quarto.yml\n\nproject:\n  type: website\n  output-dir: _site\n\nfilters:\n  - pseudocode\n\n\nMath Setup\n\n\n_quarto.yml\n\nformat:\n  html:\n    include-in-header:\n      - include/mathjax.html\n\n上記のinclude/mathjax.htmlに対して以下のようなLinesを設定します\n\n\ninclude/mathjax.html\n\n&lt;script&gt;\n    MathJax = {\n        tex: {\n            inlineMath: [['$','$'], ['\\\\(','\\\\)']],\n            displayMath: [['$$','$$'], ['\\\\[','\\\\]']],\n            processEscapes: true,\n            processEnvironments: true,\n            tags: 'all',\n        }\n    }\n&lt;/script&gt;\n&lt;script src=\"https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-chtml-full.js\"\n        integrity=\"sha256-kbAFUDxdHwlYv01zraGjvjNZayxKtdoiJ38bDTFJtaQ=\"\n        crossorigin=\"anonymous\"&gt;\n&lt;/script&gt;\n\nMathJax Options\n\n\n\n\n\n\n\n\nKeys\n内容\n\n\n\n\ninlineMath\nインライン数式 のマーカー指定．例：$a^2 + b^2 = c^2$ または \\(...\\)\n\n\ndisplayMath\nディスプレイ数式（中央寄せで大きく表示） のマーカー指定．例：$$E = mc^2$$ または \\[...\\]\n\n\nprocessEscapes\nバックスラッシュを エスケープとして解釈するか．true にすると \\\\( を \\( として扱えるようになる\n\n\nprocessEnvironments\n\\begin{...} ... \\end{...} 形式の LaTeX 環境 を使えるようにする\n\n\ntags: 'all'\n式番号を付ける場所の指定．'all' は display 数式すべて に番号を振る（\\begin{equation} でなくても）\n\n\n\n\nMathJax本体の読み込み設定\n\n\n\n\n\n\n\n\n属性\n説明\n\n\n\n\nsrc\nCDN 上の MathJax v3 スクリプト．tex-chtml-full.js は LaTeX入力 + HTML/CSS出力 対応の完全版\n\n\nintegrity\nSubresource Integrity（SRI） チェック用ハッシュ（改ざん防止）\n\n\ncrossorigin=\"anonymous\"\nSRI を有効にするための指定\n\n\n\n\n\n\nAlgorithm表記設定\nPseudocodeの参照または参照時の表示を設定する場合，_quarto.ymlに以下のように記載します\n\n\n_quarto.yml\n\nformat:\n  html:\n    pseudocode:\n      caption-prefix: \"アルゴリズム\"    # DefaultはAlgorithm\n      reference-prefix: \"アルゴリズム\"  # DefaultはAlgorithm\n\n\n\n\n\n\n\n\n\n\n\nオプション名\n意味\nデフォルト\n解説\n\n\n\n\ncaption-prefix\nキャプションの前に付ける語句\n\"Algorithm\"\n例：Algorithm 1: Euclidean のような見出しに使われる\n\n\nreference-prefix\n@ref(fig:xxx) のような参照時の接頭辞\n\"Algorithm\"\n参照時に Algorithm 1 のように表示されます\n\n\ncaption-number\n番号付けの有無\ntrue\nfalse にすると Algorithm: xxx のように番号なしになる"
  },
  {
    "objectID": "posts/2025-07-31-how-to-write-pseudocode-in-quarto/index.html#pseudocode-blockの記述方法",
    "href": "posts/2025-07-31-how-to-write-pseudocode-in-quarto/index.html#pseudocode-blockの記述方法",
    "title": "Quarto Projectへのpseudocode extensions導入",
    "section": "📘 Pseudocode Blockの記述方法",
    "text": "📘 Pseudocode Blockの記述方法\npseudocodeコードブロックの中にPseudocodeを以下のように記述すると，以下のような出力になります．\n```pseudocode\n#| html-indent-size: \"1.2em\"\n#| html-comment-delimiter: \"//\"\n#| html-line-number: true\n#| html-line-number-punc: \":\"\n#| html-no-end: false\n#| pdf-placement: \"htb!\"\n#| pdf-line-number: true\n\n\\begin{algorithm}\n\\caption{Quicksort}\n\\begin{algorithmic}\n\\Procedure{Quicksort}{$A, p, r$}\n  \\If{$p &lt; r$}\n    \\State $q = $ \\Call{Partition}{$A, p, r$}\n    \\State \\Call{Quicksort}{$A, p, q - 1$}\n    \\State \\Call{Quicksort}{$A, q + 1, r$}\n  \\EndIf\n\\EndProcedure\n\\Procedure{Partition}{$A, p, r$}\n  \\State $x = A[r]$\n  \\State $i = p - 1$\n  \\For{$j = p$ \\To $r - 1$}\n    \\If{$A[j] &lt; x$}\n      \\State $i = i + 1$\n      \\State exchange\n      $A[i]$ with     $A[j]$\n    \\EndIf\n    \\State exchange $A[i]$ with $A[r]$\n  \\EndFor\n\\EndProcedure\n\\end{algorithmic}\n\\end{algorithm}\n```\n\n\n\n\\begin{algorithm} \\caption{Quicksort} \\begin{algorithmic} \\Procedure{Quicksort}{$A, p, r$} \\If{$p &lt; r$} \\State $q = $ \\Call{Partition}{$A, p, r$} \\State \\Call{Quicksort}{$A, p, q - 1$} \\State \\Call{Quicksort}{$A, q + 1, r$} \\EndIf \\EndProcedure \\Procedure{Partition}{$A, p, r$} \\State $x = A[r]$ \\State $i = p - 1$ \\For{$j = p$ \\To $r - 1$} \\If{$A[j] &lt; x$} \\State $i = i + 1$ \\State exchange $A[i]$ with $A[j]$ \\EndIf \\State exchange $A[i]$ with $A[r]$ \\EndFor \\EndProcedure \\end{algorithmic} \\end{algorithm}"
  },
  {
    "objectID": "posts/2025-07-31-how-to-write-pseudocode-in-quarto/index.html#quarto-pseudocode-の仕様",
    "href": "posts/2025-07-31-how-to-write-pseudocode-in-quarto/index.html#quarto-pseudocode-の仕様",
    "title": "Quarto Projectへのpseudocode extensions導入",
    "section": "quarto-pseudocode の仕様",
    "text": "quarto-pseudocode の仕様\nSyntax\n\nキーワードには大文字と小文字の形式(UpperCamelCase) (例: \\Procedure, \\If, \\EndIf) を使用\n数式は標準の LaTeX 数式構文をサポート\n\nBlock Parameters\nコメント形式のパラメーターを以下のように記載することができます．\n#| html-indent-size: \"1.2em\"\n#| html-comment-delimiter: \"//\"\n#| html-line-number: true\n#| html-line-number-punc: \":\"\n#| html-no-end: false\n#| pdf-placement: \"htb!\"\n#| pdf-line-number: true\n\n\\begin{algorithm}\n\\caption{My Algorithm}\n\\begin{algorithmic}\n...\n\\end{algorithmic}\n\\end{algorithm}\n\n\n\n\n\n\n\n\n\nパラメーター\nデフォルト\n形式\n説明\n\n\n\n\nlabel\n\nall\nクロス参照用のラベル (alg- で始まる必要があります)\n\n\nhtml-indent-size\n“1.2em”\nHTML\nネストされたブロックのインデント サイズ\n\n\nhtml-comment-delimiter\n“//”\nHTML\nコメント デリミタ文字\n\n\nhtml-line-number\ntrue\nHTML\n行番号を表示\n\n\nhtml-line-number-punc\n“:”\nHTML\n行番号の句読点\n\n\nhtml-no-end\nfalse\nHTML\n末尾のキーワードを非表示\n\n\npdf-placement\n“H”\nPDF\nフロート配置 (htbp!)\n\n\npdf-line-number\ntrue\nPDF\n行番号を表示\n\n\n\nCSS styleの設定\n設定用CSSファイルに以下のような記述をすることでfontやcontainerの設定ができます\n.pseudocode-container {\n  border: 1px solid #ddd;\n  border-radius: 5px;\n  padding: 10px;\n  margin: 20px 0;\n}\n\n.ps-algorithm {\n  font-family: 'Courier New', monospace;\n}"
  },
  {
    "objectID": "posts/2025-07-31-how-to-write-pseudocode-in-quarto/index.html#appendix-uppercamelcase",
    "href": "posts/2025-07-31-how-to-write-pseudocode-in-quarto/index.html#appendix-uppercamelcase",
    "title": "Quarto Projectへのpseudocode extensions導入",
    "section": "Appendix: UpperCamelCase",
    "text": "Appendix: UpperCamelCase\n\n\n\n\n\n\n\n\n\n名称\n例\n説明\n\n\n\n\nALL UPPERCASE\nPROJECT, TYPE, EXTENSIONS\n全部大文字\n\n\nUpperCamelCase\nProject, Type, Extensions\n各単語の先頭が大文字（キャメルケース）\n\n\nlowerCamelCase\nproject, projectType, extensionList\n1語目は小文字で始め，2語目以降の先頭を大文字\n\n\nsnake_case\nproject_type, extension_list\n単語をアンダースコア _ でつなぐ"
  },
  {
    "objectID": "posts/2025-07-31-how-to-write-pseudocode-in-quarto/index.html#references",
    "href": "posts/2025-07-31-how-to-write-pseudocode-in-quarto/index.html#references",
    "title": "Quarto Projectへのpseudocode extensions導入",
    "section": "References",
    "text": "References\n\nQuarto Pseudocode Extension"
  },
  {
    "objectID": "posts/2025-05-19-roo-code-setup/index.html",
    "href": "posts/2025-05-19-roo-code-setup/index.html",
    "title": "Roo Code環境構築",
    "section": "",
    "text": "項目\n説明\n\n\n\n\nOS\nUbuntu 22.04 LTS\n\n\nセットアップ対象\nRoo Code 3.17\n\n\n主な使用方法\nVSCode + Roo Code"
  },
  {
    "objectID": "posts/2025-05-19-roo-code-setup/index.html#この記事のスコープ",
    "href": "posts/2025-05-19-roo-code-setup/index.html#この記事のスコープ",
    "title": "Roo Code環境構築",
    "section": "",
    "text": "項目\n説明\n\n\n\n\nOS\nUbuntu 22.04 LTS\n\n\nセットアップ対象\nRoo Code 3.17\n\n\n主な使用方法\nVSCode + Roo Code"
  },
  {
    "objectID": "posts/2025-05-19-roo-code-setup/index.html#roo-codeとは",
    "href": "posts/2025-05-19-roo-code-setup/index.html#roo-codeとは",
    "title": "Roo Code環境構築",
    "section": "Roo Codeとは？",
    "text": "Roo Codeとは？\nRoo Codeとは？\n\nRoo Codeとは，VSCode上で動作するコーディングAIアシスタント\nAIを活用してコマンドラインやAPI操作を支援するインターフェースやエージェントであり，ユーザーが設定したLLMサービス自体は外部APIプロバイダーに依拠している\n\n\n\n\n\n\nsequenceDiagram\n    participant User as User\n    participant RooCode as Roo Code (AI Assistant)\n    participant Claude as Claude API\n\n    User-&gt;&gt;RooCode: 「preprocess.pyのunit test&lt;br&gt;をpytestで記載して」\n    RooCode-&gt;&gt;Claude: Calls Claude API\n    Claude-&gt;&gt;RooCode: API Response \n    RooCode-&gt;&gt;User: 「pytestを用いたunit test例はこちらです．&lt;br&gt;pytestコマンドを実行いたしましょうか？」\n\n\n\n\n\n\nRoo Codeでなにができるのか？\n\nモード切替機能を活用することで，コード作成，設計，デバッグなど，タスクに応じたアシストが可能\nVSCode上でCLIコマンドの実行が可能\n\nRoo Code vs GitHub Copilot\n\nRoo Code: より包括的なタスク管理とプロジェクト全体の理解を重視\nGitHub Copilot: リアルタイムのコード補完に特化\n\n\n\n\n\n\n\n\n\n\n特徴\nRoo Code\nGitHub Copilot\n\n\n\n\nタスクの範囲\nコード生成，デバッグ，設計，質問応答など対応可能\n主にコード補完や生成に特化\n\n\nツール連携\nファイル操作，検索，CLIコマンド実行など，VS Code内での高度な操作が可能\n基本的にコード補完に限定\n\n\nモード切り替え\nコード作成，設計，デバッグなど，目的に応じたモード及びカスタマイズが可能\nAsk, Edit, Agentモード切り替えが可能"
  },
  {
    "objectID": "posts/2025-05-19-roo-code-setup/index.html#install-roo-code",
    "href": "posts/2025-05-19-roo-code-setup/index.html#install-roo-code",
    "title": "Roo Code環境構築",
    "section": "Install Roo Code",
    "text": "Install Roo Code\nInstall Roo Code with VSCode\n\n拡張機能からRoo Codeをインストール\nサイドバーのRoo Codeアイコンをクリックし，API keyの設定"
  },
  {
    "objectID": "posts/2025-05-19-roo-code-setup/index.html#getting-startted",
    "href": "posts/2025-05-19-roo-code-setup/index.html#getting-startted",
    "title": "Roo Code環境構築",
    "section": "Getting Startted",
    "text": "Getting Startted\n参照ファイルの追加\n\n@&lt;file-path&gt; or 参照したいファイルをRoo Code message boxまでドラッグして，Shift を押しながら読み込ませる"
  },
  {
    "objectID": "posts/2025-05-19-roo-code-setup/index.html#customization",
    "href": "posts/2025-05-19-roo-code-setup/index.html#customization",
    "title": "Roo Code環境構築",
    "section": "Customization",
    "text": "Customization\n\nMode Customization\n\nPromptアイコンをクリックすることで，Roo Codeの「モード」は以下の機能でカスタマイズすることができます\n設定ファイル: ~/.config/Code/User/globalStorage/rooveterinaryinc.roo-cline/settings/custom_modes.json\n\n\n\n\n\n\n\n\n\n項目\n説明\n\n\n\n\nSlug\nMode unique identifier\n\n\nRole Definition\nモードの目的や専門性を定義例: 「文章の作成，編集，校正に特化したモード。技術文書やクリエイティブな文章の作成をサポートします」\n\n\nTool Groups\nread: ファイルの読み取りや指示の取得edit: ファイルの編集や新規作成command: ファイル管理やコンテンツ処理のためのコマンド実行\n\n\nWhen to Use\nこのモードを選択すべき状況を明確化．Orchestrateモードのときに役に立つ\n\n\nCustom Instructions\nモードの動作に関する追加指示を設定\n\n\n\n\n設定例\n{\n  \"customModes\": [\n    {\n      \"slug\": \"writer-mode\",\n      \"name\": \"📘 Writer Mode\",\n      \"roleDefinition\": \"You are Roo, a technical documentation expert specializing in creating clear, comprehensive documentation for software projects. Your expertise includes:\\nWriting clear, concise technical documentation\\nCreating and maintaining README files, API documentation, and user guides\\nFollowing documentation best practices and style guides\\nUnderstanding code to accurately document its functionality\\nOrganizing documentation in a logical, easily navigable structure\",\n      \"whenToUse\": \"Use this mode for tasks focused on content creation, editing, and refinement. Ideal for writing technical documentation, creative writing, or improving existing text\",\n      \"groups\": [\n        \"read\",\n        \"edit\"\n      ],\n      \"source\": \"global\",\n      \"customInstructions\": \"Focus on creating documentation that is clear, concise, and follows a consistent style. Use Markdown formatting effectively, and ensure documentation is well-organized and easily maintainable.\"\n    }\n  ]\n}\n\n\n\n\n\nMode別API configuration\n\n\n\n\nmode別API Configuration設定\n\nPromptアイコンをクリックすると，API Configuration という項目が確認できます\nAPI Configurationを設定することで，mode毎にどのAPIを使用するのかを設定することができます\n\ncustom_modes.json経由での設定は確認できず\n\n\n左の例では，Writer Modeについて，preprocessという名前のAPIをアサインしています．\n\n\n\n\n.rooignoreの設定\n\n.rooignore ファイルは，Roo ツールやフレームワークで無視するファイルやディレクトリを指定するために使用されます\n基本的な構文は.gitignoreと同じ\n.rooignore ファイルはプロジェクトのルートディレクトリに配置する必要があります\n\n\n\n# 一時ファイルを無視\n*.tmp\n\n# ログファイルを無視\nlogs/\n\n# 特定のファイルを除外\n!keep_this_file.txt\n\n\n.rooignore設定挙動\n.rooignore設定により無視されたファイルについて，操作はブロックされます：\n\nread_file: 無視されたファイルを読み取らない\nwrite_to_file: 無視されたファイルへの書き込みや新規作成を行わない\napply_diff: 無視されたファイルに対して差分を適用しない\nlist_code_definition_names: 無視されたファイルを解析の対象にしない\n\n\n\n\n\nShortcut settings\n\n\n\n\n\n\n\n\nショートカット\n機能説明\n\n\n\n\nctrl+meta+i\nRoo Codeパネルの表示/非表示(Toggle)\n\n\n/\nモード切替メニューの表示\n\n\nctrl + .\nモード切替Toggle\n\n\nalt + insert\ninput modeへ切り替え\n\n\nalt + enter\nAccept Roo Code suggestion\n\n\n\n\nVSCode設定Tips\n{\n    {\n    \"key\": \"ctrl+enter\",\n    \"command\": \"roo.acceptInput\",\n    \"when\": \"rooViewFocused\"\n  },\n}\n\nkey: キーボードショートカットを指\ncommand: \"roo.acceptInput\": Roo CodeのsuggestionをAcceptするコマンド\n\"when\": \"rooViewFocused\": Roo Codeビューがフォーカスされているときのみ\n\nVSCode shortcuts設定例\n\n\nkeybindings.json\n\n  {\n    \"key\": \"ctrl+enter\",\n    \"command\": \"-github.copilot.generate\",\n    \"when\": \"editorTextFocus && github.copilot.activated && !commentEditorFocused && !inInteractiveInput && !interactiveEditorFocused\"\n  },\n  {\n    \"key\": \"ctrl+meta+i\",\n    \"command\": \"workbench.view.extension.roo-cline-ActivityBar\",\n    \"when\": \"!auxiliaryBarVisible && (terminalFocus || editorTextFocus)\"\n  },\n  {\n    \"key\": \"ctrl+meta+i\",\n    \"command\": \"workbench.action.toggleAuxiliaryBar\",\n    \"when\": \"auxiliaryBarVisible\"\n  },\n  {\n    \"key\": \"ctrl+alt+i\",\n    \"command\": \"-workbench.panel.chat\",\n    \"when\": \"workbench.panel.chat.view.copilot.active\"\n  },\n  {\n    \"key\": \"ctrl+alt+b\",\n    \"command\": \"-workbench.action.toggleAuxiliaryBar\"\n  },\n  {\n    \"key\": \"alt+insert\",\n    \"command\": \"roo-cline.focusInput\",\n    \"when\": \"auxiliaryBarVisible\"\n  },\n  {\n    \"key\": \"alt+enter\",\n    \"command\": \"roo.acceptInput\",\n     \"when\": \"auxiliaryBarVisible\"\n  },"
  },
  {
    "objectID": "posts/2025-05-19-roo-code-setup/index.html#appendix-request-strategies",
    "href": "posts/2025-05-19-roo-code-setup/index.html#appendix-request-strategies",
    "title": "Roo Code環境構築",
    "section": "Appendix: Request Strategies",
    "text": "Appendix: Request Strategies\n\n\n\n\n\n\n\n\nStrategy\n実装例\n\n\n\n\nBe specific\nFix the codeではなくFix the bug in calculateTotal のように具体的に記述する\n\n\nProvide context\nファイルやコードの参照には @ Context Mentions を使用する\n\n\nBreak down tasks\n複雑なタスクは小さく管理しやすいステップに分割して提出する\n\n\nInclude exmaples\n特定のフォーマットやスタイルが必要な場合，サンプルコードを提供する\n\n\nFocus on related tasks\n一度に1つの焦点を絞ったリクエストを提出する\n\n\nAvoid Excessive jargon\n明確で分かりやすい言葉を使う，専門用語の使用は意味の明瞭化の範囲内で使用する"
  },
  {
    "objectID": "posts/2025-05-19-roo-code-setup/index.html#references",
    "href": "posts/2025-05-19-roo-code-setup/index.html#references",
    "title": "Roo Code環境構築",
    "section": "References",
    "text": "References\n\nRoo Code Docs"
  },
  {
    "objectID": "posts/2025-07-19-Ubuntu-Nautilus-and-ssh/index.html",
    "href": "posts/2025-07-19-Ubuntu-Nautilus-and-ssh/index.html",
    "title": "NautilusからSSH先のファイルを操作する",
    "section": "",
    "text": "手順\n\nNautilusをClient側で開く\nサイドバー下部の「その他の場所」をクリック\n「サーバーへ接続」に以下を入力：\n\nssh://&lt;ユーザー名&gt;@&lt;ホスト名またはIPアドレス&gt;\n\n入力箇所\nNautilusのbottom sectionにある「Connect to Server」のEnter server address ... の部分で接続設定をします．.ssh/configで\nHost pupupuserver\n  HostName 192.168.1.100\n  User kirby\n  LocalForward 8787 localhost:8787\nとHost設定を行っていれば\nssh://pupupuserver\nと入力してもOKです．\n\n\n\nnautilus\n\n\n\n\n\n\n\n\nNotesshfsを用いたmount\n\n\n\nmkdir ./remote\nsshfs pupupuserver:/home/kirby ./remote\nとすれば，ローカルのフォルダに直接ssh接続先ディレクトリをマウントすることができます．個人の方針として，\n\nアクセスしたいディレクトリが明確に定まっている状況\n分析プロジェクトとかでVSCode経由でSサーバーディレクトリを操作したいとき\n\nという状況のときに使用しています．"
  },
  {
    "objectID": "posts/2025-07-19-Ubuntu-Nautilus-and-ssh/index.html#ssh先のファイルをnautilusで操作する",
    "href": "posts/2025-07-19-Ubuntu-Nautilus-and-ssh/index.html#ssh先のファイルをnautilusで操作する",
    "title": "NautilusからSSH先のファイルを操作する",
    "section": "",
    "text": "手順\n\nNautilusをClient側で開く\nサイドバー下部の「その他の場所」をクリック\n「サーバーへ接続」に以下を入力：\n\nssh://&lt;ユーザー名&gt;@&lt;ホスト名またはIPアドレス&gt;\n\n入力箇所\nNautilusのbottom sectionにある「Connect to Server」のEnter server address ... の部分で接続設定をします．.ssh/configで\nHost pupupuserver\n  HostName 192.168.1.100\n  User kirby\n  LocalForward 8787 localhost:8787\nとHost設定を行っていれば\nssh://pupupuserver\nと入力してもOKです．\n\n\n\nnautilus\n\n\n\n\n\n\n\n\nNotesshfsを用いたmount\n\n\n\nmkdir ./remote\nsshfs pupupuserver:/home/kirby ./remote\nとすれば，ローカルのフォルダに直接ssh接続先ディレクトリをマウントすることができます．個人の方針として，\n\nアクセスしたいディレクトリが明確に定まっている状況\n分析プロジェクトとかでVSCode経由でSサーバーディレクトリを操作したいとき\n\nという状況のときに使用しています．"
  },
  {
    "objectID": "posts/2025-07-19-Ubuntu-Nautilus-and-ssh/index.html#多段ssh踏み台サーバ経由の場合",
    "href": "posts/2025-07-19-Ubuntu-Nautilus-and-ssh/index.html#多段ssh踏み台サーバ経由の場合",
    "title": "NautilusからSSH先のファイルを操作する",
    "section": "多段SSH（踏み台サーバ経由）の場合",
    "text": "多段SSH（踏み台サーバ経由）の場合\n踏み台設定は以下のような状況を考えます\nHost jumpserver\n  HostName jump.example.com\n  User kirby\n  LocalForward 8787 localhost:8787\n\nHost targetserver\n  HostName 192.168.1.110\n  User kirby\n  LocalForward 8787 localhost:8787\n\n手順: SSHトンネルを張ってlocalhostに接続\n\nSSHトンネルを貼る\n\nssh -N -L 2222:192.168.1.110:22 kirby@jump.example.com\n\nサイドバー下部の「その他の場所」をクリック\n「サーバーへ接続」に以下を入力：\n\nssh://kirby@localhost:2222"
  },
  {
    "objectID": "posts/2025-04-10-scatter-plot-with-D3/index.html",
    "href": "posts/2025-04-10-scatter-plot-with-D3/index.html",
    "title": "D3を用いた散布図生成",
    "section": "",
    "text": "Note可視化方針\n\n\n\n ▶  Question\n\n日常活動について，活動に対して感じる有意義さと活動を通して得られる幸福感はどのように相関しているのか？\n\n ▶  Data\n\n\n\n\n\n\n\nDataset\n2022 American Time Use Survey\n\n\nPATH\n./act_means.tsv\n\n\nAbout\n洗濯や調理などの日常活動に従事するときに感じる幸福度と有意義さをスコア化して，その平均を活動ごとに表したもの\n\n\n\n ▶  可視化コンポーネント: normal\n\nscatter_plot_default.html: HTML sturecture\nscatterplot_style.css: CSS for styling\nscatterplot_default.js: JS for scatterplot\n\n ▶  可視化コンポーネント: bubble version\n\nscatter_plot_with_bubble.html: HTML sturecture\nscatterplot_with_bubble.js: JS for bubbleplot"
  },
  {
    "objectID": "posts/2025-04-10-scatter-plot-with-D3/index.html#問題設定と可視化",
    "href": "posts/2025-04-10-scatter-plot-with-D3/index.html#問題設定と可視化",
    "title": "D3を用いた散布図生成",
    "section": "",
    "text": "Note可視化方針\n\n\n\n ▶  Question\n\n日常活動について，活動に対して感じる有意義さと活動を通して得られる幸福感はどのように相関しているのか？\n\n ▶  Data\n\n\n\n\n\n\n\nDataset\n2022 American Time Use Survey\n\n\nPATH\n./act_means.tsv\n\n\nAbout\n洗濯や調理などの日常活動に従事するときに感じる幸福度と有意義さをスコア化して，その平均を活動ごとに表したもの\n\n\n\n ▶  可視化コンポーネント: normal\n\nscatter_plot_default.html: HTML sturecture\nscatterplot_style.css: CSS for styling\nscatterplot_default.js: JS for scatterplot\n\n ▶  可視化コンポーネント: bubble version\n\nscatter_plot_with_bubble.html: HTML sturecture\nscatterplot_with_bubble.js: JS for bubbleplot"
  },
  {
    "objectID": "posts/2025-04-10-scatter-plot-with-D3/index.html#scatter-plot-with-d3",
    "href": "posts/2025-04-10-scatter-plot-with-D3/index.html#scatter-plot-with-d3",
    "title": "D3を用いた散布図生成",
    "section": "scatter plot with D3",
    "text": "scatter plot with D3\nMeaningfullness vs Hapiness について２つのplotを以下では提示しています． 左右のFigureは同じデータを使っているにも関わらず印象が異なります．\n\n\n\n\n\n\nNote解釈\n\n\n\n\nScatter Plot: Meaningfullness と Hapiness の間にはハッキリとした相関関係は見られない\nBubble Plot: 活動別従事者割合(relwt)をweightとして，それをbubble sizeに当てはめた場合，meaningfullnessとHapinessの間には正の相関があると推察できる\n\n\n\nscatter plotでは各点が等しく重要であるという印象を読み手に与えますが，aggregateデータではcount sizeがindexごとによって異なるケースでは 「各点が等しく重要」というのはミスリーディングかもしれません．このような場合，各indexのcount sizeという第３の情報をバブルの面積に比例させることで表すというBubble plotの利用が考えられます．\nただし，バブルの導入により各点が重なって読みづらくなってしまうというトレードオフもあるので，opacityの調整や，そもそも使用しないなどの意思決定をケースバイケースで実施していくことが必要です．\n\n\n ▶  Scatter Plot\n\n\n\n\n\n\n ▶  Bubble Plot\n\n\n\n\n\n\n\n\n\n\n\n\n\nImportantBubble Plotのコツ\n\n\n\n\nバブルの大きさは通常「面積」で表現するべき\nd3.scaleSqrt() を使ってバブルの半径をsqrtスケーリングすると，面積をデータに比例させることができます\nバブル同士が重なってしまうと個別の値が読み取りにくくなるので，透過度(opacity)の調整やBorder colorの導入の検討が必要\n\n\n\n\nアンチパターン: 透過度の重要性\nscatter plot, bubble plotにおいて，透過度（opacity）の調整は，データの密度や重なりを視覚的に正確に伝えるという効果を持つ重要な視覚的テクニックです．\n\n\n\n\n\n\nNote可視化シーン別透過度調整の効果\n\n\n\n\nscatter plot: 重なりが多いところが自然と濃くなるため，「どこに多くのデータが集中しているか」が明確になる\nbubble plot: 先に描いた点や小さい円が完全に見えなくなることを防ぐ\n\n\n\n以下では透過度を全く調整せずに可視化した場合を示しています．\n\n\n ▶  Scatter Plot\n\nすべての点が同じ濃さのため，data point密度の「濃度差が表現されない」\nバブルのサイズや色も一定なので視覚的には「一様」に見えてしまい、分布の濃淡や偏り、異常検知が難しくなる\n\n\n\n\n\n\n\n ▶  Bubble Plot\n\n小さなバブルが大きなバブルの下に隠れて見えなくなる\n密集したエリアがごちゃごちゃして読みづらくなる\nどのバブルがどの値か判別しにくくなるため，面積情報のメリットが薄れる"
  },
  {
    "objectID": "posts/2025-06-11-heatpump-lecture-01/index.html",
    "href": "posts/2025-06-11-heatpump-lecture-01/index.html",
    "title": "冷凍サイクルとヒートポンプの基礎",
    "section": "",
    "text": "Key Takeaways"
  },
  {
    "objectID": "posts/2025-06-11-heatpump-lecture-01/index.html#ものを冷やす仕組み",
    "href": "posts/2025-06-11-heatpump-lecture-01/index.html#ものを冷やす仕組み",
    "title": "冷凍サイクルとヒートポンプの基礎",
    "section": "ものを冷やす仕組み",
    "text": "ものを冷やす仕組み\n熱は常に「高温から低温へ移動(=熱力学第二法則)」します．この性質を利用して，冷却は次のように行われます：\n\n対象物よりも温度の低いものを接触させて熱を移動させる = 熱伝導ベース\n蒸発や断熱膨張などの物理現象を利用して，周囲から熱を奪う = 相変化ベース\n\nものを冷やすのは熱伝導ベースと相変化ベースの２つがありますが，冷却効率は大きく異なります．\n\n\n\n\n\n\n\n\n項目\n顕熱冷却\n蒸発冷却\n\n\n\n\n熱の種類\n顕熱（温度変化）\n潜熱（状態変化）\n\n\n冷却効率（J/g）\n例：1gの水を用いて10℃分熱を吸収する → 約42 J/g吸収\n水1gの蒸発 → 約2260 J/g吸収\n\n\nエネルギー吸収\n小さい（比熱×温度差に依存）\n大きい（潜熱は比熱の数十倍）\n\n\n使用例\n冷水で冷やす，金属板で放熱など\n汗の蒸発，気化式冷却，打ち水\n\n\n\n同じ質量の水を使っても，蒸発させた方がはるかに多くの熱エネルギーを奪えるため，冷却効率が高いという特徴が有ります．\n\n\n\n\n\n\nNote顕熱と比熱と潜熱\n\n\n\n\n1kgの冷水が \\(4.1916\\) kJ の熱を取り入れると，1Kだけ温度が上昇する．\n水を20℃→30℃に温めるときに使う熱は「顕熱」\n物質1kgの温度を1K上げるのに必要な熱量は「比熱」\n物質が状態変化（固体⇄液体⇄気体）するときに温度を変えずに出入りする熱は「潜熱」\n\n熱運動の激しさを変化させるのではなく，分子間の結合をほどくために使われる熱\n融解熱や蒸発熱\n\n\n\n\n\nExample 1 顕熱\n比熱 \\(c\\) [kJ/kg・K]， 質量 m[kg]，温度 \\(t_1\\) [K] の物質が熱を吸収して \\(t_2\\) になったとき，吸収した熱量 \\(Q\\) [kJ] は\n\\[\nQ = m\\cdot c(t_2 - t_1)\n\\]\nと計算できます．\n\n\n\nExample 2 水1gの潜熱\n水は極性分子で，水素結合が強いため，蒸発に多くのエネルギーが必要という特徴が有ります．\n\n\nCode\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\ndf = pd.read_csv('./input.csv')\ntemp = df['temp']\nenthalpy = df['enthalpy'] * 1000\n# pa = df['Pa']\n\nplt.figure(figsize=(8, 6))\nplt.plot(temp, enthalpy)\n\n# 軸ラベルとタイトル\nplt.xlabel('evaporation temperature(℃)')\nplt.ylabel('latent heat(J)')\nplt.title('evaporation temperature vs latent heat plot')\n\nplt.grid(True, linestyle=':', alpha=0.6)\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNote熱力学における圧力と温度\n\n\n\nマクロの状態変数\n\n熱力学とは，「非道にたくさんの分子からなる集団を１つの系と見て，これをマクロ的または統計的に調べる学問」\n空気などの気体を体積 \\(V\\) のある容器に入れたとき，夥しい気体分子が容器の中でそれぞれ動いている(ミクロ的視点)\nこの気体のマクロ的状態を表す量として圧力 \\(p\\) と絶対温度 \\(T\\) がある\n\nミクロとマクロの関係\n\n圧力 \\(p\\): ものすごい数の気体分子が単位時間・単位面積当たり，容器の壁面に衝突して与えられる力積(\\(\\text{力} \\times \\text{時間}\\))の平均的な送料\n温度 \\(T\\): 気体分子の不規則な運動の平均的な激しさの度合い\n\n絶対零度\n\nすべての分子が不規則な運動をやめて静止している状態\n\n\n\n\n0℃以下の低温までものを冷やしたいとき → 冷媒の登場\n熱を取り除きたいときは，蒸発潜熱を利用した冷却が効率が良いとわかりましたが，常圧のもとでは水は 100℃で沸騰，蒸発となります(標準沸点が100℃)．一方，絶対圧 0.6108 kPa のような低圧にすれば 0℃で水は沸騰→蒸発しますが，\n\nものを0℃まで冷やしたい場合は，この圧力を保つことが必要 → 高性能な真空ポンプが必要\n0℃以下まで冷やしたいとしても，0℃で水は凍ってしまうので，0℃以下の低温を得ることはできない(熱力学第二法則)\n\n0℃以下の低温を得るには，あまり高真空にすることなく，低い温度で沸騰・蒸発し，しかも蒸発潜熱の大きい物質を媒体として選ば良いとなります． このような熱を取り去る媒体を冷媒といいます．\n\nDefinition 1 (冷媒) \n冷媒（refrigerant）とは，蒸発・凝縮などの相変化を通じて熱を運ぶ物質であり，主に冷凍機やエアコン，ヒートポンプで使われます． 蒸気圧圧縮冷凍装置で用いられる冷媒として，アンモニアやフルオロカーボン(R 134 a, R410 aなど)がある．\n\n冷媒に求められる性質\n\n毒性及び燃焼性が低く，安全性に優れること\n地球環境や周囲環境を破壊しないこと\n化学的に安定であること\n適切な沸点を持つこと\n経済性および入手性に優れること\n単位面積あたりの冷凍能力が大きいこと（蒸発潜熱が大きい冷媒を使っていても，熱伝導率が悪かったり，流速が遅いと単位面積あたりの冷凍能力は小さい可能性がある）\n理論成績係数が高いこと\n圧縮機吐出しガス温度が冷凍機油の使用温度範囲内であること\n伝熱特性に優れること\n\n\n\n冷媒の種類\n蒸気圧縮冷凍装置が出現した初期は，メチルエーテル，エチルエーテル，アンモニア，二酸化硫黄，メチルクロライドなどが冷媒として使用されていましたが，燃焼性や毒性という問題が有りました．\n1928年にアメリカで無毒の不燃性のフルオロカーボン冷媒(R12)が発明され，産業用/家庭用の冷蔵庫や冷凍空調装置が普及するようになりました．冷媒は基本的にはフルオロカーボンとその他（自然冷媒）に分類されるほど普及しています．フルオロカーボンは，炭化水素の水素を一部フッ素に置き換えた化合物です．分子構造の特徴によりCFC，HCFC，HFC，HFO等のグループに分けられます．\nフルオロカーボン冷媒の種類\n\n\n\n\n\n\n\n\n\n冷媒種類\n冷媒番号\n説明\n\n\n\n\nCFC冷媒\nR11, R12\n塩素を含むクロロフルオロカーボン冷媒．モントリオール議定書での規制対象．1995年末の段階で日本では全廃されている\n\n\nHCFC冷媒\nR22, R123\n塩素を少量だけ含むハイドロクロロフルオロカーボン冷媒．2020年に日本では全廃\n\n\nHFC冷媒\nR32, R125, R134a，R410A\n塩素を含まないハイドロフルオロカーボン冷媒．HFC冷媒は，HCFC冷媒と比べると誘電率が大きく，その電気絶縁性がやや劣る（圧縮機からの漏れ電流には注意を要する）\n\n\n\n\nフルオロカーボン冷媒とアンモニア冷媒の比較\n\n冷凍効果という点ではアンモニアが圧倒的に優れる\nフルオロカーボン冷媒は冷凍効果は低めだが，安全性や取り扱いやすさから広く使われている\n\n\n\n\n\n\n\n\n\n\n比較項目\nアンモニア（NH₃）\nフルオロカーボン（HFC）\n\n\n\n\n冷凍効果（潜熱）\n◎ 非常に高い\n△ 中程度\n\n\n熱伝導率\n◎ 高い\n△ 低い\n\n\n冷媒量\n◎ 少量で済む\n△ 多く必要\n\n\n圧力\n○ 中〜高圧\n○ 中圧（使いやすい）\n\n\n安全性\n× 毒性・可燃性あり\n◎ 無毒・非可燃（だがGWP高）\n\n\n環境性\n◎ ODP/GWP＝0\n△ GWP高いものが多い\n\n\n用途\n産業用冷凍（冷凍倉庫など）\n家庭・車・業務用エアコンなど\n\n\n\n\n\n\n\n\n\n\nTip塩素とオゾン層破壊\n\n\n\n塩素を含むフルオロカーボン冷媒が大気中に放出されると，太陽からの強い紫外線によって分解され塩素 Cl を放出します． これがオゾン \\(\\text{O}_3\\) と以下のような化学反応を行って，オゾンを分解・破壊してしまいます\n\\[\n\\begin{align}\n\\text{Cl} + \\text{O}_3 &\\to \\text{CIO} + \\text{O}_2\\\\\n\\text{ClO} + \\text{O} &\\to \\text{CI} + \\text{O}_2 \\text{(再びオゾンを破壊してしまうClを生成)}\n\\end{align}\n\\]\n\nCIO: 一酸化塩素，常温常圧で気体であり，非常に不安定\n\n\n\n冷媒の番号\n冷媒番号はアシュレイ番号ともよばれ，冷媒の記号は先頭に「R」をつけて，2～4桁の数字を用いて表します．表記方法はASHRAE規格34及びISO817によって以下のように定められています\n\n\n\n\n\n\n\n\n項目\n説明\n\n\n\n\nR\n冷媒（Refrigerant）の頭文字\n\n\n千の位\n不飽和炭化水素に対する不飽和炭素結合の数（二重結合・三重結合など）\n\n\n百の位\n炭素原子の数 − 1\n\n\n十の位\n水素原子の数 ＋ 1\n\n\n一の位\nフッ素原子の数\n\n\n添え字\n構造異性体（同じ組成式だが結合の構造が異なる）または混合物の組成を区別するための記号\n\n\n\n\n\nプロパン冷媒(R290): \\(\\text{C}_3\\text{H}_8\\)\nR32: \\(\\text{C}\\text{H}_2\\text{F}_2\\)\n\nただし，すべてがこのルールに則っているわけではなく，400番台は非共沸混合冷媒，500番台は共沸混合冷媒を示します．これらの場合，番号の下２桁はASHRAE規格で認定された冷媒番号の取得順となります．\n600番台は有機化合物，700番台は無機化合物を示します．そのため，二酸化炭素やアンモニアなどの無機化合物には700番台が与えられます．例として，Nブタン冷媒R600，アンモニアR717，二酸化炭素R744です．\n\n\n\n\n\n\nTip共沸混合冷媒と非共沸混合冷媒\n\n\n\nフルオロカーボン冷媒の「単一成分冷媒」をいくつか混ぜ合わせた「混合冷媒」があり，混合冷媒は「非共沸点混合冷媒」と「共沸混合冷媒」に分けられます．非共沸混合冷媒は沸点の異なる冷媒同士を混ぜ合わせた冷媒のことです．\n\n相変化のとき温度勾配が生じる\n露点（凝縮始め）と沸点（凝縮終わり）が一致しない\n\nという特徴が有ります．一方，温度勾配を生じないのが「共沸混合冷媒」(R507A)です．温度勾配の小さい「非共沸混合冷媒」は「共沸混合冷媒」に近い凝縮蒸発特性があるので「疑似共沸混合冷媒」(R410A と R404A)とも呼ばれたりします．\n\n\n\n\nフルオロカーボン冷媒の取り扱い\n\nフルオロカーボンは安定した冷媒で，毒性は低く，可燃性もないが酸欠の危険がある\n大気中で空気より重く，濡れると床面付近に滞留しやすい\n冷媒設備の全冷媒充填量(kg)を，冷媒を内蔵している機器を設置した最小室内陽席(m³)で除した値が，限界濃度以下であること\n圧力容器や配管の修理の際に，内部に残留ガスがないことを確かめること\n裸火や高温の物体に触れると，分解してフッ化水素やホスゲンなどの毒性の強いガスを生成する\nフルオロカーボン冷媒が濡れて滞留している室内に燃焼危惧があると不完全燃焼となり，一酸化炭素中毒のおそれがある\n\n\n\n\n\n\n\nTip限界濃度\n\n\n\n\n限界濃度とは，この濃度において湿疹や重大な障害を受けることなく，緊急の処置をとった上で，自らも避難できる程度の濃度\n\n\n\n\n\n蒸発器・凝縮器・圧縮機・膨張弁\n\n\n\n\n\n冷凍装置において，冷媒の蒸発潜熱を利用して物を冷却するには，冷媒と物とを直接接触させずに，冷却館内や容器内で冷媒を沸騰・蒸発させ．その壁（例: 配管壁）を介して冷却します．このような冷却管や容器で構成されたものを蒸発器といいます．\n熱吸収した冷媒蒸気を蒸発器から取り除かなれば，一定の蒸発温度を維持することができなくなってしまいます．そのため発生した冷媒蒸気を蒸発器から常に取り除かなければなりません．熱吸収した冷媒蒸気を捨て去ってもいいですが，経済的ではないのでどうにか再利用する方法を模索する必要が有ります．\n冷媒が沸騰・蒸発する温度（飽和温度）は圧力が下がるに伴って低下，逆に圧力上がると飽和温度も上昇します．この性質を活用し，蒸発器内で発生した蒸気に対して圧力を加える + 周囲（例: 外気温）から得られる外気や水で冷却（=潜熱を開放）して再び液化します．このように冷媒は装置内を蒸発，圧力上昇，液化，膨張，再蒸発といった状態変化を繰り返しながら循環し，目的の冷凍作用を行います． この過程のことを冷凍サイクルと呼びます．\n📘 REMARKS\n\n\n\n\n\n\n\n\n構成要素\n説明\n\n\n\n\n蒸発器\n低圧の液体冷媒が熱を吸収して蒸発し，周囲から熱を奪うことで冷却を行う熱器\n\n\n圧縮機\n蒸気が凝縮する圧力まで高めるために用いられる機器．空調機のの消費電力の約８割を占める\n\n\n凝縮器\n高圧・高温の冷媒蒸気を冷却し，凝縮させる伝熱管や容器で構成された機器\n\n\n膨張弁\n圧力が高い凝縮器と圧力が低い蒸発器を結び通路の弁．凝縮した高圧の冷媒液を，低圧の蒸発器で蒸発した量だけ弁を調整して補給することで，蒸発器内を一定の低い圧力に保つ\n\n\n\n\n\n\n\n\n\n\n\n\nph線図における点\n冷媒状態\n\n\n\n\n1\n蒸発器をでて圧縮機に吸入される冷媒ガスは乾燥飽和蒸気より少し過熱された過熱蒸気（低圧）\n\n\n2\n圧縮機から吐出され，凝縮器に入る冷媒蒸気はかなり温度の高い過熱蒸気（高圧）\n\n\n5\n凝縮器で飽和液が少し過冷却され，膨張弁に入る過冷却液（高圧）\n\n\n6\n膨張弁を通って減圧され，蒸発器に入る湿り蒸気（低圧）\n\n\n\n\n\n\n\n\n\n\n\n\nTip潜熱とウォームコア\n\n\n\n気体から液体に戻るとき，潜熱が開放されて周囲を温めます．身の回りの例として，台風の中心には強い上昇気流があり，それによって空気に含まれている水蒸気が上空に運ばれてと飽和し，そこで凝結（雲の状態へ）します．このとき潜熱を放出するので，台風中心の上空の空気は，その周りの平均気温よりも高くなっています．\n\n\n\n台風の温度偏差の鉛直断面図\n\n\n上の図はx軸が台風の中心からの距離，y軸が高度及び気圧を指しています．等高線みたいな線は気候学的な高度別平均気温との差（温度偏差）をplotしています．"
  },
  {
    "objectID": "posts/2025-06-11-heatpump-lecture-01/index.html#蒸発器と凝縮器におけるエンタルピー変化",
    "href": "posts/2025-06-11-heatpump-lecture-01/index.html#蒸発器と凝縮器におけるエンタルピー変化",
    "title": "冷凍サイクルとヒートポンプの基礎",
    "section": "蒸発器と凝縮器におけるエンタルピー変化",
    "text": "蒸発器と凝縮器におけるエンタルピー変化\n理論冷凍サイクルにおいて，冷媒の蒸発及び凝縮は圧力一定のもとで行われます．比エンタルピー変化が\n\\[\ndh = dq + vdp\n\\]\nであるので，圧力一定であるので \\(dp=0\\) であることから\n\\[\ndh = dq\n\\]\nつまり，授受した熱量に相当する分だけ比エンタルピーが変化することがわかります．"
  },
  {
    "objectID": "posts/2025-06-11-heatpump-lecture-01/index.html#冷凍装置の効率係数",
    "href": "posts/2025-06-11-heatpump-lecture-01/index.html#冷凍装置の効率係数",
    "title": "冷凍サイクルとヒートポンプの基礎",
    "section": "冷凍装置の効率係数",
    "text": "冷凍装置の効率係数\n圧縮機の仕事量\n圧縮機に流出入する冷媒1kgが保有するエネルギーは，運動エネルギーや位置エネルギーが十分小さく無視できるとすると以下のように表せます\n\\[\n\\underbrace{h}_{\\text{比エンタルピー}} = \\underbrace{u}_{\\text{内部エネルギー}} + \\underbrace{p\\nu}_{\\text{冷媒流動の仕事}}\n\\]\n\n\\(h\\): 流動する冷媒の保有エネルギー [kJ/kg]\n\\(u\\): 物体を構成している膨大な数の分子・原子のもつエネルギーの総和として，物体内に蓄えられているエネルギー\n\n熱エネルギーと分子・原子などの平均配置を決める相互作用エネルギー\n\n\\(p\\): 圧力\n\\(\\nu\\): 比体積(冷媒蒸気1kgの体積) [\\(m^3\\)/kg]\n\nしたがって，以下のように変数を整理すると\n\n\\(q_m\\) [kg/s] : 圧縮機に単位時間に流出入する冷媒流量\n\\(h_1\\): 圧縮機入口の冷媒の比エンタルピー\n\\(h_2\\): 圧縮機出口の冷媒の比エンタルピー\n\n圧縮機によって冷媒に加えられる単位時間あたりの圧縮仕事 \\(P\\) [kW] は以下のように表すことができます\n\\[\nP = q_m(h_2 - h_1)\n\\]\n蒸発器の熱交換量\n蒸発器においては，冷媒は熱を組み上げ，その量だけ保有エネルギーが増大します．冷媒 1kg あたりが組み上げる熱量(冷凍効果)[kJ/kg]を \\(r\\) とすると\n\n\\(h_1\\): 蒸発器出口の冷媒の比エンタルピー\n\\(h_6\\): 入口の比エンタルピー\n\nを用いて，\n\\[\nr = h_1 - h_6\n\\]\nまた，単位時間あたりの交換熱量 \\(\\Phi_o\\) は\n\\[\n\\Phi_o = q_m(h_6 - h_1)\n\\]\nつまり，冷凍装置の冷凍能力は，蒸発器出入り口における冷媒の比エンタルピー差に冷媒循環量を乗じて求められることになります．\n凝縮器の熱交換量\n凝縮器では冷媒は熱放出し，その単位時間あたりの放出熱量 \\(\\Phi_k\\) [kW] を凝縮負荷と呼びます．\n\n\\(h_2\\): 凝縮器入口の冷媒比エンタルピー\n\\(h_5\\): 凝縮器出口の冷媒比エンタルピー\n\nより\n\\[\n\\Phi_k = q_m(h_2 - h_5)\n\\]\n\n\n\n\n\n\nTip膨張弁\n\n\n\n膨張弁では基本的に外部と熱交換を行いません．高圧・高温の液冷媒を断熱膨張を通して低圧・低温の液冷媒に変えるのが主な機能です． 冷媒液が圧力降下するときに，液の一部が自己蒸発する際の潜熱によって，冷媒自身の温度が下がります．\n\n\n\n熱力学第一法則(エネルギー保存則)\n単位時間あたりに冷凍装置に入るすべてのエネルギーは，単位時間あたりに装置から出るすべてのエネルギーと等しくなければなりません．ここから次の式が成立します:\n\\[\n\\Phi_k = \\Phi_o + P\n\\]\n\n\n\n蒸気圧圧縮式冷凍装置の熱収支\n\n\n\nDefinition 2 (冷凍サイクルの成績係数) \n冷凍作用を行うのに必要なエネルギー \\(P\\) と冷凍能力 \\(\\Phi_o\\) の比を冷凍サイクルの成績係数(\\(COP_c\\))といい\n\\[\nCOP_c = \\frac{\\Phi_o}{P}\n\\]\nこの値は同じ冷凍装置であっても，運転条件によって変わります．\n\n冷凍サイクルの成績係数が大きいほど小さい動力で大きな冷凍能力が得られると解釈できます．\n\n\n\n\n\n\nTip実際の機器における圧縮機仕事\n\n\n\n実際の圧縮機では，\n\n吸い込み弁と吐出し便の流れの抵抗\n吸い込み蒸気とシリンダ壁との間の熱交換\n蒸発器直後の連絡配管圧力損失\n機械的摩擦損失動力\n\nといった要因により理論断熱圧縮動力以上の圧縮動力を必要とします．つまり\n\\[\nP = P_c + P_m\n\\]\n\n\\(P\\): 実際の圧縮機の駆動に必要な動力\n\\(P_c\\): 蒸気の圧縮に用いられる圧縮動力\n\\(P_m\\): 機械的摩擦損失動力の和\n\n一般に機械効率 \\(\\displaystyle \\frac{P_c}{P}\\) は0.8~0.9 とされます．\n\n\n\n\nヒートポンプ\n\nDefinition 3 (ヒートポンプ) \n冷媒を凝縮するために凝縮器で熱量 \\(\\Phi_k\\) を放熱しているが，これを暖房やその他の加熱源として利用する装置をヒートポンプ装置と呼び，そのサイクルをヒートポンプサイクルという．\n\n「冷媒の流れ方向自体は同じだが，吸熱と放熱の役割が冷凍機と逆になる．つまり，蒸発器で吸収した熱を暖房として利用するのがヒートポンプである」点に注意してください．\nヒートポンプサイクルの成績係数 \\(COP_h\\) は\n\\[\n\\begin{align}\nCOP_h\n  &= \\frac{\\Phi_k}{P}\\\\\n  &= \\frac{\\Phi_o + P}{P}\\\\\n  &= COP_c + 1\n\\end{align}\n\\]\nこの式より，ヒートポンプサイクルの成績係数は，同じ温度条件の冷凍サイクルの成績係数よりも１だけかならず大きい値になることがわかります．\n\n\n製品としての能力\n実際のエアコンなどの空調機器の「能力」は，単に冷媒回路が移動する熱量（冷却や加熱）だけでなく，室内ファンなどの補助的な消費電力の影響も加味して評価されることがあります\n\\[\n\\begin{align}\n\\text{冷房能力} &= \\Phi_0 - \\text{室内ファン消費電力}\\\\\n\\text{暖房能力} &= \\Phi_k + \\text{室内ファン消費電力}\n\\end{align}\n\\]"
  },
  {
    "objectID": "posts/2025-06-11-heatpump-lecture-01/index.html#理解度チェック問題",
    "href": "posts/2025-06-11-heatpump-lecture-01/index.html#理解度チェック問題",
    "title": "冷凍サイクルとヒートポンプの基礎",
    "section": "📘 理解度チェック問題",
    "text": "📘 理解度チェック問題\n\nExercise 1 \n容器に入った20℃の水8kgに，0℃の氷3.0kgを入れて放置した．容器は断熱されており，熱容量は無視できるとして，平衡状態の容器内の温度と容器内の氷の質量を求めよ．水の比熱を4.19kJ/(kg·K)，氷の融解潜熱を334kJ/kgとする．\n\n\n\n\n\n\n\nNoteSolution\n\n\n\n\n\n条件\n\n\n\n項目\n値\n\n\n\n\n水の質量\n\\(8.0 \\, \\text{kg}\\)\n\n\n水の初温\n\\(20^\\circ\\text{C}\\)\n\n\n氷の質量\n\\(3.0 \\, \\text{kg}\\)\n\n\n氷の初温\n\\(0^\\circ\\text{C}\\)\n\n\n水の比熱\n\\(4.19 \\, \\text{kJ/(kg·K)}\\)\n\n\n氷の融解熱\n\\(334 \\, \\text{kJ/kg}\\)\n\n\n\n水を0℃まで冷やすのに必要な熱量の計算\n\\[\n\\begin{align}\nQ_{water}\n  &= (20 - 0) \\text{K} \\times 4.19 \\text{kJ/kg·K} \\times 8 \\text{kg}\\\\\n  &= 670.4\\text{kJ}\n\\end{align}\n\\]\n氷が全て溶けるのに必要な熱量\n\\[\n\\begin{align}\nQ_{ice}\n  &= 334\\text{kJ/kg} \\times 3.0\\text{kg}\\\\\n  &= 1002\\text{kJ}\n\\end{align}\n\\]\nthen, \\(Q_{ice} &gt; Q_{water}\\) のため，氷がすべて溶け切ることはないことがわかります．\nどれくらいの氷が残るのか？\n水を0℃まで冷やすのに使用される氷の質量は\n\\[\n\\frac{Q_{water}}{\\text{氷の融解熱}} = \\frac{670.4\\text{kJ}}{334\\text{kJ/kg}} \\approx 2.007\\text{kg}\n\\]\nしたがって，平衡状態の容器内の温度と容器内の氷の質量は温度＝0℃，氷の質量＝0.993kgとなる．\n\n\n\n\nExercise 2 \n次の記述の内，正しいものを選べ\n\n冷凍装置では，蒸発器で取り入れた熱と凝縮器で放出する熱量は等しい\n蒸気圧縮冷凍装置の冷却能力は，圧縮機に加えるエネルギーに等しい\n吸収冷凍装置の駆動源は熱であり，これを再生器に加えることにより低温を得る\n蒸気圧縮ヒートポンプでは，装置内を循環する冷媒の流れ方向が冷凍サイクルのそれと逆方向になる\n蒸気圧縮ヒートポンプの成績係数は，同じ温度条件での冷凍サイクルの成績係数より１だけ大きい．\n冷凍サイクルの成績係数は，蒸発温度や凝縮温度には関係しない\nヒートポンプの成績係数の値は常に1より大きい\n冷凍装置における冷凍能力は，各機器への熱の出入り前後の比エンタルピーがわかれば計算できる\n吸収冷凍機では，圧縮機を使用せずに，吸収器・発生器(再生器)・溶液ポンプなどを用いて冷媒を循環させ，冷熱を得る\n蒸発温度と凝縮温度などの運転条件が同じでも，理論冷凍サイクルCOPに比べ，実際の装置におけるCOPは小さくなる\n理論ヒートポンプサイクルでは，圧縮機で理論断熱圧縮動力を消費して，この圧縮動力に相当する熱と，蒸発器で取り入れた熱が冷媒に加わって凝縮負荷となり，凝縮器から放出される熱を利用する\n\n\n\n\n\n\n\n\nNoteSolution\n\n\n\n\n\nc, e, g, i, j, k\n\n\n\n\nExercise 3 凝縮器について\n次の記述の内，正しいものを選べ\n\n理論凝縮負荷は冷凍能力に理論断熱圧縮動力を加えて求めることができる\n\n\n\n\n\n\n\n\nNoteSolution\n\n\n\n\n\na,\n\n\n\n\nExercise 4 圧縮機について\n次の記述の内，正しいものを選べ\n\n二段圧縮冷凍装置は，一般に，低段圧縮機から出た冷媒ガスを一度冷却しているので，高段圧縮機の吐出しガスの温度が高くならないこと，また，圧縮機の損失を減らすことができ，圧縮機効率の低下を防ぐことができる．\n理論断熱圧縮動力が同じ場合，圧縮機の全断熱効率が大きくなると，実際の圧縮機の駆動軸動力は小さくなる\n圧縮機から吐出され，凝縮器に入る冷媒蒸気はかなり温度の高い過熱蒸気（高圧）\n蒸発器をでて圧縮機に吸入される冷媒ガスは乾燥飽和蒸気より少し過熱された過熱蒸気（低圧）\n\n\n\n\n\n\n\n\nNoteSolution\n\n\n\n\n\na, b, c, d\n\n\n\n\nExercise 5 \n次の記述のうち，冷媒について正しいものを選べ\n\n冷媒の蒸発潜熱は冷媒の種類関係なく一定である\n同じ温度のもとでは，標準沸点の低い冷媒ほど圧力は高くなる\n蒸気圧縮冷凍装置では，冷媒の蒸発の潜熱を利用して冷却作用を行う\nR 404A は共沸混合冷媒である\n一般に，HFC冷媒は，HCFC冷媒と比べると誘電率が大きく，その電気絶縁性がやや劣る\n一般に，アンモニア冷媒液は冷凍機油より比重が小さく，フルオロカーボン冷媒液は冷凍機油よりも比重が大きい\nフルオロカーボンの冷凍効果はアンモニアに比べ著しく大きいので，冷媒として広く用いられている\nアンモニアの標準沸点はR22の標準沸点より高い\nR134a冷媒は，塩素原子を含む\n装置から漏洩した冷媒ガスは，フルオロカーボンの場合には床面近くに，アンモニアは天井近くに滞留しやすい\n非共沸混合冷媒では，液と蒸気が共存する二相域において，液の組成と蒸気の組成は異なる\n\n\n\n\n\n\n\n\nNoteSolution\n\n\n\n\n\nb, c, e, f, h, j, k\n\n\n\n\nExercise 6 \n冷凍能力 4.5 kWの冷凍装置があり，圧縮機の消費動力は 1.5 kWである．この装置の凝縮器で放出される熱量 [kW] はいくらか．また，この装置の冷凍サイクル成績係数はいくらか？\n\n\n\n\n\n\n\nNoteSolution\n\n\n\n\n\n凝縮器で放出される熱量(凝縮負荷) \\(\\Phi_k\\) は\n\\[\n\\Phi_k = 4.5 \\text{kW}  + 1.5 \\text{kW}= 6 \\text{kW}\n\\]\n成績係数 \\(COP_c\\) は\n\\[\nCOP_c = \\frac{4.5 \\text{kW}}{1.5 \\text{kW}} = 3\n\\]"
  },
  {
    "objectID": "posts/2025-06-11-heatpump-lecture-01/index.html#appendix",
    "href": "posts/2025-06-11-heatpump-lecture-01/index.html#appendix",
    "title": "冷凍サイクルとヒートポンプの基礎",
    "section": "Appendix",
    "text": "Appendix\n\n数値目安\n\n\nCode\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\n\n# read data\ndf = pd.read_csv(\"./r134_property.csv\")\nenthalpy = df['steam_enthalpy'] - df['liquid_enthalpy']\n\n# plot temperature and pressure(mPa)\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(14, 6))\n\n# Set plot background color\nfig.patch.set_facecolor('#EFF5F5')\nfig.suptitle('R-134a Temperature vs Vapor Pressure', fontsize=16) # Overall title\n\nax1.plot(\n    df[\"temperature\"],    # X-axis: Vapor Pressure\n    df[\"Mpa\"],  # Y-axis: Temperature\n    color='black',\n    linestyle='solid', # Equivalent to 'dot' dash in Plotly\n    # marker='o',    # Add markers\n    markersize=4,  # Adjust marker size as desired\n    label='R-134a Vapor Pressure' # Optional: Add a label for legend\n)\n\nax2.plot(\n    df[\"temperature\"],    # X-axis: Vapor Pressure\n    enthalpy,  # Y-axis: kj/kg\n    color='black',\n    linestyle='solid', # Equivalent to 'dot' dash in Plotly\n    # marker='o',    # Add markers\n    markersize=4,  # Adjust marker size as desired\n    label='R-134a Vapor Pressure' # Optional: Add a label for legend\n)\n\n# Set axis 1 titles\nax1.set_title(\"R-134a Temperature vs. Vapor Pressure\")\nax1.set_xlabel(\"Temperature (°C)\")\nax1.set_ylabel(\"Vapor Pressure (Mpa)\")\nax1.grid(True, which='both', color='#DDEEEF', linestyle='-', linewidth=0.5)\nax1.set_axisbelow(True)\n\n# Set axis 2 titles\n# ax2.set_yscale('log')\nax2.grid(True, which='both', color='#DDEEEF', linestyle='-', linewidth=0.5)\nax2.set_axisbelow(True)\nax2.set_xlabel(\"Temperature (°C)\")\nax2.set_ylabel(\"latent heat(kJ/kg)\") # Indicate log scale in label\nax2.set_title(\"Temperature vs Latent heat\")\n\n\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n内部エネルギーとは？\n\nDefinition 4 内部エネルギー\n物体の内部の分子運動による運動エネルギーと，分子間力によるポテンシャルエネルギーを，内部エネルギーと呼ぶ\n\n内部エネルギーは，物体内部の分子の運動エネルギーと分子間力によるポテンシャルエネルギーから構成されます．運動エネルギーを \\(E_k\\), ポテンシャルエネルギーを \\(E_p\\) とすると\n\\[\n\\begin{align}\nU\n  &= \\sum_N(\\text{分子の}E_k) + \\sum_N(\\text{分子間力による}E_p)\\\\\n  &= \\sum_N\\left(\\frac{1}{2}mv^2 + \\epsilon\\right) + \\sum_N(\\text{分子間力による}E_p)\\\\\n  &= \\sum_N\\left(\\frac{1}{2}m\\overline{v}^2 + \\epsilon\\right) + \\sum_N(\\text{分子間力による}E_p)\n\\end{align}\n\\]\n\n\\(\\displaystyle\\frac{1}{2}m\\overline{v}^2\\) は分子1個の並進運動（分子が回転しない運動）の平均運動エネルギー\n\\(\\epsilon\\): 内部運動の運動エネルギー，H₂などの二原子分子やH₂O多原子分子の回転運動，または分子間距離の伸縮による振動運動"
  },
  {
    "objectID": "posts/2025-06-11-heatpump-lecture-01/index.html#references",
    "href": "posts/2025-06-11-heatpump-lecture-01/index.html#references",
    "title": "冷凍サイクルとヒートポンプの基礎",
    "section": "References",
    "text": "References\n\nうるるとさらら Rシリーズカタログ\n熱力学第1法則と第2法則\n高校生から味わう理論物理入門 &gt; 気体の内部エネルギーの意味と公式，求め方"
  },
  {
    "objectID": "posts/2022-08-11-difference-in-shebang/index.html",
    "href": "posts/2022-08-11-difference-in-shebang/index.html",
    "title": "[過去ブログからの転記] Shebangにおける /bin/bash と /usr/bin/bash の違い",
    "section": "",
    "text": "Definition 1 shebang\nシェルスクリプトの１行目は#!で始まり，その後にプログラムを解釈実行するインタプリタのパスを書く． これをshebangと呼ぶ．\n\nshebangと言語\n\n\n\n\nインタプリタ\n記法\n\n\n\n\nBourne shell\n#!/bin/sh\n\n\nbash\n#!/bin/bash\n\n\nperl\n#!/usr/bin/perl\n\n\npython\n#!/usr/bin/python\n\n\n\n\n\n\n\n\n\n\nNoteシェルスクリプト実行と必要権限\n\n\n\n\nバイナリ形式のファイルは実行権限のみで実行できるが，シェルスクリプトの場合は実行権限 + 読み込み権限が必要\nbash &lt;script-path&gt; とすれば読み込み権限のみで実行可能\n\n\n\n\n\nshebangでインタプリタを設定する方法は色々ありますが，\n\n#!/bin/bash\n#!/usr/bin/bash\n\nというパターンをみることがあります (前者のほうがメジャーですが)．\n$ which bash\n/usr/bin/bash\nなので，terminal上で実行するシェルと起動を合わせようと思うと後者のほうが良さそうですが，どちらも実行可能な場合，Linuxにおいては２つの間に挙動上の差はありません．\n/bin/は/usr/binと実体は同じ\nls -il で /bin/bash と /usr/bin/bash を比較してみると同じi-node番号なので挙動上差がない事がわかります\n$ ls -li /usr/bin/bash /bin/bash\n32768586 -rwxr-xr-x 1 root root 1446024 Mar 31  2024 /bin/bash*\n32768586 -rwxr-xr-x 1 root root 1446024 Mar 31  2024 /usr/bin/bash*\nLinux環境ならば /bin/bash と /usr/bin/bash どちらもbashをインタプレタとして利用できますが，Macとかだと\n% which bash\nbin/bash\nで/usr/bin/bashが存在しないケースがあります．そのため，一般的には #!/bin/bash のほうが好ましいといえます."
  },
  {
    "objectID": "posts/2022-08-11-difference-in-shebang/index.html#shebangとは",
    "href": "posts/2022-08-11-difference-in-shebang/index.html#shebangとは",
    "title": "[過去ブログからの転記] Shebangにおける /bin/bash と /usr/bin/bash の違い",
    "section": "",
    "text": "Definition 1 shebang\nシェルスクリプトの１行目は#!で始まり，その後にプログラムを解釈実行するインタプリタのパスを書く． これをshebangと呼ぶ．\n\nshebangと言語\n\n\n\n\nインタプリタ\n記法\n\n\n\n\nBourne shell\n#!/bin/sh\n\n\nbash\n#!/bin/bash\n\n\nperl\n#!/usr/bin/perl\n\n\npython\n#!/usr/bin/python\n\n\n\n\n\n\n\n\n\n\nNoteシェルスクリプト実行と必要権限\n\n\n\n\nバイナリ形式のファイルは実行権限のみで実行できるが，シェルスクリプトの場合は実行権限 + 読み込み権限が必要\nbash &lt;script-path&gt; とすれば読み込み権限のみで実行可能\n\n\n\n\n\nshebangでインタプリタを設定する方法は色々ありますが，\n\n#!/bin/bash\n#!/usr/bin/bash\n\nというパターンをみることがあります (前者のほうがメジャーですが)．\n$ which bash\n/usr/bin/bash\nなので，terminal上で実行するシェルと起動を合わせようと思うと後者のほうが良さそうですが，どちらも実行可能な場合，Linuxにおいては２つの間に挙動上の差はありません．\n/bin/は/usr/binと実体は同じ\nls -il で /bin/bash と /usr/bin/bash を比較してみると同じi-node番号なので挙動上差がない事がわかります\n$ ls -li /usr/bin/bash /bin/bash\n32768586 -rwxr-xr-x 1 root root 1446024 Mar 31  2024 /bin/bash*\n32768586 -rwxr-xr-x 1 root root 1446024 Mar 31  2024 /usr/bin/bash*\nLinux環境ならば /bin/bash と /usr/bin/bash どちらもbashをインタプレタとして利用できますが，Macとかだと\n% which bash\nbin/bash\nで/usr/bin/bashが存在しないケースがあります．そのため，一般的には #!/bin/bash のほうが好ましいといえます."
  },
  {
    "objectID": "posts/2022-08-11-difference-in-shebang/index.html#インタプリタの種類",
    "href": "posts/2022-08-11-difference-in-shebang/index.html#インタプリタの種類",
    "title": "[過去ブログからの転記] Shebangにおける /bin/bash と /usr/bin/bash の違い",
    "section": "インタプリタの種類",
    "text": "インタプリタの種類\n\n\n\n\n\n\nNoteTL:DR;\n\n\n\nインタプリタの種類は本質的には以下の２種類\n\nどのインタプリタが実行するか\n子プロセス（サブシェル）か，現在のシェルか\n\n\n\n\n\n方法\n子プロセス\nshebang\n環境への影響\n\n\n\n\n./hello.sh\nあり\n読む\n影響なし\n\n\nbash hello.sh\nあり\n読まない\n影響なし\n\n\nsource hello.sh\nなし\n読まない\n影響あり\n\n\n. hello.sh\nなし\n読まない\n影響あり\n\n\n\n\n\n\nカレントディレクトリにhello.shという以下のファイルを作成したとします.\n#!/bin/bash\n\necho 'Hello World!'\ndate\nこのhello.shの実行方法として以下の4つがあります:\n## (1) shebangのインタプリタを利用\n$ ./hello.sh\n\n## (2) ユーザー指定でbash インタプリタを使用（shebangは読まない）\n$ bash ./hello.sh\n\n## (3) 自身のシェルをインタプリタとして使用（shebangは読まない）\n$ source ./hello.sh\n\n## (4) 自身のシェルをインタプリタとして使用（shebangは読まない）\n$ . ./hello.sh\n(1) ./hello.sh\n\n\n\n\n\nsequenceDiagram\n    participant A as シェル\n    participant B as bash\n    participant C as hello.sh\n\n    A-&gt;&gt;C: カーネルがインタプリタの読み取り\n    A-&gt;&gt;B: shebangに従い&lt;br&gt;子シェルを起動\n    B-&gt;&gt;C: スクリプトの読み込み&lt;br&gt;と実行\n\n\n\n\n\n\n(2) bash ./hello.sh\n\n\n\n\n\nsequenceDiagram\n    participant A as シェル\n    participant B as bash\n    participant C as hello.sh\n\n    A-&gt;&gt;B: インタプリタを起動\n    B-&gt;&gt;C: スクリプトの読み込み&lt;br&gt;と実行\n\n\n\n\n\n\n(3) source ./hello.sh 及び (4) . ./hello.sh\n\n\n\n\n\nsequenceDiagram\n    participant A as シェル\n    participant C as hello.sh\n\n    A-&gt;&gt;C: スクリプトの読み込み&lt;br&gt;と実行"
  },
  {
    "objectID": "posts/2025-06-15-polytropic/index.html",
    "href": "posts/2025-06-15-polytropic/index.html",
    "title": "断熱圧縮とポリトロープ変化",
    "section": "",
    "text": "理論冷凍サイクルでは可逆断熱圧縮（平衡状態を維持しながらの断熱圧縮）として扱われますが，実際には圧縮機において圧縮中の冷媒上記には熱の出入りがあります． また，圧縮機頭部を冷却し，圧縮中に加熱した冷媒ガスから積極的に熱を除去することもあり，これらの圧縮をポリトロープ圧縮と呼びます．\n\n\n\n\\(c_p\\): 定圧比熱 [kJ/(kg\\(\\cdot\\)K)]\n\\(c_p\\): 定容比熱 [kJ/(kg\\(\\cdot\\)K)]\n\nとして理想気体の \\(c_v, c_p\\) の関係をまず考えてみます．理想気体の状態方程式より\n\\[\npv = RT\n\\]\nこれは状態式なので全微分すると\n\\[\npdv + vdp = Rdt\n\\]\nこれを用いて比エンタルピ変化を考えると\n\\[\n\\begin{align}\ndh\n  &= du + pdv + vdp\\\\\n  &= du + RdT\n\\end{align}\n\\]\n理想気体を仮定しているので\n\\[\n\\begin{align}\ndu &= c_vdT\\\\\ndh &= c_pdT\n\\end{align}\n\\]\n従って，\n\\[\nc_pdT = c_vdT + RdT\n\\]\n両辺をdTで除して整理すると\n\\[\nc_p - c_v = R\n\\]\nここで比熱比 \\(\\kappa\\) を次のように定義する\n\\[\n\\frac{c_p}{c_v} = \\kappa\n\\]\n整理すると\n\\[\n\\begin{align}\nc_p &= \\frac{\\kappa R}{\\kappa - 1}\\\\\nc_v &= \\frac{R}{\\kappa - 1}\n\\end{align}\n\\]\nポワソン公式の導出\n断熱圧縮では \\(dq = 0\\) であるので，理想気体では\n\\[\n\\begin{align}\n&c_vdT + pdv = 0\\\\\n&\\Rightarrow dT = -\\frac{pdv}{c_v}\n\\end{align}\n\\]\n理想気体の状態方程式を微分すると\n\\[\npdv + vdp = RdT\n\\]\nこれらを \\(dT\\) を消去する形で整理すると\n\\[\n\\begin{gather}\n\\frac{R + c_v}{c_v}pdv + vdp = 0\\\\\n\\Rightarrow \\frac{c_p}{c_v}pdv + vdp = 0\\\\\n\\Rightarrow \\kappa \\frac{dv}{v} = -\\frac{dp}{p}\n\\end{gather}\n\\]\nこれを積分すると\n\\[\npv^\\kappa = C \\label{eq-poisson}\n\\]\nこの断熱圧縮時の理想気体の可逆断熱圧縮時の圧力 \\(p\\) と比体積 \\(v\\) と \\(\\kappa\\) の関係をポアソンの公式と呼びます．\n温度と圧力で表したポアソンの公式\n\\(\\eqref{eq-poisson}\\) を理想気体の状態方程式を用いて変形すると\n\\[\n\\begin{align}\npv^\\kappa = p\\left(\\frac{RT}{p}\\right)^\\kappa = C\n\\end{align}\n\\]\n従って\n\\[\n\\frac{p^{(\\kappa-1)/\\kappa}}{T} = \\text{const}\n\\]\nとポアソンの公式を露わことができます．\n同様に \\(T\\) と \\(v\\) についてならば\n\\[\nTv^{\\kappa-1}= \\text{const}\n\\]\n断熱圧縮と状態変化\n圧縮機で断熱圧縮をした結果 \\(p_1 \\to p_2\\) まで変化したとします．このときの温度変化はポワソン公式より\n\\[\n\\frac{T_2}{T_1} = \\left(\\frac{p_2}{p_1}\\right)^{(\\kappa-1)/\\kappa} \\label{eq-compress-ratio}\n\\]\nつまり\n\n圧力比が大きいほど温度比も大きくなる\n比熱比が大きいほど温度比も大きくなる\n\n\n\n\n\n\n\nNote\n\n\n\n\n実際の圧縮機での冷媒蒸気の圧縮では圧縮機の機械的な摩擦による熱が冷媒に加わり，吐出しガス温度はより高くなる\nこの温度が高すぎると冷凍機油を劣化させ，圧縮機寿命に影響を及ぼしてしまう\n鉱油の冷凍機油の劣化温度は一般に120~130℃以上\n\n\n\n\nExample 1 CoolPropを用いた圧縮機吐出しガス温度の計算\n蒸発温度が -20℃，凝縮温度が 30℃，圧縮機吸い込み蒸気の加熱度が 5K のとき，圧縮機吸込み蒸気を凝縮圧力まで断熱圧縮した後の吐出しガス温度 \\(Td\\) をもとめてみます． 冷媒はR410Aとして，比熱比 \\(\\kappa = 1.28\\) で一定とする．\n圧縮機吸い込み温度 \\(T\\) は，\n\\[\nT = 273.15 + (-20) + 5 = 258.15\n\\]\n低い圧センサを \\(P_l\\), 高圧センサを \\(P_h\\) とすると \\(\\eqref{eq-compress-ratio}\\) より\n\\[\nTd = 258.15 \\times \\left(\\frac{P_h}{P_l}\\right)^{(\\kappa-1)/\\kappa}\n\\]\nよってまず，圧力比を取得します\n\n\nCode\nfrom CoolProp.CoolProp import PropsSI\n\nTe = 273.15 - 20   # 蒸発温度\nTc = 273.15 + 30\nfluid = 'R410A'  # 冷媒名\n\n# 飽和圧力（単位：Pa）を取得\nP_l = PropsSI('P', 'T', Te, 'Q', 0, fluid)\nP_h = PropsSI('P', 'T', Tc, 'Q', 0, fluid)\nP_ratio = P_h/P_l\n\nprint(f\"低圧圧力 = {P_l/1000000:.4f} MPa\")\nprint(f\"高圧圧力 = {P_h/1000000:.4f} MPa\")\nprint(f\"圧力比 = {P_ratio:.4f}\")\n\n\n低圧圧力 = 0.4007 MPa\n高圧圧力 = 1.8891 MPa\n圧力比 = 4.7148\n\n\n圧力比がわかったので実際に計算してみると\n\n\nCode\nTe = 273.15 + (-20) + 5 \nkappa = 1.28\n\nTd = Te * (P_ratio) ** ((kappa - 1)/kappa)\nprint(f\"圧縮機吹出しガス温度 = {Td:4f} K = {Td - 273.15:4f} ℃\")\n\n\n圧縮機吹出しガス温度 = 362.403188 K = 89.253188 ℃\n\n\n次に圧縮前後の比エンタルピ差を求めてみます．\n\\[\ndh = dq + vdp\n\\]\nであるので断熱圧縮時は \\(dq = 0\\) つまり\n\\[\n\\begin{align}\nh_2 - h_1\n  &= \\int^2_1 vdp\\\\\n  &= \\int^2_1 \\left(\\frac{C}{p}\\right)^{1/\\kappa}dp\\\\\n  &= \\frac{\\kappa}{\\kappa - 1}(p_2v_2 - p_1v_1) \\label{eq-compress-work}\n\\end{align}\n\\]"
  },
  {
    "objectID": "posts/2025-06-15-polytropic/index.html#圧縮機における断熱圧縮",
    "href": "posts/2025-06-15-polytropic/index.html#圧縮機における断熱圧縮",
    "title": "断熱圧縮とポリトロープ変化",
    "section": "",
    "text": "理論冷凍サイクルでは可逆断熱圧縮（平衡状態を維持しながらの断熱圧縮）として扱われますが，実際には圧縮機において圧縮中の冷媒上記には熱の出入りがあります． また，圧縮機頭部を冷却し，圧縮中に加熱した冷媒ガスから積極的に熱を除去することもあり，これらの圧縮をポリトロープ圧縮と呼びます．\n\n\n\n\\(c_p\\): 定圧比熱 [kJ/(kg\\(\\cdot\\)K)]\n\\(c_p\\): 定容比熱 [kJ/(kg\\(\\cdot\\)K)]\n\nとして理想気体の \\(c_v, c_p\\) の関係をまず考えてみます．理想気体の状態方程式より\n\\[\npv = RT\n\\]\nこれは状態式なので全微分すると\n\\[\npdv + vdp = Rdt\n\\]\nこれを用いて比エンタルピ変化を考えると\n\\[\n\\begin{align}\ndh\n  &= du + pdv + vdp\\\\\n  &= du + RdT\n\\end{align}\n\\]\n理想気体を仮定しているので\n\\[\n\\begin{align}\ndu &= c_vdT\\\\\ndh &= c_pdT\n\\end{align}\n\\]\n従って，\n\\[\nc_pdT = c_vdT + RdT\n\\]\n両辺をdTで除して整理すると\n\\[\nc_p - c_v = R\n\\]\nここで比熱比 \\(\\kappa\\) を次のように定義する\n\\[\n\\frac{c_p}{c_v} = \\kappa\n\\]\n整理すると\n\\[\n\\begin{align}\nc_p &= \\frac{\\kappa R}{\\kappa - 1}\\\\\nc_v &= \\frac{R}{\\kappa - 1}\n\\end{align}\n\\]\nポワソン公式の導出\n断熱圧縮では \\(dq = 0\\) であるので，理想気体では\n\\[\n\\begin{align}\n&c_vdT + pdv = 0\\\\\n&\\Rightarrow dT = -\\frac{pdv}{c_v}\n\\end{align}\n\\]\n理想気体の状態方程式を微分すると\n\\[\npdv + vdp = RdT\n\\]\nこれらを \\(dT\\) を消去する形で整理すると\n\\[\n\\begin{gather}\n\\frac{R + c_v}{c_v}pdv + vdp = 0\\\\\n\\Rightarrow \\frac{c_p}{c_v}pdv + vdp = 0\\\\\n\\Rightarrow \\kappa \\frac{dv}{v} = -\\frac{dp}{p}\n\\end{gather}\n\\]\nこれを積分すると\n\\[\npv^\\kappa = C \\label{eq-poisson}\n\\]\nこの断熱圧縮時の理想気体の可逆断熱圧縮時の圧力 \\(p\\) と比体積 \\(v\\) と \\(\\kappa\\) の関係をポアソンの公式と呼びます．\n温度と圧力で表したポアソンの公式\n\\(\\eqref{eq-poisson}\\) を理想気体の状態方程式を用いて変形すると\n\\[\n\\begin{align}\npv^\\kappa = p\\left(\\frac{RT}{p}\\right)^\\kappa = C\n\\end{align}\n\\]\n従って\n\\[\n\\frac{p^{(\\kappa-1)/\\kappa}}{T} = \\text{const}\n\\]\nとポアソンの公式を露わことができます．\n同様に \\(T\\) と \\(v\\) についてならば\n\\[\nTv^{\\kappa-1}= \\text{const}\n\\]\n断熱圧縮と状態変化\n圧縮機で断熱圧縮をした結果 \\(p_1 \\to p_2\\) まで変化したとします．このときの温度変化はポワソン公式より\n\\[\n\\frac{T_2}{T_1} = \\left(\\frac{p_2}{p_1}\\right)^{(\\kappa-1)/\\kappa} \\label{eq-compress-ratio}\n\\]\nつまり\n\n圧力比が大きいほど温度比も大きくなる\n比熱比が大きいほど温度比も大きくなる\n\n\n\n\n\n\n\nNote\n\n\n\n\n実際の圧縮機での冷媒蒸気の圧縮では圧縮機の機械的な摩擦による熱が冷媒に加わり，吐出しガス温度はより高くなる\nこの温度が高すぎると冷凍機油を劣化させ，圧縮機寿命に影響を及ぼしてしまう\n鉱油の冷凍機油の劣化温度は一般に120~130℃以上\n\n\n\n\nExample 1 CoolPropを用いた圧縮機吐出しガス温度の計算\n蒸発温度が -20℃，凝縮温度が 30℃，圧縮機吸い込み蒸気の加熱度が 5K のとき，圧縮機吸込み蒸気を凝縮圧力まで断熱圧縮した後の吐出しガス温度 \\(Td\\) をもとめてみます． 冷媒はR410Aとして，比熱比 \\(\\kappa = 1.28\\) で一定とする．\n圧縮機吸い込み温度 \\(T\\) は，\n\\[\nT = 273.15 + (-20) + 5 = 258.15\n\\]\n低い圧センサを \\(P_l\\), 高圧センサを \\(P_h\\) とすると \\(\\eqref{eq-compress-ratio}\\) より\n\\[\nTd = 258.15 \\times \\left(\\frac{P_h}{P_l}\\right)^{(\\kappa-1)/\\kappa}\n\\]\nよってまず，圧力比を取得します\n\n\nCode\nfrom CoolProp.CoolProp import PropsSI\n\nTe = 273.15 - 20   # 蒸発温度\nTc = 273.15 + 30\nfluid = 'R410A'  # 冷媒名\n\n# 飽和圧力（単位：Pa）を取得\nP_l = PropsSI('P', 'T', Te, 'Q', 0, fluid)\nP_h = PropsSI('P', 'T', Tc, 'Q', 0, fluid)\nP_ratio = P_h/P_l\n\nprint(f\"低圧圧力 = {P_l/1000000:.4f} MPa\")\nprint(f\"高圧圧力 = {P_h/1000000:.4f} MPa\")\nprint(f\"圧力比 = {P_ratio:.4f}\")\n\n\n低圧圧力 = 0.4007 MPa\n高圧圧力 = 1.8891 MPa\n圧力比 = 4.7148\n\n\n圧力比がわかったので実際に計算してみると\n\n\nCode\nTe = 273.15 + (-20) + 5 \nkappa = 1.28\n\nTd = Te * (P_ratio) ** ((kappa - 1)/kappa)\nprint(f\"圧縮機吹出しガス温度 = {Td:4f} K = {Td - 273.15:4f} ℃\")\n\n\n圧縮機吹出しガス温度 = 362.403188 K = 89.253188 ℃\n\n\n次に圧縮前後の比エンタルピ差を求めてみます．\n\\[\ndh = dq + vdp\n\\]\nであるので断熱圧縮時は \\(dq = 0\\) つまり\n\\[\n\\begin{align}\nh_2 - h_1\n  &= \\int^2_1 vdp\\\\\n  &= \\int^2_1 \\left(\\frac{C}{p}\\right)^{1/\\kappa}dp\\\\\n  &= \\frac{\\kappa}{\\kappa - 1}(p_2v_2 - p_1v_1) \\label{eq-compress-work}\n\\end{align}\n\\]"
  },
  {
    "objectID": "posts/2025-06-15-polytropic/index.html#ポリトロープ変化",
    "href": "posts/2025-06-15-polytropic/index.html#ポリトロープ変化",
    "title": "断熱圧縮とポリトロープ変化",
    "section": "ポリトロープ変化",
    "text": "ポリトロープ変化\n圧縮機での実際の圧縮では，\n\n吸い込み蒸気がシリンダ壁などで加熱\n圧縮ガスの熱が圧縮機壁を通って外部に放熱\n\nという現象が発生し，可逆断熱圧縮とはなりません．可逆断熱圧縮とならなくても圧力 \\(p\\) と比容積 \\(v\\) が以下のような指数関係で結ばれるような変化とみなせる，つまり\n\\[\npv^n = C\n\\]\nであるとき，これはポリトロープ変化(ポリトロープ圧縮)と呼びます．\n\nDefinition 1 ポリトロープ変化\n理想気体と見なせる気体について，圧力 \\(p\\) と比容積 \\(v\\) が以下のような指数関係で結ばれるような変化をポリトロープ変化という\n\\[\npv^n = C\n\\]\n\n\\(C\\): constant\n\\(n\\): ポリトロープ指数\n\n温度と圧力の能動的な同時操作を行えば，変化経路としては，どのような向きの経路でも取ることができると仮定される（=可逆的変化）\n\nポリトロープ変化と変化の種類\n\n\n\n\n\n\n\n\n\nポリトロープ指数\n対応状況\n変化\n\n\n\n\n\\(n=0\\)\n\\(p=C\\)\n等圧変化\n\n\n\\(n=1\\)\n\\(pv=C\\)\n等温変化\n\n\n\\(n=\\infty\\)\n\\(v=C\\)\n等積変化\n\n\n\\(n=\\kappa\\)\n\\(pv^\\kappa=C\\)\n断熱変化\n\n\n\n\n\nExample 2 \\(1 &lt; n &lt; \\kappa\\) のポリトロープ圧縮\n等温変化，断熱変化，ポリトロープ変化それぞれの場合のPV plotは以下のようになります．\n\n\nCode\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\ndef plot_pv_diagram():\n    # 理想気体の比熱比 (γ) を設定\n    # 断熱変化は PV^γ = const で表される\n    kappa = (\n        1.4  # 単原子分子理想気体の場合 5/3 = 1.67, 二原子分子理想気体の場合 7/5 = 1.4\n    )\n    poly = 1.2\n\n    # 点 1 の状態量\n    P1 = 2.0  # P軸のスケールに合わせて適当な値に調整\n    V1 = 1.0  # V軸のスケールに合わせて適当な値に調整\n    TA = P1 * V1  # PV = nRT なので、T は PV に比例すると考えられる\n\n    # 点 2 の状態量\n    P2 = np.linspace(P1, 7.0, 1000)\n    V2_adiabatic = V1 * (P1 / P2) ** (1 / kappa)\n    V2_poly = V1 * (P1 / P2) ** (1 / poly)\n    V2_iso = V1 * (P1 / P2)\n\n    # Matplotlibでプロット\n    plt.figure(figsize=(8, 6))\n\n    # 断熱変化の曲線 (AからB)\n    plt.plot(V2_adiabatic, P2, linewidth=2, label=\"adiabatic\")\n    plt.plot(V2_poly, P2, linewidth=2, label=\"polytropic\")\n    plt.plot(V2_iso, P2, linewidth=2, label=\"iso\")\n\n    # text labelの付与\n    plt.text(V2_poly[0], P2[0] + 0.1, '1', fontsize=12, ha='right')\n    plt.text(V2_poly[-1], P2[-1] * 1.01, '2\\'', fontsize=12, ha='right')\n\n\n    # 軸ラベルとタイトル\n    plt.xlabel(\"v\")\n    plt.ylabel(\"p\")\n    plt.title(\"PV plot\")\n    plt.legend()\n\n    # 軸の範囲を設定\n    plt.xlim(0, 1.2)\n    plt.ylim(0, 7.5)\n\n    # 凡例\n    # plt.legend() # 等温変化と断熱変化の凡例は曲線上に直接記述した方が見やすいかも\n\n    # グリッド\n    plt.grid(True, linestyle=\":\", alpha=0.6)\n\n    # 軸の目盛りとラベル\n    plt.yticks([P1, P2[-1]], [f\"P1\", f\"P2\"])\n\n    plt.tight_layout()\n    plt.show()\n\n\n# 関数を呼び出してグラフを表示\nplot_pv_diagram()\n\n\n\n\n\n\n\n\n\n冷媒を状態1から状態2’までポリトロープ圧縮した場合，圧縮の際に外部に熱が放出される場合の比エンタルピー変化は\n\\[\nh_2 - h_1 = q_{12} + \\int^2_1 vdp\n\\]\n断熱圧縮の場合は，\\(q_{12} = 0\\) であるから断熱圧縮仕事 \\(-l_{12}\\) は\n\\[\n-l_{12} = h_2 - h_1\n\\]\nポリトロープ圧縮仕事 \\(-l_{12'}\\) は\n\\[\n\\begin{align}\n-l_{12'}\n  &= -l_{12} + q_{12}\\\\\n  &= h_2 -h_1 + q_{12}\\\\\n  &= h_{2'} - h_1\n\\end{align}\n\\]\n\\(\\eqref{eq-compress-work}\\) より\n\\[\n\\begin{align}\n-l_{12} &= \\frac{\\kappa}{\\kappa - 1}(p_2v_2 - p_1v_1)\\\\\n-l_{1'2} &= \\frac{n}{n - 1}(p_{2'}v_{2'} - p_1v_1)\n\\end{align}\n\\]\n\n\n\n\n\n\nNote\n\n\n\n\n比熱比 \\(\\kappa\\), ポリトロープ指数 \\(n\\), 状態1と2の圧力 \\(p_1, p_2\\) がわかれば，圧縮後の比体積 \\(v_2, v_{2'}\\) がわかる\nPH線図では変化後の座標を等比体積線と圧力の交点として図示することができる\n\n\n\n\n\n\nExample 3 放熱量の計算\nR410A用の圧縮機で\n\n吸い込み蒸気の圧力 \\(p_1 = 0.40\\) MPa\n吸い込み蒸気の比体積が \\(v_1 = 0.07\\) m³/kg\n吐出し蒸気の圧力 \\(p_2 = 1.88\\) MPa\n比熱比 \\(\\kappa = 1.3\\)\n\nとします．ポリトロープ指数 \\(n=1.2\\) のポリトロープ圧縮仕事に成るためには，断熱圧縮仕事からどれくらいの熱量が放熱される必要があるか考えてみます．\n断熱圧縮後の比体積 \\(v_2\\) と断熱圧縮仕事 \\(-l_{12}\\) は\n\\[\n\\begin{align}\nv_2 &= v_1\\left(\\frac{p_1}{p_2}\\right)^{1/\\kappa}\\\\\n-l_{12} &= \\frac{\\kappa}{\\kappa-1}(p_2v_2 - p_1v_1)\n\\end{align}\n\\]\nポリトロープ圧縮後の比体積 \\(v_{2'}\\) と圧縮仕事 \\(-l_{12'}\\) は\n\\[\n\\begin{align}\nv_{2'} &= v_1\\left(\\frac{p_1}{p_{2'}}\\right)^{1/n}\\\\\n-l_{12'} &= \\frac{n}{n-1}(p_{2'}v_{2'} - p_1v_1)\n\\end{align}\n\\]\n熱量 \\(dq\\) は\n\\[\ndq = -l_{12'}  - (-l_{12})\n\\]\nこれをPythonで実装すると\n\n\nCode\ndef calculate_heat_released(p1_MPa, v1, p2_MPa, kappa, n):\n    \"\"\"\n    ポリトロープ圧縮過程で放出される熱量 dq [kJ/kg] を計算する\n    \n    Parameters:\n        p1_MPa (float): 吸い込み圧力 [MPa]\n        v1 (float): 吸い込み比体積 [m^3/kg]\n        p2_MPa (float): 吐出し圧力 [MPa]\n        kappa (float): 断熱比（比熱比）[-]\n        n (float): ポリトロープ指数 [-]\n    \n    Returns:\n        dq (float): 放熱量 [kJ/kg]\n        l12 (float): 断熱圧縮仕事 [kJ/kg]\n        l12p (float): ポリトロープ圧縮仕事 [kJ/kg]\n    \"\"\"\n    # 単位変換 MPa → Pa\n    p1 = p1_MPa * 1e6\n    p2 = p2_MPa * 1e6\n\n    # 断熱圧縮後の比体積 v2\n    v2 = v1 * (p1 / p2)**(1 / kappa)\n\n    # 断熱圧縮仕事 [J/kg → kJ/kg]\n    l12 = (kappa / (kappa - 1)) * (p2 * v2 - p1 * v1) / 1000\n\n    # ポリトロープ圧縮後の比体積 v2'\n    v2p = v1 * (p1 / p2)**(1 / n)\n\n    # ポリトロープ圧縮仕事 [J/kg → kJ/kg]\n    l12p = (n / (n - 1)) * (p2 * v2p - p1 * v1) / 1000\n\n    # 放熱量（断熱仕事との差）\n    dq = l12p - l12\n\n    return dq, l12, l12p\n\ndq, l12, l12p = calculate_heat_released(\n    p1_MPa=0.40,\n    v1=0.07,\n    p2_MPa=1.88,\n    kappa=1.3,\n    n=1.2\n)\n\nprint(f\"断熱圧縮仕事      : {-l12:.2f} kJ/kg\")\nprint(f\"ポリトロープ圧縮仕事: {-l12p:.2f} kJ/kg\")\nprint(f\"放出される熱量     : {dq:.2f} kJ/kg\")\n\n\n断熱圧縮仕事      : -52.08 kJ/kg\nポリトロープ圧縮仕事: -49.43 kJ/kg\n放出される熱量     : -2.65 kJ/kg"
  },
  {
    "objectID": "posts/2025-06-15-polytropic/index.html#理解度チェック",
    "href": "posts/2025-06-15-polytropic/index.html#理解度チェック",
    "title": "断熱圧縮とポリトロープ変化",
    "section": "📘 理解度チェック",
    "text": "📘 理解度チェック\n\nExercise 1 \n\\(10\\) kg の理想気体が \\(pv^{1.3} = C\\) に従って，圧力 \\(0.1\\) MPa, 温度 300K の初期状態から圧縮され，圧力 \\(2.7\\) MPa になったとする．このとき，\n\n圧縮後の気体の温度を求めよ \n\n\n\n\n\n\n\n\nNoteSolution\n\n\n\n\n\n圧縮後の気体の温度を求めよ\n理想気体の状態方程式より\n\\[\n\\frac{p_1v_1}{T_1} = \\frac{p_2v_2}{T_2}\n\\]\n\n\\(p_i\\): 状態 \\(i\\) の圧力\n\\(T_i\\): 状態 \\(i\\) の温度(K)\n\\(v_i\\): 状態 \\(i\\) の比容積\n\nこれを問題文に当てはめると\n\\[\n\\begin{align}\n& \\frac{0.1\\text{MPa}\\times v_1}{300} = \\frac{2.7\\text{MPa}\\times v_2}{T_2}\\\\\n&\\Rightarrow T_2 = \\frac{2.7}{0.1} \\times 300 \\times \\underbrace{\\frac{v_2}{v_1}}_{\\text{比容積比率}}\n\\end{align}\n\\]\n比容積比率はポリトロープ変化 \\(pv^{1.3} = C\\) より\n\\[\n\\frac{p_1}{p_2} = \\left(\\frac{v_2}{v_1}\\right)^{1.3}\n\\]\nしたがって，\n\\[\n\\frac{v_2}{v_1} = \\left(\\frac{1}{27}\\right)^{\\frac{1}{1.3}}\n\\]\nよってこれを計算すると\n\n\nCode\nimport numpy as np\n\nvolume_ratio = 27 ** (-10/13)\np_ratio = 27\nbase_temp = 300\n\nres_temp = volume_ratio * p_ratio * base_temp\nprint(f\"{res_temp:.2f}K\")\n\n\n641.85K"
  },
  {
    "objectID": "posts/2025-06-15-polytropic/index.html#appendix-coolprop",
    "href": "posts/2025-06-15-polytropic/index.html#appendix-coolprop",
    "title": "断熱圧縮とポリトロープ変化",
    "section": "Appendix: CoolProp",
    "text": "Appendix: CoolProp\n\n冷媒の飽和圧力（saturation pressure）の取得\nSyntax\n\n\nCode\nfrom CoolProp.CoolProp import PropsSI\n\nT = 273.15 + 5   # 飽和温度 [K]（例：5℃）\nfluid = 'R410A'  # 冷媒名\n\n# 飽和圧力（単位：Pa）を取得\nP_sat = PropsSI('P', 'T', T, 'Q', 0, fluid)\n\nprint(f\"飽和圧力 = {P_sat/1000000:.2f} MPa\")\n\n\n飽和圧力 = 0.94 MPa\n\n\n入力仕様\n\n\n\n\n引数\n内容\n\n\n\n\n'P'\n求めたいプロパティ（圧力）\n\n\n'T', T\n与える温度（[K]）\n\n\n'Q', 0\n品質（0: 飽和液体、1: 飽和蒸気）\n\n\nfluid\n冷媒名（例：‘R410A’, ‘R134a’）\n\n\n\n\n単一冷媒, 共沸冷媒では’Q’, 0 または ‘Q’, 1 のどちらでも、飽和温度においては同じ飽和圧力を返します\nR407Cのような温度勾配の大きい非共沸冷媒では異なる飽和圧力を返します"
  },
  {
    "objectID": "posts/2025-06-15-polytropic/index.html#references",
    "href": "posts/2025-06-15-polytropic/index.html#references",
    "title": "断熱圧縮とポリトロープ変化",
    "section": "References",
    "text": "References\n\n日本機械学会誌 &gt; 2020/3 閉じた系と開いた系の第一法則\nエントロピーとエンタルピー &gt; 工業仕事"
  },
  {
    "objectID": "posts/2025-09-04-bash-alias/index.html",
    "href": "posts/2025-09-04-bash-alias/index.html",
    "title": "シェルスクリプトにおけるAlias",
    "section": "",
    "text": "Aliasは，コマンド及びコマンドとオプションの組み合わせに別名をつける機能です． aliasおよびunalias組み込みコマンドを使用して，alias名と対応する値を設定・解除します．\nAliasの展開動作\n\nシェルが適切な位置で引用符で囲まれていない単語を読み取ると，その単語がalias名と一致するかをチェック\n一致する場合，シェルはその単語をalias値に置き換え，元の単語の代わりにその値を読み取ったかのように処理\n\nalias置換を試みるときに，単語の後に続く文字は確認しません．\nAliasの名前と置換テキストの制約\n\n名前の制約: /, $, `, =およびシェルのメタキャラクタや引用符文字をalias名に含めることはできません\n置換テキスト: 有効なシェル入力（メタキャラクタを含む）を含めることができます\n再帰的展開の防止: 置換テキストの最初の単語はaliasとしてテストされますが，展開中のaliasと同一の単語は2回展開されません．例えば，lsをls -Fにaliasしても，Bashは再帰的に展開しようとしません\n\n連続的なalias展開\n\nalias値の最後の文字が空白の場合，シェルはaliasに続く次のコマンド単語もalias展開の対象として確認します．\n\nAliasの制限\n\n引数の扱い: cshのように置換テキストに引数を使用するメカニズムはありません\n非対話モードでの展開: シェルが非対話モードの場合，shoptを使用してexpand_aliasesオプションを設定しない限り，aliasは展開されません\n\nAliasの定義と実行タイミング\n\naliasは，コマンドが実行される時ではなく，読み取られる時に展開されます\n同じ行に他のコマンドと一緒に記述されたalias定義は，シェルが次の入力行を読み取るまで有効になりません\n複合コマンド内のalias定義は，シェルが複合コマンド全体を解析・実行するまで有効になりません\nalias定義に続くその行のコマンドは，新しいaliasの影響を受けません\n\nAliasかどうかの確認\ntype コマンドは指定したコマンドが，バイナリなのか，エイリアスなのかなどの情報を示すコマンドです．\n$ type ls\nls is an alias for ls -F --color=auto --group-directories-first"
  },
  {
    "objectID": "posts/2025-09-04-bash-alias/index.html#aliasとは",
    "href": "posts/2025-09-04-bash-alias/index.html#aliasとは",
    "title": "シェルスクリプトにおけるAlias",
    "section": "",
    "text": "Aliasは，コマンド及びコマンドとオプションの組み合わせに別名をつける機能です． aliasおよびunalias組み込みコマンドを使用して，alias名と対応する値を設定・解除します．\nAliasの展開動作\n\nシェルが適切な位置で引用符で囲まれていない単語を読み取ると，その単語がalias名と一致するかをチェック\n一致する場合，シェルはその単語をalias値に置き換え，元の単語の代わりにその値を読み取ったかのように処理\n\nalias置換を試みるときに，単語の後に続く文字は確認しません．\nAliasの名前と置換テキストの制約\n\n名前の制約: /, $, `, =およびシェルのメタキャラクタや引用符文字をalias名に含めることはできません\n置換テキスト: 有効なシェル入力（メタキャラクタを含む）を含めることができます\n再帰的展開の防止: 置換テキストの最初の単語はaliasとしてテストされますが，展開中のaliasと同一の単語は2回展開されません．例えば，lsをls -Fにaliasしても，Bashは再帰的に展開しようとしません\n\n連続的なalias展開\n\nalias値の最後の文字が空白の場合，シェルはaliasに続く次のコマンド単語もalias展開の対象として確認します．\n\nAliasの制限\n\n引数の扱い: cshのように置換テキストに引数を使用するメカニズムはありません\n非対話モードでの展開: シェルが非対話モードの場合，shoptを使用してexpand_aliasesオプションを設定しない限り，aliasは展開されません\n\nAliasの定義と実行タイミング\n\naliasは，コマンドが実行される時ではなく，読み取られる時に展開されます\n同じ行に他のコマンドと一緒に記述されたalias定義は，シェルが次の入力行を読み取るまで有効になりません\n複合コマンド内のalias定義は，シェルが複合コマンド全体を解析・実行するまで有効になりません\nalias定義に続くその行のコマンドは，新しいaliasの影響を受けません\n\nAliasかどうかの確認\ntype コマンドは指定したコマンドが，バイナリなのか，エイリアスなのかなどの情報を示すコマンドです．\n$ type ls\nls is an alias for ls -F --color=auto --group-directories-first"
  },
  {
    "objectID": "posts/2025-09-04-bash-alias/index.html#aliasを一時的に解除する方法",
    "href": "posts/2025-09-04-bash-alias/index.html#aliasを一時的に解除する方法",
    "title": "シェルスクリプトにおけるAlias",
    "section": "Aliasを一時的に解除する方法",
    "text": "Aliasを一時的に解除する方法\n設定されているaliasを一時的に無効化してコマンドを実行したい場合，以下の方法があります：\n\n1. バックスラッシュを使用\n\\command\nlsがaliasされている場合\n\\ls\n\n\n2. commandコマンドを使用\ncommand command_name\nlsがaliasされている場合\ncommand ls"
  },
  {
    "objectID": "posts/2025-09-04-bash-alias/index.html#bash_aliasesファイル",
    "href": "posts/2025-09-04-bash-alias/index.html#bash_aliasesファイル",
    "title": "シェルスクリプトにおけるAlias",
    "section": ".bash_aliasesファイル",
    "text": ".bash_aliasesファイル\n\n.bash_aliasesは，ユーザーのホームディレクトリに配置される設定ファイルで，bashのalias定義を管理するために使用\n.bashrcファイルを直接編集せずにalias設定を整理するために使用\n\n\n\n\n\n\n\nNote.bash_aliasesの利点\n\n\n\n\n設定の分離: .bashrcとalias定義を分けることで，設定ファイルの管理が容易になる\n可読性の向上: alias定義を専用ファイルにまとめることで，設定を見つけやすくなる\nメンテナンス性: バックアップや他の環境への移行が簡単になる\n\n\n\n使用方法\n\n1. .bash_aliasesファイルの作成\n.bash_aliasesはデフォルトで存在しないため，必要に応じて作成する必要があります\ntouch ~/.bash_aliases\n\n\n2. .bashrcでの読み込み設定\n通常，.bashrcには以下のような記述が含まれており，.bash_aliasesが存在する場合は自動的に読み込まれます：\n# Alias definitions.\n# You may want to put all your additions into a separate file like\n# ~/.bash_aliases, instead of adding them here directly.\n\nif [ -f ~/.bash_aliases ]; then\n    . ~/.bash_aliases\nfi\n\n\n\n\n\n\nNote\n\n\n\n\n.bashrcに読み込みの記述がない場合は，手動で追加する必要があります\n\n\n\n\n\n3. aliasの定義例\n.bash_aliasesファイル内でaliasを定義します：\n# ディレクトリ操作\nalias ll='ls -alF'\nalias la='ls -A'\nalias l='ls -CF'\n\n# 安全な操作\nalias rm='rm -i'\nalias cp='cp -i'\nalias mv='mv -i'\n\n# よく使うコマンド\nalias ..='cd ..'\nalias ...='cd ../..'\nalias grep='grep --color=auto'\n\n\n4. 設定の反映\naliasを追加・変更した後，以下のコマンドで設定を反映します：\nsource ~/.bash_aliases\nまたは\nsource ~/.bashrc"
  },
  {
    "objectID": "posts/2025-09-04-bash-alias/index.html#references",
    "href": "posts/2025-09-04-bash-alias/index.html#references",
    "title": "シェルスクリプトにおけるAlias",
    "section": "References",
    "text": "References\n\ngnu bash manual &gt; aliases"
  },
  {
    "objectID": "posts/2025-04-09-vector-outer-product/index.html",
    "href": "posts/2025-04-09-vector-outer-product/index.html",
    "title": "ベクトル空間における外積",
    "section": "",
    "text": "▶  Key Takeaways"
  },
  {
    "objectID": "posts/2025-04-09-vector-outer-product/index.html#ベクトルの外積",
    "href": "posts/2025-04-09-vector-outer-product/index.html#ベクトルの外積",
    "title": "ベクトル空間における外積",
    "section": "ベクトルの外積",
    "text": "ベクトルの外積\n\n\nDefinition 1 : 外積 \n３次元実数空間のベクトル\n\\[\n\\begin{align}\n\\pmb a = (a_1, a_2, a_3)\\\\\n\\pmb b = (b_1, b_2, b_3)\n\\end{align}\n\\]\nに対して，\n\\[\n\\left(\\begin{vmatrix}\na_2 & a_3\\\\\nb_2 & b_3\n\\end{vmatrix},\n- \\begin{vmatrix}\na_1 & a_3\\\\\nb_1 & b_3\n\\end{vmatrix},\n\\begin{vmatrix}\na_1 & a_2\\\\\nb_1 & b_2\n\\end{vmatrix}\n\\right)\n\\]\nを \\(\\pmb a\\) と \\(\\pmb b\\) の外積またはベクトル積 といい，\\(\\pmb a \\times \\pmb b\\) と表す．\n\n\n3次元実ベクトル空間 \\(\\mathbb R^3\\) の標準基低\n\\[\n\\pmb e_1 = (1, 0, 0), \\pmb e_2 = (0, 1, 0), \\pmb e_3 = (0, 0, 1)\n\\]\nを用いて表現すると\n\\[\n\\pmb a \\times \\pmb b = \\begin{vmatrix}\na_2 & a_3\\\\\nb_2 & b_3\n\\end{vmatrix}\\pmb e_1\n- \\begin{vmatrix}\na_1 & a_3\\\\\nb_1 & b_3\n\\end{vmatrix}\\pmb e_2 +\n\\begin{vmatrix}\na_1 & a_2\\\\\nb_1 & b_2\n\\end{vmatrix}\\pmb e_3\n\\]\nと表現することもできます．この式を直感的に理解するとすると\n\\[\n\\begin{vmatrix}\n\\pmb e_1& \\pmb e_2 & \\pmb e_3\\\\\na_1& a_2 & a_3\\\\\nb_1& b_2 & b_3\n\\end{vmatrix}\n\\]\nと対応すると考えることもできます．\n\n\n\n\n\n\nNoteProperty: 外積の性質\n\n\n\n外積について次の法則が成り立つ\n\\[\n\\begin{align}\n&\\pmb a \\times \\pmb b = -\\pmb b\\times \\pmb a\\\\\n&(\\lambda\\pmb a) \\times \\pmb b = \\pmb a \\times (\\lambda \\pmb b ) = \\lambda (\\pmb a \\times \\pmb b )\\\\\n&\\pmb a \\times (\\pmb b  + \\pmb c) = \\pmb a \\times \\pmb b + \\pmb a \\times \\pmb c\\\\\n&\\pmb a \\times \\pmb a = \\pmb 0\n\\end{align}\n\\]\n\n\n\n\n\n\n\n\n\nNoteProof\n\n\n\n\n\n ▶ \\(\\pmb a \\times \\pmb b = -\\pmb b \\times \\pmb a\\)\n\\[\n\\begin{align}\n\\pmb a \\times \\pmb b\n    &= \\begin{vmatrix}\na_2 & a_3\\\\\nb_2 & b_3\n\\end{vmatrix}\\pmb e_1\n- \\begin{vmatrix}\na_1 & a_3\\\\\nb_1 & b_3\n\\end{vmatrix}\\pmb e_2 +\n\\begin{vmatrix}\na_1 & a_2\\\\\nb_1 & b_2\n\\end{vmatrix}\\pmb e_3\\\\\n&= -\\begin{vmatrix}\nb_2 & b_3\\\\\na_2 & a_3\n\\end{vmatrix}\\pmb e_1\n+ \\begin{vmatrix}\nb_1 & b_3\\\\\na_1 & a_3\n\\end{vmatrix}\\pmb e_2 -\n\\begin{vmatrix}\nb_1 & b_2\\\\\na_1 & a_2\n\\end{vmatrix}\\pmb e_3\\\\\n&= (-1)\\left(\n\\begin{vmatrix}\nb_2 & b_3\\\\\na_2 & a_3\n\\end{vmatrix}\\pmb e_1\n- \\begin{vmatrix}\nb_1 & b_3\\\\\na_1 & a_3\n\\end{vmatrix}\\pmb e_2 +\n\\begin{vmatrix}\nb_1 & b_2\\\\\na_1 & a_2\n\\end{vmatrix}\\pmb e_3\\right)\\\\\n&= - \\pmb b \\times \\pmb a\n\\end{align}\n\\]\n ▶  \\((\\lambda\\pmb a) \\times \\pmb b = \\pmb a \\times (\\lambda \\pmb b ) = \\lambda (\\pmb a \\times \\pmb b )\\)\n\\(\\eqref{#eq-determinant-linear}\\) より\n\\[\n\\begin{align}\n(\\lambda\\pmb a) \\times \\pmb b\n    &= \\begin{vmatrix}\n\\lambda a_2 & \\lambda a_3\\\\\nb_2 & b_3\n\\end{vmatrix}\\pmb e_1\n- \\begin{vmatrix}\n\\lambda a_1 & \\lambda a_3\\\\\nb_1 & b_3\n\\end{vmatrix}\\pmb e_2 +\n\\begin{vmatrix}\n\\lambda a_1 & \\lambda a_2\\\\\nb_1 & b_2\n\\end{vmatrix}\\pmb e_3\\\\\n&= \\lambda\\begin{vmatrix}\na_2 & a_3\\\\\nb_2 & b_3\n\\end{vmatrix}\\pmb e_1\n- \\lambda\\begin{vmatrix}\na_1 & a_3\\\\\nb_1 & b_3\n\\end{vmatrix}\\pmb e_2 +\n\\lambda\\begin{vmatrix}\na_1 & a_2\\\\\nb_1 & b_2\n\\end{vmatrix}\\pmb e_3\\\\\n&= \\lambda (\\pmb a\\times \\pmb b )\n\\end{align}\n\\]\n同様に\n\\[\n\\begin{align}\n\\pmb a\\times (\\lambda\\pmb b)  \n    &= \\begin{vmatrix}\na_2 & a_3\\\\\n\\lambda b_2 & \\lambda b_3\n\\end{vmatrix}\\pmb e_1\n- \\begin{vmatrix}\na_1 & a_3\\\\\n\\lambda b_1 & \\lambda b_3\n\\end{vmatrix}\\pmb e_2 +\n\\begin{vmatrix}\na_1 & a_2\\\\\n\\lambda b_1 & \\lambda b_2\n\\end{vmatrix}\\pmb e_3\\\\\n&= \\lambda\\begin{vmatrix}\na_2 & a_3\\\\\nb_2 & b_3\n\\end{vmatrix}\\pmb e_1\n- \\lambda\\begin{vmatrix}\na_1 & a_3\\\\\nb_1 & b_3\n\\end{vmatrix}\\pmb e_2 +\n\\lambda\\begin{vmatrix}\na_1 & a_2\\\\\nb_1 & b_2\n\\end{vmatrix}\\pmb e_3\\\\\n&= \\lambda (\\pmb a\\times \\pmb b )\n\\end{align}\n\\]\n ▶  \\(\\pmb a \\times (\\pmb b  + \\pmb c) = \\pmb a \\times \\pmb b + \\pmb a \\times \\pmb c\\)\n\\[\n\\begin{align}\n&\\pmb a\\times (\\pmb b + \\pmb c)\\\\\n    &=\n        \\begin{vmatrix}\n        a_2 & a_3\\\\\n        b_2 + c_2 &  b_3 + c_3\n        \\end{vmatrix}\\pmb e_1\n        - \\begin{vmatrix}\n        a_1 & a_3\\\\\n         b_1 + c_1 &  b_3 + c_3\n        \\end{vmatrix}\\pmb e_2 +\n        \\begin{vmatrix}\n        a_1 & a_2\\\\\n         b_1 + c_1 &  b_2 + c_2\n        \\end{vmatrix}\\pmb e_3\\\\\n    &=\n        \\left(\n            \\begin{vmatrix}\n            a_2 & a_3\\\\\n            b_2&  b_3\n            \\end{vmatrix}\n            +\n            \\begin{vmatrix}\n            a_2 & a_3\\\\\n            c_2&  c_3\n            \\end{vmatrix}\n        \\right)\\pmb e_1\n        - \\left(\n            \\begin{vmatrix}\n            a_1 & a_3\\\\\n            b_1&  b_3\n            \\end{vmatrix}\n            +\n            \\begin{vmatrix}\n            a_1 & a_3\\\\\n            c_1&  c_3\n            \\end{vmatrix}\n        \\right)\\pmb e_2 +\n        \\left(\n            \\begin{vmatrix}\n            a_1 & a_2\\\\\n            b_1&  b_2\n            \\end{vmatrix}\n            +\n            \\begin{vmatrix}\n            a_1 & a_2\\\\\n            c_1&  c_2\n            \\end{vmatrix}\n        \\right)\\pmb e_3\\\\\n    &= \\left(\n            \\begin{vmatrix}\n            a_2 & a_3\\\\\n            b_2&  b_3\n            \\end{vmatrix}\n        \\pmb e_1\n        -\n            \\begin{vmatrix}\n            a_1 & a_3\\\\\n            b_1&  b_3\n            \\end{vmatrix}\n            \\pmb e_2 +\n            \\begin{vmatrix}\n            a_1 & a_2\\\\\n            b_1&  b_2\n            \\end{vmatrix}\n       \\pmb e_3\\right)+\n       \\left(\n            \\begin{vmatrix}\n            a_2 & a_3\\\\\n            c_2&  c_3\n            \\end{vmatrix}\n        \\pmb e_1\n        -\n            \\begin{vmatrix}\n            a_1 & a_3\\\\\n            c_1&  c_3\n            \\end{vmatrix}\n            \\pmb e_2 +\n            \\begin{vmatrix}\n            a_1 & a_2\\\\\n            c_1&  c_2\n            \\end{vmatrix}\n       \\pmb e_3\\right)\\\\\n    &= \\pmb a \\times \\pmb b + \\pmb a \\times \\pmb c\n\\end{align}\n\\]\n ▶  \\(\\pmb a\\times \\pmb a = \\pmb 0\\)\n\\[\n\\begin{align}\n\\pmb a \\times \\pmb a\n    &= \\begin{vmatrix}\na_2 & a_3\\\\\na_2 & a_3\n\\end{vmatrix}\\pmb e_1\n- \\begin{vmatrix}\na_1 & a_3\\\\\na_1 & a_3\n\\end{vmatrix}\\pmb e_2 +\n\\begin{vmatrix}\na_1 & a_2\\\\\na_1 & a_2\n\\end{vmatrix}\\pmb e_3\\\\\n&= 0\\pmb e_1 - 0\\pmb e_2 + 0\\pmb e_3\\\\\n&= \\pmb 0\n\\end{align}\n\\]\n\n\n\n\nExample 1 \n\\(\\mathbb R^3\\) の標準基底 \\(\\pmb e_1, \\pmb e_2, \\pmb e_3\\) に関して\n\\[\n\\begin{align}\n\\pmb e_1 \\times \\pmb e_2 &= \\left(\\begin{vmatrix}\n0 & 0\\\\\n1 & 0\n\\end{vmatrix}, -\\begin{vmatrix}\n1  & 0\\\\\n0  & 0\n\\end{vmatrix}, \\begin{vmatrix}\n1 & 0 \\\\\n0 & 1\n\\end{vmatrix} \\right)\\\\\n&= \\pmb e_3\n\\end{align}\n\\]\n\\[\n\\begin{align}\n\\pmb e_2 \\times \\pmb e_3 &= \\left(\\begin{vmatrix}\n1 & 0\\\\\n0 & 1\n\\end{vmatrix}, -\\begin{vmatrix}\n0  & 0\\\\\n0  & 1\n\\end{vmatrix}, \\begin{vmatrix}\n0 & 1 \\\\\n0 & 0\n\\end{vmatrix} \\right)\\\\\n&= \\pmb e_1\n\\end{align}\n\\]\n\\[\n\\begin{align}\n\\pmb e_3 \\times \\pmb e_1 &= \\left(\\begin{vmatrix}\n0 & 1\\\\\n0 & 0\n\\end{vmatrix}, -\\begin{vmatrix}\n0  & 1\\\\\n1  & 0\n\\end{vmatrix}, \\begin{vmatrix}\n0 & 0 \\\\\n1 & 0\n\\end{vmatrix} \\right)\\\\\n&= \\pmb e_2\n\\end{align}\n\\]\n\n\n ▶  内積と外積を組み合わせた性質\n\n\nTheorem 1 \n３つのベクトル \\(\\pmb a = (a_1, a_2, a_3), \\pmb b = (b_1, b_2, b_3), \\pmb c = (c_1, c_2, c_3)\\) について，\n\\[\n(\\pmb a\\times \\pmb b, \\pmb c) = (\\pmb a, \\pmb b \\times \\pmb c) = \\begin{vmatrix}\na_1 & a_2 & a_3\\\\\nb_1 & b_2 & b_3\\\\\nc_1 & c_2 & c_3\n\\end{vmatrix}\n\\]\n\n\n\n\n\n\n\n\n\nNoteProof\n\n\n\n\n\n\\[\n\\begin{align}\n(\\pmb a\\times \\pmb b, \\pmb c)\n    &=\n        \\left(\\begin{vmatrix}\n        a_2 & a_3\\\\\n        b_2 & b_3\n        \\end{vmatrix}\\pmb e_1\n        - \\begin{vmatrix}\n        a_1 & a_3\\\\\n        b_1 & b_3\n        \\end{vmatrix}\\pmb e_2 +\n        \\begin{vmatrix}\n        a_1 & a_2\\\\\n        b_1 & b_2\n        \\end{vmatrix}\\pmb e_3, \\pmb c\\right)\\\\\n    &=\n    \\begin{vmatrix}\n        a_2 & a_3\\\\\n        b_2 & b_3\n        \\end{vmatrix}c_1\n        - \\begin{vmatrix}\n        a_1 & a_3\\\\\n        b_1 & b_3\n        \\end{vmatrix}c_2 +\n        \\begin{vmatrix}\n        a_1 & a_2\\\\\n        b_1 & b_2\n        \\end{vmatrix}c_3\\\\\n    &=\n    \\begin{vmatrix}\na_1 & a_2 & a_3\\\\\nb_1 & b_2 & b_3\\\\\nc_1 & c_2 & c_3\n\\end{vmatrix}\n\\end{align}\n\\]\n同様に\n\\[\n\\begin{align}\n(\\pmb a, \\pmb b \\times \\pmb c)\n&= (\\pmb b \\times \\pmb c, \\pmb a)\\\\\n    &=\n        \\left(\\begin{vmatrix}\n        b_2 & b_3\\\\\n        c_2 & c_3\n        \\end{vmatrix}\\pmb e_1\n        - \\begin{vmatrix}\n        b_1 & b_3\\\\\n        c_1 & c_3\n        \\end{vmatrix}\\pmb e_2 +\n        \\begin{vmatrix}\n        b_1 & b_2\\\\\n        c_1 & c_2\n        \\end{vmatrix}\\pmb e_3, \\pmb a\\right)\\\\\n    &=\n        \\begin{vmatrix}\n        b_2 & b_3\\\\\n        c_2 & c_3\n        \\end{vmatrix}a_1\n        - \\begin{vmatrix}\n        b_1 & b_3\\\\\n        c_1 & c_3\n        \\end{vmatrix}a_2 +\n        \\begin{vmatrix}\n        b_1 & b_2\\\\\n        c_1 & c_2\n        \\end{vmatrix} a_3\\\\\n    &=\n    \\begin{vmatrix}\na_1 & a_2 & a_3\\\\\nb_1 & b_2 & b_3\\\\\nc_1 & c_2 & c_3\n\\end{vmatrix}\n\\end{align}\n\\]"
  },
  {
    "objectID": "posts/2025-04-09-vector-outer-product/index.html#外積の幾何学的性質",
    "href": "posts/2025-04-09-vector-outer-product/index.html#外積の幾何学的性質",
    "title": "ベクトル空間における外積",
    "section": "外積の幾何学的性質",
    "text": "外積の幾何学的性質\n\n\nTheorem 2 \n３次元実ベクトル \\(\\pmb a, \\pmb b\\) の外積の大きさは\n\\[\n||\\pmb a\\times \\pmb b|| = ||\\pmb a||\\,||\\pmb b||\\sin \\theta\n\\]\nここで， \\(\\theta\\) は \\(\\pmb a, \\pmb b\\) のなす角であるとする\n\n\n\n\n\n\n\n\nNoteProof\n\n\n\n\n\n\\[\n\\begin{align}\n||\\pmb a\\times \\pmb b|| = ((a_2b_3 - a_3b_2), -(a_1b_3 - a_3b_1), (a_1b_2 - a_2b_1))\n\\end{align}\n\\]\nであるので\n\\[\n\\begin{align}\n||\\pmb a\\times \\pmb b||^2\n    =& a_2^2b_3^2 + a_3^2b_2^2 + a_1^2b_3^2 + a_3^2b_1^2 + a_1^2b_2^2 + a_2^2b_1^2\\\\\n     & - 2(a_2a_3b_2b_3 + a_1a_3b_1b_3+ a_1a_2b_1b_2)\n\\end{align}\n\\]\n続いて\n\\[\n\\cos\\theta = \\frac{(\\pmb a, \\pmb b)}{||\\pmb a||\\,||\\pmb b||}\\quad \\text{s.t. } (0\\leq \\theta \\leq \\pi)\n\\]\nであることから\n\\[\n\\begin{align}\n||\\pmb a||^2\\,||\\pmb b||^2\\sin^2\\theta\n    =& ||\\pmb a||^2\\,||\\pmb b||^2 (1 - \\cos^2\\theta)\\\\\n    =& ||\\pmb a||^2\\,||\\pmb b||^2 - (\\pmb a, \\pmb b)^2\\\\\n    =& (a_1^2 + a_2^2 + a_3^2)(b_1^2 + b_2^2 + b_3^2) - (a_1b_1 + a_2b_2 + a_3b_3)^2\\\\\n    =& a_2^2b_3^2 + a_3^2b_2^2 + a_1^2b_3^2 + a_3^2b_1^2 + a_1^2b_2^2 + a_2^2b_1^2\\\\\n     & - 2(a_2a_3b_2b_3 + a_1a_3b_1b_3+ a_1a_2b_1b_2)\n\\end{align}\n\\]\n従って，\n\\[\n||\\pmb a\\times \\pmb b||^2 = ||\\pmb a||^2\\,||\\pmb b||^2\\sin^2\\theta\n\\]\nこのとき，ノルムは0より大きく，\\(0\\leq \\theta \\leq \\pi\\) では \\(\\sin^2\\theta \\geq 0\\) であるので\n\\[\n||\\pmb a\\times \\pmb b|| = ||\\pmb a||\\,||\\pmb b||\\sin \\theta\n\\]\n\n\n\n ▶  Key Takeaways\n\n上記の定理は２つの３次現実ベクトルの外積のノルムは，２つの３次現実ベクトルが成す平行四辺形の面積と等しいことを意味している\n外積を \\(\\displaystyle\\frac{1}{2}\\) 倍すると，２つの３次現実ベクトルが成す三角形の面積となります．\n\n\nExample 2 \n\\[\n\\begin{align}\n\\pmb a &= (3, 4)\\\\\n\\pmb b &= (5, 2)\n\\end{align}\n\\]\nと二次元ベクトルが与えられているとします．この２つのベクトルがなす三角形の面積は外積を応用すると以下のように計算できるはずです\n\\[\n\\begin{align}\n\\triangle ABO\n    &= \\frac{1}{2}\\sqrt{(0, 0, 3\\times 2 - (4 \\times 5))(0, 0, 3\\times 2 - (4 \\times 5))^T}\\\\\n    &=  7\n\\end{align}\n\\]\n\n上では二次元ベクトル \\((x, y)\\) を \\((x, y, 0)\\) とみなして計算しています\nただし，これは外積の説明というよりかは \\(2\\) 次正方行列の行列式がなぜ面積と対応するのかのほうが適切かも\n\n実際に Pythonで計算してみると\n\nCode\nimport matplotlib.pyplot as plt\nimport numpy as np\n# Define the two vectors\nvector1 = np.array([3, 4])  # Vector 1 (x, y)\nvector2 = np.array([5, 2])  # Vector 2 (x, y)\n\n# Define the origin\norigin = [0, 0]\n\n# Create the plot\nfig, ax = plt.subplots(figsize=(6, 6))\n\n# Plot the vectors\nax.quiver(*origin, vector1[0], vector1[1], angles='xy', scale_units='xy', scale=1, color='r', label='Vector 1')\nax.quiver(*origin, vector2[0], vector2[1], angles='xy', scale_units='xy', scale=1, color='b', label='Vector 2')\n\n# Plot the triangle\ntriangle_x = [0, vector1[0], vector2[0], 0]\ntriangle_y = [0, vector1[1], vector2[1], 0]\nax.fill(triangle_x, triangle_y, color='lightblue', alpha=0.5, label='Triangle')\n\n# Set plot limits\nax.set_xlim(-1, max(vector1[0], vector2[0]) + 1)\nax.set_ylim(-1, max(vector1[1], vector2[1]) + 1)\n\n# Add grid, labels, and legend\nax.grid()\nax.set_aspect('equal')\nax.set_xlabel('X-axis')\nax.set_ylabel('Y-axis')\nax.legend()\n\n# Add title\nax.set_title('2D Vectors and Triangle')\n\n# Show the plot\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 1\n\n\n\n\n\nCode\n## compute area\nfrom shapely import Polygon\ncoords = (origin, vector1, vector2)\npolygon = Polygon(coords)\n\nprint(f\"Area of triangle: {polygon.area}\")\n\n\nArea of triangle: 7.0\n\n\n\n\n\n外積の直交性\n\n\nTheorem 3 \n２つの２次元実ベクトル \\(\\pmb a, \\pmb b\\) について\n\\[\n(\\pmb a\\times \\pmb b, \\pmb a) = (\\pmb a\\times \\pmb b, \\pmb b) = 0\n\\]\nつまり，\n\\[\n\\begin{align}\n\\pmb a\\times \\pmb b \\perp \\pmb a\\\\\n\\pmb a\\times \\pmb b \\perp \\pmb a\n\\end{align}\n\\]\n\n\n\n\n\n\n\n\nNoteProof\n\n\n\n\n\n\\[\n\\begin{align}\n(\\pmb a\\times \\pmb b, \\pmb a)\n    &=  \\begin{vmatrix}\n    a_1 & a_2 & a_3\\\\\n    a_1 & a_2 & a_3\\\\\n    b_1 & b_2 & b_3\n    \\end{vmatrix} = 0\n\\end{align}\n\\]\n同様に\n\\[\n\\begin{align}\n(\\pmb a\\times \\pmb b, \\pmb b)\n    &=  \\begin{vmatrix}\n    b_1 & b_2 & b_3\\\\\n    a_1 & a_2 & a_3\\\\\n    b_1 & b_2 & b_3\n    \\end{vmatrix} = 0\n\\end{align}\n\\]\nなお途中の式変形は行列式の性質「\\(|A| = 0 \\Leftrightarrow \\text{各行ベクトルが一次従属}\\)」を用いている．\n\n\n\n ▶  Key Takeaways\n\n\\(\\pmb a\\times \\pmb b\\) のベクトルの方向は，\\(\\pmb a\\) から \\(\\pmb b\\) へ回転するときの右ねじが進む方向に対応すると言われる\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.mplot3d import Axes3D\n\n# Define the vectors\na = np.array([3, 1, 0])  # Vector b\nb = np.array([1, 2, 0])  # Vector a\n\n# Compute the outer product (cross product)\nouter_product = np.cross(a, b)\n\n# Create a 3D plot\nfig = plt.figure(figsize=(8, 8))\nax = fig.add_subplot(111, projection='3d')\n\n# Plot vector a\nax.quiver(0, 0, 0, a[0], a[1], a[2], color='r', label='Vector a', arrow_length_ratio=0.1)\n\n# Plot vector b\nax.quiver(0, 0, 0, b[0], b[1], b[2], color='b', label='Vector b', arrow_length_ratio=0.1)\n\n# Plot the outer product vector\nax.quiver(0, 0, 0, outer_product[0], outer_product[1], outer_product[2], color='g', label='a × b', arrow_length_ratio=0.1)\n\n# Plot the square\nparallelogram_x = [0, a[0], a[0] + b[0], b[0], 0]\nparallelogram_y = [0, a[1], a[1] + b[1], b[1], 0]\nparallelogram_z = [0, a[2], a[2] + b[2], b[2], 0]\nax.plot_trisurf(parallelogram_x, parallelogram_y, parallelogram_z, color='lightblue', alpha=0.5, label='||a × b||')\n\n\n\n\n# Set plot limits\nmax_range = max(np.linalg.norm(a), np.linalg.norm(b), np.linalg.norm(outer_product)) + 1\nax.set_xlim([-1, 6])\nax.set_ylim([-1, 6])\nax.set_zlim([-1, 6])\n\n# Add labels and legend\nax.set_xlabel('X-axis')\nax.set_ylabel('Y-axis')\nax.set_zlabel('Z-axis')\nax.legend()\n\n# Add title\nax.set_title('3D Vectors and Their Outer Product')\n\n# Tilt the plot\nax.view_init(elev=30, azim=-60) \n\n# Show the plot\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 2"
  },
  {
    "objectID": "posts/2025-04-09-vector-outer-product/index.html#appendix",
    "href": "posts/2025-04-09-vector-outer-product/index.html#appendix",
    "title": "ベクトル空間における外積",
    "section": "Appendix",
    "text": "Appendix\n\n\nLemma 1 \n第 \\(i\\) 行が，２つの行ベクトルの和である行列の行列式は，他の行は同じで第 \\(i\\) 行は各々のベクトルをとった行列の行列式となる．すなわち，\n\\[\n\\left|\n\\begin{array}{ccc}\na_{11} & \\cdots & a_{1n} \\\\\n\\vdots &        & \\vdots \\\\\nb_{i1} + c_{i1} & \\cdots & b_{in} + c_{in} \\\\\n\\vdots &        & \\vdots \\\\\na_{n1} & \\cdots & a_{nn}\n\\end{array}\n\\right|\n=\n\\left|\n\\begin{array}{ccc}\na_{11} & \\cdots & a_{1n} \\\\\n\\vdots &        & \\vdots \\\\\nb_{i1} & \\cdots & b_{in}\\\\\n\\vdots &        & \\vdots \\\\\na_{n1} & \\cdots & a_{nn}\n\\end{array}\n\\right|\n+\n\\left|\n\\begin{array}{ccc}\na_{11} & \\cdots & a_{1n} \\\\\n\\vdots &        & \\vdots \\\\\nc_{i1} & \\cdots & c_{in} \\\\\n\\vdots &        & \\vdots \\\\\na_{n1} & \\cdots & a_{nn}\n\\end{array}\n\\right|\n\\]\n\n\nLemma 1 より以下もわかります\n\\[\n\\left|\n\\begin{array}{ccc}\na_{11} & \\cdots & a_{1n} \\\\\n\\vdots &        & \\vdots \\\\\n\\lambda a_{i1} & \\cdots & \\lambda a_{in} \\\\\n\\vdots &        & \\vdots \\\\\na_{n1} & \\cdots & a_{nn}\n\\end{array}\n\\right|\n= \\lambda\n\\left|\n\\begin{array}{ccc}\na_{11} & \\cdots & a_{1n} \\\\\n\\vdots &        & \\vdots \\\\\na_{i1} & \\cdots & a_{in} \\\\\n\\vdots &        & \\vdots \\\\\na_{n1} & \\cdots & a_{nn}\n\\end{array}\n\\right|\\label{#eq-determinant-linear}\n\\]\n\n余因子と行列式\n\n\nDefinition 2 : 余因子(cofactor) \n\\(n\\) 次の正方行列 \\(A = (a_{ij})\\) から，その第 \\(i\\) 行と第 \\(j\\) 列を取り除いて得られる \\((n-1)\\) 次の正方行列を \\(A_{ij}\\) と表記するとします． このとき \\(a_{ij}\\) の余因子 \\(\\tilde{a}_{ij}\\) は以下のように定義される\n\\[\n\\tilde{a}_{ij} = (-1)^{i+j}|A_{ij}|\n\\]\nまたは\n\\[\n\\tilde{a}_{ij} = (-1)^{i+j}\n\\left|\n\\begin{array}{cccccc}\na_{11} & \\cdots & a_{1(j-1)} & a_{1(j+1)} & \\cdots & a_{1n} \\\\\n\\vdots &        & \\vdots     & \\vdots     &        & \\vdots \\\\\na_{(i-1)1} & \\cdots & \\cdots & \\cdots & \\cdots & a_{(i-1)n} \\\\\na_{(i+1)1} & \\cdots & \\cdots & \\cdots & \\cdots & a_{(i+1)n} \\\\\n\\vdots &        & \\vdots     & \\vdots     &        & \\vdots \\\\\na_{n1} & \\cdots & a_{n(j-1)} & a_{n(j+1)} & \\cdots & a_{nn}\n\\end{array}\n\\right|\n\\]\n\n\n\nExample 3 \n\\[r\nA = \\left(\\begin{array}{ccc}\n1 & 2 & 0\\\\\n3 & 5 & -1\\\\\n4 & 6 & 7\n\\end{array}\\right)\n\\]\nについて，\\(\\tilde{a}_{11}, \\tilde{a}_{12}, \\tilde{a}_{13}\\) はそれぞれ以下のように計算されます\n\\[\n\\begin{align}\n\\tilde{a}_{11} &= (-1)^2 \\left(\\begin{vmatrix}5 & -1\\\\6&7\\end{vmatrix}\\right) = 41\\\\\n\\tilde{a}_{12} &= (-1)^3 \\left(\\begin{vmatrix}3 & -1\\\\4&7\\end{vmatrix}\\right) = -25\\\\\n\\tilde{a}_{13} &= (-1)^4 \\left(\\begin{vmatrix}3 & 5\\\\4&6\\end{vmatrix}\\right) = -2\n\\end{align}\n\\]\n\n\n\n\nTheorem 4 : 行列式の展開 \n\\[\na_{i1}\\tilde a_{i1} + a_{i2}\\tilde a_{i2} + \\cdots + a_{in}\\tilde a_{in} = |A|\n\\]\n\n\n\n\n\n\n\n\n\nNoteProof\n\n\n\n\n\n与えられた行列 \\(A = (a_{ij})\\) の第 \\(i\\) 行は\n\\[\n(a_{i1}, \\cdots, a_{in}) = (a_{i1}, 0, \\cdots, 0) + (0, a_{i2}, \\cdots, 0) \\cdots + (0, \\cdots, 0, a_{in})\n\\]\nと線型結合で表せるので，Lemma 1 より\n\\[\n|A|\n=\n\\left|\n\\begin{array}{cccc}\na_{11} &\\cdots & \\cdots & a_{1n} \\\\\n\\vdots & &       & \\vdots \\\\\na_{11} & 0 & \\cdots & 0 \\\\\n\\vdots &      &  & \\vdots \\\\\na_{n1} &\\cdots &\\cdots & a_{nn}\n\\end{array}\n\\right|\n+\n\\left|\n\\begin{array}{cccc}\na_{11} &\\cdots & \\cdots & a_{1n} \\\\\n\\vdots & &       & \\vdots \\\\\n0 & a_{12} & 0 \\cdots & 0 \\\\\n\\vdots &      &  & \\vdots \\\\\na_{n1} &\\cdots &\\cdots & a_{nn}\n\\end{array}\n\\right|\n+ \\cdots +\n\\left|\n\\begin{array}{cccc}\na_{11} &\\cdots & \\cdots & a_{1n} \\\\\n\\vdots & &       & \\vdots \\\\\n0 & \\cdots& \\cdots 0 & a_{in} \\\\\n\\vdots &      &  & \\vdots \\\\\na_{n1} &\\cdots &\\cdots & a_{nn}\n\\end{array}\n\\right|\\label{#eq-additive}\n\\]\nRHSの第 \\(j\\) 番目の行列式の計算を考える．このとき，行を１つ交換するたびに行列式は \\(-1\\) 倍されることから\n\\[\n\\left|\n\\begin{array}{ccccc}\na_{11} &\\cdots &\\cdots& \\cdots & a_{1n} \\\\\n\\vdots & &   &    & \\vdots \\\\\n0 & \\cdots  &a_{ij} & \\cdots & 0 \\\\\n\\vdots &   &   &  & \\vdots \\\\\na_{n1} &\\cdots &\\cdots &\\cdots & a_{nn}\n\\end{array}\n\\right|\n=\n(-1)^{i-1}\n\\left|\n\\begin{array}{ccccc}\n0 & \\cdots  &a_{ij} & \\cdots & 0 \\\\\na_{11} &\\cdots &\\cdots& \\cdots & a_{1n} \\\\\n\\vdots & &   &    & \\vdots \\\\\n\\vdots &   &   &  & \\vdots \\\\\na_{n1} &\\cdots &\\cdots &\\cdots & a_{nn}\n\\end{array}\n\\right|\n\\]\n列を１つ交換するたびに行列式は \\(-1\\) 倍されることから\n\\[\n\\left|\n\\begin{array}{ccccc}\n0 & \\cdots  &a_{ij} & \\cdots & 0 \\\\\na_{11} &\\cdots &\\cdots& \\cdots & a_{1n} \\\\\n\\vdots & &   &    & \\vdots \\\\\n\\vdots &   &   &  & \\vdots \\\\\na_{n1} &\\cdots &\\cdots &\\cdots & a_{nn}\n\\end{array}\n\\right|\n=\n(-1)^{j-1}\n\\left|\n\\begin{array}{ccccc}\na_{ij} &0 & \\cdots & \\cdots & 0 \\\\\na_{1j} &a_{11} &\\cdots & \\cdots & a_{1n} \\\\\n\\vdots &\\vdots & &       & \\vdots \\\\\n\\vdots &\\vdots &   &     & \\vdots \\\\\na_{nj} &a_{n1} &\\cdots  &\\cdots & a_{nn}\n\\end{array}\n\\right|\n\\]\n従って，\n\\[\n\\begin{align}\n\\left|\n\\begin{array}{ccccc}\na_{11} &\\cdots &\\cdots& \\cdots & a_{1n} \\\\\n\\vdots & &   &    & \\vdots \\\\\n0 & \\cdots  &a_{ij} & \\cdots & 0 \\\\\n\\vdots &   &   &  & \\vdots \\\\\na_{n1} &\\cdots &\\cdots &\\cdots & a_{nn}\n\\end{array}\n\\right|\n&= (-1)^{i+j-2}\na_{ij}\n\\left|\n\\begin{array}{cccc}\na_{11} &\\cdots & \\cdots & a_{1n} \\\\\n\\vdots & &       & \\vdots \\\\\n\\vdots &   &     & \\vdots \\\\\na_{n1} &\\cdots  &\\cdots & a_{nn}\n\\end{array}\n\\right|\\\\\n&= (-1)^{i+j-2} a_{ij}|A_{ij}|\\\\\n&= a_{ij}(-1)^{i+j-2}|A_{ij}|\\\\\n&= a_{ij}\\tilde a_{ij}\n\\end{align}\n\\]\n\\(\\eqref{#eq-additive}\\) より\n\\[\n|A| = \\sum_{j=1}^na_{ij}\\tilde a_{ij}\n\\]"
  },
  {
    "objectID": "posts/2026-01-18-dd-command/index.html",
    "href": "posts/2026-01-18-dd-command/index.html",
    "title": "ISOイメージをUSBデバイスに書き込むための dd コマンド",
    "section": "",
    "text": "Definition 1 dd コマンド\n\ncp よりもより低レイヤーなコピー・変換ツール\n入力と出力にデバイスを指定できるため，フォーマット変換・データ修復・ディスク操作などに使われる\n\n\nsyntax\ndd [if=入力ファイル名] [of=出力ファイル名] [bs=ブロックサイズ] [count=ブロック数]\n\n\n\n\n\n\n\n\nオプション\n説明\n\n\n\n\nif=入力ファイル名\n入力ファイルの指定\n\n\nof=出力ファイル名\n出力ファイルの指定\n\n\nbs=ブロックサイズ\n1回の read/write で使用するブロックサイズの指定\n\n\ncount=ブロック数\n入呂育するブロック数の指定\n\n\nconv=変換オプション\nnoerror: 読み込みエラー後も継続する  sync: 入力ブロックを入力バッファサイズになるまで埋める\n\n\n\n\nconv=sync は不足した入力ブロックを NUL（または空白）で埋めるという処理になります．"
  },
  {
    "objectID": "posts/2026-01-18-dd-command/index.html#ddコマンド",
    "href": "posts/2026-01-18-dd-command/index.html#ddコマンド",
    "title": "ISOイメージをUSBデバイスに書き込むための dd コマンド",
    "section": "",
    "text": "Definition 1 dd コマンド\n\ncp よりもより低レイヤーなコピー・変換ツール\n入力と出力にデバイスを指定できるため，フォーマット変換・データ修復・ディスク操作などに使われる\n\n\nsyntax\ndd [if=入力ファイル名] [of=出力ファイル名] [bs=ブロックサイズ] [count=ブロック数]\n\n\n\n\n\n\n\n\nオプション\n説明\n\n\n\n\nif=入力ファイル名\n入力ファイルの指定\n\n\nof=出力ファイル名\n出力ファイルの指定\n\n\nbs=ブロックサイズ\n1回の read/write で使用するブロックサイズの指定\n\n\ncount=ブロック数\n入呂育するブロック数の指定\n\n\nconv=変換オプション\nnoerror: 読み込みエラー後も継続する  sync: 入力ブロックを入力バッファサイズになるまで埋める\n\n\n\n\nconv=sync は不足した入力ブロックを NUL（または空白）で埋めるという処理になります．"
  },
  {
    "objectID": "posts/2026-01-18-dd-command/index.html#isoファイルをusbデバイスに書き込む",
    "href": "posts/2026-01-18-dd-command/index.html#isoファイルをusbデバイスに書き込む",
    "title": "ISOイメージをUSBデバイスに書き込むための dd コマンド",
    "section": "ISOファイルをUSBデバイスに書き込む",
    "text": "ISOファイルをUSBデバイスに書き込む\n基本的には\ndd if=image.iso of=&lt;USBデバイス&gt;\nとなります．\n\nExample 1 (Linux Mint 22.3 Cinnamon インストーラーの作成) \n手順の流れは\n\nLinux Mint ISOファイルをダウンロード\nISOをUSBに書き込み\nPCを再起動\nBIOS/UEFIで起動\n\nまず，ISOファイルは以下のコマンドでダウンロードします\n## tmp directoryに移動\n$ cd ~/tmp\n\n## ISOイメージファイルのダウンロード\n$ curl -O https://ftp.udx.icscoe.jp/Linux/linuxmint/iso/stable/22.3/linuxmint-22.3-cinnamon-64bit.iso\n次に，書き込むデバイスを確認します\n$ lsblk\n...\nsdc           8:0    1  57.3G  0 disk\n├─sdc1\n...\n今回のターゲットは sdc となります（注意点として，パーティションされた sdc1 ではなく，あくまでデバイスとなります）． アウトプット先を確認した後，必ずunmountします\ndd コマンドはファイルシステムを無視してディスクを直接書き換えるコマンドです．OSがそのデバイスをマウントしたままだと， OS側の方でデバイスのファイルシステムを認識しながら，そのファイルシステムがまるっと書き換わってしまうのでエラーが競合が発生してしまうためです．\n次に，USBデバイスに書き込みを行います．\n## ddコマンドを用いた書き込み\n$ sudo dd if=linuxmint-22.3-cinnamon-64bit.iso of=/dev/sdc status=progress oflag=sync bs=4M\n3070230528 bytes (3.1 GB, 2.9 GiB) copied, 120 s, 25.6 MB/s\n737+1 records in\n737+1 records out\n3091660800 bytes (3.1 GB, 2.9 GiB) copied, 121.427 s, 25.5 MB/s\n\n\n\n\nオプション\n意味\n\n\n\n\nif=\nUbuntu ISO\n\n\nof=/dev/sdc\nUSB 全体（パーティション番号なし）\n\n\nbs=4M\n高速かつ安全\n\n\nstatus=progress\n進捗表示\n\n\noflag=sync\n書き込み完了を保証\n\n\n\n\n\n\n\n\n\n\nNoteブロックサイズの指定の効果\n\n\n\nbs=4M を指定することで 4MB単位で read/writeが発生します．これは4MBごとにシステムコールの\n\nread()\nwrite()\n\nが発生することになります．ブロックサイズが小さすぎると，システムコールの頻度が増大してしまうので，大きいほどその回数を減らすことができます．一方，指定ブロックサイズが大きすぎると，一回のシステムコールで使用するメモリ領域が増えてしまいます．ここらへんのバランスを考えた上で，今回は 4MB と指定しています．"
  },
  {
    "objectID": "posts/2026-01-18-dd-command/index.html#references",
    "href": "posts/2026-01-18-dd-command/index.html#references",
    "title": "ISOイメージをUSBデバイスに書き込むための dd コマンド",
    "section": "References",
    "text": "References\n\nIT media &gt; 【dd】コマンド――ブロック単位でファイルをコピー，変換する\nAsk Ubuntu &gt; Do I have to unmount the drive when using dd command?"
  },
  {
    "objectID": "posts/2025-12-04-kernel-regression/index.html",
    "href": "posts/2025-12-04-kernel-regression/index.html",
    "title": "NW Regressionのメモ",
    "section": "",
    "text": "\\((X_1, Y_1), \\cdots, (X_n, Y_n) \\sim F\\) というデータを観測したとき，\n\\[\nr(x) = \\mathbb E[Y | X = x]\n\\]\nというCEFを推定するのがゴールとなります．このとき，\\(\\hat r(x)\\) を回帰関数とすると \\(r(x)\\) との距離を考える必要があります． 距離の一例として\n\\[\nL(\\hat r, r) = \\int (\\hat r(x) - r(x))^2 \\,\\mathrm{d}x\n\\]\nとするとリスク関数は\n\\[\nR(\\hat r, r) = \\mathbb E\\left[\\int (\\hat r(x) - r(x))^2 \\,\\mathrm{d}x\\right]\n\\]\n\nこのとき，\\(r^{\\prime\\prime}(y) &lt; \\infty\\) であると仮定しています\n\n回帰関数のBiasとVarianceを \\(b(x), v(x)\\) とすると，\n\\[\nR(\\hat r, r) = \\int b^2(x) \\,\\mathrm{d}x + \\int v(x)\\,\\mathrm{d}x\n\\]\nNon-parametric Regressionの方針\nNon-parametric Regression推定の考え方は，データの「局所平均」をとることでです． ある点における回帰関数の推定値は、その点の近傍にある \\(Y\\) の値の平均として求めることになります．\nバンド幅は Bias と Variance に影響を与えますが，\n\n近傍が広すぎると，Bias が大きく Variance が小さい状態へ（oversmoothing）\n逆に近傍が狭すぎると，Bias は小さいが Variance が大きい状態へ（undersmoothing）"
  },
  {
    "objectID": "posts/2025-12-04-kernel-regression/index.html#non-parametric-regression",
    "href": "posts/2025-12-04-kernel-regression/index.html#non-parametric-regression",
    "title": "NW Regressionのメモ",
    "section": "",
    "text": "\\((X_1, Y_1), \\cdots, (X_n, Y_n) \\sim F\\) というデータを観測したとき，\n\\[\nr(x) = \\mathbb E[Y | X = x]\n\\]\nというCEFを推定するのがゴールとなります．このとき，\\(\\hat r(x)\\) を回帰関数とすると \\(r(x)\\) との距離を考える必要があります． 距離の一例として\n\\[\nL(\\hat r, r) = \\int (\\hat r(x) - r(x))^2 \\,\\mathrm{d}x\n\\]\nとするとリスク関数は\n\\[\nR(\\hat r, r) = \\mathbb E\\left[\\int (\\hat r(x) - r(x))^2 \\,\\mathrm{d}x\\right]\n\\]\n\nこのとき，\\(r^{\\prime\\prime}(y) &lt; \\infty\\) であると仮定しています\n\n回帰関数のBiasとVarianceを \\(b(x), v(x)\\) とすると，\n\\[\nR(\\hat r, r) = \\int b^2(x) \\,\\mathrm{d}x + \\int v(x)\\,\\mathrm{d}x\n\\]\nNon-parametric Regressionの方針\nNon-parametric Regression推定の考え方は，データの「局所平均」をとることでです． ある点における回帰関数の推定値は、その点の近傍にある \\(Y\\) の値の平均として求めることになります．\nバンド幅は Bias と Variance に影響を与えますが，\n\n近傍が広すぎると，Bias が大きく Variance が小さい状態へ（oversmoothing）\n逆に近傍が狭すぎると，Bias は小さいが Variance が大きい状態へ（undersmoothing）"
  },
  {
    "objectID": "posts/2025-12-04-kernel-regression/index.html#kernel-regression",
    "href": "posts/2025-12-04-kernel-regression/index.html#kernel-regression",
    "title": "NW Regressionのメモ",
    "section": "Kernel Regression",
    "text": "Kernel Regression\n\nDefinition 1 Kernel Regression Estimator\n\\[\n\\hat r(x) = \\sum_{i=1}^n w_i(x) Y_i\n\\]\n\\(w_i(x)\\): importance weight and the form is following\n\\[\nw_i(x) = \\frac{K\\left(\\frac{x - X_i}{h}\\right)}{\\sum_{i=1}^nK\\left(\\frac{x - X_i}{h}\\right)}\n\\]\n\n表記簡略化のため \\(K\\left(\\frac{x - X_i}{h}\\right) = K_h(X_i)\\) とし，\\(X_i\\) は １変数の場合とします．\n\n\\[\n\\begin{align}\n\\hat r(x)\n  &= \\frac{\\sum Y_i K_h(X_i)}{\\sum K_h(X_i)}\\\\\n  &= \\frac{\\frac{1}{n}\\sum Y_i K_h(X_i)}{\\frac{1}{n}\\sum K_h(X_i)}\\\\\n  &= \\frac{\\frac{1}{n}\\sum Y_i K_h(X_i)}{\\hat p(x)}\\\\\n  &\\approx \\frac{\\frac{1}{n}\\sum Y_i K_h(X_i)}{p(x)}\n\\end{align}\n\\]\n\nこのとき numerator 側の期待値を考えると\n\n\\[\n\\begin{align}\n\\mathbb{E}[Y K_h(X - x)]\n&= \\iint y K_h(u - x) p(u, y)\\, dy\\, du \\\\\n&= \\int K_h(u - x) \\left( \\int y p(y \\mid u)\\, dy \\right) p(u)\\, du \\\\\n&= \\int K_h(u - x) r(u) p(u)\\, du \\\\\n&= \\int K(t)\\, r(x + th)\\, p(x + th)\\, dt \\\\\n&\\approx \\int K(t)\n\\left[ r(x) + th r'(x) + \\frac{t^2 h^2}{2} r''(x) \\right]\n\\left[ p(x) + th p'(x) + \\frac{t^2 h^2}{2} p''(x) \\right] dt \\\\\n&= r(x)p(x) + \\frac{c h^2}{2} \\left[ r(x)p''(x) + 2 r'(x)p'(x) + r''(x)p(x) \\right]\n\\end{align}\n\\]\n\nこのとき \\(c = \\int t^2K(t)\\)．したがって，\n\\[\n\\mathbb E[\\hat r(x)] = r(x) + Ch^2\n\\]\n分散の導出\n\n\\[\n\\begin{align}\n\\mathbb E[Y^2K^2_h(X - x)]\n  &= \\int \\mathbb E[Y^2 | X=u]K^2_h(u - x)p(u)\\, du \\\\\n  &= \\int (r^2(u) + \\sigma^2(u))K^2_h(u - x)p(u)\\, du \\\\\n  &= \\int \\left( \\sigma^{2}(x + th) + r^{2}(x + th) \\right)\n      \\frac{1}{h^{2}} K^{2}(t)\\, p(x + th)\\, h\\, dt \\\\\n  &= \\frac{1}{h} \\int \\left( \\sigma^{2}(x) + r^{2}(x) \\right)\n      p(x)\\, K^{2}(t)\\, dt + o\\!\\left(\\frac{1}{h}\\right).\n\\end{align}\n\\]\n\nしたがって， \\(\\mathcal{O}(1/h)\\). \\(h\\to 0\\) の状況では \\(\\mathbb E[Y^2K^2_h(X - x)]\\) のオーダーが支配的になるので\n\\[\n\\operatorname{Var}(Y K_h(X - x)) \\approx \\mathcal{O}(1/h)\n\\]\nしたがって，i.i.dと \\(\\sum_{i=1}^n\\) より\n\\[\n\\operatorname{Var}(\\hat r(x)) = \\frac{C}{nh}\n\\]\nこれらを踏まえるとIMSEは\n\\[\n\\operatorname{IMSE} = ch^4 + \\frac{c}{nh}\n\\]\n\n\n\n\n\n\nNoteCurse of dimensionality\n\n\n\n\\(d\\) 次元を考えるとリスク関数は次のオーダーになります\n\\[\nR(\\hat r, r) \\approx n^{-4/(4 + d)}\n\\]\n\\(d\\) が大きくなるほど，IMSEのオーダーは悪くなることから curse of dimensionality と呼びます．"
  },
  {
    "objectID": "posts/2025-03-02-find-coordinates/index.html",
    "href": "posts/2025-03-02-find-coordinates/index.html",
    "title": "敵の砲台の座標を探せ 1/N",
    "section": "",
    "text": "\\((a, b)\\) を中心点とする半径 \\(r\\) の円をplotすることを考えます．\n半径 \\(r\\) の円の中心点の座標が原点 \\((0, 0)\\) にある場合，円周上の点 \\(P = (x, y)\\) は，\\(P\\) から \\(x\\) 軸に下ろした垂線と \\(x\\) 軸が交わる点を \\(Q\\) としたとき \\(\\triangle OPQ\\) は斜辺 \\(r\\)，高さ \\(y\\), 底辺の長さ \\(x\\) となる直角三角形を構成するので，三平方の定理より\n\\[\nr^2 = x^2 + y^2\n\\]\nこれが円上の座標が満たす方程式となります．原点を中心点とする場合を考えましたが，中心が \\((a, b)\\)，半径 \\(r\\) の円の式は同様の方法で\n\\[\nr^2 = (x - a)^2 + (y - b)^2 \\label{#eq-circle}\n\\]\nと表すことが出来ます．\n\n\nCode\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport matplotlib.tri as mtri\n\n# set params\nR = 1\nO = (2, 1)\n\n# variables\ntheta = np.linspace(0, 2 * np.pi, 1000)\nx = np.cos(theta) * R + O[0]\ny = np.sin(theta) * R + O[1]\n\nA = (x[100], y[100])\ntriangles = [[0, 1, 2]]\nx_trinagle = [O[0], A[0], A[0]]\ny_trinagle = [O[1], O[1], A[1]]\ntriang = mtri.Triangulation(x_trinagle, y_trinagle, triangles)\n\n# plot\nfig, ax = plt.subplots(figsize=(8, 6))\nax.grid()\nax.set_aspect(\"equal\")\nax.set_xlim(0.5, 3.5)\nax.set_ylim(-0.5, 2.5)\n\n\nax.plot(x, y)\nax.scatter(*O, s=8, color=\"k\")\nax.scatter(*A, s=8, color=\"k\")\nax.text(*O, s=\"O\",  ha='center', va='bottom')\nax.text(*A, s=\"A = ($x_1, y_1$)\", ha='left', va='bottom')\nax.text(2.4, 1.35, s=\"r\")\nax.text(2.4, 0.9, s=\"$x_1 - 2$\", ha='center', va='bottom')\nax.text(A[0]+0.05, 1.35, s=\"$y_1 - 1$\", ha='left', va='bottom')\n\n# add lines\nax.triplot(triang, 'ko-')\n\n\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\n# set params\nR = 2.5\nO = (3, 1/2)\n\n# variables\ntheta = np.linspace(0, 2 * np.pi, 1000)\nx = np.cos(theta) * R + O[0]\ny = np.sin(theta) * R + O[1]\n\nP = (1, -1)\nQ = (3, 3)\nR = (1, 2)\n\n# plot\nfig, ax = plt.subplots(figsize=(8, 6))\nax.grid()\nax.set_aspect(\"equal\")\n\nax.plot(x, y)\nax.scatter(*O, s=8, color=\"k\")\nax.scatter(*P, s=8, color=\"k\")\nax.scatter(*Q, s=8, color=\"k\")\nax.scatter(*R, s=8, color=\"k\")\nax.text(*O, s=\"O\",  ha='center', va='bottom')\nax.text(*P, s=\"P\",  ha='center', va='bottom')\nax.text(*Q, s=\"Q\", ha='left', va='bottom')\nax.text(*R, s=\"R\", ha='left', va='bottom')\n\n\nplt.show()\n\n\n\n\n\n\n\n\n\n３点 \\(P = (1, -1), Q = (3, 3), R = (1, 2)\\) が与えられたとして，この３点を通る円を求める問題を考えます．\n\\(\\eqref{#eq-circle}\\) を展開すると\n\\[\nx^2 + y^2 - 2ax - 2by + a^2 + b^2 = r^2\n\\]\nこれを整理して\n\\[\nx^2 + y^2 + Ax + By + C = 0 \\label{#eq-basemodel}\n\\]\nと変形します．ここで，\\(P = (1, -1), Q = (3, 3), R = (1, 2)\\) の情報を用いると\n\\[\n\\begin{gather}\n2 + A - B + C = 0\\\\\n18 + 3A + 3B + C = 0\\\\\n5 + A +2B + C = 0\n\\end{gather}\n\\]\nという \\(A,B,C\\) についての連立方程式を得ることが出来ます．これを解くと\n\\[\nA = -6, B = -1, C = 3\n\\]\n従って，\n\\[\n(x - 3)^2 + (y - 0.5)^2 = 2.5^2 \\label{#eq-ans1}\n\\]\n\n\n点 \\(P, Q, R\\) からなる三角形の外接円として求めたい円を捉えることも出来ます． 外接円の円心は三角形の各線分の垂直二等分線の交点として求めることが出来ます．\n\n\nCode\ndef func_pq(x):\n    a = - (P[0] - Q[0]) / (P[1] - Q[1])\n    b = - a * (P[0] + Q[0]) / 2 + (P[1] + Q[1]) / 2\n\n    return a*x + b\n\ndef func_pr(x):\n    a = - (P[0] - R[0]) / (P[1] - R[1])\n    b = - a * (P[0] + R[0]) / 2 + (P[1] + R[1]) / 2\n\n    return a*x + b\n\nx_lin = np.array([0, 6])\ntriangles = [[0, 1, 2]]\nx_trinagle = [P[0], Q[0], R[0]]\ny_trinagle = [P[1], Q[1], R[1]]\ntriang = mtri.Triangulation(x_trinagle, y_trinagle, triangles)\n\n\n\n# plot\nfig, ax = plt.subplots(figsize=(8, 6))\nax.grid()\nax.set_aspect(\"equal\")\nax.set_xlim(0, 6)\nax.set_ylim(-2.5, 3.5)\nax.plot(x_lin, func_pq(x_lin), label='PQ Perpendicular bisector', linestyle='--', color='gray')\nax.plot(x_lin, func_pr(x_lin), label='PR Perpendicular bisector', linestyle=':', color='gray')\n\n\nax.plot(x, y)\nax.scatter(*O, s=8, color=\"k\")\nax.scatter(*P, s=8, color=\"k\")\nax.scatter(*Q, s=8, color=\"k\")\nax.scatter(*R, s=8, color=\"k\")\nax.text(*O, s=\"O\",  ha='center', va='bottom')\nax.text(*P, s=\"P\",  ha='center', va='bottom')\nax.text(*Q, s=\"Q\", ha='left', va='bottom')\nax.text(*R, s=\"R\", ha='left', va='bottom')\n\n# add lines\nax.triplot(triang, 'ko-')\n\nplt.legend(loc='center left', bbox_to_anchor=(1, 0.95))\nplt.show()\n\n\n\n\n\n\n\n\n\n\\(PQ\\) の垂直二等分線 \\(f(x)\\) は\n\\[\n\\begin{align}\nf(x)\n    &= -\\frac{P_x - Q_x}{P_y - Q_y}x + \\frac{P_y + Q_y}{2} + \\frac{P_x - Q_x}{P_y - Q_y} \\frac{P_x + Q_y}{2}\\\\\n    &= -\\frac{P_x - Q_x}{P_y - Q_y}x + \\frac{P_x^2 - Q_x^2 + P_y^2 - Q_y^2}{2(P_y - Q_y)}\n\\end{align}\n\\]\n同様に \\(PR\\) の垂直二等分線 \\(g(x)\\) は\n\\[\n\\begin{align}\ng(x)\n    &= -\\frac{P_x - R_x}{P_y - R_y}x + \\frac{P_y + R_y}{2} + \\frac{P_x - R_x}{P_y - R_y} \\frac{P_x + R_y}{2}\\\\\n    &= -\\frac{P_x - R_x}{P_y - R_y}x + \\frac{P_x^2 - R_x^2 + P_y^2 - R_y^2}{2(P_y - R_y)}\n\\end{align}\n\\]\nここから \\(f(x), g(x)\\) が交差する点を求めることで外接円の円心を求めることが出来ます．\n少しめんどくさいので，数値計算で説いてみると\n\n\nCode\na = - (P[0] - Q[0]) / (P[1] - Q[1])\nb = - a * (P[0] + Q[0]) / 2 + (P[1] + Q[1]) / 2\nc = - (P[0] - R[0]) / (P[1] - R[1])\nd = - c * (P[0] + R[0]) / 2 + (P[1] + R[1]) / 2\n\nprint((d-b)/(a-c), a * (d-b)/(a-c) + b)\n\n\n3.0 0.5\n\n\n\\(\\eqref{#eq-ans1}\\) と一致する計算結果となることが確かめられました．\n\n📘 REMARKS \n上記の垂直二等分線の交点を \\((x_0, y_0)\\) としたとき，整理すると以下のようになります．\n\\[\nA = \\left(\\begin{array}{cc}\nR_y - Q_y & -(P_y - Q_y)\\\\\n-(R_x - Q_x) & P_x - Q_x\\\\\n\\end{array}\\right)\n\\]\nとしたとき，\n\\[\n\\left(\\begin{array}{c}\nx_0\\\\\ny_0\n\\end{array}\\right)\n    = \\frac{1}{\\operatorname{det}A} A\\left(\\begin{array}{c}\n(P_x^2 - Q_x^2 + P_y^2 - Q_y^2)/2\\\\\n(R_x^2 - Q_x^2 + R_y^2 - Q_y^2)/2\n\\end{array}\\right)\n\\]\n実際に計算してみると\n\n\nCode\nA_array = np.array([[R[1] - Q[1], -(P[1] - Q[1])], [-(R[0] - Q[0]), P[0] - Q[0]]])\nB_array = np.array(\n    [\n        [(P[0]**2 - Q[0]**2 + P[1]**2 - Q[1]**2) / 2],\n        [(R[0]**2 - Q[0]**2 + R[1]**2 - Q[1]**2) / 2],\n    ]\n)\n\nresult = np.ravel((A_array @ B_array) / np.linalg.det(A_array))\nradius = np.sqrt(np.sum((np.array(P) - result) **2))\nprint(f\"中心点 = ({result}), 半径 = {radius}\")\n\n\n中心点 = ([3.  0.5]), 半径 = 2.5"
  },
  {
    "objectID": "posts/2025-03-02-find-coordinates/index.html#円の式",
    "href": "posts/2025-03-02-find-coordinates/index.html#円の式",
    "title": "敵の砲台の座標を探せ 1/N",
    "section": "",
    "text": "\\((a, b)\\) を中心点とする半径 \\(r\\) の円をplotすることを考えます．\n半径 \\(r\\) の円の中心点の座標が原点 \\((0, 0)\\) にある場合，円周上の点 \\(P = (x, y)\\) は，\\(P\\) から \\(x\\) 軸に下ろした垂線と \\(x\\) 軸が交わる点を \\(Q\\) としたとき \\(\\triangle OPQ\\) は斜辺 \\(r\\)，高さ \\(y\\), 底辺の長さ \\(x\\) となる直角三角形を構成するので，三平方の定理より\n\\[\nr^2 = x^2 + y^2\n\\]\nこれが円上の座標が満たす方程式となります．原点を中心点とする場合を考えましたが，中心が \\((a, b)\\)，半径 \\(r\\) の円の式は同様の方法で\n\\[\nr^2 = (x - a)^2 + (y - b)^2 \\label{#eq-circle}\n\\]\nと表すことが出来ます．\n\n\nCode\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport matplotlib.tri as mtri\n\n# set params\nR = 1\nO = (2, 1)\n\n# variables\ntheta = np.linspace(0, 2 * np.pi, 1000)\nx = np.cos(theta) * R + O[0]\ny = np.sin(theta) * R + O[1]\n\nA = (x[100], y[100])\ntriangles = [[0, 1, 2]]\nx_trinagle = [O[0], A[0], A[0]]\ny_trinagle = [O[1], O[1], A[1]]\ntriang = mtri.Triangulation(x_trinagle, y_trinagle, triangles)\n\n# plot\nfig, ax = plt.subplots(figsize=(8, 6))\nax.grid()\nax.set_aspect(\"equal\")\nax.set_xlim(0.5, 3.5)\nax.set_ylim(-0.5, 2.5)\n\n\nax.plot(x, y)\nax.scatter(*O, s=8, color=\"k\")\nax.scatter(*A, s=8, color=\"k\")\nax.text(*O, s=\"O\",  ha='center', va='bottom')\nax.text(*A, s=\"A = ($x_1, y_1$)\", ha='left', va='bottom')\nax.text(2.4, 1.35, s=\"r\")\nax.text(2.4, 0.9, s=\"$x_1 - 2$\", ha='center', va='bottom')\nax.text(A[0]+0.05, 1.35, s=\"$y_1 - 1$\", ha='left', va='bottom')\n\n# add lines\nax.triplot(triang, 'ko-')\n\n\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\n# set params\nR = 2.5\nO = (3, 1/2)\n\n# variables\ntheta = np.linspace(0, 2 * np.pi, 1000)\nx = np.cos(theta) * R + O[0]\ny = np.sin(theta) * R + O[1]\n\nP = (1, -1)\nQ = (3, 3)\nR = (1, 2)\n\n# plot\nfig, ax = plt.subplots(figsize=(8, 6))\nax.grid()\nax.set_aspect(\"equal\")\n\nax.plot(x, y)\nax.scatter(*O, s=8, color=\"k\")\nax.scatter(*P, s=8, color=\"k\")\nax.scatter(*Q, s=8, color=\"k\")\nax.scatter(*R, s=8, color=\"k\")\nax.text(*O, s=\"O\",  ha='center', va='bottom')\nax.text(*P, s=\"P\",  ha='center', va='bottom')\nax.text(*Q, s=\"Q\", ha='left', va='bottom')\nax.text(*R, s=\"R\", ha='left', va='bottom')\n\n\nplt.show()\n\n\n\n\n\n\n\n\n\n３点 \\(P = (1, -1), Q = (3, 3), R = (1, 2)\\) が与えられたとして，この３点を通る円を求める問題を考えます．\n\\(\\eqref{#eq-circle}\\) を展開すると\n\\[\nx^2 + y^2 - 2ax - 2by + a^2 + b^2 = r^2\n\\]\nこれを整理して\n\\[\nx^2 + y^2 + Ax + By + C = 0 \\label{#eq-basemodel}\n\\]\nと変形します．ここで，\\(P = (1, -1), Q = (3, 3), R = (1, 2)\\) の情報を用いると\n\\[\n\\begin{gather}\n2 + A - B + C = 0\\\\\n18 + 3A + 3B + C = 0\\\\\n5 + A +2B + C = 0\n\\end{gather}\n\\]\nという \\(A,B,C\\) についての連立方程式を得ることが出来ます．これを解くと\n\\[\nA = -6, B = -1, C = 3\n\\]\n従って，\n\\[\n(x - 3)^2 + (y - 0.5)^2 = 2.5^2 \\label{#eq-ans1}\n\\]\n\n\n点 \\(P, Q, R\\) からなる三角形の外接円として求めたい円を捉えることも出来ます． 外接円の円心は三角形の各線分の垂直二等分線の交点として求めることが出来ます．\n\n\nCode\ndef func_pq(x):\n    a = - (P[0] - Q[0]) / (P[1] - Q[1])\n    b = - a * (P[0] + Q[0]) / 2 + (P[1] + Q[1]) / 2\n\n    return a*x + b\n\ndef func_pr(x):\n    a = - (P[0] - R[0]) / (P[1] - R[1])\n    b = - a * (P[0] + R[0]) / 2 + (P[1] + R[1]) / 2\n\n    return a*x + b\n\nx_lin = np.array([0, 6])\ntriangles = [[0, 1, 2]]\nx_trinagle = [P[0], Q[0], R[0]]\ny_trinagle = [P[1], Q[1], R[1]]\ntriang = mtri.Triangulation(x_trinagle, y_trinagle, triangles)\n\n\n\n# plot\nfig, ax = plt.subplots(figsize=(8, 6))\nax.grid()\nax.set_aspect(\"equal\")\nax.set_xlim(0, 6)\nax.set_ylim(-2.5, 3.5)\nax.plot(x_lin, func_pq(x_lin), label='PQ Perpendicular bisector', linestyle='--', color='gray')\nax.plot(x_lin, func_pr(x_lin), label='PR Perpendicular bisector', linestyle=':', color='gray')\n\n\nax.plot(x, y)\nax.scatter(*O, s=8, color=\"k\")\nax.scatter(*P, s=8, color=\"k\")\nax.scatter(*Q, s=8, color=\"k\")\nax.scatter(*R, s=8, color=\"k\")\nax.text(*O, s=\"O\",  ha='center', va='bottom')\nax.text(*P, s=\"P\",  ha='center', va='bottom')\nax.text(*Q, s=\"Q\", ha='left', va='bottom')\nax.text(*R, s=\"R\", ha='left', va='bottom')\n\n# add lines\nax.triplot(triang, 'ko-')\n\nplt.legend(loc='center left', bbox_to_anchor=(1, 0.95))\nplt.show()\n\n\n\n\n\n\n\n\n\n\\(PQ\\) の垂直二等分線 \\(f(x)\\) は\n\\[\n\\begin{align}\nf(x)\n    &= -\\frac{P_x - Q_x}{P_y - Q_y}x + \\frac{P_y + Q_y}{2} + \\frac{P_x - Q_x}{P_y - Q_y} \\frac{P_x + Q_y}{2}\\\\\n    &= -\\frac{P_x - Q_x}{P_y - Q_y}x + \\frac{P_x^2 - Q_x^2 + P_y^2 - Q_y^2}{2(P_y - Q_y)}\n\\end{align}\n\\]\n同様に \\(PR\\) の垂直二等分線 \\(g(x)\\) は\n\\[\n\\begin{align}\ng(x)\n    &= -\\frac{P_x - R_x}{P_y - R_y}x + \\frac{P_y + R_y}{2} + \\frac{P_x - R_x}{P_y - R_y} \\frac{P_x + R_y}{2}\\\\\n    &= -\\frac{P_x - R_x}{P_y - R_y}x + \\frac{P_x^2 - R_x^2 + P_y^2 - R_y^2}{2(P_y - R_y)}\n\\end{align}\n\\]\nここから \\(f(x), g(x)\\) が交差する点を求めることで外接円の円心を求めることが出来ます．\n少しめんどくさいので，数値計算で説いてみると\n\n\nCode\na = - (P[0] - Q[0]) / (P[1] - Q[1])\nb = - a * (P[0] + Q[0]) / 2 + (P[1] + Q[1]) / 2\nc = - (P[0] - R[0]) / (P[1] - R[1])\nd = - c * (P[0] + R[0]) / 2 + (P[1] + R[1]) / 2\n\nprint((d-b)/(a-c), a * (d-b)/(a-c) + b)\n\n\n3.0 0.5\n\n\n\\(\\eqref{#eq-ans1}\\) と一致する計算結果となることが確かめられました．\n\n📘 REMARKS \n上記の垂直二等分線の交点を \\((x_0, y_0)\\) としたとき，整理すると以下のようになります．\n\\[\nA = \\left(\\begin{array}{cc}\nR_y - Q_y & -(P_y - Q_y)\\\\\n-(R_x - Q_x) & P_x - Q_x\\\\\n\\end{array}\\right)\n\\]\nとしたとき，\n\\[\n\\left(\\begin{array}{c}\nx_0\\\\\ny_0\n\\end{array}\\right)\n    = \\frac{1}{\\operatorname{det}A} A\\left(\\begin{array}{c}\n(P_x^2 - Q_x^2 + P_y^2 - Q_y^2)/2\\\\\n(R_x^2 - Q_x^2 + R_y^2 - Q_y^2)/2\n\\end{array}\\right)\n\\]\n実際に計算してみると\n\n\nCode\nA_array = np.array([[R[1] - Q[1], -(P[1] - Q[1])], [-(R[0] - Q[0]), P[0] - Q[0]]])\nB_array = np.array(\n    [\n        [(P[0]**2 - Q[0]**2 + P[1]**2 - Q[1]**2) / 2],\n        [(R[0]**2 - Q[0]**2 + R[1]**2 - Q[1]**2) / 2],\n    ]\n)\n\nresult = np.ravel((A_array @ B_array) / np.linalg.det(A_array))\nradius = np.sqrt(np.sum((np.array(P) - result) **2))\nprint(f\"中心点 = ({result}), 半径 = {radius}\")\n\n\n中心点 = ([3.  0.5]), 半径 = 2.5"
  },
  {
    "objectID": "posts/2025-03-02-find-coordinates/index.html#敵の砲台の座標を探せ",
    "href": "posts/2025-03-02-find-coordinates/index.html#敵の砲台の座標を探せ",
    "title": "敵の砲台の座標を探せ 1/N",
    "section": "敵の砲台の座標を探せ",
    "text": "敵の砲台の座標を探せ\n\n\nExercise 1 \nとある固定の１地点から自軍領地に対して敵が砲撃をかけてきているとします. 敵の砲台は角度のみを調整できるだけで，砲撃予定距離 \\(r\\) は一定とします．ただし，実際の砲撃距離は風向などの外乱要因によってノイズが混じっているとします．\nとある日に敵から50回の攻撃を受けたとき，その砲台座標を推定してください．砲撃のノイズは\\(\\operatorname{i.i.d}\\)とする．\n\n\n\\(\\eqref{#eq-basemodel}\\) より\n\\[\n\\begin{align}\nz_i = - x_i^2 - y_i^2\n\\end{align}\n\\]\nと定義すると，\\(e_i\\) をresidualとして\n\\[\nz_i = \\beta_0 + \\beta_1 x_i + \\beta_2 y_i + e_i\n\\]\nについて \\((\\beta_0, \\beta_1, \\beta_2)\\) をLinear modelで推定し，その推定値を \\((\\hat\\beta_0, \\hat\\beta_1, \\hat\\beta_2)\\) と表せば 敵の砲台の推定座標 \\((\\hat x, \\hat y)\\) 及び推定距離 \\(\\hat r\\) は\n\\[\n\\begin{align}\n\\hat x &= -\\hat\\beta_1/2\\\\\n\\hat y &= -\\hat\\beta_2/2\\\\\n\\hat r &= \\sqrt{\\hat x^2 + \\hat y^2 - \\hat\\beta_0}\n\\end{align}\n\\]\nと計算できそうに思えます．\n ▶  Data Generating Process\n\n敵の砲台の座標は \\((0, 0)\\)\n敵は \\((0, 0)\\) の地点から砲撃距離 \\(20\\) で攻撃してくる\n実際の砲撃距離 \\(r \\sim N(20, 1)\\)\n砲撃角度は \\(\\left[\\displaystyle{\\frac{\\pi}{3}, \\frac{\\pi}{2}}\\right]\\) の範囲で一様分布で定まる\n\nというData Generating Processとします．\n\n\nCode\ndef gdp(x_0: float, y_0: float, noise: float = 1.0, radius: float = 20,  attack_num: int = 50):\n    # params\n    theta = np.random.uniform(np.pi/3 , np.pi/2 , attack_num)\n    r = radius + np.random.normal(0, noise, attack_num)\n\n    x = np.cos(theta) * r + x_0\n    y = np.sin(theta) * r + y_0\n\n    return x, y\n\n\nこのGDPに従う形で攻撃されたとするとき，その散布図は以下のようになります．\n\n\nCode\nnp.random.seed(42)\n\nx_attack, y_attack = gdp(0, 0)\n\nfig, ax = plt.subplots()\nax.scatter(x_attack, y_attack)\nax.set_xlim(-1, np.max([np.max(x_attack), np.max(y_attack)]) + 1)\nax.set_ylim(-1, np.max([np.max(x_attack), np.max(y_attack)]) + 1)\nax.grid()\nax.set_aspect('equal')\nplt.show()\n\n\n\n\n\n\n\n\n\n ▶  OLS Monte Carlo Simulation\nOLSによるパラメータ推定値を \\(1,000\\) 回simulationし，その組み合わせをkde plotしたものが以下となります．x座標についてバイアスがあることがわかります． 砲撃距離に関しても不自然な推定値となっています．\n\n\nCode\nimport pandas as pd\nimport statsmodels.api as sm\nimport seaborn as sns\n\ndef gpd_dataframe(x: float = 0, y: float = 0, noise: float = 1.0):\n    x_attack, y_attack = gdp(x, y, noise)\n    df = pd.DataFrame(\n        {\n            \"x_coordinate\": x_attack,\n            \"y_coordinate\": y_attack,\n        }\n    )\n\n    return df\n\n\ndef ols_solver(\n    df: pd.DataFrame, xy_columns: tuple[str] = (\"x_coordinate\", \"y_coordinate\")\n):\n    Y = -(df[xy_columns[0]] ** 2) - df[xy_columns[1]]\n    X = sm.add_constant(df.loc[:, xy_columns])\n\n    # regression\n    model = sm.OLS(Y, X)\n    results = model.fit()\n\n    # convert estimates to target params\n    x_hat = -results.params[xy_columns[0]] / 2\n    y_hat = -results.params[xy_columns[1]] / 2\n    r_hat_sqr = (x_hat**2 + y_hat**2 - results.params['const'])\n    r_hat = np.sqrt(r_hat_sqr) if r_hat_sqr &gt; 0 else np.nan\n\n    return [x_hat, y_hat, r_hat]\n\n\ndef estimator_simulator(func, noise: float = 1.0, iter: int = 1000):\n    res = list(map(lambda x: func(gpd_dataframe(0, 0, noise)), range(iter)))\n    return np.array(res)\n\nfig, ax = plt.subplots(1, 2)\n\nols_res = estimator_simulator(ols_solver)\nsns.kdeplot(x=ols_res[:, 0], y=ols_res[:, 1], cmap=\"Blues\", fill=True, ax=ax[0])\nsns.kdeplot(x=ols_res[:, 2], cmap=\"Blues\", fill=True, ax=ax[1])\n\n# Show the plot\nax[0].set_xlabel(\"estimated x coordinate\")\nax[0].set_ylabel(\"estimated y coordinate\")\nax[0].set_aspect('equal')\nax[0].set_title(\"OLS 2D Density Plot\\nwith 1000 iterations\")\nax[1].set_title(\"Raidus Density Plot\\nwith 1000 iterations\")\nplt.show()\n\n\n\n\n\n\n\n\n\nそもそも \\(r_i = 20 + \\epsilon_i\\) と決定されていますが\n\\[\n\\beta_0 = a^2 + b^2 - (r + \\epsilon_i)^2\n\\]\nで決定されており，これを踏まえて OLSのモデルを見てみると\n\\[\nz_i = \\left(a^2 + b^2 - r^2 - \\epsilon_i^2 - 2r\\epsilon \\right) - 2ax_i - 2by_i\n\\]\nとなるので，そもそもunbiasedな推定量になっていないと判断できます\n ▶  Regression with MLE\n\\(\\eqref{#eq-circle}\\) に則り，もっと直接的に\n\\[\nL(\\beta) = (\\sqrt{(x_i - \\beta_1)^2 + (y_i - \\beta_2)^2} - \\beta_0)^2\n\\]\nを最小する形でパラメーターを推定してみます．このとき．residualが\\(N(0, \\sigma)\\) に従うならばLikelihoodは\n\\[\nf(X_i\\vert \\beta, \\sigma) = \\frac{1}{\\sqrt{2\\pi}\\sigma}\\exp\\left(-\\frac{L(\\beta)}{2\\sigma^2}\\right)\n\\]\nと表せるので，これを用いて解いてみます．\n\n\nCode\nimport numpy as np\nfrom scipy.optimize import minimize\n\n\ndef lik(parameters, x, y):\n    x_0 = parameters[0]\n    y_0 = parameters[1]\n    r_0 = parameters[2]\n    sigma = parameters[3]\n    g_x = (np.sqrt((np.sqrt((x - x_0) ** 2 + (y - y_0) ** 2) - r_0)**2)) ** 2\n\n    L = len(x) / 2 * np.log(sigma**2) +  1 / (2 * sigma**2) * np.sum(g_x)\n    return L\n\n\ndef mle_solver(\n    df: pd.DataFrame, xy_columns: tuple[str] = (\"x_coordinate\", \"y_coordinate\")\n):\n\n    x_attack = df[xy_columns[0]].values\n    y_attack = df[xy_columns[1]].values\n    lik_model = minimize(\n        lambda params: lik(params, x_attack, y_attack),\n        np.array([1, 1, 20, 1]),\n        method=\"L-BFGS-B\",\n    )\n    return lik_model[\"x\"]\n\n\nmle_res = estimator_simulator(mle_solver)\n\n# plot\nfig, axes= plt.subplots(1, 2)\n\nsns.kdeplot(x=mle_res[:, 0], y=mle_res[:, 1], cmap=\"Blues\", fill=True, ax=axes[0])\nsns.kdeplot(x=mle_res[:, 2], cmap=\"Blues\", fill=True, ax=axes[1])\n\n# Show the plot\naxes[0].set_xlabel(\"estimated x coordinate\")\naxes[0].set_ylabel(\"estimated y coordinate\")\naxes[0].set_title(\"MLE 2D Density Plot\\nwith 1000 iterations\")\naxes[0].set_aspect(\"equal\")\naxes[1].set_title(\"Raidus Density Plot\\nwith 1000 iterations\")\n\nplt.show()\n\n\n\n\n\n\n\n\n\n定式化は正しいはずですが，\\((x_0, y_0, r_0)\\) は効率的な推定量となっていない疑いがあることが読み取れます．\n次に，\n\\[\nL(\\beta) = \\sqrt{(x_i - \\beta_1)^2 + (y_i - \\beta_2)^2 - \\beta_0^2} \\label{#eq-mle}\n\\]\nをLoss functionとして推定してみます．\n\n\nCode\nimport numpy as np\nfrom scipy.optimize import minimize\n\n\ndef lik(parameters, x, y):\n    x_0 = parameters[0]\n    y_0 = parameters[1]\n    r_0 = parameters[2]\n    sigma = parameters[3]\n    g_x = (x - x_0) ** 2 + (y - y_0) ** 2 - r_0**2\n\n    L = len(x) / 2 * np.log(sigma**2) +  1 / (2 * sigma**2) * np.sum(g_x)\n    return L\n\n\ndef mle_solver(\n    df: pd.DataFrame, xy_columns: tuple[str] = (\"x_coordinate\", \"y_coordinate\")\n):\n\n    x_attack = df[xy_columns[0]].values\n    y_attack = df[xy_columns[1]].values\n    lik_model = minimize(\n        lambda params: lik(params, x_attack, y_attack),\n        np.array([1, 1, 20, 1]),\n        method=\"L-BFGS-B\",\n    )\n    return lik_model[\"x\"]\n\n\nmle_res = estimator_simulator(mle_solver)\n\n# plot\nfig, axes= plt.subplots(1, 2)\n\nsns.kdeplot(x=mle_res[:, 0], y=mle_res[:, 1], cmap=\"Blues\", fill=True, ax=axes[0])\nsns.kdeplot(x=mle_res[:, 2], cmap=\"Blues\", fill=True, ax=axes[1])\n\n# Show the plot\naxes[0].set_xlabel(\"estimated x coordinate\")\naxes[0].set_ylabel(\"estimated y coordinate\")\naxes[0].set_title(\"MLE 2D Density Plot\\nwith 1000 iterations\")\naxes[0].set_aspect(\"equal\")\naxes[1].set_title(\"Raidus Density Plot\\nwith 1000 iterations\")\n\nplt.show()\n\n\n\n\n\n\n\n\n\n先程よりは精度良く推定できているように見えますが，\\(\\eqref{#eq-mle}\\) は\n\\[\nL(\\beta) = \\sqrt{\\epsilon_i^2 + 2\\beta_0 \\epsilon_i}\n\\]\nとなるので，そもそもMLEの定式化が間違っていることがわかります．また，\\(\\beta_0\\) が大きいほどresidualが大きくなる傾向があることから，unbiasedな推定量は得られていないことがわかります．\n ▶  Regression with stan\ncmdstanを用いて砲台座標を推定する例を紹介します．まずstan modelを以下のように設定します．\n\n砲撃距離のノイズについて \\(N(0, 1)\\) であることが既にわかっている状況を想定\n予定砲撃距離 \\(r_0\\) は \\(\\operatorname{Uniform}(2, 30)\\) の事前分布がある\n\ndata {\n    int&lt;lower=1&gt; N;  // Number of data points\n    array[N] real y; // outcomes\n    array[N] real x; // outcomes\n}\n\nparameters {\n    real&lt;lower=0&gt; r_0; // probability of success\n    real x_0;             // Center x-coordinate\n    real y_0;             // Center y-coordinate\n}\n\nmodel {\n    // priors\n    r_0 ~ uniform(2, 30);\n    real sigma = 1;\n\n    // objective loss\n    array[N] real circle_equation;\n    for (i in 1:N) {\n        circle_equation[i] = sqrt((x[i] - x_0)^2 + (y[i] - y_0)^2) - r_0;\n    }\n\n    circle_equation ~ normal(0, sigma);\n}\nその後，このモデルを用いて推定したものが以下となります．\n\nfrom cmdstanpy import CmdStanModel\n\ndf_stan = gpd_dataframe(0, 0, 1)\ndata = {\n    \"N\": df_stan.shape[0],\n    \"y\": df_stan.y_coordinate.values,\n    \"x\": df_stan.x_coordinate.values,\n    \"sigma\": 1,\n}\n\nmodel = CmdStanModel(stan_file=\"./stanmodel.stan\")\nfit = model.sample(data=data, seed=42)\nfit.summary()\n\n01:27:30 - cmdstanpy - INFO - compiling stan file /home/runner/work/regmonkey-datascience-blog/regmonkey-datascience-blog/posts/2025-03-02-find-coordinates/stanmodel.stan to exe file /home/runner/work/regmonkey-datascience-blog/regmonkey-datascience-blog/posts/2025-03-02-find-coordinates/stanmodel\n01:27:36 - cmdstanpy - INFO - compiled model executable: /home/runner/work/regmonkey-datascience-blog/regmonkey-datascience-blog/posts/2025-03-02-find-coordinates/stanmodel\n01:27:36 - cmdstanpy - INFO - CmdStan start processing\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n                                                                                                                                                                                                                                                                                                                                \n\n\n01:27:38 - cmdstanpy - INFO - CmdStan done processing.\n01:27:38 - cmdstanpy - WARNING - Some chains may have failed to converge.\n    Chain 1 had 310 divergent transitions (31.0%)\n    Chain 2 had 341 divergent transitions (34.1%)\n    Chain 3 had 293 divergent transitions (29.3%)\n    Chain 4 had 320 divergent transitions (32.0%)\n    Use the \"diagnose()\" method on the CmdStanMCMC object to see further information.\n\n\n\n\n\n\n\n\n\n\n\n\nMean\nMCSE\nStdDev\nMAD\n5%\n50%\n95%\nESS_bulk\nESS_tail\nESS_bulk/s\nR_hat\n\n\n\n\nlp__\n-22.627700\n0.044144\n1.21901\n0.873056\n-25.04740\n-22.267300\n-21.44630\n886.907\n1292.320\n385.9470\n1.00150\n\n\nr_0\n20.167700\n0.429917\n6.21166\n7.274600\n9.15980\n20.889900\n29.01690\n208.133\n258.641\n90.5715\n1.01911\n\n\nx_0\n0.151580\n0.131551\n1.88887\n1.973320\n-3.05708\n0.195962\n3.10467\n199.727\n234.533\n86.9133\n1.02554\n\n\ny_0\n-0.299075\n0.419656\n6.11452\n7.154330\n-8.93022\n-1.015920\n10.49840\n220.608\n278.533\n96.0001\n1.01959\n\n\n\n\n\n\n\nCredible intervalを見ると \\((0, 0)\\) は推定区間に含まれている一方，Mean, Medianともに \\(y_0\\) の方は乖離した値が推定されてしまっています．"
  },
  {
    "objectID": "posts/2025-12-27-parquet-tools-query/index.html",
    "href": "posts/2025-12-27-parquet-tools-query/index.html",
    "title": "parquet-toolsコマンド",
    "section": "",
    "text": "Note実行例について\n\n\n\n\nコマンド実行の引数で用いているファイルはこちらのGoogle Driveに格納しています\nコマンドを試す場合は事前にダウンロードしてください"
  },
  {
    "objectID": "posts/2025-12-27-parquet-tools-query/index.html#parquet-toolsとは",
    "href": "posts/2025-12-27-parquet-tools-query/index.html#parquet-toolsとは",
    "title": "parquet-toolsコマンド",
    "section": "parquet-toolsとは？",
    "text": "parquet-toolsとは？\n\nparquet-toolsは，Parquetファイルを操作するためのコマンドラインツール\nPythonで実装\n\n主な機能\n\n\nparquet-toolsのコマンド一覧\n\n\n\n\n\n\nコマンド\n機能\n\n\n\n\nhead\nParquetファイルの先頭N行を表示\n\n\ninfo\nメタデータとスキーマ情報を表示\n\n\nmerge\n複数のParquetファイルを1つに統合\n\n\ncsv2parquet\nCSVファイルをParquet形式に変換\n\n\nquery\nDuckDBを使用してSQLクエリを実行\n\n\n\n\nインストール\nuvを使用してインストールすることを想定しています\nuv tool install https://github.com/RyoNakagami/parquet-tools.git\nまたは、uvxを使って直接実行することも可能です．\nuvx --from git+https://github.com/RyoNakagami/parquet-tools.git parquet-tools &lt;command&gt;"
  },
  {
    "objectID": "posts/2025-12-27-parquet-tools-query/index.html#headコマンド",
    "href": "posts/2025-12-27-parquet-tools-query/index.html#headコマンド",
    "title": "parquet-toolsコマンド",
    "section": "headコマンド",
    "text": "headコマンド\n\nDefinition 1 head コマンド\n\nParquetファイルの先頭N行を表示\nデフォルトでは10行を表示\nスペース区切り\n基本的には簡易的に値を確認するデバッグ用のコマンド\n\n\n# 先頭10行を表示（デフォルト）\nparquet-tools head &lt;parquet-file&gt;\n\n# 先頭5行を表示\nparquet-tools head -n 5 &lt;parquet-file&gt;\n\n# CSVファイルとして出力\nparquet-tools head -n 100 &lt;parquet-file&gt; -o output.csv\nOptions\n\n\n\nオプション\n説明\n\n\n\n\n-n, --rows\n表示する行数を指定（デフォルト: 10）\n\n\n-o, --output\n出力先のCSVファイルパス"
  },
  {
    "objectID": "posts/2025-12-27-parquet-tools-query/index.html#infoコマンド",
    "href": "posts/2025-12-27-parquet-tools-query/index.html#infoコマンド",
    "title": "parquet-toolsコマンド",
    "section": "infoコマンド",
    "text": "infoコマンド\n\nDefinition 2 info コマンド\n\nParquetファイルのメタデータとスキーマ情報を表示\nyaml, json形式での出力が可能\n\n\n# 基本的な使用方法\nparquet-tools info &lt;parquet-file&gt;\n\n# YAML形式で出力\nparquet-tools info --yaml &lt;parquet-file&gt;\n\n# JSON形式で出力\nparquet-tools info --json &lt;parquet-file&gt;\noptions\n\n\n\n\nオプション\n説明\n\n\n\n\n--yaml\nYAML形式で出力\n\n\n--json\nJSON形式で出力\n\n\n\n\n\nExample 1 (全国医療施設情報のスキーマ確認) \n以下のコマンドから次のような情報が読み取れます\n\nRows = 7,640\nColumns = 65\nRow Groups = 1\n\nParquet ファイルは 1つの Row Group（行グループ） で構成されている\nParquet の物理ストレージ単位(並列処理の単位)\n\nCompression = SNAPPY\nApache Arrow C++ v22.0.0 を使って Parquet ファイルが作成\n\n$ parquet-tools info 01-1_hospital_facility_info_20251201.parquet \n=== File Info ===\nPath: 01-1_hospital_facility_info_20251201.parquet\nRows: 7,640\nColumns: 65\nRow Groups: 1\nCompression: SNAPPY\nCreated By: parquet-cpp-arrow version 22.0.0\n\n=== Schema ===\n  ID: string\n  正式名称: string\n  正式名称（フリガナ）: string\n  略称: string\n  略称（フリガナ）: string\n  英語表記（ローマ字表記）: string\n  機関区分: string\n  都道府県コード: string\n  市区町村コード: string\n  所在地: string\n  所在地座標（緯度）: double\n  所在地座標（経度）: double\n  案内用ホームページアドレス: string\n  毎週決まった曜日に休診（月）: bool\n  毎週決まった曜日に休診（火）: bool\n  毎週決まった曜日に休診（水）: bool\n  毎週決まった曜日に休診（木）: bool\n  毎週決まった曜日に休診（金）: bool\n  毎週決まった曜日に休診（土）: bool\n  毎週決まった曜日に休診（日）: bool\n  決まった週に休診（定期週）第1週（月）: bool\n  決まった週に休診（定期週）第1週（火）: bool\n  決まった週に休診（定期週）第1週（水）: bool\n  決まった週に休診（定期週）第1週（木）: bool\n  決まった週に休診（定期週）第1週（金）: bool\n  決まった週に休診（定期週）第1週（土）: bool\n  決まった週に休診（定期週）第1週（日）: bool\n  決まった週に休診（定期週）第2週（月）: bool\n  決まった週に休診（定期週）第2週（火）: bool\n  決まった週に休診（定期週）第2週（水）: bool\n  決まった週に休診（定期週）第2週（木）: bool\n  決まった週に休診（定期週）第2週（金）: bool\n  決まった週に休診（定期週）第2週（土）: bool\n  決まった週に休診（定期週）第2週（日）: bool\n  決まった週に休診（定期週）第3週（月）: bool\n  決まった週に休診（定期週）第3週（火）: bool\n  決まった週に休診（定期週）第3週（水）: bool\n  決まった週に休診（定期週）第3週（木）: bool\n  決まった週に休診（定期週）第3週（金）: bool\n  決まった週に休診（定期週）第3週（土）: bool\n  決まった週に休診（定期週）第3週（日）: bool\n  決まった週に休診（定期週）第4週（月）: bool\n  決まった週に休診（定期週）第4週（火）: bool\n  決まった週に休診（定期週）第4週（水）: bool\n  決まった週に休診（定期週）第4週（木）: bool\n  決まった週に休診（定期週）第4週（金）: bool\n  決まった週に休診（定期週）第4週（土）: bool\n  決まった週に休診（定期週）第4週（日）: bool\n  決まった週に休診（定期週）第5週（月）: bool\n  決まった週に休診（定期週）第5週（火）: bool\n  決まった週に休診（定期週）第5週（水）: bool\n  決まった週に休診（定期週）第5週（木）: bool\n  決まった週に休診（定期週）第5週（金）: bool\n  決まった週に休診（定期週）第5週（土）: bool\n  決まった週に休診（定期週）第5週（日）: bool\n  祝日に休診: bool\n  その他の休診日（gw、お盆等）: string\n  一般病床: int64\n  療養病床: int64\n  療養病床のうち医療保険適用: int64\n  療養病床のうち介護保険適用: int64\n  精神病床: int64\n  結核病床: int64\n  感染症病床: int64\n  一般病床: int64"
  },
  {
    "objectID": "posts/2025-12-27-parquet-tools-query/index.html#csv2parquetコマンド",
    "href": "posts/2025-12-27-parquet-tools-query/index.html#csv2parquetコマンド",
    "title": "parquet-toolsコマンド",
    "section": "csv2parquetコマンド",
    "text": "csv2parquetコマンド\n\nDefinition 3 csv2parquet コマンド\n\nCSVファイルをParquet形式に変換\nスキーマファイルを指定することで，列の型を明示的に定義可能\n\n\n# 基本的な使用方法（型は自動推論）\nparquet-tools csv2parquet input.csv -o output.parquet\n\n# スキーマファイルを指定\nparquet-tools csv2parquet input.csv -o output.parquet --schema schema.yaml\n\n# 圧縮コーデックを指定\nparquet-tools csv2parquet input.csv -o output.parquet --compression zstd\nOptions\n\n\n\n\nオプション\n説明\n\n\n\n\n-o, --output\n出力ファイルパス（必須）\n\n\n--schema\nスキーマファイルパス（YAML または JSON）\n\n\n--compression\n圧縮コーデック（snappy, zstd, gzip, lz4, none）\n\n\n\n\nスキーマファイルの例（YAML）\nfields:\n  - name: id\n    type: int64\n  - name: name\n    type: string\n  - name: price\n    type: float64\n  - name: is_available\n    type: boolean\n  - name: created_at\n    type: timestamp\n  - name: birth_date\n    type: date\n対応する型\n\n\n\n型\n説明\n\n\n\n\nstring\n文字列型\n\n\nint64\n64ビット整数型\n\n\nfloat64\n64ビット浮動小数点型\n\n\nboolean\n真偽値型\n\n\ntimestamp\nタイムスタンプ型\n\n\ndate\n日付型\n\n\n\n空文字列，NA、nullなどは自動的にnull値に変換されます"
  },
  {
    "objectID": "posts/2025-12-27-parquet-tools-query/index.html#queryコマンド",
    "href": "posts/2025-12-27-parquet-tools-query/index.html#queryコマンド",
    "title": "parquet-toolsコマンド",
    "section": "queryコマンド",
    "text": "queryコマンド\n\nDefinition 4 query コマンド\n\nDuckDBを使用して，ParquetファイルにSQLクエリを実行するコマンド\nParquetファイルは data というテーブル名で参照\n--sql-file をつかうことでSQLファイルを実行させることができる\n\n\n# 基本的なクエリ\nparquet-tools query \"SELECT * FROM data LIMIT 10\" data.parquet\n\n# 条件付きクエリ\nparquet-tools query \"SELECT id, name FROM data WHERE value &gt; 100\" data.parquet\n\n# 集計クエリ\nparquet-tools query \"SELECT category, COUNT(*) as cnt FROM data GROUP BY category\" data.parquet\n\n# 結果をCSVに出力\nparquet-tools query \"SELECT * FROM data\" data.parquet -o result.csv\nOptions\n\n\n\n\nオプション\n説明\n\n\n\n\n-o, --output\n結果をCSVファイルに出力\n\n\n--sql-file\n実行するSQLをファイルから読み込む\n\n\n\n\n\nExample 2 (全国医療施設情報のデータ確認) \n都道府県ごとに\n\n医療施設の数（distinct，クリニックは除く）\n病床数の合計\n1施設あたり平均病床数\n病床数の母標準偏差（施設間のばらつき）\n\nを計算して，都道府県コード順に並べてみたいと思います．\n$ parquet-tools query 01-1_hospital_facility_info_20251201.parquet \"\nSELECT\n  CAST(都道府県コード AS INT) AS prefecture_code,\n  COUNT(DISTINCT ID) AS facility_count,\n  SUM(一般病床) AS total_beds,\n  AVG(一般病床) AS avg_beds_per_facility,\n  STDDEV_POP(一般病床) AS std_beds_per_facility\nFROM data\nGROUP BY 都道府県コード\n\nUNION ALL\n\n-- 全国\nSELECT\n  0 AS prefecture_code,          -- 全国を 0 として表現\n  COUNT(DISTINCT ID) AS facility_count,\n  SUM(一般病床) AS total_beds,\n  AVG(一般病床) AS avg_beds_per_facility,\n  STDDEV_POP(一般病床) AS std_beds_per_facility\nFROM data\n\nORDER BY prefecture_code\n\"\n\n    prefecture_code  facility_count  total_beds  avg_beds_per_facility  std_beds_per_facility\n0                 0            7640    842371.0             132.115903             163.389970\n1                 1             436     41523.0             129.759375             134.619283\n2                 2              83      8942.0             154.172414             151.051731\n3                 3              84      9454.0             113.903614             147.797697\n4                 4             134     14829.0             154.468750             175.811568\n5                 5              63      7699.0             202.605263             158.547941\n6                 6              66      7955.0             122.384615             166.080026\n7                 7             119     14408.0             169.505882             185.842857\n8                 8             164     17379.0             126.854015             148.012257\n9                 9              59      7354.0             222.848485             276.448924\n10               10             127     14097.0             121.525862             128.509792\n11               11             327     37466.0             153.549180             168.478952\n12               12             269     35469.0             177.345000             171.913833\n13               13             592     80034.0             145.781421             197.228695\n14               14             310     45187.0             195.614719             184.881976\n15               15             114     14961.0             170.011364             155.021809\n16               16             102      7759.0             146.396226             158.023564\n17               17              88      9442.0             162.793103             174.859624\n18               18              67      6117.0              91.298507             132.949437\n19               19              60      6216.0             135.130435             129.769965\n20               20             121     14679.0             149.785714             141.969834\n21               21              94     12628.0             134.340426             169.380382\n22               22             167     20819.0             129.310559             183.584301\n23               23             303     39329.0             189.081731             220.297260\n24               24              91     10898.0             167.661538             157.961269\n25               25              57      8946.0             208.046512             173.366926\n26               26             127     19116.0             178.654206             184.586180\n27               27             482     63012.0             130.730290             167.346071\n28               28             332     39045.0             151.337209             154.044638\n29               29              72      9856.0             158.967742             159.517717\n30               30              80      8110.0             128.730159             137.651182\n31               31              39      4401.0             169.269231             156.062748\n32               32              46      4969.0             150.575758             140.275493\n33               33             155     17420.0             113.116883             181.092319\n34               34             224     20617.0             128.856250             141.973318\n35               35             133     10274.0             133.428571             145.708250\n36               36             103      6217.0              60.950980             107.673014\n37               37              86      8477.0             136.725806             149.489148\n38               38             131     11284.0             120.042553             138.629916\n39               39             118      7615.0             101.533333             115.125709\n40               40             444     43096.0              97.063063             149.968137\n41               41              93      6121.0              66.532609             102.199767\n42               42             143     11296.0              80.113475             124.087712\n43               43             199     16210.0              81.457286             120.348017\n44               44             147     11663.0              80.434483              98.114628\n45               45             118      8452.0              73.495652              99.268750\n46               46             207     13721.0              66.931707             106.618743\n47               47              64      7809.0             177.477273             158.422692\n結果の解釈\n\n\n\n\n\n\n\n\n観点\n結果(数値)\n\n\n\n\n施設数が多い都道府県\n東京（592），大阪（482），福岡（444），北海道（436）\n\n\n施設数が少ない都道府県\n鳥取（39），島根（46），滋賀（57）\n\n\n平均一般病床数が多い都道府県\n栃木（222.8），滋賀（208.0），秋田（202.6）\n\n\n平均一般病床数が少ない都道府県\n徳島（61.0），佐賀（66.5），鹿児島（66.9）\n\n\n標準偏差が大きい都道府県\n栃木（276.4），愛知（220.3），東京（197.2）\n\n\n\n\n\n施設数は人口規模に概ね比例しており，東京・大阪・福岡などの大都市圏で多い\n平均一般病床数は地域差が大きく，栃木県が最も高い（222.8床/施設）\n栃木県（9）は標準偏差が276.4と突出して大きく，施設間格差が大きい\n\n大規模な急性期病院と中小病院が混在している可能性\n\n九州地方（福岡(40)，佐賀(41)，長崎(42)，熊本(43)，大分(44)，宮崎(45)，鹿児島(46)）は平均一般病床数が低い傾向\n北海道（1）は施設数436で全国4位だが，平均一般病床数は129.8床/施設と全国平均（132.1床）を下回る\n沖縄（47）は平均一般病床数177.5床/施設と比較的高い\n\n離島が多く本島の基幹病院に急性期医療が集約されている可能性\n\n\n\n\n\nExample 3 (都道府県別中心座標からの平均距離及び分散) \n\n各都道府県内の医療施設が地理的にどの程度分散しているかを確認するため，都道府県内の施設座標の重心（centroid）からの平均距離と標準偏差を計算\n座標データには異常値が含まれている可能性があるため，日本の緯度経度範囲（緯度: 24〜46度，経度: 122〜154度）でフィルタリング\n\nそのため，施設数について上記の結果と比べ変動あり\n\n\n$ parquet-tools query 01-1_hospital_facility_info_20251201.parquet \"\nWITH base AS (\n  SELECT\n    CAST(都道府県コード AS INT) AS prefecture_code,\n    ID,\n    \"所在地座標（緯度）\" AS lat,\n    \"所在地座標（経度）\" AS lon\n  FROM data\n  WHERE \"所在地座標（緯度）\" BETWEEN 24 AND 46   -- 日本の緯度範囲\n    AND \"所在地座標（経度）\" BETWEEN 122 AND 154 -- 日本の経度範囲\n),\n\ncentroid AS (\n  SELECT\n    prefecture_code,\n    AVG(lat) AS mean_lat,\n    AVG(lon) AS mean_lon\n  FROM base\n  GROUP BY prefecture_code\n),\n\ndistance_calc AS (\n  SELECT\n    b.prefecture_code,\n    -- Haversine distance (km)\n    6371.0 * 2 * ASIN(\n      SQRT(\n        POWER(SIN(RADIANS(b.lat - c.mean_lat) / 2), 2)\n        + COS(RADIANS(c.mean_lat))\n        * COS(RADIANS(b.lat))\n        * POWER(SIN(RADIANS(b.lon - c.mean_lon) / 2), 2)\n      )\n    ) AS distance_km\n  FROM base b\n  JOIN centroid c\n    ON b.prefecture_code = c.prefecture_code\n)\n\nSELECT\n  prefecture_code,\n  COUNT(1) AS facility_count,\n  ROUND(AVG(distance_km), 2) AS avg_distance_km,\n  ROUND(STDDEV_POP(distance_km), 2) AS std_distance_km\nFROM distance_calc\nGROUP BY prefecture_code\nORDER BY prefecture_code;\"\n\n    prefecture_code  facility_count  avg_distance_km  std_distance_km\n0                 1             290            93.77            60.94\n1                 2              83            38.81            13.98\n2                 3              80            40.96            22.72\n3                 4             134            23.42            16.30\n4                 5              63            37.75            20.52\n5                 6              64            34.52            17.36\n6                 7             119            37.82            19.74\n7                 8             162            31.90            15.44\n8                 9              56            20.43            14.87\n9                10             126            18.65            12.69\n10               11             326            19.11             9.78\n11               12             268            24.78            16.60\n12               13             591            15.57            13.64\n13               14             307            15.80             8.60\n14               15             100            42.09            25.37\n15               16             102            15.35             9.29\n16               17              88            23.06            22.74\n17               18              67            19.22            16.72\n18               19              59            13.29            10.62\n19               20             120            36.25            20.10\n20               21              93            25.78            19.02\n21               22             167            43.71            21.01\n22               23             301            21.03            13.13\n23               24              91            27.51            20.31\n24               25              57            17.71             8.90\n25               26             127            18.87            18.05\n26               27             482            13.63             8.94\n27               28             313            27.50            16.74\n28               29              72            10.69             4.60\n29               30              80            27.67            18.25\n30               31              31            32.39            13.85\n31               32              31            48.39            30.18\n32               33             153            22.29            13.41\n33               34             224            34.46            14.96\n34               35             133            35.52            18.83\n35               36             103            17.86            13.18\n36               37              86            16.33             8.85\n37               38             131            32.28            22.05\n38               39             118            26.81            23.16\n39               40             444            27.91            13.92\n40               41              90            19.54             8.50\n41               42             142            34.57            26.55\n42               43             199            25.12            18.66\n43               44             147            24.79            16.57\n44               45             117            34.82            20.59\n45               46             204            51.76            81.11\n46               47              34            25.00            49.11\n結果の解釈\n座標フィルタリング後は，各都道府県の地理的特性を反映した妥当な値が得られます．\n\n\n\n\n\n\n\n\n\n観点\n都道府県（prefecture_code）\n平均距離\n\n\n\n\n施設が分散（広域）\n北海道（1），鹿児島（46），島根（32），静岡（22），新潟（15）\n40〜94km\n\n\n施設が集中（コンパクト）\n奈良（29），大阪（27），山梨（19），東京（13），富山（16）\n10〜16km\n\n\n\n\n\n大阪府(27)は府域が狭く施設が密集しているため，平均距離が小さいと思われる\n北海道(1)は広大な面積に施設が分散しているため，平均距離が大きいという仮設と整合的\n離島を持つ都道府県（沖縄(47)，長崎(42)，鹿児島(46)など）は標準偏差が大きくなる傾向があると思われる"
  },
  {
    "objectID": "posts/2025-12-27-parquet-tools-query/index.html#references",
    "href": "posts/2025-12-27-parquet-tools-query/index.html#references",
    "title": "parquet-toolsコマンド",
    "section": "References",
    "text": "References\n\nGitHub &gt; RyoNakagami/parquet-tools\n厚生労働省 &gt; 医療情報ネットのオープンデータ"
  },
  {
    "objectID": "posts/2021-01-16-apt-personal-package-archive/index.html",
    "href": "posts/2021-01-16-apt-personal-package-archive/index.html",
    "title": "追加されたPersonal Package Archive(PPA)の管理",
    "section": "",
    "text": "この記事はRyo’s Tech Blog &gt; add-apt-repository ppaとはなにか？からの修正版です．"
  },
  {
    "objectID": "posts/2021-01-16-apt-personal-package-archive/index.html#personal-package-archiveppaとはなにか",
    "href": "posts/2021-01-16-apt-personal-package-archive/index.html#personal-package-archiveppaとはなにか",
    "title": "追加されたPersonal Package Archive(PPA)の管理",
    "section": "Personal Package Archive(PPA)とはなにか？",
    "text": "Personal Package Archive(PPA)とはなにか？\n\nDefinition 1 PPA\n\nPPAはPersonal Package Archiveの略称でlaunchpad.netに用意された個人用リポジトリ\nPPAを用いることで，開発者は自由にプログラム配布用のレポジトリを作成することができる.\nユーザーは sources.list へ repositoryの情報を加えるだけ(多くの場合 add-apt-repository コマンドを用いる)で，aptコマンド経由でプログラムが利用可能\n\n\nつまるところ，PPAs（Personal Package Archives）は，標準的なソフトウェア配布チャンネルに含まれないソフトウェアや更新プログラムのために使用されます． 公式のUbuntuリポジトリでは多くのパッケージが提供されていますが，提供されているバージョンが最新バージョンとは限りません．\n\n最新のソフトウェアを使用したい\n最先端の機能にアクセスしたい\n\nというときに，add-apt-repository コマンドを用いて PPA を登録し，packageへアクセスします． PPAを登録すると，apt upgradeでアップグレードの対象となるため，システム全体で一括してアップグレードをかけることができる便利さがあります．\nUbuntu公式レポジトリポリシー\n\nUbuntuの公式リポジトリは，「一度リリースしたら，できる限り同じバージョンのまま不具合修正とセキュリティ対応を行う」という保守方針を取っています\n基本的には，動作安定性の確保から「one release, one package」という関係になっているので，機能追加された最新版packageは新しいpackageとしてリリースされる必要があります\n機能追加のたびに新しいpackageを作る必要があるのでUbuntu公式レポジトリでは多くのpackageが少し古いバージョンになっています\n\n\n\n\n\n\nsequenceDiagram\n    participant Dev as 開発者（ソフトウェア提供者）\n    participant PPA as PPAインフラ（Launchpad）\n    participant User as エンドユーザー\n    participant Ubuntu as Ubuntu公式リポジトリ\n\n    Dev-&gt;&gt;PPA: ソースパッケージのアップロード\n    PPA-&gt;&gt;PPA: 自動でバイナリをビルド\n    PPA--&gt;&gt;User: パッケージの提供（apt経由で）\n    \n    Note right of User: 公式と同じUIで&lt;br/&gt;インストール・アップデート可能\n\n    Dev--&gt;&gt;Ubuntu: 品質の高いPPAを公式提案\n    Ubuntu-&gt;&gt;Ubuntu: 検証・品質チェック and 公式リポジトリに統合\n    Ubuntu--&gt;&gt;User: 公式レポジトリーからの提供\n\n    Note right of Ubuntu: 開発者が作成したPPAを&lt;br/&gt;ベースに採用できる\n\n\n\n\n\n\n\nPPAの追加\nBasic Syntax\nsudo add-apt-repository ppa:&lt;ppa-name&gt;\n追加されたリポジトリの情報は，/etc/apt/sources.list.d ディレクトリ以下に.listファイルとして格納されます．.listファイルの内容例としては\ndeb http://ppa.launchpad.net/c2d4u.team/c2d4u4.0+/ubuntu jammy main\n# deb-src http://ppa.launchpad.net/c2d4u.team/c2d4u4.0+/ubuntu jammy main\n\n\n\n\n\n\n\n\n項目\n内容\n\n\n\n\ndeb\nバイナリパッケージ（.deb）を取得する行\n\n\nhttp://ppa.launchpad.net/...\nPPA の URL（Launchpad にホスト）\n\n\njammy\n対象の Ubuntu バージョン\n\n\nmain\nセクション名（PPAでは基本的に main）\n\n\n# deb-src ...\nソースコード用（多くの場合コメントアウト）\n\n\n\n\n\nExample 1 R setup\nR や CRAN パッケージを最新版をdeb packageとして提供するレポジトリとして，c2d4u.team/c2d4u4.0+ があります．追加コマンドは以下\n# PPAの追加\n% sudo add-apt-repository ppa:c2d4u.team/c2d4u4.0+\n\n# パッケージリスト更新\n% sudo apt update\n\n# R本体をインストール\n% sudo apt install r-base\nまた，/etc/apt/sources.list.d ディレクトリ以下について確認してみると\n% ls /etc/apt/sources.list.d | grep \"c2d4u\"\nc2d4u_team-ubuntu-c2d4u4_0_-jammy.list\n\n\n\n\n可能な限りPPA経由のパッケージインストールは避ける\n\n\n\n\n\n\nWarningPPA利用の注意点\n\n\n\n\nPPAは公式リポジトリのようなチェックは行われないので，品質や信頼性のリスクは追加したユーザー責任\nPPAと公式の両方にパッケージがある場合，PPAに存在するパッケージのバージョンが公式リポジトリのバージョンより高かったら，アップグレード時にPPA版のバージョンに更新されてしまう\n\n\n\nPPAと公式の両方にパッケージがある場合は，どちらも優先度は等しく，どちらが最新バージョンかどうかで利用バージョンが決定されます．PPAが更新された結果，apt updateで意図せずversionが更新されてしまって，依存関係問題から今まで動いていたのにある日突然ソフトが動かなくなったという自体に陥るリスクがあります.\nPPA利用にあたってのチェック項目\n\n\n\n\n\n\n\n\n\nチェック項目\n内容\n推奨される確認方法\n\n\n\n\nPPA作成者の信頼性\nPPAを作成・管理している人物が信頼できるかどうか？\nPPA説明ページや Launchpad のプロフィールを見る\n\n\nPPAが公式に近いかどうか\nCranやLibreOfficeのような公式PPAと、個人が作成したPPAは信頼性が異なる\n公式Webサイトで紹介されているかを確認\n\n\n利用者数\nそのPPAを使用しているユーザーの数と評判\nPPA Stats やLaunchpadコメントなど\n\n\nメンテナンス・更新頻度\nPPAが最近も更新されているか（古いと依存関係の不整合で危険）\nPPAページの「Last updated」や apt policy で確認\n\n\n対応Ubuntuバージョン\n自分のUbuntuバージョンに対応しているか\nPPA内の dists/ ディレクトリ一覧または .list ファイル\n\n\nパッケージの品質\nパッケージが正しくビルドされ、他と競合しないか\n導入前に apt install --simulate で動作確認"
  },
  {
    "objectID": "posts/2021-01-16-apt-personal-package-archive/index.html#ppaの管理",
    "href": "posts/2021-01-16-apt-personal-package-archive/index.html#ppaの管理",
    "title": "追加されたPersonal Package Archive(PPA)の管理",
    "section": "PPAの管理",
    "text": "PPAの管理\n追加されたPPAの確認\n% grep -r ^deb /etc/apt/sources.list.d/ | grep --color ppa\nPPA経由で追加されたpackageの確認\n# インストール済みのパッケージのうち Origin が ppa のもの\n% aptitude search '?narrow(?installed, ~Oppa)'\n\n\n\n\n\n\n\n\n要素\n意味\n\n\n\n\n?narrow(A, B)\n集合 A の中から条件 B を満たすものをさらに絞り込む\n\n\n?installed\n現在インストールされているパッケージだけを対象にする\n\n\n~O&lt;value&gt;\nパッケージの「由来（Origin）」にマッチする（APTのリポジトリ情報）\n\n\n~Oppa\nOrigin が ppa を含むパッケージ（PPA由来のもの）\n\n\n\n\nパッケージの詳細情報取得\napt-cache policy &lt;package-name&gt; でpakcage 情報の詳細を取得できます． *** となっているものが現在インストールされているバージョンとなります．\n% apt-cache policy r-cran-zip                 \nr-cran-zip:\n  Installed: 2.3.0-1cran1.2204.0\n  Candidate: 2.3.0-1cran1.2204.0\n  Version table:\n *** 2.3.0-1cran1.2204.0 500\n        500 https://ppa.launchpadcontent.net/c2d4u.team/c2d4u4.0+/ubuntu jammy/main amd64 Packages\n        100 /var/lib/dpkg/status\n     2.2.0-2 500\n        500 http://jp.archive.ubuntu.com/ubuntu jammy/universe amd64 Packages\n\nPPAの削除\nadd-apt-repository –remove\n## Delete\n% sudo add-apt-repository --remove ppa:PPA_Name/ppa\n\n## Check whether the ppa is actually deleted\n% ls /etc/apt/sources.list.d\n\n/etc/apt/sources.list.d からレポジトリ登録情報を格納した .listファイルが削除されます\n/etc/apt/sources.list.d ディレクトリで直接ファイルを削除するのと実質的に同じ\nあくまでレポジトリ登録を削除するだけ = 追加されたpackage自体は残る\n\nppa-purge\n% sudo ppa-purge ppa:ppa-owner/ppa-name\n\nppa-purgeコマンドはレポジトリ登録の削除と同時に，PPAからインストールしたパッケージを「可能な限り」現在有効なリポジトリにあるパッケージに置き変えてくれるコマンド\nsudo apt-get install ppa-purge が事前に必要\nあくまで置き換えるコマンドなので削除したい場合は sudo apt autoremove コマンドのほうが良いかもしれません"
  },
  {
    "objectID": "posts/2021-01-16-apt-personal-package-archive/index.html#references",
    "href": "posts/2021-01-16-apt-personal-package-archive/index.html#references",
    "title": "追加されたPersonal Package Archive(PPA)の管理",
    "section": "References",
    "text": "References\n\nRyo’s Tech Blog &gt; add-apt-repository ppaとはなにか？\nAsk Ubuntu &gt; Are PPAs safe to add to my system and what are some “red flags” to watch out for?"
  },
  {
    "objectID": "posts/2025-09-03-bash-color-code/index.html",
    "href": "posts/2025-09-03-bash-color-code/index.html",
    "title": "Bashscript Color Code",
    "section": "",
    "text": "Warning\n\n\n\n\nターミナル互換性: すべてのターミナルがすべてのANSIエスケープシーケンスをサポートしているわけではありません"
  },
  {
    "objectID": "posts/2025-09-03-bash-color-code/index.html#ansiエスケープシーケンスの基本",
    "href": "posts/2025-09-03-bash-color-code/index.html#ansiエスケープシーケンスの基本",
    "title": "Bashscript Color Code",
    "section": "ANSIエスケープシーケンスの基本",
    "text": "ANSIエスケープシーケンスの基本\n\nDefinition 1 ANSIエスケープシーケンス\n\n端末表示を制御するための「可視ではない制御文字列\nANSIエスケープシーケンスは \\e[XXXm または \\033[XXXm の形式で記述\n\\e は ESC文字（ASCII 27）を表す\n\n\nsyntax\nESC [ パラメータ コマンド\n文字装飾を行う場合は\nESC [ &lt;params&gt; m"
  },
  {
    "objectID": "posts/2025-09-03-bash-color-code/index.html#テキスト装飾コード",
    "href": "posts/2025-09-03-bash-color-code/index.html#テキスト装飾コード",
    "title": "Bashscript Color Code",
    "section": "テキスト装飾コード",
    "text": "テキスト装飾コード\n\n\n\n\nコード\n説明\n\n\n\n\n\\e[0m\nリセット（デフォルトに戻す）\n\n\n\\e[1m\n太字\n\n\n\\e[2m\n薄い色（dim）\n\n\n\\e[3m\nイタリック\n\n\n\\e[4m\n下線\n\n\n\\e[5m\n点滅\n\n\n\\e[7m\n反転（背景色と文字色を入れ替え）\n\n\n\\e[8m\n非表示\n\n\n\\e[9m\n取り消し線"
  },
  {
    "objectID": "posts/2025-09-03-bash-color-code/index.html#標準色前景色",
    "href": "posts/2025-09-03-bash-color-code/index.html#標準色前景色",
    "title": "Bashscript Color Code",
    "section": "標準色（前景色）",
    "text": "標準色（前景色）\n\n\n\n\nコード\n色\n表示例\n\n\n\n\n\\e[30m\n黒\nBlack\n\n\n\\e[31m\n赤\nRed\n\n\n\\e[32m\n緑\nGreen\n\n\n\\e[33m\n黄\nYellow\n\n\n\\e[34m\n青\nBlue\n\n\n\\e[35m\nマゼンタ\nMagenta\n\n\n\\e[36m\nシアン\nCyan\n\n\n\\e[37m\n白\nWhite\n\n\n\\e[39m\nデフォルト色\nDefault"
  },
  {
    "objectID": "posts/2025-09-03-bash-color-code/index.html#明るい色前景色",
    "href": "posts/2025-09-03-bash-color-code/index.html#明るい色前景色",
    "title": "Bashscript Color Code",
    "section": "明るい色（前景色）",
    "text": "明るい色（前景色）\n\n\n\n\nコード\n色\n表示例\n\n\n\n\n\\e[90m\n明るい黒（グレー）\nBright Black\n\n\n\\e[91m\n明るい赤\nBright Red\n\n\n\\e[92m\n明るい緑\nBright Green\n\n\n\\e[93m\n明るい黄\nBright Yellow\n\n\n\\e[94m\n明るい青\nBright Blue\n\n\n\\e[95m\n明るいマゼンタ\nBright Magenta\n\n\n\\e[96m\n明るいシアン\nBright Cyan\n\n\n\\e[97m\n明るい白\nBright White"
  },
  {
    "objectID": "posts/2025-09-03-bash-color-code/index.html#背景色",
    "href": "posts/2025-09-03-bash-color-code/index.html#背景色",
    "title": "Bashscript Color Code",
    "section": "背景色",
    "text": "背景色\n\n\n\n\nコード\n色\n\n\n\n\n\\e[40m\n黒背景\n\n\n\\e[41m\n赤背景\n\n\n\\e[42m\n緑背景\n\n\n\\e[43m\n黄背景\n\n\n\\e[44m\n青背景\n\n\n\\e[45m\nマゼンタ背景\n\n\n\\e[46m\nシアン背景\n\n\n\\e[47m\n白背景\n\n\n\\e[49m\nデフォルト背景\n\n\n\\e[100m\n明るい黒背景（グレー）\n\n\n\\e[101m\n明るい赤背景\n\n\n\\e[102m\n明るい緑背景\n\n\n\\e[103m\n明るい黄背景\n\n\n\\e[104m\n明るい青背景\n\n\n\\e[105m\n明るいマゼンタ背景\n\n\n\\e[106m\n明るいシアン背景\n\n\n\\e[107m\n明るい白背景"
  },
  {
    "objectID": "posts/2025-09-03-bash-color-code/index.html#best-practices",
    "href": "posts/2025-09-03-bash-color-code/index.html#best-practices",
    "title": "Bashscript Color Code",
    "section": "Best Practices",
    "text": "Best Practices\n\n\n\n\n\n\nNoteRule 1. 変数定義には $'...' 形式を使用\n\n\n\n\nエスケープ文字 \\e を解釈させるため、$'...' 形式で変数を定義\n\n\n\n# Good\nRED=$'\\e[31m'\nGREEN=$'\\e[32m'\nRESET=$'\\e[0m'\n\necho \"${RED}Error message${RESET}\"\n\n# Bad - エスケープが解釈されない\nRED='\\e[31m'\n\n\n\n\n\n\nNoteRule 2. 色変数を事前定義して再利用\n\n\n\n\nスクリプトの冒頭で色変数を定義し、可読性を高める\n\n\n\n#!/bin/bash\n\n# Color definitions\nreadonly RED=$'\\e[31m'\nreadonly GREEN=$'\\e[32m'\nreadonly YELLOW=$'\\e[33m'\nreadonly BLUE=$'\\e[34m'\nreadonly MAGENTA=$'\\e[35m'\nreadonly CYAN=$'\\e[36m'\nreadonly WHITE=$'\\e[37m'\nreadonly BOLD=$'\\e[1m'\nreadonly RESET=$'\\e[0m'\n\n# Usage\necho \"${GREEN}${BOLD}Success!${RESET}\"\necho \"${RED}Error occurred${RESET}\"\n\n\n\n\n\n\nNoteRule 3. 必ずリセットコードで終了\n\n\n\n\n色コードを使用した後は必ず \\e[0m でリセットし、以降の出力に影響を与えないようにする\n\n\n\n# Color definitions\nreadonly RED=$'\\e[31m'\nreadonly GREEN=$'\\e[32m'\nreadonly YELLOW=$'\\e[33m'\nreadonly RESET=$'\\e[0m'\n\n# Helper functions\nprint_error() {\n    echo \"${RED}[ERROR]${RESET} $*\" &gt;&2\n}\n\nprint_success() {\n    echo \"${GREEN}[SUCCESS]${RESET} $*\"\n}\n\nprint_warning() {\n    echo \"${YELLOW}[WARNING]${RESET} $*\"\n}\n\n# Usage\nprint_error \"File not found\"\nprint_success \"Operation completed\"\nprint_warning \"This feature is deprecated\"\n\n\n\n\n\n\nNoteRule 4. 複数の装飾を組み合わせる\n\n\n\n\nセミコロンで区切って複数の効果を適用\n\n\n\n# 太字 + 赤色\nBOLD_RED=$'\\e[1;31m'\n\n# 下線 + 青色 + 白背景\nUNDERLINE_BLUE_WHITE=$'\\e[4;34;47m'\n\necho \"${BOLD_RED}Important${RESET}\""
  },
  {
    "objectID": "posts/2025-12-10-github-repository-memo/index.html",
    "href": "posts/2025-12-10-github-repository-memo/index.html",
    "title": "自分用GitHub Repository作成時のメモ",
    "section": "",
    "text": "Note\n\n\n\n\nあくまで共通項についてのメモです\n厳密には下記のStep 3 ghコマンドの実行 の前にdocument や gitignoreなり他にもやることはあります\n\n\n\nminimum structure\n.\n├── .github/\n│   ├── repository_metadata/    # Repository configuration files\n│   │   ├── gh_repo.yml        # Repository metadata\n│   │   └── label_master.yml   # Label definitions\n│   └── workflows/             # GitHub Actions workflows\n│       └── label-generator.yml # Label automation workflow\n└── README.md\n手順\n\nディレクトリの作成と移動\nmkdir &lt;repository-name&gt; && cd $_\nRepositoryメタデータの作成\n以下のように .github/repository_metadata/gh_repo.yml に記述します\n\n\ngh_repo.yml\n\nmeta-data:\nrepository_name: your-repo-name       # Required: Repository name\nvisibility: private|public            # Required: Repository visibility\norg-name: YourOrgName                # Required: Organization name\nhomepage: YourURL                    # Optional: e.g., https://ryonakagami.github.io/regmonkey-datascience-blog/\ntag:                                 # Optional: Repository tags\n  - tag1\n  - tag2\ndescription: |                       # Required: Repository description\n  A clear, concise description of your project.\n\n\n\n\n\n\n\n\nCaution\n\n\n\n'Required' とされているフィールドは必ず入力して下さい\n\n\n\nghコマンドの実行\n自分は .gitconfig で Alias 設定を行い git create-repo と git update-repo を実行できるようにしています．\n# step 1\ngit create-repo   # only when the repository not created yet\n\n# step 2\ngit update-repo   # reflecting tags, description, and homepage\n（Optional）ラベルのカスタマイズ\n.github/repository_metadata/label_master.yml を以下のフォーマットで編集．main へのpushが label_master.yml の変更を含んでいるときにラベルが作成される\n# ------------------------------------------------\n# GitHub Issue Labels aligned with Branch Naming Conventions\n# Author: Ryo Nakagami\n# ------------------------------------------------\n\n# --- Development Workflows (Aligned with Branch Prefixes) ---\n- name: environment\n  color: EFDECD         # almond\n  description: This issue is related to development repository structure etc\n\n- name: feature\n  color: 008000         # green\n  description: New feature development\n\n- name: bugfix\n  color: DC143C         # crimson\n  description: Bug fix or defect correction\n\n\n\n\n\n\n\n\n\n\n\n\nイベント\nWorkflow が動作する？\n説明\n\n\n\n\nmain への PR を作成\n❌\npush ではないため\n\n\nmain への PR を更新（コミット追加）\n❌\npush は発生しているが，そのブランチで動くので main とは関係なし\n\n\nmain への PR を merge\n✅\nmerge commit が main に push されるため\n\n\n\n\nワークフローファイル\n\n\nlabel-generator.yml\n\nname: Label Manager\n\n# Trigger: Runs when labels.yaml is modified\non:\n  push:\n    branches:\n      - main\n    paths:\n      - .github/repository_metadata/label_master.yml\n\n# Minimal required permissions\npermissions:\n  contents: read    # Read repository files\n  issues: write     # Create/update/delete labels\n\njobs:\n  sync-labels:\n    runs-on: ubuntu-latest\n    \n    steps:\n      # ============================================================\n      # SETUP: Install required tools and authenticate\n      # ============================================================\n      \n      - name: Checkout repository\n        uses: actions/checkout@v4\n\n      - name: Install uv\n        uses: astral-sh/setup-uv@v4\n        # uv is used to install Python tools like yamlcli\n\n      - name: Install dependencies\n        run: |\n          # Update package lists quietly\n          sudo apt-get update -qq\n          \n          # Install jq (JSON processor) and gh (GitHub CLI)\n          sudo apt-get install -y -qq jq gh\n          \n          # Install yamlcli via uv to convert YAML to JSON\n          uv tool install git+https://github.com/RyoNakagami/yamlcli.git\n\n      - name: Authenticate GitHub CLI\n        run: echo \"${{ secrets.GITHUB_TOKEN }}\" | gh auth login --with-token\n        # Note: Not setting GH_TOKEN here allows gh to store credentials\n        # This prevents \"To have GitHub CLI store credentials...\" warning\n\n      # ============================================================\n      # PARSE: Convert YAML configuration to JSON\n      # ============================================================\n      \n      - name: Parse labels configuration\n        id: parse\n        run: |\n          # Convert labels.yaml to JSON format and save to file\n          yamlcli --to-json .github/repository_metadata/label_master.yml &gt; /tmp/labels.json\n          echo \"Labels configuration parsed successfully\"\n\n      # ============================================================\n      # SYNC: Create or update labels from configuration\n      # ============================================================\n      \n      - name: Sync labels\n        run: |\n          # Exit on error, undefined variables, or pipe failures\n          set -euo pipefail\n          \n          # Get list of existing label names once to avoid repeated API calls\n          EXISTING_LABELS=$(gh label list --json name --jq '.[].name')\n          \n          # Process each label definition from the JSON array\n          jq -c '.[]' /tmp/labels.json | while IFS= read -r label; do\n            # Extract label properties\n            NAME=$(echo \"$label\" | jq -r '.name')\n            COLOR=$(echo \"$label\" | jq -r '.color')\n            DESC=$(echo \"$label\" | jq -r '.description // \"\"')  # Default to empty string if null\n            \n            echo \"Processing label: $NAME\"\n            \n            # Check if label already exists in repository\n            if echo \"$EXISTING_LABELS\" | grep -Fxq \"$NAME\"; then\n              # Update existing label\n              echo \"  Updating existing label\"\n              gh label edit \"$NAME\" --color \"$COLOR\" --description \"$DESC\"\n            else\n              # Create new label\n              echo \"  Creating new label\"\n              gh label create \"$NAME\" --color \"$COLOR\" --description \"$DESC\"\n            fi\n          done\n\n      # ============================================================\n      # PRUNE: Remove labels not defined in configuration\n      # ============================================================\n      \n      - name: Prune obsolete labels\n        run: |\n          # Exit on error, undefined variables, or pipe failures\n          set -euo pipefail\n          \n          # Get list of all existing labels in the repository\n          EXISTING_LABELS=$(gh label list --json name --jq '.[].name')\n          \n          # Get list of desired labels from configuration\n          DESIRED_LABELS=$(jq -r '.[].name' /tmp/labels.json)\n          \n          # Check each existing label\n          echo \"$EXISTING_LABELS\" | while IFS= read -r label; do\n            # Skip empty lines\n            if [[ -n \"$label\" ]] && ! echo \"$DESIRED_LABELS\" | grep -Fxq \"$label\"; then\n              # Label exists in repo but not in config - delete it\n              echo \"Deleting obsolete label: $label\"\n              gh label delete \"$label\" --yes || echo \"  Failed to delete $label (may be in use)\"\n            fi\n          done\n        # gh CLI uses stored credentials from auth login step"
  },
  {
    "objectID": "posts/2025-12-10-github-repository-memo/index.html#getting-started",
    "href": "posts/2025-12-10-github-repository-memo/index.html#getting-started",
    "title": "自分用GitHub Repository作成時のメモ",
    "section": "",
    "text": "Note\n\n\n\n\nあくまで共通項についてのメモです\n厳密には下記のStep 3 ghコマンドの実行 の前にdocument や gitignoreなり他にもやることはあります\n\n\n\nminimum structure\n.\n├── .github/\n│   ├── repository_metadata/    # Repository configuration files\n│   │   ├── gh_repo.yml        # Repository metadata\n│   │   └── label_master.yml   # Label definitions\n│   └── workflows/             # GitHub Actions workflows\n│       └── label-generator.yml # Label automation workflow\n└── README.md\n手順\n\nディレクトリの作成と移動\nmkdir &lt;repository-name&gt; && cd $_\nRepositoryメタデータの作成\n以下のように .github/repository_metadata/gh_repo.yml に記述します\n\n\ngh_repo.yml\n\nmeta-data:\nrepository_name: your-repo-name       # Required: Repository name\nvisibility: private|public            # Required: Repository visibility\norg-name: YourOrgName                # Required: Organization name\nhomepage: YourURL                    # Optional: e.g., https://ryonakagami.github.io/regmonkey-datascience-blog/\ntag:                                 # Optional: Repository tags\n  - tag1\n  - tag2\ndescription: |                       # Required: Repository description\n  A clear, concise description of your project.\n\n\n\n\n\n\n\n\nCaution\n\n\n\n'Required' とされているフィールドは必ず入力して下さい\n\n\n\nghコマンドの実行\n自分は .gitconfig で Alias 設定を行い git create-repo と git update-repo を実行できるようにしています．\n# step 1\ngit create-repo   # only when the repository not created yet\n\n# step 2\ngit update-repo   # reflecting tags, description, and homepage\n（Optional）ラベルのカスタマイズ\n.github/repository_metadata/label_master.yml を以下のフォーマットで編集．main へのpushが label_master.yml の変更を含んでいるときにラベルが作成される\n# ------------------------------------------------\n# GitHub Issue Labels aligned with Branch Naming Conventions\n# Author: Ryo Nakagami\n# ------------------------------------------------\n\n# --- Development Workflows (Aligned with Branch Prefixes) ---\n- name: environment\n  color: EFDECD         # almond\n  description: This issue is related to development repository structure etc\n\n- name: feature\n  color: 008000         # green\n  description: New feature development\n\n- name: bugfix\n  color: DC143C         # crimson\n  description: Bug fix or defect correction\n\n\n\n\n\n\n\n\n\n\n\n\nイベント\nWorkflow が動作する？\n説明\n\n\n\n\nmain への PR を作成\n❌\npush ではないため\n\n\nmain への PR を更新（コミット追加）\n❌\npush は発生しているが，そのブランチで動くので main とは関係なし\n\n\nmain への PR を merge\n✅\nmerge commit が main に push されるため\n\n\n\n\nワークフローファイル\n\n\nlabel-generator.yml\n\nname: Label Manager\n\n# Trigger: Runs when labels.yaml is modified\non:\n  push:\n    branches:\n      - main\n    paths:\n      - .github/repository_metadata/label_master.yml\n\n# Minimal required permissions\npermissions:\n  contents: read    # Read repository files\n  issues: write     # Create/update/delete labels\n\njobs:\n  sync-labels:\n    runs-on: ubuntu-latest\n    \n    steps:\n      # ============================================================\n      # SETUP: Install required tools and authenticate\n      # ============================================================\n      \n      - name: Checkout repository\n        uses: actions/checkout@v4\n\n      - name: Install uv\n        uses: astral-sh/setup-uv@v4\n        # uv is used to install Python tools like yamlcli\n\n      - name: Install dependencies\n        run: |\n          # Update package lists quietly\n          sudo apt-get update -qq\n          \n          # Install jq (JSON processor) and gh (GitHub CLI)\n          sudo apt-get install -y -qq jq gh\n          \n          # Install yamlcli via uv to convert YAML to JSON\n          uv tool install git+https://github.com/RyoNakagami/yamlcli.git\n\n      - name: Authenticate GitHub CLI\n        run: echo \"${{ secrets.GITHUB_TOKEN }}\" | gh auth login --with-token\n        # Note: Not setting GH_TOKEN here allows gh to store credentials\n        # This prevents \"To have GitHub CLI store credentials...\" warning\n\n      # ============================================================\n      # PARSE: Convert YAML configuration to JSON\n      # ============================================================\n      \n      - name: Parse labels configuration\n        id: parse\n        run: |\n          # Convert labels.yaml to JSON format and save to file\n          yamlcli --to-json .github/repository_metadata/label_master.yml &gt; /tmp/labels.json\n          echo \"Labels configuration parsed successfully\"\n\n      # ============================================================\n      # SYNC: Create or update labels from configuration\n      # ============================================================\n      \n      - name: Sync labels\n        run: |\n          # Exit on error, undefined variables, or pipe failures\n          set -euo pipefail\n          \n          # Get list of existing label names once to avoid repeated API calls\n          EXISTING_LABELS=$(gh label list --json name --jq '.[].name')\n          \n          # Process each label definition from the JSON array\n          jq -c '.[]' /tmp/labels.json | while IFS= read -r label; do\n            # Extract label properties\n            NAME=$(echo \"$label\" | jq -r '.name')\n            COLOR=$(echo \"$label\" | jq -r '.color')\n            DESC=$(echo \"$label\" | jq -r '.description // \"\"')  # Default to empty string if null\n            \n            echo \"Processing label: $NAME\"\n            \n            # Check if label already exists in repository\n            if echo \"$EXISTING_LABELS\" | grep -Fxq \"$NAME\"; then\n              # Update existing label\n              echo \"  Updating existing label\"\n              gh label edit \"$NAME\" --color \"$COLOR\" --description \"$DESC\"\n            else\n              # Create new label\n              echo \"  Creating new label\"\n              gh label create \"$NAME\" --color \"$COLOR\" --description \"$DESC\"\n            fi\n          done\n\n      # ============================================================\n      # PRUNE: Remove labels not defined in configuration\n      # ============================================================\n      \n      - name: Prune obsolete labels\n        run: |\n          # Exit on error, undefined variables, or pipe failures\n          set -euo pipefail\n          \n          # Get list of all existing labels in the repository\n          EXISTING_LABELS=$(gh label list --json name --jq '.[].name')\n          \n          # Get list of desired labels from configuration\n          DESIRED_LABELS=$(jq -r '.[].name' /tmp/labels.json)\n          \n          # Check each existing label\n          echo \"$EXISTING_LABELS\" | while IFS= read -r label; do\n            # Skip empty lines\n            if [[ -n \"$label\" ]] && ! echo \"$DESIRED_LABELS\" | grep -Fxq \"$label\"; then\n              # Label exists in repo but not in config - delete it\n              echo \"Deleting obsolete label: $label\"\n              gh label delete \"$label\" --yes || echo \"  Failed to delete $label (may be in use)\"\n            fi\n          done\n        # gh CLI uses stored credentials from auth login step"
  },
  {
    "objectID": "posts/2025-12-10-github-repository-memo/index.html#references",
    "href": "posts/2025-12-10-github-repository-memo/index.html#references",
    "title": "自分用GitHub Repository作成時のメモ",
    "section": "References",
    "text": "References\n\nregmonkey-gitcommand"
  },
  {
    "objectID": "posts/2025-12-05-p-value/index.html",
    "href": "posts/2025-12-05-p-value/index.html",
    "title": "P-valueの考え方",
    "section": "",
    "text": "Definition 1 P value\nデータにばらつきがある場合，ばらつきだけの原因で評価指標が観測された以上の大きな値を取る確率\n\nP値はNHSTの文脈で用いられる指標です．統計的文脈に則した定義を与えるとすると，\n\\(H_o:  \\theta \\in \\Theta_0\\) vs \\(H_o:  \\theta \\notin \\Theta_0\\) なるNHSTにおいて，棄却域が\n\\[\nR = \\{\\pmb x | W(\\pmb x) &gt; c\\}\n\\]\nで与えられる検定を考えます．このとき\n\\[\np(\\pmb x) = \\sup_{\\theta \\in \\Theta_0} P_\\theta (W(\\pmb X) \\geq W(\\pmb x))\n\\]\nをP値もしくは有意確率といいます．\n\nTheorem 1 Type I エラーのバウンド\nすべての \\(\\theta \\in \\Theta_0\\) とすべての \\(\\alpha \\in (0, 1)\\) について\n\\[\nP_\\theta(p(\\pmb X) \\leq \\alpha) \\leq \\alpha\n\\]\nが成り立つ．\n\n\n\n\n\n\n\nNoteProof\n\n\n\n\n\n\\(\\theta \\in \\Theta_0\\) を任意に固定して\n\\[\np(\\pmb x | \\theta) = P_\\theta(W(\\pmb X) \\geq W(\\pmb x))\n\\]\nとおきます．\\(-W(\\pmb X)\\) の分布関数を \\(F_\\theta(w)\\) とすると\n\n\\[\n\\begin{align}\np(\\pmb x | \\theta)\n  &= P_\\theta(-W(\\pmb X) \\leq -W(\\pmb x))\\\\[5pt]\n  &= F_\\theta(-W(\\pmb x))\n\\end{align}\n\\]\n\n\\(F_\\theta(-W(\\pmb X))\\) は分布関数 \\(F_\\theta\\) に \\(-W(\\pmb X)\\) を代入したものなので，\\((0, 1)\\) 上に一様分布します． したがって，確率測度 \\(P_\\theta\\) に対して\n\\[\nP_\\theta(p(\\pmb X | \\theta) \\leq \\alpha) = P_\\theta(F_\\theta(-W(\\pmb X))\\leq \\alpha) = \\alpha\n\\]\n定義より\n\\[\np(\\pmb x) = \\sup_{\\theta^\\prime \\in \\Theta_0} p(\\pmb x | \\theta^\\prime) \\geq p(\\pmb x | \\theta)\n\\]\nであるので\n\\[\nP_\\theta(p(\\pmb X) \\leq \\alpha) \\leq P_\\theta(p(\\pmb X | \\theta) \\leq \\alpha) = \\alpha\n\\]\n\n\n\nこの定理は，帰無仮説が真であるとき，p値が \\(\\alpha\\) 以下となる確率（＝Type I error rate）は高々 \\(\\alpha\\) であることを保証しています．\nわかりやすいイメージとして，指示関数 \\(\\mathbf{1}\\{p(\\pmb X) \\leq \\alpha\\}\\) を考えます．この関数は\n\np値が \\(\\alpha\\) 以下のとき \\(1\\)（帰無仮説を棄却）\np値が \\(\\alpha\\) より大きいとき \\(0\\)（帰無仮説を棄却しない）\n\nを返します．帰無仮説が真のもとで繰り返しサンプリングを行い，この指示関数の値を記録すると，その平均（＝棄却する割合）は\n\\[\nE_\\theta[\\mathbf{1}\\{p(\\pmb X) \\leq \\alpha\\}] = P_\\theta(p(\\pmb X) \\leq \\alpha) \\leq \\alpha\n\\]\nとなります．つまり，帰無仮説が真であるにもかかわらず誤って棄却してしまう割合は，長期的に見て \\(\\alpha\\) 以下に抑えられるということです．\n\nExample 1 \n\\(X_1, \\cdots. X_n \\overset{\\mathrm{iid}}{\\sim}  N(\\mu, \\sigma^2_0)\\) とし，\\(\\sigma^2_0\\) は既知であるとする．\n\n\\(H_0: \\mu = \\mu_0\\)\n\\(H_1: \\mu =\\neq \\mu_0\\)\n\nとなる両側検定については，検定統計量は\n\\[\nW(\\bar X) = \\sqrt{n}|\\bar X - \\mu_0|/\\sigma_0\n\\]\nとなり，有意水準 \\(\\alpha\\) について，対応する棄却域は\n\\[\nR = \\{\\bar x | W(\\bar x) &gt; z_{\\alpha/2}\\}\n\\]\nこのとき，\\(Z = \\sqrt{n}(\\bar X - \\mu_0)/\\sigma_0\\) とおくと，\\(W(\\bar X) = |Z|\\) になります．また，\\(H_0\\) のもとで \\(Z \\sim N(0, 1)\\) であるので\n\n\\[\n\\begin{align}\np(\\bar x)\n  &= P_{\\mu_0}(W(\\bar X) \\geq W(\\bar x))\\\\\n  &= P(|Z| \\geq \\sqrt{n}|\\bar x - \\mu|/\\sigma_0)\n\\end{align}\n\\]\n\n\\(\\bar x \\in R\\) のときは\n\n\\[\n\\begin{align}\np(\\bar x)\n  &= P(|Z| \\geq \\sqrt{n}|\\bar x - \\mu_0|/\\sigma_0)\\\\\n  &\\leq P(|Z| \\geq z_{\\alpha/2}) = \\alpha\n\\end{align}\n\\]\n\nしたがって，定理 Theorem 1 より\n\\[\nP_{\\mu_0}(p(\\bar X) \\leq \\alpha) = \\alpha\n\\]\nとなります．仮にデータを観測して \\(p(\\bar x) &lt; 0.01\\) となるとき．\\(H_0\\) のもとで，P値が0.01より小さくなる確率は 0.01 より小さいことがわかります．"
  },
  {
    "objectID": "posts/2025-12-05-p-value/index.html#p-valueの定義",
    "href": "posts/2025-12-05-p-value/index.html#p-valueの定義",
    "title": "P-valueの考え方",
    "section": "",
    "text": "Definition 1 P value\nデータにばらつきがある場合，ばらつきだけの原因で評価指標が観測された以上の大きな値を取る確率\n\nP値はNHSTの文脈で用いられる指標です．統計的文脈に則した定義を与えるとすると，\n\\(H_o:  \\theta \\in \\Theta_0\\) vs \\(H_o:  \\theta \\notin \\Theta_0\\) なるNHSTにおいて，棄却域が\n\\[\nR = \\{\\pmb x | W(\\pmb x) &gt; c\\}\n\\]\nで与えられる検定を考えます．このとき\n\\[\np(\\pmb x) = \\sup_{\\theta \\in \\Theta_0} P_\\theta (W(\\pmb X) \\geq W(\\pmb x))\n\\]\nをP値もしくは有意確率といいます．\n\nTheorem 1 Type I エラーのバウンド\nすべての \\(\\theta \\in \\Theta_0\\) とすべての \\(\\alpha \\in (0, 1)\\) について\n\\[\nP_\\theta(p(\\pmb X) \\leq \\alpha) \\leq \\alpha\n\\]\nが成り立つ．\n\n\n\n\n\n\n\nNoteProof\n\n\n\n\n\n\\(\\theta \\in \\Theta_0\\) を任意に固定して\n\\[\np(\\pmb x | \\theta) = P_\\theta(W(\\pmb X) \\geq W(\\pmb x))\n\\]\nとおきます．\\(-W(\\pmb X)\\) の分布関数を \\(F_\\theta(w)\\) とすると\n\n\\[\n\\begin{align}\np(\\pmb x | \\theta)\n  &= P_\\theta(-W(\\pmb X) \\leq -W(\\pmb x))\\\\[5pt]\n  &= F_\\theta(-W(\\pmb x))\n\\end{align}\n\\]\n\n\\(F_\\theta(-W(\\pmb X))\\) は分布関数 \\(F_\\theta\\) に \\(-W(\\pmb X)\\) を代入したものなので，\\((0, 1)\\) 上に一様分布します． したがって，確率測度 \\(P_\\theta\\) に対して\n\\[\nP_\\theta(p(\\pmb X | \\theta) \\leq \\alpha) = P_\\theta(F_\\theta(-W(\\pmb X))\\leq \\alpha) = \\alpha\n\\]\n定義より\n\\[\np(\\pmb x) = \\sup_{\\theta^\\prime \\in \\Theta_0} p(\\pmb x | \\theta^\\prime) \\geq p(\\pmb x | \\theta)\n\\]\nであるので\n\\[\nP_\\theta(p(\\pmb X) \\leq \\alpha) \\leq P_\\theta(p(\\pmb X | \\theta) \\leq \\alpha) = \\alpha\n\\]\n\n\n\nこの定理は，帰無仮説が真であるとき，p値が \\(\\alpha\\) 以下となる確率（＝Type I error rate）は高々 \\(\\alpha\\) であることを保証しています．\nわかりやすいイメージとして，指示関数 \\(\\mathbf{1}\\{p(\\pmb X) \\leq \\alpha\\}\\) を考えます．この関数は\n\np値が \\(\\alpha\\) 以下のとき \\(1\\)（帰無仮説を棄却）\np値が \\(\\alpha\\) より大きいとき \\(0\\)（帰無仮説を棄却しない）\n\nを返します．帰無仮説が真のもとで繰り返しサンプリングを行い，この指示関数の値を記録すると，その平均（＝棄却する割合）は\n\\[\nE_\\theta[\\mathbf{1}\\{p(\\pmb X) \\leq \\alpha\\}] = P_\\theta(p(\\pmb X) \\leq \\alpha) \\leq \\alpha\n\\]\nとなります．つまり，帰無仮説が真であるにもかかわらず誤って棄却してしまう割合は，長期的に見て \\(\\alpha\\) 以下に抑えられるということです．\n\nExample 1 \n\\(X_1, \\cdots. X_n \\overset{\\mathrm{iid}}{\\sim}  N(\\mu, \\sigma^2_0)\\) とし，\\(\\sigma^2_0\\) は既知であるとする．\n\n\\(H_0: \\mu = \\mu_0\\)\n\\(H_1: \\mu =\\neq \\mu_0\\)\n\nとなる両側検定については，検定統計量は\n\\[\nW(\\bar X) = \\sqrt{n}|\\bar X - \\mu_0|/\\sigma_0\n\\]\nとなり，有意水準 \\(\\alpha\\) について，対応する棄却域は\n\\[\nR = \\{\\bar x | W(\\bar x) &gt; z_{\\alpha/2}\\}\n\\]\nこのとき，\\(Z = \\sqrt{n}(\\bar X - \\mu_0)/\\sigma_0\\) とおくと，\\(W(\\bar X) = |Z|\\) になります．また，\\(H_0\\) のもとで \\(Z \\sim N(0, 1)\\) であるので\n\n\\[\n\\begin{align}\np(\\bar x)\n  &= P_{\\mu_0}(W(\\bar X) \\geq W(\\bar x))\\\\\n  &= P(|Z| \\geq \\sqrt{n}|\\bar x - \\mu|/\\sigma_0)\n\\end{align}\n\\]\n\n\\(\\bar x \\in R\\) のときは\n\n\\[\n\\begin{align}\np(\\bar x)\n  &= P(|Z| \\geq \\sqrt{n}|\\bar x - \\mu_0|/\\sigma_0)\\\\\n  &\\leq P(|Z| \\geq z_{\\alpha/2}) = \\alpha\n\\end{align}\n\\]\n\nしたがって，定理 Theorem 1 より\n\\[\nP_{\\mu_0}(p(\\bar X) \\leq \\alpha) = \\alpha\n\\]\nとなります．仮にデータを観測して \\(p(\\bar x) &lt; 0.01\\) となるとき．\\(H_0\\) のもとで，P値が0.01より小さくなる確率は 0.01 より小さいことがわかります．"
  },
  {
    "objectID": "posts/2025-12-05-p-value/index.html#統計的判定とドメイン領域判定",
    "href": "posts/2025-12-05-p-value/index.html#統計的判定とドメイン領域判定",
    "title": "P-valueの考え方",
    "section": "統計的判定とドメイン領域判定",
    "text": "統計的判定とドメイン領域判定\n医薬品の臨床試験においては、\\(\\text{p-value}&lt;\\alpha\\) のとき「統計的に有意である」と判定し，帰無仮説（処置効果が存在しない）を棄却する，というプロトコルが用いられます．\nしかし，この判定はあくまで統計的判定であり，医学的に意味のある処置効果が存在することを直接示すものではないです．P値はあくまで，\n\nデータにばらつきがある場合，ばらつきだけの原因で評価指標が観測された以上の大きな値を取る確率\n\nを表す量であり，\n\\[\nP_\\theta(p(\\pmb X) \\leq \\alpha) \\leq \\alpha \\, \\ (\\theta \\in \\Theta_0)\n\\]\nを用いたNeyman-Pearson流の意思決定フレームワークにおけるType I Error制御にすぎません．「医薬品の効果があった」という医学的判定とは異なります． 医学的判定において重要なのは，\n\n効果量の大きさが臨床的に意味のある水準か\n副作用や安全性とのバランスは妥当か\n除外すべき患者がデータに含まれていないか？\n\nといったP-valueの枠外の観点と照らし合わせて，結果を解釈して意思決定を行うことです．\n統計的判定が得られなければ，医学的判断の対象にはなりえない，といったプロトコルを事前に作成して統計的判定の指標としてP値を用いるのはよいですが， P値そのものは医学的有効性や臨床的価値の判断とは切り分けて解釈されるべきです．"
  },
  {
    "objectID": "posts/2025-12-05-p-value/index.html#p-valueをベイズ的に考える",
    "href": "posts/2025-12-05-p-value/index.html#p-valueをベイズ的に考える",
    "title": "P-valueの考え方",
    "section": "p-valueをベイズ的に考える",
    "text": "p-valueをベイズ的に考える\np-value を用いた統計的判定では、対立仮説 \\(H_1\\) が成立すると結論づけるために，まず帰無仮説 \\(H_0\\) を設定し，そのもとで観測データがどの程度「起こりにくいか」を評価する、という手続きを取ります．\nここで，p-valueをベイズ的な観点で考えてみます． データ確認前に持っている仮説に対する信念を事前確率 \\(P(H_0), P(H_1)\\) として表すとして，\n\\[\nR = \\frac{P(H_1)}{P(H_0)}\n\\]\nという事前オッズを考えることができます．これはデータを観測する前の段階で，どちらの仮説を支持するかを表す量となります\n\\[\nR \\geq 1\n\\]\nであるならば，\\(H_0\\) よりも \\(H_1\\) のほうが起こりやすいと想定していることになります．\n\\[\n\\left\\{\n  \\begin{array}{c}\n    H_0: \\Delta \\leq 0\\\\\n    H_1: \\Delta &gt; 0\\\\\n  \\end{array}\\right.\n\\]\nおよび検定統計量を \\(T\\), データから計算される \\(T\\) の値を \\(t_0\\) とする検定をおこなったとき，p-valueは定義より\n\\[\n\\text{p-value} = Pr(T \\geq t_0 | H_0)\n\\]\nここでベイズの定理を用いると\n\\[\n\\begin{align}\n\\operatorname{Pr}\\left(H_1 \\mid T \\geq t_0\\right) &\n  =\\frac{\\operatorname{Pr}\\left(H_1, T \\geq t_0\\right)}{\\operatorname{Pr}\\left(T \\geq t_0\\right)} \\\\\n  & =\\frac{\\operatorname{Pr}\\left(T \\geq t_0 \\mid H_1\\right) \\operatorname{Pr}\\left(H_1\\right)}{\\operatorname{Pr}\\left(T \\geq t_0|H_0\\right) \\operatorname{P}\\left(H_0\\right) + \\operatorname{Pr}\\left(T \\geq t_0|H_1\\right) \\operatorname{P}\\left(H_1\\right)}\\\\\n  &= \\frac{\\operatorname{Pr}\\left(T \\geq t_0 \\mid H_1\\right) R}{\\operatorname{Pr}\\left(T \\geq t_0|H_0\\right) + \\operatorname{Pr}\\left(T \\geq t_0|H_1\\right) R}\\\\\n  &= \\frac{\\operatorname{Pr}\\left(T \\geq t_0 \\mid H_1\\right) R}{\\text{p-value} + \\operatorname{Pr}\\left(T \\geq t_0|H_1\\right) R}\n\\end{align}\n\\]\n\\(\\operatorname{Pr}(T\\geq t_0 | H_1)\\) は検出力に対応することを考えると，\n\\[\n\\operatorname{Pr}\\left(H_1 \\mid T \\geq t_0\\right) = \\frac{\\text{power} \\times R}{\\text{p-value} + \\text{power} \\times R}\n\\]\n\nシミュレーション: 検出力・p-value・事前オッズと事後確率の関係\n検出力（power），p-value，事前オッズ \\(R\\) を動かしたときの \\(\\Pr(H_1 | T \\geq t_0)\\) を計算してみます．\n\n\nテーブル表示\nimport pandas as pd\nimport numpy as np\n\ndef posterior_prob(power, p_value, R):\n    \"\"\"Pr(H1 | T &gt;= t0) を計算\"\"\"\n    return (power * R) / (p_value + power * R)\n\n# パラメータの組み合わせ\nRs = [0.5, 1.0, 2.0]\npowers = [0.05, 0.1, 0.2, 0.4, 0.6, 0.8]\np_values = [0.001, 0.01, 0.05, 0.1]\n\n# マルチインデックステーブル作成\nindex = pd.MultiIndex.from_product([Rs, powers], names=[\"R\", \"Power\"])\ndf = pd.DataFrame(index=index, columns=[f\"{p}\" for p in p_values])\n\nfor R in Rs:\n    for power in powers:\n        for p in p_values:\n            df.loc[(R, power), f\"{p}\"] = posterior_prob(power, p, R)\n\ndf.columns.name = \"p-value\"\ndf = df.astype(float).round(3)\ndf\n\n\n\n\n\n\n\n\n\np-value\n0.001\n0.01\n0.05\n0.1\n\n\nR\nPower\n\n\n\n\n\n\n\n\n0.5\n0.05\n0.962\n0.714\n0.333\n0.200\n\n\n0.10\n0.980\n0.833\n0.500\n0.333\n\n\n0.20\n0.990\n0.909\n0.667\n0.500\n\n\n0.40\n0.995\n0.952\n0.800\n0.667\n\n\n0.60\n0.997\n0.968\n0.857\n0.750\n\n\n0.80\n0.998\n0.976\n0.889\n0.800\n\n\n1.0\n0.05\n0.980\n0.833\n0.500\n0.333\n\n\n0.10\n0.990\n0.909\n0.667\n0.500\n\n\n0.20\n0.995\n0.952\n0.800\n0.667\n\n\n0.40\n0.998\n0.976\n0.889\n0.800\n\n\n0.60\n0.998\n0.984\n0.923\n0.857\n\n\n0.80\n0.999\n0.988\n0.941\n0.889\n\n\n2.0\n0.05\n0.990\n0.909\n0.667\n0.500\n\n\n0.10\n0.995\n0.952\n0.800\n0.667\n\n\n0.20\n0.998\n0.976\n0.889\n0.800\n\n\n0.40\n0.999\n0.988\n0.941\n0.889\n\n\n0.60\n0.999\n0.992\n0.960\n0.923\n\n\n0.80\n0.999\n0.994\n0.970\n0.941\n\n\n\n\n\n\n\n上記テーブルから以下のことがわかります：\n\np-value が小さいほど：\\(\\Pr(H_1 | T \\geq t_0)\\) は大きくなる\n検出力が高いほど：\\(\\Pr(H_1 | T \\geq t_0)\\) は大きくなる\n事前オッズ \\(R\\) が大きいほど：\\(\\Pr(H_1 | T \\geq t_0)\\) は大きくなる\n\n特に，検出力が低い場合（power = 0.05）では，\\(R = 1\\), p-value が 0.05 であっても事後確率は約 50% にとどまり，\\(H_1\\) が正しいとは言い難い状況になります．"
  },
  {
    "objectID": "posts/2025-12-05-p-value/index.html#シミュレーション-one-sample-t検定と-p-value-の分布",
    "href": "posts/2025-12-05-p-value/index.html#シミュレーション-one-sample-t検定と-p-value-の分布",
    "title": "P-valueの考え方",
    "section": "シミュレーション: One-sample t検定と p-value の分布",
    "text": "シミュレーション: One-sample t検定と p-value の分布\nガンマ分布からサンプルを生成して one-sample t 検定を行います．\n\n\\(H_0: \\mu = 0\\)\n\\(H_1: \\mu \\neq 0\\)\n\n真の分布として \\(X \\sim \\text{Gamma}(2, 1) - 1.85\\) を仮定します（\\(E[X] = 0.15 &gt; 0\\)，右に歪んだ分布）．\n\n\n真の分布\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy import stats\n\n# シフトしたガンマ分布の確率密度関数\nx = np.linspace(-2, 8, 500)\nshift = 1.85\npdf = stats.gamma.pdf(x + shift, a=2, scale=1)\n\nfig, ax = plt.subplots(figsize=(7, 4))\nax.plot(x, pdf, 'b-', lw=2, label=r'$X \\sim \\mathrm{Gamma}(2, 1) - 1.85$')\nax.fill_between(x, pdf, alpha=0.3)\nax.axvline(x=0, color='red', linestyle='--', lw=1.5, label=r'$\\mu_0 = 0$ (under $H_0$)')\nax.axvline(x=0.15, color='green', linestyle='--', lw=1.5, label=r'$E[X] = 0.15$ (true mean)')\nax.set_xlabel('x', fontsize=12)\nax.set_ylabel('Density', fontsize=12)\nax.set_title('True Distribution (Shifted Gamma)', fontsize=12)\nax.legend()\nax.set_xlim(-2, 8)\nax.set_ylim(0, None)\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n\n\\(H_1\\) が真である状況で，サンプルサイズ \\(n\\) を変えたときの p-value の分布を確認します．\nまず，理論検出力を計算します．\\(H_0: \\mu = 0\\) に対する片側 t 検定の検出力は，非心度パラメータ\n\\[\n\\delta = \\frac{\\mu - \\mu_0}{\\sigma / \\sqrt{n}} = \\frac{0.15}{\\sqrt{2} / \\sqrt{n}} = 0.15 \\sqrt{n/2}\n\\]\nを用いて，非心 t 分布から計算できます（\\(\\text{Gamma}(2,1)\\) の分散は 2）．\n\n\n理論検出力\nimport polars as pl\n\n# パラメータ\nalpha = 0.05\nmu_true = 0.15\nsigma = np.sqrt(2)  # Gamma(2,1) の標準偏差\nsample_sizes = [50, 100, 200, 300, 500, 1000]\n\n# 理論検出力の計算\npower_results = []\nfor n in sample_sizes:\n    # 非心度パラメータ\n    ncp = mu_true / (sigma / np.sqrt(n))\n    # 臨界値 (中心t分布)\n    t_crit = stats.t.ppf(1 - alpha / 2, df=n-1)\n    # 検出力 (非心t分布)\n    power = 1 - stats.nct.cdf(t_crit, df=n-1, nc=ncp)\n    power_results.append({\"n\": n, \"非心度 $\\delta$\": round(ncp, 3), \"理論検出力\": round(power, 3)})\n\npl.DataFrame(power_results)\n\n\n\nshape: (6, 3)\n\n\n\nn\n非心度 $\\delta$\n理論検出力\n\n\ni64\nf64\nf64\n\n\n\n\n50\n0.75\n0.11\n\n\n100\n1.061\n0.182\n\n\n200\n1.5\n0.32\n\n\n300\n1.837\n0.449\n\n\n500\n2.372\n0.658\n\n\n1000\n3.354\n0.918\n\n\n\n\n\n\n\n\np-value シミュレーション\nnp.random.seed(42)\n\n# パラメータ\nsample_sizes = [50, 100, 200, 300, 500, 1000]\nn_simulations = 2000\n# シミュレーション\nresults = {n: [] for n in sample_sizes}\n\nfor n in sample_sizes:\n    for _ in range(n_simulations):\n        # ガンマ分布からサンプル生成 (E[X] = 2 - 1.85 = 0.15, 右に歪んだ分布)\n        X = np.random.gamma(shape=2, scale=1, size=n) - 1.85\n        # one-sample t検定 (H1: mean != 0)\n        t_stat, p_two_sided = stats.ttest_1samp(X, popmean=0, alternative=\"two-sided\")\n        # 片側検定に変換\n        results[n].append(p_two_sided)\n\n# Box plot\nfig, ax = plt.subplots(figsize=(8, 6))\ndata = [results[n] for n in sample_sizes]\nbp = ax.boxplot(data, tick_labels=[f\"n={n}\" for n in sample_sizes], patch_artist=True)\n\n# 色設定\ncolors = plt.cm.viridis(np.linspace(0.2, 0.8, len(sample_sizes)))\nfor patch, color in zip(bp[\"boxes\"], colors):\n    patch.set_facecolor(color)\n    patch.set_alpha(0.7)\n\nax.axhline(y=0.05, color=\"red\", linestyle=\"--\", label=r\"$\\alpha = 0.05$\")\nax.set_xlabel(\"Sample Size\", fontsize=12)\nax.set_ylabel(\"p-value\", fontsize=12)\nax.set_title(r\"p-value Distribution under $H_1$ (One-sample t-test)\", fontsize=12)\nax.legend()\nax.set_ylim(-0.02, 1.0)\n\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\np-value 分布のヒストグラム\nfig, axes = plt.subplots(3, 2, figsize=(10, 8))\naxes = axes.flatten()\n\nfor idx, n in enumerate(sample_sizes):\n    ax = axes[idx]\n    bins = np.arange(0, 1.025, 0.025)  # 0.05刻み\n    ax.hist(\n        results[n],\n        bins=bins,\n        weights=np.ones(len(results[n])) / len(results[n]),\n        alpha=0.7,\n        color=colors[idx],\n        edgecolor=\"black\",\n    )\n    ax.axvline(x=0.05, color=\"red\", linestyle=\"--\", lw=1.5, label=r\"$\\alpha = 0.05$\")\n\n    # シミュレーションでの棄却率\n    rejection_rate = np.mean(np.array(results[n]) &lt; 0.05)\n    ax.set_title(f\"n = {n} (rejection rate: {rejection_rate:.3f})\", fontsize=12)\n    ax.set_xlabel(\"p-value\", fontsize=10)\n    ax.set_ylabel(\"Proportion\", fontsize=10)\n    ax.set_xlim(0, 1)\n    ax.legend(fontsize=9)\n\nplt.suptitle(r\"p-value Distribution under $H_1$\", fontsize=14, y=1.02)\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n\n\\(H_1\\) が真である状況では，サンプルサイズが大きくなるほど検出力が上がり，p-value は小さい値に集中していきます．シミュレーションによる棄却率は理論検出力とほぼ一致することが確認できます．\n\n対数正規分布の場合\nより裾が重い分布として，\\(X \\sim \\text{LogNormal}(0, 1) - 1.5\\) を考えます（\\(E[X] = e^{0.5} - 1.5 \\approx 0.149 &gt; 0\\)）． この確率変数列に対して， one-sample t 検定を行います．\n\n\n対数正規分布の真の分布\n# 対数正規分布 - 1.5 の確率密度関数\nshift_ln = 1.5\nx_ln = np.linspace(-1.5, 10, 500)\npdf_ln = stats.lognorm.pdf(x_ln + shift_ln, s=1, scale=np.exp(0))\n\nmu_ln = np.exp(0.5) - shift_ln  # E[X] = exp(mu + sigma^2/2) - shift\nsigma_ln = np.sqrt(\n    (np.exp(1) - 1) * np.exp(1)\n)  # Var[X] = (exp(sigma^2) - 1) * exp(2mu + sigma^2)\n\nfig, ax = plt.subplots(figsize=(7, 4))\nax.plot(x_ln, pdf_ln, \"b-\", lw=2, label=r\"$X \\sim \\mathrm{LogNormal}(0, 1) - 1.5$\")\nax.fill_between(x_ln, pdf_ln, alpha=0.3)\nax.axvline(x=0, color=\"red\", linestyle=\"--\", lw=1.5, label=r\"$\\mu_0 = 0$ (under $H_0$)\")\nax.axvline(\n    x=mu_ln,\n    color=\"green\",\n    linestyle=\"--\",\n    lw=1.5,\n    label=f\"$E[X] = {mu_ln:.3f}$ (true mean)\",\n)\nax.set_xlabel(\"x\", fontsize=12)\nax.set_ylabel(\"Density\", fontsize=12)\nax.set_title(\"True Distribution (Shifted LogNormal)\", fontsize=12)\nax.legend()\nax.set_xlim(-1, 10)\nax.set_ylim(0, None)\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n理論検出力（対数正規分布）\n# 理論検出力の計算\npower_results_ln = []\nfor n in sample_sizes:\n    ncp = mu_ln / (sigma_ln / np.sqrt(n))\n    t_crit = stats.t.ppf(1 - alpha / 2, df=n - 1)\n    power = 1 - stats.nct.cdf(t_crit, df=n - 1, nc=ncp)\n    power_results_ln.append(\n        {\"n\": n, \"非心度 $\\delta$\": round(ncp, 3), \"理論検出力\": round(power, 3)}\n    )\n\npl.DataFrame(power_results_ln)\n\n\n\nshape: (6, 3)\n\n\n\nn\n非心度 $\\delta$\n理論検出力\n\n\ni64\nf64\nf64\n\n\n\n\n50\n0.487\n0.069\n\n\n100\n0.688\n0.101\n\n\n200\n0.973\n0.161\n\n\n300\n1.192\n0.22\n\n\n500\n1.539\n0.336\n\n\n1000\n2.176\n0.585\n\n\n\n\n\n\n\n\np-value シミュレーション（対数正規分布）\nnp.random.seed(42)\n\n# シミュレーション\nresults_ln = {n: [] for n in sample_sizes}\nmeans_ln = {n: [] for n in sample_sizes}\n\nfor n in sample_sizes:\n    for _ in range(n_simulations):\n        X = np.random.lognormal(mean=0, sigma=1, size=n) - 1.5\n        means_ln[n].append(np.mean(X))\n        t_stat, p_one_sided = stats.ttest_1samp(X, popmean=0, alternative=\"two-sided\")\n        results_ln[n].append(p_one_sided)\n\n# ヒストグラム\nfig, axes = plt.subplots(3, 2, figsize=(10, 8))\naxes = axes.flatten()\n\nfor idx, n in enumerate(sample_sizes):\n    ax = axes[idx]\n    bins = np.arange(0, 1.025, 0.025)\n    ax.hist(\n        results_ln[n],\n        bins=bins,\n        weights=np.ones(len(results_ln[n])) / len(results_ln[n]),\n        alpha=0.7,\n        color=colors[idx],\n        edgecolor=\"black\",\n    )\n    ax.axvline(x=0.05, color=\"red\", linestyle=\"--\", lw=1.5, label=r\"$\\alpha = 0.05$\")\n\n    rejection_rate = np.mean(np.array(results_ln[n]) &lt; 0.05)\n    ax.set_title(f\"n = {n} (rejection rate: {rejection_rate:.3f})\", fontsize=12)\n    ax.set_xlabel(\"p-value\", fontsize=10)\n    ax.set_ylabel(\"Proportion\", fontsize=10)\n    ax.set_xlim(0, 1)\n    ax.legend(fontsize=9)\n\nplt.suptitle(r\"p-value Distribution under $H_1$ (LogNormal - 1.5)\", fontsize=14, y=1.02)\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n標本平均の分布（対数正規分布）\nfig, axes = plt.subplots(3, 2, figsize=(10, 10))\naxes = axes.flatten()\n\nfor idx, n in enumerate(sample_sizes):\n    ax = axes[idx]\n    mean_data = np.array(means_ln[n])\n\n    # ヒストグラム\n    ax.hist(\n        mean_data,\n        bins=30,\n        density=True,\n        alpha=0.7,\n        color=colors[idx],\n        edgecolor=\"black\",\n        label=\"Simulation\",\n    )\n\n    # 理論的な正規分布（CLT）\n    se = sigma_ln / np.sqrt(n)\n    x_norm = np.linspace(mean_data.min(), mean_data.max(), 100)\n    ax.plot(\n        x_norm,\n        stats.norm.pdf(x_norm, loc=mu_ln, scale=se),\n        \"r-\",\n        lw=2,\n        label=f\"CLT: N({mu_ln:.3f}, {se:.3f}²)\",\n    )\n\n    ax.axvline(\n        x=mu_ln, color=\"green\", linestyle=\"--\", lw=1.5, label=f\"True mean = {mu_ln:.3f}\"\n    )\n    ax.axvline(x=0, color=\"black\", linestyle=\":\", lw=1.5, label=r\"$\\mu_0 = 0$\")\n    ax.set_title(f\"n = {n}\", fontsize=12)\n    ax.set_xlabel(r\"$\\bar{X}$\", fontsize=10)\n    ax.set_ylabel(\"Density\", fontsize=10)\n    ax.legend(fontsize=8)\n\nplt.suptitle(\n    r\"Sampling Distribution of $\\bar{X}$ (LogNormal - 1.5)\", fontsize=14, y=1.02\n)\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n\n対数正規分布はガンマ分布より裾が重く歪みも大きいため，t検定の正規性仮定からの乖離が大きくなります．標本平均の分布を見ると，サンプルサイズが小さいときは右に歪んでいますが，\\(n\\) が大きくなるとCLTにより正規分布に近づいていくことが確認できます．"
  },
  {
    "objectID": "posts/2025-12-05-p-value/index.html#appendix-h_1-mu-0-のときのp-valueの分布",
    "href": "posts/2025-12-05-p-value/index.html#appendix-h_1-mu-0-のときのp-valueの分布",
    "title": "P-valueの考え方",
    "section": "Appendix: \\(H_1: \\mu > 0\\) のときのp-valueの分布",
    "text": "Appendix: \\(H_1: \\mu &gt; 0\\) のときのp-valueの分布\n\\(\\{X_i\\}_{i=1}^n \\overset{\\mathrm{iid}}{\\sim} G(\\mu, \\sigma^2)\\) となる確率変数列に対するone-sample t testを考えます．\n\\[\n\\left\\{\\begin{array}{c}\nH_0: \\mu \\leq 0\\\\\nH_1: \\mu &gt; 0\n\\end{array}\\right.\n\\]\nと帰無仮説と対立仮説を設定し，検定統計量 \\(T\\) は\n\\[\nT = \\frac{\\bar X - \\mu_0}{\\hat\\sigma / \\sqrt{n}}\n\\]\nとします．データから \\(T = t_0\\) を得られたとして，このときのp-valueは定義より\n\\[\n\\text{p-value} = \\operatorname{Pr}(T &gt; t_0 | H_0) = 1 - F_{t(n-1)}(t_0)\n\\]\nCLTが成立するとすると\n\\[\n\\bar{X} \\sim N\\left(\\mu, \\frac{\\sigma^2}{n}\\right)\n\\]\nしたがって，\\(H_1\\) が真のときの \\(T\\) は漸近的に\n\\[\nT = \\frac{\\bar{X} - \\mu_1}{\\sigma/\\sqrt{n}}\\frac{\\sigma}{\\hat\\sigma} + \\frac{\\mu_1 - \\mu_0}{\\sigma/\\sqrt{n}}\\frac{\\sigma}{\\hat\\sigma}\n\\]\nRHSの第一項は連続写像定理およびSlutskyの定理より \\(N(0, 1)\\) に分布収束．RHSの第二項が非心パラメータ \\(\\delta\\) として\n\\[\n\\delta = \\frac{\\mu_1}{\\sigma/\\sqrt{n}}\n\\]\nしたがって，\n\\[\nT \\sim N\\left(\\frac{\\mu_1}{\\sigma/\\sqrt{n}}, 1\\right)\n\\]\nこのとき，p-valueの分布関数 \\(F_p\\) は\n\n\\[\n\\begin{align}\nF_p(\\alpha)\n  &= \\operatorname{Pr}(\\text{p-value}\\leq \\alpha)\\\\[5pt]\n  &= \\operatorname{Pr}(1 - F_{t(n-1)}(T) \\leq \\alpha)\\\\[5pt]\n  &= 1 - \\operatorname{Pr}(F_{t(n-1)}(T) \\leq 1- \\alpha)\\\\[5pt]\n  &= 1 - \\operatorname{Pr}(T \\leq F_{t(n-1)}^{-1}(1- \\alpha))\\\\[5pt]\n  &= 1 - \\Phi\\left(F_{t(n-1)}^{-1}(1- \\alpha) - \\frac{\\mu_1}{\\sigma/\\sqrt{n}}\\right)\n\\end{align}\n\\]\n\n\nExample 2 (ガンマ分布one-sample test p-value CDFのシミュレーション) \n\n\nCode\n# パラメータ（Gamma分布の場合）\nmu_1 = 0.15  # 真の平均\nsigma = np.sqrt(2)  # Gamma(2,1) の標準偏差\n\n\ndef theoretical_pvalue_cdf(alpha, n, mu_1, sigma):\n    \"\"\"\n    理論的なp-value分布のCDF（漸近近似）\n    F_p(alpha) = 1 - Φ(F_{t(n-1)}^{-1}(1-alpha) - μ_1/(σ/√n))\n    \"\"\"\n    delta = mu_1 / (sigma / np.sqrt(n))  # 非心度\n    t_quantile = stats.t.ppf(1 - alpha, df=n - 1)\n    return 1 - stats.norm.cdf(t_quantile - delta)\n\n\n# プロット\nfig, axes = plt.subplots(3, 2, figsize=(10, 10))\naxes = axes.flatten()\n\nalpha_grid = np.linspace(0.001, 1, 500)\n\n# シミュレーション\nresults_one_sieded = {n: [] for n in sample_sizes}\n\nfor n in sample_sizes:\n    for _ in range(n_simulations):\n        # ガンマ分布からサンプル生成 (E[X] = 2 - 1.85 = 0.15, 右に歪んだ分布)\n        X = np.random.gamma(shape=2, scale=1, size=n) - 1.85\n        # one-sample t検定 (H1: mean != 0)\n        t_stat, p_one_sided = stats.ttest_1samp(X, popmean=0, alternative=\"greater\")\n        # 片側検定に変換\n        results_one_sieded[n].append(p_one_sided)\n\nfor idx, n in enumerate(sample_sizes):\n    ax = axes[idx]\n\n    # シミュレーションによる経験的CDF\n    sorted_pvals = np.sort(results_one_sieded[n])\n    empirical_cdf = np.arange(1, len(sorted_pvals) + 1) / len(sorted_pvals)\n    ax.step(\n        sorted_pvals, empirical_cdf, where=\"post\", label=\"Simulation (ECDF)\", alpha=0.8\n    )\n\n    # 理論的CDF（漸近正規近似）\n    theoretical_cdf = [theoretical_pvalue_cdf(a, n, mu_1, sigma) for a in alpha_grid]\n    ax.plot(alpha_grid, theoretical_cdf, \"r--\", lw=2, label=\"Theory (Normal approx)\")\n\n    # 非心t分布による理論CDF（より正確）\n    delta = mu_1 / (sigma / np.sqrt(n))\n    t_quantiles = stats.t.ppf(1 - alpha_grid, df=n - 1)\n    theoretical_cdf_nct = 1 - stats.nct.cdf(t_quantiles, df=n - 1, nc=delta)\n    ax.plot(alpha_grid, theoretical_cdf_nct, \"g-\", lw=2, label=\"Theory (Noncentral-t)\")\n\n    ax.set_xlabel(r\"$\\alpha$\", fontsize=10)\n    ax.set_ylabel(r\"$F_p(\\alpha)$\", fontsize=10)\n    ax.set_title(f\"n = {n}\", fontsize=12)\n    ax.legend(fontsize=8)\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.plot([0, 1], [0, 1], \"k:\", alpha=0.3, label=\"Uniform (under $H_0$)\")\n\nplt.suptitle(r\"CDF of p-value under $H_1$ (Gamma distribution)\", fontsize=14, y=1.02)\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\nExample 3 (対数正規分布 one-sample test p-value CDFのシミュレーション) \n\n\nCode\n# パラメータ（対数正規分布の場合）\n# mu_ln, sigma_ln は既に定義済み\n\n# プロット\nfig, axes = plt.subplots(3, 2, figsize=(10, 10))\naxes = axes.flatten()\n\nalpha_grid = np.linspace(0.001, 1, 500)\n\n# シミュレーション\nresults_ln_one_sided = {n: [] for n in sample_sizes}\nmeans_ln = {n: [] for n in sample_sizes}\n\nfor n in sample_sizes:\n    for _ in range(n_simulations):\n        X = np.random.lognormal(mean=0, sigma=1, size=n) - 1.5\n        means_ln[n].append(np.mean(X))\n        t_stat, p_one_sided = stats.ttest_1samp(X, popmean=0, alternative=\"greater\")\n        results_ln_one_sided[n].append(p_one_sided)\n\n\nfor idx, n in enumerate(sample_sizes):\n    ax = axes[idx]\n\n    # シミュレーションによる経験的CDF\n    sorted_pvals = np.sort(results_ln_one_sided[n])\n    empirical_cdf = np.arange(1, len(sorted_pvals) + 1) / len(sorted_pvals)\n    ax.step(\n        sorted_pvals, empirical_cdf, where=\"post\", label=\"Simulation (ECDF)\", alpha=0.8\n    )\n\n    # 理論的CDF（漸近正規近似）\n    theoretical_cdf = [\n        theoretical_pvalue_cdf(a, n, mu_ln, sigma_ln) for a in alpha_grid\n    ]\n    ax.plot(alpha_grid, theoretical_cdf, \"r--\", lw=2, label=\"Theory (Normal approx)\")\n\n    # 非心t分布による理論CDF（より正確）\n    delta = mu_ln / (sigma_ln / np.sqrt(n))\n    t_quantiles = stats.t.ppf(1 - alpha_grid, df=n - 1)\n    theoretical_cdf_nct = 1 - stats.nct.cdf(t_quantiles, df=n - 1, nc=delta)\n    ax.plot(alpha_grid, theoretical_cdf_nct, \"g-\", lw=2, label=\"Theory (Noncentral-t)\")\n\n    ax.set_xlabel(r\"$\\alpha$\", fontsize=10)\n    ax.set_ylabel(r\"$F_p(\\alpha)$\", fontsize=10)\n    ax.set_title(f\"n = {n}\", fontsize=12)\n    ax.legend(fontsize=8)\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.plot([0, 1], [0, 1], \"k:\", alpha=0.3, label=\"Uniform (under $H_0$)\")\n\nplt.suptitle(r\"CDF of p-value under $H_1$ (LogNormal - 1.5)\", fontsize=14, y=1.02)\nplt.tight_layout()\nplt.show()"
  },
  {
    "objectID": "posts/2025-12-05-p-value/index.html#references",
    "href": "posts/2025-12-05-p-value/index.html#references",
    "title": "P-valueの考え方",
    "section": "References",
    "text": "References\n\n久保川 - 現代数理統計学の基礎, 7.5.4"
  },
  {
    "objectID": "posts/2025-12-03-BOM/index.html",
    "href": "posts/2025-12-03-BOM/index.html",
    "title": "UTF-8 の BOM 付き vs BOM なし",
    "section": "",
    "text": "Definition 1 BOM\n\nバイト順序（エンディアン）を示すためのマーク\nBOM は必ずテキストの先頭に付与される(= テキストの中間に置かれることはない)\nUTF-8 はバイト順序がないので必要ないが，UTF-8であることの判定のためにUTF-8 with BOM となる場合がある\n\n\nプログラムがテキストデータを読み込む際に先頭の数バイトによりUnicodeのデータであることやどの種類の符号化形式を採用しているのかを判別しています． BOM付きのUTF-8であれば先頭の3バイトがBOMであり，0xEF 0xBB 0xBFというデータになります．\nBOM一覧\n\n\n\n\n\n\n\n\n符号化形式（符号化スキーム）\nエンディアン\nバイト順マーク (BOM)\n\n\n\n\nUTF-8\nなし\nEF BB BF\n\n\nUTF-16\nBE\nFE FF\n\n\nUTF-16\nLE\nFF FE\n\n\nUTF-32\nBE\n00 00 FE FF\n\n\nUTF-32\nLE\nFF FE 00 00\n\n\n\n\n\n以下を内容とする test.sh というファイルがあるとします．\n#!/bin/bash\n\necho \"Hallo World!!\"\nBOMが付与されていないと\n$ xxd test.sh | head                \n00000000: 2321 2f62 696e 2f62 6173 680a 0a65 6368  #!/bin/bash..ech\n00000010: 6f20 2248 616c 6c6f 2057 6f72 6c64 2121  o \"Hallo World!!\n00000020: 220a 0a                                  \"..\nとなりますが，vim \"+set bomb\" \"+wq\" test.sh とBOMを付与すると\n$ xxd test.sh | head                 \n00000000: efbb bf23 212f 6269 6e2f 6261 7368 0a0a  ...#!/bin/bash..\n00000010: 6563 686f 2022 4861 6c6c 6f20 576f 726c  echo \"Hallo Worl\n00000020: 6421 2122 0a0a                           d!!\"..\n先頭バイトが efbb bf となっていることから UTF-8 with BOMであることがわかります．\nBOMありの場合，chmod +x test.sh 実行後にランしてみると\n$ ./test.sh                    \n./test.sh: 1: ﻿#!/bin/bash: not found\nHallo World!!\nとなります．\n\n\n\n\n\n\nNotenkf を用いた文字コード判定\n\n\n\nnkf コマンドと --guess オプションを組み合わせると，使用されている文字コードと改行コードの判定結果を表示することができます．\n$ nkf --guess test.sh \nUTF-8 (BOM) (LF)\n\n\n\n\n\n\nDefinition 2 nkf コマンド\n\nNetwork Kanji Filterの略\n文字コードと改行コードを変換するためのコマンド\nnkf [opttion] [file]\n\n\n入力文字コードオプション\n\n\n\nオプション\n意味\n\n\n\n\n-J\n入力を ISO-2022-JP とみなす\n\n\n-S\n入力を Shift_JIS とみなす\n\n\n-E\n入力を EUC-JP とみなす\n\n\n--ic=UTF-8\n入力を UTF-8 とみなす\n\n\n\n出力文字コードオプション\n\n\n\nオプション\n意味\n\n\n\n\n-j\n出力を ISO-2022-JP\n\n\n-s\n出力を Shift_JIS\n\n\n-e\n出力を EUC-JP\n\n\n-w\n出力を UTF-8（BOMなし）\n\n\n-w8\n出力を UTF-8（BOM付き）\n\n\n--oc=UTF-8\n出力を UTF-8（BOMなし）\n\n\n--oc=UTF-8-BOM\n出力を UTF-8（BOM付き）\n\n\n\n\n\nnkf --overwrite --oc=UTF-8 test.sh\nとすることでBOMなしUTF-8へ変換することが出来ます．\n\n\n\n\n\n\n\nオプション\n意味\n\n\n\n\n--overwrite\n元ファイルを上書きして保存する\n\n\n--oc=UTF-8\n出力の文字コードを UTF-8 にする\n\n\n\n内部的には\n\n元ファイルの文字コードが自動判定される\n内容を UTF-8 に変換\nBOM を持っていた場合は削除\n変換後の内容で test.sh を上書き保存\n\nという処理が行われるので，もし思ったような挙動が確認できない場合は「元ファイルの文字コードが自動判定される」に問題があるかもなので 入力文字コード指定オプションを組み合わせたりします"
  },
  {
    "objectID": "posts/2025-12-03-BOM/index.html#bombyte-order-mark",
    "href": "posts/2025-12-03-BOM/index.html#bombyte-order-mark",
    "title": "UTF-8 の BOM 付き vs BOM なし",
    "section": "",
    "text": "Definition 1 BOM\n\nバイト順序（エンディアン）を示すためのマーク\nBOM は必ずテキストの先頭に付与される(= テキストの中間に置かれることはない)\nUTF-8 はバイト順序がないので必要ないが，UTF-8であることの判定のためにUTF-8 with BOM となる場合がある\n\n\nプログラムがテキストデータを読み込む際に先頭の数バイトによりUnicodeのデータであることやどの種類の符号化形式を採用しているのかを判別しています． BOM付きのUTF-8であれば先頭の3バイトがBOMであり，0xEF 0xBB 0xBFというデータになります．\nBOM一覧\n\n\n\n\n\n\n\n\n符号化形式（符号化スキーム）\nエンディアン\nバイト順マーク (BOM)\n\n\n\n\nUTF-8\nなし\nEF BB BF\n\n\nUTF-16\nBE\nFE FF\n\n\nUTF-16\nLE\nFF FE\n\n\nUTF-32\nBE\n00 00 FE FF\n\n\nUTF-32\nLE\nFF FE 00 00\n\n\n\n\n\n以下を内容とする test.sh というファイルがあるとします．\n#!/bin/bash\n\necho \"Hallo World!!\"\nBOMが付与されていないと\n$ xxd test.sh | head                \n00000000: 2321 2f62 696e 2f62 6173 680a 0a65 6368  #!/bin/bash..ech\n00000010: 6f20 2248 616c 6c6f 2057 6f72 6c64 2121  o \"Hallo World!!\n00000020: 220a 0a                                  \"..\nとなりますが，vim \"+set bomb\" \"+wq\" test.sh とBOMを付与すると\n$ xxd test.sh | head                 \n00000000: efbb bf23 212f 6269 6e2f 6261 7368 0a0a  ...#!/bin/bash..\n00000010: 6563 686f 2022 4861 6c6c 6f20 576f 726c  echo \"Hallo Worl\n00000020: 6421 2122 0a0a                           d!!\"..\n先頭バイトが efbb bf となっていることから UTF-8 with BOMであることがわかります．\nBOMありの場合，chmod +x test.sh 実行後にランしてみると\n$ ./test.sh                    \n./test.sh: 1: ﻿#!/bin/bash: not found\nHallo World!!\nとなります．\n\n\n\n\n\n\nNotenkf を用いた文字コード判定\n\n\n\nnkf コマンドと --guess オプションを組み合わせると，使用されている文字コードと改行コードの判定結果を表示することができます．\n$ nkf --guess test.sh \nUTF-8 (BOM) (LF)\n\n\n\n\n\n\nDefinition 2 nkf コマンド\n\nNetwork Kanji Filterの略\n文字コードと改行コードを変換するためのコマンド\nnkf [opttion] [file]\n\n\n入力文字コードオプション\n\n\n\nオプション\n意味\n\n\n\n\n-J\n入力を ISO-2022-JP とみなす\n\n\n-S\n入力を Shift_JIS とみなす\n\n\n-E\n入力を EUC-JP とみなす\n\n\n--ic=UTF-8\n入力を UTF-8 とみなす\n\n\n\n出力文字コードオプション\n\n\n\nオプション\n意味\n\n\n\n\n-j\n出力を ISO-2022-JP\n\n\n-s\n出力を Shift_JIS\n\n\n-e\n出力を EUC-JP\n\n\n-w\n出力を UTF-8（BOMなし）\n\n\n-w8\n出力を UTF-8（BOM付き）\n\n\n--oc=UTF-8\n出力を UTF-8（BOMなし）\n\n\n--oc=UTF-8-BOM\n出力を UTF-8（BOM付き）\n\n\n\n\n\nnkf --overwrite --oc=UTF-8 test.sh\nとすることでBOMなしUTF-8へ変換することが出来ます．\n\n\n\n\n\n\n\nオプション\n意味\n\n\n\n\n--overwrite\n元ファイルを上書きして保存する\n\n\n--oc=UTF-8\n出力の文字コードを UTF-8 にする\n\n\n\n内部的には\n\n元ファイルの文字コードが自動判定される\n内容を UTF-8 に変換\nBOM を持っていた場合は削除\n変換後の内容で test.sh を上書き保存\n\nという処理が行われるので，もし思ったような挙動が確認できない場合は「元ファイルの文字コードが自動判定される」に問題があるかもなので 入力文字コード指定オプションを組み合わせたりします"
  },
  {
    "objectID": "posts/2025-12-03-BOM/index.html#appendix",
    "href": "posts/2025-12-03-BOM/index.html#appendix",
    "title": "UTF-8 の BOM 付き vs BOM なし",
    "section": "Appendix",
    "text": "Appendix\n\nDefinition 3 UTF-8\n\nUnicodeで割り振ったコードポイントの文字符号化形式(encoding形式)の一種\nASCIIと同じ文字は1バイト，その他の文字については2～4バイトを用いて文字を表現する\nASCIIとの対応関係があるので 「ASCIIと上位互換性がある」 と言われる\n\n\n\nExample 1 (Unicode と UTF-8 の対応)  \n\n\n\n\n\n\n\n\n\n文字\nUnicode\nUTF-8\nUTF-8の2進数表現\n\n\n\n\nA\nU+0041\n0x41\n0100 0001\n\n\nα\nU+03B1\n0xCE 0xB1\n1100 1110 1011 0001\n\n\n\nAのUTF-8の2進数表現は 8 bit = 1 Byteであるので，「ASCIIと同じ文字は1バイト」であることがわかります．また， α は16 bitとなっていますが，ギリシャ文字は ASCII の範囲外なので 2 Bytes となります．"
  },
  {
    "objectID": "posts/2025-12-03-BOM/index.html#references",
    "href": "posts/2025-12-03-BOM/index.html#references",
    "title": "UTF-8 の BOM 付き vs BOM なし",
    "section": "References",
    "text": "References\n\n【nkf】コマンド――文字コードと改行コードを変換する"
  },
  {
    "objectID": "posts/2025-06-16-refrigerating-machine-oil/index.html",
    "href": "posts/2025-06-16-refrigerating-machine-oil/index.html",
    "title": "冷凍機油",
    "section": "",
    "text": "Definition 1 冷凍機油\n\n冷凍空調機用の圧縮機に使用される潤滑油を冷凍機油と呼ぶ\n冷媒と直接接触する(冷媒と一緒に冷凍サイクルを流れる可能性がある)\nJIS Ｋ2211(摩擦試験方法」または「摩擦試験に関する規格」)等で規格化もされている\n\n\n冷凍機油の使用目的\n\n圧縮機の回転部分やシリンダとピストンの隙間などの摺動部分の摩擦/摩耗の防止\n圧縮機内の摩擦熱や作動熱を吸収・除去という冷却作用\n金属部品の腐食を防ぐ防錆目的\n圧縮機内部で冷媒ガスが漏れるのを防ぐために，ピストンや軸の隙間を密封するシーリング目的\n\n\n\n冷凍機油は冷凍サイクル内を冷媒と一緒に流れるので\n\n超低温からかなりの高温まで耐えること\n冷媒との相溶性に優れていること(溶け過ぎも溶けなさすぎもダメ)\n\nが必要です．相溶性が悪いと，分離した油が滞留し冷媒の流れを妨げるだけでなく，冷却装置の構成効果を低下させたり，キャピラリで閉塞を起こすこともあります． 使用目的と合わせて冷凍機油に求められる性質をまとめると以下のようになります\n\n\n\n\n\n\n\n\n性質\n説明\n\n\n\n\n適切な粘度\n潤滑性能の観点から，粘度は適切で，運転温度範囲内で安定していることが必要\n\n\n油膜形成性\n金属表面の接触を油膜が遮断することで，部品の摩耗や損傷を防ぐことができる\n\n\n低い凝固点\n凝固点が低いこと．冷凍機は低温環境で動くため，油が固まってしまうと潤滑性能が失われる\n\n\n化学的安定性\n高温や圧力の条件下でも分解や劣化が起こりにくいこと\n\n\n水分を含まないこと\n金属部品を腐食させない．水分を含んでしまうと，低温で氷ができ，配管やバルブの閉塞の原因になる\n\n\n酸分を含まないこと\n金属部品を酸化を通して腐食させない．\n\n\n硫黄分を含まないこと\n硫黄が酸化・分解すると腐食性の硫黄酸化物が発生し，金属の腐食を促進してしまう\n\n\n酸化しにくいこと\n酸化が進むと油の分子構造が変化し，粘度が変動したり，潤滑効果が低下．酸化分解物が集まるとスラッジができてしまう\n\n\n絶縁性\n冷凍機のコンプレッサーには電動モーターが使われているため，冷凍機油が絶縁性を持っていないとショートサーキットが発生してしまう\n\n\n絶縁材・シール材との適合性\n絶縁材・シール材とと化学的に反応せず，膨潤や硬化，脆化を起こさないこと\n\n\nワックス非析出\nワックスが生成されると配管や油路，フィルター詰まりを起こすリスクが上がる\n\n\n\n\n\n\n\n\n\n\nNote冷凍機油と冷媒液が二層分離した場合\n\n\n\n二層分離とは，冷凍機油と冷媒が混ざらずに，上層・下層の二層に分かれる状態のことです．冷凍機油と冷媒の「溶解度」が低いと，二層分離が起こる可能性が高くなります，二層分離による悪影響として\n\n\n\n\n\n\n\n項目\n内容\n\n\n\n\n① 潤滑不良\n油が冷媒と一緒に圧縮機を回らなくなり，潤滑部に油が届かない．→ 摩耗・焼き付きの原因\n\n\n② 冷媒循環不良\n油が冷媒ラインに滞留・詰まり，熱交換器での冷媒の流れが阻害される\n\n\n③ 起動不良・故障\n起動時に油が偏在すると，液圧縮や過負荷の原因になる\n\n\n④ 圧縮機温度上昇\n油膜が切れ，摩擦が増えることで発熱 → 過熱・絶縁劣化・寿命短縮\n\n\n⑤ 圧力損失\n油が冷媒と共に移動しないため，配管内の圧力損失が大きくなる\n\n\n\nそのため，\n\n冷媒と相溶性のある油を選定\n油戻し設計\n油分離器の設置\n定期点検・交換\n\nが重要になってきます．\n\n\n冷凍機器の構成と潤滑油に要求される性能\n\n\n\n\n\n\n\n\n主な構成部品\n油に要求される性能\n主な評価試験\n\n\n\n\n蒸発器（エバポレータ）\n① 低温流動性② 冷媒相溶性③ ワックス等の非析出性\n① 流動点② 冷媒溶解度，粘度，シールドチューブ冷媒共存流動点③ フロック点\n\n\n膨張弁（キャピラリ）\n① 耐スラッジ性② 剪断安定性③ 低温流動性④ ワックス非析出\n① 熱安定性②（剪断安定性）③，④ 同上\n\n\n凝縮器（コンデンサー）\n① 冷媒との高温相溶性\n冷媒との相溶性\n\n\n圧縮機（コンプレッサ）\n① 潤滑性，極圧性② 熱安定性，化学的安定性③ 冷媒相溶性④ モーター等材料適合性⑤ 密閉型圧縮機では電気絶縁性\n① ファレックス試験，高速四球，高圧摩擦試験② シールドチューブ加水分解安定性③ 冷媒相溶性④ シールドチューブ，オートクレーブ⑤ 絶縁破壊電圧・体積抵抗率"
  },
  {
    "objectID": "posts/2025-06-16-refrigerating-machine-oil/index.html#冷凍機油の使用目的",
    "href": "posts/2025-06-16-refrigerating-machine-oil/index.html#冷凍機油の使用目的",
    "title": "冷凍機油",
    "section": "",
    "text": "Definition 1 冷凍機油\n\n冷凍空調機用の圧縮機に使用される潤滑油を冷凍機油と呼ぶ\n冷媒と直接接触する(冷媒と一緒に冷凍サイクルを流れる可能性がある)\nJIS Ｋ2211(摩擦試験方法」または「摩擦試験に関する規格」)等で規格化もされている\n\n\n冷凍機油の使用目的\n\n圧縮機の回転部分やシリンダとピストンの隙間などの摺動部分の摩擦/摩耗の防止\n圧縮機内の摩擦熱や作動熱を吸収・除去という冷却作用\n金属部品の腐食を防ぐ防錆目的\n圧縮機内部で冷媒ガスが漏れるのを防ぐために，ピストンや軸の隙間を密封するシーリング目的\n\n\n\n冷凍機油は冷凍サイクル内を冷媒と一緒に流れるので\n\n超低温からかなりの高温まで耐えること\n冷媒との相溶性に優れていること(溶け過ぎも溶けなさすぎもダメ)\n\nが必要です．相溶性が悪いと，分離した油が滞留し冷媒の流れを妨げるだけでなく，冷却装置の構成効果を低下させたり，キャピラリで閉塞を起こすこともあります． 使用目的と合わせて冷凍機油に求められる性質をまとめると以下のようになります\n\n\n\n\n\n\n\n\n性質\n説明\n\n\n\n\n適切な粘度\n潤滑性能の観点から，粘度は適切で，運転温度範囲内で安定していることが必要\n\n\n油膜形成性\n金属表面の接触を油膜が遮断することで，部品の摩耗や損傷を防ぐことができる\n\n\n低い凝固点\n凝固点が低いこと．冷凍機は低温環境で動くため，油が固まってしまうと潤滑性能が失われる\n\n\n化学的安定性\n高温や圧力の条件下でも分解や劣化が起こりにくいこと\n\n\n水分を含まないこと\n金属部品を腐食させない．水分を含んでしまうと，低温で氷ができ，配管やバルブの閉塞の原因になる\n\n\n酸分を含まないこと\n金属部品を酸化を通して腐食させない．\n\n\n硫黄分を含まないこと\n硫黄が酸化・分解すると腐食性の硫黄酸化物が発生し，金属の腐食を促進してしまう\n\n\n酸化しにくいこと\n酸化が進むと油の分子構造が変化し，粘度が変動したり，潤滑効果が低下．酸化分解物が集まるとスラッジができてしまう\n\n\n絶縁性\n冷凍機のコンプレッサーには電動モーターが使われているため，冷凍機油が絶縁性を持っていないとショートサーキットが発生してしまう\n\n\n絶縁材・シール材との適合性\n絶縁材・シール材とと化学的に反応せず，膨潤や硬化，脆化を起こさないこと\n\n\nワックス非析出\nワックスが生成されると配管や油路，フィルター詰まりを起こすリスクが上がる\n\n\n\n\n\n\n\n\n\n\nNote冷凍機油と冷媒液が二層分離した場合\n\n\n\n二層分離とは，冷凍機油と冷媒が混ざらずに，上層・下層の二層に分かれる状態のことです．冷凍機油と冷媒の「溶解度」が低いと，二層分離が起こる可能性が高くなります，二層分離による悪影響として\n\n\n\n\n\n\n\n項目\n内容\n\n\n\n\n① 潤滑不良\n油が冷媒と一緒に圧縮機を回らなくなり，潤滑部に油が届かない．→ 摩耗・焼き付きの原因\n\n\n② 冷媒循環不良\n油が冷媒ラインに滞留・詰まり，熱交換器での冷媒の流れが阻害される\n\n\n③ 起動不良・故障\n起動時に油が偏在すると，液圧縮や過負荷の原因になる\n\n\n④ 圧縮機温度上昇\n油膜が切れ，摩擦が増えることで発熱 → 過熱・絶縁劣化・寿命短縮\n\n\n⑤ 圧力損失\n油が冷媒と共に移動しないため，配管内の圧力損失が大きくなる\n\n\n\nそのため，\n\n冷媒と相溶性のある油を選定\n油戻し設計\n油分離器の設置\n定期点検・交換\n\nが重要になってきます．\n\n\n冷凍機器の構成と潤滑油に要求される性能\n\n\n\n\n\n\n\n\n主な構成部品\n油に要求される性能\n主な評価試験\n\n\n\n\n蒸発器（エバポレータ）\n① 低温流動性② 冷媒相溶性③ ワックス等の非析出性\n① 流動点② 冷媒溶解度，粘度，シールドチューブ冷媒共存流動点③ フロック点\n\n\n膨張弁（キャピラリ）\n① 耐スラッジ性② 剪断安定性③ 低温流動性④ ワックス非析出\n① 熱安定性②（剪断安定性）③，④ 同上\n\n\n凝縮器（コンデンサー）\n① 冷媒との高温相溶性\n冷媒との相溶性\n\n\n圧縮機（コンプレッサ）\n① 潤滑性，極圧性② 熱安定性，化学的安定性③ 冷媒相溶性④ モーター等材料適合性⑤ 密閉型圧縮機では電気絶縁性\n① ファレックス試験，高速四球，高圧摩擦試験② シールドチューブ加水分解安定性③ 冷媒相溶性④ シールドチューブ，オートクレーブ⑤ 絶縁破壊電圧・体積抵抗率"
  },
  {
    "objectID": "posts/2025-06-16-refrigerating-machine-oil/index.html#冷凍機油の種類",
    "href": "posts/2025-06-16-refrigerating-machine-oil/index.html#冷凍機油の種類",
    "title": "冷凍機油",
    "section": "冷凍機油の種類",
    "text": "冷凍機油の種類\n冷凍機油は\n\n鉱物油\n合成油\n\nに大別されます．鉱油は石油由来の非極性炭化水素系を基油としており，ナフテン系鉱油やパラフィン系鉱油があります．非極性の炭化水素分子は，同じ非極性分子同士とはよく混ざり合うので，ＨＦＣ冷媒はＣＦＣ冷媒やＨＣＦＣ冷媒とは相溶性が良いです．一方，ＨＦＣ冷媒対応冷凍機油の場合，ＨＦＣ冷媒はＣＦＣ冷媒やＨＣＦＣ冷媒とは異なり構造的に電気的に極性を有するため，従来の鉱油とは相溶しません．そのため，冷凍機油の分子にエステル結合（-ＣＯＯ-） 等の極性を有する結合を導入し合成したＨＦＣ冷媒と相溶する冷凍機油が開発されています．\n具体的には，エステル結合を有するエステル油，カーボネート油，エーテル結合（-Ｏ-）を有するポリアルキレングリコール油（略称ＰＡＧ），ポリビニールエーテル油（略称ＰＶＥ）等が該当し，ＨＦＣ134ａ 対応のカーエアコンにはＰＡＧ，冷蔵庫にはポリオールエステル油（ヒンダードアルコール利用のエステル油，略称ＰＯＥ） が既に導入されており，Ｒ407ＣやＲ410Ａ対応空調機にはＰＯＥ，ＰＶＥが適応される傾向が有ります．\n\n\n\n\n\n\n\n\n\n\n用途\n主な圧縮機の形式\n主たる冷媒\n主たる潤滑油\n\n\n\n\n家庭用冷蔵庫\nレシプロ等\nR134a\nポリオールエステル（POE）\n\n\nカーエアコン\n斜板式，ロータリー，スクロール等\nR134a\nポリアルキレングリコール（PAG）\n\n\nエアコン\nロータリー，スクロール等\nR410A，R407C\nポリオールエステル（POE），ポリビニルエーテル（PVE）\n\n\nショーケース\nロータリー，スクロール，ターボ等\nR404A，R507\nポリオールエステル（POE）\n\n\n産業用冷凍機\nレシプロ，スクリュー，スクロール，ターボ等\nアンモニア\nポリアルキレングリコール（PAG）\n\n\n産業用冷凍機\nレシプロ，スクリュー，スクロール，ターボ等\nR404A，R507\nポリオールエステル（POE）\n\n\n\n\n\n\n\n\n\n\nNoteアンモニア冷媒圧縮機と冷凍機油\n\n\n\n\nアンモニアを冷媒とする往復圧縮機では，吐出しガス温度が高く，冷凍機油が劣化しやすい\n圧縮機から吐き出された冷凍機油が非相溶性の場合には，圧縮機に戻さず，冷凍装置の外部に放出する場合もある\nアンモニアと相溶性のある合成油を用いた場合は，フルオロカーボン冷媒と同様に油分離期から直接油を圧縮機に戻したり，装置内を循環させて圧縮機に戻したりする"
  },
  {
    "objectID": "posts/2025-06-16-refrigerating-machine-oil/index.html#冷凍機油と冷媒の相互溶解性",
    "href": "posts/2025-06-16-refrigerating-machine-oil/index.html#冷凍機油と冷媒の相互溶解性",
    "title": "冷凍機油",
    "section": "冷凍機油と冷媒の相互溶解性",
    "text": "冷凍機油と冷媒の相互溶解性\n相溶性は温度と圧力で定まり，二層分離するものから完全相溶するものに大別されます．\n\n温度条件: -40~90℃, 冷凍機油分率: 20~30 mass%\n\n\n\n冷凍機油\nR32\nR125\nR134a\nR143a\nR152a\n\n\n\n\nナフテン系\n分離\n分離\n分離\n分離\n分離\n\n\nPAG油\n-40℃以下で分離\n溶解\n溶解\n分離\n溶解\n\n\nエステル油\n溶解\n溶解\n溶解\n分離\n溶解\n\n\nエステル油\n分離\n溶解\n溶解\n-10℃以下で分離\n分離\n\n\n\n\n分離: 冷凍機油リッチな液相と冷媒液リッチな液相との２つの液相に分離すること\n\n\n\n\n\n\n\n\nNote\n\n\n\n溶解，部分溶解，分離は温度帯によって変化しますがR410とPOE油との溶解性をみると以下のように変化します\n\n\n\n\n\n温度帯\n40 mass%のR410Aの溶解性\n\n\n\n\n-59~-32℃\n分離\n\n\n-32~-23℃\n部分溶解\n\n\n-23~50℃\n溶解\n\n\n\n\n\n\n\n温度帯\n60 mass%のR410A\n\n\n\n\n-59~-15℃\n分離\n\n\n-15~-1℃\n部分溶解\n\n\n-1~30℃\n分離\n\n\n30~-37℃\n部分溶解\n\n\n37~-41℃\n分離\n\n\n\n\n\n\n\n温度帯\n95 mass%のR410A\n\n\n\n\n-59~-30℃\n分離\n\n\n-30~-10℃\n部分溶解\n\n\n-10~48℃\n溶解\n\n\n\n\n\n\n\n下の図では冷凍機油に対するR22の溶解度を示しています．横軸は溶解度ですが，質量分率で表されています．つまり 質量分率 = 冷媒質量 / 冷凍機油質量 です．平衡線図より\n\n圧力が同じであれば，温度が高いとR22の溶解度が小さい\n温度が同じであれば，圧力が低いときにR22の溶解度が小さくなる\n\n始動時のオイルフォーミングは，急に圧力が下がると平衡溶解度が小さくなるので，余分な冷媒が気化して追い出される現象です．\n\n\n\n冷凍機油とR22の平衡線図\n\n\n\n冷媒が冷凍機油に多量に溶け込むときの問題\n① 潤滑性能の低下（粘度低下）\n\n冷媒が油に多く溶け込むと，油の粘度が著しく低下します\n粘度が低いと，潤滑油膜が形成されにくくなり，摩擦・摩耗が増加\n\n② 発泡現象（フォーミング）\n\n圧縮機起動時や急激な圧力変化時に，冷媒が油から急に気化し，泡が発生\nこの泡によって油の供給が不安定になり，潤滑不足やキャビテーションを引き起こす可能性がある"
  },
  {
    "objectID": "posts/2025-06-16-refrigerating-machine-oil/index.html#油分離器-oil-separator",
    "href": "posts/2025-06-16-refrigerating-machine-oil/index.html#油分離器-oil-separator",
    "title": "冷凍機油",
    "section": "油分離器: Oil Separator",
    "text": "油分離器: Oil Separator\n\nDefinition 2 油分離器\n\n油分離器は，冷凍装置の圧縮機と凝縮器との間に設置し，圧縮機吐出しガスに含まれている冷凍機油を分離する機器\nフルオロカーボン冷凍装置や総妖精の冷凍機油を用いたアンモニア冷凍装置では，分離した冷凍機油を圧縮機のクランクケースへ戻す\n非相溶性の冷凍機油を用いたアンモニア冷凍装置では，分離した冷凍機油を油溜め器に送り出す場合もある\n小型のフルオロカーボン冷凍装置では配管距離が短いので油分離機を設けないことが多い\n\n\nなぜ凝縮器にそのまま冷凍機油を送り出してはいけないのか？\n\n吐出しガス中に含まれる冷凍機油をそのまま凝縮器に送り込むと，圧縮機の湯量は減少し，潤滑不良の原因となる\n凝縮器の伝熱作用を阻害する可能性もある\n凝縮器・膨張弁を経由して蒸発器に流入すると，冷凍機油が蒸発器に蓄積され，蒸発器での伝熱作用を阻害するリスクがある\n相溶性の冷凍機油を冷凍装置では，以下の観点から冷媒に混入した冷凍機油を蒸発器から圧縮機へ戻すことが難しい\n\n低圧配管ではガス密度が小さく，配管断面積が大きいため流速が遅い → 油を押し流す力が弱い\n一般に油は温度が低下するにつれ粘度は増大し，増大する分だけ油を押し流す力が必要になる\n\n\n\n\n\n\n\n\nNote複数圧縮機や蒸発器の台数が多い場合\n\n\n\n圧縮機や蒸発器の台数が多い場合，油を均等にクランケースに戻すのが難しくなります．そのため，油分離機を圧縮機後，凝縮器前に設置することが求められます．\n\n\n\n油分離器の原理\n\n\n圧縮機から吐出された油交じりの冷媒ガスを油分離器の側面にあてることで，油は壁面に付着し下部へ滴下する．（遠心分離）\nガスは上部から排出され，不要な油を系外へ排出しないようにしている．\n滴下した油は下部の油戻し穴を通って，圧縮機の吸入配管へ戻る．\n\n\n\n\n\n遠心分離系油分離器"
  },
  {
    "objectID": "posts/2025-06-16-refrigerating-machine-oil/index.html#油戻し運転",
    "href": "posts/2025-06-16-refrigerating-machine-oil/index.html#油戻し運転",
    "title": "冷凍機油",
    "section": "油戻し運転",
    "text": "油戻し運転\n\nDefinition 3 油戻し運転\n油戻し運転とは，冷媒回路内に拡散・滞留してしまった冷凍機油を圧縮機へ戻すための特別な運転のこと\n\n\n油戻し運転の方式\n方式①\n\n縦配管でも油が戻っていくまでの冷媒流速まで上げて冷媒ガスで冷凍機油を戻す\n流速を上げるので，インバータ周波数を高回転にする必要があり，その為に，室内機側の冷媒通過音が大きくなる。また能力が過剰になるため冷え過ぎる\n\n方式②\n\n液冷媒と一緒に油を戻す\n湿り運転させる必要があるので，液冷媒が圧縮機内に戻り，圧縮機故障につながる可能性がある"
  },
  {
    "objectID": "posts/2025-06-16-refrigerating-machine-oil/index.html#理解度チェック",
    "href": "posts/2025-06-16-refrigerating-machine-oil/index.html#理解度チェック",
    "title": "冷凍機油",
    "section": "📘 理解度チェック",
    "text": "📘 理解度チェック\n\nExercise 1 冷凍機油の使用目的\n次の記述の内，正しいものを選べ\n\n冷凍・空調用の圧縮機に使用されている潤滑油を冷凍機油と呼ぶ．HFC系冷媒用冷凍機油の合成油は水分を吸収しやすいものが多いので保守管理には注意を要する\n冷凍機油の役割は，圧縮機の軸受，ロータやピストンなどの潤滑面に油膜をつくり，金属どうしの直接接触を避け，円滑なしゅう動と摩耗防止とともに，摩擦によって生じる熱を除去することなどである\n\n\n\n\n\n\n\n\nNoteSolution\n\n\n\n\n\na, b\n\n\n\n\nExercise 2 冷凍機油の種類\n次の記述の内，正しいものを選べ\n\n冷凍機油は，鉱油と合成油の2種類がある\n鉱油は，炭化水素を基油にしている．ナフテン系鉱油，パラフィン系鉱油がある\n合成油の主なものは，ポリアルキレングリコール（PAG）油，ポリビニルエーテル（PVE）油，ポリオールエステル（POE）油などがある\n鉱油や合成油と混合して冷凍機油として用いているアルキルベンゼンがある\nHFC系冷媒は，アルキルベンゼン系鉱油などの炭化水素系冷凍機油には溶解しないが，合成油であるポリオールエステル（POE）油などには相溶性がある\n\n\n\n\n\n\n\n\nNoteSolution\n\n\n\n\n\na, b, c, d, e\n\n\n\n\nExercise 3 冷媒と冷凍機油の組合せ\n次の記述の内，正しいものを選べ\n\nフルオロカーボン中に水分が入ると，冷媒が加水分解されて腐食性物質を発生し，金属が腐食を起こす原因になる\nフルオロカーボン冷媒が油に溶け込む割合は，冷媒の圧力が高いほど，または温度が低いほど大きい\nフルオロカーボン冷媒は油とよく溶け合うので，吐出し管に脂分力を設けても，油を分離することはできない\nR22は油をよく溶解するので，蒸発器内に油が大量に滞留しても伝熱上支障がない\nフルオロカーボン容圧縮機のクランクケース内の油温が低い場合，始動時にオイルフォーミングを起こし，油上がりが多くなる\n\n\n\n\n\n\n\n\nNoteSolution\n\n\n\n\n\na, b, e"
  },
  {
    "objectID": "posts/2025-04-29-shellscript-tips/index.html",
    "href": "posts/2025-04-29-shellscript-tips/index.html",
    "title": "シェルコマンドTips",
    "section": "",
    "text": "Note直前のコマンドの引数呼び出し\n\n\n\n\n\n\n\n\nコマンド\n動作\nショートカット\n\n\n\n\n!^\n直前のコマンドの最初の引数\n\n\n\n!$\n直前のコマンドの最後の引数\nesc + . または Alt + .\n\n\n!:N\n直前のコマンドのN番目の引数\n\n\n\n!*\n直前のコマンドのすべての引数\n\n\n\n\nAlt + . の特徴\n\nAltを押しながら.を連続で入力すると，一回目は直前，二回目は２回前の最後の引数をsuggestしてくれます．\nesc+ .もセットで押せば同じような挙動となりますが，入力しづらいので Alt + . の方が好みです"
  },
  {
    "objectID": "posts/2025-04-29-shellscript-tips/index.html#シェルスクリプト便利コマンドリスト",
    "href": "posts/2025-04-29-shellscript-tips/index.html#シェルスクリプト便利コマンドリスト",
    "title": "シェルコマンドTips",
    "section": "",
    "text": "Note直前のコマンドの引数呼び出し\n\n\n\n\n\n\n\n\nコマンド\n動作\nショートカット\n\n\n\n\n!^\n直前のコマンドの最初の引数\n\n\n\n!$\n直前のコマンドの最後の引数\nesc + . または Alt + .\n\n\n!:N\n直前のコマンドのN番目の引数\n\n\n\n!*\n直前のコマンドのすべての引数\n\n\n\n\nAlt + . の特徴\n\nAltを押しながら.を連続で入力すると，一回目は直前，二回目は２回前の最後の引数をsuggestしてくれます．\nesc+ .もセットで押せば同じような挙動となりますが，入力しづらいので Alt + . の方が好みです"
  },
  {
    "objectID": "posts/2025-04-29-shellscript-tips/index.html#zsh-terminal用ショートカットリスト",
    "href": "posts/2025-04-29-shellscript-tips/index.html#zsh-terminal用ショートカットリスト",
    "title": "シェルコマンドTips",
    "section": "Zsh Terminal用ショートカットリスト",
    "text": "Zsh Terminal用ショートカットリスト\n\n\n\n\n\n\nNoteCursor moving\n\n\n\n\n\n\n\n\n\n\n\n\n\nショートカット\nkeybind setting\n動作\n\n\n\n\nctrl + ←\nbindkey '^[[1;5C' backward-word\ncursor backward by one word\n\n\nalt + B\ndefault\ncursor backward by one word\n\n\nctrl + →\nbindkey '^[[1;5D' forward-word\ncursor forward by one word\n\n\nalt + F\ndefault\ncursor forward by one word\n\n\nctrl + A\ndefault\nライン先頭へ移動\n\n\nhome\ndefault\nライン先頭へ移動\n\n\nctrl + E\ndefault\nライン末尾へ移動\n\n\nend\ndefault\nライン末尾へ移動\n\n\n\n\n\n\n\n\n\n\n\n\nNoteSearch\n\n\n\n\n\n\n\n\n\n\n\n\n\nショートカット\nkeybind setting\n動作\n\n\n\n\nctrl + R\ndefault\nReverse search in history\n\n\nctrl + S\ndefault\nForward search in history\n\n\n\n\n\n\n\n\n\n\n\n\nNoteEditing\n\n\n\n\n\n\n\n\n\n\n\n\n\nショートカット\nkeybind setting\n動作\n\n\n\n\nctrl + K\ndefault\nカーソル位置から後ろのwordsをすべて削除\n\n\nctrl + U\ndefault\nライン全消し\n\n\nctrl + Y\ndefault\n削除した文字列をペースト\n\n\nctrl + W\ndefault\nカーソル位置からword block先頭までを削除\n\n\n\n\n\n\n\n\n\n\n\n\nNoteGit\n\n\n\n\n\n\n\n\n\n\n\n\n\nショートカット\nkeybind setting\n動作\n\n\n\n\nctrl + G then ctrl + A\nbindkey \"^G^A\" _git_add\ngit add -u\n\n\nctrl + G then ctrl + home\n\"^G^[[1;5H\" _git_cd\ncd \"$(git root)\"\n\n\nctrl + G then ctrl + S\nbindkey \"^G^S\" _git_status\ngit status -sb\n\n\n\ngit status -sbコマンド\ngit status と git status -sbの違いは出力形式にあります\n\n\ngit status\n\n現在のブランチ、ステージ済み・未ステージの変更、未追跡ファイルなどを詳細に表示\n\n% git status\nOn branch main\nYour branch is up to date with 'origin/main'.\n\nChanges not staged for commit:\n  modified:   file.txt\n\ngit status -sb\n\n短くスクリプト向けの要約を表示\n\n-s で各ファイルの状態を2文字コードで表示（例: Mは変更）\n-b で現在のブランチと追跡情報を先頭に追加\n\n\n% git status -sb\n## main...origin/main\n M file.txt"
  },
  {
    "objectID": "posts/2025-04-29-shellscript-tips/index.html#appendix-1-ansi-escape-sequence",
    "href": "posts/2025-04-29-shellscript-tips/index.html#appendix-1-ansi-escape-sequence",
    "title": "シェルコマンドTips",
    "section": "Appendix-1: ANSI escape sequence",
    "text": "Appendix-1: ANSI escape sequence\n\n\n\n\n\n\n\n\n\nシンボル\n対応コマンド\n説明\n\n\n\n\n^[[\nESC + [\n\n\n\n1;5\nmodifier (5 = Ctrl)\n\n\n\n^A\nCtrl+A\n\n\n\n^G\nCtrl+G\nASCII 7, BEL, bell character\n\n\n^S\nCtrl+S\nASCII 19, XOFF, used for terminal flow control to pause output\n\n\nC\nCursor Right\n\n\n\nD\nCursor Left\n\n\n\nH\nHome key"
  },
  {
    "objectID": "posts/2025-04-29-shellscript-tips/index.html#appendix-2-custom-keybind-setup",
    "href": "posts/2025-04-29-shellscript-tips/index.html#appendix-2-custom-keybind-setup",
    "title": "シェルコマンドTips",
    "section": "Appendix-2: custom keybind setup",
    "text": "Appendix-2: custom keybind setup\n以下のファイルを .zshrc に読み込ませています\n\n\ncustom_keybind.sh\n\n#!/bin/zsh\n#---------------------------------------------------\n# cursor moving command\n#---------------------------------------------------\nbindkey '^[[1;5D' backward-word\nbindkey '^[[1;5C' forward-word\n\n\n#---------------------------------------------------\n# git-related command\n#---------------------------------------------------\nfunction _git_cd() {\n    echo \"cd $(git root)\"\n    cd \"$(git root)\"\n    zle accept-line\n}\nzle -N  _git_cd\n\nfunction _git_status() {\n    echo \"git status -sb\" \n    git status -sb\n    zle accept-line\n    #zle reset-prompt\n}\nzle -N  _git_status  # _git_status関数をgit_status widgetとして登録\n\nfunction _git_add() {\n    echo \"git add -u\" # promptにgit add -uを表示\n    git add -u\n    zle accept-line\n    \n}\nzle -N _git_add  # _git_status関数をgit_status widgetとして登録\n\nfunction _git_commit_amend() {\n    echo \"git commit --amend --no-edit\" # promptにgit commit --amend --no-editを表示\n    git commit --amend --no-edit\n    zle accept-line\n    \n}\nzle -N _git_commit_amend  # _git_commit_amend関数をgit_status widgetとして登録\n\nfunction _git_pull() {\n    echo \"git pull\" # promptにgit add -uを表示\n    git pull\n    zle accept-line\n    \n}\nzle -N _git_pull  # _git_status関数をgit_status widgetとして登録\n\nfunction _git_push() {\n    echo \"git push\" # promptにgit add -uを表示\n    git push\n    zle accept-line\n    \n}\nzle -N _git_push  # _git_status関数をgit_status widgetとして登録\n\n#---------------------------------------------------\n# vscode-related command\n#---------------------------------------------------\nfunction _vscode_cd() {\n    echo \"code-cd\" # promptにgit add -uを表示\n    code-cd\n    zle accept-line\n    \n}\nzle -N _vscode_cd  # _git_status関数をgit_status widgetとして登録\n\n\n#---------------------------------------------------\n# bindkey setup\n#---------------------------------------------------\n# git\nbindkey \"^G^A\" _git_add\nbindkey \"^G^[[1;5H\" _git_cd       # Ctrl + g + Home\nbindkey \"^G^M\" _git_commit_amend\nbindkey \"^G^P\" _git_push\nbindkey \"^G^l\" _git_pull\nbindkey \"^G^S\" _git_status\n\n# vscode related\nbindkey \"^V^[[1;5H\" _vscode_cd       # Ctrl + v + Home"
  },
  {
    "objectID": "posts/2024-12-11-BQ-create-external-table/index.html",
    "href": "posts/2024-12-11-BQ-create-external-table/index.html",
    "title": "Cloud StorageからExternal Tableの作成",
    "section": "",
    "text": "Google Cloud StorageからBigQuery上にExternal tabaleを作成する\nPartition Fieldが定義されたExternal tabaleを作成するための条件を確認する"
  },
  {
    "objectID": "posts/2024-12-11-BQ-create-external-table/index.html#このノートのスコープ",
    "href": "posts/2024-12-11-BQ-create-external-table/index.html#このノートのスコープ",
    "title": "Cloud StorageからExternal Tableの作成",
    "section": "",
    "text": "Google Cloud StorageからBigQuery上にExternal tabaleを作成する\nPartition Fieldが定義されたExternal tabaleを作成するための条件を確認する"
  },
  {
    "objectID": "posts/2024-12-11-BQ-create-external-table/index.html#external-tableとは",
    "href": "posts/2024-12-11-BQ-create-external-table/index.html#external-tableとは",
    "title": "Cloud StorageからExternal Tableの作成",
    "section": "External Tableとは？",
    "text": "External Tableとは？\n\nDefinition 1 External Table\n\nBigQueryのExternal Table（外部テーブル）は，BigQuery内にデータをコピーまたはインポートすることなく， 外部データソースに直接アクセスしてクエリを実行できる機能\nBigQueryにおけるExternal Tableの利用形式として，permanent tableとtemporary tableの２つがあります\n\n\npermanent tableとtemporary table\n\npermanent table: BigQuery dataset内に作成され，外部データソースにリンクされるテーブル\ntemporary table: 外部データソースに対して一時的にクエリを実行する場合に利用されるテーブル\n\n\n\n\n\n\n\nNote\n\n\n\n一時的なテスト処理などでtemporary tableを用いることは有用ですが，分析者間でクエリやコードを共有して分析を進める場合はpermanent tableを用いないと テーブルアクセスを共有できません．\n\n\nサポートされているデータストア&lt;\nBigQueryからアクセス可能な外部データソースとしてサポートされているデータストアは以下:\n\nBigLake\nCloud Storage\nBigtable\nGoogle Drive\nAmazon S3\nAzure Blob Storage\n\nPricing\nBigQueryのPricingは\n\nCompute pricing: クエリの処理にかかる費用\nStorage pricing: データ保存費用\n\nの２つから構成されています．External Tableを用いると，後者の方はCloud Storage換算の費用となるため，一般的には ストレージコストを抑えることができます．ただし，External Tableにアクセスして分析するたびに\n\nQuery cost: クエリ計算処理時間に比例するコスト\nBytes cost: External tableからのデータ読み取りサイズに比例するコスト\n\nが発生します．\n\n\n\n\n\n\nNotePricing費用低減のTips\n\n\n\nExternal Tableを用いた分析が一時的なものであるならばExternal Tableを用いたほうが良いと思いますが， 頻繁にBigQueryからアクセスする場合は\n\nPartitioning/Clusteringを用いてアクセスサイズを抑える\nSELECT以下で*を使用せず，分析に用いるカラムを明示的に指定して，スキャンサイズを抑える\n\nという工夫，またはBigQuery native tableとしてデータを保持することを検討したほうが良いと思います．\n\n\n\nExternal Table use cases\n\nExternal Tableの特徴\n\nBigQuery native tableとしてデータは保持しない\nExternal Tableと紐づく外部ストアの最新データに対して，クエリ処理が走る\n\nがあります．そのため，PoCや営業段階での分析や頻繁にupdateされるデータに対してのオンライン分析といった場面で活用されるケースが多いです．\n\n\nExample 1 営業段階でのアドホック分析\n\nBtoC向けサービスを展開している企業Aに対して営業をしているとする\nNDAを結んだ後に，企業Aが保有しているデータのサンプルとして２年間分の連携してもらった\nこのデータを用いて簡易的な分析を行い，どのようなインサイトが導けそうか？を次の営業会議で企業Aに伝え説得したい\n\nという場面を考えます．このとき，\n\nわざわざテーブルスキーマを定義する時間はあまりない→早くEDAをやりたい\nサンプルデータなので，プロジェクト受注後に連携されるであろうデータセットよりも情報量が少ない→わざわざテーブルスキーマしても再利用可能性は低い\n\nExternal Tableを利用することで以下のようなメリットを享受することができます:\n\nテーブルスキーマをわざわざ定義しなくても，BigQueryを用いた大容量のデータに対しての分析が可能\n複数の分析者間でサンプルデータをCloud Storageベースで簡単に共有できる\nPythonなどの言語を用いた分析でも，予めBigQueryで前処理して小さいdatamartを作成し，それに対してEDAが実施できる"
  },
  {
    "objectID": "posts/2024-12-11-BQ-create-external-table/index.html#external-table作成",
    "href": "posts/2024-12-11-BQ-create-external-table/index.html#external-table作成",
    "title": "Cloud StorageからExternal Tableの作成",
    "section": "External Table作成",
    "text": "External Table作成\nここでは，EXTERNAL PARTITION TABLEの作成を目的に\n\ngoogle cloud storageへのupload\nEXTERNAL TABLEの作成\n\nの２段階の流れで説明します．\n\nCloud Storageへのupload\n~/pupupuland_store_posというdirectory以下に，yyyymmdd形式の日付でpartitionされたPARQUET形式のデータがあるとします．\npupupuland_store_pos\n├── partition_dt=2023-09-23\n│   └── purchase_history_2023-09-23.parquet\n├── partition_dt=2023-09-24\n│   └── purchase_history_2023-09-24.parquet\n├── partition_dt=2023-09-25\n│   └── purchase_history_2023-09-25.parquet\n├── partition_dt=2023-09-26\n│   └── purchase_history_2023-09-26.parquet\n├── partition_dt=2023-09-27\n│   └── purchase_history_2023-09-27.parquet\n├── partition_dt=2023-09-28\n│   └── purchase_history_2023-09-28.parquet\n├── partition_dt=2023-09-29\n│   └── purchase_history_2023-09-29.parquet\n└── partition_dt=2023-09-30\n    └── purchase_history_2023-09-30.parquet\nこのディレクトリ構造を保持したまま，gs://project-make-dedede-great-again/というcloud storage bucketに格納したいとします．このとき\ngcloud storage cp -r ~/pupupuland_store_pos/ gs://project-make-dedede-great-again/\n以上で下準備は完了です．\nExternal Tableの作成\nGoogle Cloud project pupupuland-businessdata の dedede-holdings dataset以下に先程上げた pupupuland_store_pos tableを作成したいと思います．\nCREATE EXTERNAL TABLE `pupupuland-businessdata.dedede-holdings.pupupuland_store_pos`\nOPTIONS (\n  format = 'PARQUET',\n  uris = ['gs://project-make-dedede-great-again/pupupuland_store_pos/*'],\n  hive_partition_uri_prefix = 'gs://project-make-dedede-great-again/pupupuland_store_pos/', -- 末尾にスラッシュを追加\n  require_hive_partition_filter = false\n);\nrequire_hive_partition_filter フィールド\n\nrequire_hive_partition_filter フィールドはクエリ時にpartition_dtによるWHERE句フィルタリングを強制するか否かの設定フィールドです．\nデフォルトではfalseとなっており，この場合はフィルタリングしなくてもクエリできることを意味します．"
  },
  {
    "objectID": "posts/2024-12-11-BQ-create-external-table/index.html#appendix-hive形式",
    "href": "posts/2024-12-11-BQ-create-external-table/index.html#appendix-hive形式",
    "title": "Cloud StorageからExternal Tableの作成",
    "section": "Appendix: Hive形式",
    "text": "Appendix: Hive形式\n\nDefinition 2 Hive形式\n\n&lt;ベースパス&gt;/&lt;列名&gt;=&lt;値&gt;/&lt;ファイル名&gt;という構造を用いたファイルパスベースのパーティション構造\n\n\ngs://bucket/retail_data/partition_month=2022-07-01/part-0001.parquet\ngs://bucket/retail_data/partition_month=2022-08-01/part-0001.parquet\nという形式でparquetが格納されているときに, hive_partitioning_mode=AUTO を指定して外部テーブルを作成すると\n\npartition_month 列が自動で追加される\nWHERE partition_month = '2022-07-01' のようなクエリが使える\nクエリ効率もよくなる（パーティションプルーニング）\n\nというメリットがあります．"
  },
  {
    "objectID": "posts/2024-12-11-BQ-create-external-table/index.html#references",
    "href": "posts/2024-12-11-BQ-create-external-table/index.html#references",
    "title": "Cloud StorageからExternal Tableの作成",
    "section": "References",
    "text": "References\n\nIntroduction to external tables"
  },
  {
    "objectID": "posts/2025-02-04-add-distance-measurement/index.html",
    "href": "posts/2025-02-04-add-distance-measurement/index.html",
    "title": "単曲線と追加距離の計算",
    "section": "",
    "text": "▶  基本用語"
  },
  {
    "objectID": "posts/2025-02-04-add-distance-measurement/index.html#基本問題-曲線の長さを求める",
    "href": "posts/2025-02-04-add-distance-measurement/index.html#基本問題-曲線の長さを求める",
    "title": "単曲線と追加距離の計算",
    "section": "基本問題: 曲線の長さを求める",
    "text": "基本問題: 曲線の長さを求める\n\n\nExercise 1 \n下図に示すような単曲線ABを含む路線の中心線を設置することになった．\n\n扇形 \\(OAB\\) の半径 \\(r = 300\\)\n\\(\\displaystyle\\angle (IP) = \\frac{\\pi}{3}\\)\n\\(IP\\) までの追加距離を623(中心杭はAの手前にあるとする)\n\nとする．このとき，曲線の始点 \\(A\\) と 曲線の終点 \\(B\\) それぞれの追加距離を求めよ．なお，直線 \\(A(IP)\\) と \\(B(IP)\\) はそれぞれ円の接線であるとする．\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n\ndef draw_circle_with_two_tangent(x0, y0, r, ax, theta_start=0, theta_end=2 * np.pi, notations=('O', 'A', 'B', 'IP')):\n    # Generate circle points\n    theta = np.linspace(theta_start, theta_end, 720)\n    x_circle = x0 + r * np.cos(theta)\n    y_circle = y0 + r * np.sin(theta)\n\n    # plot\n    ax.plot(x_circle, y_circle, \"gray\", label=\"Circle (r={radius})\")\n    ax.plot([x0, x_circle[0]], [y0, y_circle[0]], \"gray\", linestyle=\"--\")\n    ax.plot([x0, x_circle[-1]], [y0, y_circle[-1]], \"gray\", linestyle=\"--\")\n    ax.text(x0, y0, notations[0], verticalalignment=\"top\", horizontalalignment=\"left\")\n    ax.scatter(x0, y0, color=\"k\")\n\n    # add text\n    ax.text(x_circle[-1], y_circle[-1], notations[1], label=\"Circle (r={radius})\")\n    ax.scatter(x_circle[-1], y_circle[-1], color=\"k\")\n    ax.text(x_circle[0], y_circle[0], notations[2], label=\"Circle (r={radius})\")\n    ax.scatter(x_circle[0], y_circle[0], color=\"k\")\n\n    # plot external intersection points\n    mid_theta = (theta_start + theta_end) / 2\n    diff_theta = (theta_end - theta_start) / 2 \n    external_x = np.cos(mid_theta) * abs(r / np.cos(diff_theta)) + x0\n    external_y = np.sin(mid_theta) * abs(r / np.cos(diff_theta)) + y0\n\n    ax.scatter(external_x, external_y, color=\"k\")\n    ax.text(external_x, external_y, notations[3], verticalalignment=\"bottom\", horizontalalignment=\"left\")\n    ax.plot(\n        [external_x, x_circle[0]], [external_y, y_circle[0]], \"gray\", linestyle=\"-\"\n    )\n    ax.plot(\n        [external_x, x_circle[-1]], [external_y, y_circle[-1]], \"gray\", linestyle=\"-\"\n    )\n\n    return {'A': (x_circle[-1], y_circle[-1]), 'B': (x_circle[0], y_circle[0]), 'IP': (external_x, external_y )}\n\n\n# params\nx0, y0, r0 = 200, 100, 300\ntheta_start = np.pi / 10\ntheta_end = np.pi / 10 + np.pi * 2/ 3\n\nfig, ax = plt.subplots(figsize=(6, 6))\ncoordinates = draw_circle_with_two_tangent(x0, y0, r0, ax, theta_start, theta_end)\nax.grid(True, linestyle=\"--\", alpha=0.6)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNoteSolution\n\n\n\n\n\n曲線の始点 \\(A\\) の追加距離は\n\\[\nA\\text{の追加距離} = IP\\text{の追加距離} - \\text{A(IP)の長さ}\n\\]\n直線 \\(A(IP)\\) は中心点 \\(O\\) とする円に接しているので\n\\[\n\\text{AOの長さ} \\times \\tan(\\angle (IP)OA)\n\\]\n接弦定理と円周角の定理より \\(\\angle (IP)\\) の外角を \\(I\\) とすると\n\\[\n\\begin{align}\n\\angle AOB &= I\\\\\n\\angle (IP)OA &= \\frac{I}{2}\n\\end{align}\n\\]\nしたがって，\n\\[\n\\text{AOの長さ} \\times \\tan \\frac{I}{2}\n\\]\n以上より\n\\[\n\\begin{align}\nA\\text{の追加距離}\n    &= 623 - 300 \\times \\tan \\frac{\\pi}{3}\\\\\n    &= 623 - 300\\sqrt{3} \\approx 103.4\n\\end{align}\n\\]\nまた，\\(B\\text{の追加距離}\\) は，弧 \\(AB\\) の長さがわかれば\n\\[\nB\\text{の追加距離} = A\\text{の追加距離} + \\text{弧}AB\\text{の長さ}\n\\]\nと計算できる．\n\\[\n\\begin{align}\n\\text{弧}AB\\text{の長さ}\n    &= R \\times I\\\\\n    &= 300 \\times \\frac{2}{3}\\pi\\\\\n    &= 200\\pi\n\\end{align}\n\\]\nしたがって，\n\\[\nB\\text{の追加距離} \\approx 103.4 + 628.40 = 731.80\n\\]\n実際にAの追加距離をPythonで近似計算してみると\n\n\nCode\nA, IP = np.array(coordinates['A']), np.array(coordinates['IP'])\nA_add_distance = 623 - np.linalg.norm(A - IP)\nprint(f\"Aの追加距離 = {A_add_distance:.2f}\")\n\n\nAの追加距離 = 103.38\n\n\n\n\n\n\n\nExercise 2 \n曲線半径 \\(r_1 = 400\\), \\(\\displaystyle\\angle AO_1B = \\frac{\\pi}{2}\\) となるような形で現道路 \\(AB\\) が存在するとする． 現在の道路を改良し \\(O_2\\) を中心とする円曲線からなる新しい道路 \\(AB_2\\) を建設したいとします．\n新しい道路の交点 \\(IP\\) の１は現道路と変わらないとする．\n\\(\\displaystyle\\angle AO_2B_2 = \\frac{\\pi}{3}\\) としたとき，\\(AB_2\\) の路線長を求めよ．\n\n\nCode\n# params\nx0, y0, r0 = 200, 100, 400\ntheta_start = np.pi / 3\ntheta_end = np.pi / 3 + np.pi / 2\n\nfig, ax = plt.subplots(figsize=(6, 6))\ncoordinates = draw_circle_with_two_tangent(x0, y0, r0, ax, theta_start, theta_end, ('$O_1$', '$A$', '$B_1$', '$IP$'))\nax.grid(True, linestyle=\"--\", alpha=0.6)\n\nr_new = 400 / np.tan(np.pi/6) \nA = np.array(coordinates['A'])\nO = np.array((200, 100))\nAO = O - A\nO_new = A + (AO / np.linalg.norm(AO)) * r_new\n\ncoordinates_new = draw_circle_with_two_tangent(*O_new, r_new, ax, theta_end - np.pi/3, theta_end, ('$O_2$', '$A$', '$B_2$', '$IP$'))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNoteSolution\n\n\n\n\n\n新道路の曲線半径を \\(r_2\\) としたとき，\\(A(IP)\\) の長さは\n\\[\n\\begin{align}\nA(IP)\n    &= r_1 \\times \\tan \\frac{\\pi}{4}\\\\\n    &= r_2 \\times \\tan \\frac{\\pi}{6}\n\\end{align}\n\\]\nと表されるので\n\\[\n\\begin{align}\nr_2\n    &= \\frac{400 \\times 1 }{\\tan \\frac{\\pi}{6}}\\\\\n    &= 400\\times \\sqrt{3}\n    &\\approx 400\\times 1.732\\\\\n    &= 692.8\n\\end{align}\n\\]\nしたがって，\n\\[\n\\text{曲線}AB_2 = 692.8 \\times \\frac{\\pi}{3} \\approx 725.1\n\\]"
  },
  {
    "objectID": "posts/2025-02-04-add-distance-measurement/index.html#障害物がある場合の曲線設定",
    "href": "posts/2025-02-04-add-distance-measurement/index.html#障害物がある場合の曲線設定",
    "title": "単曲線と追加距離の計算",
    "section": "障害物がある場合の曲線設定",
    "text": "障害物がある場合の曲線設定\n\n\nExercise 3 \n\n曲線半径 \\(r = 200\\)\n\\(A_1B_1\\) の長さ 100\n\\(\\angle AA_1B_1 = 150^\\circ\\)\n\\(\\angle BB_1A_1 = 120^\\circ\\)\n\nという情報が与えられているとき，線分 \\(AA_1\\) の長さを求めよ．なお，直線 \\(A(IP)\\) と \\(B(IP)\\) はそれぞれ円の接線であるとする．\n\n\nCode\n# params\nx0, y0, r0 = 200, 100, 200\ntheta_start = np.pi / 3\ntheta_end = theta_start + np.pi / 2\n\nfig, ax = plt.subplots(figsize=(6, 6))\nax.grid(True, linestyle=\"--\", alpha=0.6)\n\n## draw an arc\ncoordinates = draw_circle_with_two_tangent(x0, y0, r0, ax, theta_start, theta_end, ('$O$', '$A$', '$B$', '$IP$'))\n\n## drar mid-points\nB_IP = np.array(coordinates['B']) - np.array(coordinates['IP'])\nA_IP = np.array(coordinates['A']) - np.array(coordinates['IP'])\nB_1 = np.array(coordinates['IP']) + B_IP / np.linalg.norm(B_IP) * 100 / 2\nA_1 = np.array(coordinates['IP']) + A_IP / np.linalg.norm(A_IP) * 100 / 2 * np.sqrt(3)\n\nax.plot(\n        [A_1[0], B_1[0]], [A_1[1], B_1[1]], \"gray\", linestyle=\"-\"\n    )\n\nax.text(A_1[0], A_1[1], \"$A_1$\")\nax.text(B_1[0], B_1[1], \"$B_1$\")\n\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNoteSolution\n\n\n\n\n\n\\(\\displaystyle\\angle AOB = \\frac{\\pi}{2}\\) であるので\n\\[\n\\text{length of }A(IP) = 200 \\times \\tan 45^\\circ = 200\n\\]\n正弦定理より\n\\[\n\\frac{A_1B_1}{\\sin \\angle (IP)} = \\frac{A_1(IP)}{\\sin \\angle (IP)B_1A_1}\n\\]\nしたがって，\n\\[\n\\begin{align}\n\\text{length of }A_1(IP)\n    &= 100 \\times \\sin \\angle (IP)B_1A_1\\\\\n    &= 100 \\times \\frac{\\sqrt{3}}{2}\\\\\n    &\\approx 50 \\times 1.732 = 86.60\n\\end{align}\n\\]\n以上より\n\\[\n\\text{length of }AA_1 = 200 - 86.60 = 113.40\n\\]\nPythonで確認すると\n\n\nCode\nres = np.linalg.norm(np.array(coordinates['A']) - A_1)\nprint(f\"点Aから点A_1までの距離 = {res:.2f}\")\n\n\n点Aから点A_1までの距離 = 113.40"
  },
  {
    "objectID": "posts/2025-08-16-ubuntu-upgrade/index.html",
    "href": "posts/2025-08-16-ubuntu-upgrade/index.html",
    "title": "Ubuntu 24.04.3へのupgrade",
    "section": "",
    "text": "Ubuntu 24.04.3 LTSが2025-08-07にリリースされたので，22.04.4 LTSからアップグレード\nUbuntuはLTSといっても xx.xx.2 以降を待ったほうが，安定性やセキュリティパッチの恩恵を利用開始時から享受することができる\n\n\n\n\n\n\n項目\n22.04 LTS\n24.04 LTS\n\n\n\n\ngnome-shell --versio\n42.x\n46.x\n\n\npython3 --version\n3.10.x\n3.12.x\n\n\ngcc --version\n11.x\n13.x\n\n\nSystem monitorバー表示\n-\nSystem Extensionsで設定可能\n\n\n\n\n\n\n\n\n\n\n\n\nNoteUbuntu OS upgradeの手順\n\n\n\n基本的には, 以下の手順で行います\n\nsudo update-manager -cを実行し，Ubuntu の GUI アップデートマネージャ経由で新しいリリースがあるか確認\n表示内容に応じて「OSアップグレード」を実行\nアップグレードが完了したら，指示に従い reboot\n\n\n\n今回この手順で実行したところエラーが表示されたのでその解決方法を備忘録的に以下にまとめます．\nStep 1: パッケージ情報の更新\nsudo apt update\nsudo apt upgrade\nStep 2: OS upgradeの実行と問題の発覚\n% sudo update-manager -c\n...\nErrors were encountered while processing:\n thunderbird-locale-en\n thunderbird-locale-en-us\n thunderbird-locale-ja\n thunderbird-locale-en-gb\n上記のコマンドでOSのupgradeを試したところ，thunderbird関連のパッケージが原因でOSアップグレードができないというエラーが発生．\nStep 3: 問題パッケージの再確認\napt upgrade や apt install 実行中に失敗したDebianパッケージの一覧にthunderbirdは出てくるはずです．\nsudo dpkg --configure -a\nで何も出力されないのが理想ですが，設定途中に失敗したパッケージがあると一覧として出力されます．\nStep 4: thunderbirdのpurge\nthunderbirdはあとでもう一回設定しなおせば良いので，apt remove --purgeの実行を決断．\nsudo apt remove --purge 'thunderbird*'\nsudo apt autoremove\nsudo apt clean\n\napt-get purge ではなくて apt remove --purge を用いた理由は対話式で削除パッケージを確認したかったため\napt autoremove で不要なパッケージ（メタ情報的に依存関係に組み込まれていないパッケージ）を削除\napt cleanは/var/cache/apt/archives以下にキャッシュされた .deb形式ファイルを削除するコマンド\n\n\n\n\n\n\n\nWarningapt autoremove の注意点\n\n\n\napt autoremove の対象は以下の２つの基準によって抽出されます\n\nmanualではなくautoとしてapt-markされている(=インストールが手動ではない)\nそのパッケージに対して，手動でインストールされたパッケージが依存していない\n\nたまに使っているけれども auto でインストールされたパッケージがある場合，apt autoremove の候補に上がってきてしまう可能性があるので，事前にどのパッケージが削除されるのか ユーザー自身で確認することが重要です．\n自動的にインストールされたパッケージの確認\naptitude search '~i !~M'\n\n\n\n\nパターン\n説明\n\n\n\n\n!pattern\npattern に一致しないパッケージを選択\n\n\n~M\n自動的にインストールされたパッケージを選択\n\n\n~i\nインストールされているパッケージを選択\n\n\n\n\n\n\nStep 5: OS upgrade\nOSアップグレード中断の原因となったパッケージを除去した後，再度GUIベースでupdate managerを起動し作業を進めます．\nsudo update-manager -c\nこれで晴れて Ubuntu 24.04.3 LTSへのアップグレードが完了．"
  },
  {
    "objectID": "posts/2025-08-16-ubuntu-upgrade/index.html#ltsから24.04-ltsへのupgrade備忘録",
    "href": "posts/2025-08-16-ubuntu-upgrade/index.html#ltsから24.04-ltsへのupgrade備忘録",
    "title": "Ubuntu 24.04.3へのupgrade",
    "section": "",
    "text": "Ubuntu 24.04.3 LTSが2025-08-07にリリースされたので，22.04.4 LTSからアップグレード\nUbuntuはLTSといっても xx.xx.2 以降を待ったほうが，安定性やセキュリティパッチの恩恵を利用開始時から享受することができる\n\n\n\n\n\n\n項目\n22.04 LTS\n24.04 LTS\n\n\n\n\ngnome-shell --versio\n42.x\n46.x\n\n\npython3 --version\n3.10.x\n3.12.x\n\n\ngcc --version\n11.x\n13.x\n\n\nSystem monitorバー表示\n-\nSystem Extensionsで設定可能\n\n\n\n\n\n\n\n\n\n\n\n\nNoteUbuntu OS upgradeの手順\n\n\n\n基本的には, 以下の手順で行います\n\nsudo update-manager -cを実行し，Ubuntu の GUI アップデートマネージャ経由で新しいリリースがあるか確認\n表示内容に応じて「OSアップグレード」を実行\nアップグレードが完了したら，指示に従い reboot\n\n\n\n今回この手順で実行したところエラーが表示されたのでその解決方法を備忘録的に以下にまとめます．\nStep 1: パッケージ情報の更新\nsudo apt update\nsudo apt upgrade\nStep 2: OS upgradeの実行と問題の発覚\n% sudo update-manager -c\n...\nErrors were encountered while processing:\n thunderbird-locale-en\n thunderbird-locale-en-us\n thunderbird-locale-ja\n thunderbird-locale-en-gb\n上記のコマンドでOSのupgradeを試したところ，thunderbird関連のパッケージが原因でOSアップグレードができないというエラーが発生．\nStep 3: 問題パッケージの再確認\napt upgrade や apt install 実行中に失敗したDebianパッケージの一覧にthunderbirdは出てくるはずです．\nsudo dpkg --configure -a\nで何も出力されないのが理想ですが，設定途中に失敗したパッケージがあると一覧として出力されます．\nStep 4: thunderbirdのpurge\nthunderbirdはあとでもう一回設定しなおせば良いので，apt remove --purgeの実行を決断．\nsudo apt remove --purge 'thunderbird*'\nsudo apt autoremove\nsudo apt clean\n\napt-get purge ではなくて apt remove --purge を用いた理由は対話式で削除パッケージを確認したかったため\napt autoremove で不要なパッケージ（メタ情報的に依存関係に組み込まれていないパッケージ）を削除\napt cleanは/var/cache/apt/archives以下にキャッシュされた .deb形式ファイルを削除するコマンド\n\n\n\n\n\n\n\nWarningapt autoremove の注意点\n\n\n\napt autoremove の対象は以下の２つの基準によって抽出されます\n\nmanualではなくautoとしてapt-markされている(=インストールが手動ではない)\nそのパッケージに対して，手動でインストールされたパッケージが依存していない\n\nたまに使っているけれども auto でインストールされたパッケージがある場合，apt autoremove の候補に上がってきてしまう可能性があるので，事前にどのパッケージが削除されるのか ユーザー自身で確認することが重要です．\n自動的にインストールされたパッケージの確認\naptitude search '~i !~M'\n\n\n\n\nパターン\n説明\n\n\n\n\n!pattern\npattern に一致しないパッケージを選択\n\n\n~M\n自動的にインストールされたパッケージを選択\n\n\n~i\nインストールされているパッケージを選択\n\n\n\n\n\n\nStep 5: OS upgrade\nOSアップグレード中断の原因となったパッケージを除去した後，再度GUIベースでupdate managerを起動し作業を進めます．\nsudo update-manager -c\nこれで晴れて Ubuntu 24.04.3 LTSへのアップグレードが完了．"
  },
  {
    "objectID": "posts/2025-08-16-ubuntu-upgrade/index.html#upgrade後の対応",
    "href": "posts/2025-08-16-ubuntu-upgrade/index.html#upgrade後の対応",
    "title": "Ubuntu 24.04.3へのupgrade",
    "section": "Upgrade後の対応",
    "text": "Upgrade後の対応\n\nX11の有効化\nUbuntu 22.04 LTSの段階から /etc/gdm3/custom.conf にて\n[daemon]\n# Uncomment the line below to force the login screen to use Xorg\nWaylandEnable=false\nと設定していたので，作業は特段発生しません．セッションがX11かどうかを確認する場合は\necho $XDG_SESSION_TYPE\nを実行して，x11 と表示されれば問題ありません．\n\n\n\n\n\n\nNoteWaylandを採用しない理由\n\n\n\n\nスクリーンレコーダーソフト Kazam が未対応のため\n\n\n\n\n\n24.04 HWEのインストール\nなぜか uname -r で確認するとkernelがまだ 6.8.0-78-generic であったので，24.04 HWEを改めてインストールする\n% sudo apt install --install-recommends linux-generic-hwe-24.04\n\n# 依存関係エラーが発生していたなら\n% sudo apt --fix-broken install\nその後, rebootして以下のようになっていれば問題なしです．\n% uname -r\n6.14.0-28-generic\n古いkernelとパッケージの削除\ndpkg -lでシステムにインストール済みのパッケージを確認すると\n% dpkg -l | grep linux-generic\nii  linux-generic-hwe-22.04                        6.8.0-65.68~22.04.1                     amd64        Complete Generic Linux kernel and header\nii  linux-generic-hwe-24.04                        6.14.0-28.28~24.04.1                    amd64        Complete Generic Linux kernel and headers\nとなっていました．linux-generic-hwe-22.04は必要ないので\nsudo apt-get purge linux-generic-hwe-22.04\nで消し去ります．また合わせて，古いカーネルを sudo apt autoremove などで除去しとします．最後にGRUBの設定(/etc/default/grub)をupdateしときます\nsudo update-grub\n\n\n\n\n\n\nNoteGRUB\n\n\n\n\nGRUB(GRand Unified Bootloader)はLinuxで一般的に使われているブートローダー\n複数のOSやカーネルがインストールされている場合は，それらの切り替えを行うことができる\n設定ファイルは /etc/default/grub\n設定を変更する際は必ずバックアップを取るようにしましょう\n\n\n\n\n\n/etc/apt/sources.list.d/以下の.listファイルの更新\n\n\n\n\n\n\nNote再設定方針\n\n\n\n\nOS upgradeの際に，自動的にjammyからnobleに書き換えてくれますが，ユーザーが設定したパッケージレポジトリ設定は書き換えてくれないので，強引に設定し直します．\n基本的には公式インストール手順の内，レポジトリ設定の箇所だけ実行します\n\n\n\nDocker Engine\n基本的にはgpg keyとかはUbuntuならば共通のものを使っているようだったので，repository updateのみで十分と判断\necho \\\n  \"deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.asc] https://download.docker.com/linux/ubuntu \\\n  $(. /etc/os-release && echo \"${UBUNTU_CODENAME:-$VERSION_CODENAME}\") stable\" | \\\n  sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null\nsudo apt-get update\ntailscale\ncurl -fsSL https://pkgs.tailscale.com/stable/ubuntu/noble.noarmor.gpg | sudo tee /usr/share/keyrings/tailscale-archive-keyring.gpg &gt;/dev/null\\ncurl -fsSL https://pkgs.tailscale.com/stable/ubuntu/noble.tailscale-keyring.list | sudo tee /etc/apt/sources.list.d/tailscale.list\nその他\ngrep -r \"jammy\" /etc/apt/sources.list.d/ | egrep -v \"distUpgrade:\"\nで22.04 LTSベースの.listファイルがないかを確認し，必要に応じてrmを実行．\n\n\nNVIDIA GPU Driverとcuda13.0のupgrade\nsection\n% ubuntu-drivers devices\nudevadm hwdb is deprecated. Use systemd-hwdb instead.\n...\ndriver   : nvidia-driver-580-open - third-party non-free recommended\nとあったので，\nsudo apt install -y nvidia-driver-580-open\ncuda toolkit\n公式のインストール手順に従い以下を実行\n% wget https://developer.download.nvidia.com/compute/cuda/repos/ubuntu2404/x86_64/cuda-ubuntu2404.pin\n% sudo mv cuda-ubuntu2404.pin /etc/apt/preferences.d/cuda-repository-pin-600\n% wget https://developer.download.nvidia.com/compute/cuda/13.0.0/local_installers/cuda-repo-ubuntu2404-13-0-local_13.0.0-580.65.06-1_amd64.deb\n% sudo dpkg -i cuda-repo-ubuntu2404-13-0-local_13.0.0-580.65.06-1_amd64.deb\n% sudo cp /var/cuda-repo-ubuntu2404-13-0-local/cuda-*-keyring.gpg /usr/share/keyrings/\n% sudo apt-get update\n% sudo apt-get -y install cuda-toolkit-13-0\nreboot後の確認\n# GPU driver\n% nvidia-smi\n\n# CUDA compiler version\nnvcc --version\n\n# pathが通っていない場合\n/usr/local/cuda-13.0/bin/nvcc --version\n\n\n\n\n\n\nNotenvidia-smiのcuda version\n\n\n\n\nnvidia-smiで出力される CUDA Versionは実際のCUDA versionではなく，対応可能な最大バージョンを示しています\nインストールされているCUDA versionを確認する場合は nvcc --version を実行する必要があります\n\n% nvidia-smi         \nWed Aug 20 02:15:15 2025       \n+-----------------------------------------------------------------------------------------+\n| NVIDIA-SMI 580.65.06              Driver Version: 580.65.06      CUDA Version: 13.0     |\n+-----------------------------------------+------------------------+----------------------+\n| GPU  Name                 Persistence-M | Bus-Id          Disp.A | Volatile Uncorr. ECC |\n| Fan  Temp   Perf          Pwr:Usage/Cap |           Memory-Usage | GPU-Util  Compute M. |\n|                                         |                        |               MIG M. |\n|=========================================+========================+======================|\n|   0  NVIDIA GeForce RTX 4070        On  |   00000000:01:00.0  On |                  N/A |\n|  0%   33C    P5             13W /  215W |    1167MiB /  12282MiB |      4%      Default |\n|                                         |                        |                  N/A |\n+-----------------------------------------+------------------------+----------------------+\n\n\n\n\npipx関係パッケージの再インストール\n\n\n\n\n\n\nNote\n\n\n\n\nDefaultのPython versisonが変化したので基本的にpipxで導入したものは再インストールが必要です\npipx uninstallはconfigファイルまでは消去しないので，uninstall→installの手順でOKです\n\n\n\ngpustatsの再インストール\n## uninstall\n% pipx uninstall gpustat\n\n## re-intsall\n% pipx install gpustat\n\n## check command\n% gpustat\nPoetryの再インストール\n## uninstall\n% pipx uninstall poetry\n\n## re-intsall\n% pipx install poetry\n\n## check command\n% poetry --versison\n\n## extensionsのre-innstall\n% pipx inject poetry poetry-plugin-shell\n\n\nDocker Desktopの再インストール\n問題事象\n\nDocker Desktopがうまく起動しない問題が発生\n\n原因調査\nDocker自体が死んでいるかどうかをまず調査\n% docker run hello-world\n\n\nHello from Docker!\nThis message shows that your installation appears to be working correctly.\n\nTo generate this message, Docker took the following steps:\n 1. The Docker client contacted the Docker daemon.\n 2. The Docker daemon pulled the \"hello-world\" image from the Docker Hub.\n    (amd64)\n 3. The Docker daemon created a new container from that image which runs the\n    executable that produces the output you are currently reading.\n 4. The Docker daemon streamed that output to the Docker client, which sent it\n    to your terminal.\n\nTo try something more ambitious, you can run an Ubuntu container with:\n $ docker run -it ubuntu bash\n\nShare images, automate workflows, and more with a free Docker ID:\n https://hub.docker.com/\n\nFor more examples and ideas, visit:\n https://docs.docker.com/get-started/\n\n% docker --version\nDocker version 28.3.3, build 980b856\nDocker自体は問題がないと判断し，あくまでdocker-desktopがうまく起動しないとして問題に対処しました．\nトラブルシューティング\nsystemctl --failed や sudo journalctl -p err | grep \"docker\" | less コマンドを実行すると\nFailed to start app-gnome-docker\nというエラーメッセージが出現していたので，設定ファイルを消さずに再インストールを行います．\nsudo apt remove docker-desktop\nその後，Docker公式ページが配布しているDebianパッケージをダウンロードして，\nsudo apt-get install ./docker-desktop-amd64.deb\nを実行すれば終了です．\n\n\ncups-browsed serviceの無効化\ncups-browsedサービス\n\nDNS-SD を使ってネットワーク上のプリンタや USB 接続の IPP プリンタ，プリンタアプリ，リモート CUPS キューなどの印刷サービスを自動で見つけてくれるサービス\nプリンターは特に使わないのでdisableしておく\n\n手順\n# サービスのstop\n% sudo systemctl stop cups-browsed\n\n# サービスの無効化\nsudo systemctl disable cups-browsed\n\n# status確認\n% systemctl status cups-browsed   \n○ cups-browsed.service - Make remote CUPS printers available locally\n     Loaded: loaded (/usr/lib/systemd/system/cups-browsed.service; disabled; preset: enabled)\n     Active: inactive (dead)"
  },
  {
    "objectID": "posts/2025-08-16-ubuntu-upgrade/index.html#appendix-インストール後の-.debファイルの取り扱い",
    "href": "posts/2025-08-16-ubuntu-upgrade/index.html#appendix-インストール後の-.debファイルの取り扱い",
    "title": "Ubuntu 24.04.3へのupgrade",
    "section": "Appendix: インストール後の .debファイルの取り扱い",
    "text": "Appendix: インストール後の .debファイルの取り扱い\n\n\n\n\n\n\nNote.debファイルの取り扱い\n\n\n\nプログラムのインストールに必要なファイルをまとめたものが.debファイルなので，インストール後は基本的に削除してしまって問題ありません．\n\n\nUbuntuでapt-getを使ってインストールする場合，\n\n/var/cache/apt/archives に .debファイルをダウンロード\ndpkgコマンドを用いて，プログラムをインストール\n\nという流れになります．/var/cache/apt/archives以下は基本的に再インストールしたい場合などを除いて使いみちがないので削除してしまっても問題ありません． rm コマンドを用いるよりかは，\n## interactiveに結果を確認したい場合\nsudo apt clean\n\n## スクリプトで実行する場合(標準出力が簡素)\nsudo apt-get clean\nを実行してクリーンすることが推奨されます．"
  },
  {
    "objectID": "posts/2025-08-16-ubuntu-upgrade/index.html#references",
    "href": "posts/2025-08-16-ubuntu-upgrade/index.html#references",
    "title": "Ubuntu 24.04.3へのupgrade",
    "section": "References",
    "text": "References\n\nask Ubuntu &gt; Ubuntu 24.04 Nvidia drivers\naptitude Search patterns\ncups-browsed"
  },
  {
    "objectID": "posts/2025-11-14-watch-gpu/index.html",
    "href": "posts/2025-11-14-watch-gpu/index.html",
    "title": "watchコマンドを用いてGPUリソースを確認する",
    "section": "",
    "text": "Definition 1 watch コマンド\n\nwatch は，指定したコマンドを 一定間隔で繰り返し実行し，結果をフルスクリーンで表示する Linux コマンド\n実行中は Ctrl + C で終了できます\nwatch [オプション] コマンド\n\n\n用途として，\n\nファイルやプロセスの状態を監視\nGPU 使用率やメモリ使用量などの変化を追跡\nディレクトリ内の変化を監視\n\nをTerminal上でリアルタイムで確認することが出来ます．\nOptions\n\n\n\n\n\n\n\n\n\n短いオプション\n長いオプション\n説明\n\n\n\n\n-t\n--no-title\nヘッダ（実行間隔・コマンド名・開始時刻）を非表示\n\n\n-e\n--errexit\n実行したコマンドがエラー（0以外）で終了したら watch も終了\n\n\n-b\n--beep\nエラー時にビープ音を鳴らす\n\n\n-d\n--differences\n直前の結果と比較し，変化した箇所をハイライト\n\n\n-d=permanent\n\n初回実行から変化した箇所をハイライト表示\n\n\n-c\n--color\nANSI カラー指定を有効にする\n\n\n-g\n--chgexit\n実行結果が変化したら watch を終了\n\n\n-n 秒数\n--interval 秒数\n実行間隔（秒）を指定，最小 0.1 秒\n\n\n-p\n--precise\n実行タイミングをより厳密に制御\n\n\n-x\n--exec\nコマンドを exec で実行（sh -c ではない）\n\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\n\n\n\n\n\n\n\n\n\nコマンド\nシェルによる展開のタイミング\n表示される PID\n\n\n\n\nwatch echo $$\n入力した瞬間に展開される\n常に「現在のシェルの PID」 → 変化しない\n\n\nwatch echo '$$'\n展開されずに watch に渡る → watch 内の sh が展開\n毎回「新しい sh の PID」 → 変化する\n\n\n\n\n\n\nwatch で実行されるコマンドは，そのまま実行されるのではなsh -c &lt;コマンド文字列&gt;として新しいシェルに渡されてから実行されています．\nsh -c \"&lt;command&gt;\"\nこのため，指定したコマンドの引数の中で環境変数やシェル変数を参照したいなど，引用符を使いたい場合は，適宜引用符を補う必要があります．\n\nExample 1 (watch echo $$の場合) \nwatch echo $$\nとすると，シェルが先に $$ を展開 してしまいます．つまり，実行時のシェルのPIDが1000なら\nwatch echo 1000\nと解釈され実行されます．毎回新しいシェルで展開されることを実現したいならば\nwtach echo '$$'\nとすると\nsh -c \"echo $$\"\nと解釈され，sh が $$ を展開し，実行時の sh の PID が表示されます．"
  },
  {
    "objectID": "posts/2025-11-14-watch-gpu/index.html#watch-コマンド",
    "href": "posts/2025-11-14-watch-gpu/index.html#watch-コマンド",
    "title": "watchコマンドを用いてGPUリソースを確認する",
    "section": "",
    "text": "Definition 1 watch コマンド\n\nwatch は，指定したコマンドを 一定間隔で繰り返し実行し，結果をフルスクリーンで表示する Linux コマンド\n実行中は Ctrl + C で終了できます\nwatch [オプション] コマンド\n\n\n用途として，\n\nファイルやプロセスの状態を監視\nGPU 使用率やメモリ使用量などの変化を追跡\nディレクトリ内の変化を監視\n\nをTerminal上でリアルタイムで確認することが出来ます．\nOptions\n\n\n\n\n\n\n\n\n\n短いオプション\n長いオプション\n説明\n\n\n\n\n-t\n--no-title\nヘッダ（実行間隔・コマンド名・開始時刻）を非表示\n\n\n-e\n--errexit\n実行したコマンドがエラー（0以外）で終了したら watch も終了\n\n\n-b\n--beep\nエラー時にビープ音を鳴らす\n\n\n-d\n--differences\n直前の結果と比較し，変化した箇所をハイライト\n\n\n-d=permanent\n\n初回実行から変化した箇所をハイライト表示\n\n\n-c\n--color\nANSI カラー指定を有効にする\n\n\n-g\n--chgexit\n実行結果が変化したら watch を終了\n\n\n-n 秒数\n--interval 秒数\n実行間隔（秒）を指定，最小 0.1 秒\n\n\n-p\n--precise\n実行タイミングをより厳密に制御\n\n\n-x\n--exec\nコマンドを exec で実行（sh -c ではない）\n\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\n\n\n\n\n\n\n\n\n\nコマンド\nシェルによる展開のタイミング\n表示される PID\n\n\n\n\nwatch echo $$\n入力した瞬間に展開される\n常に「現在のシェルの PID」 → 変化しない\n\n\nwatch echo '$$'\n展開されずに watch に渡る → watch 内の sh が展開\n毎回「新しい sh の PID」 → 変化する\n\n\n\n\n\n\nwatch で実行されるコマンドは，そのまま実行されるのではなsh -c &lt;コマンド文字列&gt;として新しいシェルに渡されてから実行されています．\nsh -c \"&lt;command&gt;\"\nこのため，指定したコマンドの引数の中で環境変数やシェル変数を参照したいなど，引用符を使いたい場合は，適宜引用符を補う必要があります．\n\nExample 1 (watch echo $$の場合) \nwatch echo $$\nとすると，シェルが先に $$ を展開 してしまいます．つまり，実行時のシェルのPIDが1000なら\nwatch echo 1000\nと解釈され実行されます．毎回新しいシェルで展開されることを実現したいならば\nwtach echo '$$'\nとすると\nsh -c \"echo $$\"\nと解釈され，sh が $$ を展開し，実行時の sh の PID が表示されます．"
  },
  {
    "objectID": "posts/2025-11-14-watch-gpu/index.html#watchコマンド実践",
    "href": "posts/2025-11-14-watch-gpu/index.html#watchコマンド実践",
    "title": "watchコマンドを用いてGPUリソースを確認する",
    "section": "watchコマンド実践",
    "text": "watchコマンド実践\n\nCase 1: GPUリソースを監視する\nRequirements\n% gpustat --version\ngpustat 1.1.1\n\n% byobu --version\nbyobu version 6.11\ntmux 3.4\nコマンド\nwatch -n 1 nvidia-smi\n\n毎秒（1秒間隔）で nvidia-smi を再実行し，GPUの状態を表示するコマンド\n\nwatch -n 1 gpustat --color\n\n毎秒（1秒間隔）で gpustat を再実行し，GPUの状態をカラー表示で更新するコマンド\nnvidia-smiと比べ表示がコンパクト\n\nTips\n\nByobuを用いている場合は Shift + F2 で上下にwindowをsplitして，Alt + Shift + ↑/↓ で表示を領域をコンパクトにできる\nGnome Terminator の場合は Ctrl + Shift + O で上下split，その後 Ctrl + Shift + ↑/↓ で表示を領域をresize\n\n\n\nCase 2: メモリリソースを監視する\n\nコマンド\nwatch -n 1 free -h\n\n毎秒（1秒間隔）で free -h を再実行し，メモリとSwapの使用状況を表示するコマンド\navailable 列を見ることで，アプリが実際に使えるメモリ量を把握できる\n\n\n\nCase 3: Dockerの起動状態を確認する\n\nコマンド\nwatch -n 30 -t \"docker ps\"\n\n\n\n\nオプション/コマンド\n説明\n\n\n\n\nwatch\nコマンドを定期実行\n\n\n-n 30\n30秒ごとに実行\n\n\n-t\nヘッダーを非表示\n\n\ndocker ps\n現在動作中の Docker コンテナを一覧表示\n\n\n\n\n\n引用符 \" はなくても僕の環境では動作しますが，常に安全に動かすには引用符で囲む方が安全とのことです．\n\n\n\nCase 4: Memory Usageの確認\n\nコマンド\nwatch -n 1 free -m\n表示結果例は以下\n               total        used        free      shared  buff/cache   available\nMem:           63439        7314       46771         216        9898       56124\nSwap:           8191           0        8191\n\n\n\n\n\n\n\n\n\n項目\nサイズ (MB)\n説明\n\n\n\n\ntotal\n63439\nシステム全体の物理メモリ量（約63GB）\n\n\nused\n7314\nOSやプロセスによって現在使用中のメモリ量（キャッシュ・バッファ含む）\n\n\nfree\n46771\n現在まったく使用されていない空きメモリ\n\n\nshared\n216\nプロセス間で共有されているメモリ（最近の Linux では重要度低め）\n\n\nbuff/cache\n9898\nファイルキャッシュやバッファとして使われているメモリ（必要なら解放可能）\n\n\navailable\n56124\n実際に新しいアプリが使えるメモリ（キャッシュ分も含めて計算済み）\n\n\n\n\nメモリの逼迫度や空き容量は基本的には available フィールドの値を見て判断します．\n\n\n\n\n\n\nNoteCache領域\n\n\n\n\nディスクキャッシュは，最近アクセスしたファイルを RAM に保持する仕組み\nLinuxは未使用のメモリをディスクキャッシュ用に利用する\nキャッシュはアプリからメモリを奪うことはなく，性能向上にだけ使われる\nused にはキャッシュも含まれるので，見た目だけでは「メモリ不足」に見えることがあることに注意"
  },
  {
    "objectID": "posts/2025-11-14-watch-gpu/index.html#references",
    "href": "posts/2025-11-14-watch-gpu/index.html#references",
    "title": "watchコマンドを用いてGPUリソースを確認する",
    "section": "References",
    "text": "References\n\nByobu公式ページ\nHow do I clean or disable the memory cache?"
  },
  {
    "objectID": "posts/2025-01-10-list-up-users/index.html",
    "href": "posts/2025-01-10-list-up-users/index.html",
    "title": "Linuxシステム上のユーザー一覧を条件に応じて表示する",
    "section": "",
    "text": "🎯 スクリプトの目的\n/etc/passwd ファイルを読み取り，以下のユーザーを表示する:\n\nすべてのユーザー\nシステムユーザー（UID &lt; 1000）\nhumanユーザー（UID &gt;= 1000）\n\nデフォルトでは humanユーザー を表示させる．\n\n\n\n#!/bin/bash\n\nprint_help() {\n    echo \"Usage: $0 [-a|-s|-h]\"\n    echo \"Options:\"\n    echo \"  -a    Show all users\"\n    echo \"  -s    Show only system users\"\n    echo \"  -h    Show only human users\"\n    echo \"  -?    Show this help message\"\n    exit 1\n}\n\n# Default to human users if no option is provided\nMODE=\"human\"\n\nwhile getopts \"ash?\" opt; do\n    case $opt in\n        a) MODE=\"all\";;\n        s) MODE=\"system\";;\n        h) MODE=\"human\";;\n        ?) print_help;;\n    esac\ndone\n\n# Print header\nprintf \"%-20s %-6s %-6s\\n\" \"Username\" \"UID\" \"GID\"\n\ncase $MODE in\n    \"all\")\n        awk -F: '{ printf \"%-20s %-6s %-6s\\n\", $1, $3, $4 }' /etc/passwd\n        ;;\n    \"system\")\n        awk -F: '$3 &lt; 1000 { printf \"%-20s %-6s %-6s\\n\", $1, $3, $4 }' /etc/passwd\n        ;;\n    \"human\")\n        awk -F: '$3 &gt;= 1000 && $3 &lt; 65534 { printf \"%-20s %-6s %-6s\\n\", $1, $3, $4 }' /etc/passwd\n        ;;\nesac\n\n\n\nオプションの処理\nwhile getopts \"ash?\" opt; do\n    case $opt in\n        a) MODE=\"all\";;\n        s) MODE=\"system\";;\n        h) MODE=\"human\";;\n        ?) print_help;;\n    esac\ndone\n\ngetopts を使って、コマンドラインオプションに応じて処理分岐\nMODE という変数に条件を記録し，optionに応じた処理は後段で実装\n\n\n\n\noption\n処理内容\n\n\n\n\n-a\n全ユーザー表示\n\n\n-s\nシステムユーザーのみ表示（UID &lt; 1000）\n\n\n-h\nhumanユーザーのみ表示\n\n\n-?\nヘルプを表示，status codeは exit 1\n\n\n\nヘッダー出力\nprintf \"%-20s %-6s %-6s\\n\" \"Username\" \"UID\" \"GID\"\n\n整形されたカラム見出しを出力\n%-20sは文字列(s)を左寄せで20文字分の幅で表示\n\n\n\n\n\n書式指定子\n意味\n\n\n\n\n%-20s\n左寄せで20文字幅の文字列（Username列）\n\n\n%-6s\n左寄せで6文字幅の文字列（UID列）\n\n\n%-6s\n左寄せで6文字幅の文字列（GID列）\n\n\n\n\nユーサー一覧の取得\ncase $MODE in\n    \"all\")\n        awk -F: '{ printf \"%-20s %-6s %-6s\\n\", $1, $3, $4 }' /etc/passwd\n        ;;\n    \"system\")\n        awk -F: '$3 &lt; 1000 { printf \"%-20s %-6s %-6s\\n\", $1, $3, $4 }' /etc/passwd\n        ;;\n    \"human\")\n        awk -F: '$3 &gt;= 1000 && $3 &lt; 65534 { printf \"%-20s %-6s %-6s\\n\", $1, $3, $4 }' /etc/passwd\n        ;;\nesac\n\n\n\n\n\n\n\n\ncommand\n動作説明\n\n\n\n\nawk -F:\n:区切りで /etc/passwd を分割\n\n\n'$3 &gt;= 1000 && $3 &lt; 65534 { printf ...}'\nUID が 1000以上65534未満を対象にフィルター\n\n\n$1\n/etc/passwdにおけるusernameカラム\n\n\n$3\n/etc/passwdにおけるUIDカラム\n\n\n$4\n/etc/passwdにおけるGIDカラム"
  },
  {
    "objectID": "posts/2025-01-10-list-up-users/index.html#シェルスクリプト-ls-users",
    "href": "posts/2025-01-10-list-up-users/index.html#シェルスクリプト-ls-users",
    "title": "Linuxシステム上のユーザー一覧を条件に応じて表示する",
    "section": "",
    "text": "🎯 スクリプトの目的\n/etc/passwd ファイルを読み取り，以下のユーザーを表示する:\n\nすべてのユーザー\nシステムユーザー（UID &lt; 1000）\nhumanユーザー（UID &gt;= 1000）\n\nデフォルトでは humanユーザー を表示させる．\n\n\n\n#!/bin/bash\n\nprint_help() {\n    echo \"Usage: $0 [-a|-s|-h]\"\n    echo \"Options:\"\n    echo \"  -a    Show all users\"\n    echo \"  -s    Show only system users\"\n    echo \"  -h    Show only human users\"\n    echo \"  -?    Show this help message\"\n    exit 1\n}\n\n# Default to human users if no option is provided\nMODE=\"human\"\n\nwhile getopts \"ash?\" opt; do\n    case $opt in\n        a) MODE=\"all\";;\n        s) MODE=\"system\";;\n        h) MODE=\"human\";;\n        ?) print_help;;\n    esac\ndone\n\n# Print header\nprintf \"%-20s %-6s %-6s\\n\" \"Username\" \"UID\" \"GID\"\n\ncase $MODE in\n    \"all\")\n        awk -F: '{ printf \"%-20s %-6s %-6s\\n\", $1, $3, $4 }' /etc/passwd\n        ;;\n    \"system\")\n        awk -F: '$3 &lt; 1000 { printf \"%-20s %-6s %-6s\\n\", $1, $3, $4 }' /etc/passwd\n        ;;\n    \"human\")\n        awk -F: '$3 &gt;= 1000 && $3 &lt; 65534 { printf \"%-20s %-6s %-6s\\n\", $1, $3, $4 }' /etc/passwd\n        ;;\nesac\n\n\n\nオプションの処理\nwhile getopts \"ash?\" opt; do\n    case $opt in\n        a) MODE=\"all\";;\n        s) MODE=\"system\";;\n        h) MODE=\"human\";;\n        ?) print_help;;\n    esac\ndone\n\ngetopts を使って、コマンドラインオプションに応じて処理分岐\nMODE という変数に条件を記録し，optionに応じた処理は後段で実装\n\n\n\n\noption\n処理内容\n\n\n\n\n-a\n全ユーザー表示\n\n\n-s\nシステムユーザーのみ表示（UID &lt; 1000）\n\n\n-h\nhumanユーザーのみ表示\n\n\n-?\nヘルプを表示，status codeは exit 1\n\n\n\nヘッダー出力\nprintf \"%-20s %-6s %-6s\\n\" \"Username\" \"UID\" \"GID\"\n\n整形されたカラム見出しを出力\n%-20sは文字列(s)を左寄せで20文字分の幅で表示\n\n\n\n\n\n書式指定子\n意味\n\n\n\n\n%-20s\n左寄せで20文字幅の文字列（Username列）\n\n\n%-6s\n左寄せで6文字幅の文字列（UID列）\n\n\n%-6s\n左寄せで6文字幅の文字列（GID列）\n\n\n\n\nユーサー一覧の取得\ncase $MODE in\n    \"all\")\n        awk -F: '{ printf \"%-20s %-6s %-6s\\n\", $1, $3, $4 }' /etc/passwd\n        ;;\n    \"system\")\n        awk -F: '$3 &lt; 1000 { printf \"%-20s %-6s %-6s\\n\", $1, $3, $4 }' /etc/passwd\n        ;;\n    \"human\")\n        awk -F: '$3 &gt;= 1000 && $3 &lt; 65534 { printf \"%-20s %-6s %-6s\\n\", $1, $3, $4 }' /etc/passwd\n        ;;\nesac\n\n\n\n\n\n\n\n\ncommand\n動作説明\n\n\n\n\nawk -F:\n:区切りで /etc/passwd を分割\n\n\n'$3 &gt;= 1000 && $3 &lt; 65534 { printf ...}'\nUID が 1000以上65534未満を対象にフィルター\n\n\n$1\n/etc/passwdにおけるusernameカラム\n\n\n$3\n/etc/passwdにおけるUIDカラム\n\n\n$4\n/etc/passwdにおけるGIDカラム"
  },
  {
    "objectID": "posts/2025-01-10-list-up-users/index.html#etcpasswdファイル",
    "href": "posts/2025-01-10-list-up-users/index.html#etcpasswdファイル",
    "title": "Linuxシステム上のユーザー一覧を条件に応じて表示する",
    "section": "/etc/passwdファイル",
    "text": "/etc/passwdファイル\n\nDefinition 1 /etc/passwdファイル\n\nLinux においてユーザーアカウント情報を管理するためのテキストファイル\n\n\n基本フォーマット\nユーザー名:パスワード:UID:GID:コメント:ホームディレクトリ:ログインシェル\n実際に確認してみると\n% cat /etc/passwd\nkirby:x:1001:1001:Hoshino Kirby:/home/kirby:/bin/bash\n第２フィールドは多くの場合 x という表記になっています．実際のハッシュは /etc/shadow に保存されています．"
  },
  {
    "objectID": "posts/2025-01-10-list-up-users/index.html#linuxにおけるuserとgroup",
    "href": "posts/2025-01-10-list-up-users/index.html#linuxにおけるuserとgroup",
    "title": "Linuxシステム上のユーザー一覧を条件に応じて表示する",
    "section": "LinuxにおけるUserとGroup",
    "text": "LinuxにおけるUserとGroup\nLinuxにおけるuser区分\n\n\n\n\n\n\n\n\nユーザー区分\n説明\n\n\n\n\nスーパーユーザー\nシステム唯一の特権ユーザー，すべてのアクセス制御を無視することができる． ユーザー名:root, UID:0 と決まっている\n\n\nシステムユーザー\n各種サーバープログラムやシステムプログラムの実行に利用されるユーザー． UIDは主に1~99の範囲で割り当てられる\n\n\n一般ユーザー\nシステムの一般利用者 ユーザーIDは1000以降が割り当てられる（初めてのユーザーなら1000）\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\n\nroot以外のuid1000未満のアカウントはデーモンやディレクトリの所有者として利用するシステムアカウントとして用意されている\n100未満のUIDについてシステムによって静的に割り当てられるべきであり，アプリケーションによって作成されるべきではない範囲\n100 から 499 は，システム管理者やインストール後のスクリプトが useradd を使用して動的に割り当てるために予約された領域\n\n\n\nnobodyとは誰か？\n\nDefinition 2 nobodyユーザー\n\nnobodyに対して，一般的にはUID 65534が割り当てられている\n65535は16bit符号なし整数で表すことのできる一番大きな数字(FFFFFF)\nNFS(Network File System)サーバーがクライアントから提供されたUIDやGIDを信頼できない場合，またはroot-squashオプションが使用されている場合に使用される\n基本的にはNFS用に用意されたユーザー\n\n\n注意点として，ネットワークを通じてコンピューター間でファイルを共有するNFS用のユーザーであってその他の目的で使用されることは想定されていません．「nobodyを信頼できないプログラムの実行や信頼できないデータの処理に使用すること」は推奨されません．「あくまで，サービスには専用のユーザーアカウントを持たせるべき」というルールを忘れないようにしましょう．"
  },
  {
    "objectID": "posts/2025-11-04-python-class-rules/index.html",
    "href": "posts/2025-11-04-python-class-rules/index.html",
    "title": "継承，メソッドオーバーライド，スーパーメソッドの呼び出し",
    "section": "",
    "text": "サブクラスが親クラスを継承すると，親クラスで定義されたすべてのプロパティとメソッドを引き継ぐことができます．\n\nDefinition 1 OOPにおける継承\n\nあるクラス（親クラス，スーパークラス，基底クラス）の機能を，別のクラス（子クラス，サブクラス，派生クラス）が引き継ぐ仕組み\n再利用性: 同じような処理を複数のクラスで書かかずに，親クラスにまとめてしまう\n拡張性: 親クラスの機能をそのまま使いつつ，新しい振る舞い（メソッドや属性）を追加・変更できる\n\n\n\nExample 1 (初期化処理 __init__ と継承) \n\n\nCode\nclass Person:\n    def __init__(self, name, nationality):\n        self.name = name\n        self.nationality = nationality\n\nclass FootballPlayer(Person):\n    def __init__(self, name, nationality, position, club):\n        # 親クラスの初期化（nameとnationalityを設定）\n        super().__init__(name, nationality)\n        # 子クラス独自の属性\n        self.position = position\n        self.club = club\n\n# インスタンス生成\nplayer = FootballPlayer(\"Kylian Mbappé\", \"France\", \"Forward\", \"Real Madrid\")\n\nprint(player.name)\nprint(player.nationality)\nprint(player.position)\nprint(player.club)\n\n\nKylian Mbappé\nFrance\nForward\nReal Madrid\n\n\n\n\n\nExample 2 (dataclass を用いた初期化処理と継承) \n\n\nCode\nfrom dataclasses import dataclass\n\n@dataclass\nclass Person:\n    name: str\n    nationality: str\n\n@dataclass\nclass FootballPlayer(Person):\n    position: str\n    club: str = 'Arsenal' # デフォルト値OK\n\nplayer = FootballPlayer(\"Kylian Mbappé\", \"France\", \"Forward\", \"Real Madrid\")\n\nprint(player.name)\nprint(player.nationality)\nprint(player.position)\nprint(player.club)\n\n\nKylian Mbappé\nFrance\nForward\nReal Madrid\n\n\n\n\n\nExample 3 (dataclass を用いた初期化処理と継承 with __post_init__) \n\ndataclass は 親クラス → 子クラス の順にフィールドを結合して __init__ を自動生成\nsuper().__init__ の設定が dataclass 継承では不要になる\n親クラスでデフォルト値を用いていると少し話がややこしくなる\n\n\n\nCode\nfrom dataclasses import dataclass\n\n@dataclass\nclass Person:\n    name: str\n\n    def print_name(self):\n        print(self.name)\n\n@dataclass\nclass MDPerson(Person):\n    affiliation: str\n\n    def __post_init__(self):\n        self.name = f\"Doctor {self.name}\"\n\nJohn = MDPerson('John', 'UT')\nJohn.print_name()\n\n\nDoctor John\n\n\n\n\n\n\n\nDefinition 2 メソッドのオーバーライド\n\n親クラス（スーパークラス）で定義されたメソッドを，子クラス（サブクラス）で再定義して振る舞いを変更すること\nPythonでは，基本的にすべてのメソッドがC++における「仮想関数」に相当 = いつでもオーバーライド可能\n\ndef __methodname(self) などのようにprivate化である程度防ぐことは可能\n\n\n\n\nExample 4 (親メソッドを部分的に再利用するオーバーライド) \n\n\nCode\nclass Logger:\n    def log(self, msg):\n        print(f\"[LOG] {msg}\")\n\nclass TimestampLogger(Logger):\n    def log(self, msg):\n        import datetime\n        now = datetime.datetime.now().isoformat()\n        super().log(f\"{now} - {msg}\")\n\nTimestampLogger().log(\"system started\")\n\n\n[LOG] 2026-02-02T01:28:56.019412 - system started\n\n\n\n\nCoding Style Guide\n\n\n\n\n\n\nNoteOOP Style Guide: Explicitly mark method overrides in subclasses using decorators or documentation.\n\n\n\n\n@override デコレータ（Python 3.12以降 or typing_extensions経由）を使う, xor，docstring で「\"\"\"Override of Base.process\"\"\"」と明記する\n明確な意図がない限り，基底クラスのメソッドや属性を再定義しない\n実装を置き換えるのではなく拡張する場合は，super() を適切に呼び出す\n基底クラス側でオーバーライドを想定していない場合は __ を付与してprivate化する\n\n\n\n\nExample 5 \n\n\nCode\n# from typing import override  # Python 3.12以降利用可能)\nfrom typing_extensions import override  # Python 3.11などではtyping_extensions経由\n\nclass Base:\n    def process(self, data):\n        print(\"Base processing:\", data)\n\nclass Derived(Base):\n    @override\n    def process(self, data):\n        \"\"\"Override of Base.process\"\"\"\n        print(\"Derived processing:\", data)\n        super().process(data)\n\n\n\n\n\n\n\n\nDefinition 3 Implementation Inheritance（実装継承）\n\n既存の型を特殊化し，基底クラスのコードを再利用する継承のこと\nインターフェース継承以外の継承は実装継承\n\n\nPros\n\n基底クラスのコードを再利用するので，コード量を削減できる\n継承関係はクラス定義時（コンパイル時相当）に明示されるため，静的解析ツールがその構造を理解しやすく，定義ミス（例: 未実装メソッドや誤ったオーバーライド）を早期に検出できる\n\nCons\n\n基底クラスとサブクラスに実装が分散するため，クラス階層を追いかけなければ挙動を理解できない\n「上書きすべきでないメソッド」を誤って上書きしてしまうリスクがある\n実行時にメソッド解決順序（MRO）をたどるため，パフォーマンスが低下する可能性がある\n多重継承時に，ダイヤモンド継承問題（同一祖先を複数経路で継承する形）が発生するリスクがある\n\nCoding Style Guide\n\n\n\n\n\n\nNoteOOP Style Guide: Keep inheritance hierarchies as shallow as possible — ideally within one or two levels.\n\n\n\n\n継承階層はできるだけ浅く保ち，理想的には1〜2段階以内にとどめる\n多重継承自体は許容されるが，多重実装継承は基本的には非推奨\nダイヤモンド継承は特に避けるべき\n\n\n\n\nExample 6 (アンチパターン) \n\n\nCode\nclass Device:\n    def power_on(self):\n        print(\"Power on\")\n\nclass NetworkDevice(Device):\n    def connect(self):\n        print(\"Connect to network\")\n\nclass SmartDevice(Device):\n    def connect(self):\n        print(\"Connect to app\")\n\n# Diamond inheritance: both inherit from Device\nclass SmartNetworkDevice(SmartDevice, NetworkDevice):\n    def sync(self):\n        print(\"Syncing data\")\n\n# Ambiguity: which connect() should be used?\nsnd = SmartNetworkDevice()\nsnd.connect()  # -&gt; Which one? Depends on MRO (method resolution order)\n\n\nConnect to app\n\n\n\n\n\nDefinition 4 インターフェース継承\n\n抽象クラスを親クラスとする継承のこと\nクラスに特定のメソッド群の実装を強制することもできる継承形態\n同一APIを複数クラスで統一的に提供したいときに特に利用される\n「何をできるか（what）」を宣言し，「どう実装するか（how）」はサブクラスに委ねる\n\n\n\nExample 7 (Abstract Base Classを用いたインターフェース継承) \n\n\nCode\nfrom abc import ABC, abstractmethod\n\nclass Serializer(ABC):\n    @abstractmethod\n    def serialize(self, data):\n        pass\n\nclass JsonSerializer(Serializer):\n    def serialize(self, data):\n        import json\n        return json.dumps(data)\n\ndef save_data(serializer: Serializer, data):\n    print(serializer.serialize(data))\n\n# Unified interface:\nsave_data(JsonSerializer(), {\"foo\": \"bar\"})\n\n\n{\"foo\": \"bar\"}\n\n\n\n\nPros\n\n明示的なインターフェース契約により，APIの一貫性と可読性を高められる\nIDE補完・型チェック・静的解析が機能する\n設計段階で「実装漏れ」や「誤実装」を検出できる\nユニットテストケース準備が容易になる\n\nCons\n\n小規模コードでは過剰設計になりがち(そもそも抽象クラスが必要ではない可能性がある)\n抽象クラスが肥大化すると，不要なメソッド実装を強制される場合がある\nAPI変更時に全実装クラスの修正が必要になる（保守コストの増大）\nわざわざ継承を使うのではなく，ダックタイピング + コンポジションで十分なケースもある\n実装継承と異なり，コード再利用による短縮効果はない\n\nCoding Style Guide\n\n\n\n\n\n\nNoteOOP Style Guide: Define clear, minimal, and stable interfaces.\n\n\n\n\nインターフェースは必要最小限のメソッドにとどめる\n共通APIを抽象クラスを用いて定義する場合は，説明用documentを用意すること\n\n例: すべての推定器・予測モデルは BaseEstimator（ABC）を継承し，最低限 fit(X, y), predict(X) を定義し，必要に応じてscore(X, y)を追加する\n\n\n\nExample 8 (統計推定量モジュール用の実装例) \n\n\nCode\nfrom abc import ABC, abstractmethod\nimport numpy as np\n\nclass BaseEstimator(ABC):\n    \"\"\"Abstract base class for all estimators.\n\n    Rules:\n        - Require fit() and predict() methods\n        - Optionally define score()\n    \"\"\"\n\n    @abstractmethod\n    def fit(self, X: np.ndarray, y: np.ndarray):\n        \"\"\"Fit model to data.\"\"\"\n        pass\n\n    @abstractmethod\n    def predict(self, X: np.ndarray) -&gt; np.ndarray:\n        \"\"\"Predict from model.\"\"\"\n        pass\n\n    def score(self, X: np.ndarray, y: np.ndarray) -&gt; float:\n        \"\"\"Optional: default scoring by R^2.\"\"\"\n        y_pred = self.predict(X)\n        u = ((y - y_pred) ** 2).sum()\n        v = ((y - y.mean()) ** 2).sum()\n        return 1 - u / v\n\nclass LinearRegression(BaseEstimator):\n    \"\"\"Ordinary Least Squares Estimator.\"\"\"\n\n    def __init__(self):\n        self.coef_ = None\n        self.intercept_ = None\n\n    def fit(self, X: np.ndarray, y: np.ndarray):\n        X_ = np.c_[np.ones(X.shape[0]), X]\n        beta = np.linalg.pinv(X_.T @ X_) @ X_.T @ y\n        self.intercept_ = beta[0]\n        self.coef_ = beta[1:]\n        return self\n\n    def predict(self, X: np.ndarray) -&gt; np.ndarray:\n        return X @ self.coef_ + self.intercept_\n\n\nThen,\n\n\nCode\nX = np.random.rand(100, 3)\ny = X @ np.array([1.2, -0.7, 0.3]) + 0.5 + np.random.randn(100) * 0.05\n\nmodel = LinearRegression()\nmodel.fit(X, y)\nprint(\"R^2:\", model.score(X, y))\n\n\nR^2: 0.9868353599819158\n\n\n\n\n\n\n\n継承の文脈において，C++では「データメンバーはprivateにすべき」とされますが，\n\nC++ と異なり，Pythonはすべての属性とメソッドが公開が基本\n親クラスの属性を完全にprivate的に運用（名前マングリング）してしまうと継承の柔軟性が大きく失われる\n\nという理由から，private(__name) よりかはprotected(_name) という運用のほうが好ましいとされます．\n\n\n\n\n\n\n\n\n\n\n\n目的\nPythonでの命名\nサブクラスから\n外部コードから\n備考\n\n\n\n\n公開API\nname\n✅\n✅\n利用者向けのメソッドやプロパティ\n\n\n継承向け内部属性\n_name\n✅\n⚠️（非推奨）\n継承拡張で使うデータメンバー\n\n\n完全に内部限定\n__name\n❌\n❌\n継承しない前提での内部実装用\n\n\n\n\n\n\n\nAPI設計の観点から読み取り専用の値や派生値を返す場合，getter だけのプロパティを作成して，setter を不要にすることもできます．\n\nExample 9 \nfrom abc import ABC, abstractmethod\n\nclass BaseEstimator(ABC):\n    @abstractmethod\n    def fit(self, X, y):\n        pass\n\n    @abstractmethod\n    def predict(self, X):\n        pass\n\nclass LinearEstimator(BaseEstimator):\n    def __init__(self):\n        self._weights = None  # protected属性として保持\n\n    @property\n    def weights(self):\n        \"\"\"軽微な計算や検証を伴う派生値を返す\"\"\"\n        if self._weights is None:\n            raise ValueError(\"Estimator has not been fitted yet\")\n        return self._weights\n\nweights は計算や状態確認を伴うため プロパティとして提供\nfit() / predict() は必須の公開API\n内部状態 _weights は protected とし，直接操作させない\n\n\n\n\n\n\n\n\n\nNoteOOP Style Guide: Use Properties to expose minimal and predictable attribute APIs\n\n\n\n\n属性アクセスのAPIを提供する場合，プロパティは軽量な計算や制約チェックがある場合のみ使用\n読み取り専用の値や派生値を返す場合，getter だけのプロパティを作成して，setter を不要にする\n\n\n\n\n\n\n\nDefinition 5 staticmethod\n\nクラスに属するが，インスタンス (self) やクラス (cls) に依存しないメソッド\n実際には単なる「モジュール関数」をクラス内に置いた形\n\n\n\nExample 10 \n\nself.__class__ はインスタンスのクラスを参照するので，staticmethod も呼び出し可能\n&lt;Class&gt;でも参照可能(CoyoteWeapon.commercial())\n\n\n\nCode\nfrom dataclasses import dataclass\n\n@dataclass\nclass CoyoteWeapon:\n    name: str\n    power: int\n\n    @staticmethod\n    def commercial():\n        print(\"This is Coyote Weapon\")\n\n    def info(self):\n        self.__class__.commercial()\n        print(f\"Weapon: {self.name}, Power: {self.power}\")\n\n# クラス名から staticmethod を呼び出す\nCoyoteWeapon.commercial()  # → This is Coyote Weapon\n\n# インスタンスを作ってメソッドを呼ぶ\nweapon = CoyoteWeapon(name=\"Rocket Launcher\", power=9000)\nweapon.info()\n\n\nThis is Coyote Weapon\nThis is Coyote Weapon\nWeapon: Rocket Launcher, Power: 9000\n\n\n\n\nCoding Style Guide\n\n\n\n\n\n\nNoteOOP Style Guide: Avoid staticmethod unless API requires it\n\n\n\n\nstaticmethod の乱用を避け，モジュールレベル関数で基本対応する\nMLflowなどのAPI側が実装を要求する場合のみ利用する\n\n\n\n\n\n\n\nDefinition 6 classmethod\n\nクラス全体に影響を与えるmethod\n\n\nCoding Style Guide\n\n\n\n\n\n\nNoteOOP Style Guide: Use classmethod only when writing a named constructor, or a class-specific routine that modifies necessary global state such as a process-wide cache.\n\n\n\n\n名前付きコンストラクタ や　クラス固有の処理（例: プロセス全体で使うキャッシュの初期化など）でのみ使用\n\n\n\n\nExample 11 (名前付きコンストラクタ) \n\n通常のコンストラクタ __init__ とは別に，クラスを初期化する補助的なコンストラクタを作りたい場合に使う\n\n\n\nCode\nfrom dataclasses import dataclass\n\n@dataclass\nclass Rectangle:\n    width: float\n    height: float\n\n    @classmethod\n    def from_square(cls, side_length: float):\n        \"\"\"正方形から Rectangle を作る名前付きコンストラクタ\"\"\"\n        return cls(width=side_length, height=side_length)\n\n\n# 使用例\nr = Rectangle.from_square(5)\nprint(r)  # Rectangle(width=5, height=5)\n\n\nRectangle(width=5, height=5)\n\n\n\n\n\nExample 12 \n\n_global_cache はクラス全体で共有される状態\nclassmethod を使うことで，インスタンスを生成せずにアクセス可能\n\n\n\nCode\nclass Cache:\n    _global_cache = {}\n\n    @classmethod\n    def set(cls, key, value):\n        cls._global_cache[key] = value\n\n    @classmethod\n    def get(cls, key):\n        return cls._global_cache.get(key)\n\n# 使用例\nCache.set(\"x\", 100)\nprint(Cache.get(\"x\")) \n\n\n100"
  },
  {
    "objectID": "posts/2025-11-04-python-class-rules/index.html#継承inheritance",
    "href": "posts/2025-11-04-python-class-rules/index.html#継承inheritance",
    "title": "継承，メソッドオーバーライド，スーパーメソッドの呼び出し",
    "section": "",
    "text": "サブクラスが親クラスを継承すると，親クラスで定義されたすべてのプロパティとメソッドを引き継ぐことができます．\n\nDefinition 1 OOPにおける継承\n\nあるクラス（親クラス，スーパークラス，基底クラス）の機能を，別のクラス（子クラス，サブクラス，派生クラス）が引き継ぐ仕組み\n再利用性: 同じような処理を複数のクラスで書かかずに，親クラスにまとめてしまう\n拡張性: 親クラスの機能をそのまま使いつつ，新しい振る舞い（メソッドや属性）を追加・変更できる\n\n\n\nExample 1 (初期化処理 __init__ と継承) \n\n\nCode\nclass Person:\n    def __init__(self, name, nationality):\n        self.name = name\n        self.nationality = nationality\n\nclass FootballPlayer(Person):\n    def __init__(self, name, nationality, position, club):\n        # 親クラスの初期化（nameとnationalityを設定）\n        super().__init__(name, nationality)\n        # 子クラス独自の属性\n        self.position = position\n        self.club = club\n\n# インスタンス生成\nplayer = FootballPlayer(\"Kylian Mbappé\", \"France\", \"Forward\", \"Real Madrid\")\n\nprint(player.name)\nprint(player.nationality)\nprint(player.position)\nprint(player.club)\n\n\nKylian Mbappé\nFrance\nForward\nReal Madrid\n\n\n\n\n\nExample 2 (dataclass を用いた初期化処理と継承) \n\n\nCode\nfrom dataclasses import dataclass\n\n@dataclass\nclass Person:\n    name: str\n    nationality: str\n\n@dataclass\nclass FootballPlayer(Person):\n    position: str\n    club: str = 'Arsenal' # デフォルト値OK\n\nplayer = FootballPlayer(\"Kylian Mbappé\", \"France\", \"Forward\", \"Real Madrid\")\n\nprint(player.name)\nprint(player.nationality)\nprint(player.position)\nprint(player.club)\n\n\nKylian Mbappé\nFrance\nForward\nReal Madrid\n\n\n\n\n\nExample 3 (dataclass を用いた初期化処理と継承 with __post_init__) \n\ndataclass は 親クラス → 子クラス の順にフィールドを結合して __init__ を自動生成\nsuper().__init__ の設定が dataclass 継承では不要になる\n親クラスでデフォルト値を用いていると少し話がややこしくなる\n\n\n\nCode\nfrom dataclasses import dataclass\n\n@dataclass\nclass Person:\n    name: str\n\n    def print_name(self):\n        print(self.name)\n\n@dataclass\nclass MDPerson(Person):\n    affiliation: str\n\n    def __post_init__(self):\n        self.name = f\"Doctor {self.name}\"\n\nJohn = MDPerson('John', 'UT')\nJohn.print_name()\n\n\nDoctor John\n\n\n\n\n\n\n\nDefinition 2 メソッドのオーバーライド\n\n親クラス（スーパークラス）で定義されたメソッドを，子クラス（サブクラス）で再定義して振る舞いを変更すること\nPythonでは，基本的にすべてのメソッドがC++における「仮想関数」に相当 = いつでもオーバーライド可能\n\ndef __methodname(self) などのようにprivate化である程度防ぐことは可能\n\n\n\n\nExample 4 (親メソッドを部分的に再利用するオーバーライド) \n\n\nCode\nclass Logger:\n    def log(self, msg):\n        print(f\"[LOG] {msg}\")\n\nclass TimestampLogger(Logger):\n    def log(self, msg):\n        import datetime\n        now = datetime.datetime.now().isoformat()\n        super().log(f\"{now} - {msg}\")\n\nTimestampLogger().log(\"system started\")\n\n\n[LOG] 2026-02-02T01:28:56.019412 - system started\n\n\n\n\nCoding Style Guide\n\n\n\n\n\n\nNoteOOP Style Guide: Explicitly mark method overrides in subclasses using decorators or documentation.\n\n\n\n\n@override デコレータ（Python 3.12以降 or typing_extensions経由）を使う, xor，docstring で「\"\"\"Override of Base.process\"\"\"」と明記する\n明確な意図がない限り，基底クラスのメソッドや属性を再定義しない\n実装を置き換えるのではなく拡張する場合は，super() を適切に呼び出す\n基底クラス側でオーバーライドを想定していない場合は __ を付与してprivate化する\n\n\n\n\nExample 5 \n\n\nCode\n# from typing import override  # Python 3.12以降利用可能)\nfrom typing_extensions import override  # Python 3.11などではtyping_extensions経由\n\nclass Base:\n    def process(self, data):\n        print(\"Base processing:\", data)\n\nclass Derived(Base):\n    @override\n    def process(self, data):\n        \"\"\"Override of Base.process\"\"\"\n        print(\"Derived processing:\", data)\n        super().process(data)\n\n\n\n\n\n\n\n\nDefinition 3 Implementation Inheritance（実装継承）\n\n既存の型を特殊化し，基底クラスのコードを再利用する継承のこと\nインターフェース継承以外の継承は実装継承\n\n\nPros\n\n基底クラスのコードを再利用するので，コード量を削減できる\n継承関係はクラス定義時（コンパイル時相当）に明示されるため，静的解析ツールがその構造を理解しやすく，定義ミス（例: 未実装メソッドや誤ったオーバーライド）を早期に検出できる\n\nCons\n\n基底クラスとサブクラスに実装が分散するため，クラス階層を追いかけなければ挙動を理解できない\n「上書きすべきでないメソッド」を誤って上書きしてしまうリスクがある\n実行時にメソッド解決順序（MRO）をたどるため，パフォーマンスが低下する可能性がある\n多重継承時に，ダイヤモンド継承問題（同一祖先を複数経路で継承する形）が発生するリスクがある\n\nCoding Style Guide\n\n\n\n\n\n\nNoteOOP Style Guide: Keep inheritance hierarchies as shallow as possible — ideally within one or two levels.\n\n\n\n\n継承階層はできるだけ浅く保ち，理想的には1〜2段階以内にとどめる\n多重継承自体は許容されるが，多重実装継承は基本的には非推奨\nダイヤモンド継承は特に避けるべき\n\n\n\n\nExample 6 (アンチパターン) \n\n\nCode\nclass Device:\n    def power_on(self):\n        print(\"Power on\")\n\nclass NetworkDevice(Device):\n    def connect(self):\n        print(\"Connect to network\")\n\nclass SmartDevice(Device):\n    def connect(self):\n        print(\"Connect to app\")\n\n# Diamond inheritance: both inherit from Device\nclass SmartNetworkDevice(SmartDevice, NetworkDevice):\n    def sync(self):\n        print(\"Syncing data\")\n\n# Ambiguity: which connect() should be used?\nsnd = SmartNetworkDevice()\nsnd.connect()  # -&gt; Which one? Depends on MRO (method resolution order)\n\n\nConnect to app\n\n\n\n\n\nDefinition 4 インターフェース継承\n\n抽象クラスを親クラスとする継承のこと\nクラスに特定のメソッド群の実装を強制することもできる継承形態\n同一APIを複数クラスで統一的に提供したいときに特に利用される\n「何をできるか（what）」を宣言し，「どう実装するか（how）」はサブクラスに委ねる\n\n\n\nExample 7 (Abstract Base Classを用いたインターフェース継承) \n\n\nCode\nfrom abc import ABC, abstractmethod\n\nclass Serializer(ABC):\n    @abstractmethod\n    def serialize(self, data):\n        pass\n\nclass JsonSerializer(Serializer):\n    def serialize(self, data):\n        import json\n        return json.dumps(data)\n\ndef save_data(serializer: Serializer, data):\n    print(serializer.serialize(data))\n\n# Unified interface:\nsave_data(JsonSerializer(), {\"foo\": \"bar\"})\n\n\n{\"foo\": \"bar\"}\n\n\n\n\nPros\n\n明示的なインターフェース契約により，APIの一貫性と可読性を高められる\nIDE補完・型チェック・静的解析が機能する\n設計段階で「実装漏れ」や「誤実装」を検出できる\nユニットテストケース準備が容易になる\n\nCons\n\n小規模コードでは過剰設計になりがち(そもそも抽象クラスが必要ではない可能性がある)\n抽象クラスが肥大化すると，不要なメソッド実装を強制される場合がある\nAPI変更時に全実装クラスの修正が必要になる（保守コストの増大）\nわざわざ継承を使うのではなく，ダックタイピング + コンポジションで十分なケースもある\n実装継承と異なり，コード再利用による短縮効果はない\n\nCoding Style Guide\n\n\n\n\n\n\nNoteOOP Style Guide: Define clear, minimal, and stable interfaces.\n\n\n\n\nインターフェースは必要最小限のメソッドにとどめる\n共通APIを抽象クラスを用いて定義する場合は，説明用documentを用意すること\n\n例: すべての推定器・予測モデルは BaseEstimator（ABC）を継承し，最低限 fit(X, y), predict(X) を定義し，必要に応じてscore(X, y)を追加する\n\n\n\nExample 8 (統計推定量モジュール用の実装例) \n\n\nCode\nfrom abc import ABC, abstractmethod\nimport numpy as np\n\nclass BaseEstimator(ABC):\n    \"\"\"Abstract base class for all estimators.\n\n    Rules:\n        - Require fit() and predict() methods\n        - Optionally define score()\n    \"\"\"\n\n    @abstractmethod\n    def fit(self, X: np.ndarray, y: np.ndarray):\n        \"\"\"Fit model to data.\"\"\"\n        pass\n\n    @abstractmethod\n    def predict(self, X: np.ndarray) -&gt; np.ndarray:\n        \"\"\"Predict from model.\"\"\"\n        pass\n\n    def score(self, X: np.ndarray, y: np.ndarray) -&gt; float:\n        \"\"\"Optional: default scoring by R^2.\"\"\"\n        y_pred = self.predict(X)\n        u = ((y - y_pred) ** 2).sum()\n        v = ((y - y.mean()) ** 2).sum()\n        return 1 - u / v\n\nclass LinearRegression(BaseEstimator):\n    \"\"\"Ordinary Least Squares Estimator.\"\"\"\n\n    def __init__(self):\n        self.coef_ = None\n        self.intercept_ = None\n\n    def fit(self, X: np.ndarray, y: np.ndarray):\n        X_ = np.c_[np.ones(X.shape[0]), X]\n        beta = np.linalg.pinv(X_.T @ X_) @ X_.T @ y\n        self.intercept_ = beta[0]\n        self.coef_ = beta[1:]\n        return self\n\n    def predict(self, X: np.ndarray) -&gt; np.ndarray:\n        return X @ self.coef_ + self.intercept_\n\n\nThen,\n\n\nCode\nX = np.random.rand(100, 3)\ny = X @ np.array([1.2, -0.7, 0.3]) + 0.5 + np.random.randn(100) * 0.05\n\nmodel = LinearRegression()\nmodel.fit(X, y)\nprint(\"R^2:\", model.score(X, y))\n\n\nR^2: 0.9868353599819158\n\n\n\n\n\n\n\n継承の文脈において，C++では「データメンバーはprivateにすべき」とされますが，\n\nC++ と異なり，Pythonはすべての属性とメソッドが公開が基本\n親クラスの属性を完全にprivate的に運用（名前マングリング）してしまうと継承の柔軟性が大きく失われる\n\nという理由から，private(__name) よりかはprotected(_name) という運用のほうが好ましいとされます．\n\n\n\n\n\n\n\n\n\n\n\n目的\nPythonでの命名\nサブクラスから\n外部コードから\n備考\n\n\n\n\n公開API\nname\n✅\n✅\n利用者向けのメソッドやプロパティ\n\n\n継承向け内部属性\n_name\n✅\n⚠️（非推奨）\n継承拡張で使うデータメンバー\n\n\n完全に内部限定\n__name\n❌\n❌\n継承しない前提での内部実装用\n\n\n\n\n\n\n\nAPI設計の観点から読み取り専用の値や派生値を返す場合，getter だけのプロパティを作成して，setter を不要にすることもできます．\n\nExample 9 \nfrom abc import ABC, abstractmethod\n\nclass BaseEstimator(ABC):\n    @abstractmethod\n    def fit(self, X, y):\n        pass\n\n    @abstractmethod\n    def predict(self, X):\n        pass\n\nclass LinearEstimator(BaseEstimator):\n    def __init__(self):\n        self._weights = None  # protected属性として保持\n\n    @property\n    def weights(self):\n        \"\"\"軽微な計算や検証を伴う派生値を返す\"\"\"\n        if self._weights is None:\n            raise ValueError(\"Estimator has not been fitted yet\")\n        return self._weights\n\nweights は計算や状態確認を伴うため プロパティとして提供\nfit() / predict() は必須の公開API\n内部状態 _weights は protected とし，直接操作させない\n\n\n\n\n\n\n\n\n\nNoteOOP Style Guide: Use Properties to expose minimal and predictable attribute APIs\n\n\n\n\n属性アクセスのAPIを提供する場合，プロパティは軽量な計算や制約チェックがある場合のみ使用\n読み取り専用の値や派生値を返す場合，getter だけのプロパティを作成して，setter を不要にする\n\n\n\n\n\n\n\nDefinition 5 staticmethod\n\nクラスに属するが，インスタンス (self) やクラス (cls) に依存しないメソッド\n実際には単なる「モジュール関数」をクラス内に置いた形\n\n\n\nExample 10 \n\nself.__class__ はインスタンスのクラスを参照するので，staticmethod も呼び出し可能\n&lt;Class&gt;でも参照可能(CoyoteWeapon.commercial())\n\n\n\nCode\nfrom dataclasses import dataclass\n\n@dataclass\nclass CoyoteWeapon:\n    name: str\n    power: int\n\n    @staticmethod\n    def commercial():\n        print(\"This is Coyote Weapon\")\n\n    def info(self):\n        self.__class__.commercial()\n        print(f\"Weapon: {self.name}, Power: {self.power}\")\n\n# クラス名から staticmethod を呼び出す\nCoyoteWeapon.commercial()  # → This is Coyote Weapon\n\n# インスタンスを作ってメソッドを呼ぶ\nweapon = CoyoteWeapon(name=\"Rocket Launcher\", power=9000)\nweapon.info()\n\n\nThis is Coyote Weapon\nThis is Coyote Weapon\nWeapon: Rocket Launcher, Power: 9000\n\n\n\n\nCoding Style Guide\n\n\n\n\n\n\nNoteOOP Style Guide: Avoid staticmethod unless API requires it\n\n\n\n\nstaticmethod の乱用を避け，モジュールレベル関数で基本対応する\nMLflowなどのAPI側が実装を要求する場合のみ利用する\n\n\n\n\n\n\n\nDefinition 6 classmethod\n\nクラス全体に影響を与えるmethod\n\n\nCoding Style Guide\n\n\n\n\n\n\nNoteOOP Style Guide: Use classmethod only when writing a named constructor, or a class-specific routine that modifies necessary global state such as a process-wide cache.\n\n\n\n\n名前付きコンストラクタ や　クラス固有の処理（例: プロセス全体で使うキャッシュの初期化など）でのみ使用\n\n\n\n\nExample 11 (名前付きコンストラクタ) \n\n通常のコンストラクタ __init__ とは別に，クラスを初期化する補助的なコンストラクタを作りたい場合に使う\n\n\n\nCode\nfrom dataclasses import dataclass\n\n@dataclass\nclass Rectangle:\n    width: float\n    height: float\n\n    @classmethod\n    def from_square(cls, side_length: float):\n        \"\"\"正方形から Rectangle を作る名前付きコンストラクタ\"\"\"\n        return cls(width=side_length, height=side_length)\n\n\n# 使用例\nr = Rectangle.from_square(5)\nprint(r)  # Rectangle(width=5, height=5)\n\n\nRectangle(width=5, height=5)\n\n\n\n\n\nExample 12 \n\n_global_cache はクラス全体で共有される状態\nclassmethod を使うことで，インスタンスを生成せずにアクセス可能\n\n\n\nCode\nclass Cache:\n    _global_cache = {}\n\n    @classmethod\n    def set(cls, key, value):\n        cls._global_cache[key] = value\n\n    @classmethod\n    def get(cls, key):\n        return cls._global_cache.get(key)\n\n# 使用例\nCache.set(\"x\", 100)\nprint(Cache.get(\"x\")) \n\n\n100"
  },
  {
    "objectID": "posts/2025-11-04-python-class-rules/index.html#コンポジションcomposition",
    "href": "posts/2025-11-04-python-class-rules/index.html#コンポジションcomposition",
    "title": "継承，メソッドオーバーライド，スーパーメソッドの呼び出し",
    "section": "コンポジション(Composition)",
    "text": "コンポジション(Composition)\n継承(Inhertitance)は，「class Aは class Bの一種」という思想が背景にありますが，\n\nアヒルは鳥であると同時にくちばしやしっぽを持っている\n\nというようなA(アヒル)はB(くちばしやしっぽ)を有している(A-has-B logic)の場合は，コンポジション（composition）を使うべきとされます．\n\nExample 13 (🦆 コンポジション（A-has-B logic) \n\n\nCode\nfrom dataclasses import dataclass\n\n@dataclass\nclass Bill:\n    length_cm: float\n    color: str\n\n    def quack_sound(self):\n        return \"Quack!\"\n\n\n@dataclass\nclass Tail:\n    length_cm: float\n    fluffiness: int  # 1〜10段階\n\n    def wag(self):\n        return \"Tail wagging gracefully\"\n\n\n@dataclass\nclass Bird:\n    species: str\n\n    def fly(self):\n        return f\"{self.species} is flying!\"\n\n\n@dataclass\nclass Duck(Bird):\n    bill: Bill\n    tail: Tail\n\n    def describe(self):\n        return (\n            f\"This is a {self.species}.\\n\"\n            f\"Bill: {self.bill.length_cm}cm, color {self.bill.color}\\n\"\n            f\"Tail: {self.tail.length_cm}cm, fluffiness {self.tail.fluffiness}\"\n        )\n\n    def quack(self):\n        return self.bill.quack_sound()\n\n    def wag_tail(self):\n        return self.tail.wag()\n\nduck = Duck(\n    species=\"Mallard\",\n    bill=Bill(length_cm=6.5, color=\"yellow\"),\n    tail=Tail(length_cm=8.0, fluffiness=7)\n)\n\nprint(duck.describe())\nprint(duck.fly())\nprint(duck.quack())\nprint(duck.wag_tail())\n\n\nThis is a Mallard.\nBill: 6.5cm, color yellow\nTail: 8.0cm, fluffiness 7\nMallard is flying!\nQuack!\nTail wagging gracefully\n\n\n\n\n\nComposition vs Inheritance\n\n\n\n\n\n\nNoteOOP Style Guide: Composition is often more appropriate than inheritance\n\n\n\n\n継承は慎重に使い，まずは「コンポジション（composition）」を考えるべき\n「部品の入れ替え」が必要な場合や責務を分離したい」場合，Compositionが有効\n\n\n\n\n\n\n\n\n\n\n\n\n項目\n継承 (Inheritance)\nコンポジション (Composition)\n\n\n\n\n関係\nis-a（〜は〜である）\nhas-a（〜を持っている）\n\n\n再利用\n親クラスの機能を引き継ぐ\n他クラスの機能を内部で使う\n\n\n柔軟性\n低い（構造が固定）\n高い（入れ替えや拡張が容易）\n\n\n結合度\n強い\n弱い（疎結合）"
  },
  {
    "objectID": "posts/2025-11-04-python-class-rules/index.html#appendix",
    "href": "posts/2025-11-04-python-class-rules/index.html#appendix",
    "title": "継承，メソッドオーバーライド，スーパーメソッドの呼び出し",
    "section": "Appendix",
    "text": "Appendix\n\nダックタイピング vs インターフェース継承\n\n\n\n\n\n\n\n\n\n観点\nダックタイピング\nインターフェース継承\n\n\n\n\n定義\n「見た目がアヒルならアヒル」の原則に基づき，オブジェクトの型ではなく振る舞い（メソッドや属性の存在）で判断する\n抽象クラス（ABC）を介して，特定のメソッド群を必ず実装することを強制する仕組み\n\n\nPython 的実装例\nfit() と predict() を持っていれば Estimator として扱う（Scikit-Learn 流）\nEstimator 抽象基底クラスを継承し，fit()・predict() の定義を強制する"
  },
  {
    "objectID": "posts/2025-11-04-python-class-rules/index.html#references",
    "href": "posts/2025-11-04-python-class-rules/index.html#references",
    "title": "継承，メソッドオーバーライド，スーパーメソッドの呼び出し",
    "section": "References",
    "text": "References\n\nGoogle C++ Style Guide\nGoogle Python Style Guide\nPythonにおけるオブジェクトとクラス"
  }
]