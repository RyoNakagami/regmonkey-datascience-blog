[
  {
    "objectID": "posts/2024-12-11-BQ-create-external-table/index.html",
    "href": "posts/2024-12-11-BQ-create-external-table/index.html",
    "title": "Cloud StorageからExternal Tableの作成",
    "section": "",
    "text": "Google Cloud StorageからBigQuery上にExternal tabaleを作成する\nPartition Fieldが定義されたExternal tabaleを作成するための条件を確認する"
  },
  {
    "objectID": "posts/2024-12-11-BQ-create-external-table/index.html#このノートのスコープ",
    "href": "posts/2024-12-11-BQ-create-external-table/index.html#このノートのスコープ",
    "title": "Cloud StorageからExternal Tableの作成",
    "section": "",
    "text": "Google Cloud StorageからBigQuery上にExternal tabaleを作成する\nPartition Fieldが定義されたExternal tabaleを作成するための条件を確認する"
  },
  {
    "objectID": "posts/2024-12-11-BQ-create-external-table/index.html#external-tableとは",
    "href": "posts/2024-12-11-BQ-create-external-table/index.html#external-tableとは",
    "title": "Cloud StorageからExternal Tableの作成",
    "section": "External Tableとは？",
    "text": "External Tableとは？\nBigQueryのExternal Table（外部テーブル）は，BigQuery内にデータをコピーまたはインポートすることなく， 外部データソースに直接アクセスしてクエリを実行できる機能です．\nBigQueryにおけるExternal Tableの利用形式として，permanent tableとtemporary tableの２つがあります．\n\npermanent table: BigQuery dataset内に作成され，外部データソースにリンクされるテーブル\ntemporary table: 外部データソースに対して一時的にクエリを実行する場合に利用されるテーブル\n\n一時的なテスト処理などでtemporary tableを用いることは有用ですが，分析者間でクエリやコードを共有して分析を進める場合はpermanent tableを持ちないと テーブルアクセスを共有できないので，このノートではpermanent tableを主に取り扱います．\n ▶  サポートされているデータストア\n\nBigLake\nCloud Storage\nBigtable\nGoogle Drive\nAmazon S3\nAzure Blob Storage\n\n以上のデータストアがBigQueryからアクセス可能な外部データソースとしてサポートされています\n ▶  Pricing\nBigQueryのPricingは\n\nCompute pricing: クエリの処理にかかる費用\nStorage pricing: データ保存費用\n\nの２つから構成されています．External Tableを用いると，後者の方はCloud Storage換算の費用となるため，一般的には ストレージコストを抑えることができます．ただし，External Tableにアクセスして分析するたびに\n\nQuery cost: クエリ計算処理時間に比例するコスト\nBytes cost: External tableからのデータ読み取りサイズに比例するコスト\n\nが発生します．\n\n📘 Tips \nExternal Tableを用いた分析が一時的なものであるならばExternal Tableを用いたほうが良いと思いますが， 頻繁にBigQueryからアクセスする場合は\n\nPartitioning/Clusteringを用いてアクセスサイズを抑える\nSELECT以下で*を使用せず，分析に用いるカラムを明示的に指定して，スキャンサイズを抑える\n\nという工夫，またはBigQuery native tableとしてデータを保持することを検討したほうが良いと思います．\n\n\nExternal Table use cases\nExternal Tableの特徴として，\n\nBigQuery native tableとしてデータは保持しない\nExternal Tableと紐づく外部ストアの最新データに対して，クエリ処理が走る\n\nがあります．そのため，PoCや営業段階での分析や頻繁にupdateされるデータに対してのオンライン分析といった場面で活用されるケースが多いです．\n\nExample: 営業段階でのアドホック分析 \n\nBtoC向けサービスを展開している企業Aに対して営業をしているとする\nNDAを結んだ後に，企業Aが保有しているデータのサンプルとして２年間分の連携してもらった\nこのデータを用いて簡易的な分析を行い，どのようなインサイトが導けそうか？を次の営業会議で企業Aに伝え説得したい\n\nという場面を考えます．\n ▶  Key Points\n\nわざわざテーブルスキーマを定義する時間はあまりない→早くEDAをやりたい\nサンプルデータなので，プロジェクト受注後に連携されるであろうデータセットよりも情報量が少ない→わざわざテーブルスキーマしても再利用可能性は低い\n\n ▶  External Tableのメリット\n\nテーブルスキーマをわざわざ定義しなくても，BigQueryを用いた大容量のデータに対しての分析が可能\n複数の分析者間でサンプルデータをCloud Storageベースで簡単に共有できる\nPythonなどの言語を用いた分析でも，予めBigQueryで前処理して小さいdatamartを作成し，それに対してEDAが実施できる"
  },
  {
    "objectID": "posts/2024-12-11-BQ-create-external-table/index.html#external-table作成",
    "href": "posts/2024-12-11-BQ-create-external-table/index.html#external-table作成",
    "title": "Cloud StorageからExternal Tableの作成",
    "section": "External Table作成",
    "text": "External Table作成\nここでは，EXTERNAL PARTITION TABLEの作成を目的に\n\ngoogle cloud storageへのupload\nEXTERNAL TABLEの作成\n\nの２段階の流れで説明します．\n ▶  Cloud Storageへのupload\n~/pupupuland_store_posというdirectory以下に，yyyymmdd形式の日付でpartitionされたPARQUET形式のデータがあるとします．\npupupuland_store_pos\n├── partition_dt=2023-09-23\n│   └── purchase_history_2023-09-23.parquet\n├── partition_dt=2023-09-24\n│   └── purchase_history_2023-09-24.parquet\n├── partition_dt=2023-09-25\n│   └── purchase_history_2023-09-25.parquet\n├── partition_dt=2023-09-26\n│   └── purchase_history_2023-09-26.parquet\n├── partition_dt=2023-09-27\n│   └── purchase_history_2023-09-27.parquet\n├── partition_dt=2023-09-28\n│   └── purchase_history_2023-09-28.parquet\n├── partition_dt=2023-09-29\n│   └── purchase_history_2023-09-29.parquet\n└── partition_dt=2023-09-30\n    └── purchase_history_2023-09-30.parquet\nこのディレクトリ構造を保持したまま，gs://project-make-dedede-great-again/というcloud storage bucketに格納したいとします．このとき\ngcloud storage cp -r ~/pupupuland_store_pos/ gs://project-make-dedede-great-again/\n以上で下準備は完了です．\n ▶  External Tableの作成\nGoogle Cloud project pupupuland-businessdata の dedede-holdings dataset以下に先程上げた pupupuland_store_pos tableを作成したいと思います．\nCREATE EXTERNAL TABLE `pupupuland-businessdata.dedede-holdings.pupupuland_store_pos`\nWITH PARTITION COLUMNS (\npartition_dt DATE, -- column order must match the external path\n)\nOPTIONS (\nuris = ['gs://project-make-dedede-great-again/pupupuland_store_pos/*'],\nformat = 'PARQUET',\nhive_partition_uri_prefix = 'gs://project-make-dedede-great-again/pupupuland_store_pos',\nrequire_hive_partition_filter = false);\nPARTITION COLUMNSのフィールドに partition_dtと入力していますが，これは外部ファイルのパスのパターンがgs://project-make-dedede-great-again/pupupuland_store_pos/partition_dt=yyyymmdd/data.parquet であることを前提にしています．そのため，upload時のdirectory構造を\n└── partition_dt=2023-09-30\n    └── purchase_history_20230930.parquet\nという形にしてcloud storageにuploadしたという背景があります．DATETYPEにDATEと指定していますが，/&lt;partition field&gt;=2018-10-18/という構造になっていないと失敗することに注意してください． 他にも INTEGER, STRING, TIMESTAMPが指定できます．TIMESTAMPの場合は，/&lt;partition field&gt;=2018-10-18 16:00:00+00/という構造であることが必要です．\nrequire_hive_partition_filter フィールドはクエリ時にpartition_dtによるWHERE句フィルタリングを強制するか否かの設定フィールドです． デフォルトではfalseとなっており，この場合はフィルタリングしなくてもクエリできることを意味します．"
  },
  {
    "objectID": "posts/2024-12-11-BQ-create-external-table/index.html#references",
    "href": "posts/2024-12-11-BQ-create-external-table/index.html#references",
    "title": "Cloud StorageからExternal Tableの作成",
    "section": "References",
    "text": "References\n\nIntroduction to external tables"
  },
  {
    "objectID": "posts/2025-01-29-set-and-topology-series/index.html",
    "href": "posts/2025-01-29-set-and-topology-series/index.html",
    "title": "フーリエ級数と積分理論再考",
    "section": "",
    "text": "フーリエが熱伝導方程式の解をどのように求めたのか？\nどのような流れで積分の定義の再考につながったのか？\n\nを紹介します．"
  },
  {
    "objectID": "posts/2025-01-29-set-and-topology-series/index.html#このノートのスコープ",
    "href": "posts/2025-01-29-set-and-topology-series/index.html#このノートのスコープ",
    "title": "フーリエ級数と積分理論再考",
    "section": "",
    "text": "フーリエが熱伝導方程式の解をどのように求めたのか？\nどのような流れで積分の定義の再考につながったのか？\n\nを紹介します．"
  },
  {
    "objectID": "posts/2025-01-29-set-and-topology-series/index.html#熱伝導方程式",
    "href": "posts/2025-01-29-set-and-topology-series/index.html#熱伝導方程式",
    "title": "フーリエ級数と積分理論再考",
    "section": "熱伝導方程式",
    "text": "熱伝導方程式\n物体内に温度勾配が存在すると，高温部から低温部へ熱伝導（Heat conduction）により熱エネルギーが伝わります．\n\n\n\n\n\n\nFigure 1: 長さ\\(\\pi\\)の密度が一様な棒\n\n\n\nFigure 1 のような細長い密度が一定の棒が与えられたとします．\n\n左端を 0 として，ある点の位置を左端からの距離 \\(x\\) で表す\nある点 \\(x\\) における時刻 \\(t\\) での温度を \\(T(x, t)\\) で表す\n単位断面積を単位時間に通過する熱エネルギーを \\(q(x, t)\\) とする(=熱流密度)\n\nフーリエの法則より，熱流密度 \\(q(x, t)\\) は温度勾配 \\(\\displaystyle{\\frac{\\partial T(x, t)}{\\partial x}}\\) に比例するので\n\\[\nq(x, t) = -\\lambda \\frac{\\partial T(x, t)}{\\partial x} \\label{eq-fourier-law}\n\\]\n\n\\(\\lambda  &gt; 0\\): 熱伝導率，RHSに符号マイナスがついているのは，高温から低音へ熱が流れることを表してる\n熱伝導率: 物質によって定まる物性値, 熱伝導率が大きいと熱エネルギーがよく伝わり，熱伝導率が小さいと熱エネルギーを伝えにくい\n\n\\(\\eqref{eq-fourier-law}\\) で表される熱の流入から，比熱 \\(c &gt; 0\\), 密度 \\(\\rho  &gt; 0\\) を用いると温度変化 \\(\\Delta T(x, t)\\) は熱の流入と流出２要素から以下のように表されます\n\\[\n\\begin{align}\n\\Delta T(x, t) &= \\frac{1}{c\\rho\\Delta x}(q(x, t) - q(x + \\Delta x, t))\\Delta t\\\\\n\\Rightarrow \\frac{\\Delta T(x, t)}{\\Delta t} &= \\frac{1}{c\\rho\\Delta x}(q(x, t) - q(x + \\Delta x, t))\n\\end{align}\n\\]\nここで，\\(\\Delta t\\to 0, \\Delta x\\to 0\\) とすると\n\\[\n\\frac{\\partial T(x, t)}{\\partial t} = -\\frac{1}{c\\rho}\\frac{\\partial q(x, t)}{\\partial x} \\label{eq-heat-balance}\n\\]\n\\(\\eqref{eq-fourier-law}\\), \\(\\eqref{eq-heat-balance}\\) より\n\\[\n\\begin{align}\n\\frac{\\partial T(x, t)}{\\partial t}\n    &= -\\frac{1}{c\\rho}\\frac{\\partial}{\\partial x}\\left(-\\lambda \\frac{\\partial T(x, t)}{\\partial x} \\right)\\\\\n    &= \\frac{\\lambda}{c\\rho}\\frac{\\partial^2 T(x, t)}{\\partial x^2} \\label{eq-hce}\n\\end{align}\n\\tag{1}\\]\nこれを熱伝導方程式と呼びます．\\(\\displaystyle\\frac{\\lambda}{c\\rho}\\) は温度伝導率（温度拡散率）と呼ばれます．\n\n\n\n\n\n\n🍵 Green Tea Break: 比熱\n\n\n\n\n比熱とは 1kg の物質の温度を 1K （＝1℃）上げるのに必要な熱量のこと\n「温まりやすさ」 「冷めにくさ」 を表す物理量と理解できる\n\n例えば，水1kgの場合，1K 上げるのに必要な熱量は4186J"
  },
  {
    "objectID": "posts/2025-01-29-set-and-topology-series/index.html#熱伝導方程式とフーリエ級数",
    "href": "posts/2025-01-29-set-and-topology-series/index.html#熱伝導方程式とフーリエ級数",
    "title": "フーリエ級数と積分理論再考",
    "section": "熱伝導方程式とフーリエ級数",
    "text": "熱伝導方程式とフーリエ級数\n\n方程式: 熱伝導方程式\n境界条件: 棒の両端の温度を 0 に保つ\n初期条件: 初期状態(\\(t=0\\))における位置 \\(x\\) の温度が \\(f(x)\\) で与えられている\n\nという設定の下，温度 \\(T\\) の時間変化を求める問題を考えます．\n ▶  境界条件\n\\[\nT(0, t) = T(\\pi, t) = 0 \\qquad (t\\geq 0) \\label{eq-boundary}\n\\]\n ▶  初期条件\n\\[\nT(x, 0) = f(x) \\qquad (0 \\leq x \\leq \\pi) \\label{eq-init}\n\\]\n\n ▶  重ね合わせの原理\n熱伝導方程式は次のような性質があります\n\n\\(T_1, T_2\\) が \\(\\eqref{eq-hce}\\), \\(\\eqref{eq-boundary}\\) を満たすとき，\\(T_1 + T_2\\) も\\(\\eqref{eq-hce}\\), \\(\\eqref{eq-boundary}\\) を満たす\n\\(T\\) が \\(\\eqref{eq-hce}\\), \\(\\eqref{eq-boundary}\\) を満たすとき，その任意の定数倍 \\(kT\\) も\\(\\eqref{eq-hce}\\), \\(\\eqref{eq-boundary}\\) を満たす\n\nこれを重ね合わせの原理と呼びます．\n\n温度 \\(T\\) の時間変化を求める問題を解くにあたって，フーリエは重ね合わせの原理を活用して\n\n\\(\\eqref{eq-hce}\\), \\(\\eqref{eq-boundary}\\) を満たす関数の条件のうち，なるべく簡単な形のものを求める\n得られた簡単な形の関数を足し合わせることで，初期条件 \\(\\eqref{eq-init}\\) を満たす関数を作る\n\nという二段構えで解くことを考えました．簡単な形の関数としてフーリエが考えたのは変数分離型の関数です．\n\n変数分離\n変数分離型関数とは，位置 \\(x\\) 飲みの関数 \\(v(x)\\) と時刻 \\(t\\) のみの関数 \\(w(t)\\) の積\n\\[\nT(x, t) = v(x)w(t)\n\\]\nの形で表させる関数のことです．変数分離型を仮定すると熱伝導方程式は常微分方程式を用いて以下のように表せます\n\\[\n\\begin{align}\n\\frac{c\\rho}{\\lambda}\\frac{w^\\prime(t)}{w(t)} = \\frac{v^{\\prime\\prime}(x)}{v(x)}\n\\end{align}\n\\]\nLHSは\\(t\\)のみの関数，RHSは\\(x\\)飲みの関数であるので，方程式が恒等的に成り立つためには，両辺は定数でなければなりません．定数を \\(k\\) と表すと\n\\[\n\\begin{align}\nw^\\prime(t) &= k Aw(t)\\\\\nv^{\\prime\\prime}(t) &= k v(x)\n\\end{align}\n\\]\nなお \\(A = \\displaystyle\\frac{\\lambda}{c\\rho}\\) としています．\n ▶  \\(w(t)\\) について解く\n\\[\n\\begin{align}\n\\frac{dw(t)}{w(t)} &= k A dt\\\\\n\\int \\frac{dw(t)}{w(t)}dt &= \\int k A dt \\label{eq-cond}\\\\\n\\log(\\vert w(t)\\vert) &= k A t + C \\qquad (C\\text{: constant})\\\\\nw(t) &= \\alpha \\exp(k At)\\qquad (\\alpha = \\exp(C))\n\\end{align}\n\\]\n従って，\n\\[\n\\begin{align}\nw(t) = \\left\\{\\begin{array}{c}\n\\alpha\\exp(kAt) & (k \\neq 0)\\\\\n\\alpha & (k = 0)\n\\end{array}\\right.\n\\end{align}\n\\]\n ▶  \\(v(x)\\) について解く\n2次線形微分方程式において，\\(p, q\\) が定数のとき\n\\[\ny^{\\prime\\prime} + py^{\\prime} + q = 0\n\\]\nの一般解は特定方程式 \\(a^2 + pa + q =0\\) の解によって以下のように定まります\ncase 1: ２つの実数解 \\(\\hat a_1, \\hat a_2\\) を持つ場合\n\\[\ny = A\\exp(\\hat a_1 x) + B\\exp(\\hat a_2 x)\n\\]\ncase 2: ２つの虚数解 \\(\\hat a \\pm \\hat b i\\) を持つ場合\n\\[\ny = \\exp(\\hat a x)(A\\cos(\\hat b x) + B \\sin(\\hat b x))\n\\]\ncase 3: 重解 \\(\\hat a\\) を持つ場合\n\\[\ny = (Ax + B)\\exp(\\hat a x)\n\\]\n以上より，\n\\[\n\\begin{align}\nv(x) = \\left\\{\\begin{array}{c}\n\\beta \\exp(\\sqrt{k}x) + \\gamma \\exp(-\\sqrt{k}x) & \\text{if } k &gt; 0\\\\\n\\beta x + \\gamma & \\text{if } k = 0 \\\\\n\\beta\\cos(\\sqrt{\\vert k\\vert}x) + \\gamma\\sin(\\sqrt{\\vert k\\vert}x) & \\text{if } k &lt;0\n\\end{array}\\right.\n\\end{align}\n\\]\n境界条件および初期条件を満たすように係数 \\(\\alpha, \\beta, \\gamma\\) を定めれば，解が求まることになります．\n\n\nフーリエ級数の登場\n ▶  \\(k &gt; 0\\) のケース\n\\(\\eqref{eq-cond}\\) より，時間の経過とともに温度が無限大に大きくなることはないので \\(k&gt; 0\\) はありえないことが直感的に分かりますが，\\(k&gt; 0\\) と仮定したとき 境界条件を満たす \\(\\alpha, \\beta, \\gamma\\) が存在しないことを確認します．\n\\[\n\\begin{align}\nw(t) &= \\alpha\\exp(kAt) \\\\\nv(x) &= \\beta \\exp(\\sqrt{k}x) + \\gamma \\exp(-\\sqrt{k}x)\n\\end{align}\n\\]\n境界条件より\n\\[\n\\begin{align}\nv(0) &= \\beta + \\gamma = 0\\\\\nv(\\pi) &= \\beta\\exp(\\sqrt{k}\\pi) + \\gamma\\exp(-\\sqrt{k}\\pi) = 0\n\\end{align}\n\\]\nここから\n\\[\n\\beta(\\exp(\\sqrt{k}\\pi) - \\exp(-\\sqrt{k}\\pi)) = 0\n\\]\n従って，\n\\[\n\\begin{align}\n&\\beta = \\gamma = 0\\\\\n\\Rightarrow& v(x) =  0\n\\end{align}\n\\]\nこれは \\(f(x) = 0 \\ \\ \\forall x \\in [0, \\pi]\\) 以外の場合は初期条件を満たすことがない．\n ▶  \\(k = 0\\) のケース\n\\[\n\\begin{align}\nw(t) &= \\alpha\\\\\nv(x) &= \\beta x + \\gamma\n\\end{align}\n\\]\n境界条件を満たすためには \\(\\beta = \\gamma = 0\\) が必要になるが，\\(f(x) = 0 \\ \\ \\forall x \\in [0, \\pi]\\) 以外の場合は初期条件を満たすことがない．\n ▶  \\(k &lt; 0\\) のケース\n\\[\n\\begin{align}\nw(t) &= \\alpha\\exp(kAt) \\\\\nv(x) &= \\beta\\cos(\\sqrt{\\vert k\\vert}x) + \\gamma\\sin(\\sqrt{\\vert k\\vert}x)\n\\end{align}\n\\]\n境界条件より\n\\[\n\\begin{align}\n\\beta &= 0\\\\\n\\gamma\\sin(\\sqrt{\\vert k\\vert}\\pi) &= 0\n\\end{align}\n\\]\n\\(\\gamma= 0\\) だと初期条件を満たすことができないので，\\(\\gamma \\neq 0\\). このとき，\\(\\sqrt{\\vert k\\vert} \\in \\mathbb Z\\) が解の必要条件となることが分かる． ここで，\\(k = -n^2\\) と書き直すと\n\\[\n\\begin{align}\nT(x, t) = \\alpha\\exp(-n^2At) \\cdot \\gamma\\sin(n\\pi) \\label{eq-sol-candidate}\n\\end{align}\n\\]\nが境界条件を満たす変数分離型の解となるとこが分かります．重ね合わせの原理より \\(\\eqref{eq-sol-candidate}\\) の定数倍も境界条件と熱伝導方程式を満たす関数となります．\n重ね合わせの原理より \\(1 \\leq n \\leq N\\) の範囲で\n\\[\n\\sum_{n=1}^N a_n \\alpha\\exp(-n^2At) \\cdot \\gamma\\sin(n\\pi)\n\\]\nも境界条件と熱伝導方程式を満たす関数となります．ここでフーリエは次のような主張をしました：\n\n\\[\n\\sum_{n=1}^\\infty a_n \\alpha\\exp(-n^2At) \\cdot \\gamma\\sin(n\\pi)\n\\]\nも境界条件と熱伝導方程式を満たす関数となりえる\n\nここから初期条件を満たす関数を求めたいので, \\(t=0\\) とすると\n\\[\nf(x) = \\sum_{n=1}^\\infty b_n \\sin(n\\pi)\n\\]\nが成り立つように \\(\\{b_n\\}_{n=1}^\\infty\\) を定めれば良いとなります．このとき，正弦関数の積の積分公式\n\\[\n\\begin{align}\n\\int^{\\pi}_0\\sin nx \\sin mx dx =\\begin{cases}\n\\displaystyle 0 & (m\\neq n)\\\\[4pt]\n\\displaystyle \\frac{\\pi}{2} & (m = n)\n\\end{cases}\n\\end{align}\n\\]\n従って，\n\\[\n\\begin{align}\n\\int^{\\pi}_0f(x)\\sin mx\\ dx\n& = \\int^\\pi_0 \\sum_{n=1}^\\infty b_n \\sin(n\\pi) \\sin(m\\pi) dx\\\\\n&= \\sum_{n=1}^\\infty \\int^\\pi_0b_n \\sin(n\\pi) \\sin(m\\pi) dx\\\\\n&= \\frac{\\pi}{2}b_m\n\\end{align}\n\\]\nとなり，\n\\[\nb_n = \\frac{2}{\\pi}\\int^{\\pi}_0f(x)\\sin nx \\ dx\n\\]\nこのように求めた級数関数が変数分離型を仮定したときの熱伝導方程式の解となりうるとフーリエは主張しました． これがフーリエ級数の誕生です.\n\n\nフーリエ級数の問題点と積分理論再考へ\nフーリエ級数が登場初期には以下のような批判にさらされました:\n\nフーリエ級数が収束する保証はどこにあるのか？\n\\(0\\)から\\(\\pi\\)までの特定の一個の\\(x\\)について\\(f(x)\\)の値を変更しても積分の値には影響しないので異なる関数が同じフーリエ級数で表現されてしまうのではないか？\n無限級数の項別積分(無限和と積分の順序交換)ができる保証はどこにあるのか？\n\n無限和と積分の順序交換の批判とは，仮に熱分布関数\\(T(x, t)\\)がフーリエ級数の形式で表せることができたとしても\n\\[\n\\begin{align*}\n&\\int^\\pi_{-\\pi}\\sum_{k=1}^\\infty (a_k \\cos kx + b_k \\sin kx)\\cos nx\\ dx \\\\\n&=\\sum_{k=1}^\\infty \\left(a_k \\int^\\pi_{-\\pi}\\cos kx \\cos nx\\ dx + b_k \\int^\\pi_{-\\pi}\\sin kx \\cos nx\\ dx\\right)\n\\end{align*}\n\\]\nができる保証がないというものです. これはフーリエ級数のそれ自体の問題というよりかは\n\nどんな関数が積分可能か？\nどのようなときに項別積分ができるのか？\n\nという積分の定義・理論の問題です．フーリエの時代では積分の理論が十分なものではなく，微分の逆として積分が捉えられており，上記の問題に答えることができませんでした． 以上が，熱の変化という自然科学現象の解明のため提案されたフーリエ級数が数学理論，特に積分理論の再整備の必要性を促した流れとなります．"
  },
  {
    "objectID": "posts/2025-01-29-set-and-topology-series/index.html#appendix-正弦関数の積の積分公式の証明",
    "href": "posts/2025-01-29-set-and-topology-series/index.html#appendix-正弦関数の積の積分公式の証明",
    "title": "フーリエ級数と積分理論再考",
    "section": "Appendix: 正弦関数の積の積分公式の証明",
    "text": "Appendix: 正弦関数の積の積分公式の証明\n\n\nExercise 1 \n\\(n,k\\)をそれぞれ自然数としたとき\n\\[\n\\begin{align}\n\\int^{\\pi}_0\\sin nx \\sin kx dx =\\begin{cases}\n\\displaystyle 0 & (k\\neq n)\\\\[4pt]\n\\displaystyle \\frac{\\pi}{2} & (k = n)\n\\end{cases}\n\\end{align}\n\\]\n\n\n\n\n\n\n\n\n\nProof\n\n\n\n\n\n積和の公式より\n\\[\n\\sin \\alpha\\sin \\beta=-\\frac{1}{2} \\left\\{\\cos(\\alpha+\\beta)-\\cos(\\alpha-\\beta)\\right\\}\n\\]\nこの積和の公式を用いると\n\\[\n\\begin{align}\n&\\int^{\\pi}_0\\sin nx \\sin kx\\ dx \\\\\n&= -\\frac{1}{2}\\int^{\\pi}_0 \\left\\{\\cos(n+k)x-\\cos(n-k)x\\right\\} dx \\\\\n&= -\\frac{1}{2}\\left\\{\\int^{\\pi}_0\\cos(n+k)x\\ dx- \\int^{\\pi}_0\\cos(n-k)x\\ dx\\right\\}\n\\end{align}\n\\]\nつぎに以下のケースを考えます\n\n\\(n=k\\)のとき\n\\(n\\neq k\\)のとき\n\n\n\\(n=k\\)のとき\n\n\\[\n-\\frac{1}{2}\\left\\{\\int^{\\pi}_0\\cos(n+k)x\\ dx- \\int^{\\pi}_0\\cos(n-k)x\\ dx\\right\\}\n\\]\nの第二項は\\(\\pi\\)となる一方, 第一項は\n\\[\n\\begin{align}\n\\int^{\\pi}_0\\cos(n+k)x dx &= -\\left[\\sin(n+k)x\\right]^{\\pi}_0\\\\\n&= 0\n\\end{align}\n\\]\n従って,\n\\[\n-\\frac{1}{2}\\left\\{\\int^{\\pi}_0\\cos(n+k)x\\ dx- \\int^{\\pi}_0\\cos(n-k)x\\ dx\\right\\} = \\frac{\\pi}{2}\n\\]\n\n\\(n\\neq k\\)のとき\n\n\\[\n\\begin{align}\n\\int^{\\pi}_0\\cos(n-k)x\\ dx &= -\\left[\\sin(n-k)x\\right]^{\\pi}_0 = 0\\\\[3pt]\n\\int^{\\pi}_0\\cos(n+k)x\\ dx &= -\\left[\\sin(n+k)x\\right]^{\\pi}_0 = 0\n\\end{align}\n\\]\nより\n\\[\n-\\frac{1}{2}\\left\\{\\int^{\\pi}_0\\cos(n+k)x\\ dx- \\int^{\\pi}_0\\cos(n-k)x\\ dx\\right\\} = 0\n\\]"
  },
  {
    "objectID": "posts/2025-01-08-bigquery-preprocess-01/index.html",
    "href": "posts/2025-01-08-bigquery-preprocess-01/index.html",
    "title": "BigQuery: TIME型カラムを指定したレベルで丸めて集計する",
    "section": "",
    "text": "▶  スーパーの来店時刻データ\n\n\n\nmember_id\nusage_date\nusage_time\n\n\n\n\n\n123456\n2024-02-01\n08:09:00\n\n\n\n223456\n2024-02-01\n08:10:00\n\n\n\n223456\n2024-02-11\n08:10:00\n\n\n\n123456\n2024-02-01\n20:09:00\n\n\n\n323456\n2024-02-01\n20:09:00\n\n\n\n\nという形でとあるスーパーの来店時刻データregmonkey-sample-data.restaurant_kawasaki.customer_recordが与えられているとします． このとき，以下の3つの処理を実施して，曜日×時間帯別平均来店者数の集計を行いたいとします．\n ▶  処理1: 24時間オーバーのデータへ変換\n\n00:01:00 → 24:00:00\n01:01:59 → 25:00:00\n\nのように夜中02:59:59までは26:59:59へ変換するという処理\n ▶  処理2: TIME型データを丸める\n\n08:09:00 → 08:00:00\n08:20:00 → 08:15:00\n\nのようにTIME型データを15分刻みに丸める処理\n ▶  処理3: DATE型データをISO day of weekへ変換\n\n月曜日を1, 日曜日を7とするISO day of weekに変換する\n祝日は8をアサインする\n\n2024-02-11, 2024-02-23は8がアサインされる"
  },
  {
    "objectID": "posts/2025-01-08-bigquery-preprocess-01/index.html#what-i-want-to-do",
    "href": "posts/2025-01-08-bigquery-preprocess-01/index.html#what-i-want-to-do",
    "title": "BigQuery: TIME型カラムを指定したレベルで丸めて集計する",
    "section": "",
    "text": "▶  スーパーの来店時刻データ\n\n\n\nmember_id\nusage_date\nusage_time\n\n\n\n\n\n123456\n2024-02-01\n08:09:00\n\n\n\n223456\n2024-02-01\n08:10:00\n\n\n\n223456\n2024-02-11\n08:10:00\n\n\n\n123456\n2024-02-01\n20:09:00\n\n\n\n323456\n2024-02-01\n20:09:00\n\n\n\n\nという形でとあるスーパーの来店時刻データregmonkey-sample-data.restaurant_kawasaki.customer_recordが与えられているとします． このとき，以下の3つの処理を実施して，曜日×時間帯別平均来店者数の集計を行いたいとします．\n ▶  処理1: 24時間オーバーのデータへ変換\n\n00:01:00 → 24:00:00\n01:01:59 → 25:00:00\n\nのように夜中02:59:59までは26:59:59へ変換するという処理\n ▶  処理2: TIME型データを丸める\n\n08:09:00 → 08:00:00\n08:20:00 → 08:15:00\n\nのようにTIME型データを15分刻みに丸める処理\n ▶  処理3: DATE型データをISO day of weekへ変換\n\n月曜日を1, 日曜日を7とするISO day of weekに変換する\n祝日は8をアサインする\n\n2024-02-11, 2024-02-23は8がアサインされる"
  },
  {
    "objectID": "posts/2025-01-08-bigquery-preprocess-01/index.html#query-example",
    "href": "posts/2025-01-08-bigquery-preprocess-01/index.html#query-example",
    "title": "BigQuery: TIME型カラムを指定したレベルで丸めて集計する",
    "section": "Query Example",
    "text": "Query Example\n ▶  処理1: 24時間オーバーのデータへ変換\nTIME型のままでは23:59:59までしかカバーされないので，extended timeの表記を試みたい場合はSTRING型へ変換する必要があります．\nCREATE TEMP FUNCTION convert_extended_time(standard_time TIME)\nRETURNS STRING\nAS (\n  CASE \n    WHEN EXTRACT(HOUR FROM standard_time) &lt; 3 THEN\n      FORMAT(\"%02d:%02d:%02d\", EXTRACT(HOUR FROM standard_time) + 24, EXTRACT(MINUTE FROM standard_time), EXTRACT(SECOND FROM standard_time))\n    ELSE \n      FORMAT(\"%02d:%02d:%02d\", EXTRACT(HOUR FROM standard_time), EXTRACT(MINUTE FROM standard_time), EXTRACT(SECOND FROM standard_time))\n  END\n);\n ▶  処理2: TIME型データを丸める\nCREATE TEMP FUNCTION round_to_nearest_15_minute(usage_time TIME, round_level INT64)\nRETURNS TIME\nAS (\n  TIME_TRUNC(\n    TIME_SUB(usage_time, INTERVAL MOD(EXTRACT(MINUTE FROM usage_time), round_level) MINUTE),\n    MINUTE\n  )\n);\n ▶  処理3: DATE型データをISO day of weekへ変換\nBigQueryが提供する EXTRACT(DAYOFWEEK FROM &lt;date-column&gt;) は日曜日1から始まり土曜日7で終わる形式となっているので自分で以下のように関数をUDFを定義することが必要になります．\nCREATE TEMP FUNCTION convert_iso_dayofweek(usage_date DATE)\nRETURNS INT64\nAS (\n  MOD(EXTRACT(DAYOFWEEK FROM usage_date) + 5, 7) + 1\n);\n ▶  データ抽出クエリ\nWITH\n  daily_summary AS(\n    SELECT \n        usage_date,\n        round_to_nearest_15_minute(usage_time, 15) AS rounded_usage_time,\n        CASE\n          WHEN usage_date in (DATE('2024-02-11'), DATE('2024-02-23')) THEN 8\n          ELSE convert_iso_dayofweek(usage_date) \n        END AS dayofweek,\n        COUNT(1) AS customer_count\n    FROM \n        `regmonkey-sample-data.restaurant_kawasaki.customer_record`\n    GROUP BY\n        1, 2\n  )\nSELECT\n    dayofweek,\n    convert_extended_time(rounded_usage_time) AS rounded_usage_time,\n    AVG(customer_count) AS mean_customer_count\nFROM\n    daily_summary \nGROUP BY \n  1, 2\nORDER BY\n  1, 2;"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Regmonkey datascience blog",
    "section": "",
    "text": "All\n\n\n\n\n\nDate\n\n\nTitle\n\n\nCategories\n\n\nReading Time\n\n\n\n\n\n\n2025-01-29\n\n\nフーリエ級数と積分理論再考\n\n\ndatabase\n\n\n4 min\n\n\n\n\n2025-01-08\n\n\nBigQuery: TIME型カラムを指定したレベルで丸めて集計する\n\n\nsql\n\n\n2 min\n\n\n\n\n2024-12-17\n\n\nFirefoxを用いたsocks5 proxyブラウザアクセス設定\n\n\nfirefox, network\n\n\n2 min\n\n\n\n\n2024-12-16\n\n\nmacOSへのssh接続\n\n\nssh\n\n\n1 min\n\n\n\n\n2024-12-11\n\n\nCloud StorageからExternal Tableの作成\n\n\nBigQuery\n\n\n2 min\n\n\n\n\n2024-12-07\n\n\nIPアドレス 0.0.0.0\n\n\nnetwork, quarto\n\n\n3 min\n\n\n\n\n\nNo matching items\n\n\n  \n\n\n\n\n数学\n\n集合と位相\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDate\n\n\nTitle\n\n\nCategories\n\n\nReading Time\n\n\n\n\n\n\n2025-01-29\n\n\nフーリエ級数と積分理論再考\n\n\ndatabase\n\n\n4 min\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "某経済学研究科修士取得後，どこかのデータサイエンス（コンサル）会社に勤務してます． Arsenalが好きです．"
  },
  {
    "objectID": "posts/2024-12-07-meta-address/index.html",
    "href": "posts/2024-12-07-meta-address/index.html",
    "title": "IPアドレス 0.0.0.0",
    "section": "",
    "text": "pythonでhttp serverを立てて，Quartoで作成したウェブサイトを以下のコマンドで公開するとします\n% python -m http.server 3000 --directory ./_site/\nServing HTTP on 0.0.0.0 port 3000 (http://0.0.0.0:3000/) ..\nバインド先を設定せずにserverを立ち上げたところ，0.0.0.0 で立ち上げているようです． このとき，Firewallの3000 portをホスト側でAllowすると，同じnetworkの他の端末(例:iPad)からでもアクセスできるようになりました．\n ▶  プライベートIPアドレスをバインド先に指定した場合 \n自宅内のネットワークのみで有効なプライベートIPアドレス（クラスC 192.168.0.0 ~ 192.168.255.255）を指定してhttp serverを立たてみます．\n% python -m http.server 3000 --directory ./_site/ --bind 192.168.10.105\nServing HTTP on 192.168.10.105 port 3000 (http://192.168.10.105:3000/) ...\nこのとき，同じネットワーク内にあるiPadからアクセスできるようになりました． iPad側では http://192.168.10.105:3000 に接続することでQuarto contentsにアクセスできるようになりましたが， このiPad側での操作は 0.0.0.0 で立ち上げたときと同じ操作となります．\n\n❓ Question \npython http.server を使用して 0.0.0.0 にバインドしてhttp serverを立てたときの挙動がプライベートネットワーク内部で割り当てられたプライベートIPアドレスを指定したときと同じ挙動をするのか？\n\n\n\nIPv4において 0.0.0.0 (IPv6では::/0) はSepcial-Purpose Address Registry，つまり特別な目的用に予約されたアドレスです．\n\nRFC6890\n\n\n\n\n\n\nAttribute\nValue\n\n\n\n\nAddress Block\n0.0.0.0/8\n\n\nName\nThis host on this network\n\n\nRFC\n[RFC1122], Section 3.2.1.3\n\n\nAllocation Date\nSeptember 1981\n\n\nTermination Date\nN/A\n\n\nSource\nTrue\n\n\nDestination\nFalse\n\n\nForwardable\nFalse\n\n\nGlobal\nFalse\n\n\nReserved-by-Protocol\nTrue\n\n\n\n上記より0.0.0.0 ~ 0.255.255.255について以下の情報を得ることができます\n\nGlobalセクションがFalseとなっていることから，グローバルIPアドレスとして使用できない．利用はローカルネットワークに限定される\nSourceセクションTrueより，送信元アドレスとして有効\nDestinationセクションFalseより，宛先アドレスとして使用できない = ルーティング不可\n\nただし，0.0.0.0の具体的な意味はここからではまだわかりません．\n ▶  0.0.0.0/0 vs 0.0.0.0/32 \n\n\n\n\n\n\n\n\nAttribute\n0.0.0.0/0\n0.0.0.0/32\n\n\n\n\nSubnet Mask\n0.0.0.0 (all bits variable)\n255.255.255.255 (all bits fixed)\n\n\nRange\nAll IPv4 addresses (0.0.0.0 to 255.255.255.255)\n0.0.0.0\n\n\n\n\n\n\nバインド先を指定しないでhttp serverを立てるとき，バインド先を指定しない = 有効な宛先がないことを意味します． このとき使用されるのが 0.0.0.0 です．\nこの文脈での 0.0.0.0 は catch-all wildcard と呼ばれるもので，同じネットワーク上のすべてのインターフェースに対して， バインドするという特別な意味を持っています．コンピューターが複数のネットワークに接続していて，すべてのネットワークにバインドしたい場合に 0.0.0.0を指定します．ただし，不必要に使用してしまうと誤って外部のネットワークに共有してしまったりするので使用は控えたほうが良いです．\n\n📘 REMARKS \n\nPython HTTP Serverにおける 0.0.0.0 はルーティングにおけるデフォルトルートとしての0.0.0.0は異なります\n文脈に応じて 0.0.0.0 が指す内容が異なることに注意してください\npython hhtp.serverの文脈では0.0.0.0にバインドすると以下のインターフェースからアクセス可能となります\n\nLocalhost (127.0.0.1)\nThe private network (例: 192.168.x.x)\nPublic network interfaces (Firewallでアクセスを許容していた場合)\n\n\n\nPython http serverをprivate networkに限定する意図を込めて，以下のスクリプトでホスティングすることが望ましいです\n$ python3 -m http.server -b &lt;your-local-private-network IP&gt; 8080 --directory ./_site/"
  },
  {
    "objectID": "posts/2024-12-07-meta-address/index.html#ipアドレス-0.0.0.0にバインド",
    "href": "posts/2024-12-07-meta-address/index.html#ipアドレス-0.0.0.0にバインド",
    "title": "IPアドレス 0.0.0.0",
    "section": "",
    "text": "pythonでhttp serverを立てて，Quartoで作成したウェブサイトを以下のコマンドで公開するとします\n% python -m http.server 3000 --directory ./_site/\nServing HTTP on 0.0.0.0 port 3000 (http://0.0.0.0:3000/) ..\nバインド先を設定せずにserverを立ち上げたところ，0.0.0.0 で立ち上げているようです． このとき，Firewallの3000 portをホスト側でAllowすると，同じnetworkの他の端末(例:iPad)からでもアクセスできるようになりました．\n ▶  プライベートIPアドレスをバインド先に指定した場合 \n自宅内のネットワークのみで有効なプライベートIPアドレス（クラスC 192.168.0.0 ~ 192.168.255.255）を指定してhttp serverを立たてみます．\n% python -m http.server 3000 --directory ./_site/ --bind 192.168.10.105\nServing HTTP on 192.168.10.105 port 3000 (http://192.168.10.105:3000/) ...\nこのとき，同じネットワーク内にあるiPadからアクセスできるようになりました． iPad側では http://192.168.10.105:3000 に接続することでQuarto contentsにアクセスできるようになりましたが， このiPad側での操作は 0.0.0.0 で立ち上げたときと同じ操作となります．\n\n❓ Question \npython http.server を使用して 0.0.0.0 にバインドしてhttp serverを立てたときの挙動がプライベートネットワーク内部で割り当てられたプライベートIPアドレスを指定したときと同じ挙動をするのか？\n\n\n\nIPv4において 0.0.0.0 (IPv6では::/0) はSepcial-Purpose Address Registry，つまり特別な目的用に予約されたアドレスです．\n\nRFC6890\n\n\n\n\n\n\nAttribute\nValue\n\n\n\n\nAddress Block\n0.0.0.0/8\n\n\nName\nThis host on this network\n\n\nRFC\n[RFC1122], Section 3.2.1.3\n\n\nAllocation Date\nSeptember 1981\n\n\nTermination Date\nN/A\n\n\nSource\nTrue\n\n\nDestination\nFalse\n\n\nForwardable\nFalse\n\n\nGlobal\nFalse\n\n\nReserved-by-Protocol\nTrue\n\n\n\n上記より0.0.0.0 ~ 0.255.255.255について以下の情報を得ることができます\n\nGlobalセクションがFalseとなっていることから，グローバルIPアドレスとして使用できない．利用はローカルネットワークに限定される\nSourceセクションTrueより，送信元アドレスとして有効\nDestinationセクションFalseより，宛先アドレスとして使用できない = ルーティング不可\n\nただし，0.0.0.0の具体的な意味はここからではまだわかりません．\n ▶  0.0.0.0/0 vs 0.0.0.0/32 \n\n\n\n\n\n\n\n\nAttribute\n0.0.0.0/0\n0.0.0.0/32\n\n\n\n\nSubnet Mask\n0.0.0.0 (all bits variable)\n255.255.255.255 (all bits fixed)\n\n\nRange\nAll IPv4 addresses (0.0.0.0 to 255.255.255.255)\n0.0.0.0\n\n\n\n\n\n\nバインド先を指定しないでhttp serverを立てるとき，バインド先を指定しない = 有効な宛先がないことを意味します． このとき使用されるのが 0.0.0.0 です．\nこの文脈での 0.0.0.0 は catch-all wildcard と呼ばれるもので，同じネットワーク上のすべてのインターフェースに対して， バインドするという特別な意味を持っています．コンピューターが複数のネットワークに接続していて，すべてのネットワークにバインドしたい場合に 0.0.0.0を指定します．ただし，不必要に使用してしまうと誤って外部のネットワークに共有してしまったりするので使用は控えたほうが良いです．\n\n📘 REMARKS \n\nPython HTTP Serverにおける 0.0.0.0 はルーティングにおけるデフォルトルートとしての0.0.0.0は異なります\n文脈に応じて 0.0.0.0 が指す内容が異なることに注意してください\npython hhtp.serverの文脈では0.0.0.0にバインドすると以下のインターフェースからアクセス可能となります\n\nLocalhost (127.0.0.1)\nThe private network (例: 192.168.x.x)\nPublic network interfaces (Firewallでアクセスを許容していた場合)\n\n\n\nPython http serverをprivate networkに限定する意図を込めて，以下のスクリプトでホスティングすることが望ましいです\n$ python3 -m http.server -b &lt;your-local-private-network IP&gt; 8080 --directory ./_site/"
  },
  {
    "objectID": "posts/2024-12-07-meta-address/index.html#references",
    "href": "posts/2024-12-07-meta-address/index.html#references",
    "title": "IPアドレス 0.0.0.0",
    "section": "References",
    "text": "References\n\nRFC5735"
  },
  {
    "objectID": "posts/2024-12-16-ssh-to-macos/index.html",
    "href": "posts/2024-12-16-ssh-to-macos/index.html",
    "title": "macOSへのssh接続",
    "section": "",
    "text": "同じprivate networkに属しているmacOS端末に対して公開鍵認証を用いてssh接続したい\n\n同じprovate networkに属している前提の端末へのsshになるので\nssh hoshinokirby@192.168.10.110\nのように自宅内のネットワークのみで有効なプライベートIPアドレス（クラスC 192.168.0.0 ~ 192.168.255.255）を指定してアクセスすることを想定しています．"
  },
  {
    "objectID": "posts/2024-12-16-ssh-to-macos/index.html#what-we-want-to-do",
    "href": "posts/2024-12-16-ssh-to-macos/index.html#what-we-want-to-do",
    "title": "macOSへのssh接続",
    "section": "",
    "text": "同じprivate networkに属しているmacOS端末に対して公開鍵認証を用いてssh接続したい\n\n同じprovate networkに属している前提の端末へのsshになるので\nssh hoshinokirby@192.168.10.110\nのように自宅内のネットワークのみで有効なプライベートIPアドレス（クラスC 192.168.0.0 ~ 192.168.255.255）を指定してアクセスすることを想定しています．"
  },
  {
    "objectID": "posts/2024-12-16-ssh-to-macos/index.html#how-to-set-up",
    "href": "posts/2024-12-16-ssh-to-macos/index.html#how-to-set-up",
    "title": "macOSへのssh接続",
    "section": "How to set up",
    "text": "How to set up\n ▶  Server側\nSSHサーバー側はopenssh-serverなりssh serverが動いている必要があります．\n\nSystem Preferences &gt; Sharingをクリック\nRemote Loginを有効化\n\n以上の2ステップで，macOS側のSSH serverをactive状態にすることができます．\n ▶  Client側\nパスワード認証の場合は\n\narpコマンドでアクセス先端末のプライベートIPアドレスを検索\nsshコマンドでアクセス\n\nで完了となりますが，今回は公開鍵認証手順を紹介します．公開鍵認証の場合は\n\nSSH Key Pair の作成\n公開鍵の登録(接続先のauthorized_keysファイル（~/.ssh/authorized_keys）に追加)\nsshコマンドでアクセスとなります\n\n\n\nSSH Key Pair の作成\n\nssh-keygen -t rsa -b 4096 -f ~/.ssh/pupupu_land\n\n\n-t rsa: key typeの指定\n-b 4096: key lengthの指定(長いほどsecurity強固になる)\n-f  ~/.ssh/pupupu_land: key pairの生成先とファイル名（今回はpupupu_land, pupupu_land.pubが生成される）\n\n\n\n公開鍵の登録\n\nssh-copy-id -i ~/.ssh/pupupu_land.pub username@&lt;target-ip&gt;\n\n\n-i ~/.ssh/pupupu_land.pub: コピーする公開鍵ファイルを指定\n\n公開鍵を登録するには，\n\n公開鍵のファイルをコピー\n接続先のauthorized_keysファイル（~/.ssh/authorized_keys）に追加\nauthorized_keysファイルがない場合は作成後に適切なパーミッションを設定\n\nが必要となりますが，ssh-copy-idコマンドですべて自動実行することができるというメリットがあります．\n ▶  ssh connection\n上記の設定後，sshコマンド実行することで，macOSへアクセスすることができます． 毎回プライベートIPアドレスを調べるのが億劫な場合，デバイスのMACアドレスがわかればarpコマンドで以下のように検索することもできます．\narp -a | grep &lt;MAC-address&gt; | awk -F'[()]' '{print $2}'"
  },
  {
    "objectID": "posts/2024-12-17-firefox-proxy-access/index.html",
    "href": "posts/2024-12-17-firefox-proxy-access/index.html",
    "title": "Firefoxを用いたsocks5 proxyブラウザアクセス設定",
    "section": "",
    "text": "アクセス元のglobal IPが制限されたサイト(例: 社内用gitlabサーバー)へアクセスする場合，\n\n許可されたglobal IPに属するプライベートIPネットワークに接続している端末からアクセス\n別端末から上記の端末へssh接続し，プロキシサーバー的に使用をする\n\nという2つの方法が考えられます．後者の方法をFirefoxを用いて設定する方法を紹介します．\n ▶  なぜFirefoxなのか？\n\nGoogle chromeでもproxy設定は可能ですが，OS側の設定を変更してしまう\nFirefoxはブラウザレベルでproxyの設定が可能"
  },
  {
    "objectID": "posts/2024-12-17-firefox-proxy-access/index.html#what-we-want-to-do",
    "href": "posts/2024-12-17-firefox-proxy-access/index.html#what-we-want-to-do",
    "title": "Firefoxを用いたsocks5 proxyブラウザアクセス設定",
    "section": "",
    "text": "アクセス元のglobal IPが制限されたサイト(例: 社内用gitlabサーバー)へアクセスする場合，\n\n許可されたglobal IPに属するプライベートIPネットワークに接続している端末からアクセス\n別端末から上記の端末へssh接続し，プロキシサーバー的に使用をする\n\nという2つの方法が考えられます．後者の方法をFirefoxを用いて設定する方法を紹介します．\n ▶  なぜFirefoxなのか？\n\nGoogle chromeでもproxy設定は可能ですが，OS側の設定を変更してしまう\nFirefoxはブラウザレベルでproxyの設定が可能"
  },
  {
    "objectID": "posts/2024-12-17-firefox-proxy-access/index.html#firefoxにおけるsocks5-proxy設定",
    "href": "posts/2024-12-17-firefox-proxy-access/index.html#firefoxにおけるsocks5-proxy設定",
    "title": "Firefoxを用いたsocks5 proxyブラウザアクセス設定",
    "section": "Firefoxにおけるsocks5 proxy設定",
    "text": "Firefoxにおけるsocks5 proxy設定\n\nFirefoxを開いて、右上のメニューボタン（三本線）をクリック\nメニューから「設定」を選択\nネットワーク設定を開く\n「手動でプロキシ設定をする」オプションを選択\n「SOCKS v5」を選択し，SOCKSホストを127.0.0.1，ポートを1080で設定\n変更を保存\n\n\n\n\nfirefox-proxy-setting\n\n\n\nHow to use\nLinux, Windows, MacOS問わず\nssh &lt;username&gt;@&lt;proxy-server&gt; -D 1080\nとまず，ssh接続を確立します．-D オプションはダイナミックポートフォワーディング (Dynamic Port Forwarding)の設定です． 上記を実行するとローカルの 1080番ポート にSOCKS5プロキシが立ち上がります．\nFirefoxで SOCKS5プロキシ 127.0.0.1:1080と設定すると，\n\n\n\n\n\nsequenceDiagram\n    participant Client as クライアント\n    participant LocalSOCKS as localhost:1080 (SOCKSプロキシ)\n    participant SSHTunnel as SSHトンネル\n    participant RemoteServer as リモートサーバー\n    participant ExternalServer as 外部サーバー\n\n    %% 1. クライアントがSOCKSプロキシに接続\n    Client-&gt;&gt;LocalSOCKS: データ送信 (接続要求, 宛先IP/ポート)\n\n    %% 2. SOCKSプロキシがSSHトンネル経由でリモートサーバーに転送\n    LocalSOCKS-&gt;&gt;SSHTunnel: データ転送 (暗号化)\n\n    %% 3. SSHトンネルがリモートサーバーに転送\n    SSHTunnel-&gt;&gt;RemoteServer: データ中継 (トンネル経由)\n\n    %% 4. リモートサーバーが外部サーバーに接続\n    RemoteServer-&gt;&gt;ExternalServer: 外部サーバー接続要求 (TCP/UDP)\n    ExternalServer--&gt;&gt;RemoteServer: 接続応答\n\n    %% 5. 応答をクライアントに返送\n    RemoteServer--&gt;&gt;SSHTunnel: 応答データ\n    SSHTunnel--&gt;&gt;LocalSOCKS: 暗号化データ戻し\n    LocalSOCKS--&gt;&gt;Client: レスポンス転送\n\n\n\n\n\n\n\nという順序で通信されるようになります．"
  },
  {
    "objectID": "posts/2024-12-17-firefox-proxy-access/index.html#appendix-プロキシサーバーの仕組み",
    "href": "posts/2024-12-17-firefox-proxy-access/index.html#appendix-プロキシサーバーの仕組み",
    "title": "Firefoxを用いたsocks5 proxyブラウザアクセス設定",
    "section": "Appendix: プロキシサーバーの仕組み",
    "text": "Appendix: プロキシサーバーの仕組み\nクライアントの依頼に応じて，外部のサーバーにサービスを要求し，その結果をクライアントに提供するサーバーをプロキシサーバーといいます． SOCKS5は，プロキシサーバーを利用してサーバーとクライアント間のパケットをルーティングするインターネットプロトコルのことを指します．\nSOCKS5プロキシサーバーのメリットとして，安全性，匿名性，利便性の3つがあります．\n ▶  安全性\n\nSOCKS5は，ユーザー名とパスワードによる認証機能をサポートしているため，外部の不正アクセスや認証されていないクライアントからの利用を防ぐことができる\nSSHトンネルと組み合わせることで，安全にSOCKS5プロキシサーバー経由の通信を暗号化することができる = リモートアクセス時のデータ転送が保護され，悪意のあるネットワーク環境でも安全に通信可能\nプロキシサーバーを中間地点として使用することで，DDoS攻撃などの直接的な大量トラフィック攻撃を遮断することが可能\n\n ▶  匿名性\n\nネットワーク全体のトラフィックがプロキシサーバー経由で処理されるため，外部から見えるIPアドレスが プロキシのIPになる = SOCKS5プロキシを介することで，クライアントのIPアドレス/端末名を隠すことができる\n一括でアクセス元をプロキシのIPに集約し，クライアントIPを隠蔽することでセキュリティとプライバシー保護が可能になるという活用方法がある\n\nSOCKS5プロキシは，クライアントから送信されたデータをそのまま中継しますが，データ送信時のヘッダ情報（IPアドレスなど）をカプセル化します． そのため，外部サーバーはデータの中身だけを認識し，送信元（クライアント）に関する情報は知ることができないという仕組みになっています．\n ▶  利便性\n\nSOCKS5はプロトコル非依存であり，TCPとUDPの両方の通信をサポートしている = FTP, SMTP, P2P, VoIP, DNSリクエスト, オンラインゲームなど多様なアプリケーションで利用可能\n\n\n\n\n\n\nsequenceDiagram\n    participant Client as クライアント\n    participant SOCKS5ProxyServer as SOCKS5プロキシサーバー\n    participant ExternalServer as 外部サーバー\n\n    %% 1. 接続要求とハンドシェイク\n    Client-&gt;&gt;SOCKS5ProxyServer: 接続要求 (Handshake: バージョン, 認証方式)\n    SOCKS5ProxyServer--&gt;&gt;Client: 認証方式応答 (成功/失敗)\n\n    %% 2. 外部サーバーへの接続要求\n    Client-&gt;&gt;SOCKS5ProxyServer: 外部サーバー接続要求 (宛先IP, ポート)\n    note right of Client: クライアントのIPアドレスは隠蔽される\n    SOCKS5ProxyServer-&gt;&gt;ExternalServer: 接続確立要求 (プロキシのIPを使用)\n\n    %% 3. 接続確立確認\n    ExternalServer--&gt;&gt;SOCKS5ProxyServer: 接続成功応答\n    SOCKS5ProxyServer--&gt;&gt;Client: 接続確立成功通知\n\n    %% 4. データ転送 (カプセル化)\n    Client-&gt;&gt;SOCKS5ProxyServer: データ送信 (カプセル化されたパケット)\n    note over SOCKS5ProxyServer: データをそのまま中継 (IPアドレス非公開)\n    SOCKS5ProxyServer-&gt;&gt;ExternalServer: データ転送 (TCP/UDP)\n    ExternalServer--&gt;&gt;SOCKS5ProxyServer: レスポンスデータ\n    SOCKS5ProxyServer--&gt;&gt;Client: レスポンス転送\n\n    %% 5. 通信終了\n    Client-&gt;&gt;SOCKS5ProxyServer: 通信終了リクエスト\n    SOCKS5ProxyServer-&gt;&gt;ExternalServer: 接続切断\n    SOCKS5ProxyServer--&gt;&gt;Client: 通信終了通知\n\n\n\n\n\n\n\nSOCKS5プロキシはキャッシュを行わない\nHTTPプロキシは一般的に，ウェブコンテンツ（画像、HTML、動画など）をキャッシュすることで，再アクセス時にデータ転送を高速化します． 一方，SOCKS5プロキシはキャッシュを行なわないという違いがあります．\n\nSOCKS5はデータ転送のトンネルを作る役割を果たすため，通信内容のデータを確認・保存することがない\nあくまで「データを中継する」プロトコルであり，内容に依存しないため，キャッシュ機能は持たない\n\nSOCKS5はキャッシュ機能を持たないことで，シンプルかつ高速な通信環境を提供してくれるものと理解していればOKだとおもいます． キャッシュはリアルタイム通信に不要ですし，また，キャッシュ管理の手間やストレージコストが不要というメリットもあります．"
  }
]