[
  {
    "objectID": "posts/2024-12-11-BQ-create-external-table/index.html",
    "href": "posts/2024-12-11-BQ-create-external-table/index.html",
    "title": "Cloud StorageからExternal Tableの作成",
    "section": "",
    "text": "Google Cloud StorageからBigQuery上にExternal tabaleを作成する\nPartition Fieldが定義されたExternal tabaleを作成するための条件を確認する"
  },
  {
    "objectID": "posts/2024-12-11-BQ-create-external-table/index.html#このノートのスコープ",
    "href": "posts/2024-12-11-BQ-create-external-table/index.html#このノートのスコープ",
    "title": "Cloud StorageからExternal Tableの作成",
    "section": "",
    "text": "Google Cloud StorageからBigQuery上にExternal tabaleを作成する\nPartition Fieldが定義されたExternal tabaleを作成するための条件を確認する"
  },
  {
    "objectID": "posts/2024-12-11-BQ-create-external-table/index.html#external-tableとは",
    "href": "posts/2024-12-11-BQ-create-external-table/index.html#external-tableとは",
    "title": "Cloud StorageからExternal Tableの作成",
    "section": "External Tableとは？",
    "text": "External Tableとは？\nBigQueryのExternal Table（外部テーブル）は，BigQuery内にデータをコピーまたはインポートすることなく， 外部データソースに直接アクセスしてクエリを実行できる機能です．\nBigQueryにおけるExternal Tableの利用形式として，permanent tableとtemporary tableの２つがあります．\n\npermanent table: BigQuery dataset内に作成され，外部データソースにリンクされるテーブル\ntemporary table: 外部データソースに対して一時的にクエリを実行する場合に利用されるテーブル\n\n一時的なテスト処理などでtemporary tableを用いることは有用ですが，分析者間でクエリやコードを共有して分析を進める場合はpermanent tableを持ちないと テーブルアクセスを共有できないので，このノートではpermanent tableを主に取り扱います．\n ▶  サポートされているデータストア\n\nBigLake\nCloud Storage\nBigtable\nGoogle Drive\nAmazon S3\nAzure Blob Storage\n\n以上のデータストアがBigQueryからアクセス可能な外部データソースとしてサポートされています\n ▶  Pricing\nBigQueryのPricingは\n\nCompute pricing: クエリの処理にかかる費用\nStorage pricing: データ保存費用\n\nの２つから構成されています．External Tableを用いると，後者の方はCloud Storage換算の費用となるため，一般的には ストレージコストを抑えることができます．ただし，External Tableにアクセスして分析するたびに\n\nQuery cost: クエリ計算処理時間に比例するコスト\nBytes cost: External tableからのデータ読み取りサイズに比例するコスト\n\nが発生します．\n\n📘 Tips \nExternal Tableを用いた分析が一時的なものであるならばExternal Tableを用いたほうが良いと思いますが， 頻繁にBigQueryからアクセスする場合は\n\nPartitioning/Clusteringを用いてアクセスサイズを抑える\nSELECT以下で*を使用せず，分析に用いるカラムを明示的に指定して，スキャンサイズを抑える\n\nという工夫，またはBigQuery native tableとしてデータを保持することを検討したほうが良いと思います．\n\n\nExternal Table use cases\nExternal Tableの特徴として，\n\nBigQuery native tableとしてデータは保持しない\nExternal Tableと紐づく外部ストアの最新データに対して，クエリ処理が走る\n\nがあります．そのため，PoCや営業段階での分析や頻繁にupdateされるデータに対してのオンライン分析といった場面で活用されるケースが多いです．\n\nExample: 営業段階でのアドホック分析 \n\nBtoC向けサービスを展開している企業Aに対して営業をしているとする\nNDAを結んだ後に，企業Aが保有しているデータのサンプルとして２年間分の連携してもらった\nこのデータを用いて簡易的な分析を行い，どのようなインサイトが導けそうか？を次の営業会議で企業Aに伝え説得したい\n\nという場面を考えます．\n ▶  Key Points\n\nわざわざテーブルスキーマを定義する時間はあまりない→早くEDAをやりたい\nサンプルデータなので，プロジェクト受注後に連携されるであろうデータセットよりも情報量が少ない→わざわざテーブルスキーマしても再利用可能性は低い\n\n ▶  External Tableのメリット\n\nテーブルスキーマをわざわざ定義しなくても，BigQueryを用いた大容量のデータに対しての分析が可能\n複数の分析者間でサンプルデータをCloud Storageベースで簡単に共有できる\nPythonなどの言語を用いた分析でも，予めBigQueryで前処理して小さいdatamartを作成し，それに対してEDAが実施できる"
  },
  {
    "objectID": "posts/2024-12-11-BQ-create-external-table/index.html#external-table作成",
    "href": "posts/2024-12-11-BQ-create-external-table/index.html#external-table作成",
    "title": "Cloud StorageからExternal Tableの作成",
    "section": "External Table作成",
    "text": "External Table作成\nここでは，EXTERNAL PARTITION TABLEの作成を目的に\n\ngoogle cloud storageへのupload\nEXTERNAL TABLEの作成\n\nの２段階の流れで説明します．\n ▶  Cloud Storageへのupload\n~/pupupuland_store_posというdirectory以下に，yyyymmdd形式の日付でpartitionされたPARQUET形式のデータがあるとします．\npupupuland_store_pos\n├── partition_dt=2023-09-23\n│   └── purchase_history_2023-09-23.parquet\n├── partition_dt=2023-09-24\n│   └── purchase_history_2023-09-24.parquet\n├── partition_dt=2023-09-25\n│   └── purchase_history_2023-09-25.parquet\n├── partition_dt=2023-09-26\n│   └── purchase_history_2023-09-26.parquet\n├── partition_dt=2023-09-27\n│   └── purchase_history_2023-09-27.parquet\n├── partition_dt=2023-09-28\n│   └── purchase_history_2023-09-28.parquet\n├── partition_dt=2023-09-29\n│   └── purchase_history_2023-09-29.parquet\n└── partition_dt=2023-09-30\n    └── purchase_history_2023-09-30.parquet\nこのディレクトリ構造を保持したまま，gs://project-make-dedede-great-again/というcloud storage bucketに格納したいとします．このとき\ngcloud storage cp -r ~/pupupuland_store_pos/ gs://project-make-dedede-great-again/\n以上で下準備は完了です．\n ▶  External Tableの作成\nGoogle Cloud project pupupuland-businessdata の dedede-holdings dataset以下に先程上げた pupupuland_store_pos tableを作成したいと思います．\nCREATE EXTERNAL TABLE `pupupuland-businessdata.dedede-holdings.pupupuland_store_pos`\nWITH PARTITION COLUMNS (\npartition_dt DATE, -- column order must match the external path\n)\nOPTIONS (\nuris = ['gs://project-make-dedede-great-again/pupupuland_store_pos/*'],\nformat = 'PARQUET',\nhive_partition_uri_prefix = 'gs://project-make-dedede-great-again/pupupuland_store_pos',\nrequire_hive_partition_filter = false);\nPARTITION COLUMNSのフィールドに partition_dtと入力していますが，これは外部ファイルのパスのパターンがgs://project-make-dedede-great-again/pupupuland_store_pos/partition_dt=yyyymmdd/data.parquet であることを前提にしています．そのため，upload時のdirectory構造を\n└── partition_dt=2023-09-30\n    └── purchase_history_20230930.parquet\nという形にしてcloud storageにuploadしたという背景があります．DATETYPEにDATEと指定していますが，/&lt;partition field&gt;=2018-10-18/という構造になっていないと失敗することに注意してください． 他にも INTEGER, STRING, TIMESTAMPが指定できます．TIMESTAMPの場合は，/&lt;partition field&gt;=2018-10-18 16:00:00+00/という構造であることが必要です．\nrequire_hive_partition_filter フィールドはクエリ時にpartition_dtによるWHERE句フィルタリングを強制するか否かの設定フィールドです． デフォルトではfalseとなっており，この場合はフィルタリングしなくてもクエリできることを意味します．"
  },
  {
    "objectID": "posts/2024-12-11-BQ-create-external-table/index.html#references",
    "href": "posts/2024-12-11-BQ-create-external-table/index.html#references",
    "title": "Cloud StorageからExternal Tableの作成",
    "section": "References",
    "text": "References\n\nIntroduction to external tables"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Regmonkey datascience blog",
    "section": "",
    "text": "Cloud StorageからExternal Tableの作成\n\n\n\n\n\n\nBigQuery\n\n\n\n\n\n\n\n\n\n2024-12-11\n\n\nRyo Nakagami\n\n\n\n\n\n\n\n\n\n\n\n\nIPアドレス 0.0.0.0\n\n\n\n\n\n\nnetwork\n\n\nquarto\n\n\n\n\n\n\n\n\n\n2024-12-07\n\n\nRyo Nakagami\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "某経済学研究科修士取得後，どこかのデータサイエンス（コンサル）会社に勤務してます． Arsenalが好きです．"
  },
  {
    "objectID": "posts/2024-12-07-meta-address/index.html",
    "href": "posts/2024-12-07-meta-address/index.html",
    "title": "IPアドレス 0.0.0.0",
    "section": "",
    "text": "pythonでhttp serverを立てて，Quartoで作成したウェブサイトを以下のコマンドで公開するとします\n% python -m http.server 3000 --directory ./_site/\nServing HTTP on 0.0.0.0 port 3000 (http://0.0.0.0:3000/) ..\nバインド先を設定せずにserverを立ち上げたところ，0.0.0.0 で立ち上げているようです． このとき，Firewallの3000 portをホスト側でAllowすると，同じnetworkの他の端末(例:iPad)からでもアクセスできるようになりました．\n ▶  プライベートIPアドレスをバインド先に指定した場合 \n自宅内のネットワークのみで有効なプライベートIPアドレス（クラスC 192.168.0.0 ~ 192.168.255.255）を指定してhttp serverを立たてみます．\n% python -m http.server 3000 --directory ./_site/ --bind 192.168.10.105\nServing HTTP on 192.168.10.105 port 3000 (http://192.168.10.105:3000/) ...\nこのとき，同じネットワーク内にあるiPadからアクセスできるようになりました． iPad側では http://192.168.10.105:3000 に接続することでQuarto contentsにアクセスできるようになりましたが， このiPad側での操作は 0.0.0.0 で立ち上げたときと同じ操作となります．\n\n❓ Question \npython http.server を使用して 0.0.0.0 にバインドしてhttp serverを立てたときの挙動がプライベートネットワーク内部で割り当てられたプライベートIPアドレスを指定したときと同じ挙動をするのか？\n\n\n\nIPv4において 0.0.0.0 (IPv6では::/0) はSepcial-Purpose Address Registry，つまり特別な目的用に予約されたアドレスです．\n\nRFC6890\n\n\n\n\n\n\nAttribute\nValue\n\n\n\n\nAddress Block\n0.0.0.0/8\n\n\nName\nThis host on this network\n\n\nRFC\n[RFC1122], Section 3.2.1.3\n\n\nAllocation Date\nSeptember 1981\n\n\nTermination Date\nN/A\n\n\nSource\nTrue\n\n\nDestination\nFalse\n\n\nForwardable\nFalse\n\n\nGlobal\nFalse\n\n\nReserved-by-Protocol\nTrue\n\n\n\n上記より0.0.0.0 ~ 0.255.255.255について以下の情報を得ることができます\n\nGlobalセクションがFalseとなっていることから，グローバルIPアドレスとして使用できない．利用はローカルネットワークに限定される\nSourceセクションTrueより，送信元アドレスとして有効\nDestinationセクションFalseより，宛先アドレスとして使用できない = ルーティング不可\n\nただし，0.0.0.0の具体的な意味はここからではまだわかりません．\n ▶  0.0.0.0/0 vs 0.0.0.0/32 \n\n\n\n\n\n\n\n\nAttribute\n0.0.0.0/0\n0.0.0.0/32\n\n\n\n\nSubnet Mask\n0.0.0.0 (all bits variable)\n255.255.255.255 (all bits fixed)\n\n\nRange\nAll IPv4 addresses (0.0.0.0 to 255.255.255.255)\n0.0.0.0\n\n\n\n\n\n\nバインド先を指定しないでhttp serverを立てるとき，バインド先を指定しない = 有効な宛先がないことを意味します． このとき使用されるのが 0.0.0.0 です．\nこの文脈での 0.0.0.0 は catch-all wildcard と呼ばれるもので，同じネットワーク上のすべてのインターフェースに対して， バインドするという特別な意味を持っています．コンピューターが複数のネットワークに接続していて，すべてのネットワークにバインドしたい場合に 0.0.0.0を指定します．ただし，不必要に使用してしまうと誤って外部のネットワークに共有してしまったりするので使用は控えたほうが良いです．\n\n📘 REMARKS \n\nPython HTTP Serverにおける 0.0.0.0 はルーティングにおけるデフォルトルートとしての0.0.0.0は異なります\n文脈に応じて 0.0.0.0 が指す内容が異なることに注意してください\npython hhtp.serverの文脈では0.0.0.0にバインドすると以下のインターフェースからアクセス可能となります\n\nLocalhost (127.0.0.1)\nThe private network (例: 192.168.x.x)\nPublic network interfaces (Firewallでアクセスを許容していた場合)\n\n\n\nPython http serverをprivate networkに限定する意図を込めて，以下のスクリプトでホスティングすることが望ましいです\n$ python3 -m http.server -b &lt;your-local-private-network IP&gt; 8080 --directory ./_site/"
  },
  {
    "objectID": "posts/2024-12-07-meta-address/index.html#ipアドレス-0.0.0.0にバインド",
    "href": "posts/2024-12-07-meta-address/index.html#ipアドレス-0.0.0.0にバインド",
    "title": "IPアドレス 0.0.0.0",
    "section": "",
    "text": "pythonでhttp serverを立てて，Quartoで作成したウェブサイトを以下のコマンドで公開するとします\n% python -m http.server 3000 --directory ./_site/\nServing HTTP on 0.0.0.0 port 3000 (http://0.0.0.0:3000/) ..\nバインド先を設定せずにserverを立ち上げたところ，0.0.0.0 で立ち上げているようです． このとき，Firewallの3000 portをホスト側でAllowすると，同じnetworkの他の端末(例:iPad)からでもアクセスできるようになりました．\n ▶  プライベートIPアドレスをバインド先に指定した場合 \n自宅内のネットワークのみで有効なプライベートIPアドレス（クラスC 192.168.0.0 ~ 192.168.255.255）を指定してhttp serverを立たてみます．\n% python -m http.server 3000 --directory ./_site/ --bind 192.168.10.105\nServing HTTP on 192.168.10.105 port 3000 (http://192.168.10.105:3000/) ...\nこのとき，同じネットワーク内にあるiPadからアクセスできるようになりました． iPad側では http://192.168.10.105:3000 に接続することでQuarto contentsにアクセスできるようになりましたが， このiPad側での操作は 0.0.0.0 で立ち上げたときと同じ操作となります．\n\n❓ Question \npython http.server を使用して 0.0.0.0 にバインドしてhttp serverを立てたときの挙動がプライベートネットワーク内部で割り当てられたプライベートIPアドレスを指定したときと同じ挙動をするのか？\n\n\n\nIPv4において 0.0.0.0 (IPv6では::/0) はSepcial-Purpose Address Registry，つまり特別な目的用に予約されたアドレスです．\n\nRFC6890\n\n\n\n\n\n\nAttribute\nValue\n\n\n\n\nAddress Block\n0.0.0.0/8\n\n\nName\nThis host on this network\n\n\nRFC\n[RFC1122], Section 3.2.1.3\n\n\nAllocation Date\nSeptember 1981\n\n\nTermination Date\nN/A\n\n\nSource\nTrue\n\n\nDestination\nFalse\n\n\nForwardable\nFalse\n\n\nGlobal\nFalse\n\n\nReserved-by-Protocol\nTrue\n\n\n\n上記より0.0.0.0 ~ 0.255.255.255について以下の情報を得ることができます\n\nGlobalセクションがFalseとなっていることから，グローバルIPアドレスとして使用できない．利用はローカルネットワークに限定される\nSourceセクションTrueより，送信元アドレスとして有効\nDestinationセクションFalseより，宛先アドレスとして使用できない = ルーティング不可\n\nただし，0.0.0.0の具体的な意味はここからではまだわかりません．\n ▶  0.0.0.0/0 vs 0.0.0.0/32 \n\n\n\n\n\n\n\n\nAttribute\n0.0.0.0/0\n0.0.0.0/32\n\n\n\n\nSubnet Mask\n0.0.0.0 (all bits variable)\n255.255.255.255 (all bits fixed)\n\n\nRange\nAll IPv4 addresses (0.0.0.0 to 255.255.255.255)\n0.0.0.0\n\n\n\n\n\n\nバインド先を指定しないでhttp serverを立てるとき，バインド先を指定しない = 有効な宛先がないことを意味します． このとき使用されるのが 0.0.0.0 です．\nこの文脈での 0.0.0.0 は catch-all wildcard と呼ばれるもので，同じネットワーク上のすべてのインターフェースに対して， バインドするという特別な意味を持っています．コンピューターが複数のネットワークに接続していて，すべてのネットワークにバインドしたい場合に 0.0.0.0を指定します．ただし，不必要に使用してしまうと誤って外部のネットワークに共有してしまったりするので使用は控えたほうが良いです．\n\n📘 REMARKS \n\nPython HTTP Serverにおける 0.0.0.0 はルーティングにおけるデフォルトルートとしての0.0.0.0は異なります\n文脈に応じて 0.0.0.0 が指す内容が異なることに注意してください\npython hhtp.serverの文脈では0.0.0.0にバインドすると以下のインターフェースからアクセス可能となります\n\nLocalhost (127.0.0.1)\nThe private network (例: 192.168.x.x)\nPublic network interfaces (Firewallでアクセスを許容していた場合)\n\n\n\nPython http serverをprivate networkに限定する意図を込めて，以下のスクリプトでホスティングすることが望ましいです\n$ python3 -m http.server -b &lt;your-local-private-network IP&gt; 8080 --directory ./_site/"
  },
  {
    "objectID": "posts/2024-12-07-meta-address/index.html#references",
    "href": "posts/2024-12-07-meta-address/index.html#references",
    "title": "IPアドレス 0.0.0.0",
    "section": "References",
    "text": "References\n\nRFC5735"
  }
]