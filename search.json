[
  {
    "objectID": "posts/2024-12-18-secure-shell/index.html",
    "href": "posts/2024-12-18-secure-shell/index.html",
    "title": "Secure Shellの仕組み",
    "section": "",
    "text": "Def: Secure Shell \nSSH(Secure SHell)は，ネットワークで接続された他コンピューターを遠隔操作するためのプロトコルのこと\n\nSSHプロトコルには現在，SSH1とSSH2という２つのプロトコルがあります. それぞれのプロトコルには互換性はありません. 一般的には，SSH1プロトコルには脆弱性が発見されているのでSSH2を用います. Ubuntu Serverでは，デフォルトでSSH2のみが有効となっています.\n ▶  特徴\n\n強力な認証機能と暗号化により，ファイル転送やリモート操作を安全に行うことができる\nユーザーログイン時のユーザー認証に先立って，クライアントがサーバーの正当性を確認するホスト認証が毎回行われるため偽サーバーに接続することで発生する情報漏えいリスクを低減することができる\nクライアント側から ssh コマンドを用いてSSH接続を試みる場合は，接続先のコンピュータでsshd（SSH daemon：SSHのサーバプログラム）が 動作している必要がある\n\n\n\n\n\n\n\n\nSSH接続の認証手順\n\n\n\n\n\nSSH接続を試みる際の認証は\n\nホスト認証\nユーザー認証\n\nの２段階に分かれます\n ▶  ホスト認証\n\n\n\n\n\nsequenceDiagram\n    participant A as ssh(client)\n    participant B as sshd(server)\n    A-&gt;&gt;B: ssh接続要求\n    B-&gt;&gt;A: ホスト認証鍵をクライアントへ渡す\n    A-&gt;&gt;B: ホスト認証鍵で暗号化した乱数をサーバーへ渡す\n    B-&gt;&gt;A: ホスト認証鍵の秘密鍵で復号化し，そのハッシュ値を送付\n    Note over A,B: ハッシュ値を比較し一致していれば接続成功&lt;br&gt;=ホスト認証完了\n\n\n\n\n\n\n ▶  秘密鍵公開鍵によるユーザー認証\nユーザー認証はホスト認証完了後に行われる処理となります.\n\n\n\n\n\nsequenceDiagram\n    participant A as ssh(client)\n    participant B as sshd(server)\n    A--&gt;&gt;B: 公開鍵をサーバーに設置\n    A-&gt;&gt;B: ssh接続要求\n    B-&gt;&gt;A: 公開鍵で暗号化した乱数をssh側に渡す\n    A-&gt;&gt;B: 秘密鍵で復号化し，そのハッシュ値を送付\n    Note over A,B: ハッシュ値を比較し一致していれば接続成功&lt;br&gt;=ユーザー認証完了\n\n\n\n\n\n\n\n\n\n\n\n\nDef: ホスト認証 \n接続先が正当な相手であるのかどうかの認証のこと\n\nsshコマンドで初めてサーバーに接続するとき，サーバーから送られてきた公開鍵のフィンガープリントの値が表示される. このフィンガープリントをクライアント側で受け入れると，~/.ssh/known_hostsに以下の情報が登録されます\n\n接続先サーバーのホスト名\n接続先サーバーのIPアドレス\n接続先サーバーの公開鍵\n\n初回接続時の際は，接続先サーバーのホスト認証鍵を持っていないので,接続先ホストが登録されていない旨のWarningが表示されます. このとき，接続をこのまま続けるか？と聞かれます. yesと選択すると，SSH接続先サーバーが~/.ssh/known_hostsに登録されます.\n% ssh hogehoge@123.456.78.9\nThe authenticity of host '123.456.78.9 (123.456.78.9)' can not be established.\nECDSA key fingerprint is SHA256:ghzvH/1TBjI0wvlYiRNDJvUsiYAX/R9eip5bw6+Rv10.\nAre you sure you want to continue connecting (yes/no/[fingerprint])?\n$ yes\nWarning: Permanently added '123.456.78.9' (ECDSA) to the list of known hosts.\nPassword:\nLast login: Thu Apr 11 04:16:45 2021\n上記におけるECDSA key fingerprintSHA256:ghzvH/1TBjI0wvlYiRNDJvUsiYAX/R9eip5bw6+Rv10，の意味はSHA256で公開鍵をハッシュ化すると ghzvH/1TBjI0wvlYiRNDJvUsiYAX/R9eip5bw6+Rv10というフィンガープリントが発行されることを指しています.\n一度接続するとクライアントの known_hosts というファイルにサーバーの公開鍵が保存されるので，初回接続以降は自動的に認証が行われるため警告が表示されなくなります.\n ▶  WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED! \n目的外のサーバーに接続している場合やサーバーの公開鍵が変わっている場合，警告が表示されます.一般的にはホストキーの変更は滅多に行わなれないため、許可済みのサーバーに接続した際、 WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED! のような警告が出た場合は注意する必要があります.\n% ssh ubuntu@12.3.4.56\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n\n\n@@\nIT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!\nSomeone could be eavesdropping on you right now (man-in-the-middle attack)!\nIt is also possible that a host key has just been changed.\nThe fingerprint for the ECDSA key sent by the remote host is\nSHA256:tfZBzQ16o7O7SH6u4ixBmL061Sxz8DOo1cFZ9oMuGjE.\nPlease contact your system administrator.\nAdd correct host key in /home/hogehoge/.ssh/known_hosts to get rid of this message.\nOffending ECDSA key in /home/hogehoge/.ssh/known_hosts:4\n  remove with:\n  ssh-keygen -f \"/home/hogehoge/.ssh/known_hosts\" -R \"12.3.4.56\"\nECDSA host key for 12.3.4.56 has changed and you have requested strict checking.\nHost key verification failed.\n\n\n\nホスト認証後に実施されるユーザー認証は，デフォルトでは，公開鍵認証，パスワード認証の順に実施されます. 公開鍵認証を行うには予めクライアントの公開鍵を接続先サーバーに登録する必要があります.\n ▶  公開鍵の置き場所\n公開鍵によるユーザー認証を行うにはクライアントが作成した秘密鍵/公開鍵キーペアのうち，後者をサーバー側にコピーする必要があります. 一般的には\n\n~/.ssh/authorized_keysファイルに登録する\n~/.ssh/authorized_keys以外のファイルに保存したい場合は，サーバー側の設定ファイルsshd_configで明示的に参照ファイルを指定する\n\n\nExample 1 : sshd_config設定 \netc/ssh/sshd_config にて AuthorizedKeysFile フィールドに\nAuthorizedKeysFile     .ssh/authorized_keys .ssh/authorized_keys2\nと設定することで .ssh/authorized_keys，.ssh/authorized_keys2 の２つを公開鍵読み込みファイルとして認識させることができます"
  },
  {
    "objectID": "posts/2024-12-18-secure-shell/index.html#sshの仕組み",
    "href": "posts/2024-12-18-secure-shell/index.html#sshの仕組み",
    "title": "Secure Shellの仕組み",
    "section": "",
    "text": "Def: Secure Shell \nSSH(Secure SHell)は，ネットワークで接続された他コンピューターを遠隔操作するためのプロトコルのこと\n\nSSHプロトコルには現在，SSH1とSSH2という２つのプロトコルがあります. それぞれのプロトコルには互換性はありません. 一般的には，SSH1プロトコルには脆弱性が発見されているのでSSH2を用います. Ubuntu Serverでは，デフォルトでSSH2のみが有効となっています.\n ▶  特徴\n\n強力な認証機能と暗号化により，ファイル転送やリモート操作を安全に行うことができる\nユーザーログイン時のユーザー認証に先立って，クライアントがサーバーの正当性を確認するホスト認証が毎回行われるため偽サーバーに接続することで発生する情報漏えいリスクを低減することができる\nクライアント側から ssh コマンドを用いてSSH接続を試みる場合は，接続先のコンピュータでsshd（SSH daemon：SSHのサーバプログラム）が 動作している必要がある\n\n\n\n\n\n\n\n\nSSH接続の認証手順\n\n\n\n\n\nSSH接続を試みる際の認証は\n\nホスト認証\nユーザー認証\n\nの２段階に分かれます\n ▶  ホスト認証\n\n\n\n\n\nsequenceDiagram\n    participant A as ssh(client)\n    participant B as sshd(server)\n    A-&gt;&gt;B: ssh接続要求\n    B-&gt;&gt;A: ホスト認証鍵をクライアントへ渡す\n    A-&gt;&gt;B: ホスト認証鍵で暗号化した乱数をサーバーへ渡す\n    B-&gt;&gt;A: ホスト認証鍵の秘密鍵で復号化し，そのハッシュ値を送付\n    Note over A,B: ハッシュ値を比較し一致していれば接続成功&lt;br&gt;=ホスト認証完了\n\n\n\n\n\n\n ▶  秘密鍵公開鍵によるユーザー認証\nユーザー認証はホスト認証完了後に行われる処理となります.\n\n\n\n\n\nsequenceDiagram\n    participant A as ssh(client)\n    participant B as sshd(server)\n    A--&gt;&gt;B: 公開鍵をサーバーに設置\n    A-&gt;&gt;B: ssh接続要求\n    B-&gt;&gt;A: 公開鍵で暗号化した乱数をssh側に渡す\n    A-&gt;&gt;B: 秘密鍵で復号化し，そのハッシュ値を送付\n    Note over A,B: ハッシュ値を比較し一致していれば接続成功&lt;br&gt;=ユーザー認証完了\n\n\n\n\n\n\n\n\n\n\n\n\nDef: ホスト認証 \n接続先が正当な相手であるのかどうかの認証のこと\n\nsshコマンドで初めてサーバーに接続するとき，サーバーから送られてきた公開鍵のフィンガープリントの値が表示される. このフィンガープリントをクライアント側で受け入れると，~/.ssh/known_hostsに以下の情報が登録されます\n\n接続先サーバーのホスト名\n接続先サーバーのIPアドレス\n接続先サーバーの公開鍵\n\n初回接続時の際は，接続先サーバーのホスト認証鍵を持っていないので,接続先ホストが登録されていない旨のWarningが表示されます. このとき，接続をこのまま続けるか？と聞かれます. yesと選択すると，SSH接続先サーバーが~/.ssh/known_hostsに登録されます.\n% ssh hogehoge@123.456.78.9\nThe authenticity of host '123.456.78.9 (123.456.78.9)' can not be established.\nECDSA key fingerprint is SHA256:ghzvH/1TBjI0wvlYiRNDJvUsiYAX/R9eip5bw6+Rv10.\nAre you sure you want to continue connecting (yes/no/[fingerprint])?\n$ yes\nWarning: Permanently added '123.456.78.9' (ECDSA) to the list of known hosts.\nPassword:\nLast login: Thu Apr 11 04:16:45 2021\n上記におけるECDSA key fingerprintSHA256:ghzvH/1TBjI0wvlYiRNDJvUsiYAX/R9eip5bw6+Rv10，の意味はSHA256で公開鍵をハッシュ化すると ghzvH/1TBjI0wvlYiRNDJvUsiYAX/R9eip5bw6+Rv10というフィンガープリントが発行されることを指しています.\n一度接続するとクライアントの known_hosts というファイルにサーバーの公開鍵が保存されるので，初回接続以降は自動的に認証が行われるため警告が表示されなくなります.\n ▶  WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED! \n目的外のサーバーに接続している場合やサーバーの公開鍵が変わっている場合，警告が表示されます.一般的にはホストキーの変更は滅多に行わなれないため、許可済みのサーバーに接続した際、 WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED! のような警告が出た場合は注意する必要があります.\n% ssh ubuntu@12.3.4.56\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n\n\n@@\nIT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!\nSomeone could be eavesdropping on you right now (man-in-the-middle attack)!\nIt is also possible that a host key has just been changed.\nThe fingerprint for the ECDSA key sent by the remote host is\nSHA256:tfZBzQ16o7O7SH6u4ixBmL061Sxz8DOo1cFZ9oMuGjE.\nPlease contact your system administrator.\nAdd correct host key in /home/hogehoge/.ssh/known_hosts to get rid of this message.\nOffending ECDSA key in /home/hogehoge/.ssh/known_hosts:4\n  remove with:\n  ssh-keygen -f \"/home/hogehoge/.ssh/known_hosts\" -R \"12.3.4.56\"\nECDSA host key for 12.3.4.56 has changed and you have requested strict checking.\nHost key verification failed.\n\n\n\nホスト認証後に実施されるユーザー認証は，デフォルトでは，公開鍵認証，パスワード認証の順に実施されます. 公開鍵認証を行うには予めクライアントの公開鍵を接続先サーバーに登録する必要があります.\n ▶  公開鍵の置き場所\n公開鍵によるユーザー認証を行うにはクライアントが作成した秘密鍵/公開鍵キーペアのうち，後者をサーバー側にコピーする必要があります. 一般的には\n\n~/.ssh/authorized_keysファイルに登録する\n~/.ssh/authorized_keys以外のファイルに保存したい場合は，サーバー側の設定ファイルsshd_configで明示的に参照ファイルを指定する\n\n\nExample 1 : sshd_config設定 \netc/ssh/sshd_config にて AuthorizedKeysFile フィールドに\nAuthorizedKeysFile     .ssh/authorized_keys .ssh/authorized_keys2\nと設定することで .ssh/authorized_keys，.ssh/authorized_keys2 の２つを公開鍵読み込みファイルとして認識させることができます"
  },
  {
    "objectID": "posts/2024-12-18-secure-shell/index.html#ssh-コマンドの実践",
    "href": "posts/2024-12-18-secure-shell/index.html#ssh-コマンドの実践",
    "title": "Secure Shellの仕組み",
    "section": "ssh コマンドの実践",
    "text": "ssh コマンドの実践\n\nsshコマンド\nSSHを使ってサーバーに接続するには，以下のようにsshコマンドを使います. 終了する場合は，exit，または Ctrl + Dを入力します.\n% ssh [option] &lt;username&gt;@&lt;hostname&gt;\n\n\n\n\n\n\n\nOption\n説明\n\n\n\n\n-p ポート番号\n接続に使用するポート番号を指定する\n\n\n-l ユーザー名\n接続に使用するユーザー名を指定する\n\n\n-i IDファイル\n接続に使用する公開鍵ファイルを指定する\n\n\n-f\nコマンドを実行する際にsshをバックグラウンドにする（Xアプリケーションを実行する際に使用）\n\n\n-F 設定ファイル\n設定ファイルを指定する\n\n\n\n ▶  接続先情報の設定ファイル: ~/.ssh/config\nsshコマンド実行時のオプションを~/.ssh/configで登録することができます.\nHost DEDEDE\n  HostName 100.21.209.82\n  User kirby_MBP\n  Port 1000\n  IdentityFile ~/.ssh/my_id_rsa\n  LocalForward 9999 localhost:9999\nと設定すると以下のコマンドは同じ挙動になります\n% ssh DEDEDE\n% ssh kirby_MBP@100.21.209.82 -p 1000 -i ~/.ssh/my_id_rsa -L 9999:localhost:9999\n\n\nssh-keygenコマンドによる認証鍵生成\n% ssh-keygen [option]\n\n\n\n\n\n\n\nOption\n説明\n\n\n\n\n-t タイプ\n暗号化タイプの指定\n\n\n-l\n鍵のフィンガープリントを表示する\n\n\n-f ファイル名\n鍵ファイルを指定する（生成または読み出すファイルを指定）\n\n\n-R ホスト名\n指定したホスト情報をknwon_hostsファイルから削除する\n\n\n-C コメント\nコメントを指定する（デフォルトは「ユーザー名@ホスト名」。「-C ““」でコメントを削除）\n\n\n\n ▶  暗号化アルゴリズムの種類\n\n\n\n\n\n\n\nSSH version\nssh-keygenコマンド\n\n\n\n\nSSH1 RSA\nssh-keygen -t rsa1\n\n\nSSH2 DSA\nssh-keygen -t dsa\n\n\nSSH2 RSA\nssh-keygen -t rsa\n\n\nSSH2 ECDSA\nssh-keygen -t ecdsa\n\n\nSSH2 ED25519\nssh-keygen -t ed25519\n\n\n\n\n\n\n\n\n\n🍵 ED25519のススメ\n\n\n\nGitHubやGitLabのドキュメントを確認すると，ED25519の使用が推奨されています.\nGitLabより引用すると\n\nThe book Practical Cryptography With Go suggests that ED25519 keys are more secure and performant than RSA keys. OpenSSH 6.5 introduced ED25519 SSH keys in 2014，and they should be available on most operating systems.\n\nED25519は以下のような特徴があります\n\n楕円曲線を用いた暗号\nRSAやDSAの鍵長の約半分以下で同等のセキュリティ強度が得られる\n鍵長が短いので，暗号化/復号化の計算を高速に行える\n\n従って，以下のコマンドで鍵を生成するようにしてください.\n% ssh-keygen -t e\n\n\n ▶  鍵の生成\nssh-keygenコマンドを使うと\n\n鍵ファイル名の指定（そのままEnterを入力するとデフォルトのファイル名となる）\nパスフレーズの入力（特別な理由がない限り設定する）\n\nが求められます. 特段の事情がない限り個人的には設定する方針としています. なお生成される公開鍵には，デフォルトではユーザ名とホスト名がコメントとして記載されています(以下の例ではhoge@foofoo)\n% ssh-keygen -t ed25519                                           \nGenerating public/private ed25519 key pair.\nEnter file in which to save the key (/home/hogehoge/.ssh/id_ed25519): hogehoge_ed25519\nEnter passphrase (empty for no passphrase): \nEnter same passphrase again: \nYour identification has been saved in hogehoge_ed25519\nYour public key has been saved in hogehoge_ed25519.pub\nThe key fingerprint is:\nSHA256:MnM1r0IqwugnLCTEnSHjuPoTk7mdmSMExw+r5cOkrwQ hoge@foofoo\nThe key's randomart image is:\n+--[ED25519 256]--+\n|@+%.  o  o       |\n|.o.Eo *  + S     |\n|. o..oo +        |\n|@+%.  o  o       |\n| .oo=.= S =      |\n|   ..B o + +     |\n|    = * . o .    |\n| o++o            |\n|+B==.. ....      |\n+----[SHA256]-----+\n秘密鍵の作成後，誤って内容が書き換わってしまうリスクを抑えるため，Permissionを400に設定しときます:\n% sudo chmod 400 id_ed25519\n\n\nssh-copy-idコマンド: 接続先ホストへの公開鍵登録\n鍵ペア作成後，公開鍵を接続先ホストへ登録する必要あります. この時使われるコマンドが ssh-copy-idコマンドです. なお，初回登録時点では接続先ホストではパスワード認証によるログインが許可されている必要があります.\n\nExample 2 : ssh-copy-idコマンド \n以下のコマンドで接続先サーバーの.ssh/authorized_keysに公開鍵を追記することができます\n% ssh-copy-id [-p ポート番号] -i 公開鍵ファイル名 USERNAME@$HOST\n\n# 以下のコマンドと同義\n# cat 公開鍵ファイル名 \\\n#  | ssh -p ポート番号 USERNAME@$HOST \\\n#  \"mkdir -p ~/.ssh; cat &gt;&gt; ~/.ssh/authorized_keys\"\n\n.ssh/authorized_keysファイルが存在しなくても，自動的に作成してくれます\nこのコマンド実施時には接続先ホストのパスワード入力が求められます.\n登録後はOpenSSHサーバーの設定を変更し，パスワード認証を無効にすることが推奨されます.\n\n\n\n\n\nsshpass コマンド\n\nsshpass(noninteractive ssh password provider)とは，sshコマンドでSSH接続を試みる際に要求されるログインパスワードを 事前に指定した方法でコマンドプロンプトへ渡し，簡単にSSH接続を実現するCLI機能のこと\nsshpass -p &lt;password&gt; ssh &lt;usename@&gt;接続先ホスト という形で実行するとシステムユーザーによるpsコマンドで パスワードがバレてしまうというリスクがあるので，便利さの一方，セキュリティリスクがある点について留意が必要\n\n ▶  インストール方法\n% sudo apt install sshpass ## Ubuntu\nMacだと以下のようなメッセージで怒られます.\n#Error: No available formula or cask with the name \"sshpass\".\n#We won't add sshpass because it makes it too easy for novice SSH users to\n#ruin SSH's security.\nそれでもインストールしたい場合は，ソースから直接以下のような方法でインストールします:\n% wget http://sourceforge.net/projects/sshpass/files/latest/download -O sshpass.tar.gz\n% tar -xvf sshpass.tar.gz\n% cd sshpass-1.08\n% ./configure\n% sudo make install \n% which sshpass ##pathが通っているか確認\n ▶  sshpassコマンドの利用方法\nヘルプコマンドで利用方法を確認してみます:\n% sshpass -h\nUsage: sshpass [-f|-d|-p|-e] [-hV] command parameters\n   -f filename   Take password to use from file\n   -d number     Use number as file descriptor for getting password\n   -p password   Provide password as argument (security unwise)\n   -e            Password is passed as env-var \"SSHPASS\"\n   With no parameters - password will be taken from stdin\n\n   -P prompt     Which string should sshpass search for to detect a password prompt\n   -v            Be verbose about what you're doing\n   -h            Show help (this screen)\n   -V            Print version information\nAt most one of -f，-d，-p or -e should be used\n% sshpass -p '&lt;passphrase&gt;' ssh username@host \nという形で利用することもできますが，psコマンドでpassphraseがダダ漏れになってしまうので\n% sshpass -f &lt;configfilepath&gt; ssh username@host\nまたは，-eオプションを指定することで環境変数SSHPASSを参照することができるので\n% export SSHPASS='my_pass_here'\n% echo $SSHPASS\n% sshpass -e ssh username@host \n\n\nscp コマンド: ホストとクライアント間のファイル転送\n% scp [オプション] コピー元 コピー先 \nコピー元，コピー先はそれぞれのPATHを入力しますがリモート側/ローカル側の書式例は以下です:\n\nリモートサーバー側: username@hostname：PATH\nローカルクライアント側:PATH\n\n\n\n\n\n\n\n\nOption\n説明\n\n\n\n\n-i 秘密鍵ファイル\nRSAまたはDSA認証の秘密鍵ファイルを指定する\n\n\n-P ポート番号\nポート番号を指定する\n\n\n-p\nコピー元ファイルとディレクトリの更新時間、アクセス時間、パーミッションを保持したまま転送する場合\n\n\n-r\nディレクトリ内を再帰的にコピーする\n\n\n\n ▶  ローカルからリモートホストにファイル/ディレクトリをコピー\n## ファイルのコピー\n% scp ~/tmp/file1 user@192.168.10.1:/home/user/tmp/ \n\n## ディレクトリのコピー\n% scp -r ~/tmp user1@192.168.10.1:/home/user/tmp\n\n## sshpassとの組合せ\n% sshpass -f passwordFile scp ~/tmp/file1 user@192.168.10.1:/home/user/tmp/ \n ▶  リモートホストからローカルにファイル/ディレクトリをコピー\n## ファイルのコピー\n% scp user@192.168.10.1:/home/user/file1 ~/tmp\n \n## ディレクトリのコピー\n% scp -r user@192.168.10.1:/home/user/tmp ~/tmp\n \n## 複数のファイルを、{}で囲んで「,」で区切り指定しコピーする例\n% scp user@192.168.10.1:/home/user/{file1,file2,file3} ~/tmp\n ▶  リモートホストから別のリモートホストにファイル/ディレクトリをコピー\n% scp user1@192.168.10.1:/home/user/tmp/file1 user2@192.168.10.2:/home/user/tmp/"
  },
  {
    "objectID": "posts/2025-03-05-addition-theorem/index.html",
    "href": "posts/2025-03-05-addition-theorem/index.html",
    "title": "三角関数の加法定理",
    "section": "",
    "text": "Theorem 1 : 加法定理 \n\\[\n\\begin{align}\n\\sin (\\alpha + \\beta) &= \\sin \\alpha \\cos \\beta + \\cos \\alpha \\sin \\beta\\\\\n\\cos (\\alpha + \\beta) &= \\cos \\alpha \\cos \\beta - \\sin \\alpha \\sin \\beta\n\\end{align}\n\\]\n\n\n「咲いたコスモス，コスモス咲いた」なり「しこってこすってこすってしこって」と語呂合わせで加法定理を覚えたりしますが，ここでは加法定理を図形的に考えてみたいと思います．\n\n\n\n\n\n\nFigure 1\n\n\n\nFigure 1 のように半径 \\(1\\) の単位円周上に \\(\\angle DOB = \\alpha + \\beta\\) となる点 \\(B\\) をとります． 同じく \\(\\angle AOD = \\alpha\\) となるように点をとると，\\(\\angle BOA = \\beta\\) となります．このとき，点 \\(B\\) の \\(y\\) 成分は \\(\\sin(\\alpha + \\beta)\\) となります．\n点 \\(B\\) から直線 \\(OA\\) 上に垂線を下ろし，その交点を \\(C\\) とすると \\(OB = 1\\) より\n\\[\n\\begin{align}\nBC & = \\sin\\beta\\\\\nOC &= \\cos\\beta\n\\end{align}\n\\]\nとなることがわかります．点 \\(C\\) から垂線を下ろし，\\(x\\) 軸との交点を \\(E\\), \\(B\\) から直線 \\(CE\\) との交点を \\(F\\) とすると\n\\[\n\\begin{align}\nCE &= \\sin \\alpha\\cos\\beta\\\\\nCF &= \\cos\\alpha\\sin\\beta\n\\end{align}\n\\]\nしたがって，\\(CE + CF = \\sin(\\alpha + \\beta)\\) となることから\n\\[\n\\sin (\\alpha + \\beta) = \\sin \\alpha \\cos \\beta + \\cos \\alpha \\sin \\beta\n\\]\nとなることが図形的にわかります．同様に\n\\[\n\\begin{align}\nOE &= \\cos\\alpha\\cos\\beta\\\\\nBF&= \\sin\\alpha\\sin\\beta\n\\end{align}\n\\]\nより\n\\[\n\\cos(\\alpha + \\beta) = OE - BF = \\cos\\alpha\\cos\\beta - \\sin\\alpha\\sin\\beta\n\\]\n ▶  ２角の差 \\(\\alpha - \\beta\\) の場合\n\\(\\sin(-\\beta) = -\\sin(\\beta)\\) および \\(\\cos(-\\beta) = \\cos\\beta\\) より\n\\[\n\\begin{align}\n\\sin (\\alpha - \\beta)\n    &= \\sin (\\alpha  + (-\\beta))\\\\\n    &= \\sin \\alpha \\cos (-\\beta) + \\cos \\alpha \\sin (-\\beta)\\\\\n    &= \\sin \\alpha \\cos \\beta - \\cos \\alpha \\sin \\beta\n\\end{align}\n\\]\n同様に\n\\[\n\\begin{align}\n\\cos (\\alpha - \\beta)\n    &= \\cos (\\alpha  + (-\\beta))\\\\\n    &= \\cos \\alpha \\cos (-\\beta) - \\sin \\alpha \\sin (-\\beta)\\\\\n    &= \\cos \\alpha \\cos \\beta + \\sin \\alpha \\sin \\beta\n\\end{align}\n\\]\n以上より\n\\[\n\\begin{align}\n\\sin (\\alpha \\pm \\beta) &= \\sin \\alpha \\cos \\beta \\pm \\cos \\alpha \\sin \\beta\\\\\n\\cos (\\alpha \\pm \\beta) &= \\cos \\alpha \\cos \\beta \\mp \\sin \\alpha \\sin \\beta\n\\end{align}\n\\]\n\n📘 REMARKS \n\\(\\sin \\theta\\) は奇関数，\\(\\cos \\theta\\) は偶関数であることに留意すると\n\\[\n\\begin{align}\n\\text{奇関数} \\times \\text{偶関数} &= \\text{奇関数}\\\\\n\\text{偶関数} \\times \\text{偶関数} &= \\text{偶関数}\\\\\n\\text{偶関数} + \\text{偶関数} &= \\text{偶関数}\\\\\n\\text{奇関数} + \\text{奇関数} &= \\text{奇関数}\n\\end{align}\n\\]\nであるので，加法定理のRHSとLHSがそれぞれ対応していることがわかります．\n\n\n\n\n\nTheorem 2 : オイラーの公式 \n\\[\n\\exp(i\\theta) = \\cos\\theta + i\\sin\\theta\n\\]\n\n\n\n\n\n\n\n\n\nオイラーの公式を用いた加法定理の導出\n\n\n\n\n\n\\[\n\\begin{align}\n\\exp(i(\\alpha + \\beta))\n    &= \\exp(i\\alpha)\\exp(i\\beta)\\\\\n    &= (\\cos\\alpha + i\\sin\\alpha)(\\cos\\beta + i\\sin\\beta)\\\\\n    &= \\cos\\alpha\\cos\\beta - \\sin\\alpha\\sin\\beta + i(\\sin\\alpha\\cos\\beta + \\cos\\alpha\\sin\\beta)\n\\end{align}\n\\]\n\\(\\exp(i(\\alpha + \\beta)) = \\cos(\\alpha + \\beta) + i\\sin(\\alpha + \\beta)\\) であることから実部と虚部の比較より\n\\[\n\\begin{align}\n\\sin (\\alpha + \\beta) &= \\sin \\alpha \\cos \\beta + \\cos \\alpha \\sin \\beta\\\\\n\\cos (\\alpha + \\beta) &= \\cos \\alpha \\cos \\beta - \\sin \\alpha \\sin \\beta\n\\end{align}\n\\]\n二角の差の場合は\n\\[\n\\exp(i(\\alpha - \\beta))= \\exp(i\\alpha)\\exp(-i\\beta)\n\\]\nから同様に示すことが出来ます．\n\n\n\n\n\n\n\n\n\n\n\n\n\nProof\n\n\n\n\n\n正弦と余弦の加法定理より\n\\[\n\\begin{align}\n\\tan(\\alpha \\pm \\beta)\n    &= \\frac{\\sin(\\alpha \\pm \\beta)}{\\cos(\\alpha \\pm \\beta)}\\\\\n    &= \\frac{\\sin \\alpha \\cos \\beta \\pm \\cos \\alpha \\sin \\beta}{\\cos \\alpha \\cos \\beta \\mp \\sin \\alpha \\sin \\beta}\n\\end{align}\n\\]\n分子と分母を \\(\\cos \\alpha \\cos \\beta\\) で割ると\n\\[\n\\begin{align}\n\\tan(\\alpha \\pm \\beta) = \\frac{\\tan \\alpha \\pm \\tan \\beta}{1 \\mp \\tan \\alpha \\tan \\beta}\n\\end{align}\n\\]\n\n\n\n\n\nExercise 1 \n\\(\\tan 1^\\circ\\) が無理数であることを示せ\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\\(\\tan 1^\\circ\\) がとある有理数 \\(a\\) であると仮定すると，加法定理より\n\\[\n\\tan 2^\\circ = \\frac{2a}{1 - a^2}\n\\]\nとなり，有理数の四則演算は有理数で閉じていることから \\(\\tan 2^\\circ\\) も有理数であることがわかる．同様に \\(4^\\circ, 8^\\circ, 16^\\circ, 32^\\circ\\) も有理数であることがわかる．\nここで，\n\\[\n\\tan 30^\\circ = \\frac{\\sqrt{3}}{3}\n\\]\nより \\(\\tan 30^\\circ\\) は無理数であることに着目する．一方，\\(\\tan 30^\\circ\\) は加法定理より\n\\[\n\\begin{align}\n\\tan 30^\\circ\n    &= \\tan (32^\\circ - 2^\\circ)\\\\\n    &= \\frac{\\tan 32^\\circ + \\tan 2^\\circ}{1 + \\tan 32^\\circ\\tan 2^\\circ}\n\\end{align}\n\\]\nこのとき，\\(\\tan 32^\\circ, \\tan 2^\\circ\\) はともに有理数であるので， \\(\\tan 30^\\circ\\) は無理数であることと矛盾． したがって，\\(\\tan 1^\\circ\\) は無理数である．"
  },
  {
    "objectID": "posts/2025-03-05-addition-theorem/index.html#加法定理",
    "href": "posts/2025-03-05-addition-theorem/index.html#加法定理",
    "title": "三角関数の加法定理",
    "section": "",
    "text": "Theorem 1 : 加法定理 \n\\[\n\\begin{align}\n\\sin (\\alpha + \\beta) &= \\sin \\alpha \\cos \\beta + \\cos \\alpha \\sin \\beta\\\\\n\\cos (\\alpha + \\beta) &= \\cos \\alpha \\cos \\beta - \\sin \\alpha \\sin \\beta\n\\end{align}\n\\]\n\n\n「咲いたコスモス，コスモス咲いた」なり「しこってこすってこすってしこって」と語呂合わせで加法定理を覚えたりしますが，ここでは加法定理を図形的に考えてみたいと思います．\n\n\n\n\n\n\nFigure 1\n\n\n\nFigure 1 のように半径 \\(1\\) の単位円周上に \\(\\angle DOB = \\alpha + \\beta\\) となる点 \\(B\\) をとります． 同じく \\(\\angle AOD = \\alpha\\) となるように点をとると，\\(\\angle BOA = \\beta\\) となります．このとき，点 \\(B\\) の \\(y\\) 成分は \\(\\sin(\\alpha + \\beta)\\) となります．\n点 \\(B\\) から直線 \\(OA\\) 上に垂線を下ろし，その交点を \\(C\\) とすると \\(OB = 1\\) より\n\\[\n\\begin{align}\nBC & = \\sin\\beta\\\\\nOC &= \\cos\\beta\n\\end{align}\n\\]\nとなることがわかります．点 \\(C\\) から垂線を下ろし，\\(x\\) 軸との交点を \\(E\\), \\(B\\) から直線 \\(CE\\) との交点を \\(F\\) とすると\n\\[\n\\begin{align}\nCE &= \\sin \\alpha\\cos\\beta\\\\\nCF &= \\cos\\alpha\\sin\\beta\n\\end{align}\n\\]\nしたがって，\\(CE + CF = \\sin(\\alpha + \\beta)\\) となることから\n\\[\n\\sin (\\alpha + \\beta) = \\sin \\alpha \\cos \\beta + \\cos \\alpha \\sin \\beta\n\\]\nとなることが図形的にわかります．同様に\n\\[\n\\begin{align}\nOE &= \\cos\\alpha\\cos\\beta\\\\\nBF&= \\sin\\alpha\\sin\\beta\n\\end{align}\n\\]\nより\n\\[\n\\cos(\\alpha + \\beta) = OE - BF = \\cos\\alpha\\cos\\beta - \\sin\\alpha\\sin\\beta\n\\]\n ▶  ２角の差 \\(\\alpha - \\beta\\) の場合\n\\(\\sin(-\\beta) = -\\sin(\\beta)\\) および \\(\\cos(-\\beta) = \\cos\\beta\\) より\n\\[\n\\begin{align}\n\\sin (\\alpha - \\beta)\n    &= \\sin (\\alpha  + (-\\beta))\\\\\n    &= \\sin \\alpha \\cos (-\\beta) + \\cos \\alpha \\sin (-\\beta)\\\\\n    &= \\sin \\alpha \\cos \\beta - \\cos \\alpha \\sin \\beta\n\\end{align}\n\\]\n同様に\n\\[\n\\begin{align}\n\\cos (\\alpha - \\beta)\n    &= \\cos (\\alpha  + (-\\beta))\\\\\n    &= \\cos \\alpha \\cos (-\\beta) - \\sin \\alpha \\sin (-\\beta)\\\\\n    &= \\cos \\alpha \\cos \\beta + \\sin \\alpha \\sin \\beta\n\\end{align}\n\\]\n以上より\n\\[\n\\begin{align}\n\\sin (\\alpha \\pm \\beta) &= \\sin \\alpha \\cos \\beta \\pm \\cos \\alpha \\sin \\beta\\\\\n\\cos (\\alpha \\pm \\beta) &= \\cos \\alpha \\cos \\beta \\mp \\sin \\alpha \\sin \\beta\n\\end{align}\n\\]\n\n📘 REMARKS \n\\(\\sin \\theta\\) は奇関数，\\(\\cos \\theta\\) は偶関数であることに留意すると\n\\[\n\\begin{align}\n\\text{奇関数} \\times \\text{偶関数} &= \\text{奇関数}\\\\\n\\text{偶関数} \\times \\text{偶関数} &= \\text{偶関数}\\\\\n\\text{偶関数} + \\text{偶関数} &= \\text{偶関数}\\\\\n\\text{奇関数} + \\text{奇関数} &= \\text{奇関数}\n\\end{align}\n\\]\nであるので，加法定理のRHSとLHSがそれぞれ対応していることがわかります．\n\n\n\n\n\nTheorem 2 : オイラーの公式 \n\\[\n\\exp(i\\theta) = \\cos\\theta + i\\sin\\theta\n\\]\n\n\n\n\n\n\n\n\n\nオイラーの公式を用いた加法定理の導出\n\n\n\n\n\n\\[\n\\begin{align}\n\\exp(i(\\alpha + \\beta))\n    &= \\exp(i\\alpha)\\exp(i\\beta)\\\\\n    &= (\\cos\\alpha + i\\sin\\alpha)(\\cos\\beta + i\\sin\\beta)\\\\\n    &= \\cos\\alpha\\cos\\beta - \\sin\\alpha\\sin\\beta + i(\\sin\\alpha\\cos\\beta + \\cos\\alpha\\sin\\beta)\n\\end{align}\n\\]\n\\(\\exp(i(\\alpha + \\beta)) = \\cos(\\alpha + \\beta) + i\\sin(\\alpha + \\beta)\\) であることから実部と虚部の比較より\n\\[\n\\begin{align}\n\\sin (\\alpha + \\beta) &= \\sin \\alpha \\cos \\beta + \\cos \\alpha \\sin \\beta\\\\\n\\cos (\\alpha + \\beta) &= \\cos \\alpha \\cos \\beta - \\sin \\alpha \\sin \\beta\n\\end{align}\n\\]\n二角の差の場合は\n\\[\n\\exp(i(\\alpha - \\beta))= \\exp(i\\alpha)\\exp(-i\\beta)\n\\]\nから同様に示すことが出来ます．\n\n\n\n\n\n\n\n\n\n\n\n\n\nProof\n\n\n\n\n\n正弦と余弦の加法定理より\n\\[\n\\begin{align}\n\\tan(\\alpha \\pm \\beta)\n    &= \\frac{\\sin(\\alpha \\pm \\beta)}{\\cos(\\alpha \\pm \\beta)}\\\\\n    &= \\frac{\\sin \\alpha \\cos \\beta \\pm \\cos \\alpha \\sin \\beta}{\\cos \\alpha \\cos \\beta \\mp \\sin \\alpha \\sin \\beta}\n\\end{align}\n\\]\n分子と分母を \\(\\cos \\alpha \\cos \\beta\\) で割ると\n\\[\n\\begin{align}\n\\tan(\\alpha \\pm \\beta) = \\frac{\\tan \\alpha \\pm \\tan \\beta}{1 \\mp \\tan \\alpha \\tan \\beta}\n\\end{align}\n\\]\n\n\n\n\n\nExercise 1 \n\\(\\tan 1^\\circ\\) が無理数であることを示せ\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\\(\\tan 1^\\circ\\) がとある有理数 \\(a\\) であると仮定すると，加法定理より\n\\[\n\\tan 2^\\circ = \\frac{2a}{1 - a^2}\n\\]\nとなり，有理数の四則演算は有理数で閉じていることから \\(\\tan 2^\\circ\\) も有理数であることがわかる．同様に \\(4^\\circ, 8^\\circ, 16^\\circ, 32^\\circ\\) も有理数であることがわかる．\nここで，\n\\[\n\\tan 30^\\circ = \\frac{\\sqrt{3}}{3}\n\\]\nより \\(\\tan 30^\\circ\\) は無理数であることに着目する．一方，\\(\\tan 30^\\circ\\) は加法定理より\n\\[\n\\begin{align}\n\\tan 30^\\circ\n    &= \\tan (32^\\circ - 2^\\circ)\\\\\n    &= \\frac{\\tan 32^\\circ + \\tan 2^\\circ}{1 + \\tan 32^\\circ\\tan 2^\\circ}\n\\end{align}\n\\]\nこのとき，\\(\\tan 32^\\circ, \\tan 2^\\circ\\) はともに有理数であるので， \\(\\tan 30^\\circ\\) は無理数であることと矛盾． したがって，\\(\\tan 1^\\circ\\) は無理数である．"
  },
  {
    "objectID": "posts/2025-03-05-addition-theorem/index.html#倍角の公式とサインカーブ",
    "href": "posts/2025-03-05-addition-theorem/index.html#倍角の公式とサインカーブ",
    "title": "三角関数の加法定理",
    "section": "倍角の公式とサインカーブ",
    "text": "倍角の公式とサインカーブ\n\n\nTheorem 3 : 倍角の公式 \n\\[\n\\begin{align}\n\\sin 2\\theta &= 2\\sin\\theta\\cos\\theta\\\\\n\\cos 2\\theta &= \\cos^2\\theta - \\sin^2\\theta\\\\\n             &= 1 - 2\\sin^2\\theta = 2\\cos^2\\theta - 1\\\\\n\\tan 2\\theta &= \\frac{2\\tan\\theta}{1 - \\tan^2\\theta}\n\\end{align}\n\\]\n\n\n\\(y = \\sin x\\) は振幅 \\(1\\) で周期 \\(2\\pi\\) の周期関数ですが，\n\\[\ny = \\alpha\\sin \\beta x \\quad \\alpha &gt; 0, \\beta &gt; 0\n\\]\nと変形すると，振幅 \\(\\alpha\\) で周期 \\(\\displaystyle \\frac{2\\pi}{\\beta}\\) の周期関数となります．\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport matplotlib.ticker as ticker\n\n# Define the x values\nx = np.linspace(-2 * np.pi, 2 * np.pi, 400)\n\n# Define the y values for both functions\ny1 = np.sin(x)\ny2 = np.sin(x / 2)\ny3 = 3 * np.sin(2 * x)\n\n# Create the plot\nplt.figure(figsize=(10, 6))\nplt.plot(x, y1, label=r\"$y = \\sin(x)$\", color=\"b\")\nplt.plot(x, y2, label=r\"$y = \\sin(x/2)$\", color=\"r\", linestyle=\"--\")\nplt.plot(x, y3, label=r\"$y = 3\\sin(2x)$\", color=\"gray\", linestyle=\"--\")\n\n# Add labels, title, and legend\nplt.xlabel(\"x\")\nplt.ylabel(\"y\")\nplt.title(\"Comparison of $y = \\sin(x)$ and $y = \\sin(x/2)$, $y = 3\\sin(2x)$\")\nplt.axhline(0, color=\"black\", linewidth=0.5)\nplt.axvline(0, color=\"black\", linewidth=0.5)\nplt.legend()\nplt.grid(True)\n\n# Set x-ticks to multiples of pi\nxticks = np.arange(-2 * np.pi, 2.5 * np.pi, np.pi / 2)\nxtick_labels = [\n    r\"$-2\\pi$\",\n    r\"$-\\frac{3\\pi}{2}$\",\n    r\"$-\\pi$\",\n    r\"$-\\frac{\\pi}{2}$\",\n    \"0\",\n    r\"$\\frac{\\pi}{2}$\",\n    r\"$\\pi$\",\n    r\"$\\frac{3\\pi}{2}$\",\n    r\"$2\\pi$\",\n]\nplt.xticks(xticks, xtick_labels)\n\n# Show the plot\nplt.show()\n\n\n\n\n\n\n\n\n\n次に，\\(y = \\sin x \\cos x\\) のグラフを考えてみます．加法定理より\n\\[\n\\begin{align}\n\\sin 2x\n    &= \\sin (x + x)\\\\\n    &= 2\\sin x\\cos x\n\\end{align}\n\\]\nであることから\n\\[\n\\sin x \\cos x = \\frac{1}{2}\\sin 2x\n\\]\nつまり，\\(y = \\sin x \\cos x\\) のグラフは振幅 \\(\\displaystyle \\frac{1}{2}\\)，周期 \\(\\pi\\) のサインカーブとなることがわかります．\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport matplotlib.ticker as ticker\n\n# Define the x values\nx = np.linspace(-2 * np.pi, 2 * np.pi, 400)\n\n# Define the y values for both functions\ny1 = np.sin(x) * np.cos(x)\ny2 = np.sin(2 * x) /2\n\n# Create the plot\nplt.figure(figsize=(10, 6))\nplt.plot(x, y1, label=r\"$y = \\sin(x)$\", color=\"b\")\nplt.plot(x, y2, label=r\"$y = \\frac{1}{2}\\sin(2x)$\", color=\"gray\", linestyle=\"--\")\n\n# Add labels, title, and legend\nplt.xlabel(\"x\")\nplt.ylabel(\"y\")\nplt.axhline(0, color=\"black\", linewidth=0.5)\nplt.axvline(0, color=\"black\", linewidth=0.5)\nplt.legend()\nplt.grid(True)\n\n# Set x-ticks to multiples of pi\nxticks = np.arange(-2 * np.pi, 2.5 * np.pi, np.pi / 2)\nxtick_labels = [\n    r\"$-2\\pi$\",\n    r\"$-\\frac{3\\pi}{2}$\",\n    r\"$-\\pi$\",\n    r\"$-\\frac{\\pi}{2}$\",\n    \"0\",\n    r\"$\\frac{\\pi}{2}$\",\n    r\"$\\pi$\",\n    r\"$\\frac{3\\pi}{2}$\",\n    r\"$2\\pi$\",\n]\nplt.xticks(xticks, xtick_labels)\n\n# Show the plot\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\nTheorem 4 : 半角の公式 \n\\[\n\\begin{align}\n\\sin^2 \\frac{\\theta}{2} &= \\frac{1 - \\cos\\theta}{2}\\\\\n\\cos^2 \\frac{\\theta}{2} &= \\frac{1 + \\cos\\theta}{2}\\\\\n\\tan^2 \\frac{\\theta}{2} &= \\frac{1 - \\cos\\theta}{1 + \\cos\\theta}\n\\end{align}\n\\]\n\n\n\nExample 1 \n\\(y = \\sin^2 x\\) について考えてみます．正弦関数は奇関数であるので，\\(\\sin^2 x\\) は偶関数になるはずです．半角の公式を用いると\n\\[\n\\sin^2 x = \\frac{1 - \\cos 2x}{2}\n\\]\nとなるので，振幅 \\(\\displaystyle\\frac{1}{2}\\), 周期 \\(\\pi\\) のコサインカーブを \\(\\displaystyle\\frac{1}{2}\\) 平行移動したものであることがわかります．\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport matplotlib.ticker as ticker\n\n# Define the x values\nx = np.linspace(-2 * np.pi, 2 * np.pi, 400)\n\n# Define the y values for both functions\ny1 = (1 - np.cos(2 * x))/2\ny2 = np.cos(2 * x)\n\n# Create the plot\nplt.figure(figsize=(8, 6))\nplt.plot(x, y1, label=r\"$y = \\sin^2(x)$\", color=\"b\")\nplt.plot(x, y2, label=r\"$y = \\cos(x)$\", color=\"gray\", linestyle=\"--\")\n\n# Add labels, title, and legend\nplt.xlabel(\"x\")\nplt.ylabel(\"y\")\nplt.axhline(0, color=\"black\", linewidth=0.5)\nplt.axvline(0, color=\"black\", linewidth=0.5)\nplt.legend( loc='lower right',)\nplt.grid(True)\n\n# Set x-ticks to multiples of pi\nxticks = np.arange(-2 * np.pi, 2.5 * np.pi, np.pi / 2)\nxtick_labels = [\n    r\"$-2\\pi$\",\n    r\"$-\\frac{3\\pi}{2}$\",\n    r\"$-\\pi$\",\n    r\"$-\\frac{\\pi}{2}$\",\n    \"0\",\n    r\"$\\frac{\\pi}{2}$\",\n    r\"$\\pi$\",\n    r\"$\\frac{3\\pi}{2}$\",\n    r\"$2\\pi$\",\n]\nplt.xticks(xticks, xtick_labels)\n\n\n# Show the plot\nplt.show()"
  },
  {
    "objectID": "posts/2025-03-05-addition-theorem/index.html#和積の公式",
    "href": "posts/2025-03-05-addition-theorem/index.html#和積の公式",
    "title": "三角関数の加法定理",
    "section": "和積の公式",
    "text": "和積の公式\n\n\nTheorem 5 : 正弦関数の和積の公式 \n\\[\n\\begin{align}\n\\sin \\alpha + \\sin\\beta &= 2 \\sin \\frac{\\alpha+\\beta}{2}\\cos \\frac{\\alpha-\\beta}{2}\\\\\n\\sin \\alpha - \\sin\\beta &= 2 \\cos \\frac{\\alpha+\\beta}{2}\\sin \\frac{\\alpha-\\beta}{2}\\\\\n\\cos \\alpha + \\cos\\beta &= 2 \\cos \\frac{\\alpha+\\beta}{2}\\cos \\frac{\\alpha-\\beta}{2}\\\\\n\\cos \\alpha - \\cos\\beta &= -2 \\sin \\frac{\\alpha+\\beta}{2}\\sin \\frac{\\alpha-\\beta}{2}\n\\end{align}\n\\]\n\n\n\n\n\n\n\n\n\nProof\n\n\n\n\n\n加法定理より\n\\[\n\\begin{align}\n\\sin (\\gamma + \\delta)\n    &= \\sin\\gamma \\cos\\delta + \\cos\\gamma \\sin\\delta\\\\\n\\sin (\\gamma - \\delta)\n    &= \\sin\\gamma \\cos\\delta - \\cos\\gamma \\sin\\delta\n\\end{align}\n\\]\nこれを整理すると\n\\[\n\\begin{align}\n\\sin (\\gamma + \\delta) + \\sin (\\gamma - \\delta) &= 2\\sin\\gamma \\cos\\delta\\\\\n\\sin (\\gamma + \\delta) - \\sin (\\gamma - \\delta) &= 2\\cos\\gamma \\sin\\delta\n\\end{align}\n\\]\nここで，\\(\\gamma + \\delta = \\alpha, \\gamma - \\delta = \\beta\\) とおくと\n\\[\n\\begin{gather}\n\\gamma = \\frac{ \\alpha + \\beta}{2}, \\quad \\delta = \\frac{\\alpha - \\beta}{2}\n\\end{gather}\n\\]\nとなるので\n\\[\n\\begin{align}\n\\sin \\alpha + \\sin\\beta &= 2 \\sin \\frac{\\alpha+\\beta}{2}\\cos \\frac{\\alpha-\\beta}{2}\\\\\n\\sin \\alpha - \\sin\\beta &= 2 \\cos \\frac{\\alpha+\\beta}{2}\\sin \\frac{\\alpha-\\beta}{2}\n\\end{align}\n\\]\n余弦関数も同様に\n\\[\n\\begin{align}\n\\cos (\\gamma + \\delta)\n    &= \\cos\\gamma \\cos\\delta - \\sin\\gamma \\sin\\delta\\\\\n\\cos (\\gamma - \\delta)\n    &= \\cos\\gamma \\cos\\delta + \\sin\\gamma \\sin\\delta\n\\end{align}\n\\]\nであるので\n\\[\n\\begin{align}\n\\cos (\\gamma + \\delta) + \\cos (\\gamma - \\delta) &= 2\\cos\\gamma \\cos\\delta\\\\\n\\cos (\\gamma + \\delta) - \\cos (\\gamma - \\delta) &= -2\\sin\\gamma \\sin\\delta\n\\end{align}\n\\]\nから導くことができます．\n\n\n\n\nExample 2 \n\\(x + y + z = \\pi\\) を満たす実数 \\(x, y, z\\) について\n\\[\n\\sin x + \\sin y + \\sin z = 4 \\cos\\frac{x}{2}\\cos\\frac{y}{2}\\cos\\frac{z}{2}\n\\]\nが成り立ちます．LHSを式変形すると\n\\[\n\\begin{align}\n\\sin x + \\sin y + \\sin z\n    &= \\sin x + \\sin y + \\sin (\\pi - (x + y))\\\\\n    &= \\sin x + \\sin y + \\sin (x + y)\\\\\n    &= 2\\sin\\frac{x+y}{2}\\cos\\frac{x-y}{2} + 2\\sin\\frac{x+y}{2}\\cos\\frac{x+y}{2}\\\\\n    &= 2\\sin\\frac{x+y}{2}\\left(\\cos\\frac{x-y}{2} + \\cos\\frac{x+y}{2}\\right)\\\\\n    &= 2\\sin\\frac{x+y}{2}\\times 2\\cos\\frac{\\frac{x-y}{2} + \\frac{x-y}{2}}{2}\\cos\\frac{\\frac{x-y}{2} - \\frac{x-y}{2}}{2}\\\\\n    &=4\\sin\\frac{x+y}{2}\\cos\\frac{x}{2}\\cos\\frac{-y}{2}\\\\\n    &=4\\sin\\frac{\\pi-z}{2}\\cos\\frac{x}{2}\\cos\\frac{y}{2}\\\\\n    &=4\\cos\\frac{z}{2}\\cos\\frac{x}{2}\\cos\\frac{y}{2}\n\\end{align}\n\\]"
  },
  {
    "objectID": "posts/2025-03-05-addition-theorem/index.html#references",
    "href": "posts/2025-03-05-addition-theorem/index.html#references",
    "title": "三角関数の加法定理",
    "section": "References",
    "text": "References\n\nRegmonkey Datascience Blog &gt; tangent 75°の図形的計算\nRegmonkey Datascience Blog &gt; 三角形の内接円"
  },
  {
    "objectID": "posts/2025-05-01-how-css-works/index.html",
    "href": "posts/2025-05-01-how-css-works/index.html",
    "title": "CSSの組み込み方",
    "section": "",
    "text": "Key Takeaways\n\n\n\n\n\n\n\n方法\n保守性\n再利用性\n適している場面\n\n\n\n\nインライン\n悪い\nなし\n一時的・緊急の変更\n\n\n内部CSS\n普通\nなし\n単一ページのスタイリング\n\n\n外部CSS\n良い\n高い\n大規模・再利用が前提の開発\n\n\n\n\n\n\nCSSをHTMLに組み込む方法として，\n\nインラインCSS\n内部参照CSS\n外部参照CSS\n\nの3つがあります．それぞれの使い分けも簡潔に解説します．\n1: インラインCSS\n&lt;p style=\"color: #ff0000; font-weight: bold;\"&gt;これは赤い太字のテキストです&lt;/p&gt;\n\nHTMLタグのstyle属性に直接書く方法\n特定の要素だけ一時的にスタイルを指定したいときに使用するが，構造であるHTMLドキュメントに直接デザインの指定をしてしまうので，多用するとメンテナンスが難しくなります\n一時的にテストするとき以外は原則として使用しないこと\n\nセレクタ(selector)とプロパティ(property)\n\nセレクタ: 「どのHTML要素にスタイルを適用するか」を指定する部分\nプロパティ: 「何をどうスタイルするか」の内容部分\n\nh1 {\n    color:#FF0000;\n}\nこの例では，h1がセレクタ，colorがプロパティ，#FF0000がプロパティに対応するValue\n2: 内部参照CSS\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n  &lt;style&gt;\n    p {\n      color: blue;\n      font-size: 18px;\n    }\n  &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;p&gt;これは青いテキストです。&lt;/p&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\nHTMLの&lt;head&gt;内に&lt;style&gt;タグでCSSを書く方法\nHTMLに直接書き込むスタイルなので，そのHTML1ページだけのスタイル指定(=使い回しができない)\n一時的にテストするとき以外は原則として使用しないこと\n\n3. 外部参照CSS\n\n\nhtml file\n\n&lt;head&gt;\n    &lt;link rel=\"stylesheet\" href=\"styles.css\" media=\"all\"&gt;\n&lt;/head&gt;\n\n\n\nstyle.css\n\np {\n  color: green;\n}\n\n\nHTMLの中に直接スタイルを書くのではなく，別ファイル（.css）として分けて管理し参照するスタイル\n複数ページに共通するデザインを一箇所で管理できるため，保守性や再利用性が高い\nブラウザがCSSファイルをキャッシュできるため，2回目以降の読み込みが速い\nHTML（構造）とCSS（デザイン）を分離するのはベストプラクティスとされている\n\n外部CSS参照の基本書式\n\n\n\n\n\n\n\n\n引数\n内容\n\n\n\n\nrel属性\n外部リソースとの関係性を指定．CSSを読み込む場合は \"stylesheet\"\n\n\nhref属性\n読み込むCSSファイルのURLやパスを指定\n\n\nmedia属性\nスタイルを適用するメディアタイプを指定．通常は \"all\" や \"screen\""
  },
  {
    "objectID": "posts/2025-05-01-how-css-works/index.html#cssをhtmlに組み込む方法",
    "href": "posts/2025-05-01-how-css-works/index.html#cssをhtmlに組み込む方法",
    "title": "CSSの組み込み方",
    "section": "",
    "text": "Key Takeaways\n\n\n\n\n\n\n\n方法\n保守性\n再利用性\n適している場面\n\n\n\n\nインライン\n悪い\nなし\n一時的・緊急の変更\n\n\n内部CSS\n普通\nなし\n単一ページのスタイリング\n\n\n外部CSS\n良い\n高い\n大規模・再利用が前提の開発\n\n\n\n\n\n\nCSSをHTMLに組み込む方法として，\n\nインラインCSS\n内部参照CSS\n外部参照CSS\n\nの3つがあります．それぞれの使い分けも簡潔に解説します．\n1: インラインCSS\n&lt;p style=\"color: #ff0000; font-weight: bold;\"&gt;これは赤い太字のテキストです&lt;/p&gt;\n\nHTMLタグのstyle属性に直接書く方法\n特定の要素だけ一時的にスタイルを指定したいときに使用するが，構造であるHTMLドキュメントに直接デザインの指定をしてしまうので，多用するとメンテナンスが難しくなります\n一時的にテストするとき以外は原則として使用しないこと\n\nセレクタ(selector)とプロパティ(property)\n\nセレクタ: 「どのHTML要素にスタイルを適用するか」を指定する部分\nプロパティ: 「何をどうスタイルするか」の内容部分\n\nh1 {\n    color:#FF0000;\n}\nこの例では，h1がセレクタ，colorがプロパティ，#FF0000がプロパティに対応するValue\n2: 内部参照CSS\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n  &lt;style&gt;\n    p {\n      color: blue;\n      font-size: 18px;\n    }\n  &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;p&gt;これは青いテキストです。&lt;/p&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\nHTMLの&lt;head&gt;内に&lt;style&gt;タグでCSSを書く方法\nHTMLに直接書き込むスタイルなので，そのHTML1ページだけのスタイル指定(=使い回しができない)\n一時的にテストするとき以外は原則として使用しないこと\n\n3. 外部参照CSS\n\n\nhtml file\n\n&lt;head&gt;\n    &lt;link rel=\"stylesheet\" href=\"styles.css\" media=\"all\"&gt;\n&lt;/head&gt;\n\n\n\nstyle.css\n\np {\n  color: green;\n}\n\n\nHTMLの中に直接スタイルを書くのではなく，別ファイル（.css）として分けて管理し参照するスタイル\n複数ページに共通するデザインを一箇所で管理できるため，保守性や再利用性が高い\nブラウザがCSSファイルをキャッシュできるため，2回目以降の読み込みが速い\nHTML（構造）とCSS（デザイン）を分離するのはベストプラクティスとされている\n\n外部CSS参照の基本書式\n\n\n\n\n\n\n\n\n引数\n内容\n\n\n\n\nrel属性\n外部リソースとの関係性を指定．CSSを読み込む場合は \"stylesheet\"\n\n\nhref属性\n読み込むCSSファイルのURLやパスを指定\n\n\nmedia属性\nスタイルを適用するメディアタイプを指定．通常は \"all\" や \"screen\""
  },
  {
    "objectID": "posts/2024-12-17-firefox-proxy-access/index.html",
    "href": "posts/2024-12-17-firefox-proxy-access/index.html",
    "title": "Firefoxを用いたsocks5 proxyブラウザアクセス設定",
    "section": "",
    "text": "アクセス元のglobal IPが制限されたサイト(例: 社内用gitlabサーバー)へアクセスする場合，\n\n許可されたglobal IPに属するプライベートIPネットワークに接続している端末からアクセス\n別端末から上記の端末へssh接続し，プロキシサーバー的に使用をする\n\nという2つの方法が考えられます．後者の方法をFirefoxを用いて設定する方法を紹介します．\n ▶  なぜFirefoxなのか？\n\nGoogle chromeでもproxy設定は可能ですが，OS側の設定を変更してしまう\nFirefoxはブラウザレベルでproxyの設定が可能"
  },
  {
    "objectID": "posts/2024-12-17-firefox-proxy-access/index.html#what-we-want-to-do",
    "href": "posts/2024-12-17-firefox-proxy-access/index.html#what-we-want-to-do",
    "title": "Firefoxを用いたsocks5 proxyブラウザアクセス設定",
    "section": "",
    "text": "アクセス元のglobal IPが制限されたサイト(例: 社内用gitlabサーバー)へアクセスする場合，\n\n許可されたglobal IPに属するプライベートIPネットワークに接続している端末からアクセス\n別端末から上記の端末へssh接続し，プロキシサーバー的に使用をする\n\nという2つの方法が考えられます．後者の方法をFirefoxを用いて設定する方法を紹介します．\n ▶  なぜFirefoxなのか？\n\nGoogle chromeでもproxy設定は可能ですが，OS側の設定を変更してしまう\nFirefoxはブラウザレベルでproxyの設定が可能"
  },
  {
    "objectID": "posts/2024-12-17-firefox-proxy-access/index.html#firefoxにおけるsocks5-proxy設定",
    "href": "posts/2024-12-17-firefox-proxy-access/index.html#firefoxにおけるsocks5-proxy設定",
    "title": "Firefoxを用いたsocks5 proxyブラウザアクセス設定",
    "section": "Firefoxにおけるsocks5 proxy設定",
    "text": "Firefoxにおけるsocks5 proxy設定\n\nFirefoxを開いて、右上のメニューボタン（三本線）をクリック\nメニューから「設定」を選択\nネットワーク設定を開く\n「手動でプロキシ設定をする」オプションを選択\n「SOCKS v5」を選択し，SOCKSホストを127.0.0.1，ポートを1080で設定\n変更を保存\n\n\n\n\nfirefox-proxy-setting\n\n\n\nHow to use\nLinux, Windows, MacOS問わず\nssh &lt;username&gt;@&lt;proxy-server&gt; -D 1080\nとまず，ssh接続を確立します．-D オプションはダイナミックポートフォワーディング (Dynamic Port Forwarding)の設定です． 上記を実行するとローカルの 1080番ポート にSOCKS5プロキシが立ち上がります．\nFirefoxで SOCKS5プロキシ 127.0.0.1:1080と設定すると，\n\n\n\n\n\nsequenceDiagram\n    participant Client as クライアント\n    participant LocalSOCKS as localhost:1080 (SOCKSプロキシ)\n    participant SSHTunnel as SSHトンネル\n    participant RemoteServer as リモートサーバー\n    participant ExternalServer as 外部サーバー\n\n    %% 1. クライアントがSOCKSプロキシに接続\n    Client-&gt;&gt;LocalSOCKS: データ送信 (接続要求, 宛先IP/ポート)\n\n    %% 2. SOCKSプロキシがSSHトンネル経由でリモートサーバーに転送\n    LocalSOCKS-&gt;&gt;SSHTunnel: データ転送 (暗号化)\n\n    %% 3. SSHトンネルがリモートサーバーに転送\n    SSHTunnel-&gt;&gt;RemoteServer: データ中継 (トンネル経由)\n\n    %% 4. リモートサーバーが外部サーバーに接続\n    RemoteServer-&gt;&gt;ExternalServer: 外部サーバー接続要求 (TCP/UDP)\n    ExternalServer--&gt;&gt;RemoteServer: 接続応答\n\n    %% 5. 応答をクライアントに返送\n    RemoteServer--&gt;&gt;SSHTunnel: 応答データ\n    SSHTunnel--&gt;&gt;LocalSOCKS: 暗号化データ戻し\n    LocalSOCKS--&gt;&gt;Client: レスポンス転送\n\n\n\n\n\n\n\nという順序で通信されるようになります．"
  },
  {
    "objectID": "posts/2024-12-17-firefox-proxy-access/index.html#appendix-プロキシサーバーの仕組み",
    "href": "posts/2024-12-17-firefox-proxy-access/index.html#appendix-プロキシサーバーの仕組み",
    "title": "Firefoxを用いたsocks5 proxyブラウザアクセス設定",
    "section": "Appendix: プロキシサーバーの仕組み",
    "text": "Appendix: プロキシサーバーの仕組み\nクライアントの依頼に応じて，外部のサーバーにサービスを要求し，その結果をクライアントに提供するサーバーをプロキシサーバーといいます． SOCKS5は，プロキシサーバーを利用してサーバーとクライアント間のパケットをルーティングするインターネットプロトコルのことを指します．\nSOCKS5プロキシサーバーのメリットとして，安全性，匿名性，利便性の3つがあります．\n ▶  安全性\n\nSOCKS5は，ユーザー名とパスワードによる認証機能をサポートしているため，外部の不正アクセスや認証されていないクライアントからの利用を防ぐことができる\nSSHトンネルと組み合わせることで，安全にSOCKS5プロキシサーバー経由の通信を暗号化することができる = リモートアクセス時のデータ転送が保護され，悪意のあるネットワーク環境でも安全に通信可能\nプロキシサーバーを中間地点として使用することで，DDoS攻撃などの直接的な大量トラフィック攻撃を遮断することが可能\n\n ▶  匿名性\n\nネットワーク全体のトラフィックがプロキシサーバー経由で処理されるため，外部から見えるIPアドレスが プロキシのIPになる = SOCKS5プロキシを介することで，クライアントのIPアドレス/端末名を隠すことができる\n一括でアクセス元をプロキシのIPに集約し，クライアントIPを隠蔽することでセキュリティとプライバシー保護が可能になるという活用方法がある\n\nSOCKS5プロキシは，クライアントから送信されたデータをそのまま中継しますが，データ送信時のヘッダ情報（IPアドレスなど）をカプセル化します． そのため，外部サーバーはデータの中身だけを認識し，送信元（クライアント）に関する情報は知ることができないという仕組みになっています．\n ▶  利便性\n\nSOCKS5はプロトコル非依存であり，TCPとUDPの両方の通信をサポートしている = FTP, SMTP, P2P, VoIP, DNSリクエスト, オンラインゲームなど多様なアプリケーションで利用可能\n\n\n\n\n\n\nsequenceDiagram\n    participant Client as クライアント\n    participant SOCKS5ProxyServer as SOCKS5プロキシサーバー\n    participant ExternalServer as 外部サーバー\n\n    %% 1. 接続要求とハンドシェイク\n    Client-&gt;&gt;SOCKS5ProxyServer: 接続要求 (Handshake: バージョン, 認証方式)\n    SOCKS5ProxyServer--&gt;&gt;Client: 認証方式応答 (成功/失敗)\n\n    %% 2. 外部サーバーへの接続要求\n    Client-&gt;&gt;SOCKS5ProxyServer: 外部サーバー接続要求 (宛先IP, ポート)\n    note right of Client: クライアントのIPアドレスは隠蔽される\n    SOCKS5ProxyServer-&gt;&gt;ExternalServer: 接続確立要求 (プロキシのIPを使用)\n\n    %% 3. 接続確立確認\n    ExternalServer--&gt;&gt;SOCKS5ProxyServer: 接続成功応答\n    SOCKS5ProxyServer--&gt;&gt;Client: 接続確立成功通知\n\n    %% 4. データ転送 (カプセル化)\n    Client-&gt;&gt;SOCKS5ProxyServer: データ送信 (カプセル化されたパケット)\n    note over SOCKS5ProxyServer: データをそのまま中継 (IPアドレス非公開)\n    SOCKS5ProxyServer-&gt;&gt;ExternalServer: データ転送 (TCP/UDP)\n    ExternalServer--&gt;&gt;SOCKS5ProxyServer: レスポンスデータ\n    SOCKS5ProxyServer--&gt;&gt;Client: レスポンス転送\n\n    %% 5. 通信終了\n    Client-&gt;&gt;SOCKS5ProxyServer: 通信終了リクエスト\n    SOCKS5ProxyServer-&gt;&gt;ExternalServer: 接続切断\n    SOCKS5ProxyServer--&gt;&gt;Client: 通信終了通知\n\n\n\n\n\n\n\nSOCKS5プロキシはキャッシュを行わない\nHTTPプロキシは一般的に，ウェブコンテンツ（画像、HTML、動画など）をキャッシュすることで，再アクセス時にデータ転送を高速化します． 一方，SOCKS5プロキシはキャッシュを行なわないという違いがあります．\n\nSOCKS5はデータ転送のトンネルを作る役割を果たすため，通信内容のデータを確認・保存することがない\nあくまで「データを中継する」プロトコルであり，内容に依存しないため，キャッシュ機能は持たない\n\nSOCKS5はキャッシュ機能を持たないことで，シンプルかつ高速な通信環境を提供してくれるものと理解していればOKだとおもいます． キャッシュはリアルタイム通信に不要ですし，また，キャッシュ管理の手間やストレージコストが不要というメリットもあります．"
  },
  {
    "objectID": "posts/2025-03-03-triangle-inequality/index.html",
    "href": "posts/2025-03-03-triangle-inequality/index.html",
    "title": "いろいろな三角不等式",
    "section": "",
    "text": "Theorem 1 : シュワルツの不等式 \n任意の２つのベクトル \\(\\pmb{a}, \\pmb{b}\\) に対して，\n\\[\n\\vert (\\pmb{a}, \\pmb{b})\\vert \\leq ||\\pmb{a}||\\,||\\pmb{b}||\n\\]\n等号が成り立つのは \\(\\pmb a = k\\pmb b\\) または, \\(\\pmb b = k^\\prime\\pmb a\\) が成り立つ場合に限る(\\(k,k^\\prime \\in \\mathbf R\\))．\n\n\n\n\n\n\n\n\n\nProof\n\n\n\n\n\n ▶  \\(\\pmb b = \\pmb 0\\) のとき\n\\(\\pmb b = \\pmb 0\\) のときは等号が成り立つことは自明．\n ▶  \\(\\pmb b \\neq \\pmb 0\\) のとき\n\\(\\displaystyle k = \\frac{(\\pmb a, \\pmb b)}{||\\pmb b||^2}\\) とおくと，\n\\[\n\\begin{align}\n||\\pmb a - k\\pmb b||^2\n    &= ||\\pmb a||^2 - 2k(\\pmb a, \\pmb b) + k^2 ||\\pmb b||^2\\\\\n    &= ||\\pmb a||^2 - 2\\frac{(\\pmb a, \\pmb b)^2}{||\\pmb b||^2} + \\frac{(\\pmb a, \\pmb b)^2}{||\\pmb b||^2}\\\\\n    &= ||\\pmb a||^2 - \\frac{(\\pmb a, \\pmb b)^2}{||\\pmb b||^2}\n\\end{align}\n\\]\nここで，\\(||\\pmb a - k\\pmb b||^2 \\geq 0\\) であるので\n\\[\n||\\pmb a||^2 \\geq \\frac{(\\pmb a, \\pmb b)^2}{||\\pmb b||^2}\n\\]\nこれを整理すると\n\\[\n||\\pmb a||^2||\\pmb b||^2 \\geq (\\pmb a, \\pmb b)^2 \\Rightarrow ||\\pmb a||\\,||\\pmb b|| \\geq |(\\pmb a, \\pmb b)|\n\\]\n等号成立が成立するとき \\(||\\pmb a - k\\pmb b||^2 = 0\\) であるので，\\(\\pmb a = k\\pmb b\\) が必要条件であることがわかります．\n ▶  \\(\\pmb a = k\\pmb b\\) の十分条件性 \n\\[\n\\begin{align}\n||\\pmb a||\\,||\\pmb b||\n    &= |k|||\\pmb b||\\,||\\pmb b||\\\\\n    &= |k|||\\pmb b||^2\n\\end{align}\n\\]\nまた\n\\[\n\\begin{align}\n|(\\pmb a, \\pmb b)|\n    &= |k|(\\pmb b, \\pmb b)\\\\\n    &= |k|||\\pmb b||^2\n\\end{align}\n\\]\nしたがって，\\(|\\pmb a||\\,||\\pmb b|| = |(\\pmb a, \\pmb b)|\\) が成り立つことがわかります．\n\n\n\n\n\nTheorem 2 : シュワルツの不等式と三角不等式 \n任意の２つのベクトル \\(\\pmb{a}, \\pmb{b}\\) に対して，\n\\[\n||\\pmb{a} + \\pmb{b}|| \\leq ||\\pmb{a}||\\, ||\\pmb{b}||\n\\]\n等号が成り立つのは \\(\\pmb a = k\\pmb b, k\\geq 0\\) または, \\(\\pmb b = k^\\prime\\pmb a, k^\\prime\\geq 0\\) が成り立つ場合に限る．\n\n\n\n\n\n\n\n\n\nProof\n\n\n\n\n\nシュワルツの不等式を用いると\n\\[\n\\begin{align}\n||\\pmb{a} + \\pmb{b}||^2\n    &= ||\\pmb{a}||^2 + 2(\\pmb{a},\\pmb{b}) + ||\\pmb{b}||^2\\\\\n    &\\leq ||\\pmb{a}||^2 + 2||\\pmb{a}||\\,||\\pmb{b}|| + ||\\pmb{b}||^2\\\\\n    &= (||\\pmb{a}|| + ||\\pmb{b}||)^2\n\\end{align}\n\\]\nしたがって，\n\\[\n||\\pmb{a} + \\pmb{b}|| \\leq ||\\pmb{a}||\\, ||\\pmb{b}||\n\\]\n等号成立はシュワルツの不等式の等号が成立し，かつ\n\\[\n(\\pmb{a},\\pmb{b}) \\geq 0\n\\]\nが成立するときとなるので， \\(\\pmb a = k\\pmb b, k\\geq 0\\) または, \\(\\pmb b = k^\\prime\\pmb a, k^\\prime\\geq 0\\) が成り立つ場合に限ることがわかる．"
  },
  {
    "objectID": "posts/2025-03-03-triangle-inequality/index.html#シュワルツの不等式と三角不等式",
    "href": "posts/2025-03-03-triangle-inequality/index.html#シュワルツの不等式と三角不等式",
    "title": "いろいろな三角不等式",
    "section": "",
    "text": "Theorem 1 : シュワルツの不等式 \n任意の２つのベクトル \\(\\pmb{a}, \\pmb{b}\\) に対して，\n\\[\n\\vert (\\pmb{a}, \\pmb{b})\\vert \\leq ||\\pmb{a}||\\,||\\pmb{b}||\n\\]\n等号が成り立つのは \\(\\pmb a = k\\pmb b\\) または, \\(\\pmb b = k^\\prime\\pmb a\\) が成り立つ場合に限る(\\(k,k^\\prime \\in \\mathbf R\\))．\n\n\n\n\n\n\n\n\n\nProof\n\n\n\n\n\n ▶  \\(\\pmb b = \\pmb 0\\) のとき\n\\(\\pmb b = \\pmb 0\\) のときは等号が成り立つことは自明．\n ▶  \\(\\pmb b \\neq \\pmb 0\\) のとき\n\\(\\displaystyle k = \\frac{(\\pmb a, \\pmb b)}{||\\pmb b||^2}\\) とおくと，\n\\[\n\\begin{align}\n||\\pmb a - k\\pmb b||^2\n    &= ||\\pmb a||^2 - 2k(\\pmb a, \\pmb b) + k^2 ||\\pmb b||^2\\\\\n    &= ||\\pmb a||^2 - 2\\frac{(\\pmb a, \\pmb b)^2}{||\\pmb b||^2} + \\frac{(\\pmb a, \\pmb b)^2}{||\\pmb b||^2}\\\\\n    &= ||\\pmb a||^2 - \\frac{(\\pmb a, \\pmb b)^2}{||\\pmb b||^2}\n\\end{align}\n\\]\nここで，\\(||\\pmb a - k\\pmb b||^2 \\geq 0\\) であるので\n\\[\n||\\pmb a||^2 \\geq \\frac{(\\pmb a, \\pmb b)^2}{||\\pmb b||^2}\n\\]\nこれを整理すると\n\\[\n||\\pmb a||^2||\\pmb b||^2 \\geq (\\pmb a, \\pmb b)^2 \\Rightarrow ||\\pmb a||\\,||\\pmb b|| \\geq |(\\pmb a, \\pmb b)|\n\\]\n等号成立が成立するとき \\(||\\pmb a - k\\pmb b||^2 = 0\\) であるので，\\(\\pmb a = k\\pmb b\\) が必要条件であることがわかります．\n ▶  \\(\\pmb a = k\\pmb b\\) の十分条件性 \n\\[\n\\begin{align}\n||\\pmb a||\\,||\\pmb b||\n    &= |k|||\\pmb b||\\,||\\pmb b||\\\\\n    &= |k|||\\pmb b||^2\n\\end{align}\n\\]\nまた\n\\[\n\\begin{align}\n|(\\pmb a, \\pmb b)|\n    &= |k|(\\pmb b, \\pmb b)\\\\\n    &= |k|||\\pmb b||^2\n\\end{align}\n\\]\nしたがって，\\(|\\pmb a||\\,||\\pmb b|| = |(\\pmb a, \\pmb b)|\\) が成り立つことがわかります．\n\n\n\n\n\nTheorem 2 : シュワルツの不等式と三角不等式 \n任意の２つのベクトル \\(\\pmb{a}, \\pmb{b}\\) に対して，\n\\[\n||\\pmb{a} + \\pmb{b}|| \\leq ||\\pmb{a}||\\, ||\\pmb{b}||\n\\]\n等号が成り立つのは \\(\\pmb a = k\\pmb b, k\\geq 0\\) または, \\(\\pmb b = k^\\prime\\pmb a, k^\\prime\\geq 0\\) が成り立つ場合に限る．\n\n\n\n\n\n\n\n\n\nProof\n\n\n\n\n\nシュワルツの不等式を用いると\n\\[\n\\begin{align}\n||\\pmb{a} + \\pmb{b}||^2\n    &= ||\\pmb{a}||^2 + 2(\\pmb{a},\\pmb{b}) + ||\\pmb{b}||^2\\\\\n    &\\leq ||\\pmb{a}||^2 + 2||\\pmb{a}||\\,||\\pmb{b}|| + ||\\pmb{b}||^2\\\\\n    &= (||\\pmb{a}|| + ||\\pmb{b}||)^2\n\\end{align}\n\\]\nしたがって，\n\\[\n||\\pmb{a} + \\pmb{b}|| \\leq ||\\pmb{a}||\\, ||\\pmb{b}||\n\\]\n等号成立はシュワルツの不等式の等号が成立し，かつ\n\\[\n(\\pmb{a},\\pmb{b}) \\geq 0\n\\]\nが成立するときとなるので， \\(\\pmb a = k\\pmb b, k\\geq 0\\) または, \\(\\pmb b = k^\\prime\\pmb a, k^\\prime\\geq 0\\) が成り立つ場合に限ることがわかる．"
  },
  {
    "objectID": "posts/2025-03-03-triangle-inequality/index.html#複素数と三角不等式",
    "href": "posts/2025-03-03-triangle-inequality/index.html#複素数と三角不等式",
    "title": "いろいろな三角不等式",
    "section": "複素数と三角不等式",
    "text": "複素数と三角不等式\n\n\nTheorem 3 \n複素平面上に2点 \\(z = a_1 + b_1i, w = a_2 + b_2i\\) をとったとき，次の不等式が成立する\n\\[\n\\begin{gather}\n\\vert z + w \\vert \\leq \\vert z\\vert + \\vert w \\vert\\\\\n\\vert z\\vert - \\vert w \\vert \\leq \\vert z - w \\vert\n\\end{gather}\n\\]\nこれを三角不等式と呼ぶ．\n\n\n\n\n\n\n\n\n\nProof 1\n\n\n\n\n\n注意: この証明は平面空間における三角不等式を前提にしているのでトートロジー疑惑が有ります\n\n\nCode\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Define the complex numbers\nalpha1 = 3 + 4j\nalpha2 = 5 + 2j\nalpha3 = alpha1 + alpha2\nalpha4 = alpha1 - alpha2\n\n# Extract the real and imaginary parts\na1_real, a1_imag = alpha1.real, alpha1.imag\na2_real, a2_imag = alpha2.real, alpha2.imag\na3_real, a3_imag = alpha3.real, alpha3.imag\na4_real, a4_imag = alpha4.real, alpha4.imag\n\n# Create the plot\nfig, ax = plt.subplots()\n\n# Plot the vectors\nax.quiver(0, 0, a1_real, a1_imag, angles=\"xy\", scale_units=\"xy\", scale=1, color=\"k\")\nax.quiver(0, 0, a2_real, a2_imag, angles=\"xy\", scale_units=\"xy\", scale=1, color=\"k\")\nax.quiver(\n    a1_real,\n    a1_imag,\n    a2_real,\n    a2_imag,\n    angles=\"xy\",\n    scale_units=\"xy\",\n    linewidth=1,\n    scale=1,\n    edgecolor=\"gray\",\n    color=\"gray\",\n)\nax.quiver(0, 0, a3_real, a3_imag, angles=\"xy\", scale_units=\"xy\", scale=1, color=\"k\")\nax.quiver(0, 0, a4_real, a4_imag, angles=\"xy\", scale_units=\"xy\", scale=1, color=\"k\")\nax.quiver(\n    a1_real,\n    a1_imag,\n    -a2_real,\n    -a2_imag,\n    angles=\"xy\",\n    scale_units=\"xy\",\n    linewidth=1,\n    scale=1,\n    edgecolor=\"gray\",\n    color=\"gray\",\n)\n\n\n# add point\nax.text(a1_real, a1_imag * 1.1, \"$z$\")\nax.text(a2_real, a2_imag, \"$w$\")\nax.text(a3_real, a3_imag, \"$z+w$\")\nax.text(a4_real, a4_imag + 0.5, \"$z-w$\")\n\n\n# Set the plot limits\nax.set_xlim(a4_real - 1, max(a1_real, a3_real) + 3)\nax.set_ylim(-1, max(a1_imag, a3_imag) + 3)\n\n# Add grid, labels, and legend\nax.grid()\nax.set_aspect(\"equal\")\nax.set_xlabel(\"Real Part\")\nax.set_ylabel(\"Imaginary Part\")\n\n# Add title\nax.set_title(\"Complex Number Vectors\")\n\n# Show the plot\nplt.show()\n\n\n\n\n\n\n\n\n\n原点と \\(z, z+w\\) を頂点とする三角形を考えます．このときそれぞれの辺の長さは \\(\\vert z\\vert, \\vert w\\vert, \\vert z + w\\vert\\) となります．\n三角形の二辺の和は他の１辺の長さより長いので\n\\[\n\\vert z + w \\vert \\leq \\vert z\\vert + \\vert w \\vert\n\\]\nが成立する．\n同様に\\(z, z-w\\) を頂点とする三角形についても\n\\[\n\\vert z \\vert \\leq \\vert z + w \\vert + \\vert w \\vert\n\\]\nが成り立つので，これを整理すると\n\\[\n\\vert z\\vert - \\vert w \\vert \\leq \\vert z - w \\vert\n\\]\n\n\n\n\n\n\n\n\n\n\nProof 2\n\n\n\n\n\n複素数の絶対値と共役複素数の関係より\n\\[\n\\begin{align}\n\\vert  z + w \\vert^2\n    &= (z + w)(\\bar z + \\bar w)\\\\\n    &= z\\bar z + w\\bar w + w\\bar z + z\\bar w\\\\\n    &= \\vert z\\vert^2 + \\vert w\\vert^2 + w \\overline z + z \\overline w\\\\\n    &= \\vert z\\vert^2 + \\vert w\\vert^2 + w \\overline z + \\overline{\\overline z w}\\\\\n    &= \\vert z\\vert^2 + \\vert w\\vert^2 + 2\\operatorname{Re}w \\overline z\\\\\n    &\\leq \\vert z\\vert^2 + \\vert w\\vert^2 + 2\\vert w \\overline z\\vert\\\\\n    &= \\vert z\\vert^2 + \\vert w\\vert^2 + 2\\vert w\\vert \\vert\\overline z\\vert\\\\\n    &= \\vert z\\vert^2 + \\vert w\\vert^2 + 2\\vert w\\vert \\vert z\\vert\\\\\n    &= (\\vert z \\vert + \\vert w \\vert)^2\n\\end{align}\n\\]\nしたがって，\n\\[\n\\vert  z + w \\vert \\leq \\vert z \\vert + \\vert w \\vert\n\\]\n\n\n\n\n\nTheorem 4 \n\\(\\mathbb C^n\\) の任意のベクトル \\(\\pmb a, \\pmb b\\) に対し，次が成立する\n\\[\n||\\pmb a + \\pmb b|| \\leq ||\\pmb a|| + ||\\pmb b||\n\\]\n\n\n\n\n\n\n\n\n\nProof\n\n\n\n\n\n\\[\n\\begin{align}\n||\\pmb a + \\pmb b||^2\n    &= (\\pmb a + \\pmb b, \\pmb a + \\pmb b)\\\\\n    &= ||\\pmb a||^2 + ||\\pmb b||^2 + (\\pmb a, \\pmb b) + (\\pmb b, \\pmb a)\n\\end{align}\n\\]\nここでシュワルツの不等式より\n\\[\n\\begin{align}\n|(\\pmb a, \\pmb b)| &\\leq ||\\pmb a||\\,||\\pmb b||\\\\\n|(\\pmb b, \\pmb a)| &\\leq ||\\pmb b||\\,||\\pmb a|| = ||\\pmb a||\\,||\\pmb b||\n\\end{align}\n\\]\n従って，\n\\[\n\\begin{align}\n||\\pmb a||^2 + ||\\pmb b||^2 + (\\pmb a, \\pmb b) + (\\pmb b, \\pmb a)\n    &\\leq ||\\pmb a||^2 + ||\\pmb b||^2  + 2 ||\\pmb a||\\,||\\pmb b||\\\\\n    &= (||\\pmb a|| + ||\\pmb b||)^2\n\\end{align}\n\\]\nよって，\n\\[\n\\begin{gather}\n||\\pmb a + \\pmb b||^2 \\leq (||\\pmb a|| + ||\\pmb b||)^2\\\\\n\\Rightarrow ||\\pmb a + \\pmb b|| \\leq ||\\pmb a|| + ||\\pmb b||\n\\end{gather}\n\\]"
  },
  {
    "objectID": "posts/2024-12-07-meta-address/index.html",
    "href": "posts/2024-12-07-meta-address/index.html",
    "title": "IPアドレス 0.0.0.0",
    "section": "",
    "text": "pythonでhttp serverを立てて，Quartoで作成したウェブサイトを以下のコマンドで公開するとします\n% python -m http.server 3000 --directory ./_site/\nServing HTTP on 0.0.0.0 port 3000 (http://0.0.0.0:3000/) ..\nバインド先を設定せずにserverを立ち上げたところ，0.0.0.0 で立ち上げているようです． このとき，Firewallの3000 portをホスト側でAllowすると，同じnetworkの他の端末(例:iPad)からでもアクセスできるようになりました．\n ▶  プライベートIPアドレスをバインド先に指定した場合 \n自宅内のネットワークのみで有効なプライベートIPアドレス（クラスC 192.168.0.0 ~ 192.168.255.255）を指定してhttp serverを立たてみます．\n% python -m http.server 3000 --directory ./_site/ --bind 192.168.10.105\nServing HTTP on 192.168.10.105 port 3000 (http://192.168.10.105:3000/) ...\nこのとき，同じネットワーク内にあるiPadからアクセスできるようになりました． iPad側では http://192.168.10.105:3000 に接続することでQuarto contentsにアクセスできるようになりましたが， このiPad側での操作は 0.0.0.0 で立ち上げたときと同じ操作となります．\n\n❓ Question \npython http.server を使用して 0.0.0.0 にバインドしてhttp serverを立てたときの挙動がプライベートネットワーク内部で割り当てられたプライベートIPアドレスを指定したときと同じ挙動をするのか？\n\n\n\nIPv4において 0.0.0.0 (IPv6では::/0) はSepcial-Purpose Address Registry，つまり特別な目的用に予約されたアドレスです．\n\nRFC6890\n\n\n\n\n\n\nAttribute\nValue\n\n\n\n\nAddress Block\n0.0.0.0/8\n\n\nName\nThis host on this network\n\n\nRFC\n[RFC1122], Section 3.2.1.3\n\n\nAllocation Date\nSeptember 1981\n\n\nTermination Date\nN/A\n\n\nSource\nTrue\n\n\nDestination\nFalse\n\n\nForwardable\nFalse\n\n\nGlobal\nFalse\n\n\nReserved-by-Protocol\nTrue\n\n\n\n上記より0.0.0.0 ~ 0.255.255.255について以下の情報を得ることができます\n\nGlobalセクションがFalseとなっていることから，グローバルIPアドレスとして使用できない．利用はローカルネットワークに限定される\nSourceセクションTrueより，送信元アドレスとして有効\nDestinationセクションFalseより，宛先アドレスとして使用できない = ルーティング不可\n\nただし，0.0.0.0の具体的な意味はここからではまだわかりません．\n ▶  0.0.0.0/0 vs 0.0.0.0/32 \n\n\n\n\n\n\n\n\nAttribute\n0.0.0.0/0\n0.0.0.0/32\n\n\n\n\nSubnet Mask\n0.0.0.0 (all bits variable)\n255.255.255.255 (all bits fixed)\n\n\nRange\nAll IPv4 addresses (0.0.0.0 to 255.255.255.255)\n0.0.0.0\n\n\n\n\n\n\nバインド先を指定しないでhttp serverを立てるとき，バインド先を指定しない = 有効な宛先がないことを意味します． このとき使用されるのが 0.0.0.0 です．\nこの文脈での 0.0.0.0 は catch-all wildcard と呼ばれるもので，同じネットワーク上のすべてのインターフェースに対して， バインドするという特別な意味を持っています．コンピューターが複数のネットワークに接続していて，すべてのネットワークにバインドしたい場合に 0.0.0.0を指定します．ただし，不必要に使用してしまうと誤って外部のネットワークに共有してしまったりするので使用は控えたほうが良いです．\n\n📘 REMARKS \n\nPython HTTP Serverにおける 0.0.0.0 はルーティングにおけるデフォルトルートとしての0.0.0.0は異なります\n文脈に応じて 0.0.0.0 が指す内容が異なることに注意してください\npython hhtp.serverの文脈では0.0.0.0にバインドすると以下のインターフェースからアクセス可能となります\n\nLocalhost (127.0.0.1)\nThe private network (例: 192.168.x.x)\nPublic network interfaces (Firewallでアクセスを許容していた場合)\n\n\n\nPython http serverをprivate networkに限定する意図を込めて，以下のスクリプトでホスティングすることが望ましいです\n$ python3 -m http.server -b &lt;your-local-private-network IP&gt; 8080 --directory ./_site/"
  },
  {
    "objectID": "posts/2024-12-07-meta-address/index.html#ipアドレス-0.0.0.0にバインド",
    "href": "posts/2024-12-07-meta-address/index.html#ipアドレス-0.0.0.0にバインド",
    "title": "IPアドレス 0.0.0.0",
    "section": "",
    "text": "pythonでhttp serverを立てて，Quartoで作成したウェブサイトを以下のコマンドで公開するとします\n% python -m http.server 3000 --directory ./_site/\nServing HTTP on 0.0.0.0 port 3000 (http://0.0.0.0:3000/) ..\nバインド先を設定せずにserverを立ち上げたところ，0.0.0.0 で立ち上げているようです． このとき，Firewallの3000 portをホスト側でAllowすると，同じnetworkの他の端末(例:iPad)からでもアクセスできるようになりました．\n ▶  プライベートIPアドレスをバインド先に指定した場合 \n自宅内のネットワークのみで有効なプライベートIPアドレス（クラスC 192.168.0.0 ~ 192.168.255.255）を指定してhttp serverを立たてみます．\n% python -m http.server 3000 --directory ./_site/ --bind 192.168.10.105\nServing HTTP on 192.168.10.105 port 3000 (http://192.168.10.105:3000/) ...\nこのとき，同じネットワーク内にあるiPadからアクセスできるようになりました． iPad側では http://192.168.10.105:3000 に接続することでQuarto contentsにアクセスできるようになりましたが， このiPad側での操作は 0.0.0.0 で立ち上げたときと同じ操作となります．\n\n❓ Question \npython http.server を使用して 0.0.0.0 にバインドしてhttp serverを立てたときの挙動がプライベートネットワーク内部で割り当てられたプライベートIPアドレスを指定したときと同じ挙動をするのか？\n\n\n\nIPv4において 0.0.0.0 (IPv6では::/0) はSepcial-Purpose Address Registry，つまり特別な目的用に予約されたアドレスです．\n\nRFC6890\n\n\n\n\n\n\nAttribute\nValue\n\n\n\n\nAddress Block\n0.0.0.0/8\n\n\nName\nThis host on this network\n\n\nRFC\n[RFC1122], Section 3.2.1.3\n\n\nAllocation Date\nSeptember 1981\n\n\nTermination Date\nN/A\n\n\nSource\nTrue\n\n\nDestination\nFalse\n\n\nForwardable\nFalse\n\n\nGlobal\nFalse\n\n\nReserved-by-Protocol\nTrue\n\n\n\n上記より0.0.0.0 ~ 0.255.255.255について以下の情報を得ることができます\n\nGlobalセクションがFalseとなっていることから，グローバルIPアドレスとして使用できない．利用はローカルネットワークに限定される\nSourceセクションTrueより，送信元アドレスとして有効\nDestinationセクションFalseより，宛先アドレスとして使用できない = ルーティング不可\n\nただし，0.0.0.0の具体的な意味はここからではまだわかりません．\n ▶  0.0.0.0/0 vs 0.0.0.0/32 \n\n\n\n\n\n\n\n\nAttribute\n0.0.0.0/0\n0.0.0.0/32\n\n\n\n\nSubnet Mask\n0.0.0.0 (all bits variable)\n255.255.255.255 (all bits fixed)\n\n\nRange\nAll IPv4 addresses (0.0.0.0 to 255.255.255.255)\n0.0.0.0\n\n\n\n\n\n\nバインド先を指定しないでhttp serverを立てるとき，バインド先を指定しない = 有効な宛先がないことを意味します． このとき使用されるのが 0.0.0.0 です．\nこの文脈での 0.0.0.0 は catch-all wildcard と呼ばれるもので，同じネットワーク上のすべてのインターフェースに対して， バインドするという特別な意味を持っています．コンピューターが複数のネットワークに接続していて，すべてのネットワークにバインドしたい場合に 0.0.0.0を指定します．ただし，不必要に使用してしまうと誤って外部のネットワークに共有してしまったりするので使用は控えたほうが良いです．\n\n📘 REMARKS \n\nPython HTTP Serverにおける 0.0.0.0 はルーティングにおけるデフォルトルートとしての0.0.0.0は異なります\n文脈に応じて 0.0.0.0 が指す内容が異なることに注意してください\npython hhtp.serverの文脈では0.0.0.0にバインドすると以下のインターフェースからアクセス可能となります\n\nLocalhost (127.0.0.1)\nThe private network (例: 192.168.x.x)\nPublic network interfaces (Firewallでアクセスを許容していた場合)\n\n\n\nPython http serverをprivate networkに限定する意図を込めて，以下のスクリプトでホスティングすることが望ましいです\n$ python3 -m http.server -b &lt;your-local-private-network IP&gt; 8080 --directory ./_site/"
  },
  {
    "objectID": "posts/2024-12-07-meta-address/index.html#references",
    "href": "posts/2024-12-07-meta-address/index.html#references",
    "title": "IPアドレス 0.0.0.0",
    "section": "References",
    "text": "References\n\nRFC5735"
  },
  {
    "objectID": "posts/2025-02-01-function-and-taylor-expansion/index.html",
    "href": "posts/2025-02-01-function-and-taylor-expansion/index.html",
    "title": "18世紀までの関数論とテイラー展開",
    "section": "",
    "text": "Def: 関数 \n\\(X \\subset \\mathbb R^n, Y\\subset \\mathbb R^n\\) とする．\\(X\\) から \\(Y\\) への関数（実関数）とは，\\(X\\) の任意の元 \\(x\\) に対して，\\(Y\\) の１つの元を対応させる規則をいう． このような \\(X\\) から \\(Y\\) への関数を\n\\[\nf: X\\to Y\n\\]\nを記述し，集合 \\(X\\) を関数 \\(f\\) の定義域(domain)，\\(Y\\) を値域(range) という．\n\n\\(y = x^2\\) としたとき，\\(y\\) は区間 \\((-\\infty, \\infty)\\) における \\(x\\) の関数と呼ばれます．関数の例としては以下，\n\nCode\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nx = np.linspace(-1, 1, 100)\n\nplt.plot(x, x**2)\nplt.gca().set_aspect('equal', adjustable='box')\nplt.show()\n\nplt.plot(x , np.sqrt(1 - x**2))\nplt.gca().set_aspect('equal', adjustable='box')\nplt.show()\n\n\n\n\n\n\n\n\\(y = x^2\\)\n\n\n\n\n\n\n\n\\(y = \\sqrt{1 - x^2}\\)\n\n\n\n\n\n ▶  古典的な関数\n歴史的に関数はまず，\n\n四則演算で表される代数式（\\(x^2 + 2x +1\\), \\(x + \\frac{1}{x}\\), \\(x + \\sqrt{4x^2 + 1}\\)）\n独立変数の代数式で表せない超越関数（\\(a^x, \\log x, \\sin x, \\arctan x\\)）\n\nに限られていました．これら関数は，各点周りでテイラー展開ができるという特徴があります．"
  },
  {
    "objectID": "posts/2025-02-01-function-and-taylor-expansion/index.html#関数",
    "href": "posts/2025-02-01-function-and-taylor-expansion/index.html#関数",
    "title": "18世紀までの関数論とテイラー展開",
    "section": "",
    "text": "Def: 関数 \n\\(X \\subset \\mathbb R^n, Y\\subset \\mathbb R^n\\) とする．\\(X\\) から \\(Y\\) への関数（実関数）とは，\\(X\\) の任意の元 \\(x\\) に対して，\\(Y\\) の１つの元を対応させる規則をいう． このような \\(X\\) から \\(Y\\) への関数を\n\\[\nf: X\\to Y\n\\]\nを記述し，集合 \\(X\\) を関数 \\(f\\) の定義域(domain)，\\(Y\\) を値域(range) という．\n\n\\(y = x^2\\) としたとき，\\(y\\) は区間 \\((-\\infty, \\infty)\\) における \\(x\\) の関数と呼ばれます．関数の例としては以下，\n\nCode\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nx = np.linspace(-1, 1, 100)\n\nplt.plot(x, x**2)\nplt.gca().set_aspect('equal', adjustable='box')\nplt.show()\n\nplt.plot(x , np.sqrt(1 - x**2))\nplt.gca().set_aspect('equal', adjustable='box')\nplt.show()\n\n\n\n\n\n\n\n\\(y = x^2\\)\n\n\n\n\n\n\n\n\\(y = \\sqrt{1 - x^2}\\)\n\n\n\n\n\n ▶  古典的な関数\n歴史的に関数はまず，\n\n四則演算で表される代数式（\\(x^2 + 2x +1\\), \\(x + \\frac{1}{x}\\), \\(x + \\sqrt{4x^2 + 1}\\)）\n独立変数の代数式で表せない超越関数（\\(a^x, \\log x, \\sin x, \\arctan x\\)）\n\nに限られていました．これら関数は，各点周りでテイラー展開ができるという特徴があります．"
  },
  {
    "objectID": "posts/2025-02-01-function-and-taylor-expansion/index.html#平均値の定理からtaylorの公式へ",
    "href": "posts/2025-02-01-function-and-taylor-expansion/index.html#平均値の定理からtaylorの公式へ",
    "title": "18世紀までの関数論とテイラー展開",
    "section": "平均値の定理からTaylorの公式へ",
    "text": "平均値の定理からTaylorの公式へ\n\n\nTheorem 1 : 平均値の定理 \n区間 \\([a, b]\\) において，\\(f(x), g(x)\\) は連続で, \\((a, b)\\) において微分可能とする．このとき，ある点 \\(\\xi \\in (a, b)\\) において，\n\\[\n\\frac{f(b) - f(a)}{g(b) - g(a)} = \\frac{f^\\prime(\\xi)}{g^\\prime(\\xi)}\\label{eq-mean-value}\n\\]\nただし，\\(g(a)\\neq g(b)\\)．\\(f^\\prime(x), g^\\prime(x)\\) は区間内で同時に \\(0\\) にならないと仮定する．\n\n\n\n\n\n\n\n\n\nProof\n\n\n\n\n\n\\(F(x) - \\mu f(x) - \\lambda g(x)\\) とおき，\\(F(a) = F(b) = k\\) となるように適当に \\(\\lambda:\\mu\\) を定める．\nこのとき，\n\\[\n\\begin{gather}\n\\mu f(a) - \\lambda g(a) = \\mu f(b) - \\lambda g(b)\\\\\n\\Rightarrow \\mu (f(b) - f(a)) = \\lambda (g(b) - g(a))\\\\\n\\Rightarrow \\mu (f(b) - f(a)) = \\lambda (g(b) - g(a))\\\\\n\\Rightarrow \\mu = g(b) - g(a), \\lambda = f(b) - f(a)\n\\end{gather}\n\\]\nとして，\n\\[\nF(x) = \\{g(b)-g(a)\\}f(x) - \\{f(b)-f(a)\\}g(x)\n\\]\nここで，\\(G(x) = F(x) - k\\) を考える．有界閉区間 \\([a, b]\\) において \\(f(x), g(x)\\) は連続であるので，有界閉区間 \\([a, b]\\) において \\(F(x)\\) および \\(G(x)\\) も連続関数である．関数の連続性より， とある \\(\\xi \\in [a, b]\\) で \\(G(x)\\) は最大値 \\(G(\\xi) = M &lt; \\infty\\) をとる．\n\\(M &gt; 0\\) のとき，\n\\(x = \\xi\\) において \\(\\Delta G \\leq 0\\). 故に\n\n\\(\\Delta x &gt; 0\\) とすれば \\(\\displaystyle\\frac{\\Delta G}{\\Delta x} \\leq 0\\), 従って，\\(G^\\prime(\\xi)\\leq 0\\)\n\\(\\Delta x &lt; 0\\) とすれば \\(\\displaystyle\\frac{\\Delta G}{\\Delta x} \\geq 0\\), 従って，\\(G^\\prime(\\xi)\\geq 0\\)\n\n従って，\\(G^\\prime(\\xi) = 0\\). \\(M = 0\\) のときは，同様に最小値 \\(G(\\xi) = M &gt; -\\infty\\) を考えると \\(G^\\prime(\\xi)\\geq 0\\) を得る．最小値と最大値が \\(0\\) の場合は \\(G(x)\\) が常に \\(0\\) であるので，\\(x \\in (a, b)\\) において \\(G^\\prime(x) = 0\\) は自明．\nこのとき，\\(F(x) - k = G(x)\\) より\n\\[\n\\begin{align}\nF^\\prime(\\xi) =  \\{g(b)-g(a)\\}f^\\prime(\\xi) - \\{f(b)-f(a)\\}g^\\prime(\\xi) = 0\n\\end{align}\n\\]\nよって，\n\\[\n\\frac{f(b) - f(a)}{g(b) - g(a)} = \\frac{f^\\prime(\\xi)}{g^\\prime(\\xi)}\n\\]\nが成立する．\n\n\n\n平均値の定理を幾何学的に考察してみます．独立変数 \\(t\\) について，曲線\n\\[\nx = f(t), y=g(t)\\qquad t \\in [a. b]\n\\]\nを考えます．このとき，\\(t=a, t=b\\) に対応する \\((x, y)\\) をそれぞれ \\(A, B\\) とすると，\\(\\eqref{eq-mean-value}\\) のLHSが弦ABの勾配に対応します． このとき，\\(x = f(t), y=g(t)\\) の曲線上のとある点 \\(P: t= \\xi\\) の接線が弦ABの勾配と平行になることを定理は示しています．\\(f^\\prime(x), g^\\prime(x)\\) は区間内で同時に \\(0\\) にならないと仮定は，曲線が各点において 確定の接線を有することを意味します．\n\nCode\ndef func_x(x):\n    return np.sin(x) + x\n\ndef func_y(x):\n    return x * np.log(x) ** 2\n\ndef tangent(x, x_0):\n    return func_y(x_0) + (x- func_x(x_0)) * (np.log(np.pi/2) ** 2.5)\n\n\nt = np.linspace(1e-18, np.pi/2, 1000)\nt2 = np.linspace(1.8, 2.6, 100)\nx, y = func_x(t), func_y(t)\nt_0 = 1.11\n\n# plot\nplt.plot(x, y, linewidth=2)\n\n# # add line\nplt.plot([0, func_x(np.pi/2)], [0, func_y(np.pi/2)], color=\"gray\")\nplt.text(-0.01, -0.03, \"A\")\nplt.text(2.55, 0.33, \"B\")\n\n# # add tangent\n# plt.text(x_0, sample_func(x_0)+1e-4, \"P: x = $\\exp(-2)$\")\nplt.scatter(func_x(t_0), func_y(t_0), color=\"gray\", linestyle=\"dotted\")\nplt.text(func_x(t_0), -0.02, \"P\")\nplt.plot(t2, tangent(t2, t_0))\n\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 1: \\(t\\in [0,\\pi/2]\\) 区間で定義された \\(x = \\sin(t) +t, y = \\begin{cases}t(\\log(t))^2  & (t\\in(0, \\pi/2))\\\\0 & t = 0\\end{cases}\\)\n\n\n\n\n\n\n\n\n\n🍵 Green Tea Break\n\n\n\n実数空間 \\(\\mathbb R\\) の部分集合 \\(I\\) で定義された関数 \\(f(x)\\) が区間 \\(I\\) の点 \\(a\\) において連続であるとは\n\\[\n\\lim_{x\\to a}f(x) = f(a)\n\\]\nが成り立つことをいいます．\n\\[\nf(t) = \\begin{cases}t(\\log(t))^2  & (t\\in(0, \\pi/2))\\\\0 & t = 0\\end{cases}\n\\]\nはロピタルの定理を用いると，\n\\[\n\\begin{align}\n\\lim_{t\\to 0} t(\\log(t))^2\n    &= \\lim_{t\\to 0} \\frac{(\\log(t))^2}{t^{-1}}\\\\\n    &= \\lim_{t\\to 0} \\frac{2(\\log(t))\\frac{1}{t}}{-t^{-2}}\\\\\n    &= \\lim_{t\\to 0} \\frac{2(\\log(t))}{-t^{-1}}\\\\\n    &= \\lim_{t\\to 0} \\frac{2t^{-1}}{t^{-2}}\\\\\n    &= \\lim_{t\\to 0} 2t = 0\n\\end{align}\n\\]\n以上のように連続性を示すことが出来ます．\n\n\n\nTaylorの公式\n\n\nTheorem 2 \nある区間において．\\(f(x)\\) は第 \\(n\\) 階まで微分可能とする．このときその区間において，\\(a\\) は定点，\\(x\\) を任意の点とするとき\n\\[\n\\begin{gather}\nf(x) = f(a) + \\frac{f^\\prime(a)}{1!}(x-a) + \\frac{f^{\\prime\\prime}(a)}{2!}(x-a)^2 + \\cdots + \\frac{f^{(n-1)}(a)}{(n-1)!}(x-a)^{n-1} + \\frac{f^{(n)}(\\xi)}{(n)!}(x-a)^{n}\\label{eq-taylor}\\\\\n\\text{s.t } \\quad \\xi = a + \\theta(x-a), \\qquad 0 &lt;\\theta&lt;1\n\\end{gather}\n\\]\n\n\n\\(\\frac{f^{(n)}(\\xi)}{(n)!}(x-a)^{n}\\) は \\(R_n\\) と表されることもあり，剰余項とよびます．\n\n\n\n\n\n\n\nProof\n\n\n\n\n\n\\[\nF(x) = f(x) - \\{f(a) + \\frac{f^\\prime(a)}{1!}(x-a) + \\frac{f^{\\prime\\prime}(a)}{2!}(x-a)^2 + \\cdots + \\frac{f^{(n-1)}(a)}{(n-1)!}(x-a)^{n-1}\\}\\label{eq-residual}\n\\]\nとおく．このとき，定義より\n\\[\nF(a) = F^{\\prime}(a) = F^{\\prime\\prime}(a) = \\cdots = F^{n-1}(a) = 0\n\\]\nここで，\n\\[\nG(x) = (x - a)^n\n\\]\nと定義すると第 \\(n\\) 階まで微分可能であり，また \\(G(a) = 0\\)．このとき，中間値の定理より\n\\[\n\\begin{align}\n\\frac{F(x) - F(a)}{G(x) - G(a)}\n    &= \\frac{F(x)}{G(x)}\\\\\n    &= \\frac{F(x)}{(x-a)^n}\\\\\n    &= \\frac{F^\\prime(x_1)}{n(x_1-a)^{n-1}} \\qquad x_1 \\in (a, x)\n\\end{align}\n\\]\n同様に\n\\[\n\\frac{F^\\prime(x_1)}{n(x_1-a)^{n-1}} = \\frac{F^{\\prime\\prime}(x_2)}{n(n-1)(x_2-a)^{n-2}} \\qquad x_2 \\in (a, x_1)\n\\]\n\\(f(x)\\) は第 \\(n\\) 階まで微分可能であるので，\\(F(x)\\) も第 \\(n\\) 階まで微分可能．従って，\n\\[\n\\frac{F(x)}{(x-1)^n} = \\frac{F^{n}(\\xi)}{n!} \\qquad \\exists\\xi \\in (a, x)\n\\]\nつまり\n\\[\nF(x) = \\frac{F^{n}(\\xi)}{n!}(x-a)^n\n\\]\nこれを \\(\\eqref{eq-residual}\\) に代入して整理すると \\(\\eqref{eq-taylor}\\) を得る．\n\n\n\n整式はそれ自身が有限個の項で完結したテイラー展開のしていますし，無限等比級数の公式\n\\[\n\\frac{1}{1 + r} = 1 - r + r^2 - r^3 + \\cdots = \\sum_{i=0}(-r)^i \\qquad (-1 &lt; r &lt; 1)\n\\]\nは \\(x = 1\\) 周りでの関数 \\(f(x) = 1/ x\\) のテイラー展開となっており，\\(x = 1 + r\\) とすると\n\\[\n\\begin{align}\n\\frac{1}{1+r}\n    &= 1 + \\frac{(-1)}{1!}r + \\frac{(-1)\\times(-2)}{2!}r^2 + \\frac{(-1)\\times(-2)\\times(-3)}{3!}r^3 + \\cdots\\\\\n    &= 1 - r + r^2 - r^3 + \\cdots\n\\end{align}\n\\]\nと確認することが出来ます．三角関数も\n\\[\n\\begin{align}\n\\cos x &= 1 - \\frac{1}{2}x^2 + \\frac{1}{24}x^4 - \\cdots\\\\\n\\sin x &= x - \\frac{1}{6}x^3 + \\frac{1}{120}x^5 - \\cdots\n\\end{align}\n\\]\nとテイラー展開することが出来ます．そのため，18世紀までの数学界では，関数は各点周りで冪級数にテイラー展開できるので，微分や積分もテイラー展開を応用して形式的な代数的計算で十分と考えられてました． 19世紀になると任意の関数 \\(f(x)\\) は\n\\[\nf(x) \\sim \\frac{a_0}{2} + \\sum_{n=1}^\\infty(a_n\\cos nx + b_n \\sin nx)\n\\]\nで表すことができるのではないか？という主張が登場し，関数，微分，積分の理論の見直しの必要性が認識されるようになりました．\n\nExample 1 : テイラー展開の例 \n次の関数の点 \\(a\\) のまわりのテイラー展開を剰余項を含めて \\(h^3\\) まで書き下すと以下のようになります\n\\[\n\\begin{align}\n\\log(a+h) &= \\log(a) + \\frac{h}{a} - \\frac{1}{2}\\frac{h^2}{a^2} + \\frac{1}{3}\\frac{h^3}{(a+\\theta h)^3}\\\\\n(a+h)^\\beta &= a^\\beta + \\beta a^{\\beta-1}h + \\frac{\\beta(\\beta-1)}{2!}a^{\\beta-2}h^2+ \\frac{\\beta(\\beta-1)(\\beta-2)}{3!}(a+\\theta h)^{\\beta-3}h^3\n\\end{align}\n\\]\nただし，\\(0 &lt; \\theta &lt; 1\\) とします．\n\n\n\nTaylor展開の応用: \\(e\\) が無理数であることの証明\n\\(f(x) = \\exp(x)\\) を マクローリン展開すると\n\\[\n\\exp(x) = 1 + \\frac{x}{1!} + \\frac{x^2}{2!} + \\frac{x^3}{3!} + \\cdots + \\frac{x^n}{n!} + R_{n+1}\n\\]\n\\(x = 1\\) としたとき，\n\\[\ne =  1 + \\frac{1}{1!} + \\frac{1}{2!} + \\frac{1}{3!} + \\cdots + \\frac{1}{n!} + R_{n+1}\n\\]\n剰余項 \\(R_{n+1}0\\) は\n\\[\nR_{n+1} = \\frac{\\exp(\\theta)}{(n+1)!} &gt; 0 \\quad \\exists\\theta \\in (0, 1)\n\\]\nつまり，\n\\[\nR_{n+1} = \\frac{\\exp(\\theta)}{(n+1)!} &lt; \\frac{3}{(n+1)!}\n\\]\nここで，\\(e\\) を有理数として \\(e = m/n\\) と既約分数で表せると仮定する．このとき，\\(n!e\\) は仮定より整数となるので\n\\[\n1 \\leq n!R_{n+1} = \\frac{\\exp(\\theta)}{n+1} &lt; \\frac{3}{n+1}\n\\]\n従って，\\(n+1 &lt;3\\) つまり \\(n &lt; 2\\)，従って，\\(n = 1\\) を得る．このとき，\\(m\\) は整数なので \\(e = m\\) となるが \\(2 &lt; e &lt; 3\\) より矛盾．従って，\\(e\\) は無理数となる．"
  },
  {
    "objectID": "posts/2025-01-27-differentiation_of_exponential_function/index.html",
    "href": "posts/2025-01-27-differentiation_of_exponential_function/index.html",
    "title": "指数関数の微分",
    "section": "",
    "text": "底 \\(a&gt;1\\) のとき，\n\n指数関数 \\(y = a^x\\) は区間 \\(-\\infty &lt; x &lt; \\infty\\) において連続かつ単調増大で, \\(y \\in (0, \\infty)\\)\n対数関数 \\(y = \\log_a x\\) は \\(y = a^x\\) の逆関数で，区間 \\(0 &lt; x &lt; \\infty\\) において連続かつ単調増大で, \\(y \\in (\\infty, \\infty)\\)\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# PARAMS\nbase = 2\nN = 1000 # data points\nmin_lim = -2\nmax_lim = 5\nx = np.linspace(min_lim, max_lim, N)\n\n# exponential\ny_exp = base ** x\n\n# logarithm\ny_log = np.log(x[x&gt;0]) / np.log(base) \n\n# plot\nfig, ax = plt.subplots(ncols=1)\nax.plot(x, y_exp, label='$ y = a^x$')\nax.plot(x[x&gt;0], y_log, label='$y = \\log_a x$')\nax.plot(x*0.8, x*0.8, label='45 Degree Line', linestyle='--', color='gray')\nax.axhline(0, color='black', linewidth=0.5)\nax.axvline(0, color='black', linewidth=0.5)\nax.set_xlim(min_lim, max_lim)\nax.set_xticks([])\nax.set_yticks([])\nax.text(0, 0, 'O', fontsize=12, ha='right')\nax.text(1, -0.5, '1', fontsize=12, ha='right')\nax.text(0, 1, '1', fontsize=12, ha='right')\nax.set_ylim(min_lim, max_lim)\nax.set_xlabel('$x$')\nax.set_ylabel('$y$')\nfor spine in ax.spines.values():\n    spine.set_visible(False)\nax.legend()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 1: 指数関数と対数関数\n\n\n\n\n\nTheorem 1 \n任意の \\(a &gt; 0\\) に対して，\\(y = a^x\\) の導関数は\n\\[\n\\frac{d(a^x)}{dx} = a^x\\log a\n\\]\n\n\n\n\n\n\n\n\n\nProof\n\n\n\n\n\n\\(a &gt; 1\\) のケースを考える\n\\[\n\\begin{align}\n\\frac{d(a^x)}{dx}\n    &= \\lim_{h\\to 0}\\frac{a^{x+h} - a^x}{h}\\\\\n    &= a^x\\lim_{h\\to 0}\\frac{a^{h} - 1}{h}\\label{base-eq}\n\\end{align}\n\\]\n ▶  \\(h &gt; 0\\)の場合\n\\(h &gt; 0\\) であるならば，\\(a^h &gt; 1\\)．よって\n\\[\na^h = 1 + \\frac{1}{t}\n\\]\nとおくと，\\(t &gt; 0\\)．指数関数の連続性より，\\(h\\to 0\\) のとき，\\(a^h\\to 1\\). 従って，\\(t\\to\\infty\\)．\nここで，\\(\\displaystyle h = \\log_a\\left(1 + \\frac{1}{t}\\right)\\) より\n\\[\n\\begin{align}\n\\frac{a^{h} - 1}{h}\n    & = \\frac{1/t}{\\log_a\\left(1 + \\frac{1}{t}\\right)}\\\\\n    &= \\frac{1}{\\log_a\\left(1 + \\frac{1}{t}\\right)^t}\n\\end{align}\n\\]\n\\[\n\\lim_{t\\to\\infty}\\left(1 + \\frac{1}{t}\\right)^t = e\n\\]\n対数関数 \\(\\log_a(x)\\) は連続関数なので，\\(h\\to 0\\) のとき，\\(\\log_a\\left(1 + \\frac{1}{t}\\right)^t\\to \\log_a e\\)．従って，\n\\[\n\\begin{align}\n\\lim_{h\\to 0}\\frac{a^{h} - 1}{h}\n    &= \\frac{1}{\\log_a e}\\\\\n    &= \\log a\n\\end{align}\n\\]\n ▶  \\(h &lt; 0\\)の場合\n\\(h = -z\\) を満たす \\(z&gt;0\\) を考える．このとき，\n\\[\n\\begin{align}\n\\frac{a^h - 1}{h}\n    &= \\frac{a^{-z} - 1}{-z}\\\\\n    &= \\frac{1 - a^z}{-z}\\frac{1}{a^z}\\\\\n    &= \\frac{a^z - 1}{z}\\frac{1}{a^z}\n\\end{align}\n\\]\n\\(z\\to 0\\) のとき，\\(a^z \\to 1\\) なので\n\\[\n\\frac{a^h - 1}{h}\\to \\log a\n\\]\n従って，\\(a &gt; 1\\) のとき，\\(\\displaystyle \\frac{d(a^x)}{dx} = a^x \\log a\\)\n ▶  \\(0 &lt; a &lt; 1\\) の場合 \n\\(\\eqref{base-eq}\\) と展開したとき，\\(h&gt;0\\) のとき \\(a^h &lt; 1\\) となるので\n\\[\na^h = 1 - \\frac{1}{t}\\qquad(t&gt;0)\n\\]\n指数関数の連続性より, \\(h\\to 0\\) のとき，\\(a^h\\to 0\\)，従って，\\(t\\to\\infty\\)．\n\\[\n\\begin{align}\n\\frac{a^h-1}{h}\n    &= \\frac{-\\frac{1}{t}}{\\log_a(1 - \\frac{1}{t})}\\\\\n    &= -\\frac{1}{\\log_a(1 - \\frac{1}{t})^{t}}\n\\end{align}\n\\]\nここで\n\\[\n\\lim_{t\\to\\infty} (1 - \\frac{1}{t})^{t} = \\frac{1}{e}\n\\]\nであるので，対数関数の連続性より，\\(h\\to 0\\) のとき \\(h\\to\\infty\\) だから\n\\[\n\\log_a\\left(1 - \\frac{1}{t}\\right)^{t}\\to \\log_a\\frac{1}{e} = -\\log_a e\n\\]\n従って，\n\\[\n\\lim_{h\\to 0}\\frac{a^h-1}{h} = \\log a\n\\]\n\\(h&lt;0\\) の場合も同様に示せるので，以上より\n任意の \\(a &gt; 0\\) に対して，\\(y = a^x\\) の導関数は\n\\[\n\\frac{d(a^x)}{dx} = a^x\\log a\n\\]\nが成立する．\n\n\n\n\n\n\\(a &gt; 0\\) としたとき，\n\\[\n\\log a^x = x\\log a\n\\]\nこのとき，両辺を \\(x\\) で微分すると\n\\[\n\\frac{D(a^x)}{a^x} = \\log a\n\\]\n従って，\n\\[\nD(a^x) = a^x\\log a\n\\]\nを得る．"
  },
  {
    "objectID": "posts/2025-01-27-differentiation_of_exponential_function/index.html#指数関数の微分",
    "href": "posts/2025-01-27-differentiation_of_exponential_function/index.html#指数関数の微分",
    "title": "指数関数の微分",
    "section": "",
    "text": "底 \\(a&gt;1\\) のとき，\n\n指数関数 \\(y = a^x\\) は区間 \\(-\\infty &lt; x &lt; \\infty\\) において連続かつ単調増大で, \\(y \\in (0, \\infty)\\)\n対数関数 \\(y = \\log_a x\\) は \\(y = a^x\\) の逆関数で，区間 \\(0 &lt; x &lt; \\infty\\) において連続かつ単調増大で, \\(y \\in (\\infty, \\infty)\\)\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# PARAMS\nbase = 2\nN = 1000 # data points\nmin_lim = -2\nmax_lim = 5\nx = np.linspace(min_lim, max_lim, N)\n\n# exponential\ny_exp = base ** x\n\n# logarithm\ny_log = np.log(x[x&gt;0]) / np.log(base) \n\n# plot\nfig, ax = plt.subplots(ncols=1)\nax.plot(x, y_exp, label='$ y = a^x$')\nax.plot(x[x&gt;0], y_log, label='$y = \\log_a x$')\nax.plot(x*0.8, x*0.8, label='45 Degree Line', linestyle='--', color='gray')\nax.axhline(0, color='black', linewidth=0.5)\nax.axvline(0, color='black', linewidth=0.5)\nax.set_xlim(min_lim, max_lim)\nax.set_xticks([])\nax.set_yticks([])\nax.text(0, 0, 'O', fontsize=12, ha='right')\nax.text(1, -0.5, '1', fontsize=12, ha='right')\nax.text(0, 1, '1', fontsize=12, ha='right')\nax.set_ylim(min_lim, max_lim)\nax.set_xlabel('$x$')\nax.set_ylabel('$y$')\nfor spine in ax.spines.values():\n    spine.set_visible(False)\nax.legend()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 1: 指数関数と対数関数\n\n\n\n\n\nTheorem 1 \n任意の \\(a &gt; 0\\) に対して，\\(y = a^x\\) の導関数は\n\\[\n\\frac{d(a^x)}{dx} = a^x\\log a\n\\]\n\n\n\n\n\n\n\n\n\nProof\n\n\n\n\n\n\\(a &gt; 1\\) のケースを考える\n\\[\n\\begin{align}\n\\frac{d(a^x)}{dx}\n    &= \\lim_{h\\to 0}\\frac{a^{x+h} - a^x}{h}\\\\\n    &= a^x\\lim_{h\\to 0}\\frac{a^{h} - 1}{h}\\label{base-eq}\n\\end{align}\n\\]\n ▶  \\(h &gt; 0\\)の場合\n\\(h &gt; 0\\) であるならば，\\(a^h &gt; 1\\)．よって\n\\[\na^h = 1 + \\frac{1}{t}\n\\]\nとおくと，\\(t &gt; 0\\)．指数関数の連続性より，\\(h\\to 0\\) のとき，\\(a^h\\to 1\\). 従って，\\(t\\to\\infty\\)．\nここで，\\(\\displaystyle h = \\log_a\\left(1 + \\frac{1}{t}\\right)\\) より\n\\[\n\\begin{align}\n\\frac{a^{h} - 1}{h}\n    & = \\frac{1/t}{\\log_a\\left(1 + \\frac{1}{t}\\right)}\\\\\n    &= \\frac{1}{\\log_a\\left(1 + \\frac{1}{t}\\right)^t}\n\\end{align}\n\\]\n\\[\n\\lim_{t\\to\\infty}\\left(1 + \\frac{1}{t}\\right)^t = e\n\\]\n対数関数 \\(\\log_a(x)\\) は連続関数なので，\\(h\\to 0\\) のとき，\\(\\log_a\\left(1 + \\frac{1}{t}\\right)^t\\to \\log_a e\\)．従って，\n\\[\n\\begin{align}\n\\lim_{h\\to 0}\\frac{a^{h} - 1}{h}\n    &= \\frac{1}{\\log_a e}\\\\\n    &= \\log a\n\\end{align}\n\\]\n ▶  \\(h &lt; 0\\)の場合\n\\(h = -z\\) を満たす \\(z&gt;0\\) を考える．このとき，\n\\[\n\\begin{align}\n\\frac{a^h - 1}{h}\n    &= \\frac{a^{-z} - 1}{-z}\\\\\n    &= \\frac{1 - a^z}{-z}\\frac{1}{a^z}\\\\\n    &= \\frac{a^z - 1}{z}\\frac{1}{a^z}\n\\end{align}\n\\]\n\\(z\\to 0\\) のとき，\\(a^z \\to 1\\) なので\n\\[\n\\frac{a^h - 1}{h}\\to \\log a\n\\]\n従って，\\(a &gt; 1\\) のとき，\\(\\displaystyle \\frac{d(a^x)}{dx} = a^x \\log a\\)\n ▶  \\(0 &lt; a &lt; 1\\) の場合 \n\\(\\eqref{base-eq}\\) と展開したとき，\\(h&gt;0\\) のとき \\(a^h &lt; 1\\) となるので\n\\[\na^h = 1 - \\frac{1}{t}\\qquad(t&gt;0)\n\\]\n指数関数の連続性より, \\(h\\to 0\\) のとき，\\(a^h\\to 0\\)，従って，\\(t\\to\\infty\\)．\n\\[\n\\begin{align}\n\\frac{a^h-1}{h}\n    &= \\frac{-\\frac{1}{t}}{\\log_a(1 - \\frac{1}{t})}\\\\\n    &= -\\frac{1}{\\log_a(1 - \\frac{1}{t})^{t}}\n\\end{align}\n\\]\nここで\n\\[\n\\lim_{t\\to\\infty} (1 - \\frac{1}{t})^{t} = \\frac{1}{e}\n\\]\nであるので，対数関数の連続性より，\\(h\\to 0\\) のとき \\(h\\to\\infty\\) だから\n\\[\n\\log_a\\left(1 - \\frac{1}{t}\\right)^{t}\\to \\log_a\\frac{1}{e} = -\\log_a e\n\\]\n従って，\n\\[\n\\lim_{h\\to 0}\\frac{a^h-1}{h} = \\log a\n\\]\n\\(h&lt;0\\) の場合も同様に示せるので，以上より\n任意の \\(a &gt; 0\\) に対して，\\(y = a^x\\) の導関数は\n\\[\n\\frac{d(a^x)}{dx} = a^x\\log a\n\\]\nが成立する．\n\n\n\n\n\n\\(a &gt; 0\\) としたとき，\n\\[\n\\log a^x = x\\log a\n\\]\nこのとき，両辺を \\(x\\) で微分すると\n\\[\n\\frac{D(a^x)}{a^x} = \\log a\n\\]\n従って，\n\\[\nD(a^x) = a^x\\log a\n\\]\nを得る．"
  },
  {
    "objectID": "posts/2025-04-29-shellscript-tips/index.html",
    "href": "posts/2025-04-29-shellscript-tips/index.html",
    "title": "シェルコマンドTips",
    "section": "",
    "text": "直前のコマンドの引数呼び出し\n\n\n\n\n\n\n\n\nコマンド\n動作\nショートカット\n\n\n\n\n!^\n直前のコマンドの最初の引数\n\n\n\n!$\n直前のコマンドの最後の引数\nesc + . または Alt + .\n\n\n!:N\n直前のコマンドのN番目の引数\n\n\n\n!*\n直前のコマンドのすべての引数\n\n\n\n\nAlt + . の特徴\n\nAltを押しながら.を連続で入力すると，一回目は直前，二回目は２回前の最後の引数をsuggestしてくれます．\nesc+ .もセットで押せば同じような挙動となりますが，入力しづらいので Alt + . の方が好みです"
  },
  {
    "objectID": "posts/2025-04-29-shellscript-tips/index.html#シェルスクリプト便利コマンドリスト",
    "href": "posts/2025-04-29-shellscript-tips/index.html#シェルスクリプト便利コマンドリスト",
    "title": "シェルコマンドTips",
    "section": "",
    "text": "直前のコマンドの引数呼び出し\n\n\n\n\n\n\n\n\nコマンド\n動作\nショートカット\n\n\n\n\n!^\n直前のコマンドの最初の引数\n\n\n\n!$\n直前のコマンドの最後の引数\nesc + . または Alt + .\n\n\n!:N\n直前のコマンドのN番目の引数\n\n\n\n!*\n直前のコマンドのすべての引数\n\n\n\n\nAlt + . の特徴\n\nAltを押しながら.を連続で入力すると，一回目は直前，二回目は２回前の最後の引数をsuggestしてくれます．\nesc+ .もセットで押せば同じような挙動となりますが，入力しづらいので Alt + . の方が好みです"
  },
  {
    "objectID": "posts/2025-04-29-shellscript-tips/index.html#zsh-terminal用ショートカットリスト",
    "href": "posts/2025-04-29-shellscript-tips/index.html#zsh-terminal用ショートカットリスト",
    "title": "シェルコマンドTips",
    "section": "Zsh Terminal用ショートカットリスト",
    "text": "Zsh Terminal用ショートカットリスト\n\n\n\n\n\n\nCursor moving\n\n\n\n\n\n\n\n\n\n\n\n\n\nショートカット\nkeybind setting\n動作\n\n\n\n\nctrl + ←\nbindkey '^[[1;5C' backward-word\ncursor backward by one word\n\n\nalt + B\ndefault\ncursor backward by one word\n\n\nctrl + →\nbindkey '^[[1;5D' forward-word\ncursor forward by one word\n\n\nalt + F\ndefault\ncursor forward by one word\n\n\nctrl + A\ndefault\nライン先頭へ移動\n\n\nhome\ndefault\nライン先頭へ移動\n\n\nctrl + E\ndefault\nライン末尾へ移動\n\n\nend\ndefault\nライン末尾へ移動\n\n\n\n\n\n\n\n\n\n\n\n\nSearch\n\n\n\n\n\n\n\n\n\n\n\n\n\nショートカット\nkeybind setting\n動作\n\n\n\n\nctrl + R\ndefault\nReverse search in history\n\n\nctrl + S\ndefault\nForward search in history\n\n\n\n\n\n\n\n\n\n\n\n\nEditing\n\n\n\n\n\n\n\n\n\n\n\n\n\nショートカット\nkeybind setting\n動作\n\n\n\n\nctrl + K\ndefault\nカーソル位置から後ろのwordsをすべて削除\n\n\nctrl + U\ndefault\nライン全消し\n\n\nctrl + Y\ndefault\n削除した文字列をペースト\n\n\nctrl + W\ndefault\nカーソル位置からword block先頭までを削除\n\n\n\n\n\n\n\n\n\n\n\n\nGit\n\n\n\n\n\n\n\n\n\n\n\n\n\nショートカット\nkeybind setting\n動作\n\n\n\n\nctrl + G then ctrl + A\nbindkey \"^G^A\" _git_add\ngit add -u\n\n\nctrl + G then ctrl + home\n\"^G^[[1;5H\" _git_cd\ncd \"$(git root)\"\n\n\nctrl + G then ctrl + S\nbindkey \"^G^S\" _git_status\ngit status -sb\n\n\n\ngit status -sbコマンド\ngit status と git status -sbの違いは出力形式にあります\n\n\ngit status\n\n現在のブランチ、ステージ済み・未ステージの変更、未追跡ファイルなどを詳細に表示\n\n% git status\nOn branch main\nYour branch is up to date with 'origin/main'.\n\nChanges not staged for commit:\n  modified:   file.txt\n\ngit status -sb\n\n短くスクリプト向けの要約を表示\n\n-s で各ファイルの状態を2文字コードで表示（例: Mは変更）\n-b で現在のブランチと追跡情報を先頭に追加\n\n\n% git status -sb\n## main...origin/main\n M file.txt"
  },
  {
    "objectID": "posts/2025-04-29-shellscript-tips/index.html#appendix-1-ansi-escape-sequence",
    "href": "posts/2025-04-29-shellscript-tips/index.html#appendix-1-ansi-escape-sequence",
    "title": "シェルコマンドTips",
    "section": "Appendix-1: ANSI escape sequence",
    "text": "Appendix-1: ANSI escape sequence\n\n\n\n\n\n\n\n\n\nシンボル\n対応コマンド\n説明\n\n\n\n\n^[[\nESC + [\n\n\n\n1;5\nmodifier (5 = Ctrl)\n\n\n\n^A\nCtrl+A\n\n\n\n^G\nCtrl+G\nASCII 7, BEL, bell character\n\n\n^S\nCtrl+S\nASCII 19, XOFF, used for terminal flow control to pause output\n\n\nC\nCursor Right\n\n\n\nD\nCursor Left\n\n\n\nH\nHome key"
  },
  {
    "objectID": "posts/2025-04-29-shellscript-tips/index.html#appendix-2-custom-keybind-setup",
    "href": "posts/2025-04-29-shellscript-tips/index.html#appendix-2-custom-keybind-setup",
    "title": "シェルコマンドTips",
    "section": "Appendix-2: custom keybind setup",
    "text": "Appendix-2: custom keybind setup\n以下のファイルを .zshrc に読み込ませています\n\n\ncustom_keybind.sh\n\n#!/bin/zsh\n#---------------------------------------------------\n# cursor moving command\n#---------------------------------------------------\nbindkey '^[[1;5D' backward-word\nbindkey '^[[1;5C' forward-word\n\n\n#---------------------------------------------------\n# git-related command\n#---------------------------------------------------\nfunction _git_cd() {\n    echo \"cd $(git root)\"\n    cd \"$(git root)\"\n    zle accept-line\n}\nzle -N  _git_cd\n\nfunction _git_status() {\n    echo \"git status -sb\" \n    git status -sb\n    zle accept-line\n    #zle reset-prompt\n}\nzle -N  _git_status  # _git_status関数をgit_status widgetとして登録\n\nfunction _git_add() {\n    echo \"git add -u\" # promptにgit add -uを表示\n    git add -u\n    zle accept-line\n    \n}\nzle -N _git_add  # _git_status関数をgit_status widgetとして登録\n\nfunction _git_commit_amend() {\n    echo \"git commit --amend --no-edit\" # promptにgit commit --amend --no-editを表示\n    git commit --amend --no-edit\n    zle accept-line\n    \n}\nzle -N _git_commit_amend  # _git_commit_amend関数をgit_status widgetとして登録\n\nfunction _git_pull() {\n    echo \"git pull\" # promptにgit add -uを表示\n    git pull\n    zle accept-line\n    \n}\nzle -N _git_pull  # _git_status関数をgit_status widgetとして登録\n\nfunction _git_push() {\n    echo \"git push\" # promptにgit add -uを表示\n    git push\n    zle accept-line\n    \n}\nzle -N _git_push  # _git_status関数をgit_status widgetとして登録\n\n#---------------------------------------------------\n# vscode-related command\n#---------------------------------------------------\nfunction _vscode_cd() {\n    echo \"code-cd\" # promptにgit add -uを表示\n    code-cd\n    zle accept-line\n    \n}\nzle -N _vscode_cd  # _git_status関数をgit_status widgetとして登録\n\n\n#---------------------------------------------------\n# bindkey setup\n#---------------------------------------------------\n# git\nbindkey \"^G^A\" _git_add\nbindkey \"^G^[[1;5H\" _git_cd       # Ctrl + g + Home\nbindkey \"^G^M\" _git_commit_amend\nbindkey \"^G^P\" _git_push\nbindkey \"^G^l\" _git_pull\nbindkey \"^G^S\" _git_status\n\n# vscode related\nbindkey \"^V^[[1;5H\" _vscode_cd       # Ctrl + v + Home"
  },
  {
    "objectID": "posts/2025-02-14-shogi-getting-started/index.html",
    "href": "posts/2025-02-14-shogi-getting-started/index.html",
    "title": "本日の詰将棋: Quiz 1~5",
    "section": "",
    "text": "Figure 1\n\n\n\n\n📘 KeyPoints \n\n初手に５二銀と捨てて，馬の利きを確保するのがポイント"
  },
  {
    "objectID": "posts/2025-02-14-shogi-getting-started/index.html#quiz-1-馬の利き",
    "href": "posts/2025-02-14-shogi-getting-started/index.html#quiz-1-馬の利き",
    "title": "本日の詰将棋: Quiz 1~5",
    "section": "",
    "text": "Figure 1\n\n\n\n\n📘 KeyPoints \n\n初手に５二銀と捨てて，馬の利きを確保するのがポイント"
  },
  {
    "objectID": "posts/2025-02-14-shogi-getting-started/index.html#quiz-2-角よりも銀",
    "href": "posts/2025-02-14-shogi-getting-started/index.html#quiz-2-角よりも銀",
    "title": "本日の詰将棋: Quiz 1~5",
    "section": "Quiz 2: 角よりも銀",
    "text": "Quiz 2: 角よりも銀"
  },
  {
    "objectID": "posts/2025-02-14-shogi-getting-started/index.html#quiz-3-金頭桂",
    "href": "posts/2025-02-14-shogi-getting-started/index.html#quiz-3-金頭桂",
    "title": "本日の詰将棋: Quiz 1~5",
    "section": "Quiz 3: 金頭桂",
    "text": "Quiz 3: 金頭桂\n\n\n\n\n\n\nFigure 2\n\n\n\n\n📘 KeyPoints \n\n竜を切ってからの金頭桂"
  },
  {
    "objectID": "posts/2025-02-14-shogi-getting-started/index.html#quiz-4",
    "href": "posts/2025-02-14-shogi-getting-started/index.html#quiz-4",
    "title": "本日の詰将棋: Quiz 1~5",
    "section": "Quiz 4",
    "text": "Quiz 4\n\n\n\n\n\n\n\n\n\n\n\n派生：５三に歩が存在する場合\n相手玉の逃げ道が少なくなるので，一手早く積ませることが出来ます\n\n\n\n\n\n\nFigure 3"
  },
  {
    "objectID": "posts/2025-02-14-shogi-getting-started/index.html#quiz5-飛車を切る",
    "href": "posts/2025-02-14-shogi-getting-started/index.html#quiz5-飛車を切る",
    "title": "本日の詰将棋: Quiz 1~5",
    "section": "Quiz5: 飛車を切る",
    "text": "Quiz5: 飛車を切る\n\n\n\n\n\n\n\n\n\n\n\n📘 KeyPoints \n\n馬の利きを通すためあえて竜を切る\n金２枚の代わりに斜めのコマ一つ（金一 & 角 or 銀一）の場合でも詰むことができる"
  },
  {
    "objectID": "posts/2025-04-08-probability-matrix-exercise/index.html",
    "href": "posts/2025-04-08-probability-matrix-exercise/index.html",
    "title": "確率行列と固有値",
    "section": "",
    "text": "Exercise 1 \n\\(n\\) 次非負実行列 \\(A = (a_{ij})\\) が\n\\[\n\\sum_{j=1}^n a_{ij} = 1\n\\]\nを満たすとき，\\(A\\) を確率行列と呼ぶ． このとき，以下が成立することを示せ\n\\[\nA\\pmb f = \\pmb f\n\\]\nただし，\\(\\pmb f = (1, \\cdots 1)^T\\)， つまり \\(\\pmb f\\) はすべての成分が1であるような \\(n\\)項列ベクトルであるとする．\n\n\n\n\n\n\n\n\n\nProof\n\n\n\n\n\n\\(A\\pmb f\\) は \\(n\\) 項列ベクトルとなるので，その第 \\(i\\) 項成分を \\(b_i\\) とすると\n\\[\n\\begin{align}\nb_i\n    &= \\sum_{j=1}^n a_{ij}f_j\\\\\n    &= \\sum_{j=1}^n a_{ij} \\quad (\\because f_j = 1)\\\\\n    &= 1\n\\end{align}\n\\]\n従って，\n\\[\nA\\pmb f = (1, \\cdots, 1)^T = \\pmb f\n\\]\n\n\n\n\n\nExercise 2 \n\\(A, B\\) が \\(n\\) 次確率行列であるとき，\\(AB\\) も確率行列であることを示せ\n\n\n\n\n\n\n\n\n\nProof\n\n\n\n\n\n\\(AB = (c_{ij})\\) とするとき，\n\\[\n\\begin{align}\nc_{ij} = \\sum_{k=1}^n a_{ik}b_{kj}\n\\end{align}\n\\]\nとなります．このとき\n\\[\n\\begin{align}\n\\sum_{j=1}^n c_{ij}\n    &= \\sum_{j=1}^n\\sum_{k=1}^n a_{ik}b_{kj}\\\\\n    &= \\sum_{k=1}^n\\sum_{j=1}^n a_{ik}b_{kj}\\\\\n    &= \\sum_{k=1}^n a_{ik}(\\sum_{j=1}^n b_{kj})\\\\\n    &= \\sum_{k=1}^n a_{ik} \\quad (\\because \\sum_{j=1}^n b_{kj} = 1)\\\\\n    &= 1\n\\end{align}\n\\]\n従って，\\(A, B\\) が \\(n\\) 次確率行列であるとき，\\(AB\\) も確率行列である．\n\n\n\n\n\nExercise 3 \n\\(A\\) が確率行列のとき，複素数 \\(\\lambda\\) に対して \\(A\\pmb x = \\lambda \\pmb x\\) となるような列ベクトル \\(\\pmb x \\neq \\pmb 0\\) が存在すれば\n\\[\n|\\lambda| \\leq 1\n\\]\nとなることを示せ．\n\n\n\n\n\n\n\n\n\nProof\n\n\n\n\n\n\\(\\pmb x\\) の成分のうち絶対値が最大となるような成分を \\(|x_p|\\) とすると\n\\[\n\\begin{align}\n\\lambda x_p = \\sum_{i=1}^n a_{pi} x_i\n\\end{align}\n\\]\nここで，両辺について絶対値を取ると\n\\[\n\\begin{align}\n|\\lambda x_p | &= |\\lambda|\\,|x_p|\\\\\n\\left|\\sum_{i=1}^n a_{pi} x_i\\right|\n    & \\leq \\sum_{i=1}^n a_{pi} |x_i| \\quad (\\because\\text{三角不等式})\\\\\n    & \\leq  \\sum_{i=1}^n a_{pi} |x_p|\\\\\n    &= |x_p| \\quad(\\because \\sum_{i=1}^n a_{pi} = 1)\n\\end{align}\n\\]\n従って，\n\\[\n|\\lambda|\\,|x_p| \\leq |x_p| \\Rightarrow |\\lambda|\\leq 1\n\\]"
  },
  {
    "objectID": "posts/2025-04-08-probability-matrix-exercise/index.html#problem",
    "href": "posts/2025-04-08-probability-matrix-exercise/index.html#problem",
    "title": "確率行列と固有値",
    "section": "",
    "text": "Exercise 1 \n\\(n\\) 次非負実行列 \\(A = (a_{ij})\\) が\n\\[\n\\sum_{j=1}^n a_{ij} = 1\n\\]\nを満たすとき，\\(A\\) を確率行列と呼ぶ． このとき，以下が成立することを示せ\n\\[\nA\\pmb f = \\pmb f\n\\]\nただし，\\(\\pmb f = (1, \\cdots 1)^T\\)， つまり \\(\\pmb f\\) はすべての成分が1であるような \\(n\\)項列ベクトルであるとする．\n\n\n\n\n\n\n\n\n\nProof\n\n\n\n\n\n\\(A\\pmb f\\) は \\(n\\) 項列ベクトルとなるので，その第 \\(i\\) 項成分を \\(b_i\\) とすると\n\\[\n\\begin{align}\nb_i\n    &= \\sum_{j=1}^n a_{ij}f_j\\\\\n    &= \\sum_{j=1}^n a_{ij} \\quad (\\because f_j = 1)\\\\\n    &= 1\n\\end{align}\n\\]\n従って，\n\\[\nA\\pmb f = (1, \\cdots, 1)^T = \\pmb f\n\\]\n\n\n\n\n\nExercise 2 \n\\(A, B\\) が \\(n\\) 次確率行列であるとき，\\(AB\\) も確率行列であることを示せ\n\n\n\n\n\n\n\n\n\nProof\n\n\n\n\n\n\\(AB = (c_{ij})\\) とするとき，\n\\[\n\\begin{align}\nc_{ij} = \\sum_{k=1}^n a_{ik}b_{kj}\n\\end{align}\n\\]\nとなります．このとき\n\\[\n\\begin{align}\n\\sum_{j=1}^n c_{ij}\n    &= \\sum_{j=1}^n\\sum_{k=1}^n a_{ik}b_{kj}\\\\\n    &= \\sum_{k=1}^n\\sum_{j=1}^n a_{ik}b_{kj}\\\\\n    &= \\sum_{k=1}^n a_{ik}(\\sum_{j=1}^n b_{kj})\\\\\n    &= \\sum_{k=1}^n a_{ik} \\quad (\\because \\sum_{j=1}^n b_{kj} = 1)\\\\\n    &= 1\n\\end{align}\n\\]\n従って，\\(A, B\\) が \\(n\\) 次確率行列であるとき，\\(AB\\) も確率行列である．\n\n\n\n\n\nExercise 3 \n\\(A\\) が確率行列のとき，複素数 \\(\\lambda\\) に対して \\(A\\pmb x = \\lambda \\pmb x\\) となるような列ベクトル \\(\\pmb x \\neq \\pmb 0\\) が存在すれば\n\\[\n|\\lambda| \\leq 1\n\\]\nとなることを示せ．\n\n\n\n\n\n\n\n\n\nProof\n\n\n\n\n\n\\(\\pmb x\\) の成分のうち絶対値が最大となるような成分を \\(|x_p|\\) とすると\n\\[\n\\begin{align}\n\\lambda x_p = \\sum_{i=1}^n a_{pi} x_i\n\\end{align}\n\\]\nここで，両辺について絶対値を取ると\n\\[\n\\begin{align}\n|\\lambda x_p | &= |\\lambda|\\,|x_p|\\\\\n\\left|\\sum_{i=1}^n a_{pi} x_i\\right|\n    & \\leq \\sum_{i=1}^n a_{pi} |x_i| \\quad (\\because\\text{三角不等式})\\\\\n    & \\leq  \\sum_{i=1}^n a_{pi} |x_p|\\\\\n    &= |x_p| \\quad(\\because \\sum_{i=1}^n a_{pi} = 1)\n\\end{align}\n\\]\n従って，\n\\[\n|\\lambda|\\,|x_p| \\leq |x_p| \\Rightarrow |\\lambda|\\leq 1\n\\]"
  },
  {
    "objectID": "posts/2025-04-08-probability-matrix-exercise/index.html#appendix",
    "href": "posts/2025-04-08-probability-matrix-exercise/index.html#appendix",
    "title": "確率行列と固有値",
    "section": "Appendix",
    "text": "Appendix\n\n\nTheorem 1 : 転置行列の固有値 \n任意の \\(n\\) 次正方行列 \\(A\\) に対して，\\(A\\) の固有値と \\(A^T\\) の固有値は等しい\n\n\n\n\n\n\n\n\n\nProof\n\n\n\n\n\n\\(A\\) の固有値を \\(\\lambda\\) とすると，\\(\\lambda\\) は次の固有方程式の解と対応します．\n\\[\n|\\lambda \\pmb I - A| = 0\n\\]\n行列式は転置不変性，つまり\n\\[\n|\\lambda \\pmb I - A| = |(\\lambda \\pmb I - A)^T|\n\\]\nという性質を持つので\n\\[\n\\begin{align}\n|(\\lambda \\pmb I - A)^T|\n    &= |(\\lambda \\pmb I^T - A^T)|\\\\\n    &= |(\\lambda \\pmb I - A^T)|\\\\\n    &= 0\n\\end{align}\n\\]\n従って，\\(\\lambda\\) は \\(A^T\\) の固有方程式の解となることがわかるので，\\(A\\) の固有値と \\(A^T\\) の固有値は等しいことがわかる．"
  },
  {
    "objectID": "posts/2025-02-05-surveying/index.html",
    "href": "posts/2025-02-05-surveying/index.html",
    "title": "測量法における測量の分類",
    "section": "",
    "text": "測量の分類は，一般的には，\n\n測量の手法\n測量の目的\n\nによって分類され，具体的には，多角測量，水準測量，地形測量，写真測量，地図測量，GISなどがあります．一方，測量法に基づく測量の分類という観点だと，測量法では，測量を\n\n基本測量\n公共測量\n基本測量及び公共測量以外の測量\n\nの三種類に分類しています．\n\n\n\n測量法第4条 \n「基本測量」とは，すべての測量の基礎となる測量で，国土地理院の行うものをいう\n\n基本測量とは以下２つの特徴があります\n\n国土地理院が実施する測量\nすべての測量の基礎となる測量\n\n ▶  基本測量事業内容\n\n\n\n\n\n\n\n測量内容\n説明\n\n\n\n\n基準点測量\n各種測量に地球上の正確な位置と高さを与える国家基準点体系（三角点，水準点等）の整備と維持管理事業\n\n\n地殻変動観測\n準点測量を継続的に行うことにより，地殻の動きをとらえる測量事業\n\n\n地理情報の整備や２万５千分の１地形図等基本図の作成\nデジタル形式の基本図「電子国土基本図」の整備など\n\n\n\n ▶  測量標の保全\n\n測量法第22条 \n何人も，国土地理院の長の承諾を得ないで，基本測量の測量標を移転し，汚損し，その他その効用を害する行為をしてはならない．\n\n\n\n\n\n測量法第5条 \n「公共測量」とは，基本測量以外の測量で次に掲げるものをいい，建物に関する測量その他の局地的測量又は小縮尺図の調製その他の高度の精度を必要としない測量で政令で定めるものを除く．\n\nその測量の実施に要する費用の全部又は一部を国又は公共団体が負担し，又は補助して行う測量\n基本測量又は公共測量の測量成果を使用して次の事業のために実施する測量で国土交通大臣が指定したもの\n\n行政庁の許可，認可その他の処分を受けて行われる事業\nその実施に要する費用の全部又は一部について国又は公共団体の負担又は補助，貸付けその他の助成を受けて行われる事業\n\n\n\n公共測量となる測量は以下の条件すべてを満たす測量だけとなります\n\n測量経費: 測量の費用を国・公共団体が負担・補助して実施する測量\n測量の精度: 高精度な測量に限る．国土地理院が測量計画機関から提出された計画書を審査し必要な精度が得られる方法で行われているか判断\n使用する測量: 基本測量・公共測量成果を２点以上使用する測量１点以下の場合でも規模大の測量\n\n公共測量は日本で実施される測量の大部分を占めています．（source: 国土地理院）\n\n\n\n\n\npie title 測量種類別の事業費の割合\n         \"公共測量\" : 89\n         \"民間の測量\" : 20\n         \"基本測量\": 1\n\n\n\n\n\n\n\n ▶  公共測量の表示等\n\n測量法第37条 \n公共測量を実施する者は，当該測量において設置する測量標に，公共測量の測量標であること及び測量計画機関の名称を表示しなければならない．\n\n公共測量を実施する者は，関係市町村長に対して当該測量を実施するために必要な情報の提供を求めることができる．\n測量計画機関は，公共測量において永久標識を設置したときは，遅滞なく，その種類及び所在地その他国土交通省令で定める事項を国土地理院の長に通知しなければならない．\n測量計画機関は，自ら実施した公共測量の永久標識を移転し，撤去し，又は廃棄したときは，遅滞なく，その種類及び旧所在地その他国土交通省令で定める事項を国土地理院の長に通知しなければならない．\n\n\n測量法第37条2にて，公共測量を実施するにあたって，地元の事情に最も精通していると考えられる関係市町村長に情報の提供を求めることができると規定されています．都道府県知事ではなく関係市町村長であるところに注意が必要です．\n\n\n\n\n測量法第6条 \nこの法律において「基本測量及び公共測量以外の測量」とは，基本測量又は公共測量の測量成果を使用して実施する基本測量及び公共測量以外の測量（建物に関する測量その他の局地的測量又は小縮尺図の調製その他の高度の精度を必要としない測量で政令で定めるものを除く．）をいう．"
  },
  {
    "objectID": "posts/2025-02-05-surveying/index.html#測量法における測量の分類",
    "href": "posts/2025-02-05-surveying/index.html#測量法における測量の分類",
    "title": "測量法における測量の分類",
    "section": "",
    "text": "測量の分類は，一般的には，\n\n測量の手法\n測量の目的\n\nによって分類され，具体的には，多角測量，水準測量，地形測量，写真測量，地図測量，GISなどがあります．一方，測量法に基づく測量の分類という観点だと，測量法では，測量を\n\n基本測量\n公共測量\n基本測量及び公共測量以外の測量\n\nの三種類に分類しています．\n\n\n\n測量法第4条 \n「基本測量」とは，すべての測量の基礎となる測量で，国土地理院の行うものをいう\n\n基本測量とは以下２つの特徴があります\n\n国土地理院が実施する測量\nすべての測量の基礎となる測量\n\n ▶  基本測量事業内容\n\n\n\n\n\n\n\n測量内容\n説明\n\n\n\n\n基準点測量\n各種測量に地球上の正確な位置と高さを与える国家基準点体系（三角点，水準点等）の整備と維持管理事業\n\n\n地殻変動観測\n準点測量を継続的に行うことにより，地殻の動きをとらえる測量事業\n\n\n地理情報の整備や２万５千分の１地形図等基本図の作成\nデジタル形式の基本図「電子国土基本図」の整備など\n\n\n\n ▶  測量標の保全\n\n測量法第22条 \n何人も，国土地理院の長の承諾を得ないで，基本測量の測量標を移転し，汚損し，その他その効用を害する行為をしてはならない．\n\n\n\n\n\n測量法第5条 \n「公共測量」とは，基本測量以外の測量で次に掲げるものをいい，建物に関する測量その他の局地的測量又は小縮尺図の調製その他の高度の精度を必要としない測量で政令で定めるものを除く．\n\nその測量の実施に要する費用の全部又は一部を国又は公共団体が負担し，又は補助して行う測量\n基本測量又は公共測量の測量成果を使用して次の事業のために実施する測量で国土交通大臣が指定したもの\n\n行政庁の許可，認可その他の処分を受けて行われる事業\nその実施に要する費用の全部又は一部について国又は公共団体の負担又は補助，貸付けその他の助成を受けて行われる事業\n\n\n\n公共測量となる測量は以下の条件すべてを満たす測量だけとなります\n\n測量経費: 測量の費用を国・公共団体が負担・補助して実施する測量\n測量の精度: 高精度な測量に限る．国土地理院が測量計画機関から提出された計画書を審査し必要な精度が得られる方法で行われているか判断\n使用する測量: 基本測量・公共測量成果を２点以上使用する測量１点以下の場合でも規模大の測量\n\n公共測量は日本で実施される測量の大部分を占めています．（source: 国土地理院）\n\n\n\n\n\npie title 測量種類別の事業費の割合\n         \"公共測量\" : 89\n         \"民間の測量\" : 20\n         \"基本測量\": 1\n\n\n\n\n\n\n\n ▶  公共測量の表示等\n\n測量法第37条 \n公共測量を実施する者は，当該測量において設置する測量標に，公共測量の測量標であること及び測量計画機関の名称を表示しなければならない．\n\n公共測量を実施する者は，関係市町村長に対して当該測量を実施するために必要な情報の提供を求めることができる．\n測量計画機関は，公共測量において永久標識を設置したときは，遅滞なく，その種類及び所在地その他国土交通省令で定める事項を国土地理院の長に通知しなければならない．\n測量計画機関は，自ら実施した公共測量の永久標識を移転し，撤去し，又は廃棄したときは，遅滞なく，その種類及び旧所在地その他国土交通省令で定める事項を国土地理院の長に通知しなければならない．\n\n\n測量法第37条2にて，公共測量を実施するにあたって，地元の事情に最も精通していると考えられる関係市町村長に情報の提供を求めることができると規定されています．都道府県知事ではなく関係市町村長であるところに注意が必要です．\n\n\n\n\n測量法第6条 \nこの法律において「基本測量及び公共測量以外の測量」とは，基本測量又は公共測量の測量成果を使用して実施する基本測量及び公共測量以外の測量（建物に関する測量その他の局地的測量又は小縮尺図の調製その他の高度の精度を必要としない測量で政令で定めるものを除く．）をいう．"
  },
  {
    "objectID": "posts/2025-02-05-surveying/index.html#測量法と測量の基準",
    "href": "posts/2025-02-05-surveying/index.html#測量法と測量の基準",
    "title": "測量法における測量の分類",
    "section": "測量法と測量の基準",
    "text": "測量法と測量の基準\n\n測量法第11条1項 \n位置は，地理学的経緯度及び平均海面からの高さで表示する． ただし，場合により，直角座標及び平均海面からの高さ，極座標及び平均海面からの高さ又は地心直交座標で表示することができる\n\n測量の基準に関して，位置の表示は原則「位置は，地理学的経緯度及び平均海面からの高さで表示する」ということになっています．\n\n世界測地系\n\n測量法第11条第2項 \n前項第一号の地理学的経緯度は，世界測地系に従つて測定しなければならない．\n\n世界測地系は，概念としてはただ一つのものですが，国ごとに採用する時期や構築に当たっての詳細な手法及び実現精度が異なります．代表例として以下の世界測地系があります：\n\n\n\n\n\n\n\n世界測地系\n特徴\n\n\n\n\nITRF系（国際地球基準座標系）\n地球の重心が原点，X軸をグリニッジ子午線と赤道との交点の方向，Y軸を東経90度の方向，Z軸を北極の方向にとった３次元直交座標(=Z軸は地球の自転軸と一致している)\n\n\nWGS系\nアメリカのGPSに用いられている．高精度・継続性よりむしろリアルタイム性が重要視される軍事，航法，海図，ナビゲーションの分野に適した世界測地系とされている．ITRF系とほぼ同一\n\n\nPZ系\nロシアの測位システムに用いられている\n\n\n\n日本では，ITRF系GRS80楕円体を採用しています．\n\n\n\n\n\n\n🌍: GRS80楕円体\n\n\n\n地球の形状は，自転による遠心力のため扁平な回転楕円体ですが，この楕円体の超半径と扁平率を与えたものを準拠楕円体と呼びます．準拠楕円体の１つであるGRS80楕円体では以下のように定められます\n\n長半径: 6,378,137m\n扁平率: 1/298.257222101\n\n\n\n\n回転楕円体\n\n\n\n\n\n\nジオイド\n\nDef: ジオイド \n平均海面を仮想的に陸地へ延長した面を「ジオイド」と呼ぶ．日本では，日本経緯度原点に最も近い東京湾の平均海面を通る水準面がジオイドと一致するものと考え, 高さの基準としている．ジオイドは重力方向に対して直交しています．\n\n\n\nGeoid\n\n\n\n水は重力の影響を受けて，高いところから低いところへ流れますが，地面が平坦なところでも，重力が小さいところから大きいところへ水が流れます． 地球内部の質量分布の不均一などによって，重力分布は一様ではないため，東京湾平均海面を基準としたジオイドはゆるやかな凹凸をしています．\n日本の土地の高さ（標高）は，東京湾の平均海面を基準（標高０ｍ）として測られています．水が高いこところから低いところへ流れることを表したジオイドを用いて標高が計算されているので．標高の高さと水の流れる方向は対応しているといえます．\n ▶  標高とジオイド高と楕円体高\n\n\n\nジオイド高さと標高と楕円体高\n\n\n\nジオイド高: 衛星測位の高さの基準である楕円体面から「ジオイド」までの高さ，国土地理院が発表している\n楕円体高: GPSや準天頂衛星システム等のGNSS測量で得られる高さで，楕円体面から地表面までの高さ\n\n\\[\n\\text{標高} = \\text{楕円体高} - \\text{ジオイド高}\n\\]"
  },
  {
    "objectID": "posts/2025-04-30-css-unit/index.html",
    "href": "posts/2025-04-30-css-unit/index.html",
    "title": "CSSで使う単位",
    "section": "",
    "text": "CSSで使用する単位一覧\n\n\n\n\n\n\n\n ▶  相対単位\n\n\n\n\n\n\n\n\npx\nモニターの画素(ピクセル)を1とする単位\n\n\n%\n%で割合を指定\n\n\nem\n親要素の大文字Mのフォントサイズを1とする単位\n\n\nex\n親要素の小文字xフォントサイズを1とする単位\n\n\nrem\nルート要素の大文字のフォントサイズを1とする単位\n\n\n\n\n\n ▶  絶対単位\n\n\n\n\n\n\n\n\npt\n1/72インチを1とする単位\n\n\npc\n12ptを1とする単位\n\n\nmm\nミリメートル基準\n\n\ncm\nセンチメートル基準\n\n\nin\nインチを1とする単位\n▶  emの使いどころ\nユーザー環境によってフォントのサイズが変わってしまうWebデザインにおいて，\nといったその時々のフォントサイズに応じたサイズ指定を試みたい場合に，親要素の文字の大きさを単位とするemが役に立ちます．"
  },
  {
    "objectID": "posts/2025-04-30-css-unit/index.html#emとremの違い",
    "href": "posts/2025-04-30-css-unit/index.html#emとremの違い",
    "title": "CSSで使う単位",
    "section": "emとremの違い",
    "text": "emとremの違い\nemもremも相対単位となりますが，remは常に最上位のルート要素のフォントサイズを規準に計算されるという特徴があります．活用例として，remは要素が入れ子になるような場合に，意図せずサイズが変更されるようなリスクを低減することができます．\n\n\n\n\n\n\n\nhtml code example\n\n\n\n\n\n&lt;style&gt;\n  html {\n    font-size: 16px; /* 1rem = 16px */\n  }\n\n  li.em-example {\n    font-size: 1.5em; /* 1.5 × 20px = 30px */\n    color: steelblue;\n  }\n\n  li.rem-example {\n    font-size: 1.5rem; /* 1.5 × 16px = 24px */\n    color: darkorange;\n  }\n&lt;/style&gt;\n\n&lt;ul&gt;\n    &lt;li class=\"em-example\"&gt;This text uses &lt;code&gt;1.5em&lt;/code&gt; font size&lt;/li&gt;\n    &lt;li class=\"em-example\"&gt;This text uses &lt;code&gt;1.5em&lt;/code&gt; font size\n        &lt;ul&gt;\n            &lt;li class=\"em-example\"&gt;This text uses &lt;code&gt;1.5em&lt;/code&gt; (relative to &lt;code&gt;&lt;ul&gt;&lt;/code&gt; font size)&lt;/li&gt;\n    &lt;/li&gt;\n&lt;/ul&gt;\n\n\n&lt;ul&gt;\n    &lt;li class=\"rem-example\"&gt;This text uses &lt;code&gt;1.5rem&lt;/code&gt; font size&lt;/li&gt;\n    &lt;li class=\"rem-example\"&gt;This text uses &lt;code&gt;1.5rem&lt;/code&gt; font size\n        &lt;ul&gt;\n            &lt;li class=\"rem-example\"&gt;This text uses &lt;code&gt;1.5rem&lt;/code&gt; (relative to &lt;code&gt;&lt;ul&gt;&lt;/code&gt; font size)&lt;/li&gt;\n        &lt;/ul&gt;\n    &lt;/li&gt;\n&lt;/ul&gt;\n\n\n\n ▶  emの挙動\n\n\n\n    This text uses 1.5em font size\n    This text uses 1.5em font size\n        \n            This text uses 1.5em (relative to &lt;ul&gt; font size)\n    \n  \n\n ▶  remの挙動\n\n\n\n    This text uses 1.5rem font size\n    This text uses 1.5rem font size\n        \n            This text uses 1.5rem (relative to &lt;ul&gt; font size)\n        \n    \n  \n\n\n\n\n\n\nkey takeaways\n\n\n\n\nemでは入れ子構造となってる&lt;li&gt;セクションについて，直前のフォントサイズ 1.5emにたいして更に 1.5em でフォントサイズを計算している\nremでは入れ子構造となってる&lt;li&gt;セクションでも，ルート要素フォントサイズ16pxを参照して, 1.5remを計算している"
  },
  {
    "objectID": "posts/2025-04-09-vector-outer-product/index.html",
    "href": "posts/2025-04-09-vector-outer-product/index.html",
    "title": "ベクトル空間における外積",
    "section": "",
    "text": "▶  Key Takeaways"
  },
  {
    "objectID": "posts/2025-04-09-vector-outer-product/index.html#ベクトルの外積",
    "href": "posts/2025-04-09-vector-outer-product/index.html#ベクトルの外積",
    "title": "ベクトル空間における外積",
    "section": "ベクトルの外積",
    "text": "ベクトルの外積\n\n\nDefinition 1 : 外積 \n３次元実数空間のベクトル\n\\[\n\\begin{align}\n\\pmb a = (a_1, a_2, a_3)\\\\\n\\pmb b = (b_1, b_2, b_3)\n\\end{align}\n\\]\nに対して，\n\\[\n\\left(\\begin{vmatrix}\na_2 & a_3\\\\\nb_2 & b_3\n\\end{vmatrix},\n- \\begin{vmatrix}\na_1 & a_3\\\\\nb_1 & b_3\n\\end{vmatrix},\n\\begin{vmatrix}\na_1 & a_2\\\\\nb_1 & b_2\n\\end{vmatrix}\n\\right)\n\\]\nを \\(\\pmb a\\) と \\(\\pmb b\\) の外積またはベクトル積 といい，\\(\\pmb a \\times \\pmb b\\) と表す．\n\n\n3次元実ベクトル空間 \\(\\mathbb R^3\\) の標準基低\n\\[\n\\pmb e_1 = (1, 0, 0), \\pmb e_2 = (0, 1, 0), \\pmb e_3 = (0, 0, 1)\n\\]\nを用いて表現すると\n\\[\n\\pmb a \\times \\pmb b = \\begin{vmatrix}\na_2 & a_3\\\\\nb_2 & b_3\n\\end{vmatrix}\\pmb e_1\n- \\begin{vmatrix}\na_1 & a_3\\\\\nb_1 & b_3\n\\end{vmatrix}\\pmb e_2 +\n\\begin{vmatrix}\na_1 & a_2\\\\\nb_1 & b_2\n\\end{vmatrix}\\pmb e_3\n\\]\nと表現することもできます．この式を直感的に理解するとすると\n\\[\n\\begin{vmatrix}\n\\pmb e_1& \\pmb e_2 & \\pmb e_3\\\\\na_1& a_2 & a_3\\\\\nb_1& b_2 & b_3\n\\end{vmatrix}\n\\]\nと対応すると考えることもできます．\n\n\n\n\n\n\nProperty: 外積の性質\n\n\n\n外積について次の法則が成り立つ\n\\[\n\\begin{align}\n&\\pmb a \\times \\pmb b = -\\pmb b\\times \\pmb a\\\\\n&(\\lambda\\pmb a) \\times \\pmb b = \\pmb a \\times (\\lambda \\pmb b ) = \\lambda (\\pmb a \\times \\pmb b )\\\\\n&\\pmb a \\times (\\pmb b  + \\pmb c) = \\pmb a \\times \\pmb b + \\pmb a \\times \\pmb c\\\\\n&\\pmb a \\times \\pmb a = \\pmb 0\n\\end{align}\n\\]\n\n\n\n\n\n\n\n\n\nProof\n\n\n\n\n\n ▶ \\(\\pmb a \\times \\pmb b = -\\pmb b \\times \\pmb a\\)\n\\[\n\\begin{align}\n\\pmb a \\times \\pmb b\n    &= \\begin{vmatrix}\na_2 & a_3\\\\\nb_2 & b_3\n\\end{vmatrix}\\pmb e_1\n- \\begin{vmatrix}\na_1 & a_3\\\\\nb_1 & b_3\n\\end{vmatrix}\\pmb e_2 +\n\\begin{vmatrix}\na_1 & a_2\\\\\nb_1 & b_2\n\\end{vmatrix}\\pmb e_3\\\\\n&= -\\begin{vmatrix}\nb_2 & b_3\\\\\na_2 & a_3\n\\end{vmatrix}\\pmb e_1\n+ \\begin{vmatrix}\nb_1 & b_3\\\\\na_1 & a_3\n\\end{vmatrix}\\pmb e_2 -\n\\begin{vmatrix}\nb_1 & b_2\\\\\na_1 & a_2\n\\end{vmatrix}\\pmb e_3\\\\\n&= (-1)\\left(\n\\begin{vmatrix}\nb_2 & b_3\\\\\na_2 & a_3\n\\end{vmatrix}\\pmb e_1\n- \\begin{vmatrix}\nb_1 & b_3\\\\\na_1 & a_3\n\\end{vmatrix}\\pmb e_2 +\n\\begin{vmatrix}\nb_1 & b_2\\\\\na_1 & a_2\n\\end{vmatrix}\\pmb e_3\\right)\\\\\n&= - \\pmb b \\times \\pmb a\n\\end{align}\n\\]\n ▶  \\((\\lambda\\pmb a) \\times \\pmb b = \\pmb a \\times (\\lambda \\pmb b ) = \\lambda (\\pmb a \\times \\pmb b )\\)\n\\(\\eqref{#eq-determinant-linear}\\) より\n\\[\n\\begin{align}\n(\\lambda\\pmb a) \\times \\pmb b\n    &= \\begin{vmatrix}\n\\lambda a_2 & \\lambda a_3\\\\\nb_2 & b_3\n\\end{vmatrix}\\pmb e_1\n- \\begin{vmatrix}\n\\lambda a_1 & \\lambda a_3\\\\\nb_1 & b_3\n\\end{vmatrix}\\pmb e_2 +\n\\begin{vmatrix}\n\\lambda a_1 & \\lambda a_2\\\\\nb_1 & b_2\n\\end{vmatrix}\\pmb e_3\\\\\n&= \\lambda\\begin{vmatrix}\na_2 & a_3\\\\\nb_2 & b_3\n\\end{vmatrix}\\pmb e_1\n- \\lambda\\begin{vmatrix}\na_1 & a_3\\\\\nb_1 & b_3\n\\end{vmatrix}\\pmb e_2 +\n\\lambda\\begin{vmatrix}\na_1 & a_2\\\\\nb_1 & b_2\n\\end{vmatrix}\\pmb e_3\\\\\n&= \\lambda (\\pmb a\\times \\pmb b )\n\\end{align}\n\\]\n同様に\n\\[\n\\begin{align}\n\\pmb a\\times (\\lambda\\pmb b)  \n    &= \\begin{vmatrix}\na_2 & a_3\\\\\n\\lambda b_2 & \\lambda b_3\n\\end{vmatrix}\\pmb e_1\n- \\begin{vmatrix}\na_1 & a_3\\\\\n\\lambda b_1 & \\lambda b_3\n\\end{vmatrix}\\pmb e_2 +\n\\begin{vmatrix}\na_1 & a_2\\\\\n\\lambda b_1 & \\lambda b_2\n\\end{vmatrix}\\pmb e_3\\\\\n&= \\lambda\\begin{vmatrix}\na_2 & a_3\\\\\nb_2 & b_3\n\\end{vmatrix}\\pmb e_1\n- \\lambda\\begin{vmatrix}\na_1 & a_3\\\\\nb_1 & b_3\n\\end{vmatrix}\\pmb e_2 +\n\\lambda\\begin{vmatrix}\na_1 & a_2\\\\\nb_1 & b_2\n\\end{vmatrix}\\pmb e_3\\\\\n&= \\lambda (\\pmb a\\times \\pmb b )\n\\end{align}\n\\]\n ▶  \\(\\pmb a \\times (\\pmb b  + \\pmb c) = \\pmb a \\times \\pmb b + \\pmb a \\times \\pmb c\\)\n\\[\n\\begin{align}\n&\\pmb a\\times (\\pmb b + \\pmb c)\\\\\n    &=\n        \\begin{vmatrix}\n        a_2 & a_3\\\\\n        b_2 + c_2 &  b_3 + c_3\n        \\end{vmatrix}\\pmb e_1\n        - \\begin{vmatrix}\n        a_1 & a_3\\\\\n         b_1 + c_1 &  b_3 + c_3\n        \\end{vmatrix}\\pmb e_2 +\n        \\begin{vmatrix}\n        a_1 & a_2\\\\\n         b_1 + c_1 &  b_2 + c_2\n        \\end{vmatrix}\\pmb e_3\\\\\n    &=\n        \\left(\n            \\begin{vmatrix}\n            a_2 & a_3\\\\\n            b_2&  b_3\n            \\end{vmatrix}\n            +\n            \\begin{vmatrix}\n            a_2 & a_3\\\\\n            c_2&  c_3\n            \\end{vmatrix}\n        \\right)\\pmb e_1\n        - \\left(\n            \\begin{vmatrix}\n            a_1 & a_3\\\\\n            b_1&  b_3\n            \\end{vmatrix}\n            +\n            \\begin{vmatrix}\n            a_1 & a_3\\\\\n            c_1&  c_3\n            \\end{vmatrix}\n        \\right)\\pmb e_2 +\n        \\left(\n            \\begin{vmatrix}\n            a_1 & a_2\\\\\n            b_1&  b_2\n            \\end{vmatrix}\n            +\n            \\begin{vmatrix}\n            a_1 & a_2\\\\\n            c_1&  c_2\n            \\end{vmatrix}\n        \\right)\\pmb e_3\\\\\n    &= \\left(\n            \\begin{vmatrix}\n            a_2 & a_3\\\\\n            b_2&  b_3\n            \\end{vmatrix}\n        \\pmb e_1\n        -\n            \\begin{vmatrix}\n            a_1 & a_3\\\\\n            b_1&  b_3\n            \\end{vmatrix}\n            \\pmb e_2 +\n            \\begin{vmatrix}\n            a_1 & a_2\\\\\n            b_1&  b_2\n            \\end{vmatrix}\n       \\pmb e_3\\right)+\n       \\left(\n            \\begin{vmatrix}\n            a_2 & a_3\\\\\n            c_2&  c_3\n            \\end{vmatrix}\n        \\pmb e_1\n        -\n            \\begin{vmatrix}\n            a_1 & a_3\\\\\n            c_1&  c_3\n            \\end{vmatrix}\n            \\pmb e_2 +\n            \\begin{vmatrix}\n            a_1 & a_2\\\\\n            c_1&  c_2\n            \\end{vmatrix}\n       \\pmb e_3\\right)\\\\\n    &= \\pmb a \\times \\pmb b + \\pmb a \\times \\pmb c\n\\end{align}\n\\]\n ▶  \\(\\pmb a\\times \\pmb a = \\pmb 0\\)\n\\[\n\\begin{align}\n\\pmb a \\times \\pmb a\n    &= \\begin{vmatrix}\na_2 & a_3\\\\\na_2 & a_3\n\\end{vmatrix}\\pmb e_1\n- \\begin{vmatrix}\na_1 & a_3\\\\\na_1 & a_3\n\\end{vmatrix}\\pmb e_2 +\n\\begin{vmatrix}\na_1 & a_2\\\\\na_1 & a_2\n\\end{vmatrix}\\pmb e_3\\\\\n&= 0\\pmb e_1 - 0\\pmb e_2 + 0\\pmb e_3\\\\\n&= \\pmb 0\n\\end{align}\n\\]\n\n\n\n\nExample 1 \n\\(\\mathbb R^3\\) の標準基底 \\(\\pmb e_1, \\pmb e_2, \\pmb e_3\\) に関して\n\\[\n\\begin{align}\n\\pmb e_1 \\times \\pmb e_2 &= \\left(\\begin{vmatrix}\n0 & 0\\\\\n1 & 0\n\\end{vmatrix}, -\\begin{vmatrix}\n1  & 0\\\\\n0  & 0\n\\end{vmatrix}, \\begin{vmatrix}\n1 & 0 \\\\\n0 & 1\n\\end{vmatrix} \\right)\\\\\n&= \\pmb e_3\n\\end{align}\n\\]\n\\[\n\\begin{align}\n\\pmb e_2 \\times \\pmb e_3 &= \\left(\\begin{vmatrix}\n1 & 0\\\\\n0 & 1\n\\end{vmatrix}, -\\begin{vmatrix}\n0  & 0\\\\\n0  & 1\n\\end{vmatrix}, \\begin{vmatrix}\n0 & 1 \\\\\n0 & 0\n\\end{vmatrix} \\right)\\\\\n&= \\pmb e_1\n\\end{align}\n\\]\n\\[\n\\begin{align}\n\\pmb e_3 \\times \\pmb e_1 &= \\left(\\begin{vmatrix}\n0 & 1\\\\\n0 & 0\n\\end{vmatrix}, -\\begin{vmatrix}\n0  & 1\\\\\n1  & 0\n\\end{vmatrix}, \\begin{vmatrix}\n0 & 0 \\\\\n1 & 0\n\\end{vmatrix} \\right)\\\\\n&= \\pmb e_2\n\\end{align}\n\\]\n\n\n ▶  内積と外積を組み合わせた性質\n\n\nTheorem 1 \n３つのベクトル \\(\\pmb a = (a_1, a_2, a_3), \\pmb b = (b_1, b_2, b_3), \\pmb c = (c_1, c_2, c_3)\\) について，\n\\[\n(\\pmb a\\times \\pmb b, \\pmb c) = (\\pmb a, \\pmb b \\times \\pmb c) = \\begin{vmatrix}\na_1 & a_2 & a_3\\\\\nb_1 & b_2 & b_3\\\\\nc_1 & c_2 & c_3\n\\end{vmatrix}\n\\]\n\n\n\n\n\n\n\n\n\nProof\n\n\n\n\n\n\\[\n\\begin{align}\n(\\pmb a\\times \\pmb b, \\pmb c)\n    &=\n        \\left(\\begin{vmatrix}\n        a_2 & a_3\\\\\n        b_2 & b_3\n        \\end{vmatrix}\\pmb e_1\n        - \\begin{vmatrix}\n        a_1 & a_3\\\\\n        b_1 & b_3\n        \\end{vmatrix}\\pmb e_2 +\n        \\begin{vmatrix}\n        a_1 & a_2\\\\\n        b_1 & b_2\n        \\end{vmatrix}\\pmb e_3, \\pmb c\\right)\\\\\n    &=\n    \\begin{vmatrix}\n        a_2 & a_3\\\\\n        b_2 & b_3\n        \\end{vmatrix}c_1\n        - \\begin{vmatrix}\n        a_1 & a_3\\\\\n        b_1 & b_3\n        \\end{vmatrix}c_2 +\n        \\begin{vmatrix}\n        a_1 & a_2\\\\\n        b_1 & b_2\n        \\end{vmatrix}c_3\\\\\n    &=\n    \\begin{vmatrix}\na_1 & a_2 & a_3\\\\\nb_1 & b_2 & b_3\\\\\nc_1 & c_2 & c_3\n\\end{vmatrix}\n\\end{align}\n\\]\n同様に\n\\[\n\\begin{align}\n(\\pmb a, \\pmb b \\times \\pmb c)\n&= (\\pmb b \\times \\pmb c, \\pmb a)\\\\\n    &=\n        \\left(\\begin{vmatrix}\n        b_2 & b_3\\\\\n        c_2 & c_3\n        \\end{vmatrix}\\pmb e_1\n        - \\begin{vmatrix}\n        b_1 & b_3\\\\\n        c_1 & c_3\n        \\end{vmatrix}\\pmb e_2 +\n        \\begin{vmatrix}\n        b_1 & b_2\\\\\n        c_1 & c_2\n        \\end{vmatrix}\\pmb e_3, \\pmb a\\right)\\\\\n    &=\n        \\begin{vmatrix}\n        b_2 & b_3\\\\\n        c_2 & c_3\n        \\end{vmatrix}a_1\n        - \\begin{vmatrix}\n        b_1 & b_3\\\\\n        c_1 & c_3\n        \\end{vmatrix}a_2 +\n        \\begin{vmatrix}\n        b_1 & b_2\\\\\n        c_1 & c_2\n        \\end{vmatrix} a_3\\\\\n    &=\n    \\begin{vmatrix}\na_1 & a_2 & a_3\\\\\nb_1 & b_2 & b_3\\\\\nc_1 & c_2 & c_3\n\\end{vmatrix}\n\\end{align}\n\\]"
  },
  {
    "objectID": "posts/2025-04-09-vector-outer-product/index.html#外積の幾何学的性質",
    "href": "posts/2025-04-09-vector-outer-product/index.html#外積の幾何学的性質",
    "title": "ベクトル空間における外積",
    "section": "外積の幾何学的性質",
    "text": "外積の幾何学的性質\n\n\nTheorem 2 \n３次元実ベクトル \\(\\pmb a, \\pmb b\\) の外積の大きさは\n\\[\n||\\pmb a\\times \\pmb b|| = ||\\pmb a||\\,||\\pmb b||\\sin \\theta\n\\]\nここで， \\(\\theta\\) は \\(\\pmb a, \\pmb b\\) のなす角であるとする\n\n\n\n\n\n\n\n\nProof\n\n\n\n\n\n\\[\n\\begin{align}\n||\\pmb a\\times \\pmb b|| = ((a_2b_3 - a_3b_2), -(a_1b_3 - a_3b_1), (a_1b_2 - a_2b_1))\n\\end{align}\n\\]\nであるので\n\\[\n\\begin{align}\n||\\pmb a\\times \\pmb b||^2\n    =& a_2^2b_3^2 + a_3^2b_2^2 + a_1^2b_3^2 + a_3^2b_1^2 + a_1^2b_2^2 + a_2^2b_1^2\\\\\n     & - 2(a_2a_3b_2b_3 + a_1a_3b_1b_3+ a_1a_2b_1b_2)\n\\end{align}\n\\]\n続いて\n\\[\n\\cos\\theta = \\frac{(\\pmb a, \\pmb b)}{||\\pmb a||\\,||\\pmb b||}\\quad \\text{s.t. } (0\\leq \\theta \\leq \\pi)\n\\]\nであることから\n\\[\n\\begin{align}\n||\\pmb a||^2\\,||\\pmb b||^2\\sin^2\\theta\n    =& ||\\pmb a||^2\\,||\\pmb b||^2 (1 - \\cos^2\\theta)\\\\\n    =& ||\\pmb a||^2\\,||\\pmb b||^2 - (\\pmb a, \\pmb b)^2\\\\\n    =& (a_1^2 + a_2^2 + a_3^2)(b_1^2 + b_2^2 + b_3^2) - (a_1b_1 + a_2b_2 + a_3b_3)^2\\\\\n    =& a_2^2b_3^2 + a_3^2b_2^2 + a_1^2b_3^2 + a_3^2b_1^2 + a_1^2b_2^2 + a_2^2b_1^2\\\\\n     & - 2(a_2a_3b_2b_3 + a_1a_3b_1b_3+ a_1a_2b_1b_2)\n\\end{align}\n\\]\n従って，\n\\[\n||\\pmb a\\times \\pmb b||^2 = ||\\pmb a||^2\\,||\\pmb b||^2\\sin^2\\theta\n\\]\nこのとき，ノルムは0より大きく，\\(0\\leq \\theta \\leq \\pi\\) では \\(\\sin^2\\theta \\geq 0\\) であるので\n\\[\n||\\pmb a\\times \\pmb b|| = ||\\pmb a||\\,||\\pmb b||\\sin \\theta\n\\]\n\n\n\n ▶  Key Takeaways\n\n上記の定理は２つの３次現実ベクトルの外積のノルムは，２つの３次現実ベクトルが成す平行四辺形の面積と等しいことを意味している\n外積を \\(\\displaystyle\\frac{1}{2}\\) 倍すると，２つの３次現実ベクトルが成す三角形の面積となります．\n\n\nExample 2 \n\\[\n\\begin{align}\n\\pmb a &= (3, 4)\\\\\n\\pmb b &= (5, 2)\n\\end{align}\n\\]\nと二次元ベクトルが与えられているとします．この２つのベクトルがなす三角形の面積は外積を応用すると以下のように計算できるはずです\n\\[\n\\begin{align}\n\\triangle ABO\n    &= \\frac{1}{2}\\sqrt{(0, 0, 3\\times 2 - (4 \\times 5))(0, 0, 3\\times 2 - (4 \\times 5))^T}\\\\\n    &=  7\n\\end{align}\n\\]\n\n上では二次元ベクトル \\((x, y)\\) を \\((x, y, 0)\\) とみなして計算しています\nただし，これは外積の説明というよりかは \\(2\\) 次正方行列の行列式がなぜ面積と対応するのかのほうが適切かも\n\n実際に Pythonで計算してみると\n\nCode\nimport matplotlib.pyplot as plt\nimport numpy as np\n# Define the two vectors\nvector1 = np.array([3, 4])  # Vector 1 (x, y)\nvector2 = np.array([5, 2])  # Vector 2 (x, y)\n\n# Define the origin\norigin = [0, 0]\n\n# Create the plot\nfig, ax = plt.subplots(figsize=(6, 6))\n\n# Plot the vectors\nax.quiver(*origin, vector1[0], vector1[1], angles='xy', scale_units='xy', scale=1, color='r', label='Vector 1')\nax.quiver(*origin, vector2[0], vector2[1], angles='xy', scale_units='xy', scale=1, color='b', label='Vector 2')\n\n# Plot the triangle\ntriangle_x = [0, vector1[0], vector2[0], 0]\ntriangle_y = [0, vector1[1], vector2[1], 0]\nax.fill(triangle_x, triangle_y, color='lightblue', alpha=0.5, label='Triangle')\n\n# Set plot limits\nax.set_xlim(-1, max(vector1[0], vector2[0]) + 1)\nax.set_ylim(-1, max(vector1[1], vector2[1]) + 1)\n\n# Add grid, labels, and legend\nax.grid()\nax.set_aspect('equal')\nax.set_xlabel('X-axis')\nax.set_ylabel('Y-axis')\nax.legend()\n\n# Add title\nax.set_title('2D Vectors and Triangle')\n\n# Show the plot\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 1\n\n\n\n\n\nCode\n## compute area\nfrom shapely import Polygon\ncoords = (origin, vector1, vector2)\npolygon = Polygon(coords)\n\nprint(f\"Area of triangle: {polygon.area}\")\n\n\nArea of triangle: 7.0\n\n\n\n\n\n外積の直交性\n\n\nTheorem 3 \n２つの２次元実ベクトル \\(\\pmb a, \\pmb b\\) について\n\\[\n(\\pmb a\\times \\pmb b, \\pmb a) = (\\pmb a\\times \\pmb b, \\pmb b) = 0\n\\]\nつまり，\n\\[\n\\begin{align}\n\\pmb a\\times \\pmb b \\perp \\pmb a\\\\\n\\pmb a\\times \\pmb b \\perp \\pmb a\n\\end{align}\n\\]\n\n\n\n\n\n\n\n\nProof\n\n\n\n\n\n\\[\n\\begin{align}\n(\\pmb a\\times \\pmb b, \\pmb a)\n    &=  \\begin{vmatrix}\n    a_1 & a_2 & a_3\\\\\n    a_1 & a_2 & a_3\\\\\n    b_1 & b_2 & b_3\n    \\end{vmatrix} = 0\n\\end{align}\n\\]\n同様に\n\\[\n\\begin{align}\n(\\pmb a\\times \\pmb b, \\pmb b)\n    &=  \\begin{vmatrix}\n    b_1 & b_2 & b_3\\\\\n    a_1 & a_2 & a_3\\\\\n    b_1 & b_2 & b_3\n    \\end{vmatrix} = 0\n\\end{align}\n\\]\nなお途中の式変形は行列式の性質「\\(|A| = 0 \\Leftrightarrow \\text{各行ベクトルが一次従属}\\)」を用いている．\n\n\n\n ▶  Key Takeaways\n\n\\(\\pmb a\\times \\pmb b\\) のベクトルの方向は，\\(\\pmb a\\) から \\(\\pmb b\\) へ回転するときの右ねじが進む方向に対応すると言われる\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.mplot3d import Axes3D\n\n# Define the vectors\na = np.array([3, 1, 0])  # Vector b\nb = np.array([1, 2, 0])  # Vector a\n\n# Compute the outer product (cross product)\nouter_product = np.cross(a, b)\n\n# Create a 3D plot\nfig = plt.figure(figsize=(8, 8))\nax = fig.add_subplot(111, projection='3d')\n\n# Plot vector a\nax.quiver(0, 0, 0, a[0], a[1], a[2], color='r', label='Vector a', arrow_length_ratio=0.1)\n\n# Plot vector b\nax.quiver(0, 0, 0, b[0], b[1], b[2], color='b', label='Vector b', arrow_length_ratio=0.1)\n\n# Plot the outer product vector\nax.quiver(0, 0, 0, outer_product[0], outer_product[1], outer_product[2], color='g', label='a × b', arrow_length_ratio=0.1)\n\n# Plot the square\nparallelogram_x = [0, a[0], a[0] + b[0], b[0], 0]\nparallelogram_y = [0, a[1], a[1] + b[1], b[1], 0]\nparallelogram_z = [0, a[2], a[2] + b[2], b[2], 0]\nax.plot_trisurf(parallelogram_x, parallelogram_y, parallelogram_z, color='lightblue', alpha=0.5, label='||a × b||')\n\n\n\n\n# Set plot limits\nmax_range = max(np.linalg.norm(a), np.linalg.norm(b), np.linalg.norm(outer_product)) + 1\nax.set_xlim([-1, 6])\nax.set_ylim([-1, 6])\nax.set_zlim([-1, 6])\n\n# Add labels and legend\nax.set_xlabel('X-axis')\nax.set_ylabel('Y-axis')\nax.set_zlabel('Z-axis')\nax.legend()\n\n# Add title\nax.set_title('3D Vectors and Their Outer Product')\n\n# Tilt the plot\nax.view_init(elev=30, azim=-60) \n\n# Show the plot\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 2"
  },
  {
    "objectID": "posts/2025-04-09-vector-outer-product/index.html#appendix",
    "href": "posts/2025-04-09-vector-outer-product/index.html#appendix",
    "title": "ベクトル空間における外積",
    "section": "Appendix",
    "text": "Appendix\n\n\nLemma 1 \n第 \\(i\\) 行が，２つの行ベクトルの和である行列の行列式は，他の行は同じで第 \\(i\\) 行は各々のベクトルをとった行列の行列式となる．すなわち，\n\\[\n\\left|\n\\begin{array}{ccc}\na_{11} & \\cdots & a_{1n} \\\\\n\\vdots &        & \\vdots \\\\\nb_{i1} + c_{i1} & \\cdots & b_{in} + c_{in} \\\\\n\\vdots &        & \\vdots \\\\\na_{n1} & \\cdots & a_{nn}\n\\end{array}\n\\right|\n=\n\\left|\n\\begin{array}{ccc}\na_{11} & \\cdots & a_{1n} \\\\\n\\vdots &        & \\vdots \\\\\nb_{i1} & \\cdots & b_{in}\\\\\n\\vdots &        & \\vdots \\\\\na_{n1} & \\cdots & a_{nn}\n\\end{array}\n\\right|\n+\n\\left|\n\\begin{array}{ccc}\na_{11} & \\cdots & a_{1n} \\\\\n\\vdots &        & \\vdots \\\\\nc_{i1} & \\cdots & c_{in} \\\\\n\\vdots &        & \\vdots \\\\\na_{n1} & \\cdots & a_{nn}\n\\end{array}\n\\right|\n\\]\n\n\nLemma 1 より以下もわかります\n\\[\n\\left|\n\\begin{array}{ccc}\na_{11} & \\cdots & a_{1n} \\\\\n\\vdots &        & \\vdots \\\\\n\\lambda a_{i1} & \\cdots & \\lambda a_{in} \\\\\n\\vdots &        & \\vdots \\\\\na_{n1} & \\cdots & a_{nn}\n\\end{array}\n\\right|\n= \\lambda\n\\left|\n\\begin{array}{ccc}\na_{11} & \\cdots & a_{1n} \\\\\n\\vdots &        & \\vdots \\\\\na_{i1} & \\cdots & a_{in} \\\\\n\\vdots &        & \\vdots \\\\\na_{n1} & \\cdots & a_{nn}\n\\end{array}\n\\right|\\label{#eq-determinant-linear}\n\\]\n\n余因子と行列式\n\n\nDefinition 2 : 余因子(cofactor) \n\\(n\\) 次の正方行列 \\(A = (a_{ij})\\) から，その第 \\(i\\) 行と第 \\(j\\) 列を取り除いて得られる \\((n-1)\\) 次の正方行列を \\(A_{ij}\\) と表記するとします． このとき \\(a_{ij}\\) の余因子 \\(\\tilde{a}_{ij}\\) は以下のように定義される\n\\[\n\\tilde{a}_{ij} = (-1)^{i+j}|A_{ij}|\n\\]\nまたは\n\\[\n\\tilde{a}_{ij} = (-1)^{i+j}\n\\left|\n\\begin{array}{cccccc}\na_{11} & \\cdots & a_{1(j-1)} & a_{1(j+1)} & \\cdots & a_{1n} \\\\\n\\vdots &        & \\vdots     & \\vdots     &        & \\vdots \\\\\na_{(i-1)1} & \\cdots & \\cdots & \\cdots & \\cdots & a_{(i-1)n} \\\\\na_{(i+1)1} & \\cdots & \\cdots & \\cdots & \\cdots & a_{(i+1)n} \\\\\n\\vdots &        & \\vdots     & \\vdots     &        & \\vdots \\\\\na_{n1} & \\cdots & a_{n(j-1)} & a_{n(j+1)} & \\cdots & a_{nn}\n\\end{array}\n\\right|\n\\]\n\n\n\nExample 3 \n\\[r\nA = \\left(\\begin{array}{ccc}\n1 & 2 & 0\\\\\n3 & 5 & -1\\\\\n4 & 6 & 7\n\\end{array}\\right)\n\\]\nについて，\\(\\tilde{a}_{11}, \\tilde{a}_{12}, \\tilde{a}_{13}\\) はそれぞれ以下のように計算されます\n\\[\n\\begin{align}\n\\tilde{a}_{11} &= (-1)^2 \\left(\\begin{vmatrix}5 & -1\\\\6&7\\end{vmatrix}\\right) = 41\\\\\n\\tilde{a}_{12} &= (-1)^3 \\left(\\begin{vmatrix}3 & -1\\\\4&7\\end{vmatrix}\\right) = -25\\\\\n\\tilde{a}_{13} &= (-1)^4 \\left(\\begin{vmatrix}3 & 5\\\\4&6\\end{vmatrix}\\right) = -2\n\\end{align}\n\\]\n\n\n\n\nTheorem 4 : 行列式の展開 \n\\[\na_{i1}\\tilde a_{i1} + a_{i2}\\tilde a_{i2} + \\cdots + a_{in}\\tilde a_{in} = |A|\n\\]\n\n\n\n\n\n\n\n\n\nProof\n\n\n\n\n\n与えられた行列 \\(A = (a_{ij})\\) の第 \\(i\\) 行は\n\\[\n(a_{i1}, \\cdots, a_{in}) = (a_{i1}, 0, \\cdots, 0) + (0, a_{i2}, \\cdots, 0) \\cdots + (0, \\cdots, 0, a_{in})\n\\]\nと線型結合で表せるので，Lemma 1 より\n\\[\n|A|\n=\n\\left|\n\\begin{array}{cccc}\na_{11} &\\cdots & \\cdots & a_{1n} \\\\\n\\vdots & &       & \\vdots \\\\\na_{11} & 0 & \\cdots & 0 \\\\\n\\vdots &      &  & \\vdots \\\\\na_{n1} &\\cdots &\\cdots & a_{nn}\n\\end{array}\n\\right|\n+\n\\left|\n\\begin{array}{cccc}\na_{11} &\\cdots & \\cdots & a_{1n} \\\\\n\\vdots & &       & \\vdots \\\\\n0 & a_{12} & 0 \\cdots & 0 \\\\\n\\vdots &      &  & \\vdots \\\\\na_{n1} &\\cdots &\\cdots & a_{nn}\n\\end{array}\n\\right|\n+ \\cdots +\n\\left|\n\\begin{array}{cccc}\na_{11} &\\cdots & \\cdots & a_{1n} \\\\\n\\vdots & &       & \\vdots \\\\\n0 & \\cdots& \\cdots 0 & a_{in} \\\\\n\\vdots &      &  & \\vdots \\\\\na_{n1} &\\cdots &\\cdots & a_{nn}\n\\end{array}\n\\right|\\label{#eq-additive}\n\\]\nRHSの第 \\(j\\) 番目の行列式の計算を考える．このとき，行を１つ交換するたびに行列式は \\(-1\\) 倍されることから\n\\[\n\\left|\n\\begin{array}{ccccc}\na_{11} &\\cdots &\\cdots& \\cdots & a_{1n} \\\\\n\\vdots & &   &    & \\vdots \\\\\n0 & \\cdots  &a_{ij} & \\cdots & 0 \\\\\n\\vdots &   &   &  & \\vdots \\\\\na_{n1} &\\cdots &\\cdots &\\cdots & a_{nn}\n\\end{array}\n\\right|\n=\n(-1)^{i-1}\n\\left|\n\\begin{array}{ccccc}\n0 & \\cdots  &a_{ij} & \\cdots & 0 \\\\\na_{11} &\\cdots &\\cdots& \\cdots & a_{1n} \\\\\n\\vdots & &   &    & \\vdots \\\\\n\\vdots &   &   &  & \\vdots \\\\\na_{n1} &\\cdots &\\cdots &\\cdots & a_{nn}\n\\end{array}\n\\right|\n\\]\n列を１つ交換するたびに行列式は \\(-1\\) 倍されることから\n\\[\n\\left|\n\\begin{array}{ccccc}\n0 & \\cdots  &a_{ij} & \\cdots & 0 \\\\\na_{11} &\\cdots &\\cdots& \\cdots & a_{1n} \\\\\n\\vdots & &   &    & \\vdots \\\\\n\\vdots &   &   &  & \\vdots \\\\\na_{n1} &\\cdots &\\cdots &\\cdots & a_{nn}\n\\end{array}\n\\right|\n=\n(-1)^{j-1}\n\\left|\n\\begin{array}{ccccc}\na_{ij} &0 & \\cdots & \\cdots & 0 \\\\\na_{1j} &a_{11} &\\cdots & \\cdots & a_{1n} \\\\\n\\vdots &\\vdots & &       & \\vdots \\\\\n\\vdots &\\vdots &   &     & \\vdots \\\\\na_{nj} &a_{n1} &\\cdots  &\\cdots & a_{nn}\n\\end{array}\n\\right|\n\\]\n従って，\n\\[\n\\begin{align}\n\\left|\n\\begin{array}{ccccc}\na_{11} &\\cdots &\\cdots& \\cdots & a_{1n} \\\\\n\\vdots & &   &    & \\vdots \\\\\n0 & \\cdots  &a_{ij} & \\cdots & 0 \\\\\n\\vdots &   &   &  & \\vdots \\\\\na_{n1} &\\cdots &\\cdots &\\cdots & a_{nn}\n\\end{array}\n\\right|\n&= (-1)^{i+j-2}\na_{ij}\n\\left|\n\\begin{array}{cccc}\na_{11} &\\cdots & \\cdots & a_{1n} \\\\\n\\vdots & &       & \\vdots \\\\\n\\vdots &   &     & \\vdots \\\\\na_{n1} &\\cdots  &\\cdots & a_{nn}\n\\end{array}\n\\right|\\\\\n&= (-1)^{i+j-2} a_{ij}|A_{ij}|\\\\\n&= a_{ij}(-1)^{i+j-2}|A_{ij}|\\\\\n&= a_{ij}\\tilde a_{ij}\n\\end{align}\n\\]\n\\(\\eqref{#eq-additive}\\) より\n\\[\n|A| = \\sum_{j=1}^na_{ij}\\tilde a_{ij}\n\\]"
  },
  {
    "objectID": "posts/2025-02-20-sort-pivot-table/index.html",
    "href": "posts/2025-02-20-sort-pivot-table/index.html",
    "title": "pivot tableのcolumn, rowのsort",
    "section": "",
    "text": "Exercise 1 \n\n\nCode\nimport numpy as np\nimport pandas as pd\n\nnp.random.seed(42)\n\ndef random_choice_from_list(\n    candidate: list | np.ndarray,\n    sampling_size: int,\n    p: list | tuple | np.ndarray = None,\n):\n    if sampling_size &lt;= 0:\n        raise ValueError(\"sampling_size must be greater than 0.\")\n\n    if p is None:\n        p = np.repeat(1 / len(candidate), sampling_size)\n\n    if min(p) &lt; 0 or max(p) &gt; 1:\n        raise ValueError(\"All probabilities in 'p' must be between 0 and 1 inclusive.\")\n\n    if not np.isclose(sum(p), 1):\n        raise ValueError(\"The probabilities in 'p' must sum to 1.\")\n\n    return np.random.choice(candidate, size=sampling_size, p=p)\n\n\n# Params\nN = 100\nA_list = [\"H\", \"He\", \"Li\", \"Be\", \"B\", \"C\", \"N\", \"O\", \"F\", \"Ne\"]\nA_prob = np.array([1, 4, 3, 4, 1, 6, 7, 8, 9, 10])\nA_prob = A_prob / sum(A_prob)\n\nB_list = [\"one\", \"two\", \"three\", \"four\"]\nB_prob = np.array([7, 8, 6, 1])\nB_prob = B_prob / sum(B_prob)\n\n\n# DGP\ndf = pd.DataFrame(\n    {\n        \"element\": random_choice_from_list(A_list, N, A_prob),\n        \"class\": random_choice_from_list(B_list, N, B_prob),\n        \"density\": np.random.uniform(0, 1, N),\n    }\n)\n\ndf.head()\n\n\n\n\n\n\n\n\n\nelement\nclass\ndensity\n\n\n\n\n0\nN\none\n0.642032\n\n\n1\nNe\ntwo\n0.084140\n\n\n2\nF\none\n0.161629\n\n\n3\nO\ntwo\n0.898554\n\n\n4\nBe\nthree\n0.606429\n\n\n\n\n\n\n\n ▶  問題設定\n\n上記のデータについて (element, class) をkey，frequencyをvalueとした二次元分割表を作成する\n二次元分割表をcolumn, rowそれぞれの方向について，合計frequencyに基づいたsortを行う"
  },
  {
    "objectID": "posts/2025-02-20-sort-pivot-table/index.html#問題設定",
    "href": "posts/2025-02-20-sort-pivot-table/index.html#問題設定",
    "title": "pivot tableのcolumn, rowのsort",
    "section": "",
    "text": "Exercise 1 \n\n\nCode\nimport numpy as np\nimport pandas as pd\n\nnp.random.seed(42)\n\ndef random_choice_from_list(\n    candidate: list | np.ndarray,\n    sampling_size: int,\n    p: list | tuple | np.ndarray = None,\n):\n    if sampling_size &lt;= 0:\n        raise ValueError(\"sampling_size must be greater than 0.\")\n\n    if p is None:\n        p = np.repeat(1 / len(candidate), sampling_size)\n\n    if min(p) &lt; 0 or max(p) &gt; 1:\n        raise ValueError(\"All probabilities in 'p' must be between 0 and 1 inclusive.\")\n\n    if not np.isclose(sum(p), 1):\n        raise ValueError(\"The probabilities in 'p' must sum to 1.\")\n\n    return np.random.choice(candidate, size=sampling_size, p=p)\n\n\n# Params\nN = 100\nA_list = [\"H\", \"He\", \"Li\", \"Be\", \"B\", \"C\", \"N\", \"O\", \"F\", \"Ne\"]\nA_prob = np.array([1, 4, 3, 4, 1, 6, 7, 8, 9, 10])\nA_prob = A_prob / sum(A_prob)\n\nB_list = [\"one\", \"two\", \"three\", \"four\"]\nB_prob = np.array([7, 8, 6, 1])\nB_prob = B_prob / sum(B_prob)\n\n\n# DGP\ndf = pd.DataFrame(\n    {\n        \"element\": random_choice_from_list(A_list, N, A_prob),\n        \"class\": random_choice_from_list(B_list, N, B_prob),\n        \"density\": np.random.uniform(0, 1, N),\n    }\n)\n\ndf.head()\n\n\n\n\n\n\n\n\n\nelement\nclass\ndensity\n\n\n\n\n0\nN\none\n0.642032\n\n\n1\nNe\ntwo\n0.084140\n\n\n2\nF\none\n0.161629\n\n\n3\nO\ntwo\n0.898554\n\n\n4\nBe\nthree\n0.606429\n\n\n\n\n\n\n\n ▶  問題設定\n\n上記のデータについて (element, class) をkey，frequencyをvalueとした二次元分割表を作成する\n二次元分割表をcolumn, rowそれぞれの方向について，合計frequencyに基づいたsortを行う"
  },
  {
    "objectID": "posts/2025-02-20-sort-pivot-table/index.html#solution-with-pandas",
    "href": "posts/2025-02-20-sort-pivot-table/index.html#solution-with-pandas",
    "title": "pivot tableのcolumn, rowのsort",
    "section": "Solution with pandas",
    "text": "Solution with pandas\n\n\n\n\n\n\n\nTask 1: (element, class) をkey，frequencyをvalueとした二次元分割表を作成する\n\n\n\n\n\npandas.pivot_tableを用いればかんたんに実行できます．\n\n\nCode\n# Compute the pivot table\npivot_table = pd.pivot_table(\n    df,\n    index=\"element\",  # Rows\n    columns=\"class\",  # Columns\n    aggfunc=\"size\",  # Frequency count\n    fill_value=0,  # Fill missing values with 0\n)\n\npivot_table\n\n\n\n\n\n\n\n\nclass\nfour\none\nthree\ntwo\n\n\nelement\n\n\n\n\n\n\n\n\nBe\n0\n4\n5\n1\n\n\nC\n0\n4\n4\n6\n\n\nF\n0\n6\n4\n6\n\n\nH\n0\n0\n0\n1\n\n\nHe\n0\n4\n2\n5\n\n\nLi\n1\n2\n3\n1\n\n\nN\n1\n4\n2\n1\n\n\nNe\n0\n5\n4\n7\n\n\nO\n1\n6\n4\n6\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTask 2: 二次元分割表をcolumn, rowそれぞれの方向について，合計frequencyに基づいたsortを行う\n\n\n\n\n\npivot table化された pandas.DataFrame に対するソート操作は\n\nrow操作 ; .loc のindexの操作\ncolumn操作: .loc のcolumnの操作\n\nとなります．\n ▶  rowのsort\n\n\nCode\npivot_table = pivot_table.loc[\n    pivot_table.sum(axis=1).sort_values(ascending=False).index\n]\npivot_table\n\n\n\n\n\n\n\n\nclass\nfour\none\nthree\ntwo\n\n\nelement\n\n\n\n\n\n\n\n\nO\n1\n6\n4\n6\n\n\nNe\n0\n5\n4\n7\n\n\nF\n0\n6\n4\n6\n\n\nC\n0\n4\n4\n6\n\n\nHe\n0\n4\n2\n5\n\n\nBe\n0\n4\n5\n1\n\n\nN\n1\n4\n2\n1\n\n\nLi\n1\n2\n3\n1\n\n\nH\n0\n0\n0\n1\n\n\n\n\n\n\n\n ▶  columnのsort\n\n\nCode\npivot_table = pivot_table.loc[:, pivot_table.sum(axis=0).sort_values(ascending=False).index]\npivot_table\n\n\n\n\n\n\n\n\nclass\none\ntwo\nthree\nfour\n\n\nelement\n\n\n\n\n\n\n\n\nO\n6\n6\n4\n1\n\n\nNe\n5\n7\n4\n0\n\n\nF\n6\n6\n4\n0\n\n\nC\n4\n6\n4\n0\n\n\nHe\n4\n5\n2\n0\n\n\nBe\n4\n1\n5\n0\n\n\nN\n4\n1\n2\n1\n\n\nLi\n2\n1\n3\n1\n\n\nH\n0\n1\n0\n0\n\n\n\n\n\n\n\n ▶  検証\n\n\nCode\npivot_table_total = pivot_table.copy()\n\n# row sum\npivot_table_total['total'] = pivot_table_total.sum(axis=1)\n\n# column sum\npivot_table_total.loc['column_sum'] =  pivot_table_total.sum(axis=0)\n\n# 検証\npivot_table_total\n\n\n\n\n\n\n\n\nclass\none\ntwo\nthree\nfour\ntotal\n\n\nelement\n\n\n\n\n\n\n\n\n\nO\n6\n6\n4\n1\n17\n\n\nNe\n5\n7\n4\n0\n16\n\n\nF\n6\n6\n4\n0\n16\n\n\nC\n4\n6\n4\n0\n14\n\n\nHe\n4\n5\n2\n0\n11\n\n\nBe\n4\n1\n5\n0\n10\n\n\nN\n4\n1\n2\n1\n8\n\n\nLi\n2\n1\n3\n1\n7\n\n\nH\n0\n1\n0\n0\n1\n\n\ncolumn_sum\n35\n34\n28\n3\n100"
  },
  {
    "objectID": "posts/2025-02-20-sort-pivot-table/index.html#visualization",
    "href": "posts/2025-02-20-sort-pivot-table/index.html#visualization",
    "title": "pivot tableのcolumn, rowのsort",
    "section": "Visualization",
    "text": "Visualization\n\n可視化方針 \n\nclass出現割合はelement毎に大きく異なるのかみたい\nfrequencyそのままで比較すると出現割合比較にならないので，axis = 1の方向で割合として計算する(以後，normalized_pivotと呼ぶ)\nnormalized_pivotをheatmapで可視化する，可視化の際に出現頻度を右側に参照できるようにする(sample sizeが小さいところは無視したい)\n\n\n ▶  normalized_pivot の作成\n\n\nCode\nnormalized_pivot = pivot_table.div(pivot_table.sum(axis=1), axis=0)\nnormalized_pivot\n\n\n\n\n\n\n\n\nclass\none\ntwo\nthree\nfour\n\n\nelement\n\n\n\n\n\n\n\n\nO\n0.352941\n0.352941\n0.235294\n0.058824\n\n\nNe\n0.312500\n0.437500\n0.250000\n0.000000\n\n\nF\n0.375000\n0.375000\n0.250000\n0.000000\n\n\nC\n0.285714\n0.428571\n0.285714\n0.000000\n\n\nHe\n0.363636\n0.454545\n0.181818\n0.000000\n\n\nBe\n0.400000\n0.100000\n0.500000\n0.000000\n\n\nN\n0.500000\n0.125000\n0.250000\n0.125000\n\n\nLi\n0.285714\n0.142857\n0.428571\n0.142857\n\n\nH\n0.000000\n1.000000\n0.000000\n0.000000\n\n\n\n\n\n\n\n ▶  可視化コード\n\n\nCode\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n\n# Plot heatmap\nfig, ax = plt.subplots(1, 2, figsize=(10, 6), gridspec_kw={\"width_ratios\": [3, 1]})\n\nsns.heatmap(normalized_pivot, annot=True, fmt=\".2f\", cmap=\"PuBu\", ax=ax[0])\nax[0].set_title(\"Heatmap of Normalized Pivot Table\")\nax[0].set_ylabel(\"Element\")\nax[0].set_xlabel(\"Class\")\n\nsns.barplot(\n    y=pivot_table.index,\n    x=pivot_table.sum(axis=1),\n    alpha=0.8,\n    color=\"#0047AB\",\n    orient=\"h\",\n    ax=ax[1],\n)\nax[1].set_title(\"Element Frequency Barplot\")\nax[1].set_xlabel(\"Frequency\")\n\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n🍵 color mapのカスタマイズ\n\n\n\ncolor sequenceをlightcoral, ivory, Dodgersblue という順番にしたい場合は\n\n\nCode\nfrom matplotlib.colors import LinearSegmentedColormap\n\ncustom_cpam = LinearSegmentedColormap.from_list(\"lightcoral_ivory_blue\", [\"#F08080\", \"#FFFFF0\", \"#1E90FF\"])\n\n\nとすることで自分好みにカスタマイズすることができます．\n\n\nCode\n# Plot heatmap\nfig, ax = plt.subplots(1, 2, figsize=(10, 6), gridspec_kw={\"width_ratios\": [3, 1]})\n\nsns.heatmap(normalized_pivot, annot=True, fmt=\".2f\", cmap=custom_cpam , ax=ax[0])\nax[0].set_title(\"Heatmap of Normalized Pivot Table\")\nax[0].set_ylabel(\"Element\")\nax[0].set_xlabel(\"Class\")\n\nsns.barplot(\n    y=pivot_table.index,\n    x=pivot_table.sum(axis=1),\n    alpha=1,\n    color=\"#6699CC\",\n    orient=\"h\",\n    ax=ax[1],\n)\nax[1].set_title(\"Element Frequency Barplot\")\nax[1].set_xlabel(\"Frequency\")\n\nplt.tight_layout()\nplt.show()"
  },
  {
    "objectID": "posts/2025-02-04-add-distance-measurement/index.html",
    "href": "posts/2025-02-04-add-distance-measurement/index.html",
    "title": "単曲線と追加距離の計算",
    "section": "",
    "text": "▶  基本用語"
  },
  {
    "objectID": "posts/2025-02-04-add-distance-measurement/index.html#基本問題-曲線の長さを求める",
    "href": "posts/2025-02-04-add-distance-measurement/index.html#基本問題-曲線の長さを求める",
    "title": "単曲線と追加距離の計算",
    "section": "基本問題: 曲線の長さを求める",
    "text": "基本問題: 曲線の長さを求める\n\n\nExercise 1 \n下図に示すような単曲線ABを含む路線の中心線を設置することになった．\n\n扇形 \\(OAB\\) の半径 \\(r = 300\\)\n\\(\\displaystyle\\angle (IP) = \\frac{\\pi}{3}\\)\n\\(IP\\) までの追加距離を623(中心杭はAの手前にあるとする)\n\nとする．このとき，曲線の始点 \\(A\\) と 曲線の終点 \\(B\\) それぞれの追加距離を求めよ．なお，直線 \\(A(IP)\\) と \\(B(IP)\\) はそれぞれ円の接線であるとする．\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n\ndef draw_circle_with_two_tangent(x0, y0, r, ax, theta_start=0, theta_end=2 * np.pi, notations=('O', 'A', 'B', 'IP')):\n    # Generate circle points\n    theta = np.linspace(theta_start, theta_end, 720)\n    x_circle = x0 + r * np.cos(theta)\n    y_circle = y0 + r * np.sin(theta)\n\n    # plot\n    ax.plot(x_circle, y_circle, \"gray\", label=\"Circle (r={radius})\")\n    ax.plot([x0, x_circle[0]], [y0, y_circle[0]], \"gray\", linestyle=\"--\")\n    ax.plot([x0, x_circle[-1]], [y0, y_circle[-1]], \"gray\", linestyle=\"--\")\n    ax.text(x0, y0, notations[0], verticalalignment=\"top\", horizontalalignment=\"left\")\n    ax.scatter(x0, y0, color=\"k\")\n\n    # add text\n    ax.text(x_circle[-1], y_circle[-1], notations[1], label=\"Circle (r={radius})\")\n    ax.scatter(x_circle[-1], y_circle[-1], color=\"k\")\n    ax.text(x_circle[0], y_circle[0], notations[2], label=\"Circle (r={radius})\")\n    ax.scatter(x_circle[0], y_circle[0], color=\"k\")\n\n    # plot external intersection points\n    mid_theta = (theta_start + theta_end) / 2\n    diff_theta = (theta_end - theta_start) / 2 \n    external_x = np.cos(mid_theta) * abs(r / np.cos(diff_theta)) + x0\n    external_y = np.sin(mid_theta) * abs(r / np.cos(diff_theta)) + y0\n\n    ax.scatter(external_x, external_y, color=\"k\")\n    ax.text(external_x, external_y, notations[3], verticalalignment=\"bottom\", horizontalalignment=\"left\")\n    ax.plot(\n        [external_x, x_circle[0]], [external_y, y_circle[0]], \"gray\", linestyle=\"-\"\n    )\n    ax.plot(\n        [external_x, x_circle[-1]], [external_y, y_circle[-1]], \"gray\", linestyle=\"-\"\n    )\n\n    return {'A': (x_circle[-1], y_circle[-1]), 'B': (x_circle[0], y_circle[0]), 'IP': (external_x, external_y )}\n\n\n# params\nx0, y0, r0 = 200, 100, 300\ntheta_start = np.pi / 10\ntheta_end = np.pi / 10 + np.pi * 2/ 3\n\nfig, ax = plt.subplots(figsize=(6, 6))\ncoordinates = draw_circle_with_two_tangent(x0, y0, r0, ax, theta_start, theta_end)\nax.grid(True, linestyle=\"--\", alpha=0.6)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n曲線の始点 \\(A\\) の追加距離は\n\\[\nA\\text{の追加距離} = IP\\text{の追加距離} - \\text{A(IP)の長さ}\n\\]\n直線 \\(A(IP)\\) は中心点 \\(O\\) とする円に接しているので\n\\[\n\\text{AOの長さ} \\times \\tan(\\angle (IP)OA)\n\\]\n接弦定理と円周角の定理より \\(\\angle (IP)\\) の外角を \\(I\\) とすると\n\\[\n\\begin{align}\n\\angle AOB &= I\\\\\n\\angle (IP)OA &= \\frac{I}{2}\n\\end{align}\n\\]\nしたがって，\n\\[\n\\text{AOの長さ} \\times \\tan \\frac{I}{2}\n\\]\n以上より\n\\[\n\\begin{align}\nA\\text{の追加距離}\n    &= 623 - 300 \\times \\tan \\frac{\\pi}{3}\\\\\n    &= 623 - 300\\sqrt{3} \\approx 103.4\n\\end{align}\n\\]\nまた，\\(B\\text{の追加距離}\\) は，弧 \\(AB\\) の長さがわかれば\n\\[\nB\\text{の追加距離} = A\\text{の追加距離} + \\text{弧}AB\\text{の長さ}\n\\]\nと計算できる．\n\\[\n\\begin{align}\n\\text{弧}AB\\text{の長さ}\n    &= R \\times I\\\\\n    &= 300 \\times \\frac{2}{3}\\pi\\\\\n    &= 200\\pi\n\\end{align}\n\\]\nしたがって，\n\\[\nB\\text{の追加距離} \\approx 103.4 + 628.40 = 731.80\n\\]\n実際にAの追加距離をPythonで近似計算してみると\n\n\nCode\nA, IP = np.array(coordinates['A']), np.array(coordinates['IP'])\nA_add_distance = 623 - np.linalg.norm(A - IP)\nprint(f\"Aの追加距離 = {A_add_distance:.2f}\")\n\n\nAの追加距離 = 103.38\n\n\n\n\n\n\n\nExercise 2 \n曲線半径 \\(r_1 = 400\\), \\(\\displaystyle\\angle AO_1B = \\frac{\\pi}{2}\\) となるような形で現道路 \\(AB\\) が存在するとする． 現在の道路を改良し \\(O_2\\) を中心とする円曲線からなる新しい道路 \\(AB_2\\) を建設したいとします．\n新しい道路の交点 \\(IP\\) の１は現道路と変わらないとする．\n\\(\\displaystyle\\angle AO_2B_2 = \\frac{\\pi}{3}\\) としたとき，\\(AB_2\\) の路線長を求めよ．\n\n\nCode\n# params\nx0, y0, r0 = 200, 100, 400\ntheta_start = np.pi / 3\ntheta_end = np.pi / 3 + np.pi / 2\n\nfig, ax = plt.subplots(figsize=(6, 6))\ncoordinates = draw_circle_with_two_tangent(x0, y0, r0, ax, theta_start, theta_end, ('$O_1$', '$A$', '$B_1$', '$IP$'))\nax.grid(True, linestyle=\"--\", alpha=0.6)\n\nr_new = 400 / np.tan(np.pi/6) \nA = np.array(coordinates['A'])\nO = np.array((200, 100))\nAO = O - A\nO_new = A + (AO / np.linalg.norm(AO)) * r_new\n\ncoordinates_new = draw_circle_with_two_tangent(*O_new, r_new, ax, theta_end - np.pi/3, theta_end, ('$O_2$', '$A$', '$B_2$', '$IP$'))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n新道路の曲線半径を \\(r_2\\) としたとき，\\(A(IP)\\) の長さは\n\\[\n\\begin{align}\nA(IP)\n    &= r_1 \\times \\tan \\frac{\\pi}{4}\\\\\n    &= r_2 \\times \\tan \\frac{\\pi}{6}\n\\end{align}\n\\]\nと表されるので\n\\[\n\\begin{align}\nr_2\n    &= \\frac{400 \\times 1 }{\\tan \\frac{\\pi}{6}}\\\\\n    &= 400\\times \\sqrt{3}\n    &\\approx 400\\times 1.732\\\\\n    &= 692.8\n\\end{align}\n\\]\nしたがって，\n\\[\n\\text{曲線}AB_2 = 692.8 \\times \\frac{\\pi}{3} \\approx 725.1\n\\]"
  },
  {
    "objectID": "posts/2025-02-04-add-distance-measurement/index.html#障害物がある場合の曲線設定",
    "href": "posts/2025-02-04-add-distance-measurement/index.html#障害物がある場合の曲線設定",
    "title": "単曲線と追加距離の計算",
    "section": "障害物がある場合の曲線設定",
    "text": "障害物がある場合の曲線設定\n\n\nExercise 3 \n\n曲線半径 \\(r = 200\\)\n\\(A_1B_1\\) の長さ 100\n\\(\\angle AA_1B_1 = 150^\\circ\\)\n\\(\\angle BB_1A_1 = 120^\\circ\\)\n\nという情報が与えられているとき，線分 \\(AA_1\\) の長さを求めよ．なお，直線 \\(A(IP)\\) と \\(B(IP)\\) はそれぞれ円の接線であるとする．\n\n\nCode\n# params\nx0, y0, r0 = 200, 100, 200\ntheta_start = np.pi / 3\ntheta_end = theta_start + np.pi / 2\n\nfig, ax = plt.subplots(figsize=(6, 6))\nax.grid(True, linestyle=\"--\", alpha=0.6)\n\n## draw an arc\ncoordinates = draw_circle_with_two_tangent(x0, y0, r0, ax, theta_start, theta_end, ('$O$', '$A$', '$B$', '$IP$'))\n\n## drar mid-points\nB_IP = np.array(coordinates['B']) - np.array(coordinates['IP'])\nA_IP = np.array(coordinates['A']) - np.array(coordinates['IP'])\nB_1 = np.array(coordinates['IP']) + B_IP / np.linalg.norm(B_IP) * 100 / 2\nA_1 = np.array(coordinates['IP']) + A_IP / np.linalg.norm(A_IP) * 100 / 2 * np.sqrt(3)\n\nax.plot(\n        [A_1[0], B_1[0]], [A_1[1], B_1[1]], \"gray\", linestyle=\"-\"\n    )\n\nax.text(A_1[0], A_1[1], \"$A_1$\")\nax.text(B_1[0], B_1[1], \"$B_1$\")\n\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\\(\\displaystyle\\angle AOB = \\frac{\\pi}{2}\\) であるので\n\\[\n\\text{length of }A(IP) = 200 \\times \\tan 45^\\circ = 200\n\\]\n正弦定理より\n\\[\n\\frac{A_1B_1}{\\sin \\angle (IP)} = \\frac{A_1(IP)}{\\sin \\angle (IP)B_1A_1}\n\\]\nしたがって，\n\\[\n\\begin{align}\n\\text{length of }A_1(IP)\n    &= 100 \\times \\sin \\angle (IP)B_1A_1\\\\\n    &= 100 \\times \\frac{\\sqrt{3}}{2}\\\\\n    &\\approx 50 \\times 1.732 = 86.60\n\\end{align}\n\\]\n以上より\n\\[\n\\text{length of }AA_1 = 200 - 86.60 = 113.40\n\\]\nPythonで確認すると\n\n\nCode\nres = np.linalg.norm(np.array(coordinates['A']) - A_1)\nprint(f\"点Aから点A_1までの距離 = {res:.2f}\")\n\n\n点Aから点A_1までの距離 = 113.40"
  },
  {
    "objectID": "posts/2025-05-23-what-to-write-in-wiki/index.html",
    "href": "posts/2025-05-23-what-to-write-in-wiki/index.html",
    "title": "wikiにどのような情報をどのように残すか？",
    "section": "",
    "text": "Key Takeaways\n\n\n\n\n\n\nWiki は，みんなが自由に編集できる Web サイト\n書かないよりかは書く！\n慣れてきたら，ストック情報を意識して何をWikiに記載すべきか判断する\nメタデータ（タイトル，作成者，更新日，タグ，関連資料など）を活用することで，情報の検索性・管理性・再利用性が向上する"
  },
  {
    "objectID": "posts/2025-05-23-what-to-write-in-wiki/index.html#projectと情報共有の課題",
    "href": "posts/2025-05-23-what-to-write-in-wiki/index.html#projectと情報共有の課題",
    "title": "wikiにどのような情報をどのように残すか？",
    "section": "1. Projectと情報共有の課題",
    "text": "1. Projectと情報共有の課題\n仕事の中で情報共有の課題はしばしば発生します．その発生の仕方は以下の２つが代表例としてあります．\n課題1：必要な情報が共有されていない\n\n\n\n\n\n\n\n\n事象\n問題分類\n\n\n\n\n退職・異動時に「前任者しか知らないこと」が多く，後任が混乱\n属人化問題\n\n\n同じ業務でも人によってやり方がバラバラ（手順の標準化がされていない）\nナレッジの一元化できてない問題\n\n\n毎回「この件ってどうやるんでしたっけ？」という質問が発生する\n非効率なコミュニケーション\n\n\n\n\n\n課題2：必要な情報を見つけるのが難しい\n\n\n\n\n\n\n\n\n事象\n問題分類\n\n\n\n\n手順書は共有フォルダ，仕様はメール，背景はSlack…とバラバラ\n情報の散逸問題\n\n\n検索しても古いバージョンや関係ない資料が出てきて混乱\n情報の最新化・正確性問題"
  },
  {
    "objectID": "posts/2025-05-23-what-to-write-in-wiki/index.html#projectにおけるwiki",
    "href": "posts/2025-05-23-what-to-write-in-wiki/index.html#projectにおけるwiki",
    "title": "wikiにどのような情報をどのように残すか？",
    "section": "2. ProjectにおけるWiki",
    "text": "2. ProjectにおけるWiki\n\nDefinition 1 Wiki \nプロジェクトやチームの知識・ノウハウ・手順・ルールなどを，誰でも編集・追加できる形で蓄積・共有するためのドキュメントシステムのことをWikiと呼ぶ．\n\nWikiは，単なるメモやドキュメントの集積ではなく，以下のような効果を持ったプロジェクトの「知識のインフラ」として機能します．\n\nナレッジの一元化\n属人化の防止\nコミュニケーションの効率化\n\n\n\nナレッジの一元化\n\n\nナレッジの一元化とは，プロジェクトやチームに関する情報・ノウハウ・手順・ルールなどを，分散せずに一箇所（Wikiなど）に集約して管理することを指します．これにより，以下のようなメリットがあります。\n\n情報の散逸防止\n\n口頭や個人メモ，チャットログなどに分散しがちな情報を，Wikiにまとめることで「どこに何が書いてあるか分からない」「必要な情報が見つからない」といった事態を防げます\n\n情報の最新化・正確性の維持\n\n仕様変更や新しい知見が得られた際，Wikiを更新するだけで全員が最新情報を参照でき，古い情報によるミスや認識ズレを防止できます\n\n\n\n\n属人化の防止\n\n\n属人化とは，特定の業務やノウハウが一部の人だけに依存し，その人がいないと作業が進まない・問題が解決できない状態を指します．Wikiは以下の観点からこの属人化を防ぐための有効なツールです．\n\n情報の共有・可視化\n\n業務手順やトラブル対応，設定方法などをWikiに記録することで，誰でも同じ情報にアクセスできるようになります\nこれにより，担当者が不在でも他のメンバーが対応可能となり，業務の停滞を防げます\n\nノウハウの蓄積と継承\n\n経験者が持つ暗黙知やコツを明文化してWikiに残すことで，後任者や新メンバーへのスムーズな引き継ぎが可能になります\n\nチーム全体のスキル底上げ\n\n皆がWikiを活用・更新することで，チーム全体の知識レベルが向上し，特定の人に依存しない強い組織づくりにつながります\n\n\n\n\nコミュニケーションの効率化\n\n\nコミュニケーションの非効率とは，情報が構造化されていないことや，一元管理されていないによって発生する無駄な時間のことです．例として以下のようなものがあります\n\n\n\n\n\n\n\n\n課題・現象\nコスト分類\n\n\n\n\n毎回同じ質問が繰り返される\n説明コスト\n\n\n情報が人によってバラバラで食い違う\n認識齟齬コスト\n\n\n確認・共有・引き継ぎに時間がかかる\n説明コスト・情報探索コスト\n\n\nメールやチャットを遡らないと情報が見つからない\n情報探索コスト\n\n\n\n\nWikiを活用することで上記のような「説明コスト」「認識齟齬コスト」「情報探索コスト」を以下のような機序で削減することができます\n\n説明コストの削減\n\nよくある質問や手順，ルールなどをWikiにまとめておくことで，同じ内容を何度も口頭やチャットで説明する必要がなくなります\n新メンバーや他部署からの問い合わせにも「Wikiを参照してください」と非同期コミュニケーションの案内でき，対応コストを大幅に削減できます\n仕様や方針，過去の議論の経緯などをWikiに記録しておくことで，議論のたびに一から説明したり，過去の経緯を探す手間が省けます\n\n認識齟齬コストの低減\n\nWikiに記載された内容は誰でも同じものを参照できるため，伝言ゲームによる情報のズレや誤解を防げます\n\n情報探索コストの低減\n\n業務に必要な情報（手順・FAQ・ルール・用語解説など）を構造的に蓄積・整理することで，情報の「どこにあるか」「最新版はどれか」を探す時間を減らすことができます"
  },
  {
    "objectID": "posts/2025-05-23-what-to-write-in-wiki/index.html#wikiに書くべき情報",
    "href": "posts/2025-05-23-what-to-write-in-wiki/index.html#wikiに書くべき情報",
    "title": "wikiにどのような情報をどのように残すか？",
    "section": "3. Wikiに書くべき情報",
    "text": "3. Wikiに書くべき情報\nWikiには情報を多く残せば残すほど基本的に良いですが，「フロー」と「ストック」という観点で情報を事前に整理することがより良いwikiへと繋がります．Wikiはストック型の情報を蓄積する場所であるので，「これはストック化すべき情報だ」と事前に分類・判断して整理する必要があります．\n\n\nフロー情報\n\n\n\n時系列に流れていく情報\n生まれた直後は価値が高く，時間やプロジェクト進行の経過と共に価値が下がっていく\n例: Slackやメールでのやり取り，日報・会議メモなど\n\n\nストック情報\n\n\n\n長期的に価値があり，何度も参照される情報\n例: マニュアルや設計書，仕様書など\n\n\n「フローとストックの区別」と良いWiki\n\n\n「フローとストックの区別」の視点を持つことで，以下のようなメリットがあります：\n\nWikiがごみ箱化せず，構造的に整理される\n情報の探しやすさが向上\n\n具体的な運用例\n\n\n\n\n\n\n\n\n\n情報の種類\n最初は\nその後\n\n\n\n\n新しいやり方の試行錯誤\nSlackで議論（フロー）\n成功したら手順をWikiに整理（ストック）\n\n\n問い合わせへの回答\nチャットで返す（フロー）\nよくある質問ならFAQとしてまとめる（ストック）\n\n\nプロジェクトの背景や目的\n議事録で共有（フロー）\n重要事項はWikiのプロジェクトページに追記（ストック）"
  },
  {
    "objectID": "posts/2025-05-23-what-to-write-in-wiki/index.html#coding-projectでwikiに書くべき情報",
    "href": "posts/2025-05-23-what-to-write-in-wiki/index.html#coding-projectでwikiに書くべき情報",
    "title": "wikiにどのような情報をどのように残すか？",
    "section": "4. Coding ProjectでWikiに書くべき情報",
    "text": "4. Coding ProjectでWikiに書くべき情報\n\nGoal: 開発メンバー全員が迷わず効率よく開発・運用できる\n\n\n\nWikiを書く目的は情報伝達の課題を解決するため\nCoding Projectにおいて情報伝達課題の解決はプロジェクトの生産性・品質・持続性を大きく左右する\n\n\n\n\n\n\n\n\n\nWikiに書く内容\nどの「迷い」や「非効率」を減らすか\n\n\n\n\n環境構築手順\n「動かない」「セットアップ方法がわからない」\n\n\n技術スタック・設計方針\n「なぜこの技術を使ってるの？」「全体像が見えない」\n\n\nコーディングルール・ブランチ戦略\n「このファイル名でいい？」「この書き方でOK？」\n\n\nデプロイ手順・運用ルール\n「本番反映って誰がどうやってるの？」\n\n\nFAQ・トラブル対応\n「よくあるエラーが出た，どうすればいい？」"
  },
  {
    "objectID": "posts/2025-05-23-what-to-write-in-wiki/index.html#metadata-fieldの活用",
    "href": "posts/2025-05-23-what-to-write-in-wiki/index.html#metadata-fieldの活用",
    "title": "wikiにどのような情報をどのように残すか？",
    "section": "5. metadata fieldの活用",
    "text": "5. metadata fieldの活用\nmetadata fieldを明確に設定することで，情報の管理性・検索性・再利用性が大きく向上します．\nmetadata field活用の効果\n\n\n\n\n目的\nメタデータが果たす役割\n\n\n\n\n検索性向上\nタグ・対象環境・チームでフィルタリング可能\n\n\n責任の明確化\n作成者/責任者がわかることで内容の信用度が上がる\n\n\n鮮度の判断\n更新日で「使える情報か？」を判断できる\n\n\nナレッジの繋がり\n関連リンクでページ間の文脈を可視化できる\n\n\n\n\n\nmetadata field項目例\n\n\n\n\n\n\n\n\n\nフィールド名\n内容\n記入例・補足\n\n\n\n\nタイトル / name\nページの内容をひと目で表すタイトル\n環境構築手順（ローカル） / バックエンド設計方針\n\n\n作成者 / author\n初期作成者，または責任者\nr.nak（Slack名やGitHubアカウントで統一）\n\n\n最終更新日 / last_updated\n内容が最後に更新された日時\n2025-05-23（日付のみ or タイムスタンプ）\n\n\n関連タグ / tags\n分類や検索性向上のためのタグ群\n#backend, #setup, #api, #infra\n\n\n対象環境 / environment\n適用される環境やバージョン範囲\nlocal, staging, v2.3.1〜\n\n\n関連資料 / related_docs\n他ページや外部リンクへの参照\n[デプロイ手順](../deployment.md) / URL可\n\n\n更新履歴 / changelog\n主な更新内容と日付\n2025-05-23: Docker対応を追加2025-03-01: 初版作成\n\n\n\n\n\nmetadata field実装例\n\nMarkdown with yamlConfluence\n\n\n---\ntitle: \"ローカル環境構築ガイド\"\nauthor: \"r.nak\"\nlast_updated: \"2025-05-23\"\ntags: [\"setup\", \"backend\", \"docker\"]\nenvironment: \"local\"\nteam: \"backend\"\nis_obsolete: false\nrelated_docs:\n  - \"../deployment.md\"\n  - \"https://example.com/db-guide\"\nchangelog:\n  - \"2025-05-23: Docker対応を追加\"\n  - \"2025-03-01: 初版作成\"\n---\n\n\n\nページの冒頭に「テーブル形式」でメタ情報を記述\nテーブルを「ページプロパティマクロ」で囲む\n他ページから「ページプロパティレポートマクロ」で一覧化が可能"
  },
  {
    "objectID": "posts/2025-05-23-what-to-write-in-wiki/index.html#wiki運用tips",
    "href": "posts/2025-05-23-what-to-write-in-wiki/index.html#wiki運用tips",
    "title": "wikiにどのような情報をどのように残すか？",
    "section": "5. Wiki運用Tips",
    "text": "5. Wiki運用Tips\nWikiは「作って終わり」ではなく，「育てて使い続ける」ことで真価を発揮します．一方，更新を怠り最新情報が反映されていなかったり，信頼性が低い内容が記載されていたりなど実運用ではトラブルが発生します．\n\nトラブル1：情報が乱立・重複してどれが正しいか分からない\n\n\n\n\n\n\n\n\n\n\n原因・目的\n対策内容\n効果・備考\n\n\n\n\n情報の分類が曖昧・乱立しやすい\nタグを事前定義（例：setup, troubleshooting, design, infra, FAQ）\nページの役割や内容を明確化し，重複や検索漏れを防ぐ\n\n\nページの乱立・重複・古い情報の放置\n定期的な「重複・類似ページ見直し会」（ミニレビュー）\n定期的な棚卸しで情報の鮮度・整理を維持し，正しい情報を残す\n\n\n古い情報や非推奨手順が残りやすい\nis_obsolete: true フラグで非推奨情報を明示\n利用者が「どれが最新・有効か」を一目で判断できるようにする\n\n\n\n\n\n\nトラブル2：情報の更新漏れで古い手順が誤用される\n\n\n\n\n\n\n\n\n\n\n原因・目的\n対策内容\n効果・備考\n\n\n\n\n情報の鮮度が分からず古い手順が誤用される\n「更新日」フィールドを必須化\nページごとに最新更新日が明示され，利用者が情報の新旧を判断しやすくなる\n\n\n実運用の変更がWikiに反映されないまま放置される\nPRや障害対応のチェックリストに「Wiki更新」を追加\n運用変更や障害対応のたびにWiki更新を強制し，情報の陳腐化・誤用を防ぐ\n\n\n\n\n\n\nトラブル3：誰が書いたのか分からず，内容の信頼性が低い\n\n\n\n\n\n\n\n\n\n\n原因・目的\n対策内容\n効果・備考\n\n\n\n\nページの責任者が不明で内容の信頼性や更新責任が曖昧になる\nすべてのページに「Author（責任者）」を必須項目として設定\n責任者が明確になり，内容の信頼性・更新体制が向上する\n\n\n担当者不在で情報が放置される\n作成者が異動・退職したページの担当を再割当\n継続的な管理・更新体制を維持できる\n\n\n責任者不明ページの放置・情報の陳腐化\n「責任者が不明なページ一覧」を抽出し，棚卸しリストに追加\n定期的な棚卸しで責任者を再割当し，情報の鮮度と信頼性を保つ\n\n\n\n\n\nトラブル4：一部の人しかWikiを更新しない\n\n\n\n\n\n\n\n\n\n\n原因・目的\n対策内容\n効果・備考\n\n\n\n\n書き方が分からず記載が進まない・属人化\nテンプレートを整備し，書く敷居を下げる\n誰でも迷わず記載でき，情報の質と量が安定する\n\n\n重要な情報が口頭やチャットで流れてしまう\nSlackやMTGで「この話Wikiに書いておこう」と声かけする文化作り\n情報のストック化が進み，ナレッジの蓄積・共有が促進される\n\n\n\n\n\n\nトラブル5：作っても使われない\n\n\n\n\n\n\n\n\n\n\n原因・目的\n対策内容\n効果・備考\n\n\n\n\n重要情報が分散し見つけづらい\nオンボーディング資料，障害手順書，開発ルールなど，必ず参照する情報をWikiに集約\n必要な情報が一箇所で見つかり，迷いなく参照できる\n\n\n質問・回答がチャットで流れてしまう\nSlackで「この質問，Wikiにありましたよ」文化をつくる\n情報のストック化が進み，同じ質問の繰り返しを防ぐ\n\n\nWikiの構造が複雑・不親切\n初心者でもどこから見ればいいか分かる構造をつくる\n迷わず必要な情報にたどり着ける，オンボーディングも円滑\n\n\n利用者視点の改善が進まない\nユーザーを巻き込むUI改善アンケートやフィードバック導線\n実際の利用者の声を反映し，使いやすいWiki運用が実現できる"
  },
  {
    "objectID": "posts/2025-05-23-what-to-write-in-wiki/index.html#references",
    "href": "posts/2025-05-23-what-to-write-in-wiki/index.html#references",
    "title": "wikiにどのような情報をどのように残すか？",
    "section": "References",
    "text": "References\n\nサル先生のWiki入門"
  },
  {
    "objectID": "posts/2025-02-02-taylor-expansion-and-polynomial/index.html",
    "href": "posts/2025-02-02-taylor-expansion-and-polynomial/index.html",
    "title": "有限個の多項式のテイラー展開",
    "section": "",
    "text": "\\(y = f(x)\\) の導関数を \\(f^\\prime(x)\\) とするとき，第二階の導関数を \\(f^{\\prime\\prime}(x)\\) と表記し，第 \\(n\\) 階の導関数を \\(f^{(n)}(x)\\) と表記します． 一点 \\(x\\) において\n\\[\n\\begin{gather}\nf^{\\prime\\prime}(x) = \\frac{d}{dx}\\left(\\frac{dy}{dx}\\right) = \\frac{d^2y}{dx^2}\\\\\nf^{(n)}(x) = \\frac{d^ny}{dx^n}\n\\end{gather}\n\\]\nとなります．\n ▶  記号の差異: \\(d^2y\\) vs \\(dx^2\\)\n\\(d^2y = d(dy)\\)，\\(dx^2 = (dx)^2\\) の意味で，この意味の差異を表現するため記号でも表記が異なっています．微分記号を用いて\n\\[\ndy = f^\\prime(x)dx\n\\]\nと書くとき，両辺の微分を取れば，\n\\[\n\\begin{align}\nd(dy) &= \\frac{d(f^{\\prime}(x))}{dx}(dx)^2 + f^\\prime(x)\\frac{d(dx)}{dx}dx\\\\\n      &= f^{\\prime\\prime}(x)(dx)^2 + f^\\prime(x)d(dx) \\label{eq-second-diff}\n\\end{align}\n\\]\n\\(x\\) が独立変数であるならば \\(dx\\) は \\(x\\) の水準関係なく自由に取れるので，\\(\\frac{d(dx)}{dx} = 0\\)．従って，\n\\[\nd^2y = f^{\\prime\\prime}(x)dx^2\n\\]\nとなります．もし，\\(x = \\varphi(t)\\) であるならば，\\(d^2x = \\varphi^{\\prime\\prime}(t)dt^2\\) となるので\n\\[\n\\frac{d}{dt^2}f(\\varphi(t)) = f^{\\prime\\prime}(\\varphi(t))(\\varphi^\\prime(t))^2 + f^\\prime(\\varphi(t))\\varphi^{\\prime\\prime}(t)\n\\]\n\n\n\n\nTheorem 1 : ライプニッツの公式(Leibniz rule) \n\\(u, v\\) が \\(x\\) の関数であるとき，\n\\[\n\\begin{align}\n\\frac{d^n(uv)}{dx^n}\n    &= u^{(n)}v + \\left(\\begin{array}{c}n\\\\1\\end{array}\\right)u^{(n-1)}v^{\\prime} + \\left(\\begin{array}{c}n\\\\2\\end{array}\\right)u^{(n-2)}v^{\\prime\\prime}+\\cdots+ \\left(\\begin{array}{c}n\\\\n-1\\end{array}\\right)u^{\\prime}v^{(n-1)} +uv^{(n)}\\\\\n    &= \\sum_{k=0}^n \\left(\\begin{array}{c}n\\\\ k\\end{array}\\right)u^{(n-k)}v^{(k)}\n\\end{align}\n\\]\n\n\n\n\n\n\n\n\n\nProof\n\n\n\n\n\n\\(n=1\\) のときは，積の微分公式より\n\\[\n\\frac{d(uv)}{dx^n} = \\frac{du}{dx}v + \\frac{dv}{dx}u\n\\]\n\\(n\\geq 2\\) については，帰納法を用いて示す．\\(n=t\\) のときライプニッツの公式が成立すると仮定する．\nこのとき，\n\\[\n\\begin{align}\n\\frac{d^{(t+1)}(uv)}{dx^{t+1}}\n    &= \\frac{d}{dt}\\left(\\frac{d^{(t)}(uv)}{dx^{t}}\\right)\\\\\n    &= \\frac{d}{dt}\\left(\\sum_{k=0}^t \\left(\\begin{array}{c}t\\\\ k\\end{array}\\right)u^{(t-k)}v^{(k)}\\right)\\\\\n    &= \\sum_{k=0}^t \\left(\\begin{array}{c}t\\\\ k\\end{array}\\right)[u^{(t-k+1)}v^{(k)} + u^{(t-k)}v^{(k+1)}]\\\\\n    &= \\sum_{k=0}^t \\left(\\begin{array}{c}t\\\\ k\\end{array}\\right)u^{(t-k+1)}v^{(k)} + \\sum_{k=0}^t \\left(\\begin{array}{c}t\\\\ k\\end{array}\\right)u^{(t-k)}v^{(k+1)}\\\\\n    &= \\left\\{u^{(t+1)}v + \\sum_{k=1}^t \\left(\\begin{array}{c}t\\\\ k\\end{array}\\right)u^{(t-k+1)}v^{(k)}\\right\\}+ \\left\\{uv^{(t+1)} + \\sum_{k=0}^{t-1} \\left(\\begin{array}{c}t\\\\ k\\end{array}\\right)u^{(t-k)}v^{(k+1)}\\right\\}\\\\\n    &= \\left\\{u^{(t+1)}v + \\sum_{k=1}^t \\left(\\begin{array}{c}t\\\\ k\\end{array}\\right)u^{(t-k+1)}v^{(k)}\\right\\}+ \\left\\{uv^{(t+1)} + \\sum_{j=1}^{t} \\left(\\begin{array}{c}t\\\\ j-1\\end{array}\\right)u^{(t-j+1)}v^{j}\\right\\}\\\\\n    &= u^{(t+1)}v + uv^{(t+1)} + \\sum_{k=1}^t \\left\\{\\left(\\begin{array}{c}t\\\\ k\\end{array}\\right) + \\left(\\begin{array}{c}t\\\\ k-1\\end{array}\\right)\\right\\}u^{(t-k+1)}v^{(k)}\\\\\n    &= u^{(t+1)}v + uv^{(t+1)} + \\sum_{k=1}^t \\left(\\begin{array}{c}t+1\\\\ k\\end{array}\\right)u^{(t+1-k)}v^{(k)}\\\\\n    &= \\sum_{k=0}^{t+1} \\left(\\begin{array}{c}t+1\\\\ k\\end{array}\\right)u^{(t+1-k)}v^{(k)}\n\\end{align}\n\\]\nとなり，\\(n = t + 1\\) の場合のライプニッツの公式の成立が確かめられた．\n\n\n\n\nExample 1 \n\\(y = x^2\\sin(x)\\) について \\(n\\) 階導関数を求めめたいとします．\n\\[\n(\\sin x)^{(k)} = \\sin\\left(x + \\frac{\\pi}{2}k\\right)\n\\]\nであるので\n\\(n=1\\) のときは\n\\[\ny^\\prime = x^2\\sin\\left(x + \\frac{\\pi}{2}\\right) + 2x\\sin(x)\n\\]\n\\(n\\geq 2\\) のときは，\\(x^2\\) が2回微分可能であることを考慮してライプニッツルールを利用すると\n\\[\n\\begin{align}\n\\frac{d^n}{dx^{n}}(x^2\\sin x)\n    &= x^2(\\sin(x))^{(n)} + 2nx(\\sin(x))^{(n-1)} + n(n-1)(\\sin(x))^{(n-2)}\\\\\n    &= x^2\\sin\\left(x + \\frac{\\pi}{2}n\\right) + 2nx\\sin\\left(x + \\frac{\\pi}{2}(n-1)\\right) + n(n-1)\\sin\\left(x + \\frac{\\pi}{2}(n-2)\\right)   \n\\end{align}\n\\]\n\n\n\nExample 2 \n\\[\n\\begin{align}\n(x\\sin x)^{(n)} = x\\sin\\left(x + \\frac{\\pi}{2}n\\right) + n \\sin\\left(x + \\frac{\\pi}{2}(n-1)\\right)\\\\\n(x\\cos x)^{(n)} = x\\cos\\left(x + \\frac{\\pi}{2}n\\right) + n \\cos\\left(x + \\frac{\\pi}{2}(n-1)\\right)\\\\\n(x^2\\exp(x))^{(n)} = x^2\\exp(x) + 2nx\\exp(x) + n(n-1)\\exp(x)\n\\end{align}\n\\]"
  },
  {
    "objectID": "posts/2025-02-02-taylor-expansion-and-polynomial/index.html#高階微分法とライプニッツの公式",
    "href": "posts/2025-02-02-taylor-expansion-and-polynomial/index.html#高階微分法とライプニッツの公式",
    "title": "有限個の多項式のテイラー展開",
    "section": "",
    "text": "\\(y = f(x)\\) の導関数を \\(f^\\prime(x)\\) とするとき，第二階の導関数を \\(f^{\\prime\\prime}(x)\\) と表記し，第 \\(n\\) 階の導関数を \\(f^{(n)}(x)\\) と表記します． 一点 \\(x\\) において\n\\[\n\\begin{gather}\nf^{\\prime\\prime}(x) = \\frac{d}{dx}\\left(\\frac{dy}{dx}\\right) = \\frac{d^2y}{dx^2}\\\\\nf^{(n)}(x) = \\frac{d^ny}{dx^n}\n\\end{gather}\n\\]\nとなります．\n ▶  記号の差異: \\(d^2y\\) vs \\(dx^2\\)\n\\(d^2y = d(dy)\\)，\\(dx^2 = (dx)^2\\) の意味で，この意味の差異を表現するため記号でも表記が異なっています．微分記号を用いて\n\\[\ndy = f^\\prime(x)dx\n\\]\nと書くとき，両辺の微分を取れば，\n\\[\n\\begin{align}\nd(dy) &= \\frac{d(f^{\\prime}(x))}{dx}(dx)^2 + f^\\prime(x)\\frac{d(dx)}{dx}dx\\\\\n      &= f^{\\prime\\prime}(x)(dx)^2 + f^\\prime(x)d(dx) \\label{eq-second-diff}\n\\end{align}\n\\]\n\\(x\\) が独立変数であるならば \\(dx\\) は \\(x\\) の水準関係なく自由に取れるので，\\(\\frac{d(dx)}{dx} = 0\\)．従って，\n\\[\nd^2y = f^{\\prime\\prime}(x)dx^2\n\\]\nとなります．もし，\\(x = \\varphi(t)\\) であるならば，\\(d^2x = \\varphi^{\\prime\\prime}(t)dt^2\\) となるので\n\\[\n\\frac{d}{dt^2}f(\\varphi(t)) = f^{\\prime\\prime}(\\varphi(t))(\\varphi^\\prime(t))^2 + f^\\prime(\\varphi(t))\\varphi^{\\prime\\prime}(t)\n\\]\n\n\n\n\nTheorem 1 : ライプニッツの公式(Leibniz rule) \n\\(u, v\\) が \\(x\\) の関数であるとき，\n\\[\n\\begin{align}\n\\frac{d^n(uv)}{dx^n}\n    &= u^{(n)}v + \\left(\\begin{array}{c}n\\\\1\\end{array}\\right)u^{(n-1)}v^{\\prime} + \\left(\\begin{array}{c}n\\\\2\\end{array}\\right)u^{(n-2)}v^{\\prime\\prime}+\\cdots+ \\left(\\begin{array}{c}n\\\\n-1\\end{array}\\right)u^{\\prime}v^{(n-1)} +uv^{(n)}\\\\\n    &= \\sum_{k=0}^n \\left(\\begin{array}{c}n\\\\ k\\end{array}\\right)u^{(n-k)}v^{(k)}\n\\end{align}\n\\]\n\n\n\n\n\n\n\n\n\nProof\n\n\n\n\n\n\\(n=1\\) のときは，積の微分公式より\n\\[\n\\frac{d(uv)}{dx^n} = \\frac{du}{dx}v + \\frac{dv}{dx}u\n\\]\n\\(n\\geq 2\\) については，帰納法を用いて示す．\\(n=t\\) のときライプニッツの公式が成立すると仮定する．\nこのとき，\n\\[\n\\begin{align}\n\\frac{d^{(t+1)}(uv)}{dx^{t+1}}\n    &= \\frac{d}{dt}\\left(\\frac{d^{(t)}(uv)}{dx^{t}}\\right)\\\\\n    &= \\frac{d}{dt}\\left(\\sum_{k=0}^t \\left(\\begin{array}{c}t\\\\ k\\end{array}\\right)u^{(t-k)}v^{(k)}\\right)\\\\\n    &= \\sum_{k=0}^t \\left(\\begin{array}{c}t\\\\ k\\end{array}\\right)[u^{(t-k+1)}v^{(k)} + u^{(t-k)}v^{(k+1)}]\\\\\n    &= \\sum_{k=0}^t \\left(\\begin{array}{c}t\\\\ k\\end{array}\\right)u^{(t-k+1)}v^{(k)} + \\sum_{k=0}^t \\left(\\begin{array}{c}t\\\\ k\\end{array}\\right)u^{(t-k)}v^{(k+1)}\\\\\n    &= \\left\\{u^{(t+1)}v + \\sum_{k=1}^t \\left(\\begin{array}{c}t\\\\ k\\end{array}\\right)u^{(t-k+1)}v^{(k)}\\right\\}+ \\left\\{uv^{(t+1)} + \\sum_{k=0}^{t-1} \\left(\\begin{array}{c}t\\\\ k\\end{array}\\right)u^{(t-k)}v^{(k+1)}\\right\\}\\\\\n    &= \\left\\{u^{(t+1)}v + \\sum_{k=1}^t \\left(\\begin{array}{c}t\\\\ k\\end{array}\\right)u^{(t-k+1)}v^{(k)}\\right\\}+ \\left\\{uv^{(t+1)} + \\sum_{j=1}^{t} \\left(\\begin{array}{c}t\\\\ j-1\\end{array}\\right)u^{(t-j+1)}v^{j}\\right\\}\\\\\n    &= u^{(t+1)}v + uv^{(t+1)} + \\sum_{k=1}^t \\left\\{\\left(\\begin{array}{c}t\\\\ k\\end{array}\\right) + \\left(\\begin{array}{c}t\\\\ k-1\\end{array}\\right)\\right\\}u^{(t-k+1)}v^{(k)}\\\\\n    &= u^{(t+1)}v + uv^{(t+1)} + \\sum_{k=1}^t \\left(\\begin{array}{c}t+1\\\\ k\\end{array}\\right)u^{(t+1-k)}v^{(k)}\\\\\n    &= \\sum_{k=0}^{t+1} \\left(\\begin{array}{c}t+1\\\\ k\\end{array}\\right)u^{(t+1-k)}v^{(k)}\n\\end{align}\n\\]\nとなり，\\(n = t + 1\\) の場合のライプニッツの公式の成立が確かめられた．\n\n\n\n\nExample 1 \n\\(y = x^2\\sin(x)\\) について \\(n\\) 階導関数を求めめたいとします．\n\\[\n(\\sin x)^{(k)} = \\sin\\left(x + \\frac{\\pi}{2}k\\right)\n\\]\nであるので\n\\(n=1\\) のときは\n\\[\ny^\\prime = x^2\\sin\\left(x + \\frac{\\pi}{2}\\right) + 2x\\sin(x)\n\\]\n\\(n\\geq 2\\) のときは，\\(x^2\\) が2回微分可能であることを考慮してライプニッツルールを利用すると\n\\[\n\\begin{align}\n\\frac{d^n}{dx^{n}}(x^2\\sin x)\n    &= x^2(\\sin(x))^{(n)} + 2nx(\\sin(x))^{(n-1)} + n(n-1)(\\sin(x))^{(n-2)}\\\\\n    &= x^2\\sin\\left(x + \\frac{\\pi}{2}n\\right) + 2nx\\sin\\left(x + \\frac{\\pi}{2}(n-1)\\right) + n(n-1)\\sin\\left(x + \\frac{\\pi}{2}(n-2)\\right)   \n\\end{align}\n\\]\n\n\n\nExample 2 \n\\[\n\\begin{align}\n(x\\sin x)^{(n)} = x\\sin\\left(x + \\frac{\\pi}{2}n\\right) + n \\sin\\left(x + \\frac{\\pi}{2}(n-1)\\right)\\\\\n(x\\cos x)^{(n)} = x\\cos\\left(x + \\frac{\\pi}{2}n\\right) + n \\cos\\left(x + \\frac{\\pi}{2}(n-1)\\right)\\\\\n(x^2\\exp(x))^{(n)} = x^2\\exp(x) + 2nx\\exp(x) + n(n-1)\\exp(x)\n\\end{align}\n\\]"
  },
  {
    "objectID": "posts/2025-02-02-taylor-expansion-and-polynomial/index.html#有限個の多項式のテイラー展開",
    "href": "posts/2025-02-02-taylor-expansion-and-polynomial/index.html#有限個の多項式のテイラー展開",
    "title": "有限個の多項式のテイラー展開",
    "section": "有限個の多項式のテイラー展開",
    "text": "有限個の多項式のテイラー展開\n\\(n\\) 次式の \\(f(x)\\) を考えます．このとき，定義域の任意の点 \\(a\\) を用いて，以下のように表すとします\n\\[\nf(x) = a_0 + a_1(x-a) + a_2(x-a)^2 + \\cdots + a_n(x-a)^n\n\\]\n\\(x = a\\) のとき，\\(f(a) = a_0\\)．両辺を \\(k\\) 回微分すると\n\\[\nf^{(k)}(x) = a_kk! + a_{k+1}\\frac{(k+1)!}{1!}(x-a) + a_{k+2}\\frac{(k+2)!}{2!}(x-a)^2 + \\cdots + a_{n}\\frac{n!}{(n-k)!}(x-a)^{n-k}\n\\]\nこのとき，\\(f^{(k)}(a) = a_kk!\\) であるので，\\(a_k = \\frac{f^{(k)}(a)}{k!}\\) を得る．従って，\\(n\\) 次式の \\(f(x)\\) は\n\\[\nf(x) = f(a) + \\frac{f^{\\prime}(a)}{1!}(x-a) + \\frac{f^{(2)}(a)}{2!}(x-a)^2 + \\cdots + \\frac{f^{(n)}(a)}{n!}(x-a)^n\\label{eq-poly}\n\\]\nと表すことが出来ます．\n\nExample 3 \n\\(f(x) = x^n\\) を\n\\[\nf(x) = a_0 + a_1(x-1) + a_2(x-1)^2 + \\cdots + a_n(x-1)^n\n\\]\nで表したいとします．このとき，\\(\\eqref{eq-poly}\\) より\n\\[\n\\begin{align}\nx^n\n    &= 1 + \\frac{n}{1!}(x-1)+ \\frac{n(n-1)}{2!}(x-1)^2 + \\cdots + \\frac{n!}{n!}(x-1)^n\\\\\n    &= \\sum_{k=0}^n \\left(\\begin{array}{c}n\\\\ k\\end{array}\\right)(x-1)^k\n\\end{align}\n\\]\nと表せます．これを更に式変形すると\n\\[\n\\begin{align}\n\\sum_{k=0}^n \\left(\\begin{array}{c}n\\\\ k\\end{array}\\right)(x-1)^k\n    &= \\sum_{k=0}^n \\left(\\begin{array}{c}n\\\\ k\\end{array}\\right)(x-1)^k 1^{n-k}\\\\\n    &= (x - 1 + 1)^n\\\\\n    &= x^n\n\\end{align}\n\\]\nよって \\(x^n\\) の \\(x = 1\\) まわりでのテイラー展開は \\((x - 1 + 1)^n\\) の二項展開と関係づけて理解することが出来ます．\n\n\n\n\nTheorem 2 \n\\(n\\) 次式の \\(f(x)\\) について，\\(x=a\\) が \\(k\\) 重解であるための必要十分条件は\n\\[\n\\begin{gather}\nf(a) = f^\\prime(a) = \\cdots = f^{(k-1)}(a) = 0\\\\\nf^{(k)}(a) \\neq 0\n\\end{gather}\n\\]\n\n\n\n\n\n\n\n\n\nProof\n\n\n\n\n\n\\(x=a\\) が \\(k\\) 重解であるということは，\\(f(x) = (x-a)^kg(x), g(a)\\neq 0\\) と同値であることに留意して以下示します．\n ▶  十分性\n\\(\\eqref{eq-poly}\\) より\n\\[\n\\begin{align}\nf(x)\n    &=\\frac{f^{(k)}(a)}{k!}(x-a)^k + \\frac{f^{(k+1)}(a)}{(k+1)!}(x-a)^{k+1} + \\cdots +\\frac{f^{(n)}(a)}{n!}(x-a)^n\\\\\n    &= (x-a)^k\\left\\{\\frac{f^{(k)}(a)}{k!} + \\frac{f^{(k+1)}(a)}{(k+1)!}(x-a)^{1} + \\cdots + \\frac{f^{(n)}(a)}{n!}(x-a)^{n-k}\\right\\}\\\\\n    &= (x-a)^kg(x)\n\\end{align}\n\\]\nこのとき，\\(f^{(k)}(a) \\neq 0\\) より \\(g(a)\\neq 0\\). 以上より，十分性は示せた．\n ▶  必要性\n\\(f(x) = (x-a)^kg(x), g(a)\\neq 0\\) のとき，\\(f(a) = 0\\) は自明． この式を \\(m\\) 回微分するとライプニッツルールより\n\\[\n\\begin{aligned}\nf^{(m)}(x) =& (x-a)^kg^{(m)}(x) + \\left(\\begin{array}{c}m\\\\ 1\\end{array}\\right)k(x-a)^{k-1}g^{(m-1)}(x) \\\\\n            &+ \\cdots + \\left(\\begin{array}{c}m\\\\ m\\end{array}\\right)k(k-1)\\cdots(k-m+1)(x-a)^{k-m}g(x)\n\\end{aligned}\n\\]\n\\(m &lt; k\\) であるならば，\\(f^{(m)}(a) = 0\\)，また \\(m = k\\) であるならば\n\\[\nf^{(k)}(a) = k!g(a) \\neq 0\n\\]\n従って，必要性も示された．\n\n\n\n\nExample 4 \n\\[\nf(x) = x^4 + ax^2 + bx + c = 0\n\\]\nが \\(x=1\\) を３重解に持つようにするようにパラメータを定めたいとします．\n\\[\n\\begin{align}\nf(1) &= 1 + a + b + c = 0\\\\\nf^\\prime(1) &= 4 + 2a + b = 0\\\\\nf^{\\prime\\prime}(1) &= 12 + 2a = 0\\\\\nf^{(3)}(1) &= 24 \\neq 0\\\\\n\\end{align}\n\\]\nこれを解くと，\\((a, b, c) = (-6, 8, -3)\\)．これを用いて整理すると\n\\[\nf(x) = (x-1)^3(x+3)\n\\]\nとなります．\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\n\ndef func_x(x, a, b, c):\n    return x**4 + a*x**2 + b*x + c\n\nx_domain = np.linspace(-4, 4, 100)\n\nplt.plot(x_domain, func_x(x_domain, *(-6, 8, -3)), label='$f(x) = x^4 - 6x^2 + 8x - 3$')\nplt.plot(x_domain, func_x(x_domain, *(-8, 12, -5)), label='$f(x) = (x-1)^2(x^2+2x-5)$')\nplt.xlabel('X')\nplt.ylabel('y')\nplt.axhline(0, color='gray', linestyle='--', linewidth=0.7)\nplt.legend()\nplt.xlim(-4, 4)\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 1"
  },
  {
    "objectID": "posts/2025-02-19-make-lag-variable/index.html",
    "href": "posts/2025-02-19-make-lag-variable/index.html",
    "title": "Group毎に定義されたラグ変数の作成",
    "section": "",
    "text": "Exercise 1 \n次のようなpandas.DataFrameを考えます\n\n\nCode\nimport pandas as pd\nimport polars as pl\n\ndf = pd.DataFrame(\n    {\n        \"entity_col\": [\"A\", \"A\", \"A\", \"A\", \"A\", \"A\", \"B\", \"B\", \"B\", \"C\"],\n        \"state\": [1, 0, 1, 1, 1, 0, 0, 0, 0, 1],\n        \"time_col\": pd.to_datetime([\n            \"2021-01-02\",\n            \"2021-01-03\",\n            \"2021-01-04\",\n            \"2021-01-01\",\n            \"2021-01-03\",\n            \"2021-01-04\",\n            \"2021-02-02\",\n            \"2021-02-03\",\n            \"2021-02-10\",\n            \"2021-01-02\",\n        ]),\n        \"temp\": [1, 2, 11, 13, 12, 14, 10, 9, 8, 0],\n    }\n)\n\ndf\n\n\n\n\n\n\n\n\n\nentity_col\nstate\ntime_col\ntemp\n\n\n\n\n0\nA\n1\n2021-01-02\n1\n\n\n1\nA\n0\n2021-01-03\n2\n\n\n2\nA\n1\n2021-01-04\n11\n\n\n3\nA\n1\n2021-01-01\n13\n\n\n4\nA\n1\n2021-01-03\n12\n\n\n5\nA\n0\n2021-01-04\n14\n\n\n6\nB\n0\n2021-02-02\n10\n\n\n7\nB\n0\n2021-02-03\n9\n\n\n8\nB\n0\n2021-02-10\n8\n\n\n9\nC\n1\n2021-01-02\n0\n\n\n\n\n\n\n\n ▶  実施したい処理\n\n(entity_col, state)でGroup Keysとして，各Group内部で time_col の順番に応じて tempカラムについてラグ変数を作成したい\nラグ変数の名前は Defaultでは f\"{target_column}_1lag, 指定があった場合はそれに倣うとする"
  },
  {
    "objectID": "posts/2025-02-19-make-lag-variable/index.html#問題設定-ラグ変数の作成",
    "href": "posts/2025-02-19-make-lag-variable/index.html#問題設定-ラグ変数の作成",
    "title": "Group毎に定義されたラグ変数の作成",
    "section": "",
    "text": "Exercise 1 \n次のようなpandas.DataFrameを考えます\n\n\nCode\nimport pandas as pd\nimport polars as pl\n\ndf = pd.DataFrame(\n    {\n        \"entity_col\": [\"A\", \"A\", \"A\", \"A\", \"A\", \"A\", \"B\", \"B\", \"B\", \"C\"],\n        \"state\": [1, 0, 1, 1, 1, 0, 0, 0, 0, 1],\n        \"time_col\": pd.to_datetime([\n            \"2021-01-02\",\n            \"2021-01-03\",\n            \"2021-01-04\",\n            \"2021-01-01\",\n            \"2021-01-03\",\n            \"2021-01-04\",\n            \"2021-02-02\",\n            \"2021-02-03\",\n            \"2021-02-10\",\n            \"2021-01-02\",\n        ]),\n        \"temp\": [1, 2, 11, 13, 12, 14, 10, 9, 8, 0],\n    }\n)\n\ndf\n\n\n\n\n\n\n\n\n\nentity_col\nstate\ntime_col\ntemp\n\n\n\n\n0\nA\n1\n2021-01-02\n1\n\n\n1\nA\n0\n2021-01-03\n2\n\n\n2\nA\n1\n2021-01-04\n11\n\n\n3\nA\n1\n2021-01-01\n13\n\n\n4\nA\n1\n2021-01-03\n12\n\n\n5\nA\n0\n2021-01-04\n14\n\n\n6\nB\n0\n2021-02-02\n10\n\n\n7\nB\n0\n2021-02-03\n9\n\n\n8\nB\n0\n2021-02-10\n8\n\n\n9\nC\n1\n2021-01-02\n0\n\n\n\n\n\n\n\n ▶  実施したい処理\n\n(entity_col, state)でGroup Keysとして，各Group内部で time_col の順番に応じて tempカラムについてラグ変数を作成したい\nラグ変数の名前は Defaultでは f\"{target_column}_1lag, 指定があった場合はそれに倣うとする"
  },
  {
    "objectID": "posts/2025-02-19-make-lag-variable/index.html#前処理関数の実装",
    "href": "posts/2025-02-19-make-lag-variable/index.html#前処理関数の実装",
    "title": "Group毎に定義されたラグ変数の作成",
    "section": "前処理関数の実装",
    "text": "前処理関数の実装\n\n\n\n\n\n\nSolution: generate_lag_variable_with_group_key\n\n\n\n\n\n\nfrom typing import Optional\n\n\ndef generate_lag_variable_with_group_key(\n    df: pd.DataFrame | pl.DataFrame,\n    target_column: str,\n    sort_key: list[str],\n    group_key: list[str],\n    lag_size: int,\n    ascending: list[bool] | bool = True,\n    lagged_col_name: Optional[str] = None,\n) -&gt; pd.DataFrame | pl.DataFrame:\n    \"\"\"\n    Generate a lagged variable in a DataFrame with a specified group key.\n\n    This function creates a new column in the DataFrame that contains\n    the lagged values of an existing column, grouped by specified keys.\n    It supports both pandas and polars DataFrames.\n\n    Parameters:\n        df (pd.DataFrame | pl.DataFrame):\n            The input DataFrame, either pandas or polars.\n\n        col (str):\n            The name of the column to generate the lagged variable from.\n\n        sort_key (list[str]):\n            The list of columns to sort the DataFrame by before generating the lagged variable.\n\n        group_key (list[str]):\n            The list of columns to group the DataFrame by before generating the lagged variable.\n\n        lag_size (int):\n            The number of periods to lag the variable.\n\n        ascending (list[bool] | bool, optional):\n            The sort order for each column in sort_key. Defaults to True.\n\n        lagged_col_name (Optional[str], optional):\n            The name of the new lagged column. If None, defaults to \"{col}_{lag_size}lag\".\n\n    Returns:\n        pd.DataFrame | pl.DataFrame: The DataFrame with the new lagged variable column.\n\n    Raises:\n        TypeError: If the input DataFrame is neither pandas.DataFrame nor polars.DataFrame.\n    \"\"\"\n\n    # set up common variables\n    if lagged_col_name is None:\n        lagged_col_name = f\"{target_column}_{lag_size}lag\"\n\n    result_sort_key = group_key + sort_key\n\n    if isinstance(df, pd.DataFrame):\n        # Sort the dataframe by the specified sort key\n        df_sorted = df.sort_values(by=sort_key, ascending=ascending)\n\n        # Generate the lagged variable\n        df_sorted[lagged_col_name] = df_sorted.groupby(group_key)[target_column].shift(\n            lag_size\n        )\n\n        # Sort the dataframe by the group key and sort key\n        result_sort_key = group_key + sort_key\n        df_result = df_sorted.sort_values(by=result_sort_key).reset_index(drop=True)\n\n    elif isinstance(df, pl.DataFrame):\n        if isinstance(ascending, list):\n            order_reverse = [not x for x in ascending]\n        else:\n            order_reverse = not ascending\n\n        df_sorted = df.sort(sort_key, descending=order_reverse)\n        df_sorted = df_sorted.with_columns(\n            pl.col(target_column)\n            .shift(lag_size)\n            .over(group_key)\n            .alias(lagged_col_name)\n        )\n        df_result = df_sorted.sort(result_sort_key)\n\n    else:\n        raise TypeError(\n            f\"type(df) is {type(df)}: df should be pandas.DataFrame or polars.DataFrame\"\n        )\n\n    return df_result\n\n\n\n\n\n挙動確認\n ▶  pandas.DataFrame\n\ngenerate_lag_variable_with_group_key(\n    df=df,\n    target_column=\"temp\",\n    sort_key=[\"time_col\"],\n    group_key=[\"entity_col\", \"state\"],\n    lag_size=1,\n    ascending= [True]\n)\n\n\n\n\n\n\n\n\nentity_col\nstate\ntime_col\ntemp\ntemp_1lag\n\n\n\n\n0\nA\n0\n2021-01-03\n2\nNaN\n\n\n1\nA\n0\n2021-01-04\n14\n2.0\n\n\n2\nA\n1\n2021-01-01\n13\nNaN\n\n\n3\nA\n1\n2021-01-02\n1\n13.0\n\n\n4\nA\n1\n2021-01-03\n12\n1.0\n\n\n5\nA\n1\n2021-01-04\n11\n12.0\n\n\n6\nB\n0\n2021-02-02\n10\nNaN\n\n\n7\nB\n0\n2021-02-03\n9\n10.0\n\n\n8\nB\n0\n2021-02-10\n8\n9.0\n\n\n9\nC\n1\n2021-01-02\n0\nNaN\n\n\n\n\n\n\n\n ▶  polars.DataFrame\n\ndf_polars = pl.DataFrame(df)\ngenerate_lag_variable_with_group_key(\n    df=df_polars,\n    target_column=\"temp\",\n    sort_key=[\"time_col\"],\n    group_key=[\"entity_col\", \"state\"],\n    lag_size=1,\n)\n\n\nshape: (10, 5)\n\n\n\nentity_col\nstate\ntime_col\ntemp\ntemp_1lag\n\n\nstr\ni64\ndatetime[ns]\ni64\ni64\n\n\n\n\n\"A\"\n0\n2021-01-03 00:00:00\n2\nnull\n\n\n\"A\"\n0\n2021-01-04 00:00:00\n14\n2\n\n\n\"A\"\n1\n2021-01-01 00:00:00\n13\nnull\n\n\n\"A\"\n1\n2021-01-02 00:00:00\n1\n13\n\n\n\"A\"\n1\n2021-01-03 00:00:00\n12\n1\n\n\n\"A\"\n1\n2021-01-04 00:00:00\n11\n12\n\n\n\"B\"\n0\n2021-02-02 00:00:00\n10\nnull\n\n\n\"B\"\n0\n2021-02-03 00:00:00\n9\n10\n\n\n\"B\"\n0\n2021-02-10 00:00:00\n8\n9\n\n\n\"C\"\n1\n2021-01-02 00:00:00\n0\nnull\n\n\n\n\n\n\n\n\nUnit test with pytest\n\n📘 テスト方針 \n\n異なるラグサイズ（lag size）の処理: ラグサイズの値を自由に指定できるか？\nカスタムラグカラム名の指定: ラグカラムに任意の名前を付けることができるか？。\nソート順の指定: 昇順（ascending=True）または降順（ascending=False）でソートできるか？\n不正な入力タイプのエラー処理: 入力値が不正な場合，適切なエラーメッセージを表示するか？\n\n\n ▶  Test Examples\n\nimport pytest\nimport pandas as pd\nimport polars as pl\nimport numpy as np\n\n# Import the function to be tested\n# from hogehoge import generate_lag_variable_with_group_key  # Replace with actual module name\n\n@pytest.fixture\ndef sample_pandas_df():\n    \"\"\"Fixture to provide a sample Pandas DataFrame\"\"\"\n    return pd.DataFrame({\n        \"entity\": [\"A\", \"A\", \"A\", \"B\", \"B\", \"B\"],\n        \"time\": [\"2023-01-01\", \"2023-01-02\", \"2023-01-03\",\n                 \"2023-01-01\", \"2023-01-02\", \"2023-01-03\"],\n        \"value\": [10, 20, 30, 100, 200, 300]\n    }).assign(time=lambda df: pd.to_datetime(df[\"time\"]))  # Ensure datetime type\n\n@pytest.fixture\ndef sample_polars_df():\n    \"\"\"Fixture to provide a sample Polars DataFrame\"\"\"\n    return pl.DataFrame({\n        \"entity\": [\"A\", \"A\", \"A\", \"B\", \"B\", \"B\"],\n        \"time\": [\"2023-01-01\", \"2023-01-02\", \"2023-01-03\",\n                 \"2023-01-01\", \"2023-01-02\", \"2023-01-03\"],\n        \"value\": [10, 20, 30, 100, 200, 300]\n    }).with_columns(pl.col(\"time\").str.to_date())  # Ensure datetime type\n\n@pytest.mark.parametrize(\"df_type\", [\"pandas\", \"polars\"])\ndef test_generate_lag_variable_basic(df_type, sample_pandas_df, sample_polars_df):\n    \"\"\"Test basic functionality with Pandas and Polars\"\"\"\n    df = sample_pandas_df if df_type == \"pandas\" else sample_polars_df\n    result = generate_lag_variable_with_group_key(\n        df=df,\n        target_column=\"value\",\n        sort_key=[\"time\"],\n        group_key=[\"entity\"],\n        lag_size=1\n    )\n\n    assert \"value_1lag\" in result.columns, \"Lagged column not found!\"\n    expected_values_pandas = [np.nan, 10.0, 20.0, np.nan, 100.0, 200.0]  # Expected shifted values\n    expected_values_polars = [None, 10, 20, None, 100, 200]  # Expected shifted values\n    if df_type == \"pandas\":\n        assert np.array_equal(result[\"value_1lag\"].to_list(), expected_values_pandas, equal_nan=True)\n    else:\n        assert result[\"value_1lag\"].to_list() == expected_values_polars \n\ndef test_generate_lag_variable_custom_column(sample_pandas_df):\n    \"\"\"Test if custom column name works correctly\"\"\"\n    result = generate_lag_variable_with_group_key(\n        df=sample_pandas_df,\n        target_column=\"value\",\n        sort_key=[\"time\"],\n        group_key=[\"entity\"],\n        lag_size=1,\n        lagged_col_name=\"custom_lag\"\n    )\n    assert \"custom_lag\" in result.columns, \"Custom lag column name not applied!\"\n\ndef test_generate_lag_variable_with_descending_order(sample_pandas_df):\n    \"\"\"Test sorting order with descending time\"\"\"\n    result = generate_lag_variable_with_group_key(\n        df=sample_pandas_df,\n        target_column=\"value\",\n        sort_key=[\"time\"],\n        group_key=[\"entity\"],\n        lag_size=1,\n        ascending=False  # Reverse sorting order\n    )\n    expected_values = [20.0, 30.0, np.nan, 200.0, 300.0, np.nan]  # Because order is reversed\n    assert np.array_equal(result[\"value_1lag\"].to_list(), expected_values, equal_nan=True)\n\ndef test_generate_lag_variable_invalid_input():\n    \"\"\"Test function raises TypeError for invalid input\"\"\"\n    with pytest.raises(TypeError):\n        generate_lag_variable_with_group_key(\n            df=\"not_a_dataframe\",  # Invalid type\n            target_column=\"value\",\n            sort_key=[\"time\"],\n            group_key=[\"entity\"],\n            lag_size=1\n        )\n\n\n注意点 ! \n\nnp.nan != np.nan であるため，np.nanを含むリストを比較する場合，== を直接使用しても正しく機能しません\nNaN は未定義値であるため，NaN は自身と等しくない"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Regmonkey Datascience Blog",
    "section": "",
    "text": "Order By\n      Default\n      \n        Date - Oldest\n      \n      \n        Date - Newest\n      \n      \n        Title\n      \n    \n  \n    \n      \n      \n    \n\n\n\n\n\n\nDate\n\n\n\nTitle\n\n\n\nCategories\n\n\n\nReading Time\n\n\n\n\n\n\n\n\n2025-05-30\n\n\nドキュメントの書き方\n\n\n方法論\n\n\n2 min\n\n\n\n\n\n\n2025-05-23\n\n\nwikiにどのような情報をどのように残すか？\n\n\n方法論, 環境構築\n\n\n5 min\n\n\n\n\n\n\n2025-05-19\n\n\nRoo Code環境構築\n\n\n環境構築\n\n\n7 min\n\n\n\n\n\n\n2025-05-01\n\n\nCSSの組み込み方\n\n\nhtml, quarto\n\n\n1 min\n\n\n\n\n\n\n2025-04-30\n\n\nCSSで使う単位\n\n\nhtml, quarto\n\n\n4 min\n\n\n\n\n\n\n2025-04-29\n\n\nシェルコマンドTips\n\n\nshell\n\n\n3 min\n\n\n\n\n\n\n2025-04-10\n\n\nD3を用いた散布図生成\n\n\nD3, EDA\n\n\n1 min\n\n\n\n\n\n\n2025-04-09\n\n\nベクトル空間における外積\n\n\n線形代数\n\n\n18 min\n\n\n\n\n\n\n2025-04-08\n\n\n確率行列と固有値\n\n\n線形代数, 統計\n\n\n2 min\n\n\n\n\n\n\n2025-04-07\n\n\nベクトル空間における内積\n\n\n線形代数, 複素数\n\n\n10 min\n\n\n\n\n\n\n2025-03-05\n\n\n三角関数の加法定理\n\n\n三角関数\n\n\n7 min\n\n\n\n\n\n\n2025-03-03\n\n\nいろいろな三角不等式\n\n\n複素数, 幾何, 線形代数\n\n\n5 min\n\n\n\n\n\n\n2025-03-02\n\n\n敵の砲台の座標を探せ 1/N\n\n\n幾何\n\n\n9 min\n\n\n\n\n\n\n2025-03-01\n\n\nヘロンの公式の導出\n\n\n幾何\n\n\n2 min\n\n\n\n\n\n\n2025-02-28\n\n\nカバリエリの原理\n\n\n幾何\n\n\n14 min\n\n\n\n\n\n\n2025-02-27\n\n\ntangent 75°の図形的計算\n\n\n三角関数\n\n\n2 min\n\n\n\n\n\n\n2025-02-26\n\n\n余弦定理の考え方\n\n\n三角関数\n\n\n5 min\n\n\n\n\n\n\n2025-02-25\n\n\n正弦定理の考え方\n\n\n三角関数\n\n\n7 min\n\n\n\n\n\n\n2025-02-20\n\n\npivot tableのcolumn, rowのsort\n\n\npython, 前処理\n\n\n3 min\n\n\n\n\n\n\n2025-02-19\n\n\nGroup毎に定義されたラグ変数の作成\n\n\npython, 前処理\n\n\n9 min\n\n\n\n\n\n\n2025-02-14\n\n\n本日の詰将棋: Quiz 1~5\n\n\n将棋\n\n\n1 min\n\n\n\n\n\n\n2025-02-13\n\n\n複素平面と複素数による回転\n\n\n複素数\n\n\n12 min\n\n\n\n\n\n\n2025-02-05\n\n\n測量法における測量の分類\n\n\n測量\n\n\n1 min\n\n\n\n\n\n\n2025-02-04\n\n\n単曲線と追加距離の計算\n\n\n三角関数, 測量\n\n\n4 min\n\n\n\n\n\n\n2025-02-03\n\n\n関数の連続性\n\n\n解析\n\n\n7 min\n\n\n\n\n\n\n2025-02-02\n\n\n有限個の多項式のテイラー展開\n\n\n解析\n\n\n4 min\n\n\n\n\n\n\n2025-02-01\n\n\n18世紀までの関数論とテイラー展開\n\n\n解析\n\n\n5 min\n\n\n\n\n\n\n2025-01-30\n\n\n微分方程式を用いたToy models\n\n\n微分方程式\n\n\n5 min\n\n\n\n\n\n\n2025-01-29\n\n\nフーリエ級数と積分理論再考\n\n\nフーリエ変換\n\n\n4 min\n\n\n\n\n\n\n2025-01-28\n\n\n数理モデルの作り方\n\n\n方法論\n\n\n1 min\n\n\n\n\n\n\n2025-01-27\n\n\n指数関数の微分\n\n\n解析\n\n\n2 min\n\n\n\n\n\n\n2025-01-08\n\n\nBigQuery: TIME型カラムを指定したレベルで丸めて集計する\n\n\nsql\n\n\n2 min\n\n\n\n\n\n\n2024-12-19\n\n\n自分用VSCodeショートカットシート\n\n\n環境構築, shortcuts\n\n\n2 min\n\n\n\n\n\n\n2024-12-18\n\n\nSecure Shellの仕組み\n\n\nssh\n\n\n5 min\n\n\n\n\n\n\n2024-12-17\n\n\nFirefoxを用いたsocks5 proxyブラウザアクセス設定\n\n\nfirefox, network\n\n\n2 min\n\n\n\n\n\n\n2024-12-16\n\n\nmacOSへのssh接続\n\n\nssh, 環境構築\n\n\n1 min\n\n\n\n\n\n\n2024-12-11\n\n\nCloud StorageからExternal Tableの作成\n\n\nBigQuery\n\n\n2 min\n\n\n\n\n\n\n2024-12-07\n\n\nIPアドレス 0.0.0.0\n\n\nnetwork, quarto\n\n\n3 min\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "link_list/link_table.html",
    "href": "link_list/link_table.html",
    "title": "便利リンク集",
    "section": "",
    "text": "genre\n      comment\n      url\n    \n  \n\n\n    \n        \n        \n        \n        \n        \n        \n        \n        \n    \n    \n   \n    \n      \n  \n        \n    \n    \n  \n        \n    \n    \n  \n        \n    \n      \n  \n        \n            \n                \n                \n            \n            \n                \n                \n            \n            \n                \n                \n            \n            \n                \n                \n            \n            \n                \n                \n            \n        \n    \n\n\nLoading ITables v2.2.5 from the internet...\n(need help?)"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "某経済学研究科修士取得後，どこかのデータサイエンス（コンサル）会社に勤務してます． Arsenalが好きです．"
  },
  {
    "objectID": "index_by_series.html",
    "href": "index_by_series.html",
    "title": "Regmonkey Datascience Blog",
    "section": "",
    "text": "Date\n\n\n\nTitle\n\n\n\nCategories\n\n\n\nReading Time\n\n\n\n\n\n\n\n\n2025-02-14\n\n\n本日の詰将棋: Quiz 1~5\n\n\n将棋\n\n\n1 min\n\n\n\n\n\n\n2025-02-05\n\n\n測量法における測量の分類\n\n\n測量\n\n\n1 min\n\n\n\n\n\n\n2025-02-04\n\n\n単曲線と追加距離の計算\n\n\n三角関数, 測量\n\n\n4 min\n\n\n\n\n\n\n2024-12-07\n\n\nIPアドレス 0.0.0.0\n\n\nnetwork, quarto\n\n\n3 min\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "index_by_series.html#徒然日記",
    "href": "index_by_series.html#徒然日記",
    "title": "Regmonkey Datascience Blog",
    "section": "",
    "text": "Date\n\n\n\nTitle\n\n\n\nCategories\n\n\n\nReading Time\n\n\n\n\n\n\n\n\n2025-02-14\n\n\n本日の詰将棋: Quiz 1~5\n\n\n将棋\n\n\n1 min\n\n\n\n\n\n\n2025-02-05\n\n\n測量法における測量の分類\n\n\n測量\n\n\n1 min\n\n\n\n\n\n\n2025-02-04\n\n\n単曲線と追加距離の計算\n\n\n三角関数, 測量\n\n\n4 min\n\n\n\n\n\n\n2024-12-07\n\n\nIPアドレス 0.0.0.0\n\n\nnetwork, quarto\n\n\n3 min\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "index_by_series.html#datascience",
    "href": "index_by_series.html#datascience",
    "title": "Regmonkey Datascience Blog",
    "section": "Datascience",
    "text": "Datascience\n\nGeneral\n\n\n    \n      \n      \n    \n\n\n\n\n\n\nDate\n\n\n\nTitle\n\n\n\nCategories\n\n\n\nReading Time\n\n\n\n\n\n\n\n\n2025-04-10\n\n\nD3を用いた散布図生成\n\n\nD3, EDA\n\n\n1 min\n\n\n\n\n\n\n2025-04-08\n\n\n確率行列と固有値\n\n\n線形代数, 統計\n\n\n2 min\n\n\n\n\n\n\n2025-03-02\n\n\n敵の砲台の座標を探せ 1/N\n\n\n幾何\n\n\n9 min\n\n\n\n\n\n\nNo matching items\n\n\n\n前処理\n\n\n    \n      \n      \n    \n\n\n\n\n\n\nDate\n\n\n\nTitle\n\n\n\nCategories\n\n\n\nReading Time\n\n\n\n\n\n\n\n\n2025-02-20\n\n\npivot tableのcolumn, rowのsort\n\n\npython, 前処理\n\n\n3 min\n\n\n\n\n\n\n2025-02-19\n\n\nGroup毎に定義されたラグ変数の作成\n\n\npython, 前処理\n\n\n9 min\n\n\n\n\n\n\n2025-01-08\n\n\nBigQuery: TIME型カラムを指定したレベルで丸めて集計する\n\n\nsql\n\n\n2 min\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "index_by_series.html#数学",
    "href": "index_by_series.html#数学",
    "title": "Regmonkey Datascience Blog",
    "section": "数学",
    "text": "数学\n\nGeneral\n\n\n    \n      \n      \n    \n\n\n\n\n\n\nDate\n\n\n\nTitle\n\n\n\nCategories\n\n\n\nReading Time\n\n\n\n\n\n\n\n\n2025-04-09\n\n\nベクトル空間における外積\n\n\n線形代数\n\n\n18 min\n\n\n\n\n\n\n2025-04-07\n\n\nベクトル空間における内積\n\n\n線形代数, 複素数\n\n\n10 min\n\n\n\n\n\n\n2025-03-05\n\n\n三角関数の加法定理\n\n\n三角関数\n\n\n7 min\n\n\n\n\n\n\n2025-03-03\n\n\nいろいろな三角不等式\n\n\n複素数, 幾何, 線形代数\n\n\n5 min\n\n\n\n\n\n\n2025-03-01\n\n\nヘロンの公式の導出\n\n\n幾何\n\n\n2 min\n\n\n\n\n\n\n2025-02-28\n\n\nカバリエリの原理\n\n\n幾何\n\n\n14 min\n\n\n\n\n\n\n2025-02-27\n\n\ntangent 75°の図形的計算\n\n\n三角関数\n\n\n2 min\n\n\n\n\n\n\n2025-02-26\n\n\n余弦定理の考え方\n\n\n三角関数\n\n\n5 min\n\n\n\n\n\n\n2025-02-25\n\n\n正弦定理の考え方\n\n\n三角関数\n\n\n7 min\n\n\n\n\n\n\n2025-02-02\n\n\n有限個の多項式のテイラー展開\n\n\n解析\n\n\n4 min\n\n\n\n\n\n\n2025-01-30\n\n\n微分方程式を用いたToy models\n\n\n微分方程式\n\n\n5 min\n\n\n\n\n\n\n2025-01-28\n\n\n数理モデルの作り方\n\n\n方法論\n\n\n1 min\n\n\n\n\n\n\n2025-01-27\n\n\n指数関数の微分\n\n\n解析\n\n\n2 min\n\n\n\n\n\n\nNo matching items\n\n  \n\n\n\n\n集合と位相 Series\n\n\n    \n      \n      \n    \n\n\n\n\n\n\nDate\n\n\n\nTitle\n\n\n\nCategories\n\n\n\nReading Time\n\n\n\n\n\n\n\n\n2025-02-03\n\n\n関数の連続性\n\n\n解析\n\n\n7 min\n\n\n\n\n\n\n2025-02-01\n\n\n18世紀までの関数論とテイラー展開\n\n\n解析\n\n\n5 min\n\n\n\n\n\n\n2025-01-29\n\n\nフーリエ級数と積分理論再考\n\n\nフーリエ変換\n\n\n4 min\n\n\n\n\n\n\nNo matching items\n\n\n\n複素解析 Series\n\n\n    \n      \n      \n    \n\n\n\n\n\n\nDate\n\n\n\nTitle\n\n\n\nCategories\n\n\n\nReading Time\n\n\n\n\n\n\n\n\n2025-02-13\n\n\n複素平面と複素数による回転\n\n\n複素数\n\n\n12 min\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "index_by_series.html#開発スキル",
    "href": "index_by_series.html#開発スキル",
    "title": "Regmonkey Datascience Blog",
    "section": "開発スキル",
    "text": "開発スキル\n\n\n    \n      \n      \n    \n\n\n\n\n\n\nDate\n\n\n\nTitle\n\n\n\nCategories\n\n\n\nReading Time\n\n\n\n\n\n\n\n\n2025-05-30\n\n\nドキュメントの書き方\n\n\n方法論\n\n\n2 min\n\n\n\n\n\n\n2025-05-23\n\n\nwikiにどのような情報をどのように残すか？\n\n\n方法論, 環境構築\n\n\n5 min\n\n\n\n\n\n\n2025-05-19\n\n\nRoo Code環境構築\n\n\n環境構築\n\n\n7 min\n\n\n\n\n\n\n2025-05-01\n\n\nCSSの組み込み方\n\n\nhtml, quarto\n\n\n1 min\n\n\n\n\n\n\n2025-04-30\n\n\nCSSで使う単位\n\n\nhtml, quarto\n\n\n4 min\n\n\n\n\n\n\n2025-04-29\n\n\nシェルコマンドTips\n\n\nshell\n\n\n3 min\n\n\n\n\n\n\n2024-12-19\n\n\n自分用VSCodeショートカットシート\n\n\n環境構築, shortcuts\n\n\n2 min\n\n\n\n\n\n\n2024-12-18\n\n\nSecure Shellの仕組み\n\n\nssh\n\n\n5 min\n\n\n\n\n\n\n2024-12-17\n\n\nFirefoxを用いたsocks5 proxyブラウザアクセス設定\n\n\nfirefox, network\n\n\n2 min\n\n\n\n\n\n\n2024-12-16\n\n\nmacOSへのssh接続\n\n\nssh, 環境構築\n\n\n1 min\n\n\n\n\n\n\n2024-12-11\n\n\nCloud StorageからExternal Tableの作成\n\n\nBigQuery\n\n\n2 min\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "dashboard/dashboard.html",
    "href": "dashboard/dashboard.html",
    "title": "regmonkey datascience blog",
    "section": "",
    "text": "Total Posts\n\n\n38\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPosts in This Month\n\n\n0\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLast Update\n\n\n\n\n2025-06-05"
  },
  {
    "objectID": "posts/2025-02-03-continuous-function/index.html",
    "href": "posts/2025-02-03-continuous-function/index.html",
    "title": "関数の連続性",
    "section": "",
    "text": "変数 \\(x\\) が限りなく \\(a\\) に近づくとき，\\(f(x)\\) も \\(f(a)\\) に近づくならば，\\(f(x)\\) は \\(x=a\\) において連続である，といいます．つまり，\n\\[\nx\\to a \\text{ ならば } f(x) \\to f(a)\n\\]\n\nDef: \\(\\epsilon\\)-\\(\\delta\\) 論法的連続性 \n任意の \\(\\epsilon &gt;0\\) に対して，ある \\(\\delta &gt; 0\\) が存在して，\n\\[\n\\vert x - a \\vert &lt; \\delta \\Rightarrow \\vert f(x) - f(a)\\vert &lt; \\epsilon\n\\]\nを満たすとき，\\(x=a\\) において \\(f(x)\\) は連続であるという．\n\n\nExample 1 \n\\(f(x) = \\sqrt{x}\\) について，\\(a &gt; 0\\) で連続であることを以下示します．\n\\[\n\\begin{align}\n\\vert \\sqrt{x} - \\sqrt{a} \\vert\n    &= \\left\\vert\\frac{(\\sqrt{x} - \\sqrt{a})(\\sqrt{x} + \\sqrt{a})}{\\sqrt{x}+\\sqrt{a}}\\right\\vert\\\\\n    &= \\left\\vert\\frac{x - a}{\\sqrt{x}+\\sqrt{a}}\\right\\vert\\\\\n    &\\leq \\left\\vert\\frac{x - a}{\\sqrt{a}}\\right\\vert\n\\end{align}\n\\]\nここで，\\(\\vert x - a\\vert &lt; \\delta(\\epsilon) = \\epsilon\\sqrt{a}\\) と定めると\n\\[\n\\vert x - a\\vert &lt; \\delta(\\epsilon) \\Rightarrow \\vert \\sqrt{x} - \\sqrt{a}\\vert &lt; \\epsilon\n\\]\n\n\n\nExample 2 : 三角関数の連続性 \n\\(x = a + h\\) とおくと，和積の公式を用いて\n\\[\n\\begin{align}\n\\vert \\sin(x) - \\sin(a) \\vert\n    &= 2\\left\\vert \\cos\\frac{x+a}{2}\\sin\\frac{x-a}{2} \\right\\vert\\\\\n    &= 2\\left\\vert \\cos\\left(a + \\frac{h}{2}\\right)\\sin\\frac{h}{2} \\right\\vert\\\\\n    &\\leq 2\\left\\vert\\frac{h}{2}\\right\\vert \\cdot 1\\\\\n    &=\\vert h \\vert\n\\end{align}\n\\]\n\\(\\cos x = \\sin\\left(x + \\frac{\\pi}{2}\\right)\\) であるので，\\(\\sin x\\) が連続であるならば, \\(\\cos x\\) も連続．\n\n\n\n\nTheorem 1  : 連続関数の定数倍\n\\(f(x)\\) は \\(x=a\\) で連続であるとします．このとき，定数 \\(c\\) を用いた \\(cf(x)\\) も \\(x=a\\) にて連続となります．\n\n\n\n\n\n\n\n\n\nProof\n\n\n\n\n\n仮定より\n\\[\n\\forall \\eta &gt; 0, \\exists \\delta(\\eta) &gt; 0, \\vert x - a\\vert &lt; \\delta(\\eta)\\Rightarrow\\vert f(x) - f(a)\\vert &lt; \\eta\n\\]\nこのとき，任意の \\(\\epsilon &gt; 0\\) に対して，\n\\[\n\\eta = \\frac{\\epsilon}{\\vert c \\vert} &gt;0\n\\]\nと対応させると，\n\\[\n\\forall \\epsilon &gt; 0, \\exists \\delta(\\epsilon) &gt; 0, \\vert x - a\\vert &lt; \\delta(\\epsilon)\\Rightarrow\\vert f(x) - f(a)\\vert &lt; \\frac{\\epsilon}{\\vert c \\vert }\n\\]\nつまり，\n\\[\n\\forall \\epsilon &gt; 0, \\exists \\delta(\\epsilon) &gt; 0, \\vert x - a\\vert &lt; \\delta(\\epsilon)\\Rightarrow \\vert c\\vert\\vert f(x) - f(a)\\vert &lt; \\epsilon\n\\]\nこれを変形すると\n\\[\n\\forall \\epsilon &gt; 0, \\exists \\delta(\\epsilon) &gt; 0, \\vert x - a\\vert &lt; \\delta(\\epsilon)\\Rightarrow \\vert cf(x) - cf(a)\\vert &lt; \\epsilon\n\\]\n\n\n\n\n\nTheorem 2 : 連続関数の和\n\n\\(f(x), g(x)\\) は \\(x=a\\) で連続であるとします．このとき，\\(f(x) + g(x)\\) も \\(x=a\\) にて連続となります．\n\n\n\n\n\n\n\n\n\nProof\n\n\n\n\n\n仮定より\n\\[\n\\begin{align}\n\\vert x - a \\vert &lt; \\delta&\\Rightarrow \\vert f(x) - f(a)\\vert &lt; \\epsilon/2\\\\\n\\vert x - a \\vert &lt; \\eta&\\Rightarrow \\vert g(x) - g(a)\\vert &lt; \\epsilon/2\n\\end{align}\n\\]\nここで，\\(M = \\min(\\delta, \\eta)\\) とすると，\n\\[\n\\begin{align}\n\\vert x - a \\vert &lt; M&\\Rightarrow \\vert f(x) - f(a)\\vert &lt; \\epsilon/2\\\\\n\\vert x - a \\vert &lt; M&\\Rightarrow \\vert g(x) - g(a)\\vert &lt; \\epsilon/2\n\\end{align}\n\\]\nまた\n\\[\n\\begin{align}\n\\vert(f(x) - g(x)) - (f(a) + g(a))\n    &= \\vert(f(x) - f(a)) + (g(x) + g(a))\\vert\\\\\n    &\\leq \\vert(f(x) - f(a))\\vert + \\vert (g(x) + g(a))\\vert\n\\end{align}\n\\]\n従って，\\(\\vert x - a \\vert &lt; M\\) であるならば\n\\[\n\\begin{align}\n\\vert (g(x) + f(x)) - (g(a) + f(a))\\vert \\leq \\vert(f(x) - f(a))\\vert + \\vert (g(x) + g(a))\\vert &lt; \\epsilon\n\\end{align}\n\\]\n\n\n\n\n\nTheorem 3  : 連続関数の線型結合\n\\(f(x), g(x)\\) は \\(x=a\\) で連続であるとします．このとき，定数 \\(c_1, c_2\\)に対して \\(c_1f(x) + c_2g(x)\\) も \\(x=a\\) にて連続となります．\n\n\n\n\n\n\n\n\n\nProof\n\n\n\n\n\n\\[\n\\begin{align}\n\\vert x - a \\vert &lt; \\delta&\\Rightarrow \\vert f(x) - f(a)\\vert &lt; \\frac{\\epsilon}{2\\vert c_1\\vert}\\\\\n\\vert x - a \\vert &lt; \\eta&\\Rightarrow \\vert g(x) - g(a)\\vert &lt; \\frac{\\epsilon}{2\\vert c_2\\vert}\n\\end{align}\n\\]\nとして，\\(M = \\min(\\delta, \\eta)\\) とすれば，上記と同様に連続性を示すことができます．\n\n\n\n\n\nTheorem 4  : 連続関数の積\n\\(f(x), g(x)\\) は \\(x=a\\) で連続であるとします．このとき，\\(f(x)g(x)\\) も \\(x=a\\) にて連続となります．\n\n\n\n\n\n\n\n\n\nProof\n\n\n\n\n\n\\[\n\\vert x - a \\vert &lt; \\delta(1) \\Rightarrow \\vert f(x) - f(a)\\vert &lt; 1\n\\]\nとすると，\n\\[\n\\vert x - a \\vert &lt; \\delta(1) \\Rightarrow \\vert f(x) \\vert &lt; 1 + \\vert f(a) \\vert\n\\]\n\\(\\delta, \\eta\\) を以下のように定め，\n\\[\n\\begin{align}\n\\vert x - a \\vert &lt; \\delta &\\Rightarrow \\vert f(x) - f(a)\\vert &lt; \\frac{\\epsilon}{2(1 + \\vert f(a) \\vert + \\vert g(a) \\vert)}\\\\\n\\vert x - a \\vert &lt; \\eta &\\Rightarrow \\vert g(x) - g(a)\\vert &lt; \\frac{\\epsilon}{2(1 + \\vert f(a) \\vert + \\vert g(a) \\vert)}\n\\end{align}\n\\]\n\\[\n\\delta(\\epsilon) = \\min (\\delta(1), \\delta, \\eta)\n\\]\nとすると，\n\\[\n\\begin{align}\n\\vert x - a \\vert &lt; \\delta(\\epsilon)\n    \\Rightarrow &\\vert f(x)g(x) - f(a)g(a)\\vert\\\\[5pt]\n    &= \\vert f(x)(g(x) - g(a)) + g(a)(f(x) - f(a))\\vert\\\\[5pt]\n    &\\leq \\vert f(x)\\vert \\vert(g(x) - g(a))\\vert + \\vert g(a)\\vert\\vert(f(x) - f(a))\\vert\\\\[5pt]\n    &&lt; (1 + \\vert f(a) \\vert)\\frac{\\epsilon}{2(1 + \\vert f(a) \\vert + \\vert g(a) \\vert)} + \\vert g(a)\\vert \\frac{\\epsilon}{2(1 + \\vert f(a) \\vert + \\vert g(a) \\vert)}\\\\\n    &= \\epsilon\n\\end{align}\n\\]\nよって，連続性が示された．\n\n\n\n\n\nTheorem 5  連続関数の逆数 \n\\(f(x)\\) は \\(x=a\\) で連続であるとします．このとき，\\(f(a)\\neq 0\\) であるならば \\(1/f(x)\\) も \\(x=a\\) にて連続となります．\n\n\n\n\n\n\n\n\n\nProof\n\n\n\n\n\n連続性の仮定より\n\\[\n\\vert x - a \\vert &lt; \\delta(\\vert f(a)/2\\vert) \\Rightarrow \\vert f(x) - f(a)\\vert &lt; \\frac{\\vert f(a)\\vert}{2}\n\\]\nとすると，\n\\[\n\\vert x - a \\vert &lt; \\delta(\\vert f(a)/2\\vert) \\Rightarrow \\frac{\\vert f(a)\\vert}{2} &lt; \\vert f(x)\\vert\n\\]\nこのとき，\n\\[\n\\begin{align}\n\\left\\vert \\frac{1}{f(x)} - \\frac{1}{f(a)} \\right\\vert\n    &= \\left\\vert \\frac{f(x) - f(a)}{f(x)f(a)} \\right\\vert\\\\\n    &&lt; \\left\\vert \\frac{f(x) - f(a)}{(f(a))^2 / 2} \\right\\vert\n\\end{align}\n\\]\n従って，\\(\\vert x - a \\vert &lt; \\eta \\Rightarrow \\vert f(x) - f(a)\\vert &lt; \\displaystyle\\frac{\\epsilon\\vert (f(a))^2\\vert}{2}\\) となるような \\(\\eta\\) を用いて，\n\\[\n\\delta(\\epsilon) = \\min(\\delta(\\vert f(a)/2\\vert), \\eta)\n\\]\nとすれば\n\\[\n\\vert x - a \\vert &lt; \\delta(\\epsilon) \\Rightarrow \\left\\vert \\frac{1}{f(x)} - \\frac{1}{f(a)} \\right\\vert &lt; \\epsilon\n\\]\n\n\n\n\n\n点 \\(a\\) における極限を考えるとき，\n\n\\(x\\) が増大しつつ \\(a\\) に（左側から）近づく, \\(\\lim_{x\\to a-0}\\)\n\\(x\\) が減少しつつ \\(a\\) に（右側から）近づく, \\(\\lim_{x\\to a+0}\\)\n\nそれぞれの場合を分けて取り扱うことがあります．\n\nExample 3 \n\\(f(x) = \\tan x\\) について，\\(x = \\pi/2\\) における極限を考えてみます．\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport sympy as sy\n\nx = sy.Symbol('x')\nf = sy.tan(x)\n\nx_vals = np.linspace(-np.pi/2+1e-6, np.pi, 400)\ny_vals = np.tan(x_vals)\n\nplt.figure(figsize=(8, 6))\nplt.plot(x_vals, y_vals, label=r'$f(x) = \\tan(x)$')\nplt.ylim(-10, 10)\nplt.xticks([-np.pi/2, 0, np.pi/2, np.pi], [r'$-\\frac{\\pi}{2}$', '0', r'$\\frac{\\pi}{2}$', r'$\\pi$'])\nplt.axvline(np.pi/2, color='r', linestyle='--', label=r'$x = \\frac{\\pi}{2}$')\nplt.axhline(0, color='black',linewidth=0.5)\nplt.axvline(0, color='black',linewidth=0.5)\nplt.title(r'Plot of $f(x) = \\tan(x)$ around $x = \\frac{\\pi}{2}$')\nplt.xlabel('x')\nplt.ylabel('f(x)')\nplt.legend()\nplt.grid(True)\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 1\n\n\n\n上記の図のように，\n\\[\n\\begin{align}\n\\lim_{x\\to \\pi/2+0} \\tan x &= -\\infty\\\\\n\\lim_{x\\to \\pi/2-0} \\tan x &= \\infty\n\\end{align}\n\\]\n実際に，sympy で確認してみると\n\n# DO NOT USE np.pi\nprint(f\"左極限: {sy.limit(sy.tan(x), x, sy.pi/2, '-')}\")\nprint(f\"右極限: {sy.limit(sy.tan(x), x, sy.pi/2, '+')}\")\n\n左極限: oo\n右極限: -oo\n\n\n\n\n ▶  右連続と左連続\n\\[\n\\begin{align}\nf(a) &= \\alpha\\\\[5pt]\n\\lim_{x\\to a-0} f(x) &= \\alpha\\\\\n\\lim_{x\\to a+0} f(x) &= \\beta \\neq \\alpha\n\\end{align}\n\\]\nのとき，\\(f(x)\\) は \\(x = a\\) において左連続といいます．\n\\(f(x)\\) が閉区間 \\([a, b]\\) において定義されているとき，\n\n\\(x=a\\) においては右連続\n\\(x=b\\) においては左連続\n\nであることを意味します．開区間 \\((a, b)\\) において定義されているとき，\\(f(a+0)\\) が確定ならば，それを \\(f(a)\\) として定義域を \\([a, b)\\) 区間に拡張すると \\(f(x)\\) は \\(x=a\\) において右連続になります．\n一方，\\((0, \\infty)\\) 区間で定義された関数 \\(\\displaystyle f(x) = \\frac{1}{x}\\) は開区間では連続ですが，\\(x = 0\\) のときは定義されません．このとき，\\(f(0) = 0\\) として定義域を \\([0, \\infty)\\) に拡張すると，\\(x=0\\) で連続な関数にはなりませんし，\\(f(0)\\) をどんな値にしたとしても，\\(x=0\\) の近傍において, \\(f(x)\\) はいくらでも大きくなってしまうので，連続な関数にはなりません．\n\n📘 REMARKS \n\n開区間 \\((a, b)\\) で定義された連続な関数が，開区間 \\([a, b]\\) の連続な関数に拡張できるとは限らない\n\n\n\nExample 4  : 右連続関数と累積分布関数 \n離散確率変数 \\(X\\sim\\operatorname{Bin}(5, 1/3)\\) を考えます．離散確率変数の累積分布関数 \\(F(x)\\) は\n\\[\nF(x) = \\operatorname{P}(X \\leq x) = \\sum_{y\\leq x}p(y) \\qquad p(y): \\text{確率関数}\n\\]\nと定義されるので，\\(F(x)\\) は右側連続となります．実際に\n\nCode\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom scipy.stats import binom\n\nn, p = 5, 1 / 3\nx = np.arange(0, 6)\ncdf = binom.cdf(x, n, p)\n\nfig, ax = plt.subplots(1, 1)\nax.hlines(cdf, x, x + 1, color=\"gray\")\nax.step(x, cdf, where=\"post\", color=\"gray\", linestyle=\"dotted\")\nax.plot(x, cdf, \"o\", color=\"gray\")\nax.scatter(x[:-1] + 1, cdf[:-1], marker=\"$\\u25EF$\", alpha=0.5, color=\"gray\")\nax.set_xlabel(\"x\")\nax.set_ylabel(\"F(x)\")\nax.set_title(\"CDF of Binomial Distribution (n=5, p=1/3)\")\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 2\n\n\n\nこのとき，確率関数は\n\\[\np(x) = F(x) - \\lim_{x_n\\to x-0}F(x_n)\n\\]\nとすることで計算することが出来ます．一方，\\(F(x) = \\operatorname{P}(X &lt; x)\\) と定義すると左連続となります．\n\n\n\n\n\n\\[\nf(x) = \\frac{\\sin x}{x}\n\\]\nを考えます．この関数は \\(x - 0\\) で定義されていないですが\n\\[\n\\begin{align}\nf(x) = \\left\\{\\begin{array}{c}\n\\frac{\\sin x}{x} & (x\\neq 0)\\\\\n1 & (x = 0)\n\\end{array}\\right.\n\\end{align}\n\\]\nと \\(x = 0\\) で連続かつ微分可能になるように拡張することが出来ます．この拡張された関数を特にsinc関数と呼びます．\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Define the sinc function\ndef sinc(x):\n    return np.sinc(x / np.pi)\n\ndef inverse_x(x):\n    return 1/x\n\n# Generate x values\nx_vals = np.linspace(-10*np.pi, 10*np.pi, 400)\ny_vals = sinc(x_vals)\n\n# Plot the sinc function\nplt.figure(figsize=(8, 6))\nplt.plot(x_vals, y_vals, label=r'$f(x) = \\frac{\\sin(x)}{x}$')\nplt.plot(x_vals, inverse_x(x_vals), label=r'$f(x) = \\frac{1}{x}$')\nplt.xticks(np.arange(-10*np.pi, 11*np.pi, np.pi), \n           [r'$-10\\pi$', r'$-9\\pi$', r'$-8\\pi$', r'$-7\\pi$', r'$-6\\pi$', r'$-5\\pi$', r'$-4\\pi$', r'$-3\\pi$', r'$-2\\pi$', r'$-\\pi$', '0', r'$\\pi$', r'$2\\pi$', r'$3\\pi$', r'$4\\pi$', r'$5\\pi$', r'$6\\pi$', r'$7\\pi$', r'$8\\pi$', r'$9\\pi$', r'$10\\pi$'])\nplt.axhline(0, color='black',linewidth=0.5)\nplt.axvline(0, color='black',linewidth=0.5)\nplt.title(r'Plot of $f(x) = \\frac{\\sin(x)}{x}$')\nplt.xlabel('x')\nplt.ylabel('f(x)')\nplt.ylim(-1.1, 1.1)\nplt.legend()\nplt.grid(True)\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 3\n\n\n\n ▶  \\(x = 0\\)における連続性の証明\n\n\n\n\n\n\n\nProof\n\n\n\n\n\n偶関数の性質\n\\[\n\\frac{\\sin x}{x} = \\frac{\\sin -x}{-x}\n\\]\nより \\(0 &lt; x \\to +0\\) の場合を考えます．xy座標上に \\(O = (0, 0)，A = (1, 0)，B = (\\cos x, \\sin x)，C = (1, \\tan x)\\) という点をとったとき，\n\\[\n\\text{三角形}OAB \\subset \\text{扇形}OAB \\subset \\text{三角形}OAC\n\\]\nつまり\n\\[\n\\text{三角形}OAB\\text{の面積} \\leq \\text{扇形}OAB\\text{の面積} \\leq  \\text{三角形}OAC\n\\]\n従って，\n\\[\n\\begin{align}\n\\frac{\\sin x}{2} \\leq \\frac{x}{2} &lt; \\frac{\\tan x}{2}\n\\end{align}\n\\]\n両辺 を \\(\\sin ⁡x\\) で割って逆数をとると\n\\[\n\\begin{align}\n\\cos x \\leq \\frac{x\\sin x}{x} &lt; 1\n\\end{align}\n\\]\nここで，\\(x\\to +0\\) とすると，\\(\\cos x \\to 1\\) となり，はさみうちの原理より\n\\[\n\\lim_{x\\to+0}\\frac{\\sin x}{x} = 1\n\\]\n\n\n\n ▶  \\(x = 0\\)における微分可能性の証明\n\n\n\n\n\n\n\nProof\n\n\n\n\n\n\\[\n\\begin{align}\n\\cos x \\leq \\frac{x\\sin x}{x} &lt; 1\n\\end{align}\n\\]\nが \\(-\\frac{\\pi}{2} \\leq x \\leq \\frac{\\pi}{2}\\) で成り立つので\n\\[\n0=\\lim_{x\\to0}\\frac{\\cos(x)-1}{x}\\le\\lim_{x\\to0}\\frac{\\frac{\\sin(x)}x-1}{x-0}\\le0\n\\]\n\\[\n\\begin{align}\n\\lim_{x\\to0}\\frac{1-\\cos(x)}x\n&=\\lim_{x\\to0}\\frac1x\\frac{\\sin^2(x)}{1+\\cos(x)}\\\\\n&=\\lim_{x\\to0}\\frac{\\sin(x)}x\\lim_{x\\to0}\\frac{\\sin(x)}{1+\\cos(x)}\\\\[6pt]\n&=1\\cdot0 = 0\n\\end{align}\n\\]\n従って，はさみうちの原理より \\(f^\\prime(0) = 0\\)"
  },
  {
    "objectID": "posts/2025-02-03-continuous-function/index.html#連続関数",
    "href": "posts/2025-02-03-continuous-function/index.html#連続関数",
    "title": "関数の連続性",
    "section": "",
    "text": "変数 \\(x\\) が限りなく \\(a\\) に近づくとき，\\(f(x)\\) も \\(f(a)\\) に近づくならば，\\(f(x)\\) は \\(x=a\\) において連続である，といいます．つまり，\n\\[\nx\\to a \\text{ ならば } f(x) \\to f(a)\n\\]\n\nDef: \\(\\epsilon\\)-\\(\\delta\\) 論法的連続性 \n任意の \\(\\epsilon &gt;0\\) に対して，ある \\(\\delta &gt; 0\\) が存在して，\n\\[\n\\vert x - a \\vert &lt; \\delta \\Rightarrow \\vert f(x) - f(a)\\vert &lt; \\epsilon\n\\]\nを満たすとき，\\(x=a\\) において \\(f(x)\\) は連続であるという．\n\n\nExample 1 \n\\(f(x) = \\sqrt{x}\\) について，\\(a &gt; 0\\) で連続であることを以下示します．\n\\[\n\\begin{align}\n\\vert \\sqrt{x} - \\sqrt{a} \\vert\n    &= \\left\\vert\\frac{(\\sqrt{x} - \\sqrt{a})(\\sqrt{x} + \\sqrt{a})}{\\sqrt{x}+\\sqrt{a}}\\right\\vert\\\\\n    &= \\left\\vert\\frac{x - a}{\\sqrt{x}+\\sqrt{a}}\\right\\vert\\\\\n    &\\leq \\left\\vert\\frac{x - a}{\\sqrt{a}}\\right\\vert\n\\end{align}\n\\]\nここで，\\(\\vert x - a\\vert &lt; \\delta(\\epsilon) = \\epsilon\\sqrt{a}\\) と定めると\n\\[\n\\vert x - a\\vert &lt; \\delta(\\epsilon) \\Rightarrow \\vert \\sqrt{x} - \\sqrt{a}\\vert &lt; \\epsilon\n\\]\n\n\n\nExample 2 : 三角関数の連続性 \n\\(x = a + h\\) とおくと，和積の公式を用いて\n\\[\n\\begin{align}\n\\vert \\sin(x) - \\sin(a) \\vert\n    &= 2\\left\\vert \\cos\\frac{x+a}{2}\\sin\\frac{x-a}{2} \\right\\vert\\\\\n    &= 2\\left\\vert \\cos\\left(a + \\frac{h}{2}\\right)\\sin\\frac{h}{2} \\right\\vert\\\\\n    &\\leq 2\\left\\vert\\frac{h}{2}\\right\\vert \\cdot 1\\\\\n    &=\\vert h \\vert\n\\end{align}\n\\]\n\\(\\cos x = \\sin\\left(x + \\frac{\\pi}{2}\\right)\\) であるので，\\(\\sin x\\) が連続であるならば, \\(\\cos x\\) も連続．\n\n\n\n\nTheorem 1  : 連続関数の定数倍\n\\(f(x)\\) は \\(x=a\\) で連続であるとします．このとき，定数 \\(c\\) を用いた \\(cf(x)\\) も \\(x=a\\) にて連続となります．\n\n\n\n\n\n\n\n\n\nProof\n\n\n\n\n\n仮定より\n\\[\n\\forall \\eta &gt; 0, \\exists \\delta(\\eta) &gt; 0, \\vert x - a\\vert &lt; \\delta(\\eta)\\Rightarrow\\vert f(x) - f(a)\\vert &lt; \\eta\n\\]\nこのとき，任意の \\(\\epsilon &gt; 0\\) に対して，\n\\[\n\\eta = \\frac{\\epsilon}{\\vert c \\vert} &gt;0\n\\]\nと対応させると，\n\\[\n\\forall \\epsilon &gt; 0, \\exists \\delta(\\epsilon) &gt; 0, \\vert x - a\\vert &lt; \\delta(\\epsilon)\\Rightarrow\\vert f(x) - f(a)\\vert &lt; \\frac{\\epsilon}{\\vert c \\vert }\n\\]\nつまり，\n\\[\n\\forall \\epsilon &gt; 0, \\exists \\delta(\\epsilon) &gt; 0, \\vert x - a\\vert &lt; \\delta(\\epsilon)\\Rightarrow \\vert c\\vert\\vert f(x) - f(a)\\vert &lt; \\epsilon\n\\]\nこれを変形すると\n\\[\n\\forall \\epsilon &gt; 0, \\exists \\delta(\\epsilon) &gt; 0, \\vert x - a\\vert &lt; \\delta(\\epsilon)\\Rightarrow \\vert cf(x) - cf(a)\\vert &lt; \\epsilon\n\\]\n\n\n\n\n\nTheorem 2 : 連続関数の和\n\n\\(f(x), g(x)\\) は \\(x=a\\) で連続であるとします．このとき，\\(f(x) + g(x)\\) も \\(x=a\\) にて連続となります．\n\n\n\n\n\n\n\n\n\nProof\n\n\n\n\n\n仮定より\n\\[\n\\begin{align}\n\\vert x - a \\vert &lt; \\delta&\\Rightarrow \\vert f(x) - f(a)\\vert &lt; \\epsilon/2\\\\\n\\vert x - a \\vert &lt; \\eta&\\Rightarrow \\vert g(x) - g(a)\\vert &lt; \\epsilon/2\n\\end{align}\n\\]\nここで，\\(M = \\min(\\delta, \\eta)\\) とすると，\n\\[\n\\begin{align}\n\\vert x - a \\vert &lt; M&\\Rightarrow \\vert f(x) - f(a)\\vert &lt; \\epsilon/2\\\\\n\\vert x - a \\vert &lt; M&\\Rightarrow \\vert g(x) - g(a)\\vert &lt; \\epsilon/2\n\\end{align}\n\\]\nまた\n\\[\n\\begin{align}\n\\vert(f(x) - g(x)) - (f(a) + g(a))\n    &= \\vert(f(x) - f(a)) + (g(x) + g(a))\\vert\\\\\n    &\\leq \\vert(f(x) - f(a))\\vert + \\vert (g(x) + g(a))\\vert\n\\end{align}\n\\]\n従って，\\(\\vert x - a \\vert &lt; M\\) であるならば\n\\[\n\\begin{align}\n\\vert (g(x) + f(x)) - (g(a) + f(a))\\vert \\leq \\vert(f(x) - f(a))\\vert + \\vert (g(x) + g(a))\\vert &lt; \\epsilon\n\\end{align}\n\\]\n\n\n\n\n\nTheorem 3  : 連続関数の線型結合\n\\(f(x), g(x)\\) は \\(x=a\\) で連続であるとします．このとき，定数 \\(c_1, c_2\\)に対して \\(c_1f(x) + c_2g(x)\\) も \\(x=a\\) にて連続となります．\n\n\n\n\n\n\n\n\n\nProof\n\n\n\n\n\n\\[\n\\begin{align}\n\\vert x - a \\vert &lt; \\delta&\\Rightarrow \\vert f(x) - f(a)\\vert &lt; \\frac{\\epsilon}{2\\vert c_1\\vert}\\\\\n\\vert x - a \\vert &lt; \\eta&\\Rightarrow \\vert g(x) - g(a)\\vert &lt; \\frac{\\epsilon}{2\\vert c_2\\vert}\n\\end{align}\n\\]\nとして，\\(M = \\min(\\delta, \\eta)\\) とすれば，上記と同様に連続性を示すことができます．\n\n\n\n\n\nTheorem 4  : 連続関数の積\n\\(f(x), g(x)\\) は \\(x=a\\) で連続であるとします．このとき，\\(f(x)g(x)\\) も \\(x=a\\) にて連続となります．\n\n\n\n\n\n\n\n\n\nProof\n\n\n\n\n\n\\[\n\\vert x - a \\vert &lt; \\delta(1) \\Rightarrow \\vert f(x) - f(a)\\vert &lt; 1\n\\]\nとすると，\n\\[\n\\vert x - a \\vert &lt; \\delta(1) \\Rightarrow \\vert f(x) \\vert &lt; 1 + \\vert f(a) \\vert\n\\]\n\\(\\delta, \\eta\\) を以下のように定め，\n\\[\n\\begin{align}\n\\vert x - a \\vert &lt; \\delta &\\Rightarrow \\vert f(x) - f(a)\\vert &lt; \\frac{\\epsilon}{2(1 + \\vert f(a) \\vert + \\vert g(a) \\vert)}\\\\\n\\vert x - a \\vert &lt; \\eta &\\Rightarrow \\vert g(x) - g(a)\\vert &lt; \\frac{\\epsilon}{2(1 + \\vert f(a) \\vert + \\vert g(a) \\vert)}\n\\end{align}\n\\]\n\\[\n\\delta(\\epsilon) = \\min (\\delta(1), \\delta, \\eta)\n\\]\nとすると，\n\\[\n\\begin{align}\n\\vert x - a \\vert &lt; \\delta(\\epsilon)\n    \\Rightarrow &\\vert f(x)g(x) - f(a)g(a)\\vert\\\\[5pt]\n    &= \\vert f(x)(g(x) - g(a)) + g(a)(f(x) - f(a))\\vert\\\\[5pt]\n    &\\leq \\vert f(x)\\vert \\vert(g(x) - g(a))\\vert + \\vert g(a)\\vert\\vert(f(x) - f(a))\\vert\\\\[5pt]\n    &&lt; (1 + \\vert f(a) \\vert)\\frac{\\epsilon}{2(1 + \\vert f(a) \\vert + \\vert g(a) \\vert)} + \\vert g(a)\\vert \\frac{\\epsilon}{2(1 + \\vert f(a) \\vert + \\vert g(a) \\vert)}\\\\\n    &= \\epsilon\n\\end{align}\n\\]\nよって，連続性が示された．\n\n\n\n\n\nTheorem 5  連続関数の逆数 \n\\(f(x)\\) は \\(x=a\\) で連続であるとします．このとき，\\(f(a)\\neq 0\\) であるならば \\(1/f(x)\\) も \\(x=a\\) にて連続となります．\n\n\n\n\n\n\n\n\n\nProof\n\n\n\n\n\n連続性の仮定より\n\\[\n\\vert x - a \\vert &lt; \\delta(\\vert f(a)/2\\vert) \\Rightarrow \\vert f(x) - f(a)\\vert &lt; \\frac{\\vert f(a)\\vert}{2}\n\\]\nとすると，\n\\[\n\\vert x - a \\vert &lt; \\delta(\\vert f(a)/2\\vert) \\Rightarrow \\frac{\\vert f(a)\\vert}{2} &lt; \\vert f(x)\\vert\n\\]\nこのとき，\n\\[\n\\begin{align}\n\\left\\vert \\frac{1}{f(x)} - \\frac{1}{f(a)} \\right\\vert\n    &= \\left\\vert \\frac{f(x) - f(a)}{f(x)f(a)} \\right\\vert\\\\\n    &&lt; \\left\\vert \\frac{f(x) - f(a)}{(f(a))^2 / 2} \\right\\vert\n\\end{align}\n\\]\n従って，\\(\\vert x - a \\vert &lt; \\eta \\Rightarrow \\vert f(x) - f(a)\\vert &lt; \\displaystyle\\frac{\\epsilon\\vert (f(a))^2\\vert}{2}\\) となるような \\(\\eta\\) を用いて，\n\\[\n\\delta(\\epsilon) = \\min(\\delta(\\vert f(a)/2\\vert), \\eta)\n\\]\nとすれば\n\\[\n\\vert x - a \\vert &lt; \\delta(\\epsilon) \\Rightarrow \\left\\vert \\frac{1}{f(x)} - \\frac{1}{f(a)} \\right\\vert &lt; \\epsilon\n\\]\n\n\n\n\n\n点 \\(a\\) における極限を考えるとき，\n\n\\(x\\) が増大しつつ \\(a\\) に（左側から）近づく, \\(\\lim_{x\\to a-0}\\)\n\\(x\\) が減少しつつ \\(a\\) に（右側から）近づく, \\(\\lim_{x\\to a+0}\\)\n\nそれぞれの場合を分けて取り扱うことがあります．\n\nExample 3 \n\\(f(x) = \\tan x\\) について，\\(x = \\pi/2\\) における極限を考えてみます．\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport sympy as sy\n\nx = sy.Symbol('x')\nf = sy.tan(x)\n\nx_vals = np.linspace(-np.pi/2+1e-6, np.pi, 400)\ny_vals = np.tan(x_vals)\n\nplt.figure(figsize=(8, 6))\nplt.plot(x_vals, y_vals, label=r'$f(x) = \\tan(x)$')\nplt.ylim(-10, 10)\nplt.xticks([-np.pi/2, 0, np.pi/2, np.pi], [r'$-\\frac{\\pi}{2}$', '0', r'$\\frac{\\pi}{2}$', r'$\\pi$'])\nplt.axvline(np.pi/2, color='r', linestyle='--', label=r'$x = \\frac{\\pi}{2}$')\nplt.axhline(0, color='black',linewidth=0.5)\nplt.axvline(0, color='black',linewidth=0.5)\nplt.title(r'Plot of $f(x) = \\tan(x)$ around $x = \\frac{\\pi}{2}$')\nplt.xlabel('x')\nplt.ylabel('f(x)')\nplt.legend()\nplt.grid(True)\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 1\n\n\n\n上記の図のように，\n\\[\n\\begin{align}\n\\lim_{x\\to \\pi/2+0} \\tan x &= -\\infty\\\\\n\\lim_{x\\to \\pi/2-0} \\tan x &= \\infty\n\\end{align}\n\\]\n実際に，sympy で確認してみると\n\n# DO NOT USE np.pi\nprint(f\"左極限: {sy.limit(sy.tan(x), x, sy.pi/2, '-')}\")\nprint(f\"右極限: {sy.limit(sy.tan(x), x, sy.pi/2, '+')}\")\n\n左極限: oo\n右極限: -oo\n\n\n\n\n ▶  右連続と左連続\n\\[\n\\begin{align}\nf(a) &= \\alpha\\\\[5pt]\n\\lim_{x\\to a-0} f(x) &= \\alpha\\\\\n\\lim_{x\\to a+0} f(x) &= \\beta \\neq \\alpha\n\\end{align}\n\\]\nのとき，\\(f(x)\\) は \\(x = a\\) において左連続といいます．\n\\(f(x)\\) が閉区間 \\([a, b]\\) において定義されているとき，\n\n\\(x=a\\) においては右連続\n\\(x=b\\) においては左連続\n\nであることを意味します．開区間 \\((a, b)\\) において定義されているとき，\\(f(a+0)\\) が確定ならば，それを \\(f(a)\\) として定義域を \\([a, b)\\) 区間に拡張すると \\(f(x)\\) は \\(x=a\\) において右連続になります．\n一方，\\((0, \\infty)\\) 区間で定義された関数 \\(\\displaystyle f(x) = \\frac{1}{x}\\) は開区間では連続ですが，\\(x = 0\\) のときは定義されません．このとき，\\(f(0) = 0\\) として定義域を \\([0, \\infty)\\) に拡張すると，\\(x=0\\) で連続な関数にはなりませんし，\\(f(0)\\) をどんな値にしたとしても，\\(x=0\\) の近傍において, \\(f(x)\\) はいくらでも大きくなってしまうので，連続な関数にはなりません．\n\n📘 REMARKS \n\n開区間 \\((a, b)\\) で定義された連続な関数が，開区間 \\([a, b]\\) の連続な関数に拡張できるとは限らない\n\n\n\nExample 4  : 右連続関数と累積分布関数 \n離散確率変数 \\(X\\sim\\operatorname{Bin}(5, 1/3)\\) を考えます．離散確率変数の累積分布関数 \\(F(x)\\) は\n\\[\nF(x) = \\operatorname{P}(X \\leq x) = \\sum_{y\\leq x}p(y) \\qquad p(y): \\text{確率関数}\n\\]\nと定義されるので，\\(F(x)\\) は右側連続となります．実際に\n\nCode\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom scipy.stats import binom\n\nn, p = 5, 1 / 3\nx = np.arange(0, 6)\ncdf = binom.cdf(x, n, p)\n\nfig, ax = plt.subplots(1, 1)\nax.hlines(cdf, x, x + 1, color=\"gray\")\nax.step(x, cdf, where=\"post\", color=\"gray\", linestyle=\"dotted\")\nax.plot(x, cdf, \"o\", color=\"gray\")\nax.scatter(x[:-1] + 1, cdf[:-1], marker=\"$\\u25EF$\", alpha=0.5, color=\"gray\")\nax.set_xlabel(\"x\")\nax.set_ylabel(\"F(x)\")\nax.set_title(\"CDF of Binomial Distribution (n=5, p=1/3)\")\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 2\n\n\n\nこのとき，確率関数は\n\\[\np(x) = F(x) - \\lim_{x_n\\to x-0}F(x_n)\n\\]\nとすることで計算することが出来ます．一方，\\(F(x) = \\operatorname{P}(X &lt; x)\\) と定義すると左連続となります．\n\n\n\n\n\n\\[\nf(x) = \\frac{\\sin x}{x}\n\\]\nを考えます．この関数は \\(x - 0\\) で定義されていないですが\n\\[\n\\begin{align}\nf(x) = \\left\\{\\begin{array}{c}\n\\frac{\\sin x}{x} & (x\\neq 0)\\\\\n1 & (x = 0)\n\\end{array}\\right.\n\\end{align}\n\\]\nと \\(x = 0\\) で連続かつ微分可能になるように拡張することが出来ます．この拡張された関数を特にsinc関数と呼びます．\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Define the sinc function\ndef sinc(x):\n    return np.sinc(x / np.pi)\n\ndef inverse_x(x):\n    return 1/x\n\n# Generate x values\nx_vals = np.linspace(-10*np.pi, 10*np.pi, 400)\ny_vals = sinc(x_vals)\n\n# Plot the sinc function\nplt.figure(figsize=(8, 6))\nplt.plot(x_vals, y_vals, label=r'$f(x) = \\frac{\\sin(x)}{x}$')\nplt.plot(x_vals, inverse_x(x_vals), label=r'$f(x) = \\frac{1}{x}$')\nplt.xticks(np.arange(-10*np.pi, 11*np.pi, np.pi), \n           [r'$-10\\pi$', r'$-9\\pi$', r'$-8\\pi$', r'$-7\\pi$', r'$-6\\pi$', r'$-5\\pi$', r'$-4\\pi$', r'$-3\\pi$', r'$-2\\pi$', r'$-\\pi$', '0', r'$\\pi$', r'$2\\pi$', r'$3\\pi$', r'$4\\pi$', r'$5\\pi$', r'$6\\pi$', r'$7\\pi$', r'$8\\pi$', r'$9\\pi$', r'$10\\pi$'])\nplt.axhline(0, color='black',linewidth=0.5)\nplt.axvline(0, color='black',linewidth=0.5)\nplt.title(r'Plot of $f(x) = \\frac{\\sin(x)}{x}$')\nplt.xlabel('x')\nplt.ylabel('f(x)')\nplt.ylim(-1.1, 1.1)\nplt.legend()\nplt.grid(True)\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 3\n\n\n\n ▶  \\(x = 0\\)における連続性の証明\n\n\n\n\n\n\n\nProof\n\n\n\n\n\n偶関数の性質\n\\[\n\\frac{\\sin x}{x} = \\frac{\\sin -x}{-x}\n\\]\nより \\(0 &lt; x \\to +0\\) の場合を考えます．xy座標上に \\(O = (0, 0)，A = (1, 0)，B = (\\cos x, \\sin x)，C = (1, \\tan x)\\) という点をとったとき，\n\\[\n\\text{三角形}OAB \\subset \\text{扇形}OAB \\subset \\text{三角形}OAC\n\\]\nつまり\n\\[\n\\text{三角形}OAB\\text{の面積} \\leq \\text{扇形}OAB\\text{の面積} \\leq  \\text{三角形}OAC\n\\]\n従って，\n\\[\n\\begin{align}\n\\frac{\\sin x}{2} \\leq \\frac{x}{2} &lt; \\frac{\\tan x}{2}\n\\end{align}\n\\]\n両辺 を \\(\\sin ⁡x\\) で割って逆数をとると\n\\[\n\\begin{align}\n\\cos x \\leq \\frac{x\\sin x}{x} &lt; 1\n\\end{align}\n\\]\nここで，\\(x\\to +0\\) とすると，\\(\\cos x \\to 1\\) となり，はさみうちの原理より\n\\[\n\\lim_{x\\to+0}\\frac{\\sin x}{x} = 1\n\\]\n\n\n\n ▶  \\(x = 0\\)における微分可能性の証明\n\n\n\n\n\n\n\nProof\n\n\n\n\n\n\\[\n\\begin{align}\n\\cos x \\leq \\frac{x\\sin x}{x} &lt; 1\n\\end{align}\n\\]\nが \\(-\\frac{\\pi}{2} \\leq x \\leq \\frac{\\pi}{2}\\) で成り立つので\n\\[\n0=\\lim_{x\\to0}\\frac{\\cos(x)-1}{x}\\le\\lim_{x\\to0}\\frac{\\frac{\\sin(x)}x-1}{x-0}\\le0\n\\]\n\\[\n\\begin{align}\n\\lim_{x\\to0}\\frac{1-\\cos(x)}x\n&=\\lim_{x\\to0}\\frac1x\\frac{\\sin^2(x)}{1+\\cos(x)}\\\\\n&=\\lim_{x\\to0}\\frac{\\sin(x)}x\\lim_{x\\to0}\\frac{\\sin(x)}{1+\\cos(x)}\\\\[6pt]\n&=1\\cdot0 = 0\n\\end{align}\n\\]\n従って，はさみうちの原理より \\(f^\\prime(0) = 0\\)"
  },
  {
    "objectID": "posts/2024-12-19-shortcuts/index.html",
    "href": "posts/2024-12-19-shortcuts/index.html",
    "title": "自分用VSCodeショートカットシート",
    "section": "",
    "text": "General\n\n\n\n\n\n\n\n\n\n\n\n\n\ncommand\n動作\ncomment\n\n\n\n\nF11\nフルスクリーンモード(toggle)\n\n\n\nctrl + B\nサイドバー(EXPLOER)のToggle\n\n\n\nCtrl + K Z\n禅モード\n集中作業や投影のときに使用, toggle\n\n\nCtrl + super + R\nVSCodeのReload\nフリーズしたときなどに有効\n\n\nCtrl + super + Q\nVSCodeの終了\n\n\n\nCtrl + Shift + T\n直前閉じたtabを再び開く\n\n\n\nCtrl + W\n現在フォーカスしているEditor上のファイルを閉じる\n\n\n\nCtrl + Super + W\nEditorで開かれているファイルをすべて閉じる\nデフォルトはCtrl + K Ctrl + W\n\n\nCtrl + +/-/0\nEditor画面のzoom in/out/reset\n\n\n\nCtrl + =\nEditor fontのサイズ拡大\n\n\n\nCtrl + -\nEditor fontのサイズ縮小\n\n\n\nCtrl + 0\nEditor fontのサイズリセット\n\n\n\nCtrl + Shift +=\nVSCode Window zoom 拡大\n\n\n\nCtrl + Shift +-\nVSCode Window zoom 縮小\n\n\n\nCtrl + Shift +0\nVSCode Window zoom リセット\n\n\n\n\n\n\n\n\n\n\n\n\n\nEditing\n\n\n\n\n\n\n\n\n\n\n\n\n\ncommand\n動作\ncomment\n\n\n\n\nAlt + ↑/↓\nラインの入れ替え\nlogic変更に伴う行の順番入れ替えに便利\n\n\nCtrl + ]\nインデントの追加\n\n\n\nCtrl + [\nインデントの削除\n\n\n\nCtrl + /\nラインのコメントアウト(Toggle)\n言語に合わせてサーソル行のコメントアウト切り替えができる\n\n\nCtrl + Shift + A\nブロックコメントアウト(Toggle)\n\n\n\nCtrl + D\n検索・置換用の文字ブロックが選択される\nCtrl+H or Ctrl+F と組み合わせて使うと便利\n\n\nCtrl + H\n置換モード\n正規表現モード Alt + R, 置換範囲を選択行に限定 Alt + L, 一括変換 Ctrl + Alt + Enter と組み合わせると便利．２階連続押すと Replace にフォーカスされる．キャンセルは Esc\n\n\nCtrl + L\n現在の行全体を選択\nCtrl +Shift + Lと組み合わせると便利\n\n\nCtrl + W\n開いているファイルを閉じる\n\n\n\nCtrl + super + I\nサジェスト機能\n\n\n\nCtrl + U\n選択範囲の大文字変換\n\n\n\nCtrl + super + U\n選択範囲の小文字変換\n\n\n\nCtrl + Shift + ↑\n現在位置からライン先頭までの選択(selection)\n\n\n\nCtrl + Shift + ↓\n現在位置からライン末尾までの選択(selection)\n\n\n\nCtrl + Shift + ←\n現在位置から現在位置のword block先頭までの選択(selection)\n\n\n\nCtrl + Shift + →\n現在位置から現在位置のword block末尾までの選択(selection)\n\n\n\nF12\n定義参照\n\n\n\nsuper + F12\n定義をサイドに表示\n定義を見ながら修正するときに便利\n\n\n\n\n\n\n\n\n\n\n\n\nEditing + formatting\n\n\n\n\n\n\n\n\n\n\n\n\n\ncommand\n動作\ncomment\n\n\n\n\nCtrl + Shift + I\nコード全体をformatting\neditorTextFocus && !editorHasDocumentFormattingProvider && !editorReadonly && !editor.hasSelection\n\n\nCtrl + Shift + I\n選択したコードをformatting\neditorHasDocumentSelectionFormattingProvider && editorTextFocus && !editorReadonly && editor.hasSelection\n\n\n\n\n\n\n\n\n\n\n\n\nBracket Editing\n\n\n\n\n\n\n\n\n\n\n\n\n\ncommand\n動作\ncomment\n\n\n\n\nCtrl + Alt + \\\nブラケットへの移動\nデフォルトではCtrl + Shift + \\\n\n\nCtrl + Alt + backspace\nブラケットの削除\n\n\n\n\n\n\n\n\n\n\n\n\n\nEditing + delete\n\n\n\n\n\n\n\n\n\n\n\n\n\ncommand\n動作\ncomment\n\n\n\n\nCtrl + Shift + K\nカーソル行の削除\n\n\n\nCtrl + backspace\nカーソルより左側の１単語削除\n\n\n\nCtrl + delete\nカーソルより右側の１単語削除\n\n\n\nCtrl + Super + backspace\nカーソルより左側のすべての単語削除\n\n\n\nCtrl + Super + delete\nカーソルより右側のすべての単語削除\n\n\n\n\n\n\n\n\n\n\n\n\n\nEditing + Multicursor\n\n\n\n\n\n\n\n\n\n\n\n\n\ncommand\n動作\ncomment\n\n\n\n\nCtrl +Shift + L\n選択箇所にマッチする箇所全てにカーソルを展開\nキャンセルしたい場合はEsc\n\n\nAlt +Shift + ↑/↓\nマルチカーソルを上下に展開\nキャンセルしたい場合はEsc\n\n\n\n\n\n\n\n\n\n\n\n\nEditing + 移動\n\n\n\n\n\n\n\n\n\n\n\n\n\ncommand\n動作\ncomment\n\n\n\n\nHome\n文頭まで移動\n\n\n\nEnd\n文末まで移動\n\n\n\nCtrl + Home\nファイル先頭まで移動\n\n\n\nCtrl + End\nファイル文末まで移動\n\n\n\nCtrl + G\n指定した行まで移動\n同僚から「xxx行目見て」って言われたときに便利\n\n\nCtrl + U\n直前までいたカーソル位置に戻る\nF12(定義参照)と組み合わせると便利\n\n\nCtrl + Shift + \\\n次の対応する括弧に移動\narrayやMathJax編集中に便利\n\n\nCtrl + Shift + pageup\n編集tab左移動\n\n\n\nCtrl + Shift + pagedown\n編集tab右移動\n\n\n\nCtrl + tab\n編集tabの選択移動． Ctrl + tab を押し続けて移動先を選択する\n\n\n\nCtrl + super + →\nActive Editorを右に移動する\n\n\n\nCtrl + super + ←\nActive Editorを左に移動する\n\n\n\n\n\n\n\n\n\n\n\n\n\n表示\n\n\n\n\n\n\n\n\n\n\n\n\n\ncommand\n動作\ncomment\n\n\n\n\nAlt + Z\noverflow textのwrap Toggle\n\n\n\nCtrl + Shift + ]\nブロックの展開\n\n\n\nCtrl + Shift + [\nブロックの折りたたみ\n\n\n\nCtrl + K Ctrl + 0\nすべて折りたたむ\n\n\n\nCtrl + K Ctrl + J\n折りたたみをすべて展開する\n\n\n\nCtrl + K Ctrl + 1~7\n指定したレベルに合わせて折りたたむ\n1が折りたたみレベル最上位\n\n\n\n\n\n\n\n\n\n\n\n\nGitHub Copilot\n\n\n\n\n\n\n\n\n\n\n\n\n\ncommand\n動作\ncomment\n\n\n\n\nCtrl + i\nインラインGitHub Copilotの起動\nキャンセルはEsc\n\n\nCtrl + Alt + i\nGitHub Copilotの起動(Toggle)\n\n\n\nCtrl +Esc\nCopilotプロセスのキャンセル\n\n\n\n\n\n\n\n\n\n\n\n\n\nCSV\n\n\n\n\n\n ▶  条件\n\nEdit CSVがinstall済み\n\n\n\n\n\n\n\n\n\ncommand\n動作\ncomment\n\n\n\n\nCtrl + Enter\n現在開かれているcsvファイルをtable ui形式で表示\nデータサイズが重たいものについては使用注意"
  },
  {
    "objectID": "posts/2024-12-19-shortcuts/index.html#vscode-shortcut-sheet",
    "href": "posts/2024-12-19-shortcuts/index.html#vscode-shortcut-sheet",
    "title": "自分用VSCodeショートカットシート",
    "section": "",
    "text": "General\n\n\n\n\n\n\n\n\n\n\n\n\n\ncommand\n動作\ncomment\n\n\n\n\nF11\nフルスクリーンモード(toggle)\n\n\n\nctrl + B\nサイドバー(EXPLOER)のToggle\n\n\n\nCtrl + K Z\n禅モード\n集中作業や投影のときに使用, toggle\n\n\nCtrl + super + R\nVSCodeのReload\nフリーズしたときなどに有効\n\n\nCtrl + super + Q\nVSCodeの終了\n\n\n\nCtrl + Shift + T\n直前閉じたtabを再び開く\n\n\n\nCtrl + W\n現在フォーカスしているEditor上のファイルを閉じる\n\n\n\nCtrl + Super + W\nEditorで開かれているファイルをすべて閉じる\nデフォルトはCtrl + K Ctrl + W\n\n\nCtrl + +/-/0\nEditor画面のzoom in/out/reset\n\n\n\nCtrl + =\nEditor fontのサイズ拡大\n\n\n\nCtrl + -\nEditor fontのサイズ縮小\n\n\n\nCtrl + 0\nEditor fontのサイズリセット\n\n\n\nCtrl + Shift +=\nVSCode Window zoom 拡大\n\n\n\nCtrl + Shift +-\nVSCode Window zoom 縮小\n\n\n\nCtrl + Shift +0\nVSCode Window zoom リセット\n\n\n\n\n\n\n\n\n\n\n\n\n\nEditing\n\n\n\n\n\n\n\n\n\n\n\n\n\ncommand\n動作\ncomment\n\n\n\n\nAlt + ↑/↓\nラインの入れ替え\nlogic変更に伴う行の順番入れ替えに便利\n\n\nCtrl + ]\nインデントの追加\n\n\n\nCtrl + [\nインデントの削除\n\n\n\nCtrl + /\nラインのコメントアウト(Toggle)\n言語に合わせてサーソル行のコメントアウト切り替えができる\n\n\nCtrl + Shift + A\nブロックコメントアウト(Toggle)\n\n\n\nCtrl + D\n検索・置換用の文字ブロックが選択される\nCtrl+H or Ctrl+F と組み合わせて使うと便利\n\n\nCtrl + H\n置換モード\n正規表現モード Alt + R, 置換範囲を選択行に限定 Alt + L, 一括変換 Ctrl + Alt + Enter と組み合わせると便利．２階連続押すと Replace にフォーカスされる．キャンセルは Esc\n\n\nCtrl + L\n現在の行全体を選択\nCtrl +Shift + Lと組み合わせると便利\n\n\nCtrl + W\n開いているファイルを閉じる\n\n\n\nCtrl + super + I\nサジェスト機能\n\n\n\nCtrl + U\n選択範囲の大文字変換\n\n\n\nCtrl + super + U\n選択範囲の小文字変換\n\n\n\nCtrl + Shift + ↑\n現在位置からライン先頭までの選択(selection)\n\n\n\nCtrl + Shift + ↓\n現在位置からライン末尾までの選択(selection)\n\n\n\nCtrl + Shift + ←\n現在位置から現在位置のword block先頭までの選択(selection)\n\n\n\nCtrl + Shift + →\n現在位置から現在位置のword block末尾までの選択(selection)\n\n\n\nF12\n定義参照\n\n\n\nsuper + F12\n定義をサイドに表示\n定義を見ながら修正するときに便利\n\n\n\n\n\n\n\n\n\n\n\n\nEditing + formatting\n\n\n\n\n\n\n\n\n\n\n\n\n\ncommand\n動作\ncomment\n\n\n\n\nCtrl + Shift + I\nコード全体をformatting\neditorTextFocus && !editorHasDocumentFormattingProvider && !editorReadonly && !editor.hasSelection\n\n\nCtrl + Shift + I\n選択したコードをformatting\neditorHasDocumentSelectionFormattingProvider && editorTextFocus && !editorReadonly && editor.hasSelection\n\n\n\n\n\n\n\n\n\n\n\n\nBracket Editing\n\n\n\n\n\n\n\n\n\n\n\n\n\ncommand\n動作\ncomment\n\n\n\n\nCtrl + Alt + \\\nブラケットへの移動\nデフォルトではCtrl + Shift + \\\n\n\nCtrl + Alt + backspace\nブラケットの削除\n\n\n\n\n\n\n\n\n\n\n\n\n\nEditing + delete\n\n\n\n\n\n\n\n\n\n\n\n\n\ncommand\n動作\ncomment\n\n\n\n\nCtrl + Shift + K\nカーソル行の削除\n\n\n\nCtrl + backspace\nカーソルより左側の１単語削除\n\n\n\nCtrl + delete\nカーソルより右側の１単語削除\n\n\n\nCtrl + Super + backspace\nカーソルより左側のすべての単語削除\n\n\n\nCtrl + Super + delete\nカーソルより右側のすべての単語削除\n\n\n\n\n\n\n\n\n\n\n\n\n\nEditing + Multicursor\n\n\n\n\n\n\n\n\n\n\n\n\n\ncommand\n動作\ncomment\n\n\n\n\nCtrl +Shift + L\n選択箇所にマッチする箇所全てにカーソルを展開\nキャンセルしたい場合はEsc\n\n\nAlt +Shift + ↑/↓\nマルチカーソルを上下に展開\nキャンセルしたい場合はEsc\n\n\n\n\n\n\n\n\n\n\n\n\nEditing + 移動\n\n\n\n\n\n\n\n\n\n\n\n\n\ncommand\n動作\ncomment\n\n\n\n\nHome\n文頭まで移動\n\n\n\nEnd\n文末まで移動\n\n\n\nCtrl + Home\nファイル先頭まで移動\n\n\n\nCtrl + End\nファイル文末まで移動\n\n\n\nCtrl + G\n指定した行まで移動\n同僚から「xxx行目見て」って言われたときに便利\n\n\nCtrl + U\n直前までいたカーソル位置に戻る\nF12(定義参照)と組み合わせると便利\n\n\nCtrl + Shift + \\\n次の対応する括弧に移動\narrayやMathJax編集中に便利\n\n\nCtrl + Shift + pageup\n編集tab左移動\n\n\n\nCtrl + Shift + pagedown\n編集tab右移動\n\n\n\nCtrl + tab\n編集tabの選択移動． Ctrl + tab を押し続けて移動先を選択する\n\n\n\nCtrl + super + →\nActive Editorを右に移動する\n\n\n\nCtrl + super + ←\nActive Editorを左に移動する\n\n\n\n\n\n\n\n\n\n\n\n\n\n表示\n\n\n\n\n\n\n\n\n\n\n\n\n\ncommand\n動作\ncomment\n\n\n\n\nAlt + Z\noverflow textのwrap Toggle\n\n\n\nCtrl + Shift + ]\nブロックの展開\n\n\n\nCtrl + Shift + [\nブロックの折りたたみ\n\n\n\nCtrl + K Ctrl + 0\nすべて折りたたむ\n\n\n\nCtrl + K Ctrl + J\n折りたたみをすべて展開する\n\n\n\nCtrl + K Ctrl + 1~7\n指定したレベルに合わせて折りたたむ\n1が折りたたみレベル最上位\n\n\n\n\n\n\n\n\n\n\n\n\nGitHub Copilot\n\n\n\n\n\n\n\n\n\n\n\n\n\ncommand\n動作\ncomment\n\n\n\n\nCtrl + i\nインラインGitHub Copilotの起動\nキャンセルはEsc\n\n\nCtrl + Alt + i\nGitHub Copilotの起動(Toggle)\n\n\n\nCtrl +Esc\nCopilotプロセスのキャンセル\n\n\n\n\n\n\n\n\n\n\n\n\n\nCSV\n\n\n\n\n\n ▶  条件\n\nEdit CSVがinstall済み\n\n\n\n\n\n\n\n\n\ncommand\n動作\ncomment\n\n\n\n\nCtrl + Enter\n現在開かれているcsvファイルをtable ui形式で表示\nデータサイズが重たいものについては使用注意"
  },
  {
    "objectID": "posts/2024-12-19-shortcuts/index.html#appendix-vscodeの画面構成",
    "href": "posts/2024-12-19-shortcuts/index.html#appendix-vscodeの画面構成",
    "title": "自分用VSCodeショートカットシート",
    "section": "Appendix: VSCodeの画面構成",
    "text": "Appendix: VSCodeの画面構成\n\n\n\nVSCode 画面構成例\n\n\n\n\n\n\n\n\n\n構成要素\n説明\n\n\n\n\nエディター\nファイル編集を行うエリア\n\n\nアクティビティバー\nサイドバーに表示する機能を切り替えるアイコン\n\n\nサイドバー\nファイルツリーやデバッグ時の変数などを表示するエリア\n\n\nパネル\n凛とエラーやコンソールログを表示するエリア\n\n\nステータスバー\nエディターで開いているファイルの情報などを端的に表示する"
  },
  {
    "objectID": "posts/2025-01-29-set-and-topology-series/index.html",
    "href": "posts/2025-01-29-set-and-topology-series/index.html",
    "title": "フーリエ級数と積分理論再考",
    "section": "",
    "text": "フーリエが熱伝導方程式の解をどのように求めたのか？\nどのような流れで積分の定義の再考につながったのか？\n\nを紹介します．"
  },
  {
    "objectID": "posts/2025-01-29-set-and-topology-series/index.html#このノートのスコープ",
    "href": "posts/2025-01-29-set-and-topology-series/index.html#このノートのスコープ",
    "title": "フーリエ級数と積分理論再考",
    "section": "",
    "text": "フーリエが熱伝導方程式の解をどのように求めたのか？\nどのような流れで積分の定義の再考につながったのか？\n\nを紹介します．"
  },
  {
    "objectID": "posts/2025-01-29-set-and-topology-series/index.html#熱伝導方程式",
    "href": "posts/2025-01-29-set-and-topology-series/index.html#熱伝導方程式",
    "title": "フーリエ級数と積分理論再考",
    "section": "熱伝導方程式",
    "text": "熱伝導方程式\n物体内に温度勾配が存在すると，高温部から低温部へ熱伝導（Heat conduction）により熱エネルギーが伝わります．\n\n\n\n\n\n\nFigure 1: 長さ\\(\\pi\\)の密度が一様な棒\n\n\n\nFigure 1 のような細長い密度が一定の棒が与えられたとします．\n\n左端を 0 として，ある点の位置を左端からの距離 \\(x\\) で表す\nある点 \\(x\\) における時刻 \\(t\\) での温度を \\(T(x, t)\\) で表す\n単位断面積を単位時間に通過する熱エネルギーを \\(q(x, t)\\) とする(=熱流密度)\n\nフーリエの法則より，熱流密度 \\(q(x, t)\\) は温度勾配 \\(\\displaystyle{\\frac{\\partial T(x, t)}{\\partial x}}\\) に比例するので\n\\[\nq(x, t) = -\\lambda \\frac{\\partial T(x, t)}{\\partial x} \\label{eq-fourier-law}\n\\]\n\n\\(\\lambda  &gt; 0\\): 熱伝導率，RHSに符号マイナスがついているのは，高温から低音へ熱が流れることを表してる\n熱伝導率: 物質によって定まる物性値, 熱伝導率が大きいと熱エネルギーがよく伝わり，熱伝導率が小さいと熱エネルギーを伝えにくい\n\n\\(\\eqref{eq-fourier-law}\\) で表される熱の流入から，比熱 \\(c &gt; 0\\), 密度 \\(\\rho  &gt; 0\\) を用いると温度変化 \\(\\Delta T(x, t)\\) は熱の流入と流出２要素から以下のように表されます\n\\[\n\\begin{align}\n\\Delta T(x, t) &= \\frac{1}{c\\rho\\Delta x}(q(x, t) - q(x + \\Delta x, t))\\Delta t\\\\\n\\Rightarrow \\frac{\\Delta T(x, t)}{\\Delta t} &= \\frac{1}{c\\rho\\Delta x}(q(x, t) - q(x + \\Delta x, t))\n\\end{align}\n\\]\nここで，\\(\\Delta t\\to 0, \\Delta x\\to 0\\) とすると\n\\[\n\\frac{\\partial T(x, t)}{\\partial t} = -\\frac{1}{c\\rho}\\frac{\\partial q(x, t)}{\\partial x} \\label{eq-heat-balance}\n\\]\n\\(\\eqref{eq-fourier-law}\\), \\(\\eqref{eq-heat-balance}\\) より\n\\[\n\\begin{align}\n\\frac{\\partial T(x, t)}{\\partial t}\n    &= -\\frac{1}{c\\rho}\\frac{\\partial}{\\partial x}\\left(-\\lambda \\frac{\\partial T(x, t)}{\\partial x} \\right)\\\\\n    &= \\frac{\\lambda}{c\\rho}\\frac{\\partial^2 T(x, t)}{\\partial x^2} \\label{eq-hce}\n\\end{align}\n\\tag{1}\\]\nこれを熱伝導方程式と呼びます．\\(\\displaystyle\\frac{\\lambda}{c\\rho}\\) は温度伝導率（温度拡散率）と呼ばれます．\n\n\n\n\n\n\n🍵 Green Tea Break: 比熱\n\n\n\n\n比熱とは 1kg の物質の温度を 1K （＝1℃）上げるのに必要な熱量のこと\n「温まりやすさ」 「冷めにくさ」 を表す物理量と理解できる\n\n例えば，水1kgの場合，1K 上げるのに必要な熱量は4186J"
  },
  {
    "objectID": "posts/2025-01-29-set-and-topology-series/index.html#熱伝導方程式とフーリエ級数",
    "href": "posts/2025-01-29-set-and-topology-series/index.html#熱伝導方程式とフーリエ級数",
    "title": "フーリエ級数と積分理論再考",
    "section": "熱伝導方程式とフーリエ級数",
    "text": "熱伝導方程式とフーリエ級数\n\n方程式: 熱伝導方程式\n境界条件: 棒の両端の温度を 0 に保つ\n初期条件: 初期状態(\\(t=0\\))における位置 \\(x\\) の温度が \\(f(x)\\) で与えられている\n\nという設定の下，温度 \\(T\\) の時間変化を求める問題を考えます．\n ▶  境界条件\n\\[\nT(0, t) = T(\\pi, t) = 0 \\qquad (t\\geq 0) \\label{eq-boundary}\n\\]\n ▶  初期条件\n\\[\nT(x, 0) = f(x) \\qquad (0 \\leq x \\leq \\pi) \\label{eq-init}\n\\]\n\n ▶  重ね合わせの原理\n熱伝導方程式は次のような性質があります\n\n\\(T_1, T_2\\) が \\(\\eqref{eq-hce}\\), \\(\\eqref{eq-boundary}\\) を満たすとき，\\(T_1 + T_2\\) も\\(\\eqref{eq-hce}\\), \\(\\eqref{eq-boundary}\\) を満たす\n\\(T\\) が \\(\\eqref{eq-hce}\\), \\(\\eqref{eq-boundary}\\) を満たすとき，その任意の定数倍 \\(kT\\) も\\(\\eqref{eq-hce}\\), \\(\\eqref{eq-boundary}\\) を満たす\n\nこれを重ね合わせの原理と呼びます．\n\n温度 \\(T\\) の時間変化を求める問題を解くにあたって，フーリエは重ね合わせの原理を活用して\n\n\\(\\eqref{eq-hce}\\), \\(\\eqref{eq-boundary}\\) を満たす関数の条件のうち，なるべく簡単な形のものを求める\n得られた簡単な形の関数を足し合わせることで，初期条件 \\(\\eqref{eq-init}\\) を満たす関数を作る\n\nという二段構えで解くことを考えました．簡単な形の関数としてフーリエが考えたのは変数分離型の関数です．\n\n変数分離\n変数分離型関数とは，位置 \\(x\\) 飲みの関数 \\(v(x)\\) と時刻 \\(t\\) のみの関数 \\(w(t)\\) の積\n\\[\nT(x, t) = v(x)w(t)\n\\]\nの形で表させる関数のことです．変数分離型を仮定すると熱伝導方程式は常微分方程式を用いて以下のように表せます\n\\[\n\\begin{align}\n\\frac{c\\rho}{\\lambda}\\frac{w^\\prime(t)}{w(t)} = \\frac{v^{\\prime\\prime}(x)}{v(x)}\n\\end{align}\n\\]\nLHSは\\(t\\)のみの関数，RHSは\\(x\\)飲みの関数であるので，方程式が恒等的に成り立つためには，両辺は定数でなければなりません．定数を \\(k\\) と表すと\n\\[\n\\begin{align}\nw^\\prime(t) &= k Aw(t)\\\\\nv^{\\prime\\prime}(t) &= k v(x)\n\\end{align}\n\\]\nなお \\(A = \\displaystyle\\frac{\\lambda}{c\\rho}\\) としています．\n ▶  \\(w(t)\\) について解く\n\\[\n\\begin{align}\n\\frac{dw(t)}{w(t)} &= k A dt\\\\\n\\int \\frac{dw(t)}{w(t)}dt &= \\int k A dt \\label{eq-cond}\\\\\n\\log(\\vert w(t)\\vert) &= k A t + C \\qquad (C\\text{: constant})\\\\\nw(t) &= \\alpha \\exp(k At)\\qquad (\\alpha = \\exp(C))\n\\end{align}\n\\]\n従って，\n\\[\n\\begin{align}\nw(t) = \\left\\{\\begin{array}{c}\n\\alpha\\exp(kAt) & (k \\neq 0)\\\\\n\\alpha & (k = 0)\n\\end{array}\\right.\n\\end{align}\n\\]\n ▶  \\(v(x)\\) について解く\n2次線形微分方程式において，\\(p, q\\) が定数のとき\n\\[\ny^{\\prime\\prime} + py^{\\prime} + q = 0\n\\]\nの一般解は特定方程式 \\(a^2 + pa + q =0\\) の解によって以下のように定まります\ncase 1: ２つの実数解 \\(\\hat a_1, \\hat a_2\\) を持つ場合\n\\[\ny = A\\exp(\\hat a_1 x) + B\\exp(\\hat a_2 x)\n\\]\ncase 2: ２つの虚数解 \\(\\hat a \\pm \\hat b i\\) を持つ場合\n\\[\ny = \\exp(\\hat a x)(A\\cos(\\hat b x) + B \\sin(\\hat b x))\n\\]\ncase 3: 重解 \\(\\hat a\\) を持つ場合\n\\[\ny = (Ax + B)\\exp(\\hat a x)\n\\]\n以上より，\n\\[\n\\begin{align}\nv(x) = \\left\\{\\begin{array}{c}\n\\beta \\exp(\\sqrt{k}x) + \\gamma \\exp(-\\sqrt{k}x) & \\text{if } k &gt; 0\\\\\n\\beta x + \\gamma & \\text{if } k = 0 \\\\\n\\beta\\cos(\\sqrt{\\vert k\\vert}x) + \\gamma\\sin(\\sqrt{\\vert k\\vert}x) & \\text{if } k &lt;0\n\\end{array}\\right.\n\\end{align}\n\\]\n境界条件および初期条件を満たすように係数 \\(\\alpha, \\beta, \\gamma\\) を定めれば，解が求まることになります．\n\n\nフーリエ級数の登場\n ▶  \\(k &gt; 0\\) のケース\n\\(\\eqref{eq-cond}\\) より，時間の経過とともに温度が無限大に大きくなることはないので \\(k&gt; 0\\) はありえないことが直感的に分かりますが，\\(k&gt; 0\\) と仮定したとき 境界条件を満たす \\(\\alpha, \\beta, \\gamma\\) が存在しないことを確認します．\n\\[\n\\begin{align}\nw(t) &= \\alpha\\exp(kAt) \\\\\nv(x) &= \\beta \\exp(\\sqrt{k}x) + \\gamma \\exp(-\\sqrt{k}x)\n\\end{align}\n\\]\n境界条件より\n\\[\n\\begin{align}\nv(0) &= \\beta + \\gamma = 0\\\\\nv(\\pi) &= \\beta\\exp(\\sqrt{k}\\pi) + \\gamma\\exp(-\\sqrt{k}\\pi) = 0\n\\end{align}\n\\]\nここから\n\\[\n\\beta(\\exp(\\sqrt{k}\\pi) - \\exp(-\\sqrt{k}\\pi)) = 0\n\\]\n従って，\n\\[\n\\begin{align}\n&\\beta = \\gamma = 0\\\\\n\\Rightarrow& v(x) =  0\n\\end{align}\n\\]\nこれは \\(f(x) = 0 \\ \\ \\forall x \\in [0, \\pi]\\) 以外の場合は初期条件を満たすことがない．\n ▶  \\(k = 0\\) のケース\n\\[\n\\begin{align}\nw(t) &= \\alpha\\\\\nv(x) &= \\beta x + \\gamma\n\\end{align}\n\\]\n境界条件を満たすためには \\(\\beta = \\gamma = 0\\) が必要になるが，\\(f(x) = 0 \\ \\ \\forall x \\in [0, \\pi]\\) 以外の場合は初期条件を満たすことがない．\n ▶  \\(k &lt; 0\\) のケース\n\\[\n\\begin{align}\nw(t) &= \\alpha\\exp(kAt) \\\\\nv(x) &= \\beta\\cos(\\sqrt{\\vert k\\vert}x) + \\gamma\\sin(\\sqrt{\\vert k\\vert}x)\n\\end{align}\n\\]\n境界条件より\n\\[\n\\begin{align}\n\\beta &= 0\\\\\n\\gamma\\sin(\\sqrt{\\vert k\\vert}\\pi) &= 0\n\\end{align}\n\\]\n\\(\\gamma= 0\\) だと初期条件を満たすことができないので，\\(\\gamma \\neq 0\\). このとき，\\(\\sqrt{\\vert k\\vert} \\in \\mathbb Z\\) が解の必要条件となることが分かる． ここで，\\(k = -n^2\\) と書き直すと\n\\[\n\\begin{align}\nT(x, t) = \\alpha\\exp(-n^2At) \\cdot \\gamma\\sin(n\\pi) \\label{eq-sol-candidate}\n\\end{align}\n\\]\nが境界条件を満たす変数分離型の解となるとこが分かります．重ね合わせの原理より \\(\\eqref{eq-sol-candidate}\\) の定数倍も境界条件と熱伝導方程式を満たす関数となります．\n重ね合わせの原理より \\(1 \\leq n \\leq N\\) の範囲で\n\\[\n\\sum_{n=1}^N a_n \\alpha\\exp(-n^2At) \\cdot \\gamma\\sin(n\\pi)\n\\]\nも境界条件と熱伝導方程式を満たす関数となります．ここでフーリエは次のような主張をしました：\n\n\\[\n\\sum_{n=1}^\\infty a_n \\alpha\\exp(-n^2At) \\cdot \\gamma\\sin(n\\pi)\n\\]\nも境界条件と熱伝導方程式を満たす関数となりえる\n\nここから初期条件を満たす関数を求めたいので, \\(t=0\\) とすると\n\\[\nf(x) = \\sum_{n=1}^\\infty b_n \\sin(n\\pi)\n\\]\nが成り立つように \\(\\{b_n\\}_{n=1}^\\infty\\) を定めれば良いとなります．このとき，正弦関数の積の積分公式\n\\[\n\\begin{align}\n\\int^{\\pi}_0\\sin nx \\sin mx dx =\\begin{cases}\n\\displaystyle 0 & (m\\neq n)\\\\[4pt]\n\\displaystyle \\frac{\\pi}{2} & (m = n)\n\\end{cases}\n\\end{align}\n\\]\n従って，\n\\[\n\\begin{align}\n\\int^{\\pi}_0f(x)\\sin mx\\ dx\n& = \\int^\\pi_0 \\sum_{n=1}^\\infty b_n \\sin(n\\pi) \\sin(m\\pi) dx\\\\\n&= \\sum_{n=1}^\\infty \\int^\\pi_0b_n \\sin(n\\pi) \\sin(m\\pi) dx\\\\\n&= \\frac{\\pi}{2}b_m\n\\end{align}\n\\]\nとなり，\n\\[\nb_n = \\frac{2}{\\pi}\\int^{\\pi}_0f(x)\\sin nx \\ dx\n\\]\nこのように求めた級数関数が変数分離型を仮定したときの熱伝導方程式の解となりうるとフーリエは主張しました． これがフーリエ級数の誕生です.\n\n\nフーリエ級数の問題点と積分理論再考へ\nフーリエ級数が登場初期には以下のような批判にさらされました:\n\nフーリエ級数が収束する保証はどこにあるのか？\n\\(0\\)から\\(\\pi\\)までの特定の一個の\\(x\\)について\\(f(x)\\)の値を変更しても積分の値には影響しないので異なる関数が同じフーリエ級数で表現されてしまうのではないか？\n無限級数の項別積分(無限和と積分の順序交換)ができる保証はどこにあるのか？\n\n無限和と積分の順序交換の批判とは，仮に熱分布関数\\(T(x, t)\\)がフーリエ級数の形式で表せることができたとしても\n\\[\n\\begin{align*}\n&\\int^\\pi_{-\\pi}\\sum_{k=1}^\\infty (a_k \\cos kx + b_k \\sin kx)\\cos nx\\ dx \\\\\n&=\\sum_{k=1}^\\infty \\left(a_k \\int^\\pi_{-\\pi}\\cos kx \\cos nx\\ dx + b_k \\int^\\pi_{-\\pi}\\sin kx \\cos nx\\ dx\\right)\n\\end{align*}\n\\]\nができる保証がないというものです. これはフーリエ級数のそれ自体の問題というよりかは\n\nどんな関数が積分可能か？\nどのようなときに項別積分ができるのか？\n\nという積分の定義・理論の問題です．フーリエの時代では積分の理論が十分なものではなく，微分の逆として積分が捉えられており，上記の問題に答えることができませんでした． 以上が，熱の変化という自然科学現象の解明のため提案されたフーリエ級数が数学理論，特に積分理論の再整備の必要性を促した流れとなります．"
  },
  {
    "objectID": "posts/2025-01-29-set-and-topology-series/index.html#appendix-正弦関数の積の積分公式の証明",
    "href": "posts/2025-01-29-set-and-topology-series/index.html#appendix-正弦関数の積の積分公式の証明",
    "title": "フーリエ級数と積分理論再考",
    "section": "Appendix: 正弦関数の積の積分公式の証明",
    "text": "Appendix: 正弦関数の積の積分公式の証明\n\n\nExercise 1 \n\\(n,k\\)をそれぞれ自然数としたとき\n\\[\n\\begin{align}\n\\int^{\\pi}_0\\sin nx \\sin kx dx =\\begin{cases}\n\\displaystyle 0 & (k\\neq n)\\\\[4pt]\n\\displaystyle \\frac{\\pi}{2} & (k = n)\n\\end{cases}\n\\end{align}\n\\]\n\n\n\n\n\n\n\n\n\nProof\n\n\n\n\n\n積和の公式より\n\\[\n\\sin \\alpha\\sin \\beta=-\\frac{1}{2} \\left\\{\\cos(\\alpha+\\beta)-\\cos(\\alpha-\\beta)\\right\\}\n\\]\nこの積和の公式を用いると\n\\[\n\\begin{align}\n&\\int^{\\pi}_0\\sin nx \\sin kx\\ dx \\\\\n&= -\\frac{1}{2}\\int^{\\pi}_0 \\left\\{\\cos(n+k)x-\\cos(n-k)x\\right\\} dx \\\\\n&= -\\frac{1}{2}\\left\\{\\int^{\\pi}_0\\cos(n+k)x\\ dx- \\int^{\\pi}_0\\cos(n-k)x\\ dx\\right\\}\n\\end{align}\n\\]\nつぎに以下のケースを考えます\n\n\\(n=k\\)のとき\n\\(n\\neq k\\)のとき\n\n\n\\(n=k\\)のとき\n\n\\[\n-\\frac{1}{2}\\left\\{\\int^{\\pi}_0\\cos(n+k)x\\ dx- \\int^{\\pi}_0\\cos(n-k)x\\ dx\\right\\}\n\\]\nの第二項は\\(\\pi\\)となる一方, 第一項は\n\\[\n\\begin{align}\n\\int^{\\pi}_0\\cos(n+k)x dx &= -\\left[\\sin(n+k)x\\right]^{\\pi}_0\\\\\n&= 0\n\\end{align}\n\\]\n従って,\n\\[\n-\\frac{1}{2}\\left\\{\\int^{\\pi}_0\\cos(n+k)x\\ dx- \\int^{\\pi}_0\\cos(n-k)x\\ dx\\right\\} = \\frac{\\pi}{2}\n\\]\n\n\\(n\\neq k\\)のとき\n\n\\[\n\\begin{align}\n\\int^{\\pi}_0\\cos(n-k)x\\ dx &= -\\left[\\sin(n-k)x\\right]^{\\pi}_0 = 0\\\\[3pt]\n\\int^{\\pi}_0\\cos(n+k)x\\ dx &= -\\left[\\sin(n+k)x\\right]^{\\pi}_0 = 0\n\\end{align}\n\\]\nより\n\\[\n-\\frac{1}{2}\\left\\{\\int^{\\pi}_0\\cos(n+k)x\\ dx- \\int^{\\pi}_0\\cos(n-k)x\\ dx\\right\\} = 0\n\\]"
  },
  {
    "objectID": "posts/2025-04-10-scatter-plot-with-D3/index.html",
    "href": "posts/2025-04-10-scatter-plot-with-D3/index.html",
    "title": "D3を用いた散布図生成",
    "section": "",
    "text": "可視化方針\n\n\n\n ▶  Question\n\n日常活動について，活動に対して感じる有意義さと活動を通して得られる幸福感はどのように相関しているのか？\n\n ▶  Data\n\n\n\n\n\n\n\nDataset\n2022 American Time Use Survey\n\n\nPATH\n./act_means.tsv\n\n\nAbout\n洗濯や調理などの日常活動に従事するときに感じる幸福度と有意義さをスコア化して，その平均を活動ごとに表したもの\n\n\n\n ▶  可視化コンポーネント: normal\n\nscatter_plot_default.html: HTML sturecture\nscatterplot_style.css: CSS for styling\nscatterplot_default.js: JS for scatterplot\n\n ▶  可視化コンポーネント: bubble version\n\nscatter_plot_with_bubble.html: HTML sturecture\nscatterplot_with_bubble.js: JS for bubbleplot"
  },
  {
    "objectID": "posts/2025-04-10-scatter-plot-with-D3/index.html#問題設定と可視化",
    "href": "posts/2025-04-10-scatter-plot-with-D3/index.html#問題設定と可視化",
    "title": "D3を用いた散布図生成",
    "section": "",
    "text": "可視化方針\n\n\n\n ▶  Question\n\n日常活動について，活動に対して感じる有意義さと活動を通して得られる幸福感はどのように相関しているのか？\n\n ▶  Data\n\n\n\n\n\n\n\nDataset\n2022 American Time Use Survey\n\n\nPATH\n./act_means.tsv\n\n\nAbout\n洗濯や調理などの日常活動に従事するときに感じる幸福度と有意義さをスコア化して，その平均を活動ごとに表したもの\n\n\n\n ▶  可視化コンポーネント: normal\n\nscatter_plot_default.html: HTML sturecture\nscatterplot_style.css: CSS for styling\nscatterplot_default.js: JS for scatterplot\n\n ▶  可視化コンポーネント: bubble version\n\nscatter_plot_with_bubble.html: HTML sturecture\nscatterplot_with_bubble.js: JS for bubbleplot"
  },
  {
    "objectID": "posts/2025-04-10-scatter-plot-with-D3/index.html#scatter-plot-with-d3",
    "href": "posts/2025-04-10-scatter-plot-with-D3/index.html#scatter-plot-with-d3",
    "title": "D3を用いた散布図生成",
    "section": "scatter plot with D3",
    "text": "scatter plot with D3\nMeaningfullness vs Hapiness について２つのplotを以下では提示しています． 左右のFigureは同じデータを使っているにも関わらず印象が異なります．\n\n\n\n\n\n\n解釈\n\n\n\n\nScatter Plot: Meaningfullness と Hapiness の間にはハッキリとした相関関係は見られない\nBubble Plot: 活動別従事者割合(relwt)をweightとして，それをbubble sizeに当てはめた場合，meaningfullnessとHapinessの間には正の相関があると推察できる\n\n\n\nscatter plotでは各点が等しく重要であるという印象を読み手に与えますが，aggregateデータではcount sizeがindexごとによって異なるケースでは 「各点が等しく重要」というのはミスリーディングかもしれません．このような場合，各indexのcount sizeという第３の情報をバブルの面積に比例させることで表すというBubble plotの利用が考えられます．\nただし，バブルの導入により各点が重なって読みづらくなってしまうというトレードオフもあるので，opacityの調整や，そもそも使用しないなどの意思決定をケースバイケースで実施していくことが必要です．\n\n\n ▶  Scatter Plot\n\n\n\n\n\n\n ▶  Bubble Plot\n\n\n\n\n\n\n\n\n\n\n\n\n\nBubble Plotのコツ\n\n\n\n\nバブルの大きさは通常「面積」で表現するべき\nd3.scaleSqrt() を使ってバブルの半径をsqrtスケーリングすると，面積をデータに比例させることができます\nバブル同士が重なってしまうと個別の値が読み取りにくくなるので，透過度(opacity)の調整やBorder colorの導入の検討が必要\n\n\n\n\nアンチパターン: 透過度の重要性\nscatter plot, bubble plotにおいて，透過度（opacity）の調整は，データの密度や重なりを視覚的に正確に伝えるという効果を持つ重要な視覚的テクニックです．\n\n\n\n\n\n\n可視化シーン別透過度調整の効果\n\n\n\n\nscatter plot: 重なりが多いところが自然と濃くなるため，「どこに多くのデータが集中しているか」が明確になる\nbubble plot: 先に描いた点や小さい円が完全に見えなくなることを防ぐ\n\n\n\n以下では透過度を全く調整せずに可視化した場合を示しています．\n\n\n ▶  Scatter Plot\n\nすべての点が同じ濃さのため，data point密度の「濃度差が表現されない」\nバブルのサイズや色も一定なので視覚的には「一様」に見えてしまい、分布の濃淡や偏り、異常検知が難しくなる\n\n\n\n\n\n\n\n ▶  Bubble Plot\n\n小さなバブルが大きなバブルの下に隠れて見えなくなる\n密集したエリアがごちゃごちゃして読みづらくなる\nどのバブルがどの値か判別しにくくなるため，面積情報のメリットが薄れる"
  },
  {
    "objectID": "posts/2025-03-02-find-coordinates/index.html",
    "href": "posts/2025-03-02-find-coordinates/index.html",
    "title": "敵の砲台の座標を探せ 1/N",
    "section": "",
    "text": "\\((a, b)\\) を中心点とする半径 \\(r\\) の円をplotすることを考えます．\n半径 \\(r\\) の円の中心点の座標が原点 \\((0, 0)\\) にある場合，円周上の点 \\(P = (x, y)\\) は，\\(P\\) から \\(x\\) 軸に下ろした垂線と \\(x\\) 軸が交わる点を \\(Q\\) としたとき \\(\\triangle OPQ\\) は斜辺 \\(r\\)，高さ \\(y\\), 底辺の長さ \\(x\\) となる直角三角形を構成するので，三平方の定理より\n\\[\nr^2 = x^2 + y^2\n\\]\nこれが円上の座標が満たす方程式となります．原点を中心点とする場合を考えましたが，中心が \\((a, b)\\)，半径 \\(r\\) の円の式は同様の方法で\n\\[\nr^2 = (x - a)^2 + (y - b)^2 \\label{#eq-circle}\n\\]\nと表すことが出来ます．\n\n\nCode\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport matplotlib.tri as mtri\n\n# set params\nR = 1\nO = (2, 1)\n\n# variables\ntheta = np.linspace(0, 2 * np.pi, 1000)\nx = np.cos(theta) * R + O[0]\ny = np.sin(theta) * R + O[1]\n\nA = (x[100], y[100])\ntriangles = [[0, 1, 2]]\nx_trinagle = [O[0], A[0], A[0]]\ny_trinagle = [O[1], O[1], A[1]]\ntriang = mtri.Triangulation(x_trinagle, y_trinagle, triangles)\n\n# plot\nfig, ax = plt.subplots(figsize=(8, 6))\nax.grid()\nax.set_aspect(\"equal\")\nax.set_xlim(0.5, 3.5)\nax.set_ylim(-0.5, 2.5)\n\n\nax.plot(x, y)\nax.scatter(*O, s=8, color=\"k\")\nax.scatter(*A, s=8, color=\"k\")\nax.text(*O, s=\"O\",  ha='center', va='bottom')\nax.text(*A, s=\"A = ($x_1, y_1$)\", ha='left', va='bottom')\nax.text(2.4, 1.35, s=\"r\")\nax.text(2.4, 0.9, s=\"$x_1 - 2$\", ha='center', va='bottom')\nax.text(A[0]+0.05, 1.35, s=\"$y_1 - 1$\", ha='left', va='bottom')\n\n# add lines\nax.triplot(triang, 'ko-')\n\n\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\n# set params\nR = 2.5\nO = (3, 1/2)\n\n# variables\ntheta = np.linspace(0, 2 * np.pi, 1000)\nx = np.cos(theta) * R + O[0]\ny = np.sin(theta) * R + O[1]\n\nP = (1, -1)\nQ = (3, 3)\nR = (1, 2)\n\n# plot\nfig, ax = plt.subplots(figsize=(8, 6))\nax.grid()\nax.set_aspect(\"equal\")\n\nax.plot(x, y)\nax.scatter(*O, s=8, color=\"k\")\nax.scatter(*P, s=8, color=\"k\")\nax.scatter(*Q, s=8, color=\"k\")\nax.scatter(*R, s=8, color=\"k\")\nax.text(*O, s=\"O\",  ha='center', va='bottom')\nax.text(*P, s=\"P\",  ha='center', va='bottom')\nax.text(*Q, s=\"Q\", ha='left', va='bottom')\nax.text(*R, s=\"R\", ha='left', va='bottom')\n\n\nplt.show()\n\n\n\n\n\n\n\n\n\n３点 \\(P = (1, -1), Q = (3, 3), R = (1, 2)\\) が与えられたとして，この３点を通る円を求める問題を考えます．\n\\(\\eqref{#eq-circle}\\) を展開すると\n\\[\nx^2 + y^2 - 2ax - 2by + a^2 + b^2 = r^2\n\\]\nこれを整理して\n\\[\nx^2 + y^2 + Ax + By + C = 0 \\label{#eq-basemodel}\n\\]\nと変形します．ここで，\\(P = (1, -1), Q = (3, 3), R = (1, 2)\\) の情報を用いると\n\\[\n\\begin{gather}\n2 + A - B + C = 0\\\\\n18 + 3A + 3B + C = 0\\\\\n5 + A +2B + C = 0\n\\end{gather}\n\\]\nという \\(A,B,C\\) についての連立方程式を得ることが出来ます．これを解くと\n\\[\nA = -6, B = -1, C = 3\n\\]\n従って，\n\\[\n(x - 3)^2 + (y - 0.5)^2 = 2.5^2 \\label{#eq-ans1}\n\\]\n\n\n点 \\(P, Q, R\\) からなる三角形の外接円として求めたい円を捉えることも出来ます． 外接円の円心は三角形の各線分の垂直二等分線の交点として求めることが出来ます．\n\n\nCode\ndef func_pq(x):\n    a = - (P[0] - Q[0]) / (P[1] - Q[1])\n    b = - a * (P[0] + Q[0]) / 2 + (P[1] + Q[1]) / 2\n\n    return a*x + b\n\ndef func_pr(x):\n    a = - (P[0] - R[0]) / (P[1] - R[1])\n    b = - a * (P[0] + R[0]) / 2 + (P[1] + R[1]) / 2\n\n    return a*x + b\n\nx_lin = np.array([0, 6])\ntriangles = [[0, 1, 2]]\nx_trinagle = [P[0], Q[0], R[0]]\ny_trinagle = [P[1], Q[1], R[1]]\ntriang = mtri.Triangulation(x_trinagle, y_trinagle, triangles)\n\n\n\n# plot\nfig, ax = plt.subplots(figsize=(8, 6))\nax.grid()\nax.set_aspect(\"equal\")\nax.set_xlim(0, 6)\nax.set_ylim(-2.5, 3.5)\nax.plot(x_lin, func_pq(x_lin), label='PQ Perpendicular bisector', linestyle='--', color='gray')\nax.plot(x_lin, func_pr(x_lin), label='PR Perpendicular bisector', linestyle=':', color='gray')\n\n\nax.plot(x, y)\nax.scatter(*O, s=8, color=\"k\")\nax.scatter(*P, s=8, color=\"k\")\nax.scatter(*Q, s=8, color=\"k\")\nax.scatter(*R, s=8, color=\"k\")\nax.text(*O, s=\"O\",  ha='center', va='bottom')\nax.text(*P, s=\"P\",  ha='center', va='bottom')\nax.text(*Q, s=\"Q\", ha='left', va='bottom')\nax.text(*R, s=\"R\", ha='left', va='bottom')\n\n# add lines\nax.triplot(triang, 'ko-')\n\nplt.legend(loc='center left', bbox_to_anchor=(1, 0.95))\nplt.show()\n\n\n\n\n\n\n\n\n\n\\(PQ\\) の垂直二等分線 \\(f(x)\\) は\n\\[\n\\begin{align}\nf(x)\n    &= -\\frac{P_x - Q_x}{P_y - Q_y}x + \\frac{P_y + Q_y}{2} + \\frac{P_x - Q_x}{P_y - Q_y} \\frac{P_x + Q_y}{2}\\\\\n    &= -\\frac{P_x - Q_x}{P_y - Q_y}x + \\frac{P_x^2 - Q_x^2 + P_y^2 - Q_y^2}{2(P_y - Q_y)}\n\\end{align}\n\\]\n同様に \\(PR\\) の垂直二等分線 \\(g(x)\\) は\n\\[\n\\begin{align}\ng(x)\n    &= -\\frac{P_x - R_x}{P_y - R_y}x + \\frac{P_y + R_y}{2} + \\frac{P_x - R_x}{P_y - R_y} \\frac{P_x + R_y}{2}\\\\\n    &= -\\frac{P_x - R_x}{P_y - R_y}x + \\frac{P_x^2 - R_x^2 + P_y^2 - R_y^2}{2(P_y - R_y)}\n\\end{align}\n\\]\nここから \\(f(x), g(x)\\) が交差する点を求めることで外接円の円心を求めることが出来ます．\n少しめんどくさいので，数値計算で説いてみると\n\n\nCode\na = - (P[0] - Q[0]) / (P[1] - Q[1])\nb = - a * (P[0] + Q[0]) / 2 + (P[1] + Q[1]) / 2\nc = - (P[0] - R[0]) / (P[1] - R[1])\nd = - c * (P[0] + R[0]) / 2 + (P[1] + R[1]) / 2\n\nprint((d-b)/(a-c), a * (d-b)/(a-c) + b)\n\n\n3.0 0.5\n\n\n\\(\\eqref{#eq-ans1}\\) と一致する計算結果となることが確かめられました．\n\n📘 REMARKS \n上記の垂直二等分線の交点を \\((x_0, y_0)\\) としたとき，整理すると以下のようになります．\n\\[\nA = \\left(\\begin{array}{cc}\nR_y - Q_y & -(P_y - Q_y)\\\\\n-(R_x - Q_x) & P_x - Q_x\\\\\n\\end{array}\\right)\n\\]\nとしたとき，\n\\[\n\\left(\\begin{array}{c}\nx_0\\\\\ny_0\n\\end{array}\\right)\n    = \\frac{1}{\\operatorname{det}A} A\\left(\\begin{array}{c}\n(P_x^2 - Q_x^2 + P_y^2 - Q_y^2)/2\\\\\n(R_x^2 - Q_x^2 + R_y^2 - Q_y^2)/2\n\\end{array}\\right)\n\\]\n実際に計算してみると\n\n\nCode\nA_array = np.array([[R[1] - Q[1], -(P[1] - Q[1])], [-(R[0] - Q[0]), P[0] - Q[0]]])\nB_array = np.array(\n    [\n        [(P[0]**2 - Q[0]**2 + P[1]**2 - Q[1]**2) / 2],\n        [(R[0]**2 - Q[0]**2 + R[1]**2 - Q[1]**2) / 2],\n    ]\n)\n\nresult = np.ravel((A_array @ B_array) / np.linalg.det(A_array))\nradius = np.sqrt(np.sum((np.array(P) - result) **2))\nprint(f\"中心点 = ({result}), 半径 = {radius}\")\n\n\n中心点 = ([3.  0.5]), 半径 = 2.5"
  },
  {
    "objectID": "posts/2025-03-02-find-coordinates/index.html#円の式",
    "href": "posts/2025-03-02-find-coordinates/index.html#円の式",
    "title": "敵の砲台の座標を探せ 1/N",
    "section": "",
    "text": "\\((a, b)\\) を中心点とする半径 \\(r\\) の円をplotすることを考えます．\n半径 \\(r\\) の円の中心点の座標が原点 \\((0, 0)\\) にある場合，円周上の点 \\(P = (x, y)\\) は，\\(P\\) から \\(x\\) 軸に下ろした垂線と \\(x\\) 軸が交わる点を \\(Q\\) としたとき \\(\\triangle OPQ\\) は斜辺 \\(r\\)，高さ \\(y\\), 底辺の長さ \\(x\\) となる直角三角形を構成するので，三平方の定理より\n\\[\nr^2 = x^2 + y^2\n\\]\nこれが円上の座標が満たす方程式となります．原点を中心点とする場合を考えましたが，中心が \\((a, b)\\)，半径 \\(r\\) の円の式は同様の方法で\n\\[\nr^2 = (x - a)^2 + (y - b)^2 \\label{#eq-circle}\n\\]\nと表すことが出来ます．\n\n\nCode\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport matplotlib.tri as mtri\n\n# set params\nR = 1\nO = (2, 1)\n\n# variables\ntheta = np.linspace(0, 2 * np.pi, 1000)\nx = np.cos(theta) * R + O[0]\ny = np.sin(theta) * R + O[1]\n\nA = (x[100], y[100])\ntriangles = [[0, 1, 2]]\nx_trinagle = [O[0], A[0], A[0]]\ny_trinagle = [O[1], O[1], A[1]]\ntriang = mtri.Triangulation(x_trinagle, y_trinagle, triangles)\n\n# plot\nfig, ax = plt.subplots(figsize=(8, 6))\nax.grid()\nax.set_aspect(\"equal\")\nax.set_xlim(0.5, 3.5)\nax.set_ylim(-0.5, 2.5)\n\n\nax.plot(x, y)\nax.scatter(*O, s=8, color=\"k\")\nax.scatter(*A, s=8, color=\"k\")\nax.text(*O, s=\"O\",  ha='center', va='bottom')\nax.text(*A, s=\"A = ($x_1, y_1$)\", ha='left', va='bottom')\nax.text(2.4, 1.35, s=\"r\")\nax.text(2.4, 0.9, s=\"$x_1 - 2$\", ha='center', va='bottom')\nax.text(A[0]+0.05, 1.35, s=\"$y_1 - 1$\", ha='left', va='bottom')\n\n# add lines\nax.triplot(triang, 'ko-')\n\n\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\n# set params\nR = 2.5\nO = (3, 1/2)\n\n# variables\ntheta = np.linspace(0, 2 * np.pi, 1000)\nx = np.cos(theta) * R + O[0]\ny = np.sin(theta) * R + O[1]\n\nP = (1, -1)\nQ = (3, 3)\nR = (1, 2)\n\n# plot\nfig, ax = plt.subplots(figsize=(8, 6))\nax.grid()\nax.set_aspect(\"equal\")\n\nax.plot(x, y)\nax.scatter(*O, s=8, color=\"k\")\nax.scatter(*P, s=8, color=\"k\")\nax.scatter(*Q, s=8, color=\"k\")\nax.scatter(*R, s=8, color=\"k\")\nax.text(*O, s=\"O\",  ha='center', va='bottom')\nax.text(*P, s=\"P\",  ha='center', va='bottom')\nax.text(*Q, s=\"Q\", ha='left', va='bottom')\nax.text(*R, s=\"R\", ha='left', va='bottom')\n\n\nplt.show()\n\n\n\n\n\n\n\n\n\n３点 \\(P = (1, -1), Q = (3, 3), R = (1, 2)\\) が与えられたとして，この３点を通る円を求める問題を考えます．\n\\(\\eqref{#eq-circle}\\) を展開すると\n\\[\nx^2 + y^2 - 2ax - 2by + a^2 + b^2 = r^2\n\\]\nこれを整理して\n\\[\nx^2 + y^2 + Ax + By + C = 0 \\label{#eq-basemodel}\n\\]\nと変形します．ここで，\\(P = (1, -1), Q = (3, 3), R = (1, 2)\\) の情報を用いると\n\\[\n\\begin{gather}\n2 + A - B + C = 0\\\\\n18 + 3A + 3B + C = 0\\\\\n5 + A +2B + C = 0\n\\end{gather}\n\\]\nという \\(A,B,C\\) についての連立方程式を得ることが出来ます．これを解くと\n\\[\nA = -6, B = -1, C = 3\n\\]\n従って，\n\\[\n(x - 3)^2 + (y - 0.5)^2 = 2.5^2 \\label{#eq-ans1}\n\\]\n\n\n点 \\(P, Q, R\\) からなる三角形の外接円として求めたい円を捉えることも出来ます． 外接円の円心は三角形の各線分の垂直二等分線の交点として求めることが出来ます．\n\n\nCode\ndef func_pq(x):\n    a = - (P[0] - Q[0]) / (P[1] - Q[1])\n    b = - a * (P[0] + Q[0]) / 2 + (P[1] + Q[1]) / 2\n\n    return a*x + b\n\ndef func_pr(x):\n    a = - (P[0] - R[0]) / (P[1] - R[1])\n    b = - a * (P[0] + R[0]) / 2 + (P[1] + R[1]) / 2\n\n    return a*x + b\n\nx_lin = np.array([0, 6])\ntriangles = [[0, 1, 2]]\nx_trinagle = [P[0], Q[0], R[0]]\ny_trinagle = [P[1], Q[1], R[1]]\ntriang = mtri.Triangulation(x_trinagle, y_trinagle, triangles)\n\n\n\n# plot\nfig, ax = plt.subplots(figsize=(8, 6))\nax.grid()\nax.set_aspect(\"equal\")\nax.set_xlim(0, 6)\nax.set_ylim(-2.5, 3.5)\nax.plot(x_lin, func_pq(x_lin), label='PQ Perpendicular bisector', linestyle='--', color='gray')\nax.plot(x_lin, func_pr(x_lin), label='PR Perpendicular bisector', linestyle=':', color='gray')\n\n\nax.plot(x, y)\nax.scatter(*O, s=8, color=\"k\")\nax.scatter(*P, s=8, color=\"k\")\nax.scatter(*Q, s=8, color=\"k\")\nax.scatter(*R, s=8, color=\"k\")\nax.text(*O, s=\"O\",  ha='center', va='bottom')\nax.text(*P, s=\"P\",  ha='center', va='bottom')\nax.text(*Q, s=\"Q\", ha='left', va='bottom')\nax.text(*R, s=\"R\", ha='left', va='bottom')\n\n# add lines\nax.triplot(triang, 'ko-')\n\nplt.legend(loc='center left', bbox_to_anchor=(1, 0.95))\nplt.show()\n\n\n\n\n\n\n\n\n\n\\(PQ\\) の垂直二等分線 \\(f(x)\\) は\n\\[\n\\begin{align}\nf(x)\n    &= -\\frac{P_x - Q_x}{P_y - Q_y}x + \\frac{P_y + Q_y}{2} + \\frac{P_x - Q_x}{P_y - Q_y} \\frac{P_x + Q_y}{2}\\\\\n    &= -\\frac{P_x - Q_x}{P_y - Q_y}x + \\frac{P_x^2 - Q_x^2 + P_y^2 - Q_y^2}{2(P_y - Q_y)}\n\\end{align}\n\\]\n同様に \\(PR\\) の垂直二等分線 \\(g(x)\\) は\n\\[\n\\begin{align}\ng(x)\n    &= -\\frac{P_x - R_x}{P_y - R_y}x + \\frac{P_y + R_y}{2} + \\frac{P_x - R_x}{P_y - R_y} \\frac{P_x + R_y}{2}\\\\\n    &= -\\frac{P_x - R_x}{P_y - R_y}x + \\frac{P_x^2 - R_x^2 + P_y^2 - R_y^2}{2(P_y - R_y)}\n\\end{align}\n\\]\nここから \\(f(x), g(x)\\) が交差する点を求めることで外接円の円心を求めることが出来ます．\n少しめんどくさいので，数値計算で説いてみると\n\n\nCode\na = - (P[0] - Q[0]) / (P[1] - Q[1])\nb = - a * (P[0] + Q[0]) / 2 + (P[1] + Q[1]) / 2\nc = - (P[0] - R[0]) / (P[1] - R[1])\nd = - c * (P[0] + R[0]) / 2 + (P[1] + R[1]) / 2\n\nprint((d-b)/(a-c), a * (d-b)/(a-c) + b)\n\n\n3.0 0.5\n\n\n\\(\\eqref{#eq-ans1}\\) と一致する計算結果となることが確かめられました．\n\n📘 REMARKS \n上記の垂直二等分線の交点を \\((x_0, y_0)\\) としたとき，整理すると以下のようになります．\n\\[\nA = \\left(\\begin{array}{cc}\nR_y - Q_y & -(P_y - Q_y)\\\\\n-(R_x - Q_x) & P_x - Q_x\\\\\n\\end{array}\\right)\n\\]\nとしたとき，\n\\[\n\\left(\\begin{array}{c}\nx_0\\\\\ny_0\n\\end{array}\\right)\n    = \\frac{1}{\\operatorname{det}A} A\\left(\\begin{array}{c}\n(P_x^2 - Q_x^2 + P_y^2 - Q_y^2)/2\\\\\n(R_x^2 - Q_x^2 + R_y^2 - Q_y^2)/2\n\\end{array}\\right)\n\\]\n実際に計算してみると\n\n\nCode\nA_array = np.array([[R[1] - Q[1], -(P[1] - Q[1])], [-(R[0] - Q[0]), P[0] - Q[0]]])\nB_array = np.array(\n    [\n        [(P[0]**2 - Q[0]**2 + P[1]**2 - Q[1]**2) / 2],\n        [(R[0]**2 - Q[0]**2 + R[1]**2 - Q[1]**2) / 2],\n    ]\n)\n\nresult = np.ravel((A_array @ B_array) / np.linalg.det(A_array))\nradius = np.sqrt(np.sum((np.array(P) - result) **2))\nprint(f\"中心点 = ({result}), 半径 = {radius}\")\n\n\n中心点 = ([3.  0.5]), 半径 = 2.5"
  },
  {
    "objectID": "posts/2025-03-02-find-coordinates/index.html#敵の砲台の座標を探せ",
    "href": "posts/2025-03-02-find-coordinates/index.html#敵の砲台の座標を探せ",
    "title": "敵の砲台の座標を探せ 1/N",
    "section": "敵の砲台の座標を探せ",
    "text": "敵の砲台の座標を探せ\n\n\nExercise 1 \nとある固定の１地点から自軍領地に対して敵が砲撃をかけてきているとします. 敵の砲台は角度のみを調整できるだけで，砲撃予定距離 \\(r\\) は一定とします．ただし，実際の砲撃距離は風向などの外乱要因によってノイズが混じっているとします．\nとある日に敵から50回の攻撃を受けたとき，その砲台座標を推定してください．砲撃のノイズは\\(\\operatorname{i.i.d}\\)とする．\n\n\n\\(\\eqref{#eq-basemodel}\\) より\n\\[\n\\begin{align}\nz_i = - x_i^2 - y_i^2\n\\end{align}\n\\]\nと定義すると，\\(e_i\\) をresidualとして\n\\[\nz_i = \\beta_0 + \\beta_1 x_i + \\beta_2 y_i + e_i\n\\]\nについて \\((\\beta_0, \\beta_1, \\beta_2)\\) をLinear modelで推定し，その推定値を \\((\\hat\\beta_0, \\hat\\beta_1, \\hat\\beta_2)\\) と表せば 敵の砲台の推定座標 \\((\\hat x, \\hat y)\\) 及び推定距離 \\(\\hat r\\) は\n\\[\n\\begin{align}\n\\hat x &= -\\hat\\beta_1/2\\\\\n\\hat y &= -\\hat\\beta_2/2\\\\\n\\hat r &= \\sqrt{\\hat x^2 + \\hat y^2 - \\hat\\beta_0}\n\\end{align}\n\\]\nと計算できそうに思えます．\n ▶  Data Generating Process\n\n敵の砲台の座標は \\((0, 0)\\)\n敵は \\((0, 0)\\) の地点から砲撃距離 \\(20\\) で攻撃してくる\n実際の砲撃距離 \\(r \\sim N(20, 1)\\)\n砲撃角度は \\(\\left[\\displaystyle{\\frac{\\pi}{3}, \\frac{\\pi}{2}}\\right]\\) の範囲で一様分布で定まる\n\nというData Generating Processとします．\n\n\nCode\ndef gdp(x_0: float, y_0: float, noise: float = 1.0, radius: float = 20,  attack_num: int = 50):\n    # params\n    theta = np.random.uniform(np.pi/3 , np.pi/2 , attack_num)\n    r = radius + np.random.normal(0, noise, attack_num)\n\n    x = np.cos(theta) * r + x_0\n    y = np.sin(theta) * r + y_0\n\n    return x, y\n\n\nこのGDPに従う形で攻撃されたとするとき，その散布図は以下のようになります．\n\n\nCode\nnp.random.seed(42)\n\nx_attack, y_attack = gdp(0, 0)\n\nfig, ax = plt.subplots()\nax.scatter(x_attack, y_attack)\nax.set_xlim(-1, np.max([np.max(x_attack), np.max(y_attack)]) + 1)\nax.set_ylim(-1, np.max([np.max(x_attack), np.max(y_attack)]) + 1)\nax.grid()\nax.set_aspect('equal')\nplt.show()\n\n\n\n\n\n\n\n\n\n ▶  OLS Monte Carlo Simulation\nOLSによるパラメータ推定値を \\(1,000\\) 回simulationし，その組み合わせをkde plotしたものが以下となります．x座標についてバイアスがあることがわかります． 砲撃距離に関しても不自然な推定値となっています．\n\n\nCode\nimport pandas as pd\nimport statsmodels.api as sm\nimport seaborn as sns\n\ndef gpd_dataframe(x: float = 0, y: float = 0, noise: float = 1.0):\n    x_attack, y_attack = gdp(x, y, noise)\n    df = pd.DataFrame(\n        {\n            \"x_coordinate\": x_attack,\n            \"y_coordinate\": y_attack,\n        }\n    )\n\n    return df\n\n\ndef ols_solver(\n    df: pd.DataFrame, xy_columns: tuple[str] = (\"x_coordinate\", \"y_coordinate\")\n):\n    Y = -(df[xy_columns[0]] ** 2) - df[xy_columns[1]]\n    X = sm.add_constant(df.loc[:, xy_columns])\n\n    # regression\n    model = sm.OLS(Y, X)\n    results = model.fit()\n\n    # convert estimates to target params\n    x_hat = -results.params[xy_columns[0]] / 2\n    y_hat = -results.params[xy_columns[1]] / 2\n    r_hat_sqr = (x_hat**2 + y_hat**2 - results.params['const'])\n    r_hat = np.sqrt(r_hat_sqr) if r_hat_sqr &gt; 0 else np.nan\n\n    return [x_hat, y_hat, r_hat]\n\n\ndef estimator_simulator(func, noise: float = 1.0, iter: int = 1000):\n    res = list(map(lambda x: func(gpd_dataframe(0, 0, noise)), range(iter)))\n    return np.array(res)\n\nfig, ax = plt.subplots(1, 2)\n\nols_res = estimator_simulator(ols_solver)\nsns.kdeplot(x=ols_res[:, 0], y=ols_res[:, 1], cmap=\"Blues\", fill=True, ax=ax[0])\nsns.kdeplot(x=ols_res[:, 2], cmap=\"Blues\", fill=True, ax=ax[1])\n\n# Show the plot\nax[0].set_xlabel(\"estimated x coordinate\")\nax[0].set_ylabel(\"estimated y coordinate\")\nax[0].set_aspect('equal')\nax[0].set_title(\"OLS 2D Density Plot\\nwith 1000 iterations\")\nax[1].set_title(\"Raidus Density Plot\\nwith 1000 iterations\")\nplt.show()\n\n\n\n\n\n\n\n\n\nそもそも \\(r_i = 20 + \\epsilon_i\\) と決定されていますが\n\\[\n\\beta_0 = a^2 + b^2 - (r + \\epsilon_i)^2\n\\]\nで決定されており，これを踏まえて OLSのモデルを見てみると\n\\[\nz_i = \\left(a^2 + b^2 - r^2 - \\epsilon_i^2 - 2r\\epsilon \\right) - 2ax_i - 2by_i\n\\]\nとなるので，そもそもunbiasedな推定量になっていないと判断できます\n ▶  Regression with MLE\n\\(\\eqref{#eq-circle}\\) に則り，もっと直接的に\n\\[\nL(\\beta) = (\\sqrt{(x_i - \\beta_1)^2 + (y_i - \\beta_2)^2} - \\beta_0)^2\n\\]\nを最小する形でパラメーターを推定してみます．このとき．residualが\\(N(0, \\sigma)\\) に従うならばLikelihoodは\n\\[\nf(X_i\\vert \\beta, \\sigma) = \\frac{1}{\\sqrt{2\\pi}\\sigma}\\exp\\left(-\\frac{L(\\beta)}{2\\sigma^2}\\right)\n\\]\nと表せるので，これを用いて解いてみます．\n\n\nCode\nimport numpy as np\nfrom scipy.optimize import minimize\n\n\ndef lik(parameters, x, y):\n    x_0 = parameters[0]\n    y_0 = parameters[1]\n    r_0 = parameters[2]\n    sigma = parameters[3]\n    g_x = (np.sqrt((np.sqrt((x - x_0) ** 2 + (y - y_0) ** 2) - r_0)**2)) ** 2\n\n    L = len(x) / 2 * np.log(sigma**2) +  1 / (2 * sigma**2) * np.sum(g_x)\n    return L\n\n\ndef mle_solver(\n    df: pd.DataFrame, xy_columns: tuple[str] = (\"x_coordinate\", \"y_coordinate\")\n):\n\n    x_attack = df[xy_columns[0]].values\n    y_attack = df[xy_columns[1]].values\n    lik_model = minimize(\n        lambda params: lik(params, x_attack, y_attack),\n        np.array([1, 1, 20, 1]),\n        method=\"L-BFGS-B\",\n    )\n    return lik_model[\"x\"]\n\n\nmle_res = estimator_simulator(mle_solver)\n\n# plot\nfig, axes= plt.subplots(1, 2)\n\nsns.kdeplot(x=mle_res[:, 0], y=mle_res[:, 1], cmap=\"Blues\", fill=True, ax=axes[0])\nsns.kdeplot(x=mle_res[:, 2], cmap=\"Blues\", fill=True, ax=axes[1])\n\n# Show the plot\naxes[0].set_xlabel(\"estimated x coordinate\")\naxes[0].set_ylabel(\"estimated y coordinate\")\naxes[0].set_title(\"MLE 2D Density Plot\\nwith 1000 iterations\")\naxes[0].set_aspect(\"equal\")\naxes[1].set_title(\"Raidus Density Plot\\nwith 1000 iterations\")\n\nplt.show()\n\n\n\n\n\n\n\n\n\n定式化は正しいはずですが，\\((x_0, y_0, r_0)\\) は効率的な推定量となっていない疑いがあることが読み取れます．\n次に，\n\\[\nL(\\beta) = \\sqrt{(x_i - \\beta_1)^2 + (y_i - \\beta_2)^2 - \\beta_0^2} \\label{#eq-mle}\n\\]\nをLoss functionとして推定してみます．\n\n\nCode\nimport numpy as np\nfrom scipy.optimize import minimize\n\n\ndef lik(parameters, x, y):\n    x_0 = parameters[0]\n    y_0 = parameters[1]\n    r_0 = parameters[2]\n    sigma = parameters[3]\n    g_x = (x - x_0) ** 2 + (y - y_0) ** 2 - r_0**2\n\n    L = len(x) / 2 * np.log(sigma**2) +  1 / (2 * sigma**2) * np.sum(g_x)\n    return L\n\n\ndef mle_solver(\n    df: pd.DataFrame, xy_columns: tuple[str] = (\"x_coordinate\", \"y_coordinate\")\n):\n\n    x_attack = df[xy_columns[0]].values\n    y_attack = df[xy_columns[1]].values\n    lik_model = minimize(\n        lambda params: lik(params, x_attack, y_attack),\n        np.array([1, 1, 20, 1]),\n        method=\"L-BFGS-B\",\n    )\n    return lik_model[\"x\"]\n\n\nmle_res = estimator_simulator(mle_solver)\n\n# plot\nfig, axes= plt.subplots(1, 2)\n\nsns.kdeplot(x=mle_res[:, 0], y=mle_res[:, 1], cmap=\"Blues\", fill=True, ax=axes[0])\nsns.kdeplot(x=mle_res[:, 2], cmap=\"Blues\", fill=True, ax=axes[1])\n\n# Show the plot\naxes[0].set_xlabel(\"estimated x coordinate\")\naxes[0].set_ylabel(\"estimated y coordinate\")\naxes[0].set_title(\"MLE 2D Density Plot\\nwith 1000 iterations\")\naxes[0].set_aspect(\"equal\")\naxes[1].set_title(\"Raidus Density Plot\\nwith 1000 iterations\")\n\nplt.show()\n\n\n\n\n\n\n\n\n\n先程よりは精度良く推定できているように見えますが，\\(\\eqref{#eq-mle}\\) は\n\\[\nL(\\beta) = \\sqrt{\\epsilon_i^2 + 2\\beta_0 \\epsilon_i}\n\\]\nとなるので，そもそもMLEの定式化が間違っていることがわかります．また，\\(\\beta_0\\) が大きいほどresidualが大きくなる傾向があることから，unbiasedな推定量は得られていないことがわかります．\n ▶  Regression with stan\ncmdstanを用いて砲台座標を推定する例を紹介します．まずstan modelを以下のように設定します．\n\n砲撃距離のノイズについて \\(N(0, 1)\\) であることが既にわかっている状況を想定\n予定砲撃距離 \\(r_0\\) は \\(\\operatorname{Uniform}(2, 30)\\) の事前分布がある\n\ndata {\n    int&lt;lower=1&gt; N;  // Number of data points\n    array[N] real y; // outcomes\n    array[N] real x; // outcomes\n}\n\nparameters {\n    real&lt;lower=0&gt; r_0; // probability of success\n    real x_0;             // Center x-coordinate\n    real y_0;             // Center y-coordinate\n}\n\nmodel {\n    // priors\n    r_0 ~ uniform(2, 30);\n    real sigma = 1;\n\n    // objective loss\n    array[N] real circle_equation;\n    for (i in 1:N) {\n        circle_equation[i] = sqrt((x[i] - x_0)^2 + (y[i] - y_0)^2) - r_0;\n    }\n\n    circle_equation ~ normal(0, sigma);\n}\nその後，このモデルを用いて推定したものが以下となります．\n\nfrom cmdstanpy import CmdStanModel\n\ndf_stan = gpd_dataframe(0, 0, 1)\ndata = {\n    \"N\": df_stan.shape[0],\n    \"y\": df_stan.y_coordinate.values,\n    \"x\": df_stan.x_coordinate.values,\n    \"sigma\": 1,\n}\n\nmodel = CmdStanModel(stan_file=\"./stanmodel.stan\")\nfit = model.sample(data=data, seed=42)\nfit.summary()\n\n14:28:02 - cmdstanpy - INFO - compiling stan file /home/runner/work/regmonkey-datascience-blog/regmonkey-datascience-blog/posts/2025-03-02-find-coordinates/stanmodel.stan to exe file /home/runner/work/regmonkey-datascience-blog/regmonkey-datascience-blog/posts/2025-03-02-find-coordinates/stanmodel\n14:28:10 - cmdstanpy - INFO - compiled model executable: /home/runner/work/regmonkey-datascience-blog/regmonkey-datascience-blog/posts/2025-03-02-find-coordinates/stanmodel\n14:28:10 - cmdstanpy - INFO - CmdStan start processing\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n                                                                                                                                                                                                                                                                                                                                \n\n\n14:28:11 - cmdstanpy - INFO - CmdStan done processing.\n14:28:11 - cmdstanpy - WARNING - Some chains may have failed to converge.\n    Chain 1 had 310 divergent transitions (31.0%)\n    Chain 2 had 341 divergent transitions (34.1%)\n    Chain 3 had 293 divergent transitions (29.3%)\n    Chain 4 had 321 divergent transitions (32.1%)\n    Use the \"diagnose()\" method on the CmdStanMCMC object to see further information.\n\n\n\n\n\n\n\n\n\n\n\n\nMean\nMCSE\nStdDev\nMAD\n5%\n50%\n95%\nESS_bulk\nESS_tail\nR_hat\n\n\n\n\nlp__\n-22.627700\n0.044143\n1.21901\n0.873029\n-25.04740\n-22.267300\n-21.44630\n886.927\n1292.320\n1.00150\n\n\nr_0\n20.167700\n0.429917\n6.21166\n7.274600\n9.15979\n20.889900\n29.01690\n208.132\n258.641\n1.01910\n\n\nx_0\n0.151580\n0.131551\n1.88887\n1.973310\n-3.05708\n0.195963\n3.10467\n199.726\n234.533\n1.02554\n\n\ny_0\n-0.299075\n0.419656\n6.11452\n7.154340\n-8.93022\n-1.015920\n10.49850\n220.609\n278.533\n1.01959\n\n\n\n\n\n\n\nCredible intervalを見ると \\((0, 0)\\) は推定区間に含まれている一方，Mean, Medianともに \\(y_0\\) の方は乖離した値が推定されてしまっています．"
  },
  {
    "objectID": "posts/2024-12-16-ssh-to-macos/index.html",
    "href": "posts/2024-12-16-ssh-to-macos/index.html",
    "title": "macOSへのssh接続",
    "section": "",
    "text": "同じprivate networkに属しているmacOS端末に対して公開鍵認証を用いてssh接続したい\n\n同じprovate networkに属している前提の端末へのsshになるので\nssh hoshinokirby@192.168.10.110\nのように自宅内のネットワークのみで有効なプライベートIPアドレス（クラスC 192.168.0.0 ~ 192.168.255.255）を指定してアクセスすることを想定しています．"
  },
  {
    "objectID": "posts/2024-12-16-ssh-to-macos/index.html#what-we-want-to-do",
    "href": "posts/2024-12-16-ssh-to-macos/index.html#what-we-want-to-do",
    "title": "macOSへのssh接続",
    "section": "",
    "text": "同じprivate networkに属しているmacOS端末に対して公開鍵認証を用いてssh接続したい\n\n同じprovate networkに属している前提の端末へのsshになるので\nssh hoshinokirby@192.168.10.110\nのように自宅内のネットワークのみで有効なプライベートIPアドレス（クラスC 192.168.0.0 ~ 192.168.255.255）を指定してアクセスすることを想定しています．"
  },
  {
    "objectID": "posts/2024-12-16-ssh-to-macos/index.html#how-to-set-up",
    "href": "posts/2024-12-16-ssh-to-macos/index.html#how-to-set-up",
    "title": "macOSへのssh接続",
    "section": "How to set up",
    "text": "How to set up\n ▶  Server側\nSSHサーバー側はopenssh-serverなりssh serverが動いている必要があります．\n\nSystem Preferences &gt; Sharingをクリック\nRemote Loginを有効化\n\n以上の2ステップで，macOS側のSSH serverをactive状態にすることができます．\n ▶  Client側\nパスワード認証の場合は\n\narpコマンドでアクセス先端末のプライベートIPアドレスを検索\nsshコマンドでアクセス\n\nで完了となりますが，今回は公開鍵認証手順を紹介します．公開鍵認証の場合は\n\nSSH Key Pair の作成\n公開鍵の登録(接続先のauthorized_keysファイル（~/.ssh/authorized_keys）に追加)\nsshコマンドでアクセスとなります\n\n\n\nSSH Key Pair の作成\n\nssh-keygen -t rsa -b 4096 -f ~/.ssh/pupupu_land\n\n\n-t rsa: key typeの指定\n-b 4096: key lengthの指定(長いほどsecurity強固になる)\n-f  ~/.ssh/pupupu_land: key pairの生成先とファイル名（今回はpupupu_land, pupupu_land.pubが生成される）\n\n\n\n公開鍵の登録\n\nssh-copy-id -i ~/.ssh/pupupu_land.pub username@&lt;target-ip&gt;\n\n\n-i ~/.ssh/pupupu_land.pub: コピーする公開鍵ファイルを指定\n\n公開鍵を登録するには，\n\n公開鍵のファイルをコピー\n接続先のauthorized_keysファイル（~/.ssh/authorized_keys）に追加\nauthorized_keysファイルがない場合は作成後に適切なパーミッションを設定\n\nが必要となりますが，ssh-copy-idコマンドですべて自動実行することができるというメリットがあります．\n ▶  ssh connection\n上記の設定後，sshコマンド実行することで，macOSへアクセスすることができます． 毎回プライベートIPアドレスを調べるのが億劫な場合，デバイスのMACアドレスがわかればarpコマンドで以下のように検索することもできます．\narp -a | grep &lt;MAC-address&gt; | awk -F'[()]' '{print $2}'"
  },
  {
    "objectID": "posts/2025-03-01-herons-formula/index.html",
    "href": "posts/2025-03-01-herons-formula/index.html",
    "title": "ヘロンの公式の導出",
    "section": "",
    "text": "Theorem 1 : ヘロンの公式 \n\\(\\triangle ABC\\) の3辺の長さがそれぞれ \\(a, b, c\\) で与えられているとき，\n\\[\ns = \\frac{1}{2}(a + b + c)\n\\]\nとおくと，\\(\\triangle ABC\\) の面積 \\(S\\) は\n\\[\nS = \\sqrt{s(s-a)(s-b)(s-c)}\n\\]\n\n\n\n\n\n\n\n\n\n余弦定理を用いた証明\n\n\n\n\n\n3辺の長さがわかっているので，余弦定理より\n\\[\n\\begin{align}\na^2 &= b^2 + c^2 - 2bc\\cos A\\\\\n\\Rightarrow &\\cos A = \\frac{b^2+c^2-a^2}{2bc}\n\\end{align}\n\\]\n\\(\\sin^2 A + \\cos^2 A = 1\\) より\n\\[\n\\sin A = \\sqrt{1 - \\cos^2 A}\n\\]\n従って，面積 \\(S\\) は\n\\[\nS = \\frac{1}{2}bc\\sqrt{1 - \\cos^2 A}\n\\]\nこれを展開すると\n\\[\n\\begin{align}\nS\n    &= \\frac{1}{2}bc\\sqrt{1 - \\cos^2 A}\\\\\n    &= \\frac{1}{2}bc\\sqrt{1 - \\frac{(b^2+c^2-a^2)^2}{4b^2c^2}}\\\\\n    &= \\frac{1}{2}\\sqrt{b^2c^2 - \\left(\\frac{(b^2+c^2-a^2)}{2}\\right)^2}\\\\\n    &= \\frac{1}{2}\\sqrt{\\left(-\\frac{b^2+c^2-a^2-2bc}{2}\\right)\\left(\\frac{b^2+c^2-a^2+2bc}{2}\\right)}\\\\\n    &= \\frac{1}{2}\\sqrt{\\left(-\\frac{(b-c)^2-a^2}{2}\\right)\\left(\\frac{(b+c)^2-a^2}{2}\\right)}\\\\\n    &= \\frac{1}{2}\\sqrt{\\frac{(a+b-c)(a+c-b)}{2}\\frac{(a+b+c)(b+c-a)}{2}}\\\\\n    &= \\sqrt{\\frac{(a+b-c)}{2}\\frac{(a+c-b)}{2}\\frac{(a+b+c)}{2}\\frac{(b+c-a)}{2}}\\\\\n    &= \\sqrt{s(s-a)(s-b)(s-c)}\n\\end{align}\n\\]\n\n\n\n\n\n\n\n\n\n\n三角形の傍接円からのヘロンの公式\n\n\n\n\n\n下記のように \\(\\triangle ABC\\) について内心 \\(D\\) と傍心 \\(G\\) を考えます．\n\n前準備として \\(\\triangle ABC\\) のそれぞれの角の対辺を \\(a, b, c\\) として\n\\[\ns = \\frac{1}{2}(a + b + c)\n\\]\nと変数 \\(s\\) を定義します．また，内接円の性質（各頂点の内角の二等分線上に内心が存在）より\n\\[\n\\begin{align}\nAH &= AN\\\\\nCN &= CI\\\\\nBH &= BI\n\\end{align}\n\\]\n従って，\n\\[\n\\begin{align}\nAH &= s - a\\\\\nBH &= s - b\\\\\nCN &= s = c\n\\end{align}\n\\]\n傍接円の傍心 \\(G\\) は\n\n\\(\\angle A\\) の二等分線上\n\\(B\\) と \\(C\\)の外角の二等分線上\n\nに存在することから\n\\[\nAL = AE\n\\]\nまた，\n\\[\n\\begin{align}\nAL + AE\n    &= (AC + CL) + (AB + BE)\\\\\n    &= (AC + CO) + (AB + BO)\\\\\n    &=  a + b + c\\\\\n    &= 2s\n\\end{align}\n\\]\n従って，\n\\[\nAL = AE = s\n\\]\n内接円の内心 \\(D\\) が \\(\\angle B, \\angle C\\) の二等分線上に存在するので\n\\[\n\\begin{align}\n180^\\circ\n    &= 2\\angle HBD + 2\\angle EBG\\\\\n\\Rightarrow & 90^\\circ = \\angle HBD + \\angle EBG\n\\end{align}\n\\]\n従って，\n\\[\n\\begin{align}\n\\angle BDH &= \\angle EBG\n\\angle HBD &= \\angle BGE\n\\end{align}\n\\]\nここから\n\\[\n\\triangle HBD \\sim \\triangle EGB\n\\]\nこれより\n\\[\n\\frac{s - b}{r_1}=\\frac{r_2}{s - c}\n\\]\nこれを整理すると\n\\[\nr_1r_2 = (s-b)(s-c) \\label{#eq-1}\n\\]\nまた，\\(\\triangle HDE\\) と \\(\\triangle HDO\\) の面積が等しいことから\n\\[\nsr_1 = (s-a)r_2  \\label{#eq-2}\n\\]\n\\(\\eqref{#eq-1}\\), \\(\\eqref{#eq-2}\\) を 掛け合わせて \\(r_2\\) を両辺から除して \\(s\\) を両辺にかけると\n\\[\ns^2r_1^2 = s(s-a)(s-b)(s-c)\n\\]\n従って\n\\[\nsr_1 = \\sqrt{s(s-a)(s-b)(s-c)}\n\\]\nLHSは \\(\\triangle ABC\\) の面積と一致するので，これでヘロンの公式が示された．"
  },
  {
    "objectID": "posts/2025-03-01-herons-formula/index.html#辺から三角形の面積を求める",
    "href": "posts/2025-03-01-herons-formula/index.html#辺から三角形の面積を求める",
    "title": "ヘロンの公式の導出",
    "section": "",
    "text": "Theorem 1 : ヘロンの公式 \n\\(\\triangle ABC\\) の3辺の長さがそれぞれ \\(a, b, c\\) で与えられているとき，\n\\[\ns = \\frac{1}{2}(a + b + c)\n\\]\nとおくと，\\(\\triangle ABC\\) の面積 \\(S\\) は\n\\[\nS = \\sqrt{s(s-a)(s-b)(s-c)}\n\\]\n\n\n\n\n\n\n\n\n\n余弦定理を用いた証明\n\n\n\n\n\n3辺の長さがわかっているので，余弦定理より\n\\[\n\\begin{align}\na^2 &= b^2 + c^2 - 2bc\\cos A\\\\\n\\Rightarrow &\\cos A = \\frac{b^2+c^2-a^2}{2bc}\n\\end{align}\n\\]\n\\(\\sin^2 A + \\cos^2 A = 1\\) より\n\\[\n\\sin A = \\sqrt{1 - \\cos^2 A}\n\\]\n従って，面積 \\(S\\) は\n\\[\nS = \\frac{1}{2}bc\\sqrt{1 - \\cos^2 A}\n\\]\nこれを展開すると\n\\[\n\\begin{align}\nS\n    &= \\frac{1}{2}bc\\sqrt{1 - \\cos^2 A}\\\\\n    &= \\frac{1}{2}bc\\sqrt{1 - \\frac{(b^2+c^2-a^2)^2}{4b^2c^2}}\\\\\n    &= \\frac{1}{2}\\sqrt{b^2c^2 - \\left(\\frac{(b^2+c^2-a^2)}{2}\\right)^2}\\\\\n    &= \\frac{1}{2}\\sqrt{\\left(-\\frac{b^2+c^2-a^2-2bc}{2}\\right)\\left(\\frac{b^2+c^2-a^2+2bc}{2}\\right)}\\\\\n    &= \\frac{1}{2}\\sqrt{\\left(-\\frac{(b-c)^2-a^2}{2}\\right)\\left(\\frac{(b+c)^2-a^2}{2}\\right)}\\\\\n    &= \\frac{1}{2}\\sqrt{\\frac{(a+b-c)(a+c-b)}{2}\\frac{(a+b+c)(b+c-a)}{2}}\\\\\n    &= \\sqrt{\\frac{(a+b-c)}{2}\\frac{(a+c-b)}{2}\\frac{(a+b+c)}{2}\\frac{(b+c-a)}{2}}\\\\\n    &= \\sqrt{s(s-a)(s-b)(s-c)}\n\\end{align}\n\\]\n\n\n\n\n\n\n\n\n\n\n三角形の傍接円からのヘロンの公式\n\n\n\n\n\n下記のように \\(\\triangle ABC\\) について内心 \\(D\\) と傍心 \\(G\\) を考えます．\n\n前準備として \\(\\triangle ABC\\) のそれぞれの角の対辺を \\(a, b, c\\) として\n\\[\ns = \\frac{1}{2}(a + b + c)\n\\]\nと変数 \\(s\\) を定義します．また，内接円の性質（各頂点の内角の二等分線上に内心が存在）より\n\\[\n\\begin{align}\nAH &= AN\\\\\nCN &= CI\\\\\nBH &= BI\n\\end{align}\n\\]\n従って，\n\\[\n\\begin{align}\nAH &= s - a\\\\\nBH &= s - b\\\\\nCN &= s = c\n\\end{align}\n\\]\n傍接円の傍心 \\(G\\) は\n\n\\(\\angle A\\) の二等分線上\n\\(B\\) と \\(C\\)の外角の二等分線上\n\nに存在することから\n\\[\nAL = AE\n\\]\nまた，\n\\[\n\\begin{align}\nAL + AE\n    &= (AC + CL) + (AB + BE)\\\\\n    &= (AC + CO) + (AB + BO)\\\\\n    &=  a + b + c\\\\\n    &= 2s\n\\end{align}\n\\]\n従って，\n\\[\nAL = AE = s\n\\]\n内接円の内心 \\(D\\) が \\(\\angle B, \\angle C\\) の二等分線上に存在するので\n\\[\n\\begin{align}\n180^\\circ\n    &= 2\\angle HBD + 2\\angle EBG\\\\\n\\Rightarrow & 90^\\circ = \\angle HBD + \\angle EBG\n\\end{align}\n\\]\n従って，\n\\[\n\\begin{align}\n\\angle BDH &= \\angle EBG\n\\angle HBD &= \\angle BGE\n\\end{align}\n\\]\nここから\n\\[\n\\triangle HBD \\sim \\triangle EGB\n\\]\nこれより\n\\[\n\\frac{s - b}{r_1}=\\frac{r_2}{s - c}\n\\]\nこれを整理すると\n\\[\nr_1r_2 = (s-b)(s-c) \\label{#eq-1}\n\\]\nまた，\\(\\triangle HDE\\) と \\(\\triangle HDO\\) の面積が等しいことから\n\\[\nsr_1 = (s-a)r_2  \\label{#eq-2}\n\\]\n\\(\\eqref{#eq-1}\\), \\(\\eqref{#eq-2}\\) を 掛け合わせて \\(r_2\\) を両辺から除して \\(s\\) を両辺にかけると\n\\[\ns^2r_1^2 = s(s-a)(s-b)(s-c)\n\\]\n従って\n\\[\nsr_1 = \\sqrt{s(s-a)(s-b)(s-c)}\n\\]\nLHSは \\(\\triangle ABC\\) の面積と一致するので，これでヘロンの公式が示された．"
  },
  {
    "objectID": "posts/2025-01-08-bigquery-preprocess-01/index.html",
    "href": "posts/2025-01-08-bigquery-preprocess-01/index.html",
    "title": "BigQuery: TIME型カラムを指定したレベルで丸めて集計する",
    "section": "",
    "text": "▶  スーパーの来店時刻データ\n\n\n\nmember_id\nusage_date\nusage_time\n\n\n\n\n\n123456\n2024-02-01\n08:09:00\n\n\n\n223456\n2024-02-01\n08:10:00\n\n\n\n223456\n2024-02-11\n08:10:00\n\n\n\n123456\n2024-02-01\n20:09:00\n\n\n\n323456\n2024-02-01\n20:09:00\n\n\n\n\nという形でとあるスーパーの来店時刻データregmonkey-sample-data.restaurant_kawasaki.customer_recordが与えられているとします． このとき，以下の3つの処理を実施して，曜日×時間帯別平均来店者数の集計を行いたいとします．\n ▶  処理1: 24時間オーバーのデータへ変換\n\n00:01:00 → 24:00:00\n01:01:59 → 25:00:00\n\nのように夜中02:59:59までは26:59:59へ変換するという処理\n ▶  処理2: TIME型データを丸める\n\n08:09:00 → 08:00:00\n08:20:00 → 08:15:00\n\nのようにTIME型データを15分刻みに丸める処理\n ▶  処理3: DATE型データをISO day of weekへ変換\n\n月曜日を1, 日曜日を7とするISO day of weekに変換する\n祝日は8をアサインする\n\n2024-02-11, 2024-02-23は8がアサインされる"
  },
  {
    "objectID": "posts/2025-01-08-bigquery-preprocess-01/index.html#what-i-want-to-do",
    "href": "posts/2025-01-08-bigquery-preprocess-01/index.html#what-i-want-to-do",
    "title": "BigQuery: TIME型カラムを指定したレベルで丸めて集計する",
    "section": "",
    "text": "▶  スーパーの来店時刻データ\n\n\n\nmember_id\nusage_date\nusage_time\n\n\n\n\n\n123456\n2024-02-01\n08:09:00\n\n\n\n223456\n2024-02-01\n08:10:00\n\n\n\n223456\n2024-02-11\n08:10:00\n\n\n\n123456\n2024-02-01\n20:09:00\n\n\n\n323456\n2024-02-01\n20:09:00\n\n\n\n\nという形でとあるスーパーの来店時刻データregmonkey-sample-data.restaurant_kawasaki.customer_recordが与えられているとします． このとき，以下の3つの処理を実施して，曜日×時間帯別平均来店者数の集計を行いたいとします．\n ▶  処理1: 24時間オーバーのデータへ変換\n\n00:01:00 → 24:00:00\n01:01:59 → 25:00:00\n\nのように夜中02:59:59までは26:59:59へ変換するという処理\n ▶  処理2: TIME型データを丸める\n\n08:09:00 → 08:00:00\n08:20:00 → 08:15:00\n\nのようにTIME型データを15分刻みに丸める処理\n ▶  処理3: DATE型データをISO day of weekへ変換\n\n月曜日を1, 日曜日を7とするISO day of weekに変換する\n祝日は8をアサインする\n\n2024-02-11, 2024-02-23は8がアサインされる"
  },
  {
    "objectID": "posts/2025-01-08-bigquery-preprocess-01/index.html#query-example",
    "href": "posts/2025-01-08-bigquery-preprocess-01/index.html#query-example",
    "title": "BigQuery: TIME型カラムを指定したレベルで丸めて集計する",
    "section": "Query Example",
    "text": "Query Example\n ▶  処理1: 24時間オーバーのデータへ変換\nTIME型のままでは23:59:59までしかカバーされないので，extended timeの表記を試みたい場合はSTRING型へ変換する必要があります．\nCREATE TEMP FUNCTION convert_extended_time(standard_time TIME)\nRETURNS STRING\nAS (\n  CASE \n    WHEN EXTRACT(HOUR FROM standard_time) &lt; 3 THEN\n      FORMAT(\"%02d:%02d:%02d\", EXTRACT(HOUR FROM standard_time) + 24, EXTRACT(MINUTE FROM standard_time), EXTRACT(SECOND FROM standard_time))\n    ELSE \n      FORMAT(\"%02d:%02d:%02d\", EXTRACT(HOUR FROM standard_time), EXTRACT(MINUTE FROM standard_time), EXTRACT(SECOND FROM standard_time))\n  END\n);\n ▶  処理2: TIME型データを丸める\nCREATE TEMP FUNCTION round_to_nearest_15_minute(usage_time TIME, round_level INT64)\nRETURNS TIME\nAS (\n  TIME_TRUNC(\n    TIME_SUB(usage_time, INTERVAL MOD(EXTRACT(MINUTE FROM usage_time), round_level) MINUTE),\n    MINUTE\n  )\n);\n ▶  処理3: DATE型データをISO day of weekへ変換\nBigQueryが提供する EXTRACT(DAYOFWEEK FROM &lt;date-column&gt;) は日曜日1から始まり土曜日7で終わる形式となっているので自分で以下のように関数をUDFを定義することが必要になります．\nCREATE TEMP FUNCTION convert_iso_dayofweek(usage_date DATE)\nRETURNS INT64\nAS (\n  MOD(EXTRACT(DAYOFWEEK FROM usage_date) + 5, 7) + 1\n);\n ▶  データ抽出クエリ\nWITH\n  daily_summary AS(\n    SELECT \n        usage_date,\n        round_to_nearest_15_minute(usage_time, 15) AS rounded_usage_time,\n        CASE\n          WHEN usage_date in (DATE('2024-02-11'), DATE('2024-02-23')) THEN 8\n          ELSE convert_iso_dayofweek(usage_date) \n        END AS dayofweek,\n        COUNT(1) AS customer_count\n    FROM \n        `regmonkey-sample-data.restaurant_kawasaki.customer_record`\n    GROUP BY\n        1, 2\n  )\nSELECT\n    dayofweek,\n    convert_extended_time(rounded_usage_time) AS rounded_usage_time,\n    AVG(customer_count) AS mean_customer_count\nFROM\n    daily_summary \nGROUP BY \n  1, 2\nORDER BY\n  1, 2;"
  },
  {
    "objectID": "posts/2025-04-07-inner-product/index.html",
    "href": "posts/2025-04-07-inner-product/index.html",
    "title": "ベクトル空間における内積",
    "section": "",
    "text": "\\(\\pmb{a}, \\pmb{b} \\in \\mathbb R^2\\) を空間内の２つのベクトルでいずれもゼロベクトルではないとします．原点 \\(O\\) を始点として\n\\[\n\\begin{gather}\n\\pmb{a} = \\overrightarrow{OA}\\\\\n\\pmb{b} = \\overrightarrow{OB}\n\\end{gather}\n\\]\nとなる点 \\(A, B\\) をとります．このとき，\n\\[\n\\theta = \\angle AOB\n\\]\nを ベクトル \\(\\pmb{a}, \\pmb{b}\\) の成す角 といいいます．ただし，\\(0 \\leq \\theta \\leq \\pi\\) とします．\n\n\nDefinition 1 : ベクトルの内積 \n\\[\n\\|\\pmb{a}\\|\\,\\|\\pmb{b}\\| \\cos \\theta\n\\]\nを \\(\\pmb{a}\\) と \\(\\pmb{b}\\) の内積，またはスカラー積といい，\\((\\pmb{a}, \\pmb{b})\\) や \\(\\pmb{a} \\cdot \\pmb{b}\\) で表す．\\(\\pmb{a}, \\pmb{b}\\) のいずれかがゼロベクトルの場合は\n\\[\n(\\pmb{a}, \\pmb{b}) = 0\n\\]\nとする．\n\n\n ▶  シュワルツの不等式\n内積の定義\n\\[\n(\\pmb{a}, \\pmb{b}) = \\|\\pmb{a}\\|\\,\\|\\pmb{b}\\| \\cos \\theta\n\\]\nより， \\(-1 \\leq \\cos\\theta \\leq 1\\) であるから\n\\[\n\\vert(\\pmb{a}, \\pmb{b})\\vert \\leq \\|\\pmb{a}\\|\\,\\|\\pmb{b}\\|\n\\]\nであることがわかります．証明は いろいろな三角不等式 &gt; シュワルツの不等式と三角不等式 を参考にしてください．\n ▶  直交(orthogonal)\nベクトル \\(\\pmb{a}, \\pmb{b}\\) の成す角が直角のとき，ベクトル \\(\\pmb{a}, \\pmb{b}\\) は直交すると呼びます．このとき，\\(\\cos\\theta = 0\\) であることから\n\\[\n\\pmb{a} \\perp \\pmb{b} \\Longleftrightarrow (\\pmb{a}, \\pmb{b}) = 0\n\\]\n ▶  ベクトルの角度と幾何学的理解\nベクトルの成す角の定義より\n\\[\n\\theta = \\arccos \\frac{(\\pmb a, \\pmb b)}{\\|\\pmb a\\|\\,\\|\\pmb b\\|}\n\\]\nこの定義が幾何学的に見て妥当なものかどうかを以下確認します．\nFigure 1 のように \\(\\pmb{a}, \\pmb{b}\\) を考えたとき，\\(\\pmb{b}\\) の先端から \\(\\pmb{a}\\) に対して垂線を下ろします．その足 \\(B'\\) のベクトルを \\(k\\pmb a\\) とおくと，２つのベクトルが直交 \\(\\displaystyle\\theta = \\frac{\\pi}{2}\\)するとき，その内積は \\(0\\) になることから\n\\[\n(\\pmb {b} - k\\pmb {a}, \\pmb {a}) = 0\n\\]\n内積演算の性質より\n\\[\n\\begin{align}\n&(\\pmb {a}, \\pmb {b}) = k \\|\\pmb {a}\\|^2\\\\\n&\\Rightarrow k = \\frac{(\\pmb {a}, \\pmb {b})}{\\|\\pmb {a}\\|^2} \\label{#eq-inner-angle}\n\\end{align}\n\\]\n\\(\\triangle BOB'\\) は直角三角形なので \\(\\angle BOB'\\) に対応する \\(\\cos \\theta\\) は\n\\[\n\\cos \\theta = \\frac{k\\|\\pmb a\\|}{\\|\\pmb b\\|}\n\\]\n\\(\\eqref{#eq-inner-angle}\\) をもちいると\n\\[\n\\begin{align}\n\\cos \\theta\n    &= \\frac{k\\|\\pmb a\\|}{\\|\\pmb b\\|}\\\\\n    &= \\frac{(\\pmb {a}, \\pmb {b})}{\\|\\pmb {a}\\|^2}\\frac{\\|\\pmb a\\|}{\\|\\pmb b\\|}\\\\\n    &= \\frac{(\\pmb {a}, \\pmb {b})}{\\|\\pmb a\\|\\,\\|\\pmb b\\|}\n\\end{align}\n\\]\nと整理することができ，これは Definition 1 と一致することがわかります．\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport matplotlib.patches as patches\nimport cmath\n\n\n# Define two vectors\nv0 = np.array([1, 0])\nv1 = np.array([3, 1])\nv2 = np.array([1, 3])\n\n# Calculate the angle using the dot product\ndot_product = np.dot(v1, v2)\nnorm_v1 = np.linalg.norm(v1)\nnorm_v2 = np.linalg.norm(v2)\ncos_theta_0 = np.dot(v0, v1) / (norm_v1)\ncos_theta = dot_product / (norm_v1 * norm_v2)\ntheta_rad_0 = np.arccos(cos_theta_0)\ntheta_rad = np.arccos(cos_theta)\ntheta_deg = np.degrees(theta_rad)\n\n# define projection of B into A\nv3 =  v1 * norm_v2 * cos_theta / norm_v1\n\n\n# Plot the vectors\nfig, ax = plt.subplots(figsize=(6,6))\nax.grid(True)\n\norigin = np.array([0, 0])\nax.quiver(*origin, *v1, color='r', scale=1, scale_units='xy', angles='xy')\nax.quiver(*origin, *v2, color='b', scale=1, scale_units='xy', angles='xy')\n\n# Add angle arc using a circle segment\nangle_range = np.linspace(np.arccos(cos_theta_0), theta_rad + np.arccos(cos_theta_0), 100)\narc_radius = 0.5\narc_x = arc_radius * np.cos(angle_range)\narc_y = arc_radius * np.sin(angle_range)\nax.plot(arc_x, arc_y, 'k--', linewidth=1)\nax.plot((v2[0], v3[0]), (v2[1], v3[1]), 'k--', linewidth=1)\n\n# add square box at B'\ntheta = np.angle(complex(v3[0], v3[1]))  # 60 degrees\northogonal_theta = theta + np.pi / 2  # 90° 直交\noffset = np.linalg.norm(v3)\nsize = 0.15\n# 直角マークの位置を作成（60°方向に少し移動 → 90°方向に正方形を描く）\nbase_x = offset * np.cos(theta)\nbase_y = offset * np.sin(theta)\nrect_dx = size * np.cos(orthogonal_theta)\nrect_dy = size * np.sin(orthogonal_theta)\n\n\n# 小さな直角マーク（平行四辺形を回転して表現）\nright_angle = patches.Polygon(\n    [\n        (base_x, base_y),\n        (base_x + rect_dx, base_y + rect_dy),\n        (\n            base_x + rect_dx + size * np.cos(theta),\n            base_y + rect_dy + size * np.sin(theta),\n        ),\n        (base_x + size * np.cos(theta), base_y + size * np.sin(theta)),\n    ],\n    closed=True,\n    edgecolor=\"black\",\n    facecolor=\"none\",\n)\n\nax.add_patch(right_angle)\n\n# Annotate angle\nax.text(np.median(arc_x), np.median(arc_y), f\"{theta_deg:.1f}°\", fontsize=12)\nax.text(*origin-0.1, f\"O\", fontsize=12)\nax.text(*v1, f\"A\", fontsize=12)\nax.text(*v2, f\"B\", fontsize=12)\nax.text(*v3*0.9, f\"B'\", fontsize=12)\n\n# Plot settings\nax.set_xlim(-1, 3.5)\nax.set_ylim(-1, 3.5)\nax.set_aspect('equal')\n\nax.set_title(\"Angle Between Vectors Using Inner Product\")\nax.set_xlabel(\"X\")\nax.set_ylabel(\"Y\")\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 1\n\n\n\n\n\nTheorem 1 \n２つのベクトル \\(\\pmb a, \\pmb b\\) の成分表示を \\(\\pmb a = (a_1, \\cdots, a_n), \\pmb b = (b_1, \\cdots, b_n)\\) とするとき\n\\[\n(\\pmb a, \\pmb b) = \\sum_{i=1}^n a_ib_i\n\\]\nが成り立つ．ただし，証明にあたってノルムの定義は与えられているものとする\n\\[\n\\|\\pmb a\\| = \\sqrt{a_1^2 + \\cdots + a_n^2}\n\\]\n\n\n\n\n\n\n\n\n\nProof\n\n\n\n\n\n\\(\\pmb a, \\pmb b\\) のなす角を \\(\\theta\\) とすると，余弦定理より\n\\[\n\\begin{align}\n\\|\\pmb a\\|^2 + \\|\\pmb b\\|^2 - \\|\\pmb a - \\pmb b\\|^2 = 2 \\|\\pmb a\\| \\, \\|\\pmb b\\| \\cos\\theta\n\\end{align}\n\\]\nノルムの定義より\n\\[\n\\begin{gather}\n\\|\\pmb a\\|^2 = a_1^2 + \\cdots + a_n^2\\\\\n\\|\\pmb b\\|^2 = b_1^2 + \\cdots + b_n^2\\\\\n\\|\\pmb a - \\pmb b\\|^2 = (a_1 - b_1)^2 + \\cdots + (a_n - b_n)^2\n\\end{gather}\n\\]\nまた，内積の定義より\n\\[\n\\|\\pmb a\\| \\, \\|\\pmb b\\| \\cos\\theta = \\|\\pmb a\\| \\, \\|\\pmb b\\|\\frac{(\\pmb a, \\pmb b)}{\\|\\pmb a\\| \\, \\|\\pmb b\\|} = (\\pmb a, \\pmb b)\n\\]\n従って，\n\\[\n\\begin{align}\n\\|\\pmb a\\|^2 + \\|\\pmb b\\|^2 - \\|\\pmb a - \\pmb b\\|^2\n    &= 2\\sum_i a_ib_i\\\\\n    &= 2(\\pmb a, \\pmb b)\n\\end{align}\n\\]\nよって，\n\\[\n(\\pmb a, \\pmb b) = \\sum_{i=1}^n a_ib_i\n\\]\n\n\n\n\n\n\\(\\mathbb R^n\\) の属する\\(n\\)次元実ベクトル \\(\\pmb a = (a_1, \\cdots, a_n)^T, \\pmb b = (b_1, \\cdots, b_n)^T\\) を考えます．この２つのベクトルの内積は上で確認したように\n\\[\n(\\pmb a, \\pmb b) = \\sum_{i=1}^n a_ib_i\n\\]\nとなります．ここで，\\(\\pmb a, \\pmb b\\) を \\((n \\times 1)\\) 行列とみなすと\n\\[\n(\\pmb a, \\pmb b) = \\pmb a^T\\pmb b\n\\]\nと一致します．ここから\\(n\\)次元実ベクトルの内積について次の演算性質を確認することができます．\n\n\nTheorem 2 \n\\(h, k \\in \\mathbb R\\) とすると\n\\[\n\\begin{align}\n\\text{対称性:} \\quad& (\\pmb a, \\pmb b)  = (\\pmb b, \\pmb a)\\\\\n\\text{線形性:} \\quad& (h\\pmb a + k\\pmb a^\\prime, \\pmb b)  = h(\\pmb a, \\pmb b) + k(\\pmb a^\\prime, \\pmb b)\\\\\n& (\\pmb a, h\\pmb b + k\\pmb b^\\prime)  = h(\\pmb a, \\pmb b) + k(\\pmb a, \\pmb b^\\prime)\\\\\n\\label{#eq-positivity}\\text{正値性:} \\quad& (\\pmb a, \\pmb a)  \\geq 0\n\\end{align}\n\\]\n\n\n\n\n\n\n\n\n\nProof\n\n\n\n\n\n ▶  対称性\n\\[\n\\begin{align}\n(\\pmb a, \\pmb b)\n    &= \\pmb a^T\\pmb b\\\\\n    &= (\\pmb a^T\\pmb b)^T\\\\\n    &= (\\pmb b^T\\pmb a)\\\\\n    &= (\\pmb b, \\pmb a)\n\\end{align}\n\\]\n ▶  線形性 \n\\[\n\\begin{align}\n(h\\pmb a + k\\pmb a^\\prime, \\pmb b)\n    &= (h\\pmb a + k\\pmb a^\\prime)^T\\pmb b\\\\\n    &= h\\pmb a^T \\pmb b + k{\\pmb a^\\prime}^T \\pmb b\\\\\n    &= h(\\pmb a^T \\pmb b) + k({\\pmb a^\\prime}^T \\pmb b)\\\\\n    &= h(\\pmb a, \\pmb b) + k(\\pmb a^\\prime, \\pmb b)\n\\end{align}\n\\]\n ▶  正値性\n\\[\n\\begin{align}\n(\\pmb a, \\pmb a)\n    &= \\pmb a^T\\pmb a\\\\\n    &= \\sum_i a_i^2\n\\end{align}\n\\]\n\\(a_i^2 \\geq 0 \\, (\\forall i \\in (1, \\cdots, n))\\) であるので \\((\\pmb a, \\pmb a) \\geq 0\\) が成立します．また等号成立条件は\n\\[\na_i^2 = 0 \\, (\\forall i \\in (1, \\cdots, n)) \\Leftrightarrow a_i = 0 \\, (\\forall i \\in (1, \\cdots, n))\n\\]\n従って，\n\\[\n(\\pmb a, \\pmb a) = 0 \\Leftrightarrow \\pmb a = \\pmb 0\n\\]\n\n\n\n\n\n\n\n\n\n🍵 計量ベクトル空間\n\n\n\n\n内積の定義されたベクトル空間を計量ベクトル空間といいます．\n\n\n\n\n\n\n\n\nDefinition 2 : ノルム \n計量ベクトル空間 \\(V\\) の任意のベクトル \\(\\pmb a\\) に対して，\\(\\sqrt{(\\pmb a, \\pmb a)}\\) をベクトル \\(\\pmb a\\) の長さ, またはL2ノルムといい，\\(\\|\\pmb a\\|\\) と表す．\n\n\n内積の正値性 \\(\\eqref{#eq-positivity}\\) より \\(\\|\\pmb a\\| \\geq 0\\) が成り立ち，長さ の概念（長さが負にならない）と対応していることがわかります．\n\n\nTheorem 3 \n計量ベクトル空間 \\(V\\) の内積と長さについて，\\(\\pmb a, \\pmb b \\in V, k\\in \\mathbb R\\) としたとき以下が成り立つ\n\\[\n\\begin{align}\n&\\|\\pmb a\\| \\geq 0\\\\\n&\\|k\\pmb a\\| = |k\\||\\pmb a\\|\\\\\n&(\\pmb a,\\pmb b) = \\frac{1}{2}\\{\\|\\pmb a + \\pmb b\\|^2 - \\|\\pmb a\\|^2 - \\|\\pmb b\\|^2\\} = \\frac{1}{2}\\{\\|\\pmb a\\|^2 + \\|\\pmb b\\|^2 - \\|\\pmb a - \\pmb b\\|^2 \\}\\\\\n&\\|\\pmb a + \\pmb b\\|^2 + \\|\\pmb a - \\pmb b\\|^2 = 2(\\|\\pmb a\\|^2 + \\|\\pmb b\\|^2)\n\\end{align}\n\\]\n\n\n\n\n\n\n\n\n\nProof\n\n\n\n\n\n ▶  \\(\\|k\\pmb a\\| = |k\\||\\pmb a\\|\\)\n\\[\n\\begin{align}\n\\|k\\pmb a\\|^2\n    &= (k\\pmb a, k\\pmb a)\\\\\n    &= k^2 (\\pmb a, \\pmb a)\\\\\n    &= k^2 \\|\\pmb a\\|^2\n\\end{align}\n\\]\n従って，\n\\[\n\\begin{align}\n\\|k\\pmb a\\|\n    &= \\sqrt{\\|k\\pmb a\\|^2}\\\\\n    &= \\sqrt{k^2 \\|\\pmb a\\|^2}\\\\\n    &= |k\\||\\pmb a\\|\n\\end{align}\n\\]\n ▶  \\((\\pmb a,\\pmb b) = \\frac{1}{2}\\{\\|\\pmb a + \\pmb b\\|^2 - \\|\\pmb a\\|^2 - \\|\\pmb b\\|^2\\}\\)\n\\[\n\\begin{align}\n\\|\\pmb a + \\pmb b\\|^2\n    &= (\\pmb a + \\pmb b, \\pmb a + \\pmb b)\\\\\n    &= (\\pmb a, \\pmb a) + 2(\\pmb a, \\pmb b) + (\\pmb b, \\pmb b)\\\\\n    &= \\|\\pmb a\\|^2 + \\|\\pmb b\\|^2 + 2(\\pmb a, \\pmb b)\n\\end{align}\n\\]\n従って，\n\\[\n(\\pmb a,\\pmb b) = \\frac{1}{2}\\{\\|\\pmb a + \\pmb b\\|^2 - \\|\\pmb a\\|^2 - \\|\\pmb b\\|^2\\}\n\\]\n ▶  \\((\\pmb a,\\pmb b) = \\frac{1}{2}\\{\\|\\pmb a\\|^2 + \\|\\pmb b\\|^2 - \\|\\pmb a - \\pmb b\\|^2 \\}\\)\n\\[\n\\begin{align}\n\\|\\pmb a - \\pmb b\\|^2\n    &= (\\pmb a - \\pmb b, \\pmb a - \\pmb b)\\\\\n    &= \\|\\pmb a\\|^2 + \\|\\pmb b\\|^2 -2(\\pmb a, \\pmb b)\n\\end{align}\n\\]\n従って，\n\\[\n(\\pmb a,\\pmb b) = \\frac{1}{2}\\{\\|\\pmb a\\|^2 + \\|\\pmb b\\|^2 - \\|\\pmb a - \\pmb b\\|^2 \\}\n\\]\n ▶  \\(\\|\\pmb a + \\pmb b\\|^2 + \\|\\pmb a - \\pmb b\\|^2 = 2(\\|\\pmb a\\|^2 + \\|\\pmb b\\|^2)\\)\n\\[\n\\begin{align}\n\\|\\pmb a + \\pmb b\\|^2 & = \\|\\pmb a\\|^2 + \\|\\pmb b\\|^2  + 2(\\pmb a, \\pmb b)\\\\\n\\|\\pmb a - \\pmb b\\|^2 & = \\|\\pmb a\\|^2 + \\|\\pmb b\\|^2 - 2(\\pmb a, \\pmb b)\n\\end{align}\n\\]\n両辺を足し合わせると\n\\[\n\\|\\pmb a + \\pmb b\\|^2 + \\|\\pmb a - \\pmb b\\|^2 = 2(\\|\\pmb a\\|^2 + \\|\\pmb b\\|^2)\n\\]\n\n\n\n ▶  ピタゴラスの定理\n\\(n\\) 次元実ベクトル空間 \\(V\\) に対して，\\(\\pmb a, \\pmb b \\in V\\) を考えます．\\(\\pmb a\\perp \\pmb b\\) が成立する場合，\n\\[\n\\begin{align}\n\\|\\pmb a + \\pmb b\\|^2\n    &= (\\pmb a + \\pmb b, \\pmb a + \\pmb b)\\\\\n    &= \\|\\pmb a\\|^2 + \\|\\pmb b\\|^2 + 2(\\pmb a, \\pmb b)\\\\\n    &= \\|\\pmb a\\|^2 + \\|\\pmb b\\|^2\n\\end{align}\n\\]\nこれは \\(\\pmb a\\perp \\pmb b \\Leftrightarrow (\\pmb a, \\pmb b) = 0\\) であることからわかります．\n ▶  一般化されたピタゴラスの定理\n\\(\\pmb a_1, \\cdots, \\pmb a_n \\in V\\) が互いに直交している場合，\n\\[\n\\|\\pmb a_1 + \\cdots + \\pmb a_n \\|^2 = \\|\\pmb a_1 \\|^2 + \\cdots + \\|\\pmb a_n \\|^2\n\\]"
  },
  {
    "objectID": "posts/2025-04-07-inner-product/index.html#ベクトルの成す角と内積",
    "href": "posts/2025-04-07-inner-product/index.html#ベクトルの成す角と内積",
    "title": "ベクトル空間における内積",
    "section": "",
    "text": "\\(\\pmb{a}, \\pmb{b} \\in \\mathbb R^2\\) を空間内の２つのベクトルでいずれもゼロベクトルではないとします．原点 \\(O\\) を始点として\n\\[\n\\begin{gather}\n\\pmb{a} = \\overrightarrow{OA}\\\\\n\\pmb{b} = \\overrightarrow{OB}\n\\end{gather}\n\\]\nとなる点 \\(A, B\\) をとります．このとき，\n\\[\n\\theta = \\angle AOB\n\\]\nを ベクトル \\(\\pmb{a}, \\pmb{b}\\) の成す角 といいいます．ただし，\\(0 \\leq \\theta \\leq \\pi\\) とします．\n\n\nDefinition 1 : ベクトルの内積 \n\\[\n\\|\\pmb{a}\\|\\,\\|\\pmb{b}\\| \\cos \\theta\n\\]\nを \\(\\pmb{a}\\) と \\(\\pmb{b}\\) の内積，またはスカラー積といい，\\((\\pmb{a}, \\pmb{b})\\) や \\(\\pmb{a} \\cdot \\pmb{b}\\) で表す．\\(\\pmb{a}, \\pmb{b}\\) のいずれかがゼロベクトルの場合は\n\\[\n(\\pmb{a}, \\pmb{b}) = 0\n\\]\nとする．\n\n\n ▶  シュワルツの不等式\n内積の定義\n\\[\n(\\pmb{a}, \\pmb{b}) = \\|\\pmb{a}\\|\\,\\|\\pmb{b}\\| \\cos \\theta\n\\]\nより， \\(-1 \\leq \\cos\\theta \\leq 1\\) であるから\n\\[\n\\vert(\\pmb{a}, \\pmb{b})\\vert \\leq \\|\\pmb{a}\\|\\,\\|\\pmb{b}\\|\n\\]\nであることがわかります．証明は いろいろな三角不等式 &gt; シュワルツの不等式と三角不等式 を参考にしてください．\n ▶  直交(orthogonal)\nベクトル \\(\\pmb{a}, \\pmb{b}\\) の成す角が直角のとき，ベクトル \\(\\pmb{a}, \\pmb{b}\\) は直交すると呼びます．このとき，\\(\\cos\\theta = 0\\) であることから\n\\[\n\\pmb{a} \\perp \\pmb{b} \\Longleftrightarrow (\\pmb{a}, \\pmb{b}) = 0\n\\]\n ▶  ベクトルの角度と幾何学的理解\nベクトルの成す角の定義より\n\\[\n\\theta = \\arccos \\frac{(\\pmb a, \\pmb b)}{\\|\\pmb a\\|\\,\\|\\pmb b\\|}\n\\]\nこの定義が幾何学的に見て妥当なものかどうかを以下確認します．\nFigure 1 のように \\(\\pmb{a}, \\pmb{b}\\) を考えたとき，\\(\\pmb{b}\\) の先端から \\(\\pmb{a}\\) に対して垂線を下ろします．その足 \\(B'\\) のベクトルを \\(k\\pmb a\\) とおくと，２つのベクトルが直交 \\(\\displaystyle\\theta = \\frac{\\pi}{2}\\)するとき，その内積は \\(0\\) になることから\n\\[\n(\\pmb {b} - k\\pmb {a}, \\pmb {a}) = 0\n\\]\n内積演算の性質より\n\\[\n\\begin{align}\n&(\\pmb {a}, \\pmb {b}) = k \\|\\pmb {a}\\|^2\\\\\n&\\Rightarrow k = \\frac{(\\pmb {a}, \\pmb {b})}{\\|\\pmb {a}\\|^2} \\label{#eq-inner-angle}\n\\end{align}\n\\]\n\\(\\triangle BOB'\\) は直角三角形なので \\(\\angle BOB'\\) に対応する \\(\\cos \\theta\\) は\n\\[\n\\cos \\theta = \\frac{k\\|\\pmb a\\|}{\\|\\pmb b\\|}\n\\]\n\\(\\eqref{#eq-inner-angle}\\) をもちいると\n\\[\n\\begin{align}\n\\cos \\theta\n    &= \\frac{k\\|\\pmb a\\|}{\\|\\pmb b\\|}\\\\\n    &= \\frac{(\\pmb {a}, \\pmb {b})}{\\|\\pmb {a}\\|^2}\\frac{\\|\\pmb a\\|}{\\|\\pmb b\\|}\\\\\n    &= \\frac{(\\pmb {a}, \\pmb {b})}{\\|\\pmb a\\|\\,\\|\\pmb b\\|}\n\\end{align}\n\\]\nと整理することができ，これは Definition 1 と一致することがわかります．\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport matplotlib.patches as patches\nimport cmath\n\n\n# Define two vectors\nv0 = np.array([1, 0])\nv1 = np.array([3, 1])\nv2 = np.array([1, 3])\n\n# Calculate the angle using the dot product\ndot_product = np.dot(v1, v2)\nnorm_v1 = np.linalg.norm(v1)\nnorm_v2 = np.linalg.norm(v2)\ncos_theta_0 = np.dot(v0, v1) / (norm_v1)\ncos_theta = dot_product / (norm_v1 * norm_v2)\ntheta_rad_0 = np.arccos(cos_theta_0)\ntheta_rad = np.arccos(cos_theta)\ntheta_deg = np.degrees(theta_rad)\n\n# define projection of B into A\nv3 =  v1 * norm_v2 * cos_theta / norm_v1\n\n\n# Plot the vectors\nfig, ax = plt.subplots(figsize=(6,6))\nax.grid(True)\n\norigin = np.array([0, 0])\nax.quiver(*origin, *v1, color='r', scale=1, scale_units='xy', angles='xy')\nax.quiver(*origin, *v2, color='b', scale=1, scale_units='xy', angles='xy')\n\n# Add angle arc using a circle segment\nangle_range = np.linspace(np.arccos(cos_theta_0), theta_rad + np.arccos(cos_theta_0), 100)\narc_radius = 0.5\narc_x = arc_radius * np.cos(angle_range)\narc_y = arc_radius * np.sin(angle_range)\nax.plot(arc_x, arc_y, 'k--', linewidth=1)\nax.plot((v2[0], v3[0]), (v2[1], v3[1]), 'k--', linewidth=1)\n\n# add square box at B'\ntheta = np.angle(complex(v3[0], v3[1]))  # 60 degrees\northogonal_theta = theta + np.pi / 2  # 90° 直交\noffset = np.linalg.norm(v3)\nsize = 0.15\n# 直角マークの位置を作成（60°方向に少し移動 → 90°方向に正方形を描く）\nbase_x = offset * np.cos(theta)\nbase_y = offset * np.sin(theta)\nrect_dx = size * np.cos(orthogonal_theta)\nrect_dy = size * np.sin(orthogonal_theta)\n\n\n# 小さな直角マーク（平行四辺形を回転して表現）\nright_angle = patches.Polygon(\n    [\n        (base_x, base_y),\n        (base_x + rect_dx, base_y + rect_dy),\n        (\n            base_x + rect_dx + size * np.cos(theta),\n            base_y + rect_dy + size * np.sin(theta),\n        ),\n        (base_x + size * np.cos(theta), base_y + size * np.sin(theta)),\n    ],\n    closed=True,\n    edgecolor=\"black\",\n    facecolor=\"none\",\n)\n\nax.add_patch(right_angle)\n\n# Annotate angle\nax.text(np.median(arc_x), np.median(arc_y), f\"{theta_deg:.1f}°\", fontsize=12)\nax.text(*origin-0.1, f\"O\", fontsize=12)\nax.text(*v1, f\"A\", fontsize=12)\nax.text(*v2, f\"B\", fontsize=12)\nax.text(*v3*0.9, f\"B'\", fontsize=12)\n\n# Plot settings\nax.set_xlim(-1, 3.5)\nax.set_ylim(-1, 3.5)\nax.set_aspect('equal')\n\nax.set_title(\"Angle Between Vectors Using Inner Product\")\nax.set_xlabel(\"X\")\nax.set_ylabel(\"Y\")\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 1\n\n\n\n\n\nTheorem 1 \n２つのベクトル \\(\\pmb a, \\pmb b\\) の成分表示を \\(\\pmb a = (a_1, \\cdots, a_n), \\pmb b = (b_1, \\cdots, b_n)\\) とするとき\n\\[\n(\\pmb a, \\pmb b) = \\sum_{i=1}^n a_ib_i\n\\]\nが成り立つ．ただし，証明にあたってノルムの定義は与えられているものとする\n\\[\n\\|\\pmb a\\| = \\sqrt{a_1^2 + \\cdots + a_n^2}\n\\]\n\n\n\n\n\n\n\n\n\nProof\n\n\n\n\n\n\\(\\pmb a, \\pmb b\\) のなす角を \\(\\theta\\) とすると，余弦定理より\n\\[\n\\begin{align}\n\\|\\pmb a\\|^2 + \\|\\pmb b\\|^2 - \\|\\pmb a - \\pmb b\\|^2 = 2 \\|\\pmb a\\| \\, \\|\\pmb b\\| \\cos\\theta\n\\end{align}\n\\]\nノルムの定義より\n\\[\n\\begin{gather}\n\\|\\pmb a\\|^2 = a_1^2 + \\cdots + a_n^2\\\\\n\\|\\pmb b\\|^2 = b_1^2 + \\cdots + b_n^2\\\\\n\\|\\pmb a - \\pmb b\\|^2 = (a_1 - b_1)^2 + \\cdots + (a_n - b_n)^2\n\\end{gather}\n\\]\nまた，内積の定義より\n\\[\n\\|\\pmb a\\| \\, \\|\\pmb b\\| \\cos\\theta = \\|\\pmb a\\| \\, \\|\\pmb b\\|\\frac{(\\pmb a, \\pmb b)}{\\|\\pmb a\\| \\, \\|\\pmb b\\|} = (\\pmb a, \\pmb b)\n\\]\n従って，\n\\[\n\\begin{align}\n\\|\\pmb a\\|^2 + \\|\\pmb b\\|^2 - \\|\\pmb a - \\pmb b\\|^2\n    &= 2\\sum_i a_ib_i\\\\\n    &= 2(\\pmb a, \\pmb b)\n\\end{align}\n\\]\nよって，\n\\[\n(\\pmb a, \\pmb b) = \\sum_{i=1}^n a_ib_i\n\\]\n\n\n\n\n\n\\(\\mathbb R^n\\) の属する\\(n\\)次元実ベクトル \\(\\pmb a = (a_1, \\cdots, a_n)^T, \\pmb b = (b_1, \\cdots, b_n)^T\\) を考えます．この２つのベクトルの内積は上で確認したように\n\\[\n(\\pmb a, \\pmb b) = \\sum_{i=1}^n a_ib_i\n\\]\nとなります．ここで，\\(\\pmb a, \\pmb b\\) を \\((n \\times 1)\\) 行列とみなすと\n\\[\n(\\pmb a, \\pmb b) = \\pmb a^T\\pmb b\n\\]\nと一致します．ここから\\(n\\)次元実ベクトルの内積について次の演算性質を確認することができます．\n\n\nTheorem 2 \n\\(h, k \\in \\mathbb R\\) とすると\n\\[\n\\begin{align}\n\\text{対称性:} \\quad& (\\pmb a, \\pmb b)  = (\\pmb b, \\pmb a)\\\\\n\\text{線形性:} \\quad& (h\\pmb a + k\\pmb a^\\prime, \\pmb b)  = h(\\pmb a, \\pmb b) + k(\\pmb a^\\prime, \\pmb b)\\\\\n& (\\pmb a, h\\pmb b + k\\pmb b^\\prime)  = h(\\pmb a, \\pmb b) + k(\\pmb a, \\pmb b^\\prime)\\\\\n\\label{#eq-positivity}\\text{正値性:} \\quad& (\\pmb a, \\pmb a)  \\geq 0\n\\end{align}\n\\]\n\n\n\n\n\n\n\n\n\nProof\n\n\n\n\n\n ▶  対称性\n\\[\n\\begin{align}\n(\\pmb a, \\pmb b)\n    &= \\pmb a^T\\pmb b\\\\\n    &= (\\pmb a^T\\pmb b)^T\\\\\n    &= (\\pmb b^T\\pmb a)\\\\\n    &= (\\pmb b, \\pmb a)\n\\end{align}\n\\]\n ▶  線形性 \n\\[\n\\begin{align}\n(h\\pmb a + k\\pmb a^\\prime, \\pmb b)\n    &= (h\\pmb a + k\\pmb a^\\prime)^T\\pmb b\\\\\n    &= h\\pmb a^T \\pmb b + k{\\pmb a^\\prime}^T \\pmb b\\\\\n    &= h(\\pmb a^T \\pmb b) + k({\\pmb a^\\prime}^T \\pmb b)\\\\\n    &= h(\\pmb a, \\pmb b) + k(\\pmb a^\\prime, \\pmb b)\n\\end{align}\n\\]\n ▶  正値性\n\\[\n\\begin{align}\n(\\pmb a, \\pmb a)\n    &= \\pmb a^T\\pmb a\\\\\n    &= \\sum_i a_i^2\n\\end{align}\n\\]\n\\(a_i^2 \\geq 0 \\, (\\forall i \\in (1, \\cdots, n))\\) であるので \\((\\pmb a, \\pmb a) \\geq 0\\) が成立します．また等号成立条件は\n\\[\na_i^2 = 0 \\, (\\forall i \\in (1, \\cdots, n)) \\Leftrightarrow a_i = 0 \\, (\\forall i \\in (1, \\cdots, n))\n\\]\n従って，\n\\[\n(\\pmb a, \\pmb a) = 0 \\Leftrightarrow \\pmb a = \\pmb 0\n\\]\n\n\n\n\n\n\n\n\n\n🍵 計量ベクトル空間\n\n\n\n\n内積の定義されたベクトル空間を計量ベクトル空間といいます．\n\n\n\n\n\n\n\n\nDefinition 2 : ノルム \n計量ベクトル空間 \\(V\\) の任意のベクトル \\(\\pmb a\\) に対して，\\(\\sqrt{(\\pmb a, \\pmb a)}\\) をベクトル \\(\\pmb a\\) の長さ, またはL2ノルムといい，\\(\\|\\pmb a\\|\\) と表す．\n\n\n内積の正値性 \\(\\eqref{#eq-positivity}\\) より \\(\\|\\pmb a\\| \\geq 0\\) が成り立ち，長さ の概念（長さが負にならない）と対応していることがわかります．\n\n\nTheorem 3 \n計量ベクトル空間 \\(V\\) の内積と長さについて，\\(\\pmb a, \\pmb b \\in V, k\\in \\mathbb R\\) としたとき以下が成り立つ\n\\[\n\\begin{align}\n&\\|\\pmb a\\| \\geq 0\\\\\n&\\|k\\pmb a\\| = |k\\||\\pmb a\\|\\\\\n&(\\pmb a,\\pmb b) = \\frac{1}{2}\\{\\|\\pmb a + \\pmb b\\|^2 - \\|\\pmb a\\|^2 - \\|\\pmb b\\|^2\\} = \\frac{1}{2}\\{\\|\\pmb a\\|^2 + \\|\\pmb b\\|^2 - \\|\\pmb a - \\pmb b\\|^2 \\}\\\\\n&\\|\\pmb a + \\pmb b\\|^2 + \\|\\pmb a - \\pmb b\\|^2 = 2(\\|\\pmb a\\|^2 + \\|\\pmb b\\|^2)\n\\end{align}\n\\]\n\n\n\n\n\n\n\n\n\nProof\n\n\n\n\n\n ▶  \\(\\|k\\pmb a\\| = |k\\||\\pmb a\\|\\)\n\\[\n\\begin{align}\n\\|k\\pmb a\\|^2\n    &= (k\\pmb a, k\\pmb a)\\\\\n    &= k^2 (\\pmb a, \\pmb a)\\\\\n    &= k^2 \\|\\pmb a\\|^2\n\\end{align}\n\\]\n従って，\n\\[\n\\begin{align}\n\\|k\\pmb a\\|\n    &= \\sqrt{\\|k\\pmb a\\|^2}\\\\\n    &= \\sqrt{k^2 \\|\\pmb a\\|^2}\\\\\n    &= |k\\||\\pmb a\\|\n\\end{align}\n\\]\n ▶  \\((\\pmb a,\\pmb b) = \\frac{1}{2}\\{\\|\\pmb a + \\pmb b\\|^2 - \\|\\pmb a\\|^2 - \\|\\pmb b\\|^2\\}\\)\n\\[\n\\begin{align}\n\\|\\pmb a + \\pmb b\\|^2\n    &= (\\pmb a + \\pmb b, \\pmb a + \\pmb b)\\\\\n    &= (\\pmb a, \\pmb a) + 2(\\pmb a, \\pmb b) + (\\pmb b, \\pmb b)\\\\\n    &= \\|\\pmb a\\|^2 + \\|\\pmb b\\|^2 + 2(\\pmb a, \\pmb b)\n\\end{align}\n\\]\n従って，\n\\[\n(\\pmb a,\\pmb b) = \\frac{1}{2}\\{\\|\\pmb a + \\pmb b\\|^2 - \\|\\pmb a\\|^2 - \\|\\pmb b\\|^2\\}\n\\]\n ▶  \\((\\pmb a,\\pmb b) = \\frac{1}{2}\\{\\|\\pmb a\\|^2 + \\|\\pmb b\\|^2 - \\|\\pmb a - \\pmb b\\|^2 \\}\\)\n\\[\n\\begin{align}\n\\|\\pmb a - \\pmb b\\|^2\n    &= (\\pmb a - \\pmb b, \\pmb a - \\pmb b)\\\\\n    &= \\|\\pmb a\\|^2 + \\|\\pmb b\\|^2 -2(\\pmb a, \\pmb b)\n\\end{align}\n\\]\n従って，\n\\[\n(\\pmb a,\\pmb b) = \\frac{1}{2}\\{\\|\\pmb a\\|^2 + \\|\\pmb b\\|^2 - \\|\\pmb a - \\pmb b\\|^2 \\}\n\\]\n ▶  \\(\\|\\pmb a + \\pmb b\\|^2 + \\|\\pmb a - \\pmb b\\|^2 = 2(\\|\\pmb a\\|^2 + \\|\\pmb b\\|^2)\\)\n\\[\n\\begin{align}\n\\|\\pmb a + \\pmb b\\|^2 & = \\|\\pmb a\\|^2 + \\|\\pmb b\\|^2  + 2(\\pmb a, \\pmb b)\\\\\n\\|\\pmb a - \\pmb b\\|^2 & = \\|\\pmb a\\|^2 + \\|\\pmb b\\|^2 - 2(\\pmb a, \\pmb b)\n\\end{align}\n\\]\n両辺を足し合わせると\n\\[\n\\|\\pmb a + \\pmb b\\|^2 + \\|\\pmb a - \\pmb b\\|^2 = 2(\\|\\pmb a\\|^2 + \\|\\pmb b\\|^2)\n\\]\n\n\n\n ▶  ピタゴラスの定理\n\\(n\\) 次元実ベクトル空間 \\(V\\) に対して，\\(\\pmb a, \\pmb b \\in V\\) を考えます．\\(\\pmb a\\perp \\pmb b\\) が成立する場合，\n\\[\n\\begin{align}\n\\|\\pmb a + \\pmb b\\|^2\n    &= (\\pmb a + \\pmb b, \\pmb a + \\pmb b)\\\\\n    &= \\|\\pmb a\\|^2 + \\|\\pmb b\\|^2 + 2(\\pmb a, \\pmb b)\\\\\n    &= \\|\\pmb a\\|^2 + \\|\\pmb b\\|^2\n\\end{align}\n\\]\nこれは \\(\\pmb a\\perp \\pmb b \\Leftrightarrow (\\pmb a, \\pmb b) = 0\\) であることからわかります．\n ▶  一般化されたピタゴラスの定理\n\\(\\pmb a_1, \\cdots, \\pmb a_n \\in V\\) が互いに直交している場合，\n\\[\n\\|\\pmb a_1 + \\cdots + \\pmb a_n \\|^2 = \\|\\pmb a_1 \\|^2 + \\cdots + \\|\\pmb a_n \\|^2\n\\]"
  },
  {
    "objectID": "posts/2025-04-07-inner-product/index.html#エルミート内積",
    "href": "posts/2025-04-07-inner-product/index.html#エルミート内積",
    "title": "ベクトル空間における内積",
    "section": "エルミート内積",
    "text": "エルミート内積\n実数上のベクトル空間の内積に相当するものを複素数上のベクトル空間で考えます．\\(\\pmb a \\in \\mathbb C^2\\) について実数上のベクトル空間の内積と同じように考えると\n\\[\n\\begin{align}\n\\pmb a &= (1 + 2i, 0)\\\\\n(\\pmb a, \\pmb a) &= 1 - 4 + 4i = -3 + 4i\n\\end{align}\n\\]\nとなり，正値性 \\((\\pmb a, \\pmb a)\\geq 0\\) が崩れてしまい，長さが定義できなくなるという問題が発生してしまいます．そこで \\(\\mathbb C^n\\) 上のベクトル空間についての内積は\n\\[\n(\\pmb a, \\pmb b) = \\pmb a^T\\overline{\\pmb b} =  a_1\\overline{b_1} + a_2\\overline{b_2} + \\cdots + a_n\\overline{b_n}\n\\]\nによって定義します(\\(\\overline b_j\\) は \\(b_j\\) の共役複素数)．このように定義した場合\n\n\n\n\n\n\nProperty: エルミート内積の性質\n\n\n\n\\(\\pmb a, \\pmb b, \\pmb c\\in V\\), \\(k\\in C\\) のとき，\n\\[\n\\begin{align}\n&(\\pmb a, \\pmb b) = \\overline{(\\pmb b, \\pmb a)}\\\\\n&(\\pmb a + \\pmb b, \\pmb c) = (\\pmb a, \\pmb c) + (\\pmb b, \\pmb c)\\\\\n&(\\pmb a, \\pmb b + \\pmb c) = (\\pmb a, \\pmb b) + (\\pmb a, \\pmb c)\\\\\n&(k\\pmb a, \\pmb b) = k(\\pmb a, \\pmb b)\\\\\n&(\\pmb a, k\\pmb b) = \\overline k(\\pmb a, \\pmb b)\\\\\n&(\\pmb a, \\pmb a) \\in \\mathbb R \\text{ であり } (\\pmb a, \\pmb a) \\geq 0, (\\pmb a, \\pmb a) = 0 \\Leftrightarrow \\pmb a = \\pmb 0\n\\end{align}\n\\]\n\n\n１つ目の性質はエルミート性や共役対称性と呼ばれますが，以下のように確認することができます\n\\[\n\\begin{align}\n\\overline{(\\pmb b, \\pmb a)}\n    &= \\sum_i \\overline{b_i \\overline{a_i}}\\\\\n    &= \\sum_i \\overline{b_i} a_i\\\\\n    &= \\sum_i a_i\\overline{b_i} \\\\\n    &= (\\pmb a, \\pmb b)\n\\end{align}\n\\]\n ▶  \\(\\mathbb C^n\\) における直交\n\\(\\mathbb C^n\\) の場合，内積 \\((\\pmb a, \\pmb b)\\) は一般に複素数であって実数とは限りません．そのため，ベクトルの成す角は \\(\\mathbb R^n\\) のようには定義できません． しかし，\\((\\pmb a, \\pmb b) = 0\\) のとき，\\(\\pmb a\\perp \\pmb b\\) ということにすれば，直交という概念だけは定義できます．\n\n\nTheorem 4 : シュワルツの不等式 \n\\(\\mathbb C^n\\) の任意のベクトル \\(\\pmb a, \\pmb b\\) に対し，次が成り立つ．\n\\[\n\\|(\\pmb a, \\pmb b)\\| \\leq \\|\\pmb a\\|\\|\\pmb b\\|\n\\]\n\n\n\n\n\n\n\n\n\nProof\n\n\n\n\n\n\\(x, y \\in \\mathbb C\\) とすると，エルミート内積の正値性より\n\\[\n\\begin{align}\n0\n    &\\leq (x\\pmb a + y\\pmb b, x\\pmb a + y\\pmb b)\\\\\n    &= |x|^2(\\pmb a, \\pmb a) + x \\overline y (\\pmb a, \\pmb b) + \\overline x y (\\pmb b, \\pmb a) + |y|^2(\\pmb b, \\pmb b)\n\\end{align}\n\\]\nここで，\\(x = (\\pmb b, \\pmb b), y = - (\\pmb a, \\pmb b)\\) とすると，\n\\[\n\\begin{align}\n&|x|^2(\\pmb a, \\pmb a) + x \\overline y (\\pmb a, \\pmb b) + \\overline x y (\\pmb b, \\pmb a) + |y|^2(\\pmb b, \\pmb b)\\\\\n    &= (\\pmb b, \\pmb b)\\overline{(\\pmb b, \\pmb b)}(\\pmb a, \\pmb a) - (\\pmb b, \\pmb b)\\overline{(\\pmb a, \\pmb b)}(\\pmb a, \\pmb b) - \\overline{(\\pmb b, \\pmb b)}(\\pmb a, \\pmb b)(\\pmb b, \\pmb a) + (\\pmb a, \\pmb b)\\overline{(\\pmb a, \\pmb b)}(\\pmb b, \\pmb b)\\\\\\\n    &= (\\pmb b, \\pmb b)(\\pmb b, \\pmb b)(\\pmb a, \\pmb a) - (\\pmb b, \\pmb b)\\|(\\pmb a, \\pmb b)\\|^2 - (\\pmb b, \\pmb b)\\|(\\pmb a, \\pmb b)\\|^2 + (\\pmb b, \\pmb b)\\|(\\pmb a, \\pmb b)\\|^2\\\\\n    &= 2((\\pmb b, \\pmb b)(\\pmb b, \\pmb b)(\\pmb a, \\pmb a) - (\\pmb b, \\pmb b)\\|(\\pmb a, \\pmb b)\\|^2)\n\\end{align}\n\\]\n従って，\n\\[\n0 \\leq (\\pmb b, \\pmb b) \\{(\\pmb b, \\pmb b)(\\pmb a, \\pmb a) - \\|(\\pmb a, \\pmb b)\\|^2\\}\n\\]\n\\(\\pmb b \\neq \\pmb 0\\) なら \\((\\pmb b, \\pmb b) &gt; 0\\) であるので\n\\[\n\\|(\\pmb a, \\pmb b)\\|^2 \\leq \\|\\pmb a \\|^2\\|\\pmb b \\|^2 \\Rightarrow \\|(\\pmb a, \\pmb b)\\| \\leq \\|\\pmb a\\|\\|\\pmb b\\|\n\\]\n\n\n\n\nExample 1 : 関数空間 \n実数の区間 \\([a, b]\\) で定義され，\\(K\\) の値を取る連続関数全体の空間 \\(U\\) において，\\(f, g\\in U\\) に対し，\n\\[\n(f, g) = \\int^b_a f(x) \\overline{g(x)} dx\n\\]\nと定めると，これは内積となる．内積となることからSchwarzの不等式が適応できるので，次の不等式を得ることができます\n\\[\n\\begin{align}\n\\|(f, g)\\| &\\leq \\sqrt{(f, f)}\\sqrt{(g, g)}\\\\[5pt]\n\\Rightarrow \\left\\|\\int^b_a f(x) \\overline{g(x)} dx\\right\\|\n    &\\leq \\sqrt{\\int^b_a f(x) \\overline{f(x)} dx}\\sqrt{\\int^b_a g(x) \\overline{g(x)} dx}\\\\[5pt]\n    &= \\sqrt{\\int^b_a \\|f(x)\\|^2 dx}\\sqrt{\\int^b_a \\|g(x)\\|^2 dx}\\\\\n\\end{align}\n\\]"
  },
  {
    "objectID": "posts/2025-02-28-cavalieri-principle/index.html",
    "href": "posts/2025-02-28-cavalieri-principle/index.html",
    "title": "カバリエリの原理",
    "section": "",
    "text": "一辺長さ \\(2\\) の正方形を底面として高さ3の直方体と，それをちょっとずつねじる形でずらした立体を以下のように考えます． 右図において，\\(xy\\) 平面に並行な各断面はどれも等しく一辺の長さ \\(2\\) の正方形で，その面積は \\(4\\) となってるとします．\nこのとき，カバリエリの原理よりどちらの立体像の体積は等しいことが言えます．\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.mplot3d.art3d import Poly3DCollection\n\n\ndef plot_cuboid(data, length=2, width=2, height=3, ax=None):\n    if ax is None:\n        fig = plt.figure()\n        ax = fig.add_subplot(111, projection=\"3d\")\n    poly3d = Poly3DCollection(data, alpha=0.2, edgecolor=\"k\")\n    ax.add_collection3d(poly3d)\n\n    # Set limits\n    max_dim = max(length, width, height)\n    ax.set_xlim([-max_dim, max_dim])\n    ax.set_ylim([-max_dim, max_dim])\n    ax.set_zlim([0, height * 1.1])\n    ax.set_xlabel(\"X\")\n    ax.set_ylabel(\"Y\")\n    ax.set_zlabel(\"Z\")\n\n\ndef twisted_cuboid(\n    length=2, width=2, height=3, twist_angle=np.pi / 2, num_segments=500\n):\n    # Define the base (bottom) of the cuboid\n    base_vertices = np.array(\n        [\n            [-length / 2, -width / 2, 0],\n            [length / 2, -width / 2, 0],\n            [length / 2, width / 2, 0],\n            [-length / 2, width / 2, 0],\n        ]\n    )\n\n    # Define the top face with a twist\n    rotation_matrix = np.array(\n        [\n            [np.cos(twist_angle), -np.sin(twist_angle), 0],\n            [np.sin(twist_angle), np.cos(twist_angle), 0],\n            [0, 0, 1],\n        ]\n    )\n    top_vertices = base_vertices @ rotation_matrix.T + np.array([0, 0, height])\n\n    # Interpolate between base and top vertices\n    vertices = []\n    for i in range(num_segments + 1):\n        t = i / num_segments\n        interpolated_vertices = (1 - t) * base_vertices + t * top_vertices\n        vertices.append(interpolated_vertices)\n    vertices = np.vstack(vertices)\n\n    # Define faces\n    faces = []\n    for i in range(num_segments):\n        for j in range(4):\n            next_j = (j + 1) % 4\n            faces.append(\n                [\n                    vertices[i * 4 + j],\n                    vertices[i * 4 + next_j],\n                    vertices[(i + 1) * 4 + next_j],\n                    vertices[(i + 1) * 4 + j],\n                ]\n            )\n\n    return faces\n\n\ndef cuboid(length=2, width=2, height=3, num_segments=100, ax=None):\n    # Define the base (bottom) of the cuboid\n    base_vertices = np.array(\n        [\n            [-length / 2, -width / 2, 0],\n            [length / 2, -width / 2, 0],\n            [length / 2, width / 2, 0],\n            [-length / 2, width / 2, 0],\n        ]\n    )\n\n    # Define the top face without a twist\n    top_vertices = base_vertices + np.array([0, 0, height])\n\n    # Interpolate between base and top vertices\n    vertices = []\n    for i in range(num_segments + 1):\n        t = i / num_segments\n        interpolated_vertices = (1 - t) * base_vertices + t * top_vertices\n        vertices.append(interpolated_vertices)\n    vertices = np.vstack(vertices)\n\n    # Define faces\n    faces = []\n    for i in range(num_segments):\n        for j in range(4):\n            next_j = (j + 1) % 4\n            faces.append(\n                [\n                    vertices[i * 4 + j],\n                    vertices[i * 4 + next_j],\n                    vertices[(i + 1) * 4 + next_j],\n                    vertices[(i + 1) * 4 + j],\n                ]\n            )\n\n    return faces\n\n\n# compute points\ncuboid_records = cuboid()\ntwisted_cuboid_records = twisted_cuboid()\n\n# plots\nfig = plt.figure(figsize=(12, 6))\nax1 = fig.add_subplot(121, projection=\"3d\")\nax2 = fig.add_subplot(122, projection=\"3d\")\n\nplot_cuboid(cuboid_records, ax=ax1)\nplot_cuboid(twisted_cuboid_records, ax=ax2)\n\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\nTheorem 1 : カバリエリの原理 \n2つの立体について，平行な平面で切った切り口を比べる．互いの面積がいつも等しいならば，この２つの立体の体積は等しい．\n\n\n半径 \\(r\\) の円を底面とする高さ \\(h\\) の円柱を考えます． なお \\(h = r\\) とします．この円柱から，半径 \\(r\\) の円を底面とする円錐を以下のように抜き取った立体を作ります（以降，穴あき円柱と呼ぶ）．\n\n\n\nカバリエリの原理\n\n\nこの穴開き円柱の体積は\n\\[\n\\begin{align}\n\\pi r^2\\times h - \\pi r^2\\times \\frac{h}{3}\n    &= \\frac{2}{3} \\pi r^2 h\n\\end{align}\n\\]\n一方，半径 \\(r\\) の半球の体積は\n\\[\n\\begin{align}\n\\frac{1}{2} \\times \\frac{4}{3}\\pi r^3 = \\frac{2}{3} \\pi r^2h\n\\end{align}\n\\]\n２つの立体の体積が一致することがわかります．これをカバリエリの原理を使って確かめてみます．\nまず穴あき円錐について，高さ \\(a \\in [0, h]\\) における断面積（緑色の部分）は\n\\[\nr^2\\pi - \\left(\\frac{a}{r}r\\right)^2\\pi = (r^2 - a^2)\\pi\n\\]\n半球の方は，ピタゴラスの定理より高さ \\(a\\) のときの半径が \\(\\sqrt{r^2 - a^2}\\) と求まるので\n\\[\n(\\sqrt{r^2 - a^2})^2\\pi = (r^2 - a^2)\\pi\n\\]\n従って，２つの立体について任意の高さ \\(a \\in [0, h]\\) において互いの面積がいつも等しいことがわかります．\n\n\n半径 \\(r\\), 弧の長さ \\(l\\) の扇形の面積を求めたいとします．扇形に対し，分割交互ずらしをして以下のように長方形へ極限等積変形を実施します．\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom matplotlib.patches import Wedge, Polygon\n\n# Parameters\nr = 1  # radius\nl = 0.5  # arc length\n\n# Calculate the angle of the sector\ntheta = l / r  # in radians\ndivide_num = 4\n\n# Create the sector\nfig, ax = plt.subplots(1, 2, figsize=(12, 6))\n\n# Plot the original sector\nsector = Wedge(\n    (0, 0), r, 0, np.degrees(theta), facecolor=\"lightblue\", edgecolor=\"black\"\n)\nax[0].add_patch(sector)\nax[0].set_xlim(-0.1, r * 1.2)\nax[0].set_ylim(-0.1, l)\nax[0].set_aspect(\"equal\", \"box\")\nax[0].set_title(\"Original Sector\")\n\n# Divide the sector into four parts\nangles = np.linspace(0, theta, divide_num+1)\nfor i in range(divide_num):\n    wedge = Wedge(\n        (0, 0),\n        r,\n        np.degrees(angles[i]),\n        np.degrees(angles[i + 1]),\n        facecolor=\"none\",\n        edgecolor=\"black\",\n    )\n    ax[0].add_patch(wedge)\n\n# Rearrange the parts into a parallelogram\n\n# Create the parallelogram by shifting the parts\nfor i in range(divide_num):\n    if i % 2 == 0:\n        sector = Wedge(\n            (0, np.sin(theta / divide_num) * (i // 2)), r, 0, np.degrees(theta / divide_num), facecolor=\"lightblue\", edgecolor=\"black\"\n        )\n    else:\n        sector = Wedge(\n            (np.cos(theta / divide_num), np.sin(theta / divide_num) * (i // 2 + 1 )),\n            r,\n            np.degrees(np.pi),\n            np.degrees(theta / divide_num + np.pi),\n            facecolor=\"lightblue\",\n            edgecolor=\"black\",\n        )\n    ax[1].add_patch(sector)\n    \n\n# add info\nax[1].text(1.01, l/4, f\"Height = $l/2$\", horizontalalignment=\"left\")\n\nax[1].set_xlim(-0.1, r * 1.2)\nax[1].set_ylim(-0.1, l)\nax[1].set_aspect(\"equal\", \"box\")\nax[1].set_title(\"Rearranged into Parallelogram\")\n\nplt.show()\n\n\n\n\n\n\n\n\n\n上の図では４分割ですが，これを細かくすると横の長さ \\(r\\), 縦の長さ \\(l/2\\) の長方形へ変形することができるとみなせるので\n\\[\nS = \\frac{l}{2}r\n\\]\nと計算することが出来ます．半径 \\(r\\), 弧の長さ \\(l = 2\\pi r\\) のとき，扇形は円になりますが，その円の面積も同様に\n\\[\nS = \\frac{2\\pi r}{2}r = r^2 \\pi\n\\]\nと計算でき，円の面積の公式と一致することがわかります\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom matplotlib.patches import Wedge, Polygon\n\n# Parameters\nr = 2  # radius\nl = 2*np.pi * r  # arc length\n\n# Calculate the angle of the sector\ntheta = l / r  # in radians\ndivide_num = 100\n\n# Create the sector\nfig, ax = plt.subplots(1, 2, figsize=(12, 6))\n\n# Plot the original sector\nsector = Wedge(\n    (0, 0), r, 0, np.degrees(theta), facecolor=\"lightblue\", edgecolor=\"black\"\n)\nax[0].add_patch(sector)\nax[0].set_xlim(-r * 1.2, r * 1.2)\nax[0].set_ylim(-r * 1.2, r * 1.2)\nax[0].set_aspect(\"equal\", \"box\")\nax[0].set_title(\"Original Sector\")\n\n# Divide the sector into four parts\nangles = np.linspace(0, theta, divide_num+1)\nfor i in range(divide_num):\n    wedge = Wedge(\n        (0, 0),\n        r,\n        np.degrees(angles[i]),\n        np.degrees(angles[i + 1]),\n        facecolor=\"none\",\n        edgecolor=\"black\",\n    )\n    ax[0].add_patch(wedge)\n\n# Rearrange the parts into a parallelogram\n\n# Create the parallelogram by shifting the parts\nfor i in range(divide_num):\n    if i % 2 == 0:\n        sector = Wedge(\n            (0, np.sin(theta / divide_num) * (i // 2)* r), r, 0, np.degrees(theta / divide_num), facecolor=\"lightblue\", edgecolor=\"black\"\n        )\n    else:\n        sector = Wedge(\n            (np.cos(theta / divide_num)* r, np.sin(theta / divide_num) * r * (i // 2 + 1 )),\n            r,\n            np.degrees(np.pi),\n            np.degrees(theta / divide_num + np.pi),\n            facecolor=\"lightblue\",\n            edgecolor=\"black\",\n        )\n    ax[1].add_patch(sector)\n    \n\n# add info\nax[1].text(r + 0.01, l/4, f\"Height = $r\\pi$\", horizontalalignment=\"left\")\n\nax[1].set_xlim(-0.5, r * 1.2)\nax[1].set_ylim(-0.5, l/2 * 1.05)\nax[1].set_aspect(\"equal\", \"box\")\nax[1].set_title(\"Rearranged into Parallelogram\")\n\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n半径 \\(2\\), 弧の長さが \\(\\displaystyle L = \\frac{2}{3}\\pi\\) の扇形から，半径 \\(2/3\\), 弧の長さが \\(\\displaystyle l = \\frac{2}{9}\\pi\\) の扇形を除いたパイン形を考えます．このパイン形に対して，「分割交互ずらし」を適用して極限を取ると，底辺の長さ \\(\\displaystyle \\frac{4}{3}\\)，高さ\n\\[\n\\text{height} = \\frac{l + L}{2} = \\frac{4}{9}\\pi\n\\]\nの長方形へ収束します．このとき，このパイン型の面積は\n\\[\nS = \\frac{l + L}{2}\\times \\frac{4}{3} = \\frac{16}{27}\\pi\n\\]\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom shapely.geometry import Polygon\nfrom shapely.affinity import translate\nfrom shapely.ops import unary_union\nfrom shapely.affinity import rotate\nimport geopandas as gpd\n\n\ndef create_sector(center, radius, angle_start, angle_end, num_points=100):\n    \"\"\"Creates a sector shape as a polygon using Shapely.\"\"\"\n    angles = np.linspace(np.radians(angle_start), np.radians(angle_end), num_points)\n    outer_arc = [\n        (center[0] + radius * np.cos(a), center[1] + radius * np.sin(a)) for a in angles\n    ]\n    return Polygon([center] + outer_arc + [center])  # Close the polygon\n\n\n# Parameters\ndivide_num = 20\nring_sector_list = []\nouter_radius = 2\nangle = 60 / divide_num\n\nfor i in range(divide_num):\n    center = (0, 0)\n    inner_radius = outer_radius / 3\n    angle_start, angle_end = angle * i, angle * (i + 1)  # Angle in degrees\n\n    # Create outer and inner sectors\n    outer_sector = create_sector(center, outer_radius, angle_start, angle_end)\n    inner_sector = create_sector(center, inner_radius, angle_start, angle_end)\n\n    # Subtract inner sector from outer sector to get the ring shape\n    ring_sector = outer_sector.difference(inner_sector)\n    ring_sector_list.append(ring_sector)\n\n\n# plot\nfig, ax = plt.subplots(1, 2, figsize=(12, 6))\n\nfor ring_sector in ring_sector_list:\n    # Plot using GeoPandas\n    gdf = gpd.GeoSeries([ring_sector])\n    gdf.plot(ax=ax[0], color=\"lightblue\", edgecolor=\"black\")\n\n# Formatting\nax[0].set_xlim(-0.05, outer_radius + 0.1)\nax[0].set_ylim(-0.05, outer_radius + 0.1)\n\ngdf = gpd.GeoSeries([ring_sector_list[0]])\nrotated_gdf = gpd.GeoSeries(rotate(ring_sector_list[0], 180, origin=\"center\"))\nfor i in range(len(ring_sector_list)):\n    # Plot using GeoPandas\n    if i % 2 == 0:\n        gdf_tmp = gdf.apply(\n            lambda geom: translate(\n                geom, xoff=-2/3, yoff=np.sin(np.radians(angle))*8/3 * (i//2)\n            )\n        )\n        gdf_tmp.plot(ax=ax[1], color=\"lightblue\", edgecolor=\"black\")\n    else:\n        gdf_tmp = rotated_gdf.apply(\n            lambda geom: translate(\n                geom, xoff=-2/3, yoff=np.sin(np.radians(angle))*2/3 * (i//2 + 1) + np.sin(np.radians(angle))*6/3 * (i//2)\n            ))\n        gdf_tmp.plot(ax=ax[1], color=\"lightblue\", edgecolor=\"black\")\n\n\nplt.show()"
  },
  {
    "objectID": "posts/2025-02-28-cavalieri-principle/index.html#カバリエリの原理",
    "href": "posts/2025-02-28-cavalieri-principle/index.html#カバリエリの原理",
    "title": "カバリエリの原理",
    "section": "",
    "text": "一辺長さ \\(2\\) の正方形を底面として高さ3の直方体と，それをちょっとずつねじる形でずらした立体を以下のように考えます． 右図において，\\(xy\\) 平面に並行な各断面はどれも等しく一辺の長さ \\(2\\) の正方形で，その面積は \\(4\\) となってるとします．\nこのとき，カバリエリの原理よりどちらの立体像の体積は等しいことが言えます．\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.mplot3d.art3d import Poly3DCollection\n\n\ndef plot_cuboid(data, length=2, width=2, height=3, ax=None):\n    if ax is None:\n        fig = plt.figure()\n        ax = fig.add_subplot(111, projection=\"3d\")\n    poly3d = Poly3DCollection(data, alpha=0.2, edgecolor=\"k\")\n    ax.add_collection3d(poly3d)\n\n    # Set limits\n    max_dim = max(length, width, height)\n    ax.set_xlim([-max_dim, max_dim])\n    ax.set_ylim([-max_dim, max_dim])\n    ax.set_zlim([0, height * 1.1])\n    ax.set_xlabel(\"X\")\n    ax.set_ylabel(\"Y\")\n    ax.set_zlabel(\"Z\")\n\n\ndef twisted_cuboid(\n    length=2, width=2, height=3, twist_angle=np.pi / 2, num_segments=500\n):\n    # Define the base (bottom) of the cuboid\n    base_vertices = np.array(\n        [\n            [-length / 2, -width / 2, 0],\n            [length / 2, -width / 2, 0],\n            [length / 2, width / 2, 0],\n            [-length / 2, width / 2, 0],\n        ]\n    )\n\n    # Define the top face with a twist\n    rotation_matrix = np.array(\n        [\n            [np.cos(twist_angle), -np.sin(twist_angle), 0],\n            [np.sin(twist_angle), np.cos(twist_angle), 0],\n            [0, 0, 1],\n        ]\n    )\n    top_vertices = base_vertices @ rotation_matrix.T + np.array([0, 0, height])\n\n    # Interpolate between base and top vertices\n    vertices = []\n    for i in range(num_segments + 1):\n        t = i / num_segments\n        interpolated_vertices = (1 - t) * base_vertices + t * top_vertices\n        vertices.append(interpolated_vertices)\n    vertices = np.vstack(vertices)\n\n    # Define faces\n    faces = []\n    for i in range(num_segments):\n        for j in range(4):\n            next_j = (j + 1) % 4\n            faces.append(\n                [\n                    vertices[i * 4 + j],\n                    vertices[i * 4 + next_j],\n                    vertices[(i + 1) * 4 + next_j],\n                    vertices[(i + 1) * 4 + j],\n                ]\n            )\n\n    return faces\n\n\ndef cuboid(length=2, width=2, height=3, num_segments=100, ax=None):\n    # Define the base (bottom) of the cuboid\n    base_vertices = np.array(\n        [\n            [-length / 2, -width / 2, 0],\n            [length / 2, -width / 2, 0],\n            [length / 2, width / 2, 0],\n            [-length / 2, width / 2, 0],\n        ]\n    )\n\n    # Define the top face without a twist\n    top_vertices = base_vertices + np.array([0, 0, height])\n\n    # Interpolate between base and top vertices\n    vertices = []\n    for i in range(num_segments + 1):\n        t = i / num_segments\n        interpolated_vertices = (1 - t) * base_vertices + t * top_vertices\n        vertices.append(interpolated_vertices)\n    vertices = np.vstack(vertices)\n\n    # Define faces\n    faces = []\n    for i in range(num_segments):\n        for j in range(4):\n            next_j = (j + 1) % 4\n            faces.append(\n                [\n                    vertices[i * 4 + j],\n                    vertices[i * 4 + next_j],\n                    vertices[(i + 1) * 4 + next_j],\n                    vertices[(i + 1) * 4 + j],\n                ]\n            )\n\n    return faces\n\n\n# compute points\ncuboid_records = cuboid()\ntwisted_cuboid_records = twisted_cuboid()\n\n# plots\nfig = plt.figure(figsize=(12, 6))\nax1 = fig.add_subplot(121, projection=\"3d\")\nax2 = fig.add_subplot(122, projection=\"3d\")\n\nplot_cuboid(cuboid_records, ax=ax1)\nplot_cuboid(twisted_cuboid_records, ax=ax2)\n\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\nTheorem 1 : カバリエリの原理 \n2つの立体について，平行な平面で切った切り口を比べる．互いの面積がいつも等しいならば，この２つの立体の体積は等しい．\n\n\n半径 \\(r\\) の円を底面とする高さ \\(h\\) の円柱を考えます． なお \\(h = r\\) とします．この円柱から，半径 \\(r\\) の円を底面とする円錐を以下のように抜き取った立体を作ります（以降，穴あき円柱と呼ぶ）．\n\n\n\nカバリエリの原理\n\n\nこの穴開き円柱の体積は\n\\[\n\\begin{align}\n\\pi r^2\\times h - \\pi r^2\\times \\frac{h}{3}\n    &= \\frac{2}{3} \\pi r^2 h\n\\end{align}\n\\]\n一方，半径 \\(r\\) の半球の体積は\n\\[\n\\begin{align}\n\\frac{1}{2} \\times \\frac{4}{3}\\pi r^3 = \\frac{2}{3} \\pi r^2h\n\\end{align}\n\\]\n２つの立体の体積が一致することがわかります．これをカバリエリの原理を使って確かめてみます．\nまず穴あき円錐について，高さ \\(a \\in [0, h]\\) における断面積（緑色の部分）は\n\\[\nr^2\\pi - \\left(\\frac{a}{r}r\\right)^2\\pi = (r^2 - a^2)\\pi\n\\]\n半球の方は，ピタゴラスの定理より高さ \\(a\\) のときの半径が \\(\\sqrt{r^2 - a^2}\\) と求まるので\n\\[\n(\\sqrt{r^2 - a^2})^2\\pi = (r^2 - a^2)\\pi\n\\]\n従って，２つの立体について任意の高さ \\(a \\in [0, h]\\) において互いの面積がいつも等しいことがわかります．\n\n\n半径 \\(r\\), 弧の長さ \\(l\\) の扇形の面積を求めたいとします．扇形に対し，分割交互ずらしをして以下のように長方形へ極限等積変形を実施します．\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom matplotlib.patches import Wedge, Polygon\n\n# Parameters\nr = 1  # radius\nl = 0.5  # arc length\n\n# Calculate the angle of the sector\ntheta = l / r  # in radians\ndivide_num = 4\n\n# Create the sector\nfig, ax = plt.subplots(1, 2, figsize=(12, 6))\n\n# Plot the original sector\nsector = Wedge(\n    (0, 0), r, 0, np.degrees(theta), facecolor=\"lightblue\", edgecolor=\"black\"\n)\nax[0].add_patch(sector)\nax[0].set_xlim(-0.1, r * 1.2)\nax[0].set_ylim(-0.1, l)\nax[0].set_aspect(\"equal\", \"box\")\nax[0].set_title(\"Original Sector\")\n\n# Divide the sector into four parts\nangles = np.linspace(0, theta, divide_num+1)\nfor i in range(divide_num):\n    wedge = Wedge(\n        (0, 0),\n        r,\n        np.degrees(angles[i]),\n        np.degrees(angles[i + 1]),\n        facecolor=\"none\",\n        edgecolor=\"black\",\n    )\n    ax[0].add_patch(wedge)\n\n# Rearrange the parts into a parallelogram\n\n# Create the parallelogram by shifting the parts\nfor i in range(divide_num):\n    if i % 2 == 0:\n        sector = Wedge(\n            (0, np.sin(theta / divide_num) * (i // 2)), r, 0, np.degrees(theta / divide_num), facecolor=\"lightblue\", edgecolor=\"black\"\n        )\n    else:\n        sector = Wedge(\n            (np.cos(theta / divide_num), np.sin(theta / divide_num) * (i // 2 + 1 )),\n            r,\n            np.degrees(np.pi),\n            np.degrees(theta / divide_num + np.pi),\n            facecolor=\"lightblue\",\n            edgecolor=\"black\",\n        )\n    ax[1].add_patch(sector)\n    \n\n# add info\nax[1].text(1.01, l/4, f\"Height = $l/2$\", horizontalalignment=\"left\")\n\nax[1].set_xlim(-0.1, r * 1.2)\nax[1].set_ylim(-0.1, l)\nax[1].set_aspect(\"equal\", \"box\")\nax[1].set_title(\"Rearranged into Parallelogram\")\n\nplt.show()\n\n\n\n\n\n\n\n\n\n上の図では４分割ですが，これを細かくすると横の長さ \\(r\\), 縦の長さ \\(l/2\\) の長方形へ変形することができるとみなせるので\n\\[\nS = \\frac{l}{2}r\n\\]\nと計算することが出来ます．半径 \\(r\\), 弧の長さ \\(l = 2\\pi r\\) のとき，扇形は円になりますが，その円の面積も同様に\n\\[\nS = \\frac{2\\pi r}{2}r = r^2 \\pi\n\\]\nと計算でき，円の面積の公式と一致することがわかります\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom matplotlib.patches import Wedge, Polygon\n\n# Parameters\nr = 2  # radius\nl = 2*np.pi * r  # arc length\n\n# Calculate the angle of the sector\ntheta = l / r  # in radians\ndivide_num = 100\n\n# Create the sector\nfig, ax = plt.subplots(1, 2, figsize=(12, 6))\n\n# Plot the original sector\nsector = Wedge(\n    (0, 0), r, 0, np.degrees(theta), facecolor=\"lightblue\", edgecolor=\"black\"\n)\nax[0].add_patch(sector)\nax[0].set_xlim(-r * 1.2, r * 1.2)\nax[0].set_ylim(-r * 1.2, r * 1.2)\nax[0].set_aspect(\"equal\", \"box\")\nax[0].set_title(\"Original Sector\")\n\n# Divide the sector into four parts\nangles = np.linspace(0, theta, divide_num+1)\nfor i in range(divide_num):\n    wedge = Wedge(\n        (0, 0),\n        r,\n        np.degrees(angles[i]),\n        np.degrees(angles[i + 1]),\n        facecolor=\"none\",\n        edgecolor=\"black\",\n    )\n    ax[0].add_patch(wedge)\n\n# Rearrange the parts into a parallelogram\n\n# Create the parallelogram by shifting the parts\nfor i in range(divide_num):\n    if i % 2 == 0:\n        sector = Wedge(\n            (0, np.sin(theta / divide_num) * (i // 2)* r), r, 0, np.degrees(theta / divide_num), facecolor=\"lightblue\", edgecolor=\"black\"\n        )\n    else:\n        sector = Wedge(\n            (np.cos(theta / divide_num)* r, np.sin(theta / divide_num) * r * (i // 2 + 1 )),\n            r,\n            np.degrees(np.pi),\n            np.degrees(theta / divide_num + np.pi),\n            facecolor=\"lightblue\",\n            edgecolor=\"black\",\n        )\n    ax[1].add_patch(sector)\n    \n\n# add info\nax[1].text(r + 0.01, l/4, f\"Height = $r\\pi$\", horizontalalignment=\"left\")\n\nax[1].set_xlim(-0.5, r * 1.2)\nax[1].set_ylim(-0.5, l/2 * 1.05)\nax[1].set_aspect(\"equal\", \"box\")\nax[1].set_title(\"Rearranged into Parallelogram\")\n\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n半径 \\(2\\), 弧の長さが \\(\\displaystyle L = \\frac{2}{3}\\pi\\) の扇形から，半径 \\(2/3\\), 弧の長さが \\(\\displaystyle l = \\frac{2}{9}\\pi\\) の扇形を除いたパイン形を考えます．このパイン形に対して，「分割交互ずらし」を適用して極限を取ると，底辺の長さ \\(\\displaystyle \\frac{4}{3}\\)，高さ\n\\[\n\\text{height} = \\frac{l + L}{2} = \\frac{4}{9}\\pi\n\\]\nの長方形へ収束します．このとき，このパイン型の面積は\n\\[\nS = \\frac{l + L}{2}\\times \\frac{4}{3} = \\frac{16}{27}\\pi\n\\]\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom shapely.geometry import Polygon\nfrom shapely.affinity import translate\nfrom shapely.ops import unary_union\nfrom shapely.affinity import rotate\nimport geopandas as gpd\n\n\ndef create_sector(center, radius, angle_start, angle_end, num_points=100):\n    \"\"\"Creates a sector shape as a polygon using Shapely.\"\"\"\n    angles = np.linspace(np.radians(angle_start), np.radians(angle_end), num_points)\n    outer_arc = [\n        (center[0] + radius * np.cos(a), center[1] + radius * np.sin(a)) for a in angles\n    ]\n    return Polygon([center] + outer_arc + [center])  # Close the polygon\n\n\n# Parameters\ndivide_num = 20\nring_sector_list = []\nouter_radius = 2\nangle = 60 / divide_num\n\nfor i in range(divide_num):\n    center = (0, 0)\n    inner_radius = outer_radius / 3\n    angle_start, angle_end = angle * i, angle * (i + 1)  # Angle in degrees\n\n    # Create outer and inner sectors\n    outer_sector = create_sector(center, outer_radius, angle_start, angle_end)\n    inner_sector = create_sector(center, inner_radius, angle_start, angle_end)\n\n    # Subtract inner sector from outer sector to get the ring shape\n    ring_sector = outer_sector.difference(inner_sector)\n    ring_sector_list.append(ring_sector)\n\n\n# plot\nfig, ax = plt.subplots(1, 2, figsize=(12, 6))\n\nfor ring_sector in ring_sector_list:\n    # Plot using GeoPandas\n    gdf = gpd.GeoSeries([ring_sector])\n    gdf.plot(ax=ax[0], color=\"lightblue\", edgecolor=\"black\")\n\n# Formatting\nax[0].set_xlim(-0.05, outer_radius + 0.1)\nax[0].set_ylim(-0.05, outer_radius + 0.1)\n\ngdf = gpd.GeoSeries([ring_sector_list[0]])\nrotated_gdf = gpd.GeoSeries(rotate(ring_sector_list[0], 180, origin=\"center\"))\nfor i in range(len(ring_sector_list)):\n    # Plot using GeoPandas\n    if i % 2 == 0:\n        gdf_tmp = gdf.apply(\n            lambda geom: translate(\n                geom, xoff=-2/3, yoff=np.sin(np.radians(angle))*8/3 * (i//2)\n            )\n        )\n        gdf_tmp.plot(ax=ax[1], color=\"lightblue\", edgecolor=\"black\")\n    else:\n        gdf_tmp = rotated_gdf.apply(\n            lambda geom: translate(\n                geom, xoff=-2/3, yoff=np.sin(np.radians(angle))*2/3 * (i//2 + 1) + np.sin(np.radians(angle))*6/3 * (i//2)\n            ))\n        gdf_tmp.plot(ax=ax[1], color=\"lightblue\", edgecolor=\"black\")\n\n\nplt.show()"
  },
  {
    "objectID": "posts/2025-02-28-cavalieri-principle/index.html#線分の運動とずらし面積",
    "href": "posts/2025-02-28-cavalieri-principle/index.html#線分の運動とずらし面積",
    "title": "カバリエリの原理",
    "section": "線分の運動とずらし面積",
    "text": "線分の運動とずらし面積\n野球グラウンドをならすときトンボという道具を使ったりします．このトンボを引きづる用な形でグラウンドを適当に歩くと，トンボがなす線分がグラウンドを通過することで図形が出来ます． 線分の運動の観点から，この図形の面積を求める方法をここでは紹介します．\n\n\nCode\nfrom scipy import interpolate\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nN = 1000\n\nx = np.linspace(0, 5, N)\n\ny = (\n    np.sin(x)\n    + np.cos(x ** 2) / 10\n)\n\ndydx = np.cos(x) - (2 / 10) * np.sin(x ** 2) * x\ndydx = np.where(abs(dydx) &gt; 1e-10, dydx, 0)\n\n\nupper_x = []\nupper_y = []\nlower_x = []\nlower_y = []\n\nfor i in range(N):\n    if dydx[i] &lt; 0:\n        dy = abs(1/dydx[i])\n        dist = np.sqrt(dy**2 + 1) * 10\n        dx = 1 / dist\n        dy = dy / dist\n    elif dydx[i] &gt; 0:\n        dy = abs(1/dydx[i])\n        dist = np.sqrt(dy**2 + 1)  * 10\n        dx = -1/ dist\n        dy = dy / dist\n    else:\n        dx, dy = (0, 1 / 10)\n    \n    upper_y.append(y[i] + dy)\n    upper_x.append(x[i] + dx)\n    lower_y.append(y[i] - dy)\n    lower_x.append(x[i] - dx)\n\nfig, ax = plt.subplots()\n\nax.plot(x, y, label = 'Trajectory of the center point')\nax.plot(upper_x, upper_y, color='gray', linestyle='--')\nax.plot(lower_x, lower_y, color='gray', linestyle='--')\n\nax.set_aspect('equal', 'box')  # Ensure the x and y axes have the same ratio\n\nax.set_title(\"Trajectory of a bar with length 0.2\")\n\nplt.legend()\nplt.show()\n\n\n\n\n\n\n\n\n\n一般に，大きさのある物体（剛体という）の運動は，「並進運動」と「回転運動」の合成で表されます．長さ \\(0.2\\) のトンボがグラウンドを並進運動と回転運動で通過する際に描かれる図形をplotしたものが上の図となります． 灰色の点線がそれぞれトンボの両端の軌跡を描いており，青の実線がトンボの中心点の軌跡となります．トンボがならしたグラウンドの面積は灰色で囲まれたエリアとなります．\n ▶  shapely.Polygonを用いた面積の計算\n上記で中心点の軌跡から両端の軌跡の座標を計算してあるので，それらを用いて shapely.Polygon をまず定義します．\n\n\nCode\n# shapely.Polygonの設定\npolygon_coords = list(zip(upper_x, upper_y)) + list(zip(lower_x[::-1], lower_y[::-1]))\npolygon = Polygon(polygon_coords)\n\n# Plot the polygon\nfig, ax = plt.subplots()\nx, y = polygon.exterior.xy\nax.plot(x, y, color='black')\nax.fill(x, y, color='lightblue', alpha=0.5)\nax.set_title(\"Shapely Polygon from Upper and Lower Coordinates\")\nax.set_aspect('equal', 'box')  # Ensure the x and y axes have the same ratio\nplt.show()\n\n\n\n\n\n\n\n\n\nその後，Polygon によって定義された図形の面積を計算すれば良いので\n\n\nCode\npolygon.area\n\n\n1.2470071445781767\n\n\n ▶  曲線の長さの公式と線分の移動\n詳しい説明はのちの機会としますが，線分が履く面積は\n\\[\n\\text{線分がはく面積} = \\text{中点の移動距離} \\times \\text{線分の長さ}\n\\]\nで計算することが出来ます．線分の長さは \\(0.2\\) とわかっているので，「中点の移動距離」を求めれば面積が求まりそうなことがわかります．\n\n\nTheorem 2 : 曲線の長さ \n\\(y=f(x)\\) で表される曲線の \\(x \\in [a, b]\\) の部分の長さ \\(L\\) は，\n\\[\nL = \\int^b_a \\sqrt{1 + f^\\prime(x)^2} dx\n\\]\n​（ただし，\\(f(x)\\) は微分可能で \\(f^\\prime(x)\\) は連続とする）\n\n\n点 \\(x\\) から\\(\\Delta x\\) 動いたとき，\\(\\Delta y \\approx f^\\prime(x)\\Delta x\\) 動くことから，その区間での曲線の長さは\n\\[\n\\sqrt{(\\Delta x)^2 + (f^\\prime(x)\\Delta x)^2} = \\sqrt{1 + f^\\prime(x)^2}\\Delta x\n\\]\nで近似できます．従って，\\(\\Delta x \\to dx\\) と極限を取ることで\n\\[\nL = \\int^b_a \\sqrt{1 + f^\\prime(x)^2} dx\n\\]\nと理解することが出来ます．\n今回の曲線 \\(f(x)\\) は \\([0, 5]\\) 区間で以下のように記述することができるとします．\n\\[\nf(x) =  \\sin(x) + 0.1\\cos(x^2)\n\\]\nこのとき，\\(f(x)\\) の1次導関数は\n\\[\nf^\\prime(x) = \\cos(x) - 0.2 x \\sin(x^2)\n\\]\n従って，曲線の公式より\n\\[\nL = \\int^5_0 \\sqrt{1 +  \\cos^2(x) + 0.04 x^2 \\sin^2(x^2) - 0.4x\\cos(x)\\sin(x^2)}dx\n\\]\nscipy.integrate.quad を用いて数値計算すると\n\n\nCode\nfrom scipy.integrate import quad\n\n\ndef curve_length(x):\n    return np.sqrt(\n        np.cos(x) ** 2\n        + 1 / 25 * np.sin(x**2) ** 2 * x**2\n        - 2 / 5 * np.cos(x) * np.sin(x**2) * x\n        + 1\n    )\n\n\nprint(quad(curve_length, 0, 5)[0] * 0.2)\n\n\n1.24703476690297\n\n\nshapely.Polygon を用いた計算結果と近しい値であることから計算結果の妥当性をうかがい知ることができます．"
  },
  {
    "objectID": "posts/2025-01-30-differential-equations/index.html",
    "href": "posts/2025-01-30-differential-equations/index.html",
    "title": "微分方程式を用いたToy models",
    "section": "",
    "text": "Exercise 1 : マルサスの人口論 \n時刻 \\(t\\) におけるとある国の人口が \\(N(t) &gt; 0\\) で表されるとする．マルサスは時刻 \\(t\\) から \\(t+\\Delta t\\) の人口増分 \\(\\Delta N = N(t+\\Delta) - N(t)\\) は\n\\[\n\\Delta N = k N(t)\\Delta t \\qquad (k: \\text{constant})\n\\]\nのように \\(N, \\Delta t\\) に比例するとした．ここから以下のように式変形を行い\n\\[\n\\frac{\\Delta N}{\\Delta t} = k N(t)\n\\]\n\\(\\Delta t\\to 0\\) として次のような微分方程式を得たとします\n\\[\n\\frac{dN(t)}{dt} = kN(t) \\label{eq-de-01}\n\\]\n\\((t, N(t))\\) が \\((0, 1.00 \\times 10^8), (1, 1.25 \\times 10^8)\\) と与えられているとき，\\(t = 2\\) の人口 \\(N(2)\\) を推定せよ．\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n微分方程式 \\(\\eqref{eq-de-01}\\) を以下のように変形し積分すると\n\\[\n\\begin{align}\n&\\frac{dN(t)}{dt} = kN(t) \\\\\n&\\Rightarrow \\int \\frac{1}{N(t)}\\frac{dN(t)}{dt} dt= \\int k dt \\\\\n&\\Rightarrow \\log \\vert N(t) \\vert = kt + C\\\\[5pt]\n&\\Rightarrow \\log N(t) = kt + C\n\\end{align}\n\\]\n従って，\n\\[\nN(t) = \\exp(C + kt) = \\tilde C\\exp(kt)\n\\]\n\\(t = 0\\) のときの \\(N(0) = N_0\\) とすると，\\(\\tilde C = N_0\\) でなければならないので\n\\[\nN(t) = N_0\\exp(kt) \\label{eq-malthus-solution}\n\\]\n\\((t, N(t))\\) が \\((0, 1.00 \\times 10^8), (1, 1.25 \\times 10^8)\\) と与えられているので，\n\\[\nN_0 = 1.00 \\times 10^8\n\\]\n次に\n\\[\n\\begin{align}\n&N(1) = 1.00 \\times 10^8 \\exp(k)\\\\[5pt]\n&\\Rightarrow \\exp(k) = 1.25\n\\end{align}\n\\]\n従って，\n\\[\nN(2) = (1.25)^2 \\times 10^8 \\approx 1.56 \\times 10^8\n\\]\n\n\n\n ▶  Python Simulation\nscipy.integrateパッケージのodeintを用いれば微分方程式を解くことができます．\n\nCode\nimport numpy as np\nfrom scipy.integrate import odeint\nimport matplotlib.pyplot as plt\n\n# malthusian growth func\ndef malthusian_model(y, t, k=np.log(1.25)):\n    dydt = k * y\n    return dydt\n\n# init\nN_0 = 1.0\n\n# data point\ndata = (0, 1), (1, 1.25)\n\n# time\nt = np.linspace(0, 5, 21)\n\n# solve\nn = odeint(malthusian_model, N_0, t)\n\n# plot\nplt.plot(t, n)\nplt.scatter(*zip(*data), color='red', label='observed data points')\nplt.legend()\nplt.xlabel(\"t\")\nplt.ylabel(\"$N(t)$\")\nplt.title(\"Malthusian gwrowth simulation\")\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 1\n\n\n\nFigure 1 をみると \\(N(t)\\) は指数関数的に増加していることが読み取れます．これは \\(k\\) の符号に依存しています．\n\n\\(k &gt; 0\\): 指数関数的増加\n\\(k = 0\\): 変化なし\n\\(k &lt; 0\\): 指数関数的減衰\n\nとなります．図示すると以下のようになります\n\nCode\nimport statsmodels.api as sm\n\n# params\nk_args = (-0.2, 0, 0.2)\n\n# solve\nfor k in k_args:\n    n = odeint(malthusian_model, N_0, t, args=(k,))\n    plt.plot(t, n, label=f\"k={k}\")\n\nplt.legend()\nplt.xlabel(\"t\")\nplt.ylabel(\"$N(t)$\")\nplt.title(\"Malthusian growth simulation with different $k$\")\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 2\n\n\n\n\n\n\n\n\n\n🍵 マルサスモデルの限界\n\n\n\nマルサスモデルは，\\(k &gt; 0\\) のとき人口が指数関数的に増加すると予測しています．実際には，食料や石油といった資源は有限であるので人口増加を抑制する要因があるため，現実でマルサスモデル的増加をすることは到底起こりえません．\n\n\n\n\n\n\\(N(t)\\) は 4期間ごとに観測される(=観測されるtは\\((0, 1, 2, 4)\\))\n観測される \\(N(t)\\) にはノイズが乗ってしまっている: \\(\\epsilon_t \\sim N(0, 0.1)\\)\n\nという状況ののもと，\\((N_0, k)\\) を推定し，\\(t&gt;4\\) の範囲の人口について予測することはできるのか？という問題を考えてみます．\n\\(\\eqref{eq-malthus-solution}\\) について対数を取ると\n\\[\n\\log N(t) = \\log(N_0) + kt\n\\]\nとなります．つまり，対数変換した変数についての線形モデルとして推定量を考えることができます．観測ノイズ \\(\\epsilon_t\\) を踏まえると，観測される人口を \\(\\tilde N(t)\\) とすると\n\\[\n\\begin{align}\n&\\tilde N(t) = N_0\\exp(kt) + \\epsilon_t\\\\\n&\\Rightarrow\\log \\tilde N(t) = \\log (N_0\\exp(kt) + \\epsilon_t)\n\\end{align}\n\\]\nとなってしまいますが，近似式として\n\\[\n\\log\\tilde N(t) = \\alpha + \\beta t + e_i\n\\]\nで推定するとします．\\(\\epsilon_i\\)がhomogeneousとしても\\(e_i\\)がhomogeneousとは限らないのでheteroskedasticity residual erroを想定して推定します．\n\nCode\nimport statsmodels.api as sm\n\nnp.random.seed(42)\n\n# observation step\nSTEP = 4\n\n# DGP\nactual_n = n.flatten()\nobserved_n = actual_n[::STEP][:-1] + +np.random.normal(0, 0.1, len(actual_n[::STEP][:-1]))\nobserved_t = t[::STEP][:-1]\nX = sm.add_constant(observed_t)\n\n# fit\nmodel = sm.OLS(np.log(observed_n), X).fit(cov_type=\"HC0\")\nestimated_n_0, estimated_k = model.params\n\n# simulation\nsimulated_n = odeint(malthusian_model, np.exp(estimated_n_0), t, args=(estimated_k,))\n\n# plot\nplt.plot(t, simulated_n, label=\"simulated\")\nplt.scatter(observed_t, observed_n, color=\"gray\", alpha=0.8, marker='x', label=\"actual data points\")\nplt.scatter(t, actual_n, color=\"red\", alpha=0.8, label=\"actual data points\")\nplt.legend()\nplt.xlabel(\"t\")\nplt.ylabel(\"$N(t)$\")\nplt.title(\"Malthusian growth prediction\")\nplt.axvspan(4.25, t[-1], color='gray', alpha=0.3)\nplt.text(4.65, 2.0, \"Prediction\\nPeriod\", ha='center', va='center', fontsize=11, color='black')\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 3"
  },
  {
    "objectID": "posts/2025-01-30-differential-equations/index.html#マルサスモデル",
    "href": "posts/2025-01-30-differential-equations/index.html#マルサスモデル",
    "title": "微分方程式を用いたToy models",
    "section": "",
    "text": "Exercise 1 : マルサスの人口論 \n時刻 \\(t\\) におけるとある国の人口が \\(N(t) &gt; 0\\) で表されるとする．マルサスは時刻 \\(t\\) から \\(t+\\Delta t\\) の人口増分 \\(\\Delta N = N(t+\\Delta) - N(t)\\) は\n\\[\n\\Delta N = k N(t)\\Delta t \\qquad (k: \\text{constant})\n\\]\nのように \\(N, \\Delta t\\) に比例するとした．ここから以下のように式変形を行い\n\\[\n\\frac{\\Delta N}{\\Delta t} = k N(t)\n\\]\n\\(\\Delta t\\to 0\\) として次のような微分方程式を得たとします\n\\[\n\\frac{dN(t)}{dt} = kN(t) \\label{eq-de-01}\n\\]\n\\((t, N(t))\\) が \\((0, 1.00 \\times 10^8), (1, 1.25 \\times 10^8)\\) と与えられているとき，\\(t = 2\\) の人口 \\(N(2)\\) を推定せよ．\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n微分方程式 \\(\\eqref{eq-de-01}\\) を以下のように変形し積分すると\n\\[\n\\begin{align}\n&\\frac{dN(t)}{dt} = kN(t) \\\\\n&\\Rightarrow \\int \\frac{1}{N(t)}\\frac{dN(t)}{dt} dt= \\int k dt \\\\\n&\\Rightarrow \\log \\vert N(t) \\vert = kt + C\\\\[5pt]\n&\\Rightarrow \\log N(t) = kt + C\n\\end{align}\n\\]\n従って，\n\\[\nN(t) = \\exp(C + kt) = \\tilde C\\exp(kt)\n\\]\n\\(t = 0\\) のときの \\(N(0) = N_0\\) とすると，\\(\\tilde C = N_0\\) でなければならないので\n\\[\nN(t) = N_0\\exp(kt) \\label{eq-malthus-solution}\n\\]\n\\((t, N(t))\\) が \\((0, 1.00 \\times 10^8), (1, 1.25 \\times 10^8)\\) と与えられているので，\n\\[\nN_0 = 1.00 \\times 10^8\n\\]\n次に\n\\[\n\\begin{align}\n&N(1) = 1.00 \\times 10^8 \\exp(k)\\\\[5pt]\n&\\Rightarrow \\exp(k) = 1.25\n\\end{align}\n\\]\n従って，\n\\[\nN(2) = (1.25)^2 \\times 10^8 \\approx 1.56 \\times 10^8\n\\]\n\n\n\n ▶  Python Simulation\nscipy.integrateパッケージのodeintを用いれば微分方程式を解くことができます．\n\nCode\nimport numpy as np\nfrom scipy.integrate import odeint\nimport matplotlib.pyplot as plt\n\n# malthusian growth func\ndef malthusian_model(y, t, k=np.log(1.25)):\n    dydt = k * y\n    return dydt\n\n# init\nN_0 = 1.0\n\n# data point\ndata = (0, 1), (1, 1.25)\n\n# time\nt = np.linspace(0, 5, 21)\n\n# solve\nn = odeint(malthusian_model, N_0, t)\n\n# plot\nplt.plot(t, n)\nplt.scatter(*zip(*data), color='red', label='observed data points')\nplt.legend()\nplt.xlabel(\"t\")\nplt.ylabel(\"$N(t)$\")\nplt.title(\"Malthusian gwrowth simulation\")\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 1\n\n\n\nFigure 1 をみると \\(N(t)\\) は指数関数的に増加していることが読み取れます．これは \\(k\\) の符号に依存しています．\n\n\\(k &gt; 0\\): 指数関数的増加\n\\(k = 0\\): 変化なし\n\\(k &lt; 0\\): 指数関数的減衰\n\nとなります．図示すると以下のようになります\n\nCode\nimport statsmodels.api as sm\n\n# params\nk_args = (-0.2, 0, 0.2)\n\n# solve\nfor k in k_args:\n    n = odeint(malthusian_model, N_0, t, args=(k,))\n    plt.plot(t, n, label=f\"k={k}\")\n\nplt.legend()\nplt.xlabel(\"t\")\nplt.ylabel(\"$N(t)$\")\nplt.title(\"Malthusian growth simulation with different $k$\")\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 2\n\n\n\n\n\n\n\n\n\n🍵 マルサスモデルの限界\n\n\n\nマルサスモデルは，\\(k &gt; 0\\) のとき人口が指数関数的に増加すると予測しています．実際には，食料や石油といった資源は有限であるので人口増加を抑制する要因があるため，現実でマルサスモデル的増加をすることは到底起こりえません．\n\n\n\n\n\n\\(N(t)\\) は 4期間ごとに観測される(=観測されるtは\\((0, 1, 2, 4)\\))\n観測される \\(N(t)\\) にはノイズが乗ってしまっている: \\(\\epsilon_t \\sim N(0, 0.1)\\)\n\nという状況ののもと，\\((N_0, k)\\) を推定し，\\(t&gt;4\\) の範囲の人口について予測することはできるのか？という問題を考えてみます．\n\\(\\eqref{eq-malthus-solution}\\) について対数を取ると\n\\[\n\\log N(t) = \\log(N_0) + kt\n\\]\nとなります．つまり，対数変換した変数についての線形モデルとして推定量を考えることができます．観測ノイズ \\(\\epsilon_t\\) を踏まえると，観測される人口を \\(\\tilde N(t)\\) とすると\n\\[\n\\begin{align}\n&\\tilde N(t) = N_0\\exp(kt) + \\epsilon_t\\\\\n&\\Rightarrow\\log \\tilde N(t) = \\log (N_0\\exp(kt) + \\epsilon_t)\n\\end{align}\n\\]\nとなってしまいますが，近似式として\n\\[\n\\log\\tilde N(t) = \\alpha + \\beta t + e_i\n\\]\nで推定するとします．\\(\\epsilon_i\\)がhomogeneousとしても\\(e_i\\)がhomogeneousとは限らないのでheteroskedasticity residual erroを想定して推定します．\n\nCode\nimport statsmodels.api as sm\n\nnp.random.seed(42)\n\n# observation step\nSTEP = 4\n\n# DGP\nactual_n = n.flatten()\nobserved_n = actual_n[::STEP][:-1] + +np.random.normal(0, 0.1, len(actual_n[::STEP][:-1]))\nobserved_t = t[::STEP][:-1]\nX = sm.add_constant(observed_t)\n\n# fit\nmodel = sm.OLS(np.log(observed_n), X).fit(cov_type=\"HC0\")\nestimated_n_0, estimated_k = model.params\n\n# simulation\nsimulated_n = odeint(malthusian_model, np.exp(estimated_n_0), t, args=(estimated_k,))\n\n# plot\nplt.plot(t, simulated_n, label=\"simulated\")\nplt.scatter(observed_t, observed_n, color=\"gray\", alpha=0.8, marker='x', label=\"actual data points\")\nplt.scatter(t, actual_n, color=\"red\", alpha=0.8, label=\"actual data points\")\nplt.legend()\nplt.xlabel(\"t\")\nplt.ylabel(\"$N(t)$\")\nplt.title(\"Malthusian growth prediction\")\nplt.axvspan(4.25, t[-1], color='gray', alpha=0.3)\nplt.text(4.65, 2.0, \"Prediction\\nPeriod\", ha='center', va='center', fontsize=11, color='black')\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 3"
  },
  {
    "objectID": "posts/2025-01-30-differential-equations/index.html#ヴェアフルストの人口論",
    "href": "posts/2025-01-30-differential-equations/index.html#ヴェアフルストの人口論",
    "title": "微分方程式を用いたToy models",
    "section": "ヴェアフルストの人口論",
    "text": "ヴェアフルストの人口論\n人口過密の要因を考慮に入れてマルサスモデルを修正したのがヴェアフルストモデルです．\n ▶  仮定の設定\n\n人口の上限 \\(N_\\infty\\) が存在する\n現在の人口を \\(N(t)\\) としたとき，人口増加 \\(\\Delta N(t)\\) は \\(N(t)\\) と \\(\\displaystyle 1 - \\frac{N(t)}{N_\\infty}\\) と時間区間 \\(\\Delta\\) に比例する\n\n ▶  問題の定式化\n比例定数を \\(k\\) としたとき\n\\[\n\\Delta N(t) = kN(t)\\left(1 - \\frac{N(t)}{N_\\infty}\\right)\\Delta t\n\\]\n\\(\\Delta t\\to 0\\) と極限をとると\n\\[\n\\frac{dN(t)}{dt} = kN(t)\\left(1 - \\frac{N(t)}{N_\\infty}\\right)\\label{eq-logistic-model}\n\\]\n人口変化は上記のような一階上微分方程式で表せるという形で定式化できました．\n ▶  モデルを解く\n\\(\\eqref{eq-logistic-model}\\) を変形すると\n\\[\n\\frac{N_\\infty}{N_\\infty - N(t)}\\frac{dN(t)}{N(t)dt} = k\n\\]\n両辺を \\(t\\) について積分すると\n\\[\n\\begin{align}\n& \\int\\frac{N_\\infty}{N_\\infty - N(t)}\\frac{dN(t)}{N(t)dt} dt= \\int k dt\\\\\n&\\Rightarrow \\int\\left(\\frac{1}{N(t)}+\\frac{1}{N_\\infty - N(t)}\\right)dN(t) = \\int k dt\\\\\n&\\Rightarrow \\log N(t) - \\log(N_\\infty - N(t)) = kt + C\\\\\n&\\Rightarrow \\log \\frac{N(t)}{N_\\infty - N(t)} = kt + C\n\\end{align}\n\\]\nこのとき，\\(N(0) = N_0\\) と初期条件が与えられたとすると\n\\[\n\\exp(C) = \\frac{N_0}{N_\\infty - N_0}\n\\]\nよって，\n\\[\n\\frac{N(t)}{N_\\infty - N(t)} = \\frac{N_0}{N_\\infty - N_0}\\exp(kt)\n\\]\nこれを \\(N(t)\\) についてとくと，\n\\[\nN(t) = \\frac{N_\\infty}{1 + [(N_\\infty/N_0 - 1)]\\exp(-kt)}\n\\]\nまたは\n\\[\n\\frac{1}{N(t)} = \\frac{1}{N_\\infty} + \\left(\\frac{1}{N_0} - \\frac{1}{N_\\infty}\\right)\\exp(-kt)\n\\]\n ▶  解釈\n\\(t\\to\\infty\\) のとき，\\(\\lim_{t\\to\\infty}\\exp(-kt) = 0\\) より\n\\[\n\\lim_{t\\to\\infty}N(t) = N_\\infty\n\\]\nとなることがわかります．初期値に応じて \\(N_\\infty\\) へ到達する経路は異なります．仮に \\(N_\\infty = 12, k=0.2\\) として，初期値が \\((1, 3, 6, 9, 12, 15)\\) と異なる水準で与えられたとします．\n\n\nCode\nfrom scipy.integrate import solve_ivp\n\n\n# Define logistic growth model\ndef logistic_growth(t, N, k=0.2, M=12):\n    dydt = k * N * (1 - N / M)\n    return dydt\n\n# Set up the grid for the direction field\nt_vals = np.linspace(0, 30, 20)  # Time values\nP_vals = np.linspace(0, 16, 20)  # Population values\nT, P = np.meshgrid(t_vals, P_vals)\n\n# Compute direction field (dP/dt values)\ndP_dt = logistic_growth(None, P)\n\n# Normalize arrows for visualization\nnorm = np.sqrt(1**2 + dP_dt**2)\nU = 1 / norm  # Time step is 1 (arbitrary)\nV = dP_dt / norm  # Scale arrows properly\n\n# Plot the direction field\nplt.figure(figsize=(8, 5))\nplt.quiver(T, P, U, V, color=\"gray\", alpha=0.7) # [T, P]: arrow location, [U, V]: arrow direction\n\n# Solve the ODE for different initial conditions\ninitial_conditions = [1, 3, 6, 9, 12, 15,]\nt_span = (0, 30)\nt_eval = np.linspace(0, 30, 100)\n\nfor P0 in initial_conditions:\n    sol = solve_ivp(logistic_growth, t_span, [P0], t_eval=t_eval)\n    if sol.success:\n        plt.plot(sol.t, sol.y[0], linewidth=2, label=f\"P(0)={P0}\")\n    else:\n        raise ValueError(\"computation failed\")\n\n# Labels and title\nplt.xlabel(\"t\")\nplt.ylabel(\"P(t)\")\nplt.title(\"Logistic Growth Model\")\nplt.legend()\nplt.grid()\n\n# Show the plot\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\\(0&lt; N_0 &lt; N_\\infty\\): はじめの増加は指数関数的だが，ある程度の水準から増加の度合いは減衰していく\n\\(N_0 = N_\\infty\\): 変化なし\n\\(N_0 &gt; N_\\infty\\): \\(N_\\infty\\)に近づく方向で減少していく．減衰の度合いは減衰していく\n\\(N_0 = 0\\): これも一つの均衡だが，ちょっとしたショックがあるだけで \\(N_\\infty\\) を目指すPathに乗ってしまう(= unstable equilibrium)\n\n ▶  Validation\nヴェアフルストモデルが人口動態を表した良いモデルなのか，1820-1930のアメリカの人口データを用いて検証してみます．\n\n\nCode\nimport pandas as pd\n\n# Historical population data (year, population in millions)\ndata = {\n    \"year\": [1820, 1830, 1840, 1850, 1860, 1870, 1880, 1890, 1900, 1910, 1920, 1930, 2000],\n    \"us_population_million\": [9.6, 12.9, 17.1, 23.2, 31.4, 38.6, 50.2, 62.9, 76.0, 92.0, 106.5, 123.2, 282.2]\n}\n\n# Create DataFrame\ndf = pd.DataFrame(data)\n\n# Display table\ndf\n\n\n\n\n\n\n\n\n\nyear\nus_population_million\n\n\n\n\n0\n1820\n9.6\n\n\n1\n1830\n12.9\n\n\n2\n1840\n17.1\n\n\n3\n1850\n23.2\n\n\n4\n1860\n31.4\n\n\n5\n1870\n38.6\n\n\n6\n1880\n50.2\n\n\n7\n1890\n62.9\n\n\n8\n1900\n76.0\n\n\n9\n1910\n92.0\n\n\n10\n1920\n106.5\n\n\n11\n1930\n123.2\n\n\n12\n2000\n282.2\n\n\n\n\n\n\n\nパラメーターを \\(N_0 = 3.9, k = 0.3134, N_\\infty = 197\\) と選ぶと\n\nCode\nt_index = np.linspace(0, (df.shape[0] + 10), 100)\nsol = solve_ivp(logistic_growth, [0, t_index[-1]], [3.9], t_eval=t_index, args=(0.3134, 197))\nplt.plot(1790 + sol.t*10, sol.y[0], linewidth=2, label=f\"prediction\")\nplt.scatter(\n    df.year,\n    df.us_population_million,\n    color=\"gray\",\n    alpha=0.8,\n    marker=\"x\",\n    label=\"actual data points\",\n)\nplt.xlabel('year')\nplt.ylabel('population(million)')\nplt.legend()\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 4: Model prediction vs actual USA population\n\n\n\nこのように, 1800-1930年のアメリカ人口動態を上手く説明するモデルとなっていることがわかります．一方，モデルの上限は \\(197\\times 10^6\\) であるが，2000年の人口は \\(282.2\\times 10^6\\) となっており，長期における人口動態を説明できるものにはなっていないことも読み取れます．\n\\(N_\\infty\\) の仮定が間違っていたと解釈することが一つ考えられますが，人口変化を支配する法則は技術変化や政治といった要因に影響を受けるため，常に同じ支配法則に基づいていると仮定することが間違っているとも解釈することが出来ます．"
  },
  {
    "objectID": "posts/2025-05-30-how-to-write-document/index.html",
    "href": "posts/2025-05-30-how-to-write-document/index.html",
    "title": "ドキュメントの書き方",
    "section": "",
    "text": "この記事のスコープ\n\n\n\n\nドキュメントを書くにあたっての基本ルールの紹介"
  },
  {
    "objectID": "posts/2025-05-30-how-to-write-document/index.html#ドキュメントに何を書くかwhat",
    "href": "posts/2025-05-30-how-to-write-document/index.html#ドキュメントに何を書くかwhat",
    "title": "ドキュメントの書き方",
    "section": "ドキュメントに何を書くか？(What)",
    "text": "ドキュメントに何を書くか？(What)\nドキュメントとは「ある情報を、ある対象に伝える」ための手段です．ドキュメントを書くにあたって事前に\n\n「誰に」対して\n「何を」伝えるか\n\nを明確化し，その目的に応じて構成や表現を設計することが重要です．\n\nExample 1 : ドキュメント種類別の読み手と目的整理表\n\n\n\n\n\n\n\n\n\nドキュメント種類\n誰に\n何を\n\n\n\n\n企画書\n経営層・チームマネジャー・開発メンバー\nPJの目的・スコープ・予算・スケジュール\n\n\n要件定義書\nエンジニア\nシステムの機能要件・非機能要件\n\n\n基本設計書\nエンジニア\nシステムの動作仕様・インターフェース仕様\n\n\n詳細設計\nエンジニア\nソフトウェアの内部構造・モジュール感のインターフェース・データ構造\n\n\nテスト仕様書\nプロダクトマネジャー・エンジニア\nテスト項目・テストデータ・テスト結果\n\n\nユーザーマニュアル\nユーザー\n機能の説明・利用目的・操作方法\n\n\n管理・保守マニュアル\nシステム管理者\n管理や保守に関する機能の説明・利用目的・操作方法\n\n\nリリースノート\nユーザー・システム管理者\nプロダクトのアップデートに伴う変更点\n\n\n\n\n\n\n読み手の定義\n\nルール\n「誰に」対してを特定する際，以下の３つを明確化することが有用です：\n\n読み手の目的・ニーズ\n読み手の知識レベル\n読み手の立場\n\n説明\n\n目的が違えば、必要な情報・深さ・順序が変わる\n\n\n意思決定者 → 意思決定や承認に足る根拠がほしい → 結論とインパクト重視\n現場担当者 → どう使うか／どう実装するかの具体的な手順を知りたい → 詳細手順や実装方法が重要\n\n\n知識レベルが違えば 説明の粒度・用語の選び方・例の使い方が変わる\n\n\n初心者 → 用語の定義や背景から丁寧に\n専門家 → 論点にフォーカスし冗長さを排除\n\n\n同じ事実でも、立場によって関心ポイントが異なる\n\n\n営業 → 顧客影響やKPIに注目\nエンジニア → 技術的妥当性や仕組みが重要\n\n例: ユーザーマニュアルと開発者マニュアルのアウトラインの差異\n\n\n\n\n\n\n\n\n\n種類\nアウトライン構成方針\n例\n\n\n\n\nユーザーマニュアル\nユーザーが操作する順番\n初期設定 → ログイン → 基本操作 → 応用操作 → トラブル対応\n\n\n開発者マニュアル\n開発者が開発する順番\n環境構築 → モジュール設計 → API定義 → データ構造 → エラーハンドリング\n\n\n\n\nアンチパターンと改善例\n\n\n\n\n\n\nアンチパターン: 読み手の定義がぼやけている\n\n\n\n\nプロダクトのユーザーに，プロダクトの使い方を伝える\n\n\n\n\n\n\n\n\n\n改善例:\n\n\n\n\nプロダクトを新規導入するシステム管理者に，プロダクトの導入手順を伝える\nプロダクトの利用中にエラーに遭遇したユーザーに，エラーの原因と対処方法を伝える"
  },
  {
    "objectID": "posts/2025-05-30-how-to-write-document/index.html#どのようにドキュメントを書くかhow",
    "href": "posts/2025-05-30-how-to-write-document/index.html#どのようにドキュメントを書くかhow",
    "title": "ドキュメントの書き方",
    "section": "どのようにドキュメントを書くか？(How)",
    "text": "どのようにドキュメントを書くか？(How)\n良いドキュメントを書くためには、次の３点を押さえる必要があります：\n\nEffectiveness; 必要な情報を正しく伝えられる, 合目的的であること\nEfficiency: 効率よく内容が理解できる, readability\nSatisfaction: 読み手に対する配慮があること\n\n\nEffectiveness\n\n\n\n説明\n\n書き表された情報が読み手に一意に伝わること\n書き表された情報がドキュメントの目的と合致していること\n\nアクション\n\n\nメインメッセージの構成要素が漏れなく分解されている\n曖昧さを廃し，明確な文章で書く\n誤解なく読める文章で書く\nできるだけ具体的に書く\n\n\n\n\nEfficiency\n\n\n\n説明\n\n効率よく内容が理解できること\n読み手は流し読みする傾向があるので，流し読みでも情報が伝わるように構成立てること\n\nアクション\n\n\n要点を先に伝える(MMUF, Main Message Up-Front)\n話の流れを整理し，どこに何が書いてあるかわかりやすくする(=アウトライン設計)\n\nドキュメントを書く前に事前にアウトライン設計（どこに何を書くのか）\n文章ブロックに対して，書かれている内容を端的に表す見出しを付ける\none heading, one message\n\n必要な情報だけに絞り，簡潔で読みやすい文章にする\n\n\n\n\nSatisfaction\n\n\n\n説明\n\n読み手が「読んでよかった」「わかりやすかった」と感じられること\nストレスなく読める体験が提供されていること\n\nアクション\n\n\n読み手の立場・前提知識・目的を想定して内容や語り口を調整する\n図表・余白・見出しなどで視認性を高める\n論理の正確さだけでなく、文の印象・ニュアンスにも気を配る\n\n\n\n\nわかりやすい文の書き方\n\n\n\n\n\n\n文を書き始めるのはアウトライン設計後\n\n\n\n\n文章はすぐに書き始めるのではなく，まず「構造」＝アウトラインを先に設計する\n\n\n\nわかりやすい文を書くにあたって，次の4点を抑える必要があります\n\n係り受けを明確にする\n並列関係を明確にする\n順序関係を明確にする\n「の」は一つの文に２つまでに留める\n\n\n係り受けを明確にする\n\n\n説明\n\n誤解を招く文の原因の一つが，係り受けの曖昧さ\n係り受けはできる限り近い位置に配置するべき\n\n例\n\n❌ 簡単なチャットアプリの作り方\n👍 チャットアプリの簡単な作り方\n\n\n\n並列関係を明確にする\n\n\n説明\n\n並列する要素（AとB、～や～など）は、文法的・意味的に対等な構造で書く必要がある\n並列構造が乱れると、何が並列なのか、読み手が混乱する\n\n例\n\n❌ このツールは、設定の保存、読み込み、そしてファイルの圧縮ができます\n👍 このツールは、設定の保存・読み込み、ファイルの圧縮ができます\n\n\n\n順序関係を明確にする\n\n\n説明\n\n複数の出来事や手順がある場合は、どの順で発生・実行されるかを明確にすることが重要\n順序が不明瞭だと、因果関係や手順が誤解されやすくなる\n\n例\n\n❌ 入力が完了したら、ファイルを保存し、名前を入力してください\n👍 入力が完了したら、名前を入力し、その後でファイルを保存してください\n\n\n\n「の」は一つの文に２つまでに留める\n\n\n説明\n\n「の」を多用すると、文の構造が複雑になり、意味があいまいになる\nそのため、一文に「の」は2つまでに抑えるのが、読みやすさの目安。\n\n例\n\n❌ データ処理の高速化のためのアルゴリズムの最適化手法の調査\n👍 データ処理を高速化するための、アルゴリズム最適化手法の調査\n👍 アルゴリズム最適化手法について、データ処理を高速化する観点から調査した"
  },
  {
    "objectID": "posts/2025-05-30-how-to-write-document/index.html#アンチパターンと発生原因",
    "href": "posts/2025-05-30-how-to-write-document/index.html#アンチパターンと発生原因",
    "title": "ドキュメントの書き方",
    "section": "アンチパターンと発生原因",
    "text": "アンチパターンと発生原因\n\n\n\n\n\n\nProblem 1: なにを書いていいかわからない\n\n\n\n\n\n\n\n\nドキュメントの目的がわかっていない\nドキュメントの目的から導き出されるテーマについて，その構成要素を分解できていない\n\n\n\n\n\n\n\n\nProblem 2: あれもこれもと，情報詰め込んでしまう\n\n\n\n\n\n\n\n\n読み手とテーマが明確に定義されていない\n\n\n\n\n\n\n\n\nProblem 3: 自分で説明するとき，何故か説明しづらい\n\n\n\n\n\n\n\n\nドキュメントの目的に対して，テーマが十分分解されていない\n分解されたテーマの配置が不自然な流れになっている\n\nheadingsとkey takeawaysだけ読んでみたとき，目が止まってしまう or 順番が飛んでしまう\n\n\n\n\n\n\n\n\n\nProblem 4: 何が言いたいかわからないheadingsがある\n\n\n\n\n\n\n\n\nkey takeawaysが定義されていない\nMMUFの構成になっていない\n\n\n\n\n\n\n\n\nProblem 5: 作成したユーザーマニュアルが読みづらいと言われた\n\n\n\n\n\n\n\n\n各見出しにおける想定ユーザーが明確に定義されていない\n想定ユーザーについて，書き手が仮定した読み手知識レベルが対応していない\n読み手を主語にした文となっていない\n\nユーザーマニュアルは読者の立場に立った指示やガイドを提供するべき"
  },
  {
    "objectID": "posts/2025-05-30-how-to-write-document/index.html#appendix-パラグラフと段落の違い",
    "href": "posts/2025-05-30-how-to-write-document/index.html#appendix-パラグラフと段落の違い",
    "title": "ドキュメントの書き方",
    "section": "Appendix: パラグラフと段落の違い",
    "text": "Appendix: パラグラフと段落の違い\n「パラグラフ」と「段落」は、日常的には同じ意味で使われることも多いですが、ドキュメント作成の文脈では以下のような差異が有ります:\n\n\n\n\n\n\n\n\n\n用語\n視点\n意味\n\n\n\n\n段落\n見た目\n改行による文章の区切り何を１段落にまとめるかの自由度が高い\n\n\nパラグラフ\n意味\n1つの主張を持った論理的な文の集まり1 paragraph 1 topic\n\n\n\n\nPragraphの構成\n1つのパラグラフは、原則として以下のような構造で成り立っています：\n\n\n\n\n\n\n\n\n構成要素\n説明\n\n\n\n\ntopic sentence\nパラグラフの最初に置かれ、その段落で述べたい中心的な主張やポイントを示す\n\n\nsupport sentence\n「なぜそう言えるのか？」「どんな意味があるのか？」を展開する"
  },
  {
    "objectID": "posts/2025-05-30-how-to-write-document/index.html#references",
    "href": "posts/2025-05-30-how-to-write-document/index.html#references",
    "title": "ドキュメントの書き方",
    "section": "References",
    "text": "References\n\n構造化されたストーリーとしてのスライド"
  },
  {
    "objectID": "posts/2025-02-26-law-of-cosines/index.html",
    "href": "posts/2025-02-26-law-of-cosines/index.html",
    "title": "余弦定理の考え方",
    "section": "",
    "text": "Exercise 1 \n\\(AC = 30, BC = 26, \\angle C = 70^\\circ\\) となるような \\(\\triangle ABC\\) が与えられたとします．このとき，長さ \\(AB\\) を求めよ\n\n\n\nCode\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport matplotlib.patches as patches\n\n# 辺の長さと角度\nAC = 30\nBC = 26\nangle_C = 70\n\n# 角度をラジアンに変換\nangle_C_rad = np.radians(angle_C)\n\n# 点Aの座標\nA = (0, 0)\n\nAB = np.sqrt(30**2 + 26**2 - 2 * 30 * 26 * np.cos(np.radians(70)))\n\n# 点Bの座標\nB = (AB, 0)\n\n# 点Cの座標\ncos_A = (30**2 + AB**2 - 26**2) / (2 * 30 * AB)\nsin_A = np.sqrt(1 - cos_A**2)\nC = (30 * cos_A, 30 * sin_A)\n\nslope = - (C[0] - B[0])/(C[1] - B[1])\nH = (24.6, 24.6 * slope)\n\n\n# 座標をリストに変換\nfig, ax = plt.subplots(figsize=(6, 6))\n\nax.plot([A[0], H[0]], [A[1], H[1]], \"k\")  # Black line with circle markers\nax.plot([A[0], B[0]], [A[1], B[1]], \"ko-\")  # Black line with circle markers\nax.plot([B[0], C[0]], [B[1], C[1]], \"ko-\")  # Black line with circle markers\nax.plot([C[0], A[0]], [C[1], A[1]], \"ko-\")  # Black line with circle markers\n\n# 点のラベル\nplt.text(H[0]-2, H[1], \"H\")\nplt.text(A[0]-2, A[1], \"A\")\nplt.text(B[0]+1, B[1], \"B\")\nplt.text(C[0]+1, C[1], \"C\")\n\n# 軸の範囲を設定\nplt.xlim(-5, 35)\nplt.ylim(-5, 35)\n\n# 軸のラベルを設定\nplt.xlabel(\"X\")\nplt.ylabel(\"Y\")\n\n# タイトルを設定\nplt.title(\"Triangle ABC\")\n\n# Add angles as arcs\narc_radius = 5  # Radius for the arcs\n\n# Angle at B\nangle_C_arc = patches.Arc(C, arc_radius*0.8, arc_radius*0.8, angle=250, theta1=np.degrees(320), theta2=np.degrees(70), color='blue')\nax.add_patch(angle_C_arc)\nax.text(C[0]-1, C[1] - arc_radius*.8, f\"{70}°\", fontsize=12, color='blue')\n# ax.text(C[0] + arc_radius/2, B[1] + 1, f\"{70}°\", fontsize=12, color='blue')\nax.text(5, 10, \"AC = 30\", fontsize=12, color='black', horizontalalignment='center')\nax.text(30, 10, \"BC = 26\", fontsize=12, color='black', horizontalalignment='center')\n\n# 図の表示\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 1\n\n\n\nこのとき，点 \\(A\\) から \\(BC\\) に対して垂線を下ろし，その交点を \\(H\\) とします．このとき\n\\[\n\\begin{align}\nCH &= AC * \\cos(C)\\\\\nBH &= BC - AC * \\cos(C)\\\\\nAH& = AC * \\sin(C)\n\\end{align}\n\\]\nピタゴラスの定理より\n\\[\nAB^2 = AH^2 + BH^2\n\\]\nなので\n\\[\n\\begin{align}\nAB^2 &= (BC - AC * \\cos(C))^2 + (AC * \\sin(C))^2\\\\\n     &= BC^2 + AC^2 - 2\\cdot BC\\cdot AC \\cos(C)\n\\end{align}\n\\]\n従って，\n\n\nCode\nprint(f\"AB = {AB:.2f}\")\n\n\nAB = 32.29\n\n\n ▶  ベクトルを用いた直感的理解\nベクトルの内積は \\(\\vec a \\cdot \\vec b = \\lvert a \\rvert \\lvert b \\rvert \\cos \\theta\\) で定義されることを利用すると，\n\\[\n\\begin{aligned}\nAB^2\n    &= \\left\\lvert \\overrightarrow{CA} - \\overrightarrow{CB} \\right\\rvert^2 \\\\\n    &= (\\overrightarrow{CA} - \\overrightarrow{CB}) \\cdot (\\overrightarrow{CA} - \\overrightarrow{CB}) \\\\\n    &= \\left\\lvert \\overrightarrow{CA} \\right\\rvert^2 + \\left\\lvert \\overrightarrow{CB} \\right\\rvert^2\n    - 2 \\overrightarrow{CA} \\cdot \\overrightarrow{CB} \\\\\n    &= \\left\\lvert \\overrightarrow{CA} \\right\\rvert^2 + \\left\\lvert \\overrightarrow{CB} \\right\\rvert^2\n    - 2 \\left\\lvert \\overrightarrow{CA} \\right\\rvert \\left\\lvert \\overrightarrow{CB} \\right\\rvert \\cos(\\angle ACB) \\\\\n    &= AC^2 + BC^2  - 2\\cdot AC\\cdot BC \\cos(C)\n\\end{aligned}\n\\]\n\n\n\n\nExercise 2 \n四角形PABQ が以下のように与えられている\n\n\\(AB = 10\\)\n\\(\\angle PAB = {75}^\\circ\\)\n\\(\\angle PBA = {50}^\\circ\\)\n\\(\\angle PAQ = {40}^\\circ\\)\n\\(\\angle QAB = {35}^\\circ\\)\n\\(\\angle PBQ = {70}^\\circ\\)\n\nこのとき，PQの距離を求めよ．\n\nCode\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport matplotlib.patches as patches\n\n# 辺の長さと角度\nAB = 10\nangle_PAB = np.radians(75)\nangle_PBA = np.radians(50)\nangle_QAB = np.radians(35)\nangle_AQB = np.radians(25)\nangle_QBA = np.radians(120)\nangle_APB = np.radians(55)\n\n\n# 点Aの座標\nA = (0, 0)\n\n# 点Bの座標\nB = (AB, 0)\n\n# 点Pの座標\nPA = AB / np.sin(angle_APB) * np.sin(angle_PBA)\nP = ((np.cos(angle_PAB)) * PA, (np.sin(angle_PAB)) * PA)\n\n# 点Qの座標\nQA = AB / np.sin(angle_AQB) * np.sin(angle_QBA)\nQ = ((np.cos(angle_QAB)) * QA, (np.sin(angle_QAB)) * QA)\n\n\n# 座標をリストに変換\nfig, ax = plt.subplots(figsize=(6, 6))\n\nax.plot([A[0], P[0]], [A[1], P[1]], \"k\")  # Black line with circle markers\nax.plot([A[0], B[0]], [A[1], B[1]], \"ko-\")  # Black line with circle markers\nax.plot([B[0], P[0]], [B[1], P[1]], \"ko-\")  # Black line with circle markers\nax.plot([Q[0], A[0]], [Q[1], A[1]], \"ko-\")  # Black line with circle markers\nax.plot([Q[0], B[0]], [Q[1], B[1]], \"ko-\")  # Black line with circle markers\nax.plot([Q[0], P[0]], [Q[1], P[1]], \"ko-\")  # Black line with circle markers\n\n# 点のラベル\nplt.text(A[0] - 1, A[1], \"A\")\nplt.text(B[0] + 1, B[1], \"B\")\nplt.text(P[0], P[1] + 1, \"P\")\nplt.text(Q[0] + 1, Q[1], \"Q\")\n\n# 軸の範囲を設定\nplt.xlim(-2, 20)\nplt.ylim(-2, 20)\n\n# 軸のラベルを設定\nplt.xlabel(\"X\")\nplt.ylabel(\"Y\")\n\n# タイトルを設定\nplt.title(\"How far is the distance between P and Q\")\n\n# Add angles as arcs\narc_radius = 5  # Radius for the arcs\n\n# Angle at B\nax.text(A[0] + 1, A[1] + 1.8, f\"{40}°\", fontsize=10, color=\"blue\")\nax.text(A[0] + 1, A[1] + 0.2, f\"{35}°\", fontsize=10, color=\"blue\")\nax.text(B[0] - 2, B[1] + 0.2, f\"{50}°\", fontsize=10, color=\"blue\")\nax.text(B[0] - 0.5, B[1] + 1, f\"{70}°\", fontsize=10, color=\"blue\")\n# ax.text(C[0] + arc_radius/2, B[1] + 1, f\"{70}°\", fontsize=12, color='blue')\nax.text(5, -1, \"AB = 10\", fontsize=12, color=\"black\", horizontalalignment=\"center\")\nax.text(\n    (P[0] + Q[0]) / 2,\n    (P[1] + Q[1]) / 2 + 1,\n    \"PQ = ???\",\n    fontsize=12,\n    color=\"black\",\n    horizontalalignment=\"center\",\n)\n\n\n# 図の表示\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 2\n\n\n\n\n\n\n\n\n\n\n\n\nSolution 1: 余弦定理を用いて解く\n\n\n\n\n\n\\(\\angle PAQ = {40}^\\circ\\) と問題分よりわかるので，\\(PA, QA\\) の長さがわかれば余弦定理より \\(PQ\\) が導出できます．\n正弦定理を用いて\n\\[\n\\begin{align}\nPA &= \\frac{AB}{\\sin({55}^\\circ)}\\times \\sin({50}^\\circ)\\\\\nQA &= \\frac{AB}{\\sin({25}^\\circ)}\\times \\sin({120}^\\circ)\n\\end{align}\n\\]\n余弦定理を用いると\n\\[\nPQ^2 = QA^2 + PA^2 - 2(PA)(QA)\\cos({40}^\\circ)\n\\]\nよって，\n\n\nCode\n# set variables\nAB = 10\nangle_APB = np.radians(55)\nangle_AQB = np.radians(25)\nangle_PBA = np.radians(50)\nangle_QBA = np.radians(120)\nangle_PAQ = np.radians(40)\n\n\n# compute PA and QA\nPA = AB / np.sin(angle_APB) * np.sin(angle_PBA)\nQA = AB / np.sin(angle_AQB) * np.sin(angle_QBA)\n\n\n# comnpute PQ using laws of cosines\nPQ = np.sqrt(PA ** 2 + QA **2 - 2 * PA * QA * np.cos(angle_PAQ))\n\nprint(f\"PQ = {PQ:.2f}\")\n\n\nPQ = 14.62\n\n\n\n\n\n\n\n\n\n\n\n\nSolution 2: 座標を用いて解く\n\n\n\n\n\n各点を \\(XY\\) 平明座標に以下のように置き換えます\n\n\\(A\\) = (0, 0)\n\\(B\\) = (0, 10)\n\nこのとき，点 \\(P\\) の座標 \\((P_X, P_Y)\\) は\n\\[\n\\begin{align}\nP_X & = PA \\cdot \\cos({75}^\\circ)\\\\\nP_Y & = PA \\cdot \\sin({75}^\\circ)\n\\end{align}\n\\]\n同様に点 \\(Q\\) の座標 \\((Q_X, Q_Y)\\) は\n\\[\n\\begin{align}\nQ_X & = QA \\cdot \\cos({35}^\\circ)\\\\\nQ_Y & = QA \\cdot \\sin({35}^\\circ)\n\\end{align}\n\\]\nこのとき，長さ \\(PQ\\) は点 \\(P, Q\\) の距離と表せるので\n\\[\n\\begin{align}\nPQ &= \\lVert P - Q \\rVert\\\\\n   &= \\sqrt{(P_X - Q_X)^2 + (P_Y - Q_Y)^2}\\\\\n   &= \\sqrt{(AQ^2 + PA^2 - 2(PA)(QA)(\\cos({35}^\\circ)\\cos({75}^\\circ) + \\sin({35}^\\circ)\\sin({75}^\\circ)))}\n\\end{align}\n\\]\n加法定理より\n\\[\n\\cos (A \\pm B) = \\cos A \\cos B \\mp \\sin A \\sin B\n\\]\nなので\n\\[\n\\cos({35}^\\circ)\\cos({75}^\\circ) + \\sin({35}^\\circ)\\sin({75}^\\circ) = \\cos({40}^\\circ)\n\\]\n従って，\n\\[\nPQ^2 = QA^2 + PA^2 - 2(PA)(QA)\\cos({40}^\\circ)\n\\]"
  },
  {
    "objectID": "posts/2025-02-26-law-of-cosines/index.html#余弦定理の考え方",
    "href": "posts/2025-02-26-law-of-cosines/index.html#余弦定理の考え方",
    "title": "余弦定理の考え方",
    "section": "",
    "text": "Exercise 1 \n\\(AC = 30, BC = 26, \\angle C = 70^\\circ\\) となるような \\(\\triangle ABC\\) が与えられたとします．このとき，長さ \\(AB\\) を求めよ\n\n\n\nCode\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport matplotlib.patches as patches\n\n# 辺の長さと角度\nAC = 30\nBC = 26\nangle_C = 70\n\n# 角度をラジアンに変換\nangle_C_rad = np.radians(angle_C)\n\n# 点Aの座標\nA = (0, 0)\n\nAB = np.sqrt(30**2 + 26**2 - 2 * 30 * 26 * np.cos(np.radians(70)))\n\n# 点Bの座標\nB = (AB, 0)\n\n# 点Cの座標\ncos_A = (30**2 + AB**2 - 26**2) / (2 * 30 * AB)\nsin_A = np.sqrt(1 - cos_A**2)\nC = (30 * cos_A, 30 * sin_A)\n\nslope = - (C[0] - B[0])/(C[1] - B[1])\nH = (24.6, 24.6 * slope)\n\n\n# 座標をリストに変換\nfig, ax = plt.subplots(figsize=(6, 6))\n\nax.plot([A[0], H[0]], [A[1], H[1]], \"k\")  # Black line with circle markers\nax.plot([A[0], B[0]], [A[1], B[1]], \"ko-\")  # Black line with circle markers\nax.plot([B[0], C[0]], [B[1], C[1]], \"ko-\")  # Black line with circle markers\nax.plot([C[0], A[0]], [C[1], A[1]], \"ko-\")  # Black line with circle markers\n\n# 点のラベル\nplt.text(H[0]-2, H[1], \"H\")\nplt.text(A[0]-2, A[1], \"A\")\nplt.text(B[0]+1, B[1], \"B\")\nplt.text(C[0]+1, C[1], \"C\")\n\n# 軸の範囲を設定\nplt.xlim(-5, 35)\nplt.ylim(-5, 35)\n\n# 軸のラベルを設定\nplt.xlabel(\"X\")\nplt.ylabel(\"Y\")\n\n# タイトルを設定\nplt.title(\"Triangle ABC\")\n\n# Add angles as arcs\narc_radius = 5  # Radius for the arcs\n\n# Angle at B\nangle_C_arc = patches.Arc(C, arc_radius*0.8, arc_radius*0.8, angle=250, theta1=np.degrees(320), theta2=np.degrees(70), color='blue')\nax.add_patch(angle_C_arc)\nax.text(C[0]-1, C[1] - arc_radius*.8, f\"{70}°\", fontsize=12, color='blue')\n# ax.text(C[0] + arc_radius/2, B[1] + 1, f\"{70}°\", fontsize=12, color='blue')\nax.text(5, 10, \"AC = 30\", fontsize=12, color='black', horizontalalignment='center')\nax.text(30, 10, \"BC = 26\", fontsize=12, color='black', horizontalalignment='center')\n\n# 図の表示\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 1\n\n\n\nこのとき，点 \\(A\\) から \\(BC\\) に対して垂線を下ろし，その交点を \\(H\\) とします．このとき\n\\[\n\\begin{align}\nCH &= AC * \\cos(C)\\\\\nBH &= BC - AC * \\cos(C)\\\\\nAH& = AC * \\sin(C)\n\\end{align}\n\\]\nピタゴラスの定理より\n\\[\nAB^2 = AH^2 + BH^2\n\\]\nなので\n\\[\n\\begin{align}\nAB^2 &= (BC - AC * \\cos(C))^2 + (AC * \\sin(C))^2\\\\\n     &= BC^2 + AC^2 - 2\\cdot BC\\cdot AC \\cos(C)\n\\end{align}\n\\]\n従って，\n\n\nCode\nprint(f\"AB = {AB:.2f}\")\n\n\nAB = 32.29\n\n\n ▶  ベクトルを用いた直感的理解\nベクトルの内積は \\(\\vec a \\cdot \\vec b = \\lvert a \\rvert \\lvert b \\rvert \\cos \\theta\\) で定義されることを利用すると，\n\\[\n\\begin{aligned}\nAB^2\n    &= \\left\\lvert \\overrightarrow{CA} - \\overrightarrow{CB} \\right\\rvert^2 \\\\\n    &= (\\overrightarrow{CA} - \\overrightarrow{CB}) \\cdot (\\overrightarrow{CA} - \\overrightarrow{CB}) \\\\\n    &= \\left\\lvert \\overrightarrow{CA} \\right\\rvert^2 + \\left\\lvert \\overrightarrow{CB} \\right\\rvert^2\n    - 2 \\overrightarrow{CA} \\cdot \\overrightarrow{CB} \\\\\n    &= \\left\\lvert \\overrightarrow{CA} \\right\\rvert^2 + \\left\\lvert \\overrightarrow{CB} \\right\\rvert^2\n    - 2 \\left\\lvert \\overrightarrow{CA} \\right\\rvert \\left\\lvert \\overrightarrow{CB} \\right\\rvert \\cos(\\angle ACB) \\\\\n    &= AC^2 + BC^2  - 2\\cdot AC\\cdot BC \\cos(C)\n\\end{aligned}\n\\]\n\n\n\n\nExercise 2 \n四角形PABQ が以下のように与えられている\n\n\\(AB = 10\\)\n\\(\\angle PAB = {75}^\\circ\\)\n\\(\\angle PBA = {50}^\\circ\\)\n\\(\\angle PAQ = {40}^\\circ\\)\n\\(\\angle QAB = {35}^\\circ\\)\n\\(\\angle PBQ = {70}^\\circ\\)\n\nこのとき，PQの距離を求めよ．\n\nCode\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport matplotlib.patches as patches\n\n# 辺の長さと角度\nAB = 10\nangle_PAB = np.radians(75)\nangle_PBA = np.radians(50)\nangle_QAB = np.radians(35)\nangle_AQB = np.radians(25)\nangle_QBA = np.radians(120)\nangle_APB = np.radians(55)\n\n\n# 点Aの座標\nA = (0, 0)\n\n# 点Bの座標\nB = (AB, 0)\n\n# 点Pの座標\nPA = AB / np.sin(angle_APB) * np.sin(angle_PBA)\nP = ((np.cos(angle_PAB)) * PA, (np.sin(angle_PAB)) * PA)\n\n# 点Qの座標\nQA = AB / np.sin(angle_AQB) * np.sin(angle_QBA)\nQ = ((np.cos(angle_QAB)) * QA, (np.sin(angle_QAB)) * QA)\n\n\n# 座標をリストに変換\nfig, ax = plt.subplots(figsize=(6, 6))\n\nax.plot([A[0], P[0]], [A[1], P[1]], \"k\")  # Black line with circle markers\nax.plot([A[0], B[0]], [A[1], B[1]], \"ko-\")  # Black line with circle markers\nax.plot([B[0], P[0]], [B[1], P[1]], \"ko-\")  # Black line with circle markers\nax.plot([Q[0], A[0]], [Q[1], A[1]], \"ko-\")  # Black line with circle markers\nax.plot([Q[0], B[0]], [Q[1], B[1]], \"ko-\")  # Black line with circle markers\nax.plot([Q[0], P[0]], [Q[1], P[1]], \"ko-\")  # Black line with circle markers\n\n# 点のラベル\nplt.text(A[0] - 1, A[1], \"A\")\nplt.text(B[0] + 1, B[1], \"B\")\nplt.text(P[0], P[1] + 1, \"P\")\nplt.text(Q[0] + 1, Q[1], \"Q\")\n\n# 軸の範囲を設定\nplt.xlim(-2, 20)\nplt.ylim(-2, 20)\n\n# 軸のラベルを設定\nplt.xlabel(\"X\")\nplt.ylabel(\"Y\")\n\n# タイトルを設定\nplt.title(\"How far is the distance between P and Q\")\n\n# Add angles as arcs\narc_radius = 5  # Radius for the arcs\n\n# Angle at B\nax.text(A[0] + 1, A[1] + 1.8, f\"{40}°\", fontsize=10, color=\"blue\")\nax.text(A[0] + 1, A[1] + 0.2, f\"{35}°\", fontsize=10, color=\"blue\")\nax.text(B[0] - 2, B[1] + 0.2, f\"{50}°\", fontsize=10, color=\"blue\")\nax.text(B[0] - 0.5, B[1] + 1, f\"{70}°\", fontsize=10, color=\"blue\")\n# ax.text(C[0] + arc_radius/2, B[1] + 1, f\"{70}°\", fontsize=12, color='blue')\nax.text(5, -1, \"AB = 10\", fontsize=12, color=\"black\", horizontalalignment=\"center\")\nax.text(\n    (P[0] + Q[0]) / 2,\n    (P[1] + Q[1]) / 2 + 1,\n    \"PQ = ???\",\n    fontsize=12,\n    color=\"black\",\n    horizontalalignment=\"center\",\n)\n\n\n# 図の表示\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 2\n\n\n\n\n\n\n\n\n\n\n\n\nSolution 1: 余弦定理を用いて解く\n\n\n\n\n\n\\(\\angle PAQ = {40}^\\circ\\) と問題分よりわかるので，\\(PA, QA\\) の長さがわかれば余弦定理より \\(PQ\\) が導出できます．\n正弦定理を用いて\n\\[\n\\begin{align}\nPA &= \\frac{AB}{\\sin({55}^\\circ)}\\times \\sin({50}^\\circ)\\\\\nQA &= \\frac{AB}{\\sin({25}^\\circ)}\\times \\sin({120}^\\circ)\n\\end{align}\n\\]\n余弦定理を用いると\n\\[\nPQ^2 = QA^2 + PA^2 - 2(PA)(QA)\\cos({40}^\\circ)\n\\]\nよって，\n\n\nCode\n# set variables\nAB = 10\nangle_APB = np.radians(55)\nangle_AQB = np.radians(25)\nangle_PBA = np.radians(50)\nangle_QBA = np.radians(120)\nangle_PAQ = np.radians(40)\n\n\n# compute PA and QA\nPA = AB / np.sin(angle_APB) * np.sin(angle_PBA)\nQA = AB / np.sin(angle_AQB) * np.sin(angle_QBA)\n\n\n# comnpute PQ using laws of cosines\nPQ = np.sqrt(PA ** 2 + QA **2 - 2 * PA * QA * np.cos(angle_PAQ))\n\nprint(f\"PQ = {PQ:.2f}\")\n\n\nPQ = 14.62\n\n\n\n\n\n\n\n\n\n\n\n\nSolution 2: 座標を用いて解く\n\n\n\n\n\n各点を \\(XY\\) 平明座標に以下のように置き換えます\n\n\\(A\\) = (0, 0)\n\\(B\\) = (0, 10)\n\nこのとき，点 \\(P\\) の座標 \\((P_X, P_Y)\\) は\n\\[\n\\begin{align}\nP_X & = PA \\cdot \\cos({75}^\\circ)\\\\\nP_Y & = PA \\cdot \\sin({75}^\\circ)\n\\end{align}\n\\]\n同様に点 \\(Q\\) の座標 \\((Q_X, Q_Y)\\) は\n\\[\n\\begin{align}\nQ_X & = QA \\cdot \\cos({35}^\\circ)\\\\\nQ_Y & = QA \\cdot \\sin({35}^\\circ)\n\\end{align}\n\\]\nこのとき，長さ \\(PQ\\) は点 \\(P, Q\\) の距離と表せるので\n\\[\n\\begin{align}\nPQ &= \\lVert P - Q \\rVert\\\\\n   &= \\sqrt{(P_X - Q_X)^2 + (P_Y - Q_Y)^2}\\\\\n   &= \\sqrt{(AQ^2 + PA^2 - 2(PA)(QA)(\\cos({35}^\\circ)\\cos({75}^\\circ) + \\sin({35}^\\circ)\\sin({75}^\\circ)))}\n\\end{align}\n\\]\n加法定理より\n\\[\n\\cos (A \\pm B) = \\cos A \\cos B \\mp \\sin A \\sin B\n\\]\nなので\n\\[\n\\cos({35}^\\circ)\\cos({75}^\\circ) + \\sin({35}^\\circ)\\sin({75}^\\circ) = \\cos({40}^\\circ)\n\\]\n従って，\n\\[\nPQ^2 = QA^2 + PA^2 - 2(PA)(QA)\\cos({40}^\\circ)\n\\]"
  },
  {
    "objectID": "posts/2024-12-11-BQ-create-external-table/index.html",
    "href": "posts/2024-12-11-BQ-create-external-table/index.html",
    "title": "Cloud StorageからExternal Tableの作成",
    "section": "",
    "text": "Google Cloud StorageからBigQuery上にExternal tabaleを作成する\nPartition Fieldが定義されたExternal tabaleを作成するための条件を確認する"
  },
  {
    "objectID": "posts/2024-12-11-BQ-create-external-table/index.html#このノートのスコープ",
    "href": "posts/2024-12-11-BQ-create-external-table/index.html#このノートのスコープ",
    "title": "Cloud StorageからExternal Tableの作成",
    "section": "",
    "text": "Google Cloud StorageからBigQuery上にExternal tabaleを作成する\nPartition Fieldが定義されたExternal tabaleを作成するための条件を確認する"
  },
  {
    "objectID": "posts/2024-12-11-BQ-create-external-table/index.html#external-tableとは",
    "href": "posts/2024-12-11-BQ-create-external-table/index.html#external-tableとは",
    "title": "Cloud StorageからExternal Tableの作成",
    "section": "External Tableとは？",
    "text": "External Tableとは？\nBigQueryのExternal Table（外部テーブル）は，BigQuery内にデータをコピーまたはインポートすることなく， 外部データソースに直接アクセスしてクエリを実行できる機能です．\nBigQueryにおけるExternal Tableの利用形式として，permanent tableとtemporary tableの２つがあります．\n\npermanent table: BigQuery dataset内に作成され，外部データソースにリンクされるテーブル\ntemporary table: 外部データソースに対して一時的にクエリを実行する場合に利用されるテーブル\n\n一時的なテスト処理などでtemporary tableを用いることは有用ですが，分析者間でクエリやコードを共有して分析を進める場合はpermanent tableを持ちないと テーブルアクセスを共有できないので，このノートではpermanent tableを主に取り扱います．\n ▶  サポートされているデータストア\n\nBigLake\nCloud Storage\nBigtable\nGoogle Drive\nAmazon S3\nAzure Blob Storage\n\n以上のデータストアがBigQueryからアクセス可能な外部データソースとしてサポートされています\n ▶  Pricing\nBigQueryのPricingは\n\nCompute pricing: クエリの処理にかかる費用\nStorage pricing: データ保存費用\n\nの２つから構成されています．External Tableを用いると，後者の方はCloud Storage換算の費用となるため，一般的には ストレージコストを抑えることができます．ただし，External Tableにアクセスして分析するたびに\n\nQuery cost: クエリ計算処理時間に比例するコスト\nBytes cost: External tableからのデータ読み取りサイズに比例するコスト\n\nが発生します．\n\n📘 Tips \nExternal Tableを用いた分析が一時的なものであるならばExternal Tableを用いたほうが良いと思いますが， 頻繁にBigQueryからアクセスする場合は\n\nPartitioning/Clusteringを用いてアクセスサイズを抑える\nSELECT以下で*を使用せず，分析に用いるカラムを明示的に指定して，スキャンサイズを抑える\n\nという工夫，またはBigQuery native tableとしてデータを保持することを検討したほうが良いと思います．\n\n\nExternal Table use cases\nExternal Tableの特徴として，\n\nBigQuery native tableとしてデータは保持しない\nExternal Tableと紐づく外部ストアの最新データに対して，クエリ処理が走る\n\nがあります．そのため，PoCや営業段階での分析や頻繁にupdateされるデータに対してのオンライン分析といった場面で活用されるケースが多いです．\n\nExample: 営業段階でのアドホック分析 \n\nBtoC向けサービスを展開している企業Aに対して営業をしているとする\nNDAを結んだ後に，企業Aが保有しているデータのサンプルとして２年間分の連携してもらった\nこのデータを用いて簡易的な分析を行い，どのようなインサイトが導けそうか？を次の営業会議で企業Aに伝え説得したい\n\nという場面を考えます．\n ▶  Key Points\n\nわざわざテーブルスキーマを定義する時間はあまりない→早くEDAをやりたい\nサンプルデータなので，プロジェクト受注後に連携されるであろうデータセットよりも情報量が少ない→わざわざテーブルスキーマしても再利用可能性は低い\n\n ▶  External Tableのメリット\n\nテーブルスキーマをわざわざ定義しなくても，BigQueryを用いた大容量のデータに対しての分析が可能\n複数の分析者間でサンプルデータをCloud Storageベースで簡単に共有できる\nPythonなどの言語を用いた分析でも，予めBigQueryで前処理して小さいdatamartを作成し，それに対してEDAが実施できる"
  },
  {
    "objectID": "posts/2024-12-11-BQ-create-external-table/index.html#external-table作成",
    "href": "posts/2024-12-11-BQ-create-external-table/index.html#external-table作成",
    "title": "Cloud StorageからExternal Tableの作成",
    "section": "External Table作成",
    "text": "External Table作成\nここでは，EXTERNAL PARTITION TABLEの作成を目的に\n\ngoogle cloud storageへのupload\nEXTERNAL TABLEの作成\n\nの２段階の流れで説明します．\n ▶  Cloud Storageへのupload\n~/pupupuland_store_posというdirectory以下に，yyyymmdd形式の日付でpartitionされたPARQUET形式のデータがあるとします．\npupupuland_store_pos\n├── partition_dt=2023-09-23\n│   └── purchase_history_2023-09-23.parquet\n├── partition_dt=2023-09-24\n│   └── purchase_history_2023-09-24.parquet\n├── partition_dt=2023-09-25\n│   └── purchase_history_2023-09-25.parquet\n├── partition_dt=2023-09-26\n│   └── purchase_history_2023-09-26.parquet\n├── partition_dt=2023-09-27\n│   └── purchase_history_2023-09-27.parquet\n├── partition_dt=2023-09-28\n│   └── purchase_history_2023-09-28.parquet\n├── partition_dt=2023-09-29\n│   └── purchase_history_2023-09-29.parquet\n└── partition_dt=2023-09-30\n    └── purchase_history_2023-09-30.parquet\nこのディレクトリ構造を保持したまま，gs://project-make-dedede-great-again/というcloud storage bucketに格納したいとします．このとき\ngcloud storage cp -r ~/pupupuland_store_pos/ gs://project-make-dedede-great-again/\n以上で下準備は完了です．\n ▶  External Tableの作成\nGoogle Cloud project pupupuland-businessdata の dedede-holdings dataset以下に先程上げた pupupuland_store_pos tableを作成したいと思います．\nCREATE EXTERNAL TABLE `pupupuland-businessdata.dedede-holdings.pupupuland_store_pos`\nWITH PARTITION COLUMNS (\npartition_dt DATE, -- column order must match the external path\n)\nOPTIONS (\nuris = ['gs://project-make-dedede-great-again/pupupuland_store_pos/*'],\nformat = 'PARQUET',\nhive_partition_uri_prefix = 'gs://project-make-dedede-great-again/pupupuland_store_pos',\nrequire_hive_partition_filter = false);\nPARTITION COLUMNSのフィールドに partition_dtと入力していますが，これは外部ファイルのパスのパターンがgs://project-make-dedede-great-again/pupupuland_store_pos/partition_dt=yyyymmdd/data.parquet であることを前提にしています．そのため，upload時のdirectory構造を\n└── partition_dt=2023-09-30\n    └── purchase_history_20230930.parquet\nという形にしてcloud storageにuploadしたという背景があります．DATETYPEにDATEと指定していますが，/&lt;partition field&gt;=2018-10-18/という構造になっていないと失敗することに注意してください． 他にも INTEGER, STRING, TIMESTAMPが指定できます．TIMESTAMPの場合は，/&lt;partition field&gt;=2018-10-18 16:00:00+00/という構造であることが必要です．\nrequire_hive_partition_filter フィールドはクエリ時にpartition_dtによるWHERE句フィルタリングを強制するか否かの設定フィールドです． デフォルトではfalseとなっており，この場合はフィルタリングしなくてもクエリできることを意味します．"
  },
  {
    "objectID": "posts/2024-12-11-BQ-create-external-table/index.html#references",
    "href": "posts/2024-12-11-BQ-create-external-table/index.html#references",
    "title": "Cloud StorageからExternal Tableの作成",
    "section": "References",
    "text": "References\n\nIntroduction to external tables"
  },
  {
    "objectID": "posts/2025-02-25-law-of-sines/index.html",
    "href": "posts/2025-02-25-law-of-sines/index.html",
    "title": "正弦定理の考え方",
    "section": "",
    "text": "Exercise 1 \n\\(BC = 30, \\angle B = 70^\\circ, \\angle C = 63^\\circ\\) となるような \\(\\triangle ABC\\) が与えられたとします．このとき，長さ \\(AB\\) を求めよ\n\n\n設問の \\(\\triangle ABC\\) を図示すると以下のようになります．\\(B\\) から \\(AC\\) に対して垂線を垂らし，その交点を \\(BH\\) とします．\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport matplotlib.patches as patches\n\ndef plot_triangular(base_length: float, angles: tuple, fig_size=(6,6)):\n    # Given values\n    BC = 30  # Side BC\n    angle_B = np.radians(angles[0])  # Convert degrees to radians\n    angle_C = np.radians(angles[1])  # Convert degrees to radians\n\n    # Calculate angle A\n    angle_A = np.radians(180 - sum(angles))\n\n    # Use Law of Sines to find AB and AC\n    AB = BC * np.sin(angle_B) / np.sin(angle_A)\n    AC = BC * np.sin(angle_C) / np.sin(angle_A)\n\n    # Set points in a 2D coordinate system\n    B = np.array([0, 0])  # Point B at the origin\n    C = np.array([BC, 0])  # Point C on the x-axis\n\n    # Calculate A's coordinates using trigonometry\n    A_x = BC - AC * np.cos(angle_B)  # Projection of AC on x-axis\n    A_y = AC * np.sin(angle_B)  # Height of A\n\n    A = np.array([A_x, A_y])\n\n    # Plot the triangle using ax\n    fig, ax = plt.subplots(figsize = fig_size)\n    ax.plot([A[0], B[0]], [A[1], B[1]], 'ko-')  # Black line with circle markers\n    ax.plot([B[0], C[0]], [B[1], C[1]], 'ko-')  # Black line with circle markers\n    ax.plot([C[0], A[0]], [C[1], A[1]], 'ko-')  # Black line with circle markers\n\n    # Annotate points\n    ax.text(A[0], A[1], '  A', fontsize=12, verticalalignment='bottom')\n    ax.text(B[0], B[1], '  B', fontsize=12, verticalalignment='top', horizontalalignment='right')\n    ax.text(C[0], C[1], '  C', fontsize=12, verticalalignment='top', horizontalalignment='left')\n\n    # Add angles as arcs\n    arc_radius = 5  # Radius for the arcs\n\n    # Angle at B\n    angle_B_arc = patches.Arc(B, arc_radius, arc_radius, angle=0, theta1=0, theta2=np.degrees(angle_B), color='blue')\n    ax.add_patch(angle_B_arc)\n    ax.text(B[0] + arc_radius/2, B[1] + 1, f\"{70}°\", fontsize=12, color='blue')\n\n    # Angle at C\n    angle_C_arc = patches.Arc(C, arc_radius, arc_radius, angle=0, theta1=180 - np.degrees(angle_C), theta2=180, color='red')\n    ax.add_patch(angle_C_arc)\n    ax.text((C[0] - arc_radius/2) - 2, C[1] + 1, f\"{63}°\", fontsize=12, color='red')\n\n    return fig, ax, (A, B, C)\n\n# plot\nfig, ax, coordinates = plot_triangular(30, (70, 63))\n\n# add BH\nslope = -1/((coordinates[2][1] - coordinates[0][1])/(coordinates[2][0] - coordinates[0][0]))\nax.plot((0, 26.5), (0, slope * 26.5))\nax.text(26.5, slope * 26.5, '  H', fontsize=12, verticalalignment='top', horizontalalignment='left')\n\n# add labels\nax.text(15, -2, \"BC = 30\", fontsize=12, color='black', horizontalalignment='center')\nax.axhline(0, color='black',linewidth=0.5)\nax.axvline(0, color='black',linewidth=0.5)\nax.grid(True, linestyle='--', alpha=0.6)\nax.set_xlim(-5, 35)\nax.set_ylim(-5, 42)\nax.set_title(\"Triangle ABC\")\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 1\n\n\n\n\\(\\triangle BCH, \\triangle ABH\\) を考えると，\n\\[\n\\begin{align}\nBH &= \\sin( A) * AB\\\\\nBH &= \\sin( C) * BC\n\\end{align}\n\\]\nこれを整理すると\n\\[\n\\begin{align}\nAB &= \\frac{\\sin(C) * BC}{\\sin A}\\label{eq-law-of-sines-1}\\\\\n   &= \\frac{30 \\cdot \\sin(63^\\circ)}{\\sin(47^\\circ)}\\label{eq-law-of-sines-2}\n\\end{align}\n\\]\n従って，\n\n\nCode\nprint(f\"BC = {30 * np.sin(63/180 * np.pi)/np.sin(47/180 * np.pi):.4f}\")\n\n\nBC = 36.5489\n\n\nと計算されます．\n\n\n\\(\\eqref{eq-law-of-sines-1}\\), \\(\\eqref{eq-law-of-sines-2}\\) を整理すると\n\\[\n\\frac{AB}{\\sin A} = \\frac{BC}{\\sin C}\n\\]\nを得ます．同様の方法で \\(AC\\) を求めて整理すると，\n\\[\n\\frac{AB}{\\sin A}= \\frac{AC}{\\sin B} = \\frac{BC}{\\sin C}\n\\]\nこれは，\\(\\triangle ABC\\) の外接円を考えたとき，その外接円の半径を \\(R\\) としたとき\n\\[\n\\frac{AB}{\\sin A}= \\frac{AC}{\\sin B} = \\frac{BC}{\\sin C} = 2R\n\\]\nという正弦定理へ繋がります．\n ▶  対辺と\\(\\sin\\) の比率が直径 \\(2R\\)に一致する証明\n\n\n\n\n\n\n\nProof\n\n\n\n\n\n\\(\\triangle ABC\\) の外接円について，弧BC以外の円周上の点 \\(P\\) を適当に取ったときに形成される角度 \\(\\angle BPC\\) を弧BCの円周角といいます． 中心角と円周角の関係として，\n\\[\n\\text{中心角} = 2\\times (\\text{円周角})\n\\]\nここから，「同じ弧に対する円周角は等しい」ことがいえます．ここで，\\(CP\\) が外接円の直径となるように \\(P\\) を取ると直径に対する円周角は直角なので \\(\\triangle BCP\\) は直角三角形となります．\\(CP\\) を斜辺，\\(BC\\)を対辺とすると\n\\[\nBC = 2R \\times \\sin(\\angle BPC) = 2R \\times \\sin(A)\n\\]\n従って，\n\\[\n\\frac{BC}{\\sin A} = 2R\n\\]\n従って，\n\\[\n\\frac{AB}{\\sin A}= \\frac{AC}{\\sin B} = \\frac{BC}{\\sin C} = 2R\n\\]\n\n\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# 与えられた条件\nBC = 30  # 辺BC\nangle_B = np.radians(70)  # 角B (ラジアン変換)\nangle_C = np.radians(63)  # 角C (ラジアン変換)\n\n# 角Aを計算\nangle_A = np.radians(180 - (70 + 63))\n\n# 正弦定理を使ってABとACを求める\nAB = BC * np.sin(angle_B) / np.sin(angle_A)\nAC = BC * np.sin(angle_C) / np.sin(angle_A)\n\n# 頂点座標\nB = np.array([0, 0])  # Bを原点に配置\nC = np.array([BC, 0])  # Cをx軸上に配置\nA_x = BC - AC * np.cos(angle_B)  # Aのx座標\nA_y = AC * np.sin(angle_B)  # Aのy座標\nA = np.array([A_x, A_y])\n\n# 垂直二等分線の交点（外心）を求める\ndef circumcenter(A, B, C):\n    D = 2 * (A[0] * (B[1] - C[1]) + B[0] * (C[1] - A[1]) + C[0] * (A[1] - B[1]))\n    Ux = ((A[0]**2 + A[1]**2) * (B[1] - C[1]) + (B[0]**2 + B[1]**2) * (C[1] - A[1]) + (C[0]**2 + C[1]**2) * (A[1] - B[1])) / D\n    Uy = ((A[0]**2 + A[1]**2) * (C[0] - B[0]) + (B[0]**2 + B[1]**2) * (A[0] - C[0]) + (C[0]**2 + C[1]**2) * (B[0] - A[0])) / D\n    return np.array([Ux, Uy])\n\ncircumcenter_point = circumcenter(A, B, C)\nradius = np.linalg.norm(A - circumcenter_point)  # 外接円の半径\n\n# 円周上の点P（円周角を示す）\ntheta_P = np.radians(120)  # 任意の角度 (120°)\nP_x = circumcenter_point[0] + radius * np.cos(theta_P)\nP_y = circumcenter_point[1] + radius * np.sin(theta_P)\nP = np.array([0, 30/np.sin(angle_A) * np.sin(np.pi/2 - angle_A)])\n\n# 図を作成\nfig, ax = plt.subplots(figsize=(6,6))\n\n# 三角形ABCをプロット\nax.plot([A[0], B[0]], [A[1], B[1]], 'bo-', label=\"AB\")\nax.plot([B[0], C[0]], [B[1], C[1]], 'ro-', label=\"BC\")\nax.plot([C[0], A[0]], [C[1], A[1]], 'go-', label=\"CA\")\n\n# 外接円をプロット\ncircle = plt.Circle(circumcenter_point, radius, color='cyan', fill=False, linestyle='dashed', label=\"Circumcircle\")\nax.add_patch(circle)\n\n# 円周角を示す点Pと三角形BPC\nax.plot([B[0], P[0]], [B[1], P[1]], 'purple', linestyle='dotted', label=\"BP\")\nax.plot([C[0], P[0]], [C[1], P[1]], 'purple', linestyle='dotted', label=\"CP\")\n\n# 点のラベル\nax.text(A[0], A[1], '  A', fontsize=12, verticalalignment='bottom')\nax.text(B[0], B[1], '  B', fontsize=12, verticalalignment='top', horizontalalignment='right')\nax.text(C[0], C[1], '  C', fontsize=12, verticalalignment='top', horizontalalignment='left')\nax.text(P[0], P[1], '  P', fontsize=12, verticalalignment='bottom', horizontalalignment='right', color='purple')\nax.scatter(circumcenter_point[0], circumcenter_point[1], color='black')  # 外心O\n\n# グリッドと範囲設定\nax.axhline(0, color='black', linewidth=0.5)\nax.axvline(0, color='black', linewidth=0.5)\nax.grid(True, linestyle='--', alpha=0.6)\nax.set_xlim(-radius-5, BC+radius+5)\nax.set_ylim(-radius-5, radius+AC+5)\nax.legend()\nax.set_title(\"Triangle ABC with Circumcircle and Inscribed Angle\")\n\n# 図を表示\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 2\n\n\n\n\n\n\n\n\nExercise 2 \nとある山へハイキングにいくとします．\n\n山頂をC\n山の麓のA地点から同じ標高で直線距離で1000m離れている地点をB\nA地点からCを見たときの仰角は \\(30^\\circ\\)\n\\(\\triangle ABC\\) について，\\(\\angle CAB = 75^\\circ, \\angle ABC = 45^\\circ\\)\n\nということがわかっているとします．このとき，Cの標高を求めよ．なお，\\(A, B\\) の標高は 0m とする．\n\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.mplot3d.art3d import Poly3DCollection\n\n# Given angles and side lengths\nangle_A = np.radians(75)\nangle_B = np.radians(45)\nAB = 1000  # Given\n\n# Compute angle C\nangle_C = np.radians(180 - 75 - 45)  # C = 60 degrees\n\n# Compute sides using the Law of Sines\nBC = AB * np.sin(angle_A) / np.sin(angle_C)\nAC = AB * np.sin(angle_B) / np.sin(angle_C)\n\n# Compute coordinates of A, B, and C\nA = np.array([0, 0, 0])  # A is the origin\nB = np.array([AB, 0, 0])  # B is along the x-axis\nC_x = 0  # Projection of AC on x-axis\nC_y = AC * np.cos(np.radians(30))\nC_z = AC * np.sin(np.radians(30))  # Projection on y-axis\nC = np.array([0, C_y, C_z])  # C remains in the XY plane\n\n# Triangle ACH: Given CAH = 30°, CHA = 90° (Right Triangle)\nangle_CAH = np.radians(30)\n\n# H's coordinates (directly above C in the Z direction)\nH = np.array([0, C_y, 0])\n\n# Create 3D plot\nfig = plt.figure(figsize=(8, 8))\nax = fig.add_subplot(111, projection='3d')\n\n# Plot edges of tetrahedron\nedges = [\n    (A, B), (B, C), (C, A),  # Triangle ABC\n    (A, H), (C, H), (B, H)   # Connecting H to A, C, and B\n]\n\nfor edge in edges:\n    ax.plot(*zip(*edge), 'k-')\n\n# Define faces for tetrahedron visualization\nfaces = [\n    [A, B, C],  # Base ABC\n    [A, C, H],  # Side ACH\n    [C, B, H],  # Side CBH\n    [A, H, B]   # Side AHB\n]\n\n# Add face shading\nax.add_collection3d(Poly3DCollection(faces, alpha=0.3, color='cyan'))\n\n# Annotate points\nax.text(*A, \" A\", color='black', fontsize=12)\nax.text(*B, \" B\", color='black', fontsize=12)\nax.text(*C, \" C\", color='black', fontsize=12)\nax.text(*H, \" H\", color='black', fontsize=12)\n\n# Labels and grid\nax.set_xlabel(\"X-axis\")\nax.set_ylabel(\"Y-axis\")\nax.set_zlabel(\"Z-axis\")\nax.set_title(\"3D Tetrahedron CAHB\")\nax.grid(True)\n\nax.view_init(elev=20, azim=-55) \n\n# Show the plot\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 3\n\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n上の図のようにCから\\(XY\\)平面に垂線を下ろして，XY平面との交点を \\(H\\) としたとき，今回求めたい長さは \\(CH\\)．\n問題文の情報を用いて正弦定理を利用すると\n\\[\n\\displaystyle AC = \\frac{AB}{\\sin (\\angle ACB)} \\cdot \\sin(\\angle ABC)\n\\]\nここで\n\\[\n\\begin{align}\nCH &= AC \\cdot \\sin(\\angle CAH)\\\\\n    &= \\frac{AB}{\\sin (\\angle ACB)} \\cdot \\sin(\\angle ABC) \\cdot \\sin(\\angle CAH)\n\\end{align}\n\\]\n従って，\n\n\nCode\nprint(f\"CH = {C_z:.2f}\")\n\n\nCH = 408.25"
  },
  {
    "objectID": "posts/2025-02-25-law-of-sines/index.html#正弦定理の考え方",
    "href": "posts/2025-02-25-law-of-sines/index.html#正弦定理の考え方",
    "title": "正弦定理の考え方",
    "section": "",
    "text": "Exercise 1 \n\\(BC = 30, \\angle B = 70^\\circ, \\angle C = 63^\\circ\\) となるような \\(\\triangle ABC\\) が与えられたとします．このとき，長さ \\(AB\\) を求めよ\n\n\n設問の \\(\\triangle ABC\\) を図示すると以下のようになります．\\(B\\) から \\(AC\\) に対して垂線を垂らし，その交点を \\(BH\\) とします．\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport matplotlib.patches as patches\n\ndef plot_triangular(base_length: float, angles: tuple, fig_size=(6,6)):\n    # Given values\n    BC = 30  # Side BC\n    angle_B = np.radians(angles[0])  # Convert degrees to radians\n    angle_C = np.radians(angles[1])  # Convert degrees to radians\n\n    # Calculate angle A\n    angle_A = np.radians(180 - sum(angles))\n\n    # Use Law of Sines to find AB and AC\n    AB = BC * np.sin(angle_B) / np.sin(angle_A)\n    AC = BC * np.sin(angle_C) / np.sin(angle_A)\n\n    # Set points in a 2D coordinate system\n    B = np.array([0, 0])  # Point B at the origin\n    C = np.array([BC, 0])  # Point C on the x-axis\n\n    # Calculate A's coordinates using trigonometry\n    A_x = BC - AC * np.cos(angle_B)  # Projection of AC on x-axis\n    A_y = AC * np.sin(angle_B)  # Height of A\n\n    A = np.array([A_x, A_y])\n\n    # Plot the triangle using ax\n    fig, ax = plt.subplots(figsize = fig_size)\n    ax.plot([A[0], B[0]], [A[1], B[1]], 'ko-')  # Black line with circle markers\n    ax.plot([B[0], C[0]], [B[1], C[1]], 'ko-')  # Black line with circle markers\n    ax.plot([C[0], A[0]], [C[1], A[1]], 'ko-')  # Black line with circle markers\n\n    # Annotate points\n    ax.text(A[0], A[1], '  A', fontsize=12, verticalalignment='bottom')\n    ax.text(B[0], B[1], '  B', fontsize=12, verticalalignment='top', horizontalalignment='right')\n    ax.text(C[0], C[1], '  C', fontsize=12, verticalalignment='top', horizontalalignment='left')\n\n    # Add angles as arcs\n    arc_radius = 5  # Radius for the arcs\n\n    # Angle at B\n    angle_B_arc = patches.Arc(B, arc_radius, arc_radius, angle=0, theta1=0, theta2=np.degrees(angle_B), color='blue')\n    ax.add_patch(angle_B_arc)\n    ax.text(B[0] + arc_radius/2, B[1] + 1, f\"{70}°\", fontsize=12, color='blue')\n\n    # Angle at C\n    angle_C_arc = patches.Arc(C, arc_radius, arc_radius, angle=0, theta1=180 - np.degrees(angle_C), theta2=180, color='red')\n    ax.add_patch(angle_C_arc)\n    ax.text((C[0] - arc_radius/2) - 2, C[1] + 1, f\"{63}°\", fontsize=12, color='red')\n\n    return fig, ax, (A, B, C)\n\n# plot\nfig, ax, coordinates = plot_triangular(30, (70, 63))\n\n# add BH\nslope = -1/((coordinates[2][1] - coordinates[0][1])/(coordinates[2][0] - coordinates[0][0]))\nax.plot((0, 26.5), (0, slope * 26.5))\nax.text(26.5, slope * 26.5, '  H', fontsize=12, verticalalignment='top', horizontalalignment='left')\n\n# add labels\nax.text(15, -2, \"BC = 30\", fontsize=12, color='black', horizontalalignment='center')\nax.axhline(0, color='black',linewidth=0.5)\nax.axvline(0, color='black',linewidth=0.5)\nax.grid(True, linestyle='--', alpha=0.6)\nax.set_xlim(-5, 35)\nax.set_ylim(-5, 42)\nax.set_title(\"Triangle ABC\")\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 1\n\n\n\n\\(\\triangle BCH, \\triangle ABH\\) を考えると，\n\\[\n\\begin{align}\nBH &= \\sin( A) * AB\\\\\nBH &= \\sin( C) * BC\n\\end{align}\n\\]\nこれを整理すると\n\\[\n\\begin{align}\nAB &= \\frac{\\sin(C) * BC}{\\sin A}\\label{eq-law-of-sines-1}\\\\\n   &= \\frac{30 \\cdot \\sin(63^\\circ)}{\\sin(47^\\circ)}\\label{eq-law-of-sines-2}\n\\end{align}\n\\]\n従って，\n\n\nCode\nprint(f\"BC = {30 * np.sin(63/180 * np.pi)/np.sin(47/180 * np.pi):.4f}\")\n\n\nBC = 36.5489\n\n\nと計算されます．\n\n\n\\(\\eqref{eq-law-of-sines-1}\\), \\(\\eqref{eq-law-of-sines-2}\\) を整理すると\n\\[\n\\frac{AB}{\\sin A} = \\frac{BC}{\\sin C}\n\\]\nを得ます．同様の方法で \\(AC\\) を求めて整理すると，\n\\[\n\\frac{AB}{\\sin A}= \\frac{AC}{\\sin B} = \\frac{BC}{\\sin C}\n\\]\nこれは，\\(\\triangle ABC\\) の外接円を考えたとき，その外接円の半径を \\(R\\) としたとき\n\\[\n\\frac{AB}{\\sin A}= \\frac{AC}{\\sin B} = \\frac{BC}{\\sin C} = 2R\n\\]\nという正弦定理へ繋がります．\n ▶  対辺と\\(\\sin\\) の比率が直径 \\(2R\\)に一致する証明\n\n\n\n\n\n\n\nProof\n\n\n\n\n\n\\(\\triangle ABC\\) の外接円について，弧BC以外の円周上の点 \\(P\\) を適当に取ったときに形成される角度 \\(\\angle BPC\\) を弧BCの円周角といいます． 中心角と円周角の関係として，\n\\[\n\\text{中心角} = 2\\times (\\text{円周角})\n\\]\nここから，「同じ弧に対する円周角は等しい」ことがいえます．ここで，\\(CP\\) が外接円の直径となるように \\(P\\) を取ると直径に対する円周角は直角なので \\(\\triangle BCP\\) は直角三角形となります．\\(CP\\) を斜辺，\\(BC\\)を対辺とすると\n\\[\nBC = 2R \\times \\sin(\\angle BPC) = 2R \\times \\sin(A)\n\\]\n従って，\n\\[\n\\frac{BC}{\\sin A} = 2R\n\\]\n従って，\n\\[\n\\frac{AB}{\\sin A}= \\frac{AC}{\\sin B} = \\frac{BC}{\\sin C} = 2R\n\\]\n\n\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# 与えられた条件\nBC = 30  # 辺BC\nangle_B = np.radians(70)  # 角B (ラジアン変換)\nangle_C = np.radians(63)  # 角C (ラジアン変換)\n\n# 角Aを計算\nangle_A = np.radians(180 - (70 + 63))\n\n# 正弦定理を使ってABとACを求める\nAB = BC * np.sin(angle_B) / np.sin(angle_A)\nAC = BC * np.sin(angle_C) / np.sin(angle_A)\n\n# 頂点座標\nB = np.array([0, 0])  # Bを原点に配置\nC = np.array([BC, 0])  # Cをx軸上に配置\nA_x = BC - AC * np.cos(angle_B)  # Aのx座標\nA_y = AC * np.sin(angle_B)  # Aのy座標\nA = np.array([A_x, A_y])\n\n# 垂直二等分線の交点（外心）を求める\ndef circumcenter(A, B, C):\n    D = 2 * (A[0] * (B[1] - C[1]) + B[0] * (C[1] - A[1]) + C[0] * (A[1] - B[1]))\n    Ux = ((A[0]**2 + A[1]**2) * (B[1] - C[1]) + (B[0]**2 + B[1]**2) * (C[1] - A[1]) + (C[0]**2 + C[1]**2) * (A[1] - B[1])) / D\n    Uy = ((A[0]**2 + A[1]**2) * (C[0] - B[0]) + (B[0]**2 + B[1]**2) * (A[0] - C[0]) + (C[0]**2 + C[1]**2) * (B[0] - A[0])) / D\n    return np.array([Ux, Uy])\n\ncircumcenter_point = circumcenter(A, B, C)\nradius = np.linalg.norm(A - circumcenter_point)  # 外接円の半径\n\n# 円周上の点P（円周角を示す）\ntheta_P = np.radians(120)  # 任意の角度 (120°)\nP_x = circumcenter_point[0] + radius * np.cos(theta_P)\nP_y = circumcenter_point[1] + radius * np.sin(theta_P)\nP = np.array([0, 30/np.sin(angle_A) * np.sin(np.pi/2 - angle_A)])\n\n# 図を作成\nfig, ax = plt.subplots(figsize=(6,6))\n\n# 三角形ABCをプロット\nax.plot([A[0], B[0]], [A[1], B[1]], 'bo-', label=\"AB\")\nax.plot([B[0], C[0]], [B[1], C[1]], 'ro-', label=\"BC\")\nax.plot([C[0], A[0]], [C[1], A[1]], 'go-', label=\"CA\")\n\n# 外接円をプロット\ncircle = plt.Circle(circumcenter_point, radius, color='cyan', fill=False, linestyle='dashed', label=\"Circumcircle\")\nax.add_patch(circle)\n\n# 円周角を示す点Pと三角形BPC\nax.plot([B[0], P[0]], [B[1], P[1]], 'purple', linestyle='dotted', label=\"BP\")\nax.plot([C[0], P[0]], [C[1], P[1]], 'purple', linestyle='dotted', label=\"CP\")\n\n# 点のラベル\nax.text(A[0], A[1], '  A', fontsize=12, verticalalignment='bottom')\nax.text(B[0], B[1], '  B', fontsize=12, verticalalignment='top', horizontalalignment='right')\nax.text(C[0], C[1], '  C', fontsize=12, verticalalignment='top', horizontalalignment='left')\nax.text(P[0], P[1], '  P', fontsize=12, verticalalignment='bottom', horizontalalignment='right', color='purple')\nax.scatter(circumcenter_point[0], circumcenter_point[1], color='black')  # 外心O\n\n# グリッドと範囲設定\nax.axhline(0, color='black', linewidth=0.5)\nax.axvline(0, color='black', linewidth=0.5)\nax.grid(True, linestyle='--', alpha=0.6)\nax.set_xlim(-radius-5, BC+radius+5)\nax.set_ylim(-radius-5, radius+AC+5)\nax.legend()\nax.set_title(\"Triangle ABC with Circumcircle and Inscribed Angle\")\n\n# 図を表示\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 2\n\n\n\n\n\n\n\n\nExercise 2 \nとある山へハイキングにいくとします．\n\n山頂をC\n山の麓のA地点から同じ標高で直線距離で1000m離れている地点をB\nA地点からCを見たときの仰角は \\(30^\\circ\\)\n\\(\\triangle ABC\\) について，\\(\\angle CAB = 75^\\circ, \\angle ABC = 45^\\circ\\)\n\nということがわかっているとします．このとき，Cの標高を求めよ．なお，\\(A, B\\) の標高は 0m とする．\n\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.mplot3d.art3d import Poly3DCollection\n\n# Given angles and side lengths\nangle_A = np.radians(75)\nangle_B = np.radians(45)\nAB = 1000  # Given\n\n# Compute angle C\nangle_C = np.radians(180 - 75 - 45)  # C = 60 degrees\n\n# Compute sides using the Law of Sines\nBC = AB * np.sin(angle_A) / np.sin(angle_C)\nAC = AB * np.sin(angle_B) / np.sin(angle_C)\n\n# Compute coordinates of A, B, and C\nA = np.array([0, 0, 0])  # A is the origin\nB = np.array([AB, 0, 0])  # B is along the x-axis\nC_x = 0  # Projection of AC on x-axis\nC_y = AC * np.cos(np.radians(30))\nC_z = AC * np.sin(np.radians(30))  # Projection on y-axis\nC = np.array([0, C_y, C_z])  # C remains in the XY plane\n\n# Triangle ACH: Given CAH = 30°, CHA = 90° (Right Triangle)\nangle_CAH = np.radians(30)\n\n# H's coordinates (directly above C in the Z direction)\nH = np.array([0, C_y, 0])\n\n# Create 3D plot\nfig = plt.figure(figsize=(8, 8))\nax = fig.add_subplot(111, projection='3d')\n\n# Plot edges of tetrahedron\nedges = [\n    (A, B), (B, C), (C, A),  # Triangle ABC\n    (A, H), (C, H), (B, H)   # Connecting H to A, C, and B\n]\n\nfor edge in edges:\n    ax.plot(*zip(*edge), 'k-')\n\n# Define faces for tetrahedron visualization\nfaces = [\n    [A, B, C],  # Base ABC\n    [A, C, H],  # Side ACH\n    [C, B, H],  # Side CBH\n    [A, H, B]   # Side AHB\n]\n\n# Add face shading\nax.add_collection3d(Poly3DCollection(faces, alpha=0.3, color='cyan'))\n\n# Annotate points\nax.text(*A, \" A\", color='black', fontsize=12)\nax.text(*B, \" B\", color='black', fontsize=12)\nax.text(*C, \" C\", color='black', fontsize=12)\nax.text(*H, \" H\", color='black', fontsize=12)\n\n# Labels and grid\nax.set_xlabel(\"X-axis\")\nax.set_ylabel(\"Y-axis\")\nax.set_zlabel(\"Z-axis\")\nax.set_title(\"3D Tetrahedron CAHB\")\nax.grid(True)\n\nax.view_init(elev=20, azim=-55) \n\n# Show the plot\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 3\n\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n上の図のようにCから\\(XY\\)平面に垂線を下ろして，XY平面との交点を \\(H\\) としたとき，今回求めたい長さは \\(CH\\)．\n問題文の情報を用いて正弦定理を利用すると\n\\[\n\\displaystyle AC = \\frac{AB}{\\sin (\\angle ACB)} \\cdot \\sin(\\angle ABC)\n\\]\nここで\n\\[\n\\begin{align}\nCH &= AC \\cdot \\sin(\\angle CAH)\\\\\n    &= \\frac{AB}{\\sin (\\angle ACB)} \\cdot \\sin(\\angle ABC) \\cdot \\sin(\\angle CAH)\n\\end{align}\n\\]\n従って，\n\n\nCode\nprint(f\"CH = {C_z:.2f}\")\n\n\nCH = 408.25"
  },
  {
    "objectID": "posts/2025-05-19-roo-code-setup/index.html",
    "href": "posts/2025-05-19-roo-code-setup/index.html",
    "title": "Roo Code環境構築",
    "section": "",
    "text": "項目\n説明\n\n\n\n\nOS\nUbuntu 22.04 LTS\n\n\nセットアップ対象\nRoo Code 3.17\n\n\n主な使用方法\nVSCode + Roo Code"
  },
  {
    "objectID": "posts/2025-05-19-roo-code-setup/index.html#この記事のスコープ",
    "href": "posts/2025-05-19-roo-code-setup/index.html#この記事のスコープ",
    "title": "Roo Code環境構築",
    "section": "",
    "text": "項目\n説明\n\n\n\n\nOS\nUbuntu 22.04 LTS\n\n\nセットアップ対象\nRoo Code 3.17\n\n\n主な使用方法\nVSCode + Roo Code"
  },
  {
    "objectID": "posts/2025-05-19-roo-code-setup/index.html#roo-codeとは",
    "href": "posts/2025-05-19-roo-code-setup/index.html#roo-codeとは",
    "title": "Roo Code環境構築",
    "section": "Roo Codeとは？",
    "text": "Roo Codeとは？\nRoo Codeとは？\n\nRoo Codeとは，VSCode上で動作するコーディングAIアシスタント\nAIを活用してコマンドラインやAPI操作を支援するインターフェースやエージェントであり，ユーザーが設定したLLMサービス自体は外部APIプロバイダーに依拠している\n\n\n\n\n\n\nsequenceDiagram\n    participant User as User\n    participant RooCode as Roo Code (AI Assistant)\n    participant Claude as Claude API\n\n    User-&gt;&gt;RooCode: 「preprocess.pyのunit test&lt;br&gt;をpytestで記載して」\n    RooCode-&gt;&gt;Claude: Calls Claude API\n    Claude-&gt;&gt;RooCode: API Response \n    RooCode-&gt;&gt;User: 「pytestを用いたunit test例はこちらです．&lt;br&gt;pytestコマンドを実行いたしましょうか？」\n\n\n\n\n\n\nRoo Codeでなにができるのか？\n\nモード切替機能を活用することで，コード作成，設計，デバッグなど，タスクに応じたアシストが可能\nVSCode上でCLIコマンドの実行が可能\n\nRoo Code vs GitHub Copilot\n\nRoo Code: より包括的なタスク管理とプロジェクト全体の理解を重視\nGitHub Copilot: リアルタイムのコード補完に特化\n\n\n\n\n\n\n\n\n\n\n特徴\nRoo Code\nGitHub Copilot\n\n\n\n\nタスクの範囲\nコード生成，デバッグ，設計，質問応答など対応可能\n主にコード補完や生成に特化\n\n\nツール連携\nファイル操作，検索，CLIコマンド実行など，VS Code内での高度な操作が可能\n基本的にコード補完に限定\n\n\nモード切り替え\nコード作成，設計，デバッグなど，目的に応じたモード及びカスタマイズが可能\nAsk, Edit, Agentモード切り替えが可能"
  },
  {
    "objectID": "posts/2025-05-19-roo-code-setup/index.html#install-roo-code",
    "href": "posts/2025-05-19-roo-code-setup/index.html#install-roo-code",
    "title": "Roo Code環境構築",
    "section": "Install Roo Code",
    "text": "Install Roo Code\nInstall Roo Code with VSCode\n\n拡張機能からRoo Codeをインストール\nサイドバーのRoo Codeアイコンをクリックし，API keyの設定"
  },
  {
    "objectID": "posts/2025-05-19-roo-code-setup/index.html#getting-startted",
    "href": "posts/2025-05-19-roo-code-setup/index.html#getting-startted",
    "title": "Roo Code環境構築",
    "section": "Getting Startted",
    "text": "Getting Startted\n参照ファイルの追加\n\n@&lt;file-path&gt; or 参照したいファイルをRoo Code message boxまでドラッグして，Shift を押しながら読み込ませる"
  },
  {
    "objectID": "posts/2025-05-19-roo-code-setup/index.html#customization",
    "href": "posts/2025-05-19-roo-code-setup/index.html#customization",
    "title": "Roo Code環境構築",
    "section": "Customization",
    "text": "Customization\n\nMode Customization\n\nPromptアイコンをクリックすることで，Roo Codeの「モード」は以下の機能でカスタマイズすることができます\n設定ファイル: ~/.config/Code/User/globalStorage/rooveterinaryinc.roo-cline/settings/custom_modes.json\n\n\n\n\n\n\n\n\n\n項目\n説明\n\n\n\n\nSlug\nMode unique identifier\n\n\nRole Definition\nモードの目的や専門性を定義例: 「文章の作成，編集，校正に特化したモード。技術文書やクリエイティブな文章の作成をサポートします」\n\n\nTool Groups\nread: ファイルの読み取りや指示の取得edit: ファイルの編集や新規作成command: ファイル管理やコンテンツ処理のためのコマンド実行\n\n\nWhen to Use\nこのモードを選択すべき状況を明確化．Orchestrateモードのときに役に立つ\n\n\nCustom Instructions\nモードの動作に関する追加指示を設定\n\n\n\n\n設定例\n{\n  \"customModes\": [\n    {\n      \"slug\": \"writer-mode\",\n      \"name\": \"📘 Writer Mode\",\n      \"roleDefinition\": \"You are Roo, a technical documentation expert specializing in creating clear, comprehensive documentation for software projects. Your expertise includes:\\nWriting clear, concise technical documentation\\nCreating and maintaining README files, API documentation, and user guides\\nFollowing documentation best practices and style guides\\nUnderstanding code to accurately document its functionality\\nOrganizing documentation in a logical, easily navigable structure\",\n      \"whenToUse\": \"Use this mode for tasks focused on content creation, editing, and refinement. Ideal for writing technical documentation, creative writing, or improving existing text\",\n      \"groups\": [\n        \"read\",\n        \"edit\"\n      ],\n      \"source\": \"global\",\n      \"customInstructions\": \"Focus on creating documentation that is clear, concise, and follows a consistent style. Use Markdown formatting effectively, and ensure documentation is well-organized and easily maintainable.\"\n    }\n  ]\n}\n\n\n\n\n\nMode別API configuration\n\n\n\n\nmode別API Configuration設定\n\nPromptアイコンをクリックすると，API Configuration という項目が確認できます\nAPI Configurationを設定することで，mode毎にどのAPIを使用するのかを設定することができます\n\ncustom_modes.json経由での設定は確認できず\n\n\n左の例では，Writer Modeについて，preprocessという名前のAPIをアサインしています．\n\n\n\n\n.rooignoreの設定\n\n.rooignore ファイルは，Roo ツールやフレームワークで無視するファイルやディレクトリを指定するために使用されます\n基本的な構文は.gitignoreと同じ\n.rooignore ファイルはプロジェクトのルートディレクトリに配置する必要があります\n\n\n\n# 一時ファイルを無視\n*.tmp\n\n# ログファイルを無視\nlogs/\n\n# 特定のファイルを除外\n!keep_this_file.txt\n\n\n.rooignore設定挙動\n.rooignore設定により無視されたファイルについて，操作はブロックされます：\n\nread_file: 無視されたファイルを読み取らない\nwrite_to_file: 無視されたファイルへの書き込みや新規作成を行わない\napply_diff: 無視されたファイルに対して差分を適用しない\nlist_code_definition_names: 無視されたファイルを解析の対象にしない\n\n\n\n\n\nShortcut settings\n\n\n\n\n\n\n\n\nショートカット\n機能説明\n\n\n\n\nctrl+meta+i\nRoo Codeパネルの表示/非表示(Toggle)\n\n\n/\nモード切替メニューの表示\n\n\nctrl + .\nモード切替Toggle\n\n\nalt + insert\ninput modeへ切り替え\n\n\nalt + enter\nAccept Roo Code suggestion\n\n\n\n\nVSCode設定Tips\n{\n    {\n    \"key\": \"ctrl+enter\",\n    \"command\": \"roo.acceptInput\",\n    \"when\": \"rooViewFocused\"\n  },\n}\n\nkey: キーボードショートカットを指\ncommand: \"roo.acceptInput\": Roo CodeのsuggestionをAcceptするコマンド\n\"when\": \"rooViewFocused\": Roo Codeビューがフォーカスされているときのみ\n\nVSCode shortcuts設定例\n\n\nkeybindings.json\n\n  {\n    \"key\": \"ctrl+enter\",\n    \"command\": \"-github.copilot.generate\",\n    \"when\": \"editorTextFocus && github.copilot.activated && !commentEditorFocused && !inInteractiveInput && !interactiveEditorFocused\"\n  },\n  {\n    \"key\": \"ctrl+meta+i\",\n    \"command\": \"workbench.view.extension.roo-cline-ActivityBar\",\n    \"when\": \"!auxiliaryBarVisible && (terminalFocus || editorTextFocus)\"\n  },\n  {\n    \"key\": \"ctrl+meta+i\",\n    \"command\": \"workbench.action.toggleAuxiliaryBar\",\n    \"when\": \"auxiliaryBarVisible\"\n  },\n  {\n    \"key\": \"ctrl+alt+i\",\n    \"command\": \"-workbench.panel.chat\",\n    \"when\": \"workbench.panel.chat.view.copilot.active\"\n  },\n  {\n    \"key\": \"ctrl+alt+b\",\n    \"command\": \"-workbench.action.toggleAuxiliaryBar\"\n  },\n  {\n    \"key\": \"alt+insert\",\n    \"command\": \"roo-cline.focusInput\",\n    \"when\": \"auxiliaryBarVisible\"\n  },\n  {\n    \"key\": \"alt+enter\",\n    \"command\": \"roo.acceptInput\",\n     \"when\": \"auxiliaryBarVisible\"\n  },"
  },
  {
    "objectID": "posts/2025-05-19-roo-code-setup/index.html#appendix-request-strategies",
    "href": "posts/2025-05-19-roo-code-setup/index.html#appendix-request-strategies",
    "title": "Roo Code環境構築",
    "section": "Appendix: Request Strategies",
    "text": "Appendix: Request Strategies\n\n\n\n\n\n\n\n\nStrategy\n実装例\n\n\n\n\nBe specific\nFix the codeではなくFix the bug in calculateTotal のように具体的に記述する\n\n\nProvide context\nファイルやコードの参照には @ Context Mentions を使用する\n\n\nBreak down tasks\n複雑なタスクは小さく管理しやすいステップに分割して提出する\n\n\nInclude exmaples\n特定のフォーマットやスタイルが必要な場合，サンプルコードを提供する\n\n\nFocus on related tasks\n一度に1つの焦点を絞ったリクエストを提出する\n\n\nAvoid Excessive jargon\n明確で分かりやすい言葉を使う，専門用語の使用は意味の明瞭化の範囲内で使用する"
  },
  {
    "objectID": "posts/2025-05-19-roo-code-setup/index.html#references",
    "href": "posts/2025-05-19-roo-code-setup/index.html#references",
    "title": "Roo Code環境構築",
    "section": "References",
    "text": "References\n\nRoo Code Docs"
  },
  {
    "objectID": "posts/2025-02-13-complex-plane/index.html",
    "href": "posts/2025-02-13-complex-plane/index.html",
    "title": "複素平面と複素数による回転",
    "section": "",
    "text": "Key takeways\n\n\n\n\\(z_1, z_2\\in \\mathbb C\\) のとき，\n\\[\n\\begin{align}\nz_1 &= r_1(\\cos\\theta_1 + i\\sin\\theta_1)\\\\\nz_2 &= r_2(\\cos\\theta_2 + i\\sin\\theta_2)\n\\end{align}\n\\]\nとすると，以下が成立する\n\\[\n\\begin{align}\n&z_1z_2 = r_1r_2(\\cos(\\theta_1 + \\theta_2) + i\\sin(\\theta_1 + \\theta_2))\\\\\n&|z_1z_2| = |z_1||z_2|\\\\\n&\\operatorname{arg}(z_1z_2) = \\operatorname{arg}(z_1) + \\operatorname{arg}(z_2)\\\\\n&\\frac{z_1}{z_2} = r_1r_2(\\cos(\\theta_1 - \\theta_2) + i\\sin(\\theta_1 - \\theta_2))\\\\\n&\\left|\\frac{z_1}{z_2}\\right| = \\frac{|z_1|}{|z_2|}\\\\\n&\\operatorname{arg}\\left(\\frac{z_1}{z_2}\\right) = \\operatorname{arg}(z_1) - \\operatorname{arg}(z_2)\n\\end{align}\n\\]"
  },
  {
    "objectID": "posts/2025-02-13-complex-plane/index.html#複素数の性質",
    "href": "posts/2025-02-13-complex-plane/index.html#複素数の性質",
    "title": "複素平面と複素数による回転",
    "section": "複素数の性質",
    "text": "複素数の性質\n\nDef: 複素数と 0 \n複素数 \\(z = a + bi = 0\\) のとき，\\(a = b = 0\\) である．\n\nこの定義より，複素数 \\(z\\) の絶対値 \\(\\vert z \\vert = 0\\) であるならば，\n\\[\n\\begin{align}\n\\vert z \\vert = 0 \\Leftrightarrow (a^2 + b^2) = 0 \\Leftrightarrow a = b = 0 \\Leftrightarrow z = 0\n\\end{align}\n\\]\nであることがわかります．\n\nDef: 共役複素数 \n複素数 \\(z = a + bi\\) に対して，\\(a - bi\\) を \\(z\\) の共役複素数と呼び，\\(\\overline z\\) と表す．\n\n足すと 5 になり，掛けると 7 になる２つの数を考えてみたいと思います．それぞれの数を \\(\\alpha, \\beta\\) とすると解と係数の関係より\n\\[\nx^2 - 5x + 7 =0\n\\]\nという二次方程式の解を求めることで求まります．これをといてみると\n\\[\n\\alpha, \\beta = \\frac{5 \\pm \\sqrt{25 - 28}}{2} = \\frac{5 \\pm \\sqrt{3}i}{2}\n\\]\nという複素解がでてきます．また，共役複素数の定義より\n\\[\n\\overline \\alpha = \\beta\n\\]\nであることがわかります．また，もともとの問題が２つの和が \\(5\\), 積が \\(7\\) を満たす数を求める問題であったとことから\n\\[\n\\begin{gather}\n\\alpha + \\overline\\alpha = 5\\\\\n\\alpha \\overline\\alpha = 7\n\\end{gather}\n\\]\nとなりますが，このように共役複素数は積と和が実数になるという特徴が有ります．\n\n\nTheorem 1 \n複素数 \\(z = a + bi\\) について，\n\\[\nz\\overline z = a^2 + b^2\n\\]\nが成り立つ．\n\n\n\n\n\n\n\n\n\nProof\n\n\n\n\n\n\\[\n\\begin{align}\n(a + bi)(a - bi)\n    &= a^2 - (bi)^2\\\\\n    &= a^2 - b^2i^2\\\\\n    &= a^2 + b^2\n\\end{align}\n\\]\n\n\n\n複素数 \\(z = a + bi\\) について，\\(z\\overline{z} = 1\\) となるような複素数 \\(\\overline{z}\\) を（乗法）逆元と呼ぶとき，\n\\[\n\\frac{z\\overline{z}}{a^2 + b^2} = 1\n\\]\nとなることから，\\(\\displaystyle \\frac{\\overline{z}}{\\vert z \\vert^2} = \\frac{\\overline{z}}{z\\overline{z}} = \\frac{a - bi}{a^2 + b^2}\\) が逆源となることがわかります．\n\n\nTheorem 2 : 共役複素数 \n２つの複素数 \\(z, w\\) に対して，\n\\[\n\\begin{gather}\n\\overline{z + w} = \\overline{z} + \\overline{w} \\label{#eq-complex-1}\\\\\n\\overline{z w} = \\overline{z}\\,\\overline{w} \\label{#eq-complex-2}\n\\end{gather}\n\\]\nが成り立つ．\n\n\n\n\n\n\n\n\n\nProof\n\n\n\n\n\n以下では，\\(z = a + bi, w = c + di\\) とします．\n ▶  \\(\\eqref{#eq-complex-1}\\) の証明\n\\[\n\\begin{align}\n\\overline{z + w}\n    &= \\overline{(a + c) + (b+d)i}\\\\\n    &= (a + c) - (b+d)i\\\\\n    &= (a - bi) + (c - di)\\\\\n    &= \\overline{z} + \\overline{w}\n\\end{align}\n\\]\n ▶  \\(\\eqref{#eq-complex-2}\\) の証明\n\\[\n\\begin{align}\n&zw = (ac - bd) + (ad + bc)i\\\\\n\\Rightarrow & \\overline{zw} = (ac - bd) - (ad + bc)i\n\\end{align}\n\\]\n次に\n\\[\n\\begin{align}\n\\overline{z}\\,\\overline{w}\n    &=  (ac - bd) + (ad + bc)i\n\\end{align}\n\\]\nしたがって，\\(\\eqref{#eq-complex-2}\\) が成り立つ．"
  },
  {
    "objectID": "posts/2025-02-13-complex-plane/index.html#複素平面",
    "href": "posts/2025-02-13-complex-plane/index.html#複素平面",
    "title": "複素平面と複素数による回転",
    "section": "複素平面",
    "text": "複素平面\n複素数 \\(z = a + bi\\) は実部と虚部に着目すると２つの実数の組 \\((a, b)\\) と1:1対応していることがわかります．一方，２つの実数の組 \\((a, b)\\) を与えるということは 実数平面空間の１点と対応することと同じなので，平面上の点全体と複素数の全体は１対１に対応するということがわかります．\nこの対応によって，平面が複素数全体であると考えたものを複素平面またはガウス平面と呼びます．複素平面においては，\\(x\\) 軸を実軸，\\(y\\) 軸を虚軸といいます．\n\n極形式の導入\n複素平面において，複素数 \\(z = a + bi\\) の位置ベクトル \\(\\overrightarrow{OZ}\\) について\n\n\\(r\\): \\(||\\overrightarrow{OZ}||\\)\n\\(\\theta\\) : ベクトル \\(\\overrightarrow{OZ}\\) が実軸となす角\n\nと極座標に対応させて考えると，\\(r = |z|\\) となりますし，また偏角についても\n\\[\n\\theta = \\operatorname{arg} z\n\\]\nと表します．ここから複素数について次のような表し方を得ます\n\\[\nz = r(\\cos\\theta + i\\sin\\theta)\n\\]\nこれを \\(z\\) の極形式といいます．\n\n📘 REMARKS \n複素数 \\(z = a + bi\\) について，複素平面上では\n\n\\(-z = -a - bi\\): 原点に関する対称移動\n\\(\\overline{z} = a - bi\\): 実軸に関する対称移動\n\\(-\\overline{z} = -a + bi\\): 虚軸に関する対称移動\n\n\nCode\nimport matplotlib.pyplot as plt\n\n# 複素数の定義（例として z = 2 + 1i）\na, b = 2, 1\nz = complex(a, b)\n\n# 各変換\nminus_z = -z                # -z\nconj_z = z.conjugate()      # z̄\nminus_conj_z = -conj_z      # -z̄\n\n# 複素数の点とラベル\npoints = {\n    \"z\": z,\n    \"-z\": minus_z,\n    \"z̄\": conj_z,\n    \"-z̄\": minus_conj_z\n}\n\n# プロット\nfig, ax = plt.subplots(figsize=(6,6))\nax.set_facecolor(\"#EFF5F5\")\n\nfor label, point in points.items():\n    ax.plot(point.real, point.imag, 'o', c=\"#4477AA\")\n    ax.text(point.real + 0.1, point.imag + 0.1, label, fontsize=12)\n\ndef draw_arrow(from_point, to_point, color):\n    ax.annotate(\"\",\n                xy=(to_point.real, to_point.imag),\n                xytext=(from_point.real, from_point.imag),\n                arrowprops=dict(arrowstyle=\"-&gt;\", color=color, lw=1.2))\n\ndraw_arrow(0, z, \"#4477AA\")\ndraw_arrow(complex(0, z.imag), z, \"#4477AA\")\ndraw_arrow(complex(0, z.imag), minus_conj_z, \"gray\")\ndraw_arrow(0, minus_z, \"gray\")      # z → -z\ndraw_arrow(complex(z.real, 0), conj_z, \"gray\")\ndraw_arrow(complex(z.real, 0), z, \"#4477AA\")\n\n\n# 軸設定\nax.set_xlim(-2.5, 2.5)\nax.set_ylim(-2.5, 2.5)\nax.axhline(0, color='gray', linewidth=0.5)\nax.axvline(0, color='gray', linewidth=0.5)\nax.set_xlabel('Re')\nax.set_ylabel('Im')\n\nax.set_title('Symmetries of complex numbers')\nax.grid(True, which=\"both\", linestyle=\"--\", linewidth=0.5)\nax.set_aspect(\"equal\", adjustable=\"box\")  # Make axes equal scale\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 1\n\n\n\n\n\n\n複素数の積と回転\n２つの複素数 \\(z, w\\) の積を考えます．\n\\[\n\\begin{align}\n\\vert z \\vert = r_1, \\quad & \\operatorname{arg}z = \\theta_1\\\\\n\\vert w \\vert = r_2, \\quad & \\operatorname{arg}w = \\theta_2\n\\end{align}\n\\]\nとおくと，加法定理を用いて以下のように展開できます\n\\[\n\\begin{align}\nzw\n    &= r_1(\\cos\\theta_1 + i \\sin\\theta_1)r_2(\\cos\\theta_2 + i \\sin\\theta_2)\\\\\n    &= r_1r_2\\{(\\cos\\theta_1\\cos\\theta_2 - \\sin\\theta_1\\sin\\theta_1) + i(\\cos\\theta_1\\sin\\theta_2 + \\cos\\theta_2\\sin\\theta_1)\\}\\\\\n    &= r_1r_2(\\cos(\\theta_1 + \\theta_2) + i\\sin(\\theta_1 + \\theta_2))\n\\end{align}\n\\]\nここから以下のことがわかります\n\\[\n\\begin{gather}\n\\vert zw \\vert  = \\vert z\\vert\\, \\vert w \\vert\\\\\n\\operatorname{arg} zw \\equiv \\operatorname{arg} z + \\operatorname{arg} w \\quad(\\operatorname{mod} 2\\pi)\n\\end{gather}\n\\]\n積 \\(zw\\) の位置ベクトルは，\\(z\\) の位置ベクトルを \\(\\vert w \\vert\\) 倍に拡大し，原点 \\(O\\) のまわりに角 \\(\\operatorname{arg} w\\) だけ回転させたものであると解釈できます．\n\nCode\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# --- Define your complex numbers here ---\nz = 1 + 1j\nw = complex(1, np.sqrt(3))\n# ----------------------------------------\n\n## Calculate the product\nproduct = z * w\n\n# Points and labels for scattering (Origin + z, w, product)\nnums_to_label = {\"z\": z, \"w\": w, \"z*w\": product}\npoints = list(nums_to_label.values())\nreal_parts = [p.real for p in points]\nimag_parts = [p.imag for p in points]\nscatter_labels = [f\"{name} = {num:.2f}\" for name, num in nums_to_label.items()]\n\n\n# Create the plot\nfig, ax = plt.subplots(figsize=(6, 6))\nax.set_facecolor(\"#EFF5F5\")\n# Scatter plot for the points\ncolors = [\"#4477AA\", \"gray\", \"#2E45B8\"]  # Origin, z, w, product\nmarkers = [\"o\", \"o\", \"o\"]\nfor i in range(len(points)):\n    ax.scatter(\n        real_parts[i],\n        imag_parts[i],\n        color=colors[i],\n        marker=markers[i],\n        s=50,\n        label=scatter_labels[i],\n    )\n    # Add arrows from origin\n    ax.annotate(\n        \"\",\n        xy=(real_parts[i], imag_parts[i]),\n        xytext=(0, 0),\n        arrowprops=dict(arrowstyle=\"-&gt;\", color=colors[i]),\n    )\n\n# Add argument text annotations\ntext_offset = 0.15  # Small offset for text position, adjust as needed\nfor name, num in nums_to_label.items():\n    # Calculate argument in degrees\n    arg_rad = np.angle(num)\n    arg_deg = np.degrees(arg_rad)\n\n    # Create text label\n    text_label = f\"arg({name}) = {arg_deg:.1f}°\"  # Format to 1 decimal place\n\n    # Position the text slightly offset from the point\n    # You might need to fine-tune text_x, text_y for better placement\n    text_x = num.real + text_offset * np.cos(\n        arg_rad + np.pi / 8\n    )  # Offset slightly outwards\n    text_y = num.imag + text_offset * np.sin(arg_rad + np.pi / 8)\n\n    ax.text(\n        text_x,\n        text_y,\n        text_label,\n        fontsize=9,\n        color=colors[list(nums_to_label.keys()).index(name)],\n    )  # Use point's color\n\n\n# --- Plot Styling ---\n# Set plot limits to ensure all points and text are visible\nmax_abs_val = max(abs(p) for p in points[1:]) if len(points) &gt; 1 else 1\npadding = max_abs_val * 0.4  # Add padding based on magnitude\nax.set_xlim(min(real_parts) - padding, max(real_parts) + padding)\nax.set_ylim(min(imag_parts) - padding, max(imag_parts) + padding)\n\n# Determine symmetric limits centered at 0\nlim = max(abs(l) for l in ax.get_xlim() + ax.get_ylim())\nax.set_xlim(-2, lim)\nax.set_ylim(-1, lim)\n\n\n# Add grid, labels, and title\nax.grid(True, which=\"both\", linestyle=\"--\", linewidth=0.5)\nax.axhline(y=0, color=\"k\", linewidth=0.8)\nax.axvline(x=0, color=\"k\", linewidth=0.8)\nax.set_xlabel(\"Real Axis\")\nax.set_ylabel(\"Imaginary Axis\")\nax.set_title(\"Complex Numbers z, w, z*w, and their Arguments\")\nax.set_aspect(\"equal\", adjustable=\"box\")  # Make axes equal scale\nax.legend()\n\n# Show the plot\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 2\n\n\n\n ▶  加法定理を用いずに回転を理解する\nここでは加法定理を用いずに大きさが1の複素数 \\(\\cos\\theta + i\\sin\\theta\\) を掛ける操作が複素平面上の \\(\\theta\\) 回転を表すことを確認します．\n\\[\n\\begin{gather}\nz = a + ib\\\\\nw = \\cos\\theta + i\\sin\\theta\n\\end{gather}\n\\]\nの２つの複素数の積は\n\\[\n\\begin{align}\nzw\n    &= (a + ib)(\\cos\\theta + i\\sin\\theta)\\\\\n    &= (a\\cos\\theta - b\\sin\\theta) + i(a\\sin\\theta + b\\cos\\theta )\n\\end{align}\n\\]\n以下の図では \\(z = a + ib\\) として\n\n複素数 \\(z\\) と対応する点２次元実数空間に表した点を \\(P =(a, b)\\)\n\\(P\\) を \\(\\theta\\) 回転させた点を \\(Q\\)\n\\(P\\) を \\(90^\\prime\\) 回転させた点を \\(R  = (-b, a)\\)\n\\(\\overrightarrow{OQ}\\) を \\(\\overrightarrow{OP}\\) に正射影したベクトルを \\(\\overrightarrow{OP^\\prime}\\)\n\nとしています．ベクトルの正射影の考え方より\n\\[\n\\begin{align}\n\\overrightarrow{OP^\\prime} = \\vert OQ \\vert \\cos\\theta \\frac{\\overrightarrow{OP}}{\\vert OP\\vert} = \\cos\\theta \\overrightarrow{OP}\\\\\n\\overrightarrow{P^\\prime Q} = \\vert OQ \\vert \\sin\\theta \\frac{\\overrightarrow{OR}}{\\vert OR\\vert} = \\sin\\theta \\overrightarrow{OR}\n\\end{align}\n\\]\n従って，\n\\[\n\\begin{align}\n\\overrightarrow{OQ}\n    &= \\overrightarrow{OP^\\prime} + \\overrightarrow{P^\\prime Q}\\\\\n    &= \\cos\\theta \\overrightarrow{OP} + \\sin\\theta \\overrightarrow{OR}\n\\end{align}\n\\]\nここで，成分を考えると\n\\[\n\\overrightarrow{OQ} = (a\\cos\\theta - b\\sin\\theta, a\\sin\\theta + b\\cos\\theta)\n\\]\nこれは複素数 \\((a\\cos\\theta - b\\sin\\theta) + i(a\\sin\\theta + b\\cos\\theta )\\) に対応しているので，複素数の積 \\(zw\\) は \\(z\\) を \\(\\operatorname{arg} w\\) だけ回転させた複素平面の点に対応することがわかりました．\n\nCode\nimport matplotlib.patches as patches\nimport cmath\n\nfig, ax = plt.subplots(figsize=(6, 6))\nax.set_facecolor(\"#EFF5F5\")\n\n# Circle parameters\nr = 2  # radius\ntheta = np.linspace(0, 2 * np.pi, 500)\ncircle = r * np.exp(1j * theta)\nax.plot(circle.real, circle.imag, label=f\"|z| = {r}\", color=\"gray\")\n\n## define points\nOP = complex(np.sqrt(3), 1)\nOR = OP * 1j\nO = complex(0, 0)\nOQ = complex(np.cos(np.pi / 3), np.sin(np.pi / 3)) * OP\nOP_2 = np.cos(np.pi / 3) * OP\n\n\n## plots\npoints = [OP, OR, OQ]\nscatter_labels = [\"P\", \"R\", \"Q\"]\n\nax.text(\n    0,\n    -0.15,\n    \"O\",\n    fontsize=10,\n    color=\"black\",\n)\n\n# 直交する2本の線を描画\nfor i in range(len(points)):\n    point = points[i]\n    ax.plot([0, point.real], [0, point.imag], \"k\", linewidth=2)  # OP\n    ax.text(\n        point.real,\n        point.imag + 0.05,\n        scatter_labels[i],\n        fontsize=10,\n        color=\"black\",\n    )\n\n## ad P'Q\nax.plot([OP_2.real, OQ.real], [OP_2.imag, OQ.imag], color=\"gray\", linestyle=\"dotted\")\nax.text(\n    OP_2.real + 0.05,\n    OP_2.imag * 0.8,\n    r\"$P^\\prime$\",\n    fontsize=10,\n    color=\"black\",\n)\n\n\n# 直角記号（小さな四角）を原点付近に描画\n# 直角記号（原点から少しオフセット）\ntheta = cmath.phase(OP)  # 60 degrees\northogonal_theta = theta + np.pi / 2  # 90° 直交\noffset = 0.0\n# 直角マークの位置を作成（60°方向に少し移動 → 90°方向に正方形を描く）\nbase_x = offset * np.cos(theta)\nbase_y = offset * np.sin(theta)\nrect_dx = 0.2 * np.cos(orthogonal_theta)\nrect_dy = 0.2 * np.sin(orthogonal_theta)\n\n# 小さな直角マーク（平行四辺形を回転して表現）\nright_angle = patches.Polygon(\n    [\n        (base_x, base_y),\n        (base_x + rect_dx, base_y + rect_dy),\n        (\n            base_x + rect_dx + 0.2 * np.cos(theta),\n            base_y + rect_dy + 0.2 * np.sin(theta),\n        ),\n        (base_x + 0.2 * np.cos(theta), base_y + 0.2 * np.sin(theta)),\n    ],\n    closed=True,\n    edgecolor=\"black\",\n    facecolor=\"none\",\n)\n\nax.add_patch(right_angle)\narc = patches.Arc(\n    (0, 0),\n    0.8,\n    0.8,\n    angle=np.degrees(cmath.phase(OP)),  # start\n    theta1=0,\n    theta2=np.degrees(cmath.phase(OQ)) - np.degrees(cmath.phase(OP)),\n    color=\"black\",\n)\n\n## add angle theta\ntheta_r = 0.5\nax.text(\n    theta_r * np.cos(np.mean([cmath.phase(OQ), cmath.phase(OP)])),\n    theta_r * np.sin(np.mean([cmath.phase(OQ), cmath.phase(OP)])),\n    r\"$\\theta$\",\n    color=\"black\",\n    fontsize=10,\n)\n\nax.add_patch(arc)\n\n# 軸設定\nax.set_xlim(-2.5, 2.5)\nax.set_ylim(-2.5, 2.5)\nax.set_aspect(\"equal\")\nax.grid(True)\n\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 3\n\n\n\n ▶  複素数の割り算\n２つの複素数 \\(z, w\\) を上と同様に考えます． \\(\\vert w \\vert \\neq 0\\) であるとき，\n\\[\n\\begin{align}\n\\frac{1}{w}\n    &= \\frac{1}{r_2(\\cos \\theta_2 + i\\sin\\theta_2)}\\\\\n    &= \\frac{1}{r_2}(\\cos \\theta_2 - i\\sin\\theta_2)\\\\\n    &= \\frac{1}{r_2}(\\cos (-\\theta_2) + i\\sin(-\\theta_2))\\\\\n\\end{align}\n\\]\nであるので\n\\[\n\\begin{align}\n\\frac{z}{w}\n    &= \\frac{r_1}{r_2}\\{(\\cos\\theta_1\\cos(-\\theta_2) - \\sin\\theta_1\\sin(-\\theta_2)) + i(\\cos\\theta_1\\sin(-\\theta_2 )+ \\sin\\theta_1\\cos(-\\theta_2))\\}\\\\\n    &= \\frac{r_1}{r_2}\\{(\\cos\\theta_1\\cos\\theta_2 + \\sin\\theta_1\\sin\\theta_2) + i(-\\cos\\theta_1\\sin\\theta_2 +  \\sin\\theta_1\\cos\\theta_2)\\}\\\\\n    &= \\frac{r_1}{r_2}(\\cos(\\theta_1 - \\theta_2) + i (\\sin\\theta_1 - \\theta_2))\n\\end{align}\n\\]\nしたがって，\n\\[\n\\begin{gather}\n\\bigg\\vert \\frac{z}{w} \\bigg\\vert  = \\frac{\\vert z\\vert}{\\vert w \\vert}\\\\\n\\operatorname{arg}  \\frac{z}{w}  \\equiv \\operatorname{arg} z - \\operatorname{arg} w \\quad(\\operatorname{mod} 2\\pi)\n\\end{gather}\n\\]\n\n\nTheorem 3 : ド・モアブルの公式 \n正の整数 \\(n\\) に対して，\n\\[\n(\\cos\\theta + i\\sin\\theta)^n = \\cos n\\theta + i\\sin n \\theta\n\\]\nが成り立つ．\n\n\n\n\n\n\n\n\n\nProof\n\n\n\n\n\n数学的帰納法を用いて示す．\\(n = 1\\) のとき成立するのは明らか．\\(n = k\\) のとき，ド・モアブルの公式が成立すると仮定すると\n\\[\n\\begin{align}\n(\\cos\\theta + i\\sin\\theta)^{k+1}\n    &= (\\cos\\theta + i\\sin\\theta)^{k} \\cdot (\\cos\\theta + i\\sin\\theta)\\\\\n    &= (\\cos k\\theta + i\\sin k\\theta)(\\cos\\theta + i\\sin\\theta)\\\\\n    &= (\\cos k\\theta \\cos \\theta - \\sin k\\theta\\sin \\theta) + i(\\cos k\\theta \\sin\\theta + \\sin k\\theta \\cos\\theta)\\\\\n    &= \\cos(k\\theta + \\theta) + i\\sin(k\\theta + \\theta)\\\\\n    &= \\cos(k+1)\\theta + i\\sin(k+1) \\theta\n\\end{align}\n\\]\n従って，\\(k+1\\) のときもド・モアブルの公式が成立することがわかる．\n\n\n\n ▶  1の \\(n\\) 乗根を複素数の範囲で求める\n\\(n\\) 乗すると \\(a\\) になる数を \\(a\\) の \\(n\\) 乗根といいます．ここで1の6乗根を求めてみたいと思います．\n\\(z^6 =1\\) より \\(\\vert z \\vert = 1\\). つまり，\n\\[\nz = \\cos\\theta + i \\sin\\theta\n\\]\nと表すことができます．ド・モアブルの公式より\n\\[\nz^6 = \\cos6\\theta + i \\sin6\\theta = 1\n\\]\nつまり，\n\\[\n\\begin{gather}\n6\\theta \\equiv 0 \\, \\operatorname{mod} 2\\pi\n\\end{gather}\n\\]\n\\(\\displaystyle \\zeta = \\cos\\frac{2\\pi}{6} + i \\sin \\frac{2\\pi}{6}\\) とおくと，\n\\[\n(1, \\zeta, \\zeta^2, \\zeta^3, \\zeta^4, \\zeta^5)\n\\]\nが解となります．これをplotすると以下のよう単位円周を６等分した点になることがわかります．\n\nCode\nzeta = complex(np.cos(2 * np.pi / 6), np.sin(2 * np.pi / 6))\npoints = [zeta ** i for i in range(6)]\nscatter_labels = [1] + [fr'$\\zeta^{i}$' for i in range(1, 6)]\n\n# Create the plot\nfig, ax = plt.subplots(figsize=(6, 6))\nax.set_facecolor(\"#EFF5F5\")\nfor i in range(len(points)):\n    ax.scatter(\n        points[i].real,\n        points[i].imag,\n        s=50,\n        color=\"#4477AA\",\n    )\n\n    ax.text(\n        points[i].real,\n        points[i].imag+0.05,\n        scatter_labels[i],\n        fontsize=9,\n        color='black',\n    )\n\n\n# Circle parameters\nr = 1  # radius\ntheta = np.linspace(0, 2 * np.pi, 500)\ncircle = r * np.exp(1j * theta) \nax.plot(circle.real, circle.imag, label=f'|z| = {r}', color='gray')\n\n# Add grids\nax.grid(True, which=\"both\", linestyle=\"--\", linewidth=0.5)\nax.axhline(y=0, color=\"k\", linewidth=0.8)\nax.axvline(x=0, color=\"k\", linewidth=0.8)\nax.set_xlabel(\"Real Axis\")\nax.set_ylabel(\"Imaginary Axis\")\nax.set_title(\"6th Roots of Unity on the Complex Plane\")\nax.set_aspect(\"equal\", adjustable=\"box\")  # Make axes equal scale\nax.legend()\n\n# Show the plot\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 4\n\n\n\n ▶  \\(\\alpha \\in \\mathbb C\\) の \\(n\\) 乗根\n\\(0\\) 出ない一般の複素数 \\(\\alpha = r(\\cos \\theta + i\\sin\\theta)\\) の \\(n\\) 乗根を求めます．\n\\[\nz^n = r(\\cos \\theta + i\\sin\\theta)\n\\]\nであるためには，ド・モアブルの定理より次の条件を満たすのが必要十分となります．\n\\[\n\\begin{align}\n|z|^n &= r\\\\\nn\\operatorname{arg}(z) &= \\theta  + 2k\\pi\\quad(k = 0, 1, 2, 3, \\cdots)\n\\end{align}\n\\]\n重複を避けるために，\\(k = 0, 1, \\cdots, n-1\\) とすると\n\\[\nz_k = r^{1/n}\\left\\{\\cos\\left(\\frac{\\theta}{n} + \\frac{2\\pi}{n}\\times k\\right) + i\\sin\\left(\\frac{\\theta}{n} + \\frac{2\\pi}{n}\\times k\\right)\\right\\}\n\\]\n ▶  大きさが1の複素数とLie群\n大きさが1の複素数の集合は，複素平面で考えると大きさが1の円周になります．この集合を\n\\[\nS = \\{z \\in \\mathbb C | \\vert z\\vert = 1\\}\n\\]\nと表すことができますが，オイラーの公式を用いると\n\\[\nS = \\{\\exp(i\\theta) \\in \\mathbb C | 0 \\leq \\theta &lt; 2\\pi\\}\n\\]\nと表すことができます．このとき，\\(S\\) の元は積の演算で閉じていることがわかります．つまり，\n\\[\n\\exp(i\\theta_1), \\exp(i\\theta_2) \\in S \\Rightarrow \\exp(i\\theta_1)\\exp(i\\theta_2) \\in S\n\\]\nこの積の演算に関して \\(S\\) は以下が成立するので群となります\n\n結合法則: \\((\\exp(i\\theta_1)\\exp(i\\theta_2))\\exp(i\\theta_3) = \\exp(i\\theta_1)(\\exp(i\\theta_2)\\exp(i\\theta_3)) = \\exp(i(\\theta_1 + \\theta_2 + \\theta_3))\\)\n単位元の存在: \\(\\exp(i\\cdot 0) = 1\\)\n逆元の存在: \\(\\exp(i\\theta)\\) に対して，\\(\\exp(-i\\theta)\\) が逆元として定義できる\n\nこのように，大きさが1である複素数の集合を考えることで，図形的な側面だけでなく，演算が定義された代数的な側面を持つ数学的な対象を考えることができます．\n\n\n\n\n\n\n\n📘 Key Takeaways\n\n\n\n\n\n ▶  複素ベクトル空間\n１次元複素ベクトル空間 \\(\\mathbb{C}\\) について，複素数 \\(z = a + bi, (a, b \\in \\mathbb R)\\) に対して\n\n\\((a, b)\\) を対応させる写像 \\(\\mathbb C\\to \\mathbb R^2\\) は全単射\n任意の \\(w, z \\in \\mathbb C\\) に対して，\\(w + z\\) の実部と虚部の組は \\(\\mathbb R^2\\) に含まれるので，和を保つ\nスカラーとして \\(\\lambda \\in \\mathbb R\\) を考えると，スカラー倍も保つ\n\n以上より，\\(\\mathbb{C}\\) は２次元実ベクトル空間 \\(\\mathbb R^2\\) と同一視できます．同様に \\(n\\)次元複素ベクトル空間 \\(\\mathbb C^n\\)は \\(2n\\)次元実ベクトル空間 \\(\\mathbb R^{2n}\\) とみなすことができます．\n ▶  複素ベクトル空間と実ベクトル空間の違い\n\nベクトル空間として，実数上で考えるのと複素数上で考えるのでは多くの場合大差はない\n一方，固有値や固有ベクトル，内積を考える場合には違いが生じる"
  },
  {
    "objectID": "posts/2025-02-27-how-to-compute-tan75/index.html",
    "href": "posts/2025-02-27-how-to-compute-tan75/index.html",
    "title": "tangent 75°の図形的計算",
    "section": "",
    "text": "Exercise 1 \n\\(\\tan {75}^\\circ\\) を求めよ\n\n\n\n\n\n\n\n\n\n解1: 加法定理を用いる場合\n\n\n\n\n\n\\[\n\\begin{align}\n\\tan {45}^\\circ &= 1\\\\\n\\tan {30}^\\circ &= \\frac{\\sqrt{3}}{3}\n\\end{align}\n\\]\nより，加法定理を用いて\n\\[\n\\begin{align}\n\\tan {75}^\\circ\n    &= \\frac{\\tan{30}^\\circ + \\tan{45}^\\circ}{1 - \\tan{30}^\\circ\\tan{45}^\\circ}\\\\\n    &= \\frac{1 + \\frac{\\sqrt{3}}{3}}{1 - \\frac{\\sqrt{3}}{3}}\\\\\n    &= 2 + \\sqrt{3}\n\\end{align}\n\\]\n\n\n\n\n\n\n\n\n\n\n解2: 平面幾何的に求める場合\n\n\n\n\n\n\\(\\angle A = {30}^\\circ, \\angle B = {90}^\\circ, \\angle C = {60}^\\circ\\) の \\(\\triangle ABC\\) を考えたとき，\\(\\angle A\\) の斜辺 \\(AC\\) を用いて 直角二等辺三角形 \\(\\triangle ACD\\) をまず作成します．\nこの点 \\(D\\) を通るように \\(AB\\) と平行な線を引き，長方形 \\(AEFB\\) を以下のように作成します．\n\nCode\nimport shapely.plotting\nimport matplotlib.pyplot as plt\nfrom shapely.geometry import Polygon\nimport numpy as np\n\nA = (0, 0)\nB = (1, 0)\nC = (1, np.sin(np.radians(30)))\nD = (np.sqrt(2) * np.cos(np.radians(75)), np.sqrt(2) * np.sin(np.radians(75)))\nE = (0, np.sqrt(2) * np.sin(np.radians(75)))\nF = (1, np.sqrt(2) * np.sin(np.radians(75)))\n\npolygon1 = Polygon([A, B, C])\npolygon2 = Polygon([A, C, D])\npolygon3 = Polygon([A, E, D])\npolygon4 = Polygon([C, D, F])\n\nfig, ax = plt.subplots(figsize=(6, 6))\n\nshapely.plotting.plot_polygon(polygon1, ax=ax)\nshapely.plotting.plot_polygon(polygon2, alpha=0.5, facecolor='none', ax=ax)\nshapely.plotting.plot_polygon(polygon3, alpha=0.5, facecolor='red', ax=ax)\nshapely.plotting.plot_polygon(polygon4, ax=ax)\n\n# 軸の範囲を設定\nplt.xlim(-0.1, 1.45)\nplt.ylim(-0.1, 1.45)\n\n# add label\nplt.text(A[0], A[1] - 0.05, 'A')\nplt.text(B[0]+0.02, B[1] - 0.05, 'B')\nplt.text(C[0]+0.02, C[1], 'C')\nplt.text(D[0], D[1] + 0.02, 'D')\nplt.text(E[0], E[1] + 0.02, 'E')\nplt.text(F[0], F[1] + 0.02, 'F')\n\n# Add Angles\nax.text(A[0] + 0.06, A[1], f\"{30}°\", fontsize=10)\nax.text(A[0] + 0.06, A[1] + 0.1, f\"{45}°\", fontsize=10)\nax.text(B[0] - 0.09, B[1], f\"{90}°\", fontsize=10)\nax.text(C[0] - 0.1, C[1], f\"{90}°\", fontsize=10)\nax.text(C[0] - 0.1, C[1] + 0.14, f\"{30}°\", fontsize=10)\nax.text(C[0] - 0.1, C[1] - 0.1, f\"{60}°\", fontsize=10)\n\n# Add length\nax.text(0.5, -0.08, \"$\\sqrt{3}$\", fontsize=12, color=\"black\", horizontalalignment=\"center\")\nax.text(0.5, 0.3, \"2\", fontsize=12, color=\"black\", horizontalalignment=\"center\")\nax.text(0.5, 1.0, \"2\", fontsize=12, color=\"black\", horizontalalignment=\"center\")\nax.text(1.05, 0.2, \"1\", fontsize=12, color=\"black\", horizontalalignment=\"left\")\nax.text(1.05, 1.0, \"$\\sqrt{3}$\", fontsize=12, color=\"black\", horizontalalignment=\"left\")\nax.text((D[0] + F[0])/2, 1.37,  \"1\", fontsize=12, color=\"black\", horizontalalignment=\"center\")\nax.text((D[0] + E[0])/2, 1.37,  \"$\\sqrt{3} - 1$\", fontsize=12, color=\"black\", horizontalalignment=\"center\")\n\n\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 1\n\n\n\nこのとき， \\(\\triangle CFD  \\equiv \\triangle ABC\\) なので\n\n\\(AE = 1 + \\sqrt{3}\\)\n\\(DE = \\sqrt{3} - 1\\)\n\nであることがわかります．\\(\\triangle ACD\\) は直角二等辺三角形なので \\(\\angle ADC = {45}^\\circ\\)．従って，\n\\[\n\\angle ADE = {75}^\\circ\n\\]\nよって，\n\\[\n\\begin{align}\n\\tan{75}^\\circ\n    &= \\frac{1 + \\sqrt{3}}{\\sqrt{3} - 1} \\\\\n    &= \\frac{4 + 2\\sqrt{3}}{2}\\\\\n    &= 2 + \\sqrt{3}\n\\end{align}\n\\]"
  },
  {
    "objectID": "posts/2025-01-28-mathmatical-modelling/index.html",
    "href": "posts/2025-01-28-mathmatical-modelling/index.html",
    "title": "数理モデルの作り方",
    "section": "",
    "text": "モデリングとは，現実の事象を説明するために実施するプロセスです．モデリングを通じて，これまで未知であった自然現象を解明したり，または解明を通じて将来の予測や，モデルに基づく意思決定を行ったりします．\nモデリングの流れとしては，\n\n単純化した仮定をたくさん立てる\n重要な変数が何であるのか明らかにする\n変数間の関係性について何かしらの仮定を考える\n\nこれらのステップを行いながら，現実の問題を数理モデルの問題に置き換えます．その後，適切な手法を用いて，モデルを解きます．解が出てきたならば，\n\nその解を現実の問題の文脈に翻訳し解釈\nモデルの解が現実のデータと一致しているかの妥当性検証\n\nを行いモデルを評価します．もしモデルの妥当性に疑念が認められたならば，仮定や変数の見直しなど定式化をやり直します．もしモデルが現実の事象に対して良い適合を示していたならば，意思決定目的関数に従ってモデル予測に基づく決定を行います．この一連の流れを表したのが (Figure 1) となります．\n\n\n\n\n\n\n\n\nflowchart BT\n    problem_setup[\"1: 解きたい現象の選択\"]\n    assumption[\"2: 仮説 & 仮定立案\"]\n    define_objective[\"3: 数理問題のモデル定式化\"]\n    solve[\"4: 数理問題を解く\"]\n    analysis[\"5: 解の意味を解釈する\"]\n    validation[\"6: モデル妥当性検証\"]\n    decision[\"7: モデルを用いた意思決定\"]\n    \n\n    subgraph problem-framing-phase[\"**phase 1: モデル定式化**\"]\n        direction TB\n        problem_setup --&gt; assumption\n        assumption --&gt; define_objective\n    end\n\n    subgraph analysis-phase[\"**phase 2: モデルを解く**\"]\n        direction LR\n        solve --&gt; analysis\n        analysis --&gt; validation\n    end\n\n    subgraph decision-phase[\"**phase 3: 意思決定**\"]\n        decision\n    end\n\n    analysis-phase --仮定/変数/モデル&lt;br&gt;の見直し--&gt; problem-framing-phase\n    problem-framing-phase ----&gt; analysis-phase\n    analysis-phase ----&gt; decision-phase\n\n\n\n\n\n\n\n\nFigure 1\n\n\n\n注意点として，なにを解きたいか？・知りたいか？がすでに決定されている状況からモデリングへというステップに入ります．なにを解くべきか？は意思決定問題の定式化や文脈に依存します．「解くべきもの・解く価値のあるもの」の議論を実施した上で，モデリングという過程に入ることを意識することが重要です．"
  },
  {
    "objectID": "posts/2025-01-28-mathmatical-modelling/index.html#モデリングのステップ",
    "href": "posts/2025-01-28-mathmatical-modelling/index.html#モデリングのステップ",
    "title": "数理モデルの作り方",
    "section": "",
    "text": "モデリングとは，現実の事象を説明するために実施するプロセスです．モデリングを通じて，これまで未知であった自然現象を解明したり，または解明を通じて将来の予測や，モデルに基づく意思決定を行ったりします．\nモデリングの流れとしては，\n\n単純化した仮定をたくさん立てる\n重要な変数が何であるのか明らかにする\n変数間の関係性について何かしらの仮定を考える\n\nこれらのステップを行いながら，現実の問題を数理モデルの問題に置き換えます．その後，適切な手法を用いて，モデルを解きます．解が出てきたならば，\n\nその解を現実の問題の文脈に翻訳し解釈\nモデルの解が現実のデータと一致しているかの妥当性検証\n\nを行いモデルを評価します．もしモデルの妥当性に疑念が認められたならば，仮定や変数の見直しなど定式化をやり直します．もしモデルが現実の事象に対して良い適合を示していたならば，意思決定目的関数に従ってモデル予測に基づく決定を行います．この一連の流れを表したのが (Figure 1) となります．\n\n\n\n\n\n\n\n\nflowchart BT\n    problem_setup[\"1: 解きたい現象の選択\"]\n    assumption[\"2: 仮説 & 仮定立案\"]\n    define_objective[\"3: 数理問題のモデル定式化\"]\n    solve[\"4: 数理問題を解く\"]\n    analysis[\"5: 解の意味を解釈する\"]\n    validation[\"6: モデル妥当性検証\"]\n    decision[\"7: モデルを用いた意思決定\"]\n    \n\n    subgraph problem-framing-phase[\"**phase 1: モデル定式化**\"]\n        direction TB\n        problem_setup --&gt; assumption\n        assumption --&gt; define_objective\n    end\n\n    subgraph analysis-phase[\"**phase 2: モデルを解く**\"]\n        direction LR\n        solve --&gt; analysis\n        analysis --&gt; validation\n    end\n\n    subgraph decision-phase[\"**phase 3: 意思決定**\"]\n        decision\n    end\n\n    analysis-phase --仮定/変数/モデル&lt;br&gt;の見直し--&gt; problem-framing-phase\n    problem-framing-phase ----&gt; analysis-phase\n    analysis-phase ----&gt; decision-phase\n\n\n\n\n\n\n\n\nFigure 1\n\n\n\n注意点として，なにを解きたいか？・知りたいか？がすでに決定されている状況からモデリングへというステップに入ります．なにを解くべきか？は意思決定問題の定式化や文脈に依存します．「解くべきもの・解く価値のあるもの」の議論を実施した上で，モデリングという過程に入ることを意識することが重要です．"
  }
]